{"sha": "e2780b391980532f784e49e014a81d3962219bc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNzgwYjM5MTk4MDUzMmY3ODRlNDllMDE0YTgxZDM5NjIyMTliYzY=", "commit": {"author": {"name": "Stefan Lankes", "email": "stlankes@users.noreply.github.com", "date": "2020-04-04T14:19:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-04T14:19:40Z"}, "message": "Merge branch 'master' into abi", "tree": {"sha": "64a95f8fed4425004fe3a02b0eff19f192308512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64a95f8fed4425004fe3a02b0eff19f192308512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2780b391980532f784e49e014a81d3962219bc6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeiJd8CRBK7hj4Ov3rIwAAdHIIAG6atqG5NK4mIvugsCLO+XOH\n8BEgDJJiaBnu8/p6o7dNekXZXVRxEGkdIXbUORTv9V/EwA0EgP3Ma9LIvozEmLgh\nMObe/zN3VGYeiuRld1DgRajukuAfaizzccPWhjhQ8rCJN7CixePjghDjCWcMJeZ+\nks/yI8fYBfdBzn0/i5qcoOZZ4OAkRgzXH6cy1jrnXXi0SgsKBLH/4jkDMnOsAy53\n5/qwTi58v/pn+iD3w7lXNt/b+3BJezcd2fNtF9yR1oTSpByvNMa5Uo2TQMNLIdOe\n0UjsKL0q83X0Fgm2U63NvXtVcHPvHCygS4BBzQQvvYyodistnI14ZOBpsS5Jx9Q=\n=OWsp\n-----END PGP SIGNATURE-----\n", "payload": "tree 64a95f8fed4425004fe3a02b0eff19f192308512\nparent aa223304dc130c5ace18d48c53b192b14088862e\nparent 49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd\nauthor Stefan Lankes <stlankes@users.noreply.github.com> 1586009980 +0200\ncommitter GitHub <noreply@github.com> 1586009980 +0200\n\nMerge branch 'master' into abi"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2780b391980532f784e49e014a81d3962219bc6", "html_url": "https://github.com/rust-lang/rust/commit/e2780b391980532f784e49e014a81d3962219bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2780b391980532f784e49e014a81d3962219bc6/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa223304dc130c5ace18d48c53b192b14088862e", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa223304dc130c5ace18d48c53b192b14088862e", "html_url": "https://github.com/rust-lang/rust/commit/aa223304dc130c5ace18d48c53b192b14088862e"}, {"sha": "49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd", "html_url": "https://github.com/rust-lang/rust/commit/49dc2f9f091748beb1a8a9d5b3eb3bbe7362c3bd"}], "stats": {"total": 1254, "additions": 764, "deletions": 490}, "files": [{"sha": "0d3ea0c40a3c046f3618e5b28be1e7a6d0d3b87a", "filename": "Cargo.lock", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -87,12 +87,6 @@ dependencies = [\n  \"scoped_threadpool\",\n ]\n \n-[[package]]\n-name = \"arrayref\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d382e583f07208808f6b1249e60848879ba3543f57c32277bf52d69c2f0f0ee\"\n-\n [[package]]\n name = \"arrayvec\"\n version = \"0.4.7\"\n@@ -187,11 +181,22 @@ dependencies = [\n \n [[package]]\n name = \"block-buffer\"\n-version = \"0.3.3\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b\"\n+dependencies = [\n+ \"block-padding\",\n+ \"byte-tools\",\n+ \"byteorder\",\n+ \"generic-array\",\n+]\n+\n+[[package]]\n+name = \"block-padding\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n+checksum = \"fa79dedbb091f449f1f39e53edf88d5dbe95f895dae6135a8d7b881fb5af73f5\"\n dependencies = [\n- \"arrayref\",\n  \"byte-tools\",\n ]\n \n@@ -240,9 +245,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"byte-tools\"\n-version = \"0.2.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n+checksum = \"e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7\"\n \n [[package]]\n name = \"bytecount\"\n@@ -897,9 +902,9 @@ checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \n [[package]]\n name = \"digest\"\n-version = \"0.7.6\"\n+version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03b072242a8cbaf9c145665af9d250c59af3b958f83ed6824e13533cf76d5b90\"\n+checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n dependencies = [\n  \"generic-array\",\n ]\n@@ -1226,9 +1231,9 @@ dependencies = [\n \n [[package]]\n name = \"generic-array\"\n-version = \"0.9.0\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n+checksum = \"c68f0274ae0e023facc3c97b2e00f076be70e254bc851d972503b328db79b2ec\"\n dependencies = [\n  \"typenum\",\n ]\n@@ -1962,6 +1967,17 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \n+[[package]]\n+name = \"md-5\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a18af3dcaf2b0219366cdb4e2af65a6101457b415c3d1a5c71dd9c2b7c77b9c8\"\n+dependencies = [\n+ \"block-buffer\",\n+ \"digest\",\n+ \"opaque-debug\",\n+]\n+\n [[package]]\n name = \"mdbook\"\n version = \"0.3.5\"\n@@ -2250,6 +2266,12 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n \n+[[package]]\n+name = \"opaque-debug\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c\"\n+\n [[package]]\n name = \"open\"\n version = \"1.2.1\"\n@@ -2467,9 +2489,9 @@ dependencies = [\n \n [[package]]\n name = \"pest_meta\"\n-version = \"2.1.0\"\n+version = \"2.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f5a3492a4ed208ffc247adcdcc7ba2a95be3104f58877d0d02f0df39bf3efb5e\"\n+checksum = \"54be6e404f5317079812fc8f9f5279de376d8856929e21c184ecf6bbd692a11d\"\n dependencies = [\n  \"maplit\",\n  \"pest\",\n@@ -4155,11 +4177,13 @@ dependencies = [\n  \"arena\",\n  \"cfg-if\",\n  \"log\",\n+ \"md-5\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"scoped-tls\",\n  \"serialize\",\n+ \"sha-1\",\n  \"unicode-width\",\n ]\n \n@@ -4535,14 +4559,14 @@ dependencies = [\n \n [[package]]\n name = \"sha-1\"\n-version = \"0.7.0\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51b9d1f3b5de8a167ab06834a7c883bd197f2191e1dda1a22d9ccfeedbf9aded\"\n+checksum = \"f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df\"\n dependencies = [\n  \"block-buffer\",\n- \"byte-tools\",\n  \"digest\",\n  \"fake-simd\",\n+ \"opaque-debug\",\n ]\n \n [[package]]"}, {"sha": "5a7d0655a440aec788bee1d2c6565ed2797c2e00", "filename": "src/doc/unstable-book/src/compiler-flags/src-hash-algorithm.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -0,0 +1,11 @@\n+# `src-hash-algorithm`\n+\n+The tracking issue for this feature is: [#70401](https://github.com/rust-lang/rust/issues/70401).\n+\n+------------------------\n+\n+The `-Z src-hash-algorithm` compiler flag controls which algorithm is used when hashing each source file. The hash is stored in the debug info and can be used by a debugger to verify the source code matches the executable.\n+\n+Supported hash algorithms are: `md5`, and `sha1`. Note that not all hash algorithms are supported by all debug info formats.\n+\n+By default, the compiler chooses the hash algorithm based on the target specification."}, {"sha": "700f25d35bc1dcdb5c5aa8a02f5f583fe0d999b8", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -41,7 +41,7 @@ use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::{Interner, Symbol};\n-use rustc_span::{self, FileName, Span};\n+use rustc_span::{self, FileName, SourceFileHash, Span};\n use rustc_target::abi::{Abi, Align, DiscriminantKind, HasDataLayout, Integer, LayoutOf};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n@@ -751,13 +751,23 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n     metadata\n }\n \n+fn hex_encode(data: &[u8]) -> String {\n+    let mut hex_string = String::with_capacity(data.len() * 2);\n+    for byte in data.iter() {\n+        write!(&mut hex_string, \"{:02x}\", byte).unwrap();\n+    }\n+    hex_string\n+}\n+\n pub fn file_metadata(\n     cx: &CodegenCx<'ll, '_>,\n     file_name: &FileName,\n     defining_crate: CrateNum,\n ) -> &'ll DIFile {\n     debug!(\"file_metadata: file_name: {}, defining_crate: {}\", file_name, defining_crate);\n \n+    let source_file = cx.sess().source_map().get_source_file(file_name);\n+    let hash = source_file.as_ref().map(|f| &f.src_hash);\n     let file_name = Some(file_name.to_string());\n     let directory = if defining_crate == LOCAL_CRATE {\n         Some(cx.sess().working_dir.0.to_string_lossy().to_string())\n@@ -766,17 +776,18 @@ pub fn file_metadata(\n         // independent of the compiler's working directory one way or another.\n         None\n     };\n-    file_metadata_raw(cx, file_name, directory)\n+    file_metadata_raw(cx, file_name, directory, hash)\n }\n \n pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n-    file_metadata_raw(cx, None, None)\n+    file_metadata_raw(cx, None, None, None)\n }\n \n fn file_metadata_raw(\n     cx: &CodegenCx<'ll, '_>,\n     file_name: Option<String>,\n     directory: Option<String>,\n+    hash: Option<&SourceFileHash>,\n ) -> &'ll DIFile {\n     let key = (file_name, directory);\n \n@@ -789,13 +800,27 @@ fn file_metadata_raw(\n             let file_name = file_name.as_deref().unwrap_or(\"<unknown>\");\n             let directory = directory.as_deref().unwrap_or(\"\");\n \n+            let (hash_kind, hash_value) = match hash {\n+                Some(hash) => {\n+                    let kind = match hash.kind {\n+                        rustc_span::SourceFileHashAlgorithm::Md5 => llvm::ChecksumKind::MD5,\n+                        rustc_span::SourceFileHashAlgorithm::Sha1 => llvm::ChecksumKind::SHA1,\n+                    };\n+                    (kind, hex_encode(hash.hash_bytes()))\n+                }\n+                None => (llvm::ChecksumKind::None, String::new()),\n+            };\n+\n             let file_metadata = unsafe {\n                 llvm::LLVMRustDIBuilderCreateFile(\n                     DIB(cx),\n                     file_name.as_ptr().cast(),\n                     file_name.len(),\n                     directory.as_ptr().cast(),\n                     directory.len(),\n+                    hash_kind,\n+                    hash_value.as_ptr().cast(),\n+                    hash_value.len(),\n                 )\n             };\n \n@@ -920,6 +945,9 @@ pub fn compile_unit_metadata(\n             name_in_debuginfo.len(),\n             work_dir.as_ptr().cast(),\n             work_dir.len(),\n+            llvm::ChecksumKind::None,\n+            ptr::null(),\n+            0,\n         );\n \n         let unit_metadata = llvm::LLVMRustDIBuilderCreateCompileUnit("}, {"sha": "aeb34e5c9c95444d065ea9dedc658da315ee4196", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -546,6 +546,15 @@ pub enum ThreadLocalMode {\n     LocalExec,\n }\n \n+/// LLVMRustChecksumKind\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum ChecksumKind {\n+    None,\n+    MD5,\n+    SHA1,\n+}\n+\n extern \"C\" {\n     type Opaque;\n }\n@@ -1640,6 +1649,9 @@ extern \"C\" {\n         FilenameLen: size_t,\n         Directory: *const c_char,\n         DirectoryLen: size_t,\n+        CSKind: ChecksumKind,\n+        Checksum: *const c_char,\n+        ChecksumLen: size_t,\n     ) -> &'a DIFile;\n \n     pub fn LLVMRustDIBuilderCreateSubroutineType("}, {"sha": "02bf1aded3bc367a7d066c2a6bd6cafe55763c31", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -22,7 +22,7 @@ use rustc_session::parse::CrateConfig;\n use rustc_session::CrateDisambiguator;\n use rustc_session::{config, early_error, filesearch, output, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{FileLoader, RealFileLoader, SourceMap};\n+use rustc_span::source_map::{FileLoader, SourceMap};\n use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n use std::env;\n@@ -62,15 +62,13 @@ pub fn create_session(\n     lint_caps: FxHashMap<lint::LintId, lint::Level>,\n     descriptions: Registry,\n ) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>, Lrc<SourceMap>) {\n-    let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let source_map = Lrc::new(SourceMap::with_file_loader(loader, sopts.file_path_mapping()));\n-    let mut sess = session::build_session_with_source_map(\n+    let (mut sess, source_map) = session::build_session_with_source_map(\n         sopts,\n         input_path,\n         descriptions,\n-        source_map.clone(),\n         diagnostic_output,\n         lint_caps,\n+        file_loader,\n     );\n \n     let codegen_backend = get_codegen_backend(&sess);"}, {"sha": "300aac19e51b03af8a075c8670ac0804dd535aa2", "filename": "src/librustc_middle/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_middle%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_middle%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_syntax.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -61,7 +61,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             cnum,\n             // Do not hash the source as it is not encoded\n             src: _,\n-            src_hash,\n+            ref src_hash,\n             external_src: _,\n             start_pos,\n             end_pos: _,"}, {"sha": "9b182333907974f1986a917972ceac97af694667", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1077,48 +1077,42 @@ impl<'tcx> Generics {\n         false\n     }\n \n+    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        if let Some(index) = param_index.checked_sub(self.parent_count) {\n+            &self.params[index]\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n+                .param_at(param_index, tcx)\n+        }\n+    }\n+\n     pub fn region_param(\n         &'tcx self,\n         param: &EarlyBoundRegion,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => param,\n-                _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .region_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => param,\n+            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n         }\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n     pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Type { .. } => param,\n-                _ => bug!(\"expected type parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .type_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Type { .. } => param,\n+            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n         }\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n     pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Const => param,\n-                _ => bug!(\"expected const parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n-                .const_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Const => param,\n+            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n         }\n     }\n }"}, {"sha": "58a03dbe388e65aeafd2af3f5e32171d3ed9f1f5", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -18,9 +18,10 @@ use rustc_feature::UnstableFeatures;\n use rustc_span::edition::{Edition, DEFAULT_EDITION, EDITION_NAME_LIST};\n use rustc_span::source_map::{FileName, FilePathMapping};\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::SourceFileHashAlgorithm;\n \n use rustc_errors::emitter::HumanReadableErrorType;\n-use rustc_errors::{ColorConfig, FatalError, Handler, HandlerFlags};\n+use rustc_errors::{ColorConfig, HandlerFlags};\n \n use std::collections::btree_map::{\n     Iter as BTreeMapIter, Keys as BTreeMapKeysIter, Values as BTreeMapValuesIter,\n@@ -748,25 +749,30 @@ pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateCo\n     user_cfg\n }\n \n-pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n+pub fn build_target_config(opts: &Options, error_format: ErrorOutputType) -> Config {\n     let target = Target::search(&opts.target_triple).unwrap_or_else(|e| {\n-        sp.struct_fatal(&format!(\"Error loading target specification: {}\", e))\n-            .help(\"Use `--print target-list` for a list of built-in targets\")\n-            .emit();\n-        FatalError.raise();\n+        early_error(\n+            error_format,\n+            &format!(\n+                \"Error loading target specification: {}. \\\n+            Use `--print target-list` for a list of built-in targets\",\n+                e\n+            ),\n+        )\n     });\n \n     let ptr_width = match &target.target_pointer_width[..] {\n         \"16\" => 16,\n         \"32\" => 32,\n         \"64\" => 64,\n-        w => sp\n-            .fatal(&format!(\n+        w => early_error(\n+            error_format,\n+            &format!(\n                 \"target specification was invalid: \\\n              unrecognized target-pointer-width {}\",\n                 w\n-            ))\n-            .raise(),\n+            ),\n+        ),\n     };\n \n     Config { target, ptr_width }\n@@ -1971,7 +1977,8 @@ impl PpMode {\n crate mod dep_tracking {\n     use super::{\n         CFGuard, CrateType, DebugInfo, ErrorOutputType, LinkerPluginLto, LtoCli, OptLevel,\n-        OutputTypes, Passes, Sanitizer, SwitchWithOptPath, SymbolManglingVersion,\n+        OutputTypes, Passes, Sanitizer, SourceFileHashAlgorithm, SwitchWithOptPath,\n+        SymbolManglingVersion,\n     };\n     use crate::lint;\n     use crate::utils::NativeLibraryKind;\n@@ -2049,6 +2056,7 @@ crate mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(LinkerPluginLto);\n     impl_dep_tracking_hash_via_hash!(SwitchWithOptPath);\n     impl_dep_tracking_hash_via_hash!(SymbolManglingVersion);\n+    impl_dep_tracking_hash_via_hash!(Option<SourceFileHashAlgorithm>);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);"}, {"sha": "3962e30335db2902bb4d201f1917369f157e6693", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -10,6 +10,7 @@ use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel\n \n use rustc_feature::UnstableFeatures;\n use rustc_span::edition::Edition;\n+use rustc_span::SourceFileHashAlgorithm;\n \n use std::collections::BTreeMap;\n \n@@ -283,12 +284,14 @@ macro_rules! options {\n             Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n         pub const parse_symbol_mangling_version: Option<&str> =\n             Some(\"either `legacy` or `v0` (RFC 2603)\");\n+        pub const parse_src_file_hash: Option<&str> =\n+            Some(\"either `md5`, or `sha1`\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n         use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n-            SymbolManglingVersion, CFGuard};\n+            SymbolManglingVersion, CFGuard, SourceFileHashAlgorithm};\n         use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n         use std::str::FromStr;\n@@ -622,6 +625,14 @@ macro_rules! options {\n             };\n             true\n         }\n+\n+        fn parse_src_file_hash(slot: &mut Option<SourceFileHashAlgorithm>, v: Option<&str>) -> bool {\n+            match v.and_then(|s| SourceFileHashAlgorithm::from_str(s).ok()) {\n+                Some(hash_kind) => *slot = Some(hash_kind),\n+                _ => return false,\n+            }\n+            true\n+        }\n     }\n ) }\n \n@@ -961,4 +972,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"use new LLVM pass manager\"),\n     link_native_libraries: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n         \"Link native libraries in the linker invocation.\"),\n+    src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n+        \"hash algorithm of source files in debug info (`md5`, or `sha1`)\"),\n }"}, {"sha": "1c5d19db49cdc9401184c9f0ae2d282ef2c37dd9", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -20,7 +20,8 @@ use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_span::edition::Edition;\n-use rustc_span::source_map::{self, MultiSpan, Span};\n+use rustc_span::source_map::{self, FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n+use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{PanicStrategy, RelroLevel, Target, TargetTriple};\n \n use std::cell::{self, RefCell};\n@@ -870,16 +871,15 @@ pub fn build_session(\n     local_crate_source_file: Option<PathBuf>,\n     registry: rustc_errors::registry::Registry,\n ) -> Session {\n-    let file_path_mapping = sopts.file_path_mapping();\n-\n     build_session_with_source_map(\n         sopts,\n         local_crate_source_file,\n         registry,\n-        Lrc::new(source_map::SourceMap::new(file_path_mapping)),\n         DiagnosticOutput::Default,\n         Default::default(),\n+        None,\n     )\n+    .0\n }\n \n fn default_emitter(\n@@ -956,10 +956,10 @@ pub fn build_session_with_source_map(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     registry: rustc_errors::registry::Registry,\n-    source_map: Lrc<source_map::SourceMap>,\n     diagnostics_output: DiagnosticOutput,\n-    lint_caps: FxHashMap<lint::LintId, lint::Level>,\n-) -> Session {\n+    driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n+) -> (Session, Lrc<SourceMap>) {\n     // FIXME: This is not general enough to make the warning lint completely override\n     // normal diagnostic warnings, since the warning lint can also be denied and changed\n     // later via the source code.\n@@ -977,23 +977,33 @@ pub fn build_session_with_source_map(\n         DiagnosticOutput::Default => None,\n         DiagnosticOutput::Raw(write) => Some(write),\n     };\n+\n+    let target_cfg = config::build_target_config(&sopts, sopts.error_format);\n+    let host_triple = TargetTriple::from_triple(config::host_triple());\n+    let host = Target::search(&host_triple).unwrap_or_else(|e| {\n+        early_error(sopts.error_format, &format!(\"Error loading host specification: {}\", e))\n+    });\n+\n+    let loader = file_loader.unwrap_or(Box::new(RealFileLoader));\n+    let hash_kind = sopts.debugging_opts.src_hash_algorithm.unwrap_or_else(|| {\n+        if target_cfg.target.options.is_like_msvc {\n+            SourceFileHashAlgorithm::Sha1\n+        } else {\n+            SourceFileHashAlgorithm::Md5\n+        }\n+    });\n+    let source_map = Lrc::new(SourceMap::with_file_loader_and_hash_kind(\n+        loader,\n+        sopts.file_path_mapping(),\n+        hash_kind,\n+    ));\n     let emitter = default_emitter(&sopts, registry, &source_map, write_dest);\n \n-    let diagnostic_handler = rustc_errors::Handler::with_emitter_and_flags(\n+    let span_diagnostic = rustc_errors::Handler::with_emitter_and_flags(\n         emitter,\n         sopts.debugging_opts.diagnostic_handler_flags(can_emit_warnings),\n     );\n \n-    build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map, lint_caps)\n-}\n-\n-fn build_session_(\n-    sopts: config::Options,\n-    local_crate_source_file: Option<PathBuf>,\n-    span_diagnostic: rustc_errors::Handler,\n-    source_map: Lrc<source_map::SourceMap>,\n-    driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n-) -> Session {\n     let self_profiler = if let SwitchWithOptPath::Enabled(ref d) = sopts.debugging_opts.self_profile\n     {\n         let directory =\n@@ -1015,13 +1025,7 @@ fn build_session_(\n         None\n     };\n \n-    let host_triple = TargetTriple::from_triple(config::host_triple());\n-    let host = Target::search(&host_triple).unwrap_or_else(|e| {\n-        span_diagnostic.fatal(&format!(\"Error loading host specification: {}\", e)).raise()\n-    });\n-    let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n-\n-    let parse_sess = ParseSess::with_span_handler(span_diagnostic, source_map);\n+    let parse_sess = ParseSess::with_span_handler(span_diagnostic, source_map.clone());\n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n         None => filesearch::get_or_default_sysroot(),\n@@ -1135,7 +1139,7 @@ fn build_session_(\n \n     validate_commandline_args_with_session_available(&sess);\n \n-    sess\n+    (sess, source_map)\n }\n \n // If it is useful to have a Session available already for validating a"}, {"sha": "1c2721260d69b5f1f7366766613c743a76476147", "filename": "src/librustc_span/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2FCargo.toml?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -19,3 +19,5 @@ scoped-tls = \"1.0\"\n unicode-width = \"0.1.4\"\n cfg-if = \"0.1.2\"\n log = \"0.4\"\n+sha-1 = \"0.8\"\n+md-5 = \"0.8\""}, {"sha": "0d9f3f214fb21afa031497863edd1726a9e085e7", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 77, "deletions": 12, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -47,9 +47,14 @@ use std::borrow::Cow;\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::ops::{Add, Sub};\n use std::path::PathBuf;\n+use std::str::FromStr;\n+\n+use md5::Md5;\n+use sha1::Digest;\n+use sha1::Sha1;\n \n #[cfg(test)]\n mod tests;\n@@ -874,6 +879,70 @@ impl ExternalSource {\n #[derive(Debug)]\n pub struct OffsetOverflowError;\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum SourceFileHashAlgorithm {\n+    Md5,\n+    Sha1,\n+}\n+\n+impl FromStr for SourceFileHashAlgorithm {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<SourceFileHashAlgorithm, ()> {\n+        match s {\n+            \"md5\" => Ok(SourceFileHashAlgorithm::Md5),\n+            \"sha1\" => Ok(SourceFileHashAlgorithm::Sha1),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+rustc_data_structures::impl_stable_hash_via_hash!(SourceFileHashAlgorithm);\n+\n+/// The hash of the on-disk source file used for debug info.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable_Generic)]\n+pub struct SourceFileHash {\n+    pub kind: SourceFileHashAlgorithm,\n+    value: [u8; 20],\n+}\n+\n+impl SourceFileHash {\n+    pub fn new(kind: SourceFileHashAlgorithm, src: &str) -> SourceFileHash {\n+        let mut hash = SourceFileHash { kind, value: Default::default() };\n+        let len = hash.hash_len();\n+        let value = &mut hash.value[..len];\n+        let data = src.as_bytes();\n+        match kind {\n+            SourceFileHashAlgorithm::Md5 => {\n+                value.copy_from_slice(&Md5::digest(data));\n+            }\n+            SourceFileHashAlgorithm::Sha1 => {\n+                value.copy_from_slice(&Sha1::digest(data));\n+            }\n+        }\n+        hash\n+    }\n+\n+    /// Check if the stored hash matches the hash of the string.\n+    pub fn matches(&self, src: &str) -> bool {\n+        Self::new(self.kind, src) == *self\n+    }\n+\n+    /// The bytes of the hash.\n+    pub fn hash_bytes(&self) -> &[u8] {\n+        let len = self.hash_len();\n+        &self.value[..len]\n+    }\n+\n+    fn hash_len(&self) -> usize {\n+        match self.kind {\n+            SourceFileHashAlgorithm::Md5 => 16,\n+            SourceFileHashAlgorithm::Sha1 => 20,\n+        }\n+    }\n+}\n+\n /// A single source in the `SourceMap`.\n #[derive(Clone)]\n pub struct SourceFile {\n@@ -889,7 +958,7 @@ pub struct SourceFile {\n     /// The complete source code.\n     pub src: Option<Lrc<String>>,\n     /// The source code's hash.\n-    pub src_hash: u128,\n+    pub src_hash: SourceFileHash,\n     /// The external source code (used for external crates, which will have a `None`\n     /// value as `self.src`.\n     pub external_src: Lock<ExternalSource>,\n@@ -987,7 +1056,8 @@ impl Decodable for SourceFile {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n-            let src_hash: u128 = d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n+            let src_hash: SourceFileHash =\n+                d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n             let start_pos: BytePos =\n                 d.read_struct_field(\"start_pos\", 3, |d| Decodable::decode(d))?;\n             let end_pos: BytePos = d.read_struct_field(\"end_pos\", 4, |d| Decodable::decode(d))?;\n@@ -1062,14 +1132,12 @@ impl SourceFile {\n         unmapped_path: FileName,\n         mut src: String,\n         start_pos: BytePos,\n+        hash_kind: SourceFileHashAlgorithm,\n     ) -> Self {\n+        // Compute the file hash before any normalization.\n+        let src_hash = SourceFileHash::new(hash_kind, &src);\n         let normalized_pos = normalize_src(&mut src, start_pos);\n \n-        let src_hash = {\n-            let mut hasher: StableHasher = StableHasher::new();\n-            hasher.write(src.as_bytes());\n-            hasher.finish::<u128>()\n-        };\n         let name_hash = {\n             let mut hasher: StableHasher = StableHasher::new();\n             name.hash(&mut hasher);\n@@ -1125,10 +1193,7 @@ impl SourceFile {\n             } = &mut *external_src\n             {\n                 if let Some(src) = src {\n-                    let mut hasher: StableHasher = StableHasher::new();\n-                    hasher.write(src.as_bytes());\n-\n-                    if hasher.finish::<u128>() == self.src_hash {\n+                    if self.src_hash.matches(&src) {\n                         *src_kind = ExternalSourceKind::Present(Lrc::new(src));\n                         return true;\n                     }"}, {"sha": "49e2144b3e38011a74ee4411af56d68530518cb9", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -141,27 +141,31 @@ pub struct SourceMap {\n     // This is used to apply the file path remapping as specified via\n     // `--remap-path-prefix` to all `SourceFile`s allocated within this `SourceMap`.\n     path_mapping: FilePathMapping,\n+\n+    /// The algorithm used for hashing the contents of each source file.\n+    hash_kind: SourceFileHashAlgorithm,\n }\n \n impl SourceMap {\n     pub fn new(path_mapping: FilePathMapping) -> SourceMap {\n-        SourceMap {\n-            used_address_space: AtomicU32::new(0),\n-            files: Default::default(),\n-            file_loader: Box::new(RealFileLoader),\n+        Self::with_file_loader_and_hash_kind(\n+            Box::new(RealFileLoader),\n             path_mapping,\n-        }\n+            SourceFileHashAlgorithm::Md5,\n+        )\n     }\n \n-    pub fn with_file_loader(\n+    pub fn with_file_loader_and_hash_kind(\n         file_loader: Box<dyn FileLoader + Sync + Send>,\n         path_mapping: FilePathMapping,\n+        hash_kind: SourceFileHashAlgorithm,\n     ) -> SourceMap {\n         SourceMap {\n             used_address_space: AtomicU32::new(0),\n             files: Default::default(),\n             file_loader,\n             path_mapping,\n+            hash_kind,\n         }\n     }\n \n@@ -275,6 +279,7 @@ impl SourceMap {\n                     unmapped_path,\n                     src,\n                     Pos::from_usize(start_pos),\n+                    self.hash_kind,\n                 ));\n \n                 let mut files = self.files.borrow_mut();\n@@ -296,7 +301,7 @@ impl SourceMap {\n         &self,\n         filename: FileName,\n         name_was_remapped: bool,\n-        src_hash: u128,\n+        src_hash: SourceFileHash,\n         name_hash: u128,\n         source_len: usize,\n         cnum: CrateNum,"}, {"sha": "b0ff17ad56d7c5dd13cd46500cfffa50cb205e53", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::ItemKind;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n     self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n@@ -864,87 +864,77 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n                 // Only check named `impl Trait` types defined in this crate.\n+                // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n+                // potentially risky wrt associated types in `impl`s.\n                 if generics.parent.is_none() && def_id.is_local() {\n                     let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n-                        let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                        for (subst, param) in substs.iter().zip(&generics.params) {\n-                            match subst.unpack() {\n-                                ty::subst::GenericArgKind::Type(ty) => match ty.kind {\n-                                    ty::Param(..) => {}\n-                                    // Prevent `fn foo() -> Foo<u32>` from being defining.\n-                                    _ => {\n-                                        tcx.sess\n-                                            .struct_span_err(\n-                                                span,\n-                                                \"non-defining opaque type use \\\n-                                                 in defining scope\",\n-                                            )\n-                                            .span_note(\n-                                                tcx.def_span(param.def_id),\n-                                                &format!(\n-                                                    \"used non-generic type {} for \\\n-                                                     generic parameter\",\n-                                                    ty,\n-                                                ),\n-                                            )\n-                                            .emit();\n-                                    }\n-                                },\n+                        let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+                        for (i, &arg) in substs.iter().enumerate() {\n+                            let arg_is_param = match arg.unpack() {\n+                                GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n \n-                                ty::subst::GenericArgKind::Lifetime(region) => {\n-                                    let param_span = tcx.def_span(param.def_id);\n+                                GenericArgKind::Lifetime(region) => {\n                                     if let ty::ReStatic = region {\n                                         tcx.sess\n                                             .struct_span_err(\n                                                 span,\n-                                                \"non-defining opaque type use \\\n-                                                 in defining scope\",\n+                                                \"non-defining opaque type use in defining scope\",\n                                             )\n                                             .span_label(\n-                                                param_span,\n+                                                tcx.def_span(generics.param_at(i, tcx).def_id),\n                                                 \"cannot use static lifetime; use a bound lifetime \\\n                                                  instead or remove the lifetime parameter from the \\\n                                                  opaque type\",\n                                             )\n                                             .emit();\n-                                    } else {\n-                                        seen.entry(region).or_default().push(param_span);\n+                                        continue;\n                                     }\n+\n+                                    true\n                                 }\n \n-                                ty::subst::GenericArgKind::Const(ct) => match ct.val {\n-                                    ty::ConstKind::Param(_) => {}\n-                                    _ => {\n-                                        tcx.sess\n-                                            .struct_span_err(\n-                                                span,\n-                                                \"non-defining opaque type use \\\n-                                                 in defining scope\",\n-                                            )\n-                                            .span_note(\n-                                                tcx.def_span(param.def_id),\n-                                                &format!(\n-                                                    \"used non-generic const {} for \\\n-                                                     generic parameter\",\n-                                                    ty,\n-                                                ),\n-                                            )\n-                                            .emit();\n-                                    }\n-                                },\n-                            } // match subst\n-                        } // for (subst, param)\n-                        for (_, spans) in seen {\n-                            if spans.len() > 1 {\n+                                GenericArgKind::Const(ct) => {\n+                                    matches!(ct.val, ty::ConstKind::Param(_))\n+                                }\n+                            };\n+\n+                            if arg_is_param {\n+                                seen_params.entry(arg).or_default().push(i);\n+                            } else {\n+                                // Prevent `fn foo() -> Foo<u32>` from being defining.\n+                                let opaque_param = generics.param_at(i, tcx);\n+                                tcx.sess\n+                                    .struct_span_err(\n+                                        span,\n+                                        \"non-defining opaque type use in defining scope\",\n+                                    )\n+                                    .span_note(\n+                                        tcx.def_span(opaque_param.def_id),\n+                                        &format!(\n+                                            \"used non-generic {} `{}` for generic parameter\",\n+                                            opaque_param.kind.descr(),\n+                                            arg,\n+                                        ),\n+                                    )\n+                                    .emit();\n+                            }\n+                        } // for (arg, param)\n+\n+                        for (_, indices) in seen_params {\n+                            if indices.len() > 1 {\n+                                let descr = generics.param_at(indices[0], tcx).kind.descr();\n+                                let spans: Vec<_> = indices\n+                                    .into_iter()\n+                                    .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n+                                    .collect();\n                                 tcx.sess\n                                     .struct_span_err(\n                                         span,\n-                                        \"non-defining opaque type use \\\n-                                         in defining scope\",\n+                                        \"non-defining opaque type use in defining scope\",\n                                     )\n-                                    .span_note(spans, \"lifetime used multiple times\")\n+                                    .span_note(spans, &format!(\"{} used multiple times\", descr))\n                                     .emit();\n                             }\n                         }"}, {"sha": "d45c82700689a169d5a257cdda96a1a3f45ac43e", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 39, "deletions": 101, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,7 +7,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_session::parse::feature_err;\n@@ -369,13 +369,8 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     struct ConstraintLocator<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        // (first found type span, actual type, mapping from the opaque type's generic\n-        // parameters to the concrete type's generic parameters)\n-        //\n-        // The mapping is an index for each use site of a generic parameter in the concrete type\n-        //\n-        // The indices index into the generic parameters on the opaque type.\n-        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n+        // (first found type span, actual type)\n+        found: Option<(Span, Ty<'tcx>)>,\n     }\n \n     impl ConstraintLocator<'_> {\n@@ -407,83 +402,51 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n                 // FIXME(oli-obk): trace the actual span from inference to improve errors.\n                 let span = self.tcx.def_span(def_id);\n-                // used to quickly look up the position of a generic parameter\n-                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // Skipping binder is ok, since we only use this to find generic parameters and\n-                // their positions.\n-                for (idx, subst) in substs.iter().enumerate() {\n-                    if let GenericArgKind::Type(ty) = subst.unpack() {\n-                        if let ty::Param(p) = ty.kind {\n-                            if index_map.insert(p, idx).is_some() {\n-                                // There was already an entry for `p`, meaning a generic parameter\n-                                // was used twice.\n-                                self.tcx.sess.span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"defining opaque type use restricts opaque \\\n-                                         type by using the generic parameter `{}` twice\",\n-                                        p,\n-                                    ),\n-                                );\n-                                return;\n-                            }\n-                        } else {\n+\n+                // HACK(eddyb) this check shouldn't be needed, as `wfcheck`\n+                // performs the same checks, in theory, but I've kept it here\n+                // using `delay_span_bug`, just in case `wfcheck` slips up.\n+                let opaque_generics = self.tcx.generics_of(self.def_id);\n+                let mut used_params: FxHashSet<_> = FxHashSet::default();\n+                for (i, arg) in substs.iter().enumerate() {\n+                    let arg_is_param = match arg.unpack() {\n+                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+                        GenericArgKind::Lifetime(lt) => {\n+                            matches!(lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+                        }\n+                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+                    };\n+\n+                    if arg_is_param {\n+                        if !used_params.insert(arg) {\n+                            // There was already an entry for `arg`, meaning a generic parameter\n+                            // was used twice.\n                             self.tcx.sess.delay_span_bug(\n                                 span,\n                                 &format!(\n-                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n-                                    concrete_type, substs,\n+                                    \"defining opaque type use restricts opaque \\\n+                                     type by using the generic parameter `{}` twice\",\n+                                    arg,\n                                 ),\n                             );\n                         }\n-                    }\n-                }\n-                // Compute the index within the opaque type for each generic parameter used in\n-                // the concrete type.\n-                let indices = concrete_type\n-                    .subst(self.tcx, substs)\n-                    .walk()\n-                    .filter_map(|t| match &t.kind {\n-                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                let is_param = |ty: Ty<'_>| match ty.kind {\n-                    ty::Param(_) => true,\n-                    _ => false,\n-                };\n-                let bad_substs: Vec<_> = substs\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, k)| {\n-                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n-                    })\n-                    .filter(|(_, ty)| !is_param(ty))\n-                    .collect();\n-                if !bad_substs.is_empty() {\n-                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n-                    for (i, bad_subst) in bad_substs {\n-                        self.tcx.sess.span_err(\n+                    } else {\n+                        let param = opaque_generics.param_at(i, self.tcx);\n+                        self.tcx.sess.delay_span_bug(\n                             span,\n                             &format!(\n                                 \"defining opaque type use does not fully define opaque type: \\\n-                            generic parameter `{}` is specified as concrete type `{}`\",\n-                                identity_substs.type_at(i),\n-                                bad_subst\n+                                 generic parameter `{}` is specified as concrete {} `{}`\",\n+                                param.name,\n+                                param.kind.descr(),\n+                                arg,\n                             ),\n                         );\n                     }\n-                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n-                    let mut ty = concrete_type.walk().fuse();\n-                    let mut p_ty = prev_ty.walk().fuse();\n-                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n-                        // Type parameters are equal to any other type parameter for the purpose of\n-                        // concrete type equality, as it is possible to obtain the same type just\n-                        // by passing matching parameters to a function.\n-                        (ty::Param(_), ty::Param(_)) => true,\n-                        _ => t == p,\n-                    });\n-                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n+                }\n+\n+                if let Some((prev_span, prev_ty)) = self.found {\n+                    if *concrete_type != prev_ty {\n                         debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n                         // Found different concrete types for the opaque type.\n                         let mut err = self.tcx.sess.struct_span_err(\n@@ -496,34 +459,9 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         );\n                         err.span_note(prev_span, \"previous use here\");\n                         err.emit();\n-                    } else if indices != *prev_indices {\n-                        // Found \"same\" concrete types, but the generic parameter order differs.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type's generic parameters differ from previous defining use\",\n-                        );\n-                        use std::fmt::Write;\n-                        let mut s = String::new();\n-                        write!(s, \"expected [\").unwrap();\n-                        let list = |s: &mut String, indices: &Vec<usize>| {\n-                            let mut indices = indices.iter().cloned();\n-                            if let Some(first) = indices.next() {\n-                                write!(s, \"`{}`\", substs[first]).unwrap();\n-                                for i in indices {\n-                                    write!(s, \", `{}`\", substs[i]).unwrap();\n-                                }\n-                            }\n-                        };\n-                        list(&mut s, prev_indices);\n-                        write!(s, \"], got [\").unwrap();\n-                        list(&mut s, &indices);\n-                        write!(s, \"]\").unwrap();\n-                        err.span_label(span, s);\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n                     }\n                 } else {\n-                    self.found = Some((span, concrete_type, indices));\n+                    self.found = Some((span, concrete_type));\n                 }\n             } else {\n                 debug!(\n@@ -606,7 +544,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n \n     match locator.found {\n-        Some((_, ty, _)) => ty,\n+        Some((_, ty)) => ty,\n         None => {\n             let span = tcx.def_span(def_id);\n             tcx.sess.span_err(span, \"could not find defining uses\");"}, {"sha": "e80d16bb0c7ab83b3c8609cf82d7294ab13a9a56", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -706,6 +706,30 @@ impl<T: Decodable> Decodable for Vec<T> {\n     }\n }\n \n+impl Encodable for [u8; 20] {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))?\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl Decodable for [u8; 20] {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<[u8; 20], D::Error> {\n+        d.read_seq(|d, len| {\n+            assert!(len == 20);\n+            let mut v = [0u8; 20];\n+            for i in 0..len {\n+                v[i] = d.read_seq_elt(i, |d| Decodable::decode(d))?;\n+            }\n+            Ok(v)\n+        })\n+    }\n+}\n+\n impl<'a, T: Encodable> Encodable for Cow<'a, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,"}, {"sha": "958532b8fc4b278fbeb0c2764f056b567e1aa77b", "filename": "src/libstd/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fmod.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -93,9 +93,7 @@ pub unsafe extern \"C\" fn __rust_abort() {\n \n #[cfg(not(test))]\n pub fn init() {\n-    unsafe {\n-        let _ = net::init();\n-    }\n+    let _ = net::init();\n }\n \n #[cfg(not(test))]"}, {"sha": "377c3132c5a32b1476f554af0be335692eb56211", "filename": "src/libstd/sys/hermit/net.rs", "status": "modified", "additions": 155, "deletions": 84, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fnet.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,291 +1,362 @@\n use crate::convert::TryFrom;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n use crate::str;\n+use crate::sys::hermit::abi;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n \n-//// Iinitializes HermitCore's network stack\n-pub unsafe fn init() -> io::Result<()> {\n+/// Checks whether the HermitCore's socket interface has been started already, and\n+/// if not, starts it.\n+pub fn init() -> io::Result<()> {\n+    if abi::network_init() < 0 {\n+        return Err(io::Error::new(ErrorKind::Other, \"Unable to initialize network interface\"));\n+    }\n+\n     Ok(())\n }\n \n-pub struct TcpStream(Void);\n+pub struct TcpStream(abi::Handle);\n \n impl TcpStream {\n-    pub fn connect(_: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n-        unsupported()\n+    pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n+        let addr = addr?;\n+\n+        match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n+            Ok(handle) => Ok(TcpStream(handle)),\n+            _ => {\n+                Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n+            }\n+        }\n     }\n \n-    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n-        unsupported()\n+    pub fn connect_timeout(saddr: &SocketAddr, duration: Duration) -> io::Result<TcpStream> {\n+        match abi::tcpstream::connect(\n+            saddr.ip().to_string().as_bytes(),\n+            saddr.port(),\n+            Some(duration.as_millis() as u64),\n+        ) {\n+            Ok(handle) => Ok(TcpStream(handle)),\n+            _ => {\n+                Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n+            }\n+        }\n     }\n \n-    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n+        abi::tcpstream::set_read_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n-    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n+        abi::tcpstream::set_write_timeout(self.0, duration.map(|d| d.as_millis() as u64))\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        let duration = abi::tcpstream::get_read_timeout(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n+\n+        Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        let duration = abi::tcpstream::get_write_timeout(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n+\n+        Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n-    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        abi::tcpstream::peek(self.0, buf)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n-    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n+        self.read_vectored(&mut [IoSliceMut::new(buffer)])\n     }\n \n-    pub fn read_vectored(&self, _: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read_vectored(&self, ioslice: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        let mut size: usize = 0;\n+\n+        for i in ioslice.iter_mut() {\n+            let mut pos: usize = 0;\n+\n+            while pos < i.len() {\n+                let ret = abi::tcpstream::read(self.0, &mut i[pos..])\n+                    .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n+\n+                if ret == 0 {\n+                    return Ok(size);\n+                } else {\n+                    size += ret;\n+                    pos += ret;\n+                }\n+            }\n+        }\n+\n+        Ok(size)\n     }\n \n-    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn write(&self, buffer: &[u8]) -> io::Result<usize> {\n+        self.write_vectored(&[IoSlice::new(buffer)])\n     }\n \n-    pub fn write_vectored(&self, _: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn write_vectored(&self, ioslice: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let mut size: usize = 0;\n+\n+        for i in ioslice.iter() {\n+            size += abi::tcpstream::write(self.0, i)\n+                .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to write on socket\"))?;\n+        }\n+\n+        Ok(size)\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"peer_addr isn't supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"socket_addr isn't supported\"))\n     }\n \n-    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        abi::tcpstream::shutdown(self.0, how as i32)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n-        match self.0 {}\n+        let handle = abi::tcpstream::duplicate(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to duplicate stream\"))?;\n+\n+        Ok(TcpStream(handle))\n     }\n \n-    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n+        abi::tcpstream::set_nodelay(self.0, mode)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        abi::tcpstream::nodelay(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"nodelay failed\"))\n     }\n \n-    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n+        abi::tcpstream::set_tll(self.0, tll)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        abi::tcpstream::get_tll(self.0)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to get TTL\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"take_error isn't supported\"))\n     }\n \n-    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n+        abi::tcpstream::set_nonblocking(self.0, mode)\n+            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set blocking mode\"))\n+    }\n+}\n+\n+impl Drop for TcpStream {\n+    fn drop(&mut self) {\n+        let _ = abi::tcpstream::close(self.0);\n     }\n }\n \n impl fmt::Debug for TcpStream {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+        Ok(())\n     }\n }\n \n-pub struct TcpListener(Void);\n+pub struct TcpListener(abi::Handle);\n \n impl TcpListener {\n     pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<TcpListener> {\n-        unsupported()\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n }\n \n impl fmt::Debug for TcpListener {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+        Ok(())\n     }\n }\n \n-pub struct UdpSocket(Void);\n+pub struct UdpSocket(abi::Handle);\n \n impl UdpSocket {\n     pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-        unsupported()\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn broadcast(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n \n     pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-        match self.0 {}\n+        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n     }\n }\n \n impl fmt::Debug for UdpSocket {\n     fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+        Ok(())\n     }\n }\n "}, {"sha": "21094b3252089efa43882f23fc125d2698cac530", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -640,6 +640,25 @@ static DICompileUnit::DebugEmissionKind fromRust(LLVMRustDebugEmissionKind Kind)\n   }\n }\n \n+enum class LLVMRustChecksumKind {\n+  None,\n+  MD5,\n+  SHA1,\n+};\n+\n+static Optional<DIFile::ChecksumKind> fromRust(LLVMRustChecksumKind Kind) {\n+  switch (Kind) {\n+  case LLVMRustChecksumKind::None:\n+    return None;\n+  case LLVMRustChecksumKind::MD5:\n+    return DIFile::ChecksumKind::CSK_MD5;\n+  case LLVMRustChecksumKind::SHA1:\n+    return DIFile::ChecksumKind::CSK_SHA1;\n+  default:\n+    report_fatal_error(\"bad ChecksumKind.\");\n+  }\n+}\n+\n extern \"C\" uint32_t LLVMRustDebugMetadataVersion() {\n   return DEBUG_METADATA_VERSION;\n }\n@@ -686,9 +705,15 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFile(\n     LLVMRustDIBuilderRef Builder,\n     const char *Filename, size_t FilenameLen,\n-    const char *Directory, size_t DirectoryLen) {\n+    const char *Directory, size_t DirectoryLen, LLVMRustChecksumKind CSKind,\n+    const char *Checksum, size_t ChecksumLen) {\n+  Optional<DIFile::ChecksumKind> llvmCSKind = fromRust(CSKind);\n+  Optional<DIFile::ChecksumInfo<StringRef>> CSInfo{};\n+  if (llvmCSKind)\n+    CSInfo.emplace(*llvmCSKind, StringRef{Checksum, ChecksumLen});\n   return wrap(Builder->createFile(StringRef(Filename, FilenameLen),\n-                                  StringRef(Directory, DirectoryLen)));\n+                                  StringRef(Directory, DirectoryLen),\n+                                  CSInfo));\n }\n \n extern \"C\" LLVMMetadataRef"}, {"sha": "20475bab0fc923251aad63eabb643ad96c7a529b", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -22,7 +22,7 @@ fn main() {\n }\n \n // Here we check that local debuginfo is mapped correctly.\n-// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd/\")\n+// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd/\"\n \n // And here that debuginfo from other crates are expanded to absolute paths.\n-// CHECK: !DIFile(filename: \"/the/aux-src/remap_path_prefix_aux.rs\", directory: \"\")\n+// CHECK: !DIFile(filename: \"/the/aux-src/remap_path_prefix_aux.rs\", directory: \"\""}, {"sha": "7a9d2ca9b6bbdb67ba8504273c489626ac49a2d6", "filename": "src/test/codegen/remap_path_prefix/xcrate-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fxcrate-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fxcrate-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fxcrate-generic.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -11,4 +11,4 @@ pub fn foo() {\n }\n \n // Here we check that local debuginfo is mapped correctly.\n-// CHECK: !DIFile(filename: \"/the/aux-src/xcrate-generic.rs\", directory: \"\")\n+// CHECK: !DIFile(filename: \"/the/aux-src/xcrate-generic.rs\", directory: \"\""}, {"sha": "64be1127786f104258570bfbb9d408a2fafadeaa", "filename": "src/test/codegen/src-hash-algorithm/src-hash-algorithm-md5.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fsrc-hash-algorithm%2Fsrc-hash-algorithm-md5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fsrc-hash-algorithm%2Fsrc-hash-algorithm-md5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsrc-hash-algorithm%2Fsrc-hash-algorithm-md5.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: -g -Z src-hash-algorithm=md5\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn test() {}\n+// CHECK: checksumkind: CSK_MD5"}, {"sha": "54e07152142ec35b389eedd2b0d439fef37b7e92", "filename": "src/test/codegen/src-hash-algorithm/src-hash-algorithm-sha1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fsrc-hash-algorithm%2Fsrc-hash-algorithm-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fcodegen%2Fsrc-hash-algorithm%2Fsrc-hash-algorithm-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsrc-hash-algorithm%2Fsrc-hash-algorithm-sha1.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -0,0 +1,6 @@\n+// compile-flags: -g -Z src-hash-algorithm=sha1\n+\n+#![crate_type = \"lib\"]\n+\n+pub fn test() {}\n+// CHECK: checksumkind: CSK_SHA1"}, {"sha": "0a4cc9b7fe8be4bf40046a9142bcf805d6537722", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -8,13 +8,12 @@ trait TraitWithAssoc {\n }\n \n type Foo<V> = impl Trait<V>;\n-//~^ ERROR could not find defining uses\n-//~| ERROR the trait bound `T: TraitWithAssoc` is not satisfied\n+//~^ ERROR the trait bound `T: TraitWithAssoc` is not satisfied\n \n trait Trait<U> {}\n \n impl<W> Trait<W> for () {}\n \n-fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> { //~ ERROR does not fully define\n+fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n     ()\n }"}, {"sha": "b871f79aa1dc57e9c1decc7f252ad6d31d8cbab4", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -9,20 +9,6 @@ help: consider further restricting this bound\n LL | fn foo_desugared<T: TraitWithAssoc + TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n    |                                    ^^^^^^^^^^^^^^^^\n \n-error: defining opaque type use does not fully define opaque type: generic parameter `V` is specified as concrete type `<T as TraitWithAssoc>::Assoc`\n-  --> $DIR/bound_reduction2.rs:18:1\n-   |\n-LL | / fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-LL | |     ()\n-LL | | }\n-   | |_^\n-\n-error: could not find defining uses\n-  --> $DIR/bound_reduction2.rs:10:1\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "4503607a836385cfd2072e0a3877b8e64eed2cdb", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,14 +1,26 @@\n-#![feature(type_alias_impl_trait)]\n+#![feature(type_alias_impl_trait, const_generics)]\n+#![allow(incomplete_features)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n // test that unused generic parameters are ok\n-type Two<T, U> = impl Debug;\n-//~^ could not find defining uses\n+type TwoTys<T, U> = impl Debug;\n+type TwoLifetimes<'a, 'b> = impl Debug;\n+type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n \n-fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ ERROR defining opaque type use restricts opaque type\n+fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n+fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    t\n+}\n+\n+fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n+//~^ ERROR non-defining opaque type use in defining scope\n     t\n }"}, {"sha": "b4757e2763d0699d2503f5b0e3ca894fa222a616", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,17 +1,38 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n-  --> $DIR/generic_duplicate_param_use.rs:11:1\n-   |\n-LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n-LL | |\n-LL | |     t\n-LL | | }\n-   | |_^\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use.rs:13:30\n+   |\n+LL | fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n+   |                              ^^^^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use.rs:9:13\n+   |\n+LL | type TwoTys<T, U> = impl Debug;\n+   |             ^  ^\n \n-error: could not find defining uses\n-  --> $DIR/generic_duplicate_param_use.rs:8:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use.rs:18:36\n+   |\n+LL | fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lifetime used multiple times\n+  --> $DIR/generic_duplicate_param_use.rs:10:19\n+   |\n+LL | type TwoLifetimes<'a, 'b> = impl Debug;\n+   |                   ^^  ^^\n+\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use.rs:23:50\n+   |\n+LL | fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n+   |                                                  ^^^^^^^^^^^^^^^\n+   |\n+note: constant used multiple times\n+  --> $DIR/generic_duplicate_param_use.rs:11:22\n    |\n-LL | type Two<T, U> = impl Debug;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n+   |                      ^               ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "2b98d8fc63a1159fd7698160d4d2cfd18263a867", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -8,10 +8,10 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ defining opaque type use restricts opaque type\n     t\n }\n \n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+//~^ ERROR concrete type differs from previous defining opaque type use\n     t\n }"}, {"sha": "8170c671f68cdaee02bf427b9d801ff8f2e90540", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,8 +1,16 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/generic_duplicate_param_use2.rs:14:1\n+   |\n+LL | / fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+LL | |\n+LL | |     t\n+LL | | }\n+   | |_^ expected `U`, got `T`\n+   |\n+note: previous use here\n   --> $DIR/generic_duplicate_param_use2.rs:10:1\n    |\n LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n-LL | |\n LL | |     t\n LL | | }\n    | |_^"}, {"sha": "d9133fd11f7cdac57012607aa729d63ff31ebdad", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -8,15 +8,14 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ defining opaque type use restricts opaque type\n     t\n }\n \n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+//~^ ERROR concrete type differs from previous defining opaque type use\n     t\n }\n \n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n-//~^ concrete type's generic parameters differ from previous defining use\n     u\n }"}, {"sha": "86dd33684005b0bd7f70ab48cee828bd0dcbf661", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,28 +1,19 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n-  --> $DIR/generic_duplicate_param_use3.rs:10:1\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/generic_duplicate_param_use3.rs:14:1\n    |\n-LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n+LL | / fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n LL | |\n LL | |     t\n LL | | }\n-   | |_^\n-\n-error: concrete type's generic parameters differ from previous defining use\n-  --> $DIR/generic_duplicate_param_use3.rs:19:1\n-   |\n-LL | / fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n-LL | |\n-LL | |     u\n-LL | | }\n-   | |_^ expected [`T`], got [`U`]\n+   | |_^ expected `U`, got `T`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use3.rs:15:1\n+  --> $DIR/generic_duplicate_param_use3.rs:10:1\n    |\n-LL | / fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n LL | |     t\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "40388c3b6c88aed1bdcb0939a819422a19fbc4ca", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -8,7 +8,7 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-//~^ ERROR defining opaque type use restricts opaque type\n+//~^ ERROR non-defining opaque type use in defining scope\n     t\n }\n "}, {"sha": "fcf01f5164ae4aa770e52ada1ed7076194640d13", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,11 +1,14 @@\n-error: defining opaque type use restricts opaque type by using the generic parameter `T` twice\n-  --> $DIR/generic_duplicate_param_use4.rs:10:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_duplicate_param_use4.rs:10:27\n    |\n-LL | / fn one<T: Debug>(t: T) -> Two<T, T> {\n-LL | |\n-LL | |     t\n-LL | | }\n-   | |_^\n+LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n+   |                           ^^^^^^^^^\n+   |\n+note: type used multiple times\n+  --> $DIR/generic_duplicate_param_use4.rs:8:10\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |          ^  ^\n \n error: aborting due to previous error\n "}, {"sha": "b1782120f84cc10b3fa900bfda29c762a12fde9c", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,13 +1,27 @@\n-#![feature(type_alias_impl_trait)]\n+#![feature(type_alias_impl_trait, const_generics)]\n+#![allow(incomplete_features)]\n+\n+use std::fmt::Debug;\n \n fn main() {}\n \n-type Cmp<T> = impl 'static;\n-//~^ ERROR could not find defining uses\n-//~^^ ERROR: at least one trait must be specified\n+type OneTy<T> = impl Debug;\n+type OneLifetime<'a> = impl Debug;\n+type OneConst<const X: usize> = impl Debug;\n \n+// Not defining uses, because they doesn't define *all* possible generics.\n \n-// not a defining use, because it doesn't define *all* possible generics\n-fn cmp() -> Cmp<u32> { //~ ERROR defining opaque type use does not fully define\n+fn concrete_ty() -> OneTy<u32> {\n+//~^ ERROR non-defining opaque type use in defining scope\n     5u32\n }\n+\n+fn concrete_lifetime() -> OneLifetime<'static> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    6u32\n+}\n+\n+fn concrete_const() -> OneConst<{123}> {\n+//~^ ERROR non-defining opaque type use in defining scope\n+    7u32\n+}"}, {"sha": "b0ffc4a5ef61dc1a3025bbad04c348592f722b47", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,22 +1,35 @@\n-error: at least one trait must be specified\n-  --> $DIR/generic_nondefining_use.rs:5:15\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_nondefining_use.rs:14:21\n    |\n-LL | type Cmp<T> = impl 'static;\n-   |               ^^^^^^^^^^^^\n+LL | fn concrete_ty() -> OneTy<u32> {\n+   |                     ^^^^^^^^^^\n+   |\n+note: used non-generic type `u32` for generic parameter\n+  --> $DIR/generic_nondefining_use.rs:8:12\n+   |\n+LL | type OneTy<T> = impl Debug;\n+   |            ^\n \n-error: defining opaque type use does not fully define opaque type: generic parameter `T` is specified as concrete type `u32`\n-  --> $DIR/generic_nondefining_use.rs:11:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_nondefining_use.rs:19:27\n    |\n-LL | / fn cmp() -> Cmp<u32> {\n-LL | |     5u32\n-LL | | }\n-   | |_^\n+LL | type OneLifetime<'a> = impl Debug;\n+   |                  -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL | fn concrete_lifetime() -> OneLifetime<'static> {\n+   |                           ^^^^^^^^^^^^^^^^^^^^\n \n-error: could not find defining uses\n-  --> $DIR/generic_nondefining_use.rs:5:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/generic_nondefining_use.rs:24:24\n+   |\n+LL | fn concrete_const() -> OneConst<{123}> {\n+   |                        ^^^^^^^^^^^^^^^\n+   |\n+note: used non-generic constant `123usize` for generic parameter\n+  --> $DIR/generic_nondefining_use.rs:10:21\n    |\n-LL | type Cmp<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | type OneConst<const X: usize> = impl Debug;\n+   |                     ^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "4eb7f7836d8691cdac91a83858297fc0440dfe94", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -6,7 +6,6 @@ trait IterBits {\n }\n \n type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-//~^ ERROR could not find defining uses\n \n impl<T: Copy, E> IterBits for T\n where\n@@ -18,7 +17,8 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-    //~^ ERROR defining opaque type use does not fully define opaque type\n+    //~^ ERROR non-defining opaque type use in defining scope\n+    //~| ERROR non-defining opaque type use in defining scope\n         (0u8..n)\n             .rev()\n             .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())"}, {"sha": "55984609437b09652f285c88aba21f48e96e8403", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,19 +1,26 @@\n-error: defining opaque type use does not fully define opaque type: generic parameter `I` is specified as concrete type `u8`\n-  --> $DIR/issue-60564.rs:20:5\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-60564.rs:19:34\n    |\n-LL | /     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-LL | |\n-LL | |         (0u8..n)\n-LL | |             .rev()\n-LL | |             .map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n-LL | |     }\n-   | |_____^\n+LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n+   |                                  ^^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `_` for generic parameter\n+  --> $DIR/issue-60564.rs:8:22\n+   |\n+LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+   |                      ^\n \n-error: could not find defining uses\n-  --> $DIR/issue-60564.rs:8:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-60564.rs:19:34\n+   |\n+LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n+   |                                  ^^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `u8` for generic parameter\n+  --> $DIR/issue-60564.rs:8:25\n    |\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3b6decbe9c65e5cf5e5d75123246fc66ebd33a01", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -4,9 +4,9 @@\n \n #![feature(type_alias_impl_trait)]\n trait Trait<T> {}\n-type Alias<'a, U> = impl Trait<U>; //~ ERROR could not find defining uses\n+type Alias<'a, U> = impl Trait<U>;\n fn f<'a>() -> Alias<'a, ()> {}\n-//~^ ERROR defining opaque type use does not fully define opaque type: generic parameter `U`\n+//~^ ERROR non-defining opaque type use in defining scope\n \n fn main() {}\n "}, {"sha": "c2fa54f50f881214050a05d210964a8c152bd080", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,14 +1,14 @@\n-error: defining opaque type use does not fully define opaque type: generic parameter `U` is specified as concrete type `()`\n-  --> $DIR/issue-68368-non-defining-use.rs:8:1\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-68368-non-defining-use.rs:8:15\n    |\n LL | fn f<'a>() -> Alias<'a, ()> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/issue-68368-non-defining-use.rs:7:1\n+   |               ^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `()` for generic parameter\n+  --> $DIR/issue-68368-non-defining-use.rs:7:16\n    |\n LL | type Alias<'a, U> = impl Trait<U>;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                ^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "02485b24e7b8a5fc3d0c04658a2dc880b71fd28e", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -7,7 +7,6 @@ fn main() {}\n type Two<T, U> = impl Debug;\n \n fn two<T: Debug>(t: T) -> Two<T, u32> {\n-    //~^ ERROR defining opaque type use does not fully define opaque type\n     (t, 4i8)\n }\n "}, {"sha": "cce861b76c95e8b717b276b790c8b47c0d5dda8f", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -1,27 +1,18 @@\n-error: defining opaque type use does not fully define opaque type: generic parameter `U` is specified as concrete type `u32`\n-  --> $DIR/not_a_defining_use.rs:9:1\n-   |\n-LL | / fn two<T: Debug>(t: T) -> Two<T, u32> {\n-LL | |\n-LL | |     (t, 4i8)\n-LL | | }\n-   | |_^\n-\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/not_a_defining_use.rs:30:1\n+  --> $DIR/not_a_defining_use.rs:29:1\n    |\n LL | / fn four<T: Debug, U: Bar>(t: T) -> Two<T, U> {\n LL | |     (t, <U as Bar>::FOO)\n LL | | }\n    | |_^ expected `(T, i8)`, got `(T, <U as Bar>::Blub)`\n    |\n note: previous use here\n-  --> $DIR/not_a_defining_use.rs:14:1\n+  --> $DIR/not_a_defining_use.rs:9:1\n    |\n-LL | / fn three<T: Debug, U>(t: T) -> Two<T, U> {\n-LL | |     (t, 5i8)\n+LL | / fn two<T: Debug>(t: T) -> Two<T, u32> {\n+LL | |     (t, 4i8)\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "62dc965b55f995986711e9ab22cc8421ee2c0754", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2780b391980532f784e49e014a81d3962219bc6/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=e2780b391980532f784e49e014a81d3962219bc6", "patch": "@@ -26,7 +26,6 @@ const LICENSES: &[&str] = &[\n const EXCEPTIONS: &[(&str, &str)] = &[\n     (\"mdbook\", \"MPL-2.0\"),                  // mdbook\n     (\"openssl\", \"Apache-2.0\"),              // cargo, mdbook\n-    (\"arrayref\", \"BSD-2-Clause\"),           // mdbook via handlebars via pest\n     (\"toml-query\", \"MPL-2.0\"),              // mdbook\n     (\"toml-query_derive\", \"MPL-2.0\"),       // mdbook\n     (\"is-match\", \"MPL-2.0\"),                // mdbook\n@@ -74,6 +73,9 @@ const WHITELIST: &[&str] = &[\n     \"backtrace\",\n     \"backtrace-sys\",\n     \"bitflags\",\n+    \"block-buffer\",\n+    \"block-padding\",\n+    \"byte-tools\",\n     \"byteorder\",\n     \"c2-chacha\",\n     \"cc\",\n@@ -87,15 +89,18 @@ const WHITELIST: &[&str] = &[\n     \"crossbeam-queue\",\n     \"crossbeam-utils\",\n     \"datafrog\",\n+    \"digest\",\n     \"dlmalloc\",\n     \"either\",\n     \"ena\",\n     \"env_logger\",\n+    \"fake-simd\",\n     \"filetime\",\n     \"flate2\",\n     \"fortanix-sgx-abi\",\n     \"fuchsia-zircon\",\n     \"fuchsia-zircon-sys\",\n+    \"generic-array\",\n     \"getopts\",\n     \"getrandom\",\n     \"hashbrown\",\n@@ -111,13 +116,15 @@ const WHITELIST: &[&str] = &[\n     \"lock_api\",\n     \"log\",\n     \"log_settings\",\n+    \"md-5\",\n     \"measureme\",\n     \"memchr\",\n     \"memmap\",\n     \"memoffset\",\n     \"miniz_oxide\",\n     \"nodrop\",\n     \"num_cpus\",\n+    \"opaque-debug\",\n     \"parking_lot\",\n     \"parking_lot_core\",\n     \"pkg-config\",\n@@ -150,6 +157,7 @@ const WHITELIST: &[&str] = &[\n     \"semver-parser\",\n     \"serde\",\n     \"serde_derive\",\n+    \"sha-1\",\n     \"smallvec\",\n     \"stable_deref_trait\",\n     \"syn\",\n@@ -159,6 +167,7 @@ const WHITELIST: &[&str] = &[\n     \"termion\",\n     \"termize\",\n     \"thread_local\",\n+    \"typenum\",\n     \"ucd-util\",\n     \"unicode-normalization\",\n     \"unicode-script\","}]}