{"sha": "b23b27631091e44445c829cc8fc8fe4a5c910fc8", "node_id": "C_kwDOAAsO6NoAKGIyM2IyNzYzMTA5MWU0NDQ0NWM4MjljYzhmYzhmZTRhNWM5MTBmYzg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-11T12:38:30Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-04-14T09:31:01Z"}, "message": "internal: Show more project building errors to the user", "tree": {"sha": "5908575a447f11169aaefbc477aede37a0db5002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5908575a447f11169aaefbc477aede37a0db5002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b23b27631091e44445c829cc8fc8fe4a5c910fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b23b27631091e44445c829cc8fc8fe4a5c910fc8", "html_url": "https://github.com/rust-lang/rust/commit/b23b27631091e44445c829cc8fc8fe4a5c910fc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b23b27631091e44445c829cc8fc8fe4a5c910fc8/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf9c825c9ecb566eb597f7837a5bcf9167c01635", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9c825c9ecb566eb597f7837a5bcf9167c01635", "html_url": "https://github.com/rust-lang/rust/commit/cf9c825c9ecb566eb597f7837a5bcf9167c01635"}], "stats": {"total": 133, "additions": 82, "deletions": 51}, "files": [{"sha": "2cd19952678dc59bfe148d7dc34ed5fdb0e0b342", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -329,7 +329,7 @@ impl CargoActor {\n             Ok(output) if output.status.success() => Ok(()),\n             Ok(output)  => {\n                 Err(io::Error::new(io::ErrorKind::Other, format!(\n-                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?})\\nCargo's stderr output:\\n{}\",\n+                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n                     output.status, error\n                 )))\n             }"}, {"sha": "5aa23331a13d6da026a4b907032fe92ca109d655", "filename": "crates/project_model/src/build_scripts.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Fproject_model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Fproject_model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_scripts.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -7,11 +7,11 @@\n //! here, but it covers procedural macros as well.\n \n use std::{\n+    io,\n     path::PathBuf,\n     process::{Command, Stdio},\n };\n \n-use anyhow::Result;\n use cargo_metadata::{camino::Utf8Path, Message};\n use la_arena::ArenaMap;\n use paths::AbsPathBuf;\n@@ -80,7 +80,7 @@ impl WorkspaceBuildScripts {\n         config: &CargoConfig,\n         workspace: &CargoWorkspace,\n         progress: &dyn Fn(String),\n-    ) -> Result<WorkspaceBuildScripts> {\n+    ) -> io::Result<WorkspaceBuildScripts> {\n         let mut cmd = Self::build_command(config);\n \n         if config.wrap_rustc_in_build_scripts {\n@@ -107,12 +107,12 @@ impl WorkspaceBuildScripts {\n             by_id.insert(workspace[package].id.clone(), package);\n         }\n \n-        let mut callback_err = None;\n+        let mut cfg_err = None;\n         let mut stderr = String::new();\n         let output = stdx::process::streaming_output(\n             cmd,\n             &mut |line| {\n-                if callback_err.is_some() {\n+                if cfg_err.is_some() {\n                     return;\n                 }\n \n@@ -126,7 +126,7 @@ impl WorkspaceBuildScripts {\n                 match message {\n                     Message::BuildScriptExecuted(message) => {\n                         let package = match by_id.get(&message.package_id.repr) {\n-                            Some(it) => *it,\n+                            Some(&it) => it,\n                             None => return,\n                         };\n                         let cfgs = {\n@@ -135,7 +135,7 @@ impl WorkspaceBuildScripts {\n                                 match cfg.parse::<CfgFlag>() {\n                                     Ok(it) => acc.push(it),\n                                     Err(err) => {\n-                                        callback_err = Some(anyhow::format_err!(\n+                                        cfg_err = Some(format!(\n                                             \"invalid cfg from cargo-metadata: {}\",\n                                             err\n                                         ));\n@@ -191,6 +191,11 @@ impl WorkspaceBuildScripts {\n \n         for package in workspace.packages() {\n             let package_build_data = &mut res.outputs[package];\n+            tracing::info!(\n+                \"{} BuildScriptOutput: {:?}\",\n+                workspace[package].manifest.parent().display(),\n+                package_build_data,\n+            );\n             // inject_cargo_env(package, package_build_data);\n             if let Some(out_dir) = &package_build_data.out_dir {\n                 // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n@@ -200,6 +205,11 @@ impl WorkspaceBuildScripts {\n             }\n         }\n \n+        if let Some(cfg_err) = cfg_err {\n+            stderr.push_str(&cfg_err);\n+            stderr.push('\\n');\n+        }\n+\n         if !output.status.success() {\n             if stderr.is_empty() {\n                 stderr = \"cargo check failed\".to_string();"}, {"sha": "1330a869509f9366d1f1c19666b3da5cd31185b2", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -256,7 +256,9 @@ impl ProjectWorkspace {\n     ) -> Result<WorkspaceBuildScripts> {\n         match self {\n             ProjectWorkspace::Cargo { cargo, .. } => {\n-                WorkspaceBuildScripts::run(config, cargo, progress)\n+                WorkspaceBuildScripts::run(config, cargo, progress).with_context(|| {\n+                    format!(\"Failed to run build scripts for {}\", &cargo.workspace_root().display())\n+                })\n             }\n             ProjectWorkspace::Json { .. } | ProjectWorkspace::DetachedFiles { .. } => {\n                 Ok(WorkspaceBuildScripts::default())"}, {"sha": "15ae0e64806fc4d877e8a2e6d1c5eaaad5b952e2", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -119,7 +119,9 @@ fn setup_logging(log_file: Option<&Path>) -> Result<()> {\n         None => None,\n     };\n     let filter = env::var(\"RA_LOG\").ok();\n-    logger::Logger::new(log_file, filter.as_deref()).install()?;\n+    // deliberately enable all `error` logs if the user has not set RA_LOG, as there is usually useful\n+    // information in there for debugging\n+    logger::Logger::new(log_file, filter.as_deref().or(Some(\"error\"))).install()?;\n \n     profile::init();\n "}, {"sha": "8b47ef028302f3afec29c907c8a5e7567db59a9b", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -190,6 +190,7 @@ impl GlobalState {\n \n             for file in changed_files {\n                 if !file.is_created_or_deleted() {\n+                    // FIXME: https://github.com/rust-analyzer/rust-analyzer/issues/11357\n                     let crates = self.analysis_host.raw_database().relevant_crates(file.file_id);\n                     let crate_graph = self.analysis_host.raw_database().crate_graph();\n \n@@ -255,6 +256,7 @@ impl GlobalState {\n         let request = self.req_queue.outgoing.register(R::METHOD.to_string(), params, handler);\n         self.send(request.into());\n     }\n+\n     pub(crate) fn complete_request(&mut self, response: lsp_server::Response) {\n         let handler = self\n             .req_queue\n@@ -281,6 +283,7 @@ impl GlobalState {\n             .incoming\n             .register(request.id.clone(), (request.method.clone(), request_received));\n     }\n+\n     pub(crate) fn respond(&mut self, response: lsp_server::Response) {\n         if let Some((method, start)) = self.req_queue.incoming.complete(response.id.clone()) {\n             if let Some(err) = &response.error {\n@@ -294,6 +297,7 @@ impl GlobalState {\n             self.send(response.into());\n         }\n     }\n+\n     pub(crate) fn cancel(&mut self, request_id: lsp_server::RequestId) {\n         if let Some(response) = self.req_queue.incoming.cancel(request_id) {\n             self.send(response.into());\n@@ -307,7 +311,7 @@ impl GlobalState {\n \n impl Drop for GlobalState {\n     fn drop(&mut self) {\n-        self.analysis_host.request_cancellation()\n+        self.analysis_host.request_cancellation();\n     }\n }\n "}, {"sha": "460ae4ef4daf907f38f81c692dbba35a5b8b050f", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -47,6 +47,26 @@ impl GlobalState {\n         )\n     }\n \n+    /// Sends a notification to the client containing the error `message`.\n+    /// If `additional_info` is [`Some`], appends a note to the notification telling to check the logs.\n+    /// This will always log `message` + `additional_info` to the server's error log.\n+    pub(crate) fn show_and_log_error(&mut self, message: String, additional_info: Option<String>) {\n+        let mut message = message;\n+        match additional_info {\n+            Some(additional_info) => {\n+                tracing::error!(\"{}\\n\\n{}\", &message, &additional_info);\n+                if tracing::enabled!(tracing::Level::ERROR) {\n+                    message.push_str(\"\\n\\nCheck the server logs for additional info.\");\n+                }\n+            }\n+            None => tracing::error!(\"{}\", &message),\n+        }\n+\n+        self.send_notification::<lsp_types::notification::ShowMessage>(\n+            lsp_types::ShowMessageParams { typ: lsp_types::MessageType::ERROR, message },\n+        )\n+    }\n+\n     /// rust-analyzer is resilient -- if it fails, this doesn't usually affect\n     /// the user experience. Part of that is that we deliberately hide panics\n     /// from the user."}, {"sha": "de44ba5e077d30144d188b8e334d67a4b2d33e52", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -111,10 +111,7 @@ impl GlobalState {\n             && self.config.detached_files().is_empty()\n             && self.config.notifications().cargo_toml_not_found\n         {\n-            self.show_message(\n-                lsp_types::MessageType::ERROR,\n-                \"rust-analyzer failed to discover workspace\".to_string(),\n-            );\n+            self.show_and_log_error(\"rust-analyzer failed to discover workspace\".to_string(), None);\n         };\n \n         if self.config.did_save_text_document_dynamic_registration() {\n@@ -406,9 +403,9 @@ impl GlobalState {\n                                 flycheck::Progress::DidCancel => (Progress::End, None),\n                                 flycheck::Progress::DidFinish(result) => {\n                                     if let Err(err) = result {\n-                                        self.show_message(\n-                                            lsp_types::MessageType::ERROR,\n-                                            format!(\"cargo check failed: {}\", err),\n+                                        self.show_and_log_error(\n+                                            \"cargo check failed\".to_string(),\n+                                            Some(err.to_string()),\n                                         );\n                                     }\n                                     (Progress::End, None)\n@@ -564,7 +561,6 @@ impl GlobalState {\n         if self.workspaces.is_empty() && !self.is_quiescent() {\n             self.respond(lsp_server::Response::new_err(\n                 req.id,\n-                // FIXME: i32 should impl From<ErrorCode> (from() guarantees lossless conversion)\n                 lsp_server::ErrorCode::ContentModified as i32,\n                 \"waiting for cargo metadata or cargo check\".to_owned(),\n             ));"}, {"sha": "5189d94eae988eba54b215a9cdf9da286dd029aa", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23b27631091e44445c829cc8fc8fe4a5c910fc8/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=b23b27631091e44445c829cc8fc8fe4a5c910fc8", "patch": "@@ -72,9 +72,10 @@ impl GlobalState {\n             status.message =\n                 Some(\"Reload required due to source changes of a procedural macro.\".into())\n         }\n-        if let Some(error) = self.fetch_build_data_error() {\n+        if let Err(_) = self.fetch_build_data_error() {\n             status.health = lsp_ext::Health::Warning;\n-            status.message = Some(error)\n+            status.message =\n+                Some(\"Failed to run build scripts of some packages, check the logs.\".to_string());\n         }\n         if !self.config.cargo_autoreload()\n             && self.is_quiescent()\n@@ -84,7 +85,7 @@ impl GlobalState {\n             status.message = Some(\"Workspace reload required\".to_string())\n         }\n \n-        if let Some(error) = self.fetch_workspace_error() {\n+        if let Err(error) = self.fetch_workspace_error() {\n             status.health = lsp_ext::Health::Error;\n             status.message = Some(error)\n         }\n@@ -167,17 +168,20 @@ impl GlobalState {\n         let _p = profile::span(\"GlobalState::switch_workspaces\");\n         tracing::info!(\"will switch workspaces\");\n \n-        if let Some(error_message) = self.fetch_workspace_error() {\n-            tracing::error!(\"failed to switch workspaces: {}\", error_message);\n+        if let Err(error_message) = self.fetch_workspace_error() {\n+            self.show_and_log_error(error_message, None);\n             if !self.workspaces.is_empty() {\n                 // It only makes sense to switch to a partially broken workspace\n                 // if we don't have any workspace at all yet.\n                 return;\n             }\n         }\n \n-        if let Some(error_message) = self.fetch_build_data_error() {\n-            tracing::error!(\"failed to switch build data: {}\", error_message);\n+        if let Err(error) = self.fetch_build_data_error() {\n+            self.show_and_log_error(\n+                \"rust-analyzer failed to run build scripts\".to_string(),\n+                Some(error),\n+            );\n         }\n \n         let workspaces = self\n@@ -277,20 +281,18 @@ impl GlobalState {\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n         if self.proc_macro_client.is_none() {\n-            self.proc_macro_client = match self.config.proc_macro_srv() {\n-                None => None,\n-                Some((path, args)) => match ProcMacroServer::spawn(path.clone(), args) {\n-                    Ok(it) => Some(it),\n+            if let Some((path, args)) = self.config.proc_macro_srv() {\n+                match ProcMacroServer::spawn(path.clone(), args) {\n+                    Ok(it) => self.proc_macro_client = Some(it),\n                     Err(err) => {\n                         tracing::error!(\n                             \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n                             path.display(),\n                             err\n                         );\n-                        None\n                     }\n-                },\n-            };\n+                }\n+            }\n         }\n \n         let watch = match files_config.watcher {\n@@ -348,7 +350,7 @@ impl GlobalState {\n         tracing::info!(\"did switch workspaces\");\n     }\n \n-    fn fetch_workspace_error(&self) -> Option<String> {\n+    fn fetch_workspace_error(&self) -> Result<(), String> {\n         let mut buf = String::new();\n \n         for ws in self.fetch_workspaces_queue.last_op_result() {\n@@ -358,35 +360,30 @@ impl GlobalState {\n         }\n \n         if buf.is_empty() {\n-            return None;\n+            return Ok(());\n         }\n \n-        Some(buf)\n+        Err(buf)\n     }\n \n-    fn fetch_build_data_error(&self) -> Option<String> {\n-        let mut buf = \"rust-analyzer failed to run build scripts:\\n\".to_string();\n-        let mut has_errors = false;\n+    fn fetch_build_data_error(&self) -> Result<(), String> {\n+        let mut buf = String::new();\n \n         for ws in &self.fetch_build_data_queue.last_op_result().1 {\n             match ws {\n-                Ok(data) => {\n-                    if let Some(err) = data.error() {\n-                        has_errors = true;\n-                        stdx::format_to!(buf, \"{:#}\\n\", err);\n-                    }\n-                }\n-                Err(err) => {\n-                    has_errors = true;\n-                    stdx::format_to!(buf, \"{:#}\\n\", err);\n-                }\n+                Ok(data) => match data.error() {\n+                    Some(stderr) => stdx::format_to!(buf, \"{:#}\\n\", stderr),\n+                    _ => (),\n+                },\n+                // io errors\n+                Err(err) => stdx::format_to!(buf, \"{:#}\\n\", err),\n             }\n         }\n \n-        if has_errors {\n-            Some(buf)\n+        if buf.is_empty() {\n+            Ok(())\n         } else {\n-            None\n+            Err(buf)\n         }\n     }\n "}]}