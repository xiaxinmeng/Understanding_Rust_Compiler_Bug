{"sha": "e4efa22983a676fc78dafc3d39ff81f062e72120", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZWZhMjI5ODNhNjc2ZmM3OGRhZmMzZDM5ZmY4MWYwNjJlNzIxMjA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-27T21:58:41Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-03-27T21:58:41Z"}, "message": "Source formatting fallout", "tree": {"sha": "905ca22de6e7a4a395d7128290b8c71821c93cec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/905ca22de6e7a4a395d7128290b8c71821c93cec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4efa22983a676fc78dafc3d39ff81f062e72120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4efa22983a676fc78dafc3d39ff81f062e72120", "html_url": "https://github.com/rust-lang/rust/commit/e4efa22983a676fc78dafc3d39ff81f062e72120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4efa22983a676fc78dafc3d39ff81f062e72120/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "038436919d762bf6fbdd87ce4e824f8c8c0c8822", "url": "https://api.github.com/repos/rust-lang/rust/commits/038436919d762bf6fbdd87ce4e824f8c8c0c8822", "html_url": "https://github.com/rust-lang/rust/commit/038436919d762bf6fbdd87ce4e824f8c8c0c8822"}], "stats": {"total": 174, "additions": 101, "deletions": 73}, "files": [{"sha": "bd52f11bbef94ae0caef7d39f0ac33841b59b8fb", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -96,7 +96,8 @@ fn format_crate(verbosity: Verbosity) -> Result<ExitStatus, std::io::Error> {\n     let targets = try!(get_targets());\n \n     // Currently only bin and lib files get formatted\n-    let files: Vec<_> = targets.into_iter()\n+    let files: Vec<_> = targets\n+        .into_iter()\n         .filter(|t| t.kind.should_format())\n         .inspect(|t| if verbosity == Verbosity::Verbose {\n                      println!(\"[{:?}] {:?}\", t.kind, t.path)\n@@ -165,11 +166,13 @@ fn get_targets() -> Result<Vec<Target>, std::io::Error> {\n \n fn target_from_json(jtarget: &Json) -> Target {\n     let jtarget = jtarget.as_object().unwrap();\n-    let path = PathBuf::from(jtarget.get(\"src_path\")\n+    let path = PathBuf::from(jtarget\n+                                 .get(\"src_path\")\n                                  .unwrap()\n                                  .as_string()\n                                  .unwrap());\n-    let kinds = jtarget.get(\"kind\")\n+    let kinds = jtarget\n+        .get(\"kind\")\n         .unwrap()\n         .as_array()\n         .unwrap();"}, {"sha": "1a1c0c99de3c5f763e678eafd93e34fea17b3e93", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -226,7 +226,8 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             let options = try!(CliOptions::from_matches(&matches));\n \n             // Add any additional files that were specified via `--file-lines`.\n-            files.extend(options.file_lines\n+            files.extend(options\n+                             .file_lines\n                              .files()\n                              .cloned()\n                              .map(PathBuf::from));\n@@ -338,7 +339,8 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     }\n \n     // Read the config_path and convert to parent dir if a file is provided.\n-    let config_path: Option<PathBuf> = matches.opt_str(\"config-path\")\n+    let config_path: Option<PathBuf> = matches\n+        .opt_str(\"config-path\")\n         .map(PathBuf::from)\n         .and_then(|dir| {\n                       if dir.is_file() {\n@@ -360,7 +362,8 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     }\n \n     // We append files from `--file-lines` later in `execute()`.\n-    let files: Vec<_> = matches.free\n+    let files: Vec<_> = matches\n+        .free\n         .iter()\n         .map(PathBuf::from)\n         .collect();"}, {"sha": "965187c5e07f8653ed1672769248ba383469b3d9", "filename": "src/chains.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -113,8 +113,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n-        (nested_shape, context.config.chain_indent == IndentStyle::Visual ||\n-                       parent_rewrite.len() <= context.config.tab_spaces)\n+        (nested_shape,\n+         context.config.chain_indent == IndentStyle::Visual ||\n+         parent_rewrite.len() <= context.config.tab_spaces)\n     } else if is_block_expr(&parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n@@ -425,7 +426,8 @@ fn rewrite_method_call(method_name: ast::Ident,\n             format!(\"::<{}>\", type_list.join(\", \"))\n         };\n \n-        (types.last()\n+        (types\n+             .last()\n              .unwrap()\n              .span\n              .hi,"}, {"sha": "9568842e92584cded9f54a1a59d8bae6680320f7", "filename": "src/expr.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -360,7 +360,8 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         }\n     }\n \n-    let has_long_item = try_opt!(items.iter()\n+    let has_long_item = try_opt!(items\n+                                     .iter()\n                                      .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n                                      .fold(Some(false),\n                                            |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n@@ -1308,7 +1309,8 @@ impl Rewrite for ast::Arm {\n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n         if shape.width > pat_width + comma.len() + 4 {\n-            let arm_shape = shape.shrink_left(pat_width + 4)\n+            let arm_shape = shape\n+                .shrink_left(pat_width + 4)\n                 .unwrap()\n                 .sub_width(comma.len())\n                 .unwrap()\n@@ -1404,7 +1406,8 @@ fn rewrite_guard(context: &RewriteContext,\n         // 4 = ` if `, 5 = ` => {`\n         let overhead = pattern_width + 4 + 5;\n         if overhead < shape.width {\n-            let cond_shape = shape.shrink_left(pattern_width + 4)\n+            let cond_shape = shape\n+                .shrink_left(pattern_width + 4)\n                 .unwrap()\n                 .sub_width(5)\n                 .unwrap();\n@@ -1424,7 +1427,8 @@ fn rewrite_guard(context: &RewriteContext,\n                                                        3));\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\"\\n{}if {}\",\n-                                    shape.indent\n+                                    shape\n+                                        .indent\n                                         .block_indent(context.config)\n                                         .to_string(context.config),\n                                     cond_str));\n@@ -1538,7 +1542,8 @@ fn string_requires_rewrite(context: &RewriteContext,\n                            string: &str,\n                            shape: Shape)\n                            -> bool {\n-    if context.codemap\n+    if context\n+           .codemap\n            .lookup_char_pos(span.lo)\n            .col\n            .0 != shape.indent.width() {\n@@ -1610,7 +1615,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n \n     let nested_shape = match context.config.fn_call_style {\n         IndentStyle::Block => {\n-            shape.block()\n+            shape\n+                .block()\n                 .block_indent(context.config.tab_spaces)\n                 .sub_width(context.config.tab_spaces)\n         }\n@@ -1781,9 +1787,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n-    let field_iter = fields.into_iter()\n-        .map(StructLitField::Regular)\n-        .chain(base.into_iter().map(StructLitField::Base));\n+    let field_iter =\n+        fields.into_iter().map(StructLitField::Regular).chain(base.into_iter()\n+                                                                  .map(StructLitField::Base));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n     let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));\n@@ -1895,7 +1901,8 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n-        return items.next()\n+        return items\n+                   .next()\n                    .unwrap()\n                    .rewrite(context, nested_shape)\n                    .map(|s| if context.config.spaces_within_parens {"}, {"sha": "1e9226bd56ff3428a0ee7375b9f0f738e8e021f6", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -191,7 +191,8 @@ impl<'a> FmtVisitor<'a> {\n     pub fn format_imports(&mut self, use_items: &[ptr::P<ast::Item>]) {\n         // Find the location immediately before the first use item in the run. This must not lie\n         // before the current `self.last_pos`\n-        let pos_before_first_use_item = use_items.first()\n+        let pos_before_first_use_item = use_items\n+            .first()\n             .map(|p_i| {\n                      cmp::max(self.last_pos,\n                               p_i.attrs\n@@ -204,7 +205,8 @@ impl<'a> FmtVisitor<'a> {\n         // Construct a list of pairs, each containing a `use` item and the start of span before\n         // that `use` item.\n         let mut last_pos_of_prev_use_item = pos_before_first_use_item;\n-        let mut ordered_use_items = use_items.iter()\n+        let mut ordered_use_items = use_items\n+            .iter()\n             .map(|p_i| {\n                      let new_item = (&*p_i, last_pos_of_prev_use_item);\n                      last_pos_of_prev_use_item = p_i.span.hi;"}, {"sha": "506db369806ce806b1f9f7188a1901f71a0391a1", "filename": "src/items.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -1129,7 +1129,8 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     let line_width = last_line_width(&result);\n     // This checked_sub may fail as the extra space after '=' is not taken into account\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n-    let budget = context.config\n+    let budget = context\n+        .config\n         .max_width\n         .checked_sub(indent.width() + line_width + \";\".len())\n         .unwrap_or(0);\n@@ -1720,12 +1721,12 @@ fn rewrite_args(context: &RewriteContext,\n     // Account for sugary self.\n     // FIXME: the comment for the self argument is dropped. This is blocked\n     // on rust issue #27522.\n-    let min_args =\n-        explicit_self.and_then(|explicit_self| rewrite_explicit_self(explicit_self, args, context))\n-            .map_or(1, |self_str| {\n-                arg_item_strs[0] = self_str;\n-                2\n-            });\n+    let min_args = explicit_self\n+        .and_then(|explicit_self| rewrite_explicit_self(explicit_self, args, context))\n+        .map_or(1, |self_str| {\n+            arg_item_strs[0] = self_str;\n+            2\n+        });\n \n     // Comments between args.\n     let mut arg_items = Vec::new();\n@@ -1852,7 +1853,8 @@ fn compute_budgets_for_args(context: &RewriteContext,\n         if !newline_brace {\n             used_space += 2;\n         }\n-        let one_line_budget = context.config\n+        let one_line_budget = context\n+            .config\n             .max_width\n             .checked_sub(used_space)\n             .unwrap_or(0);\n@@ -1962,7 +1964,8 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    let bound_str = try_opt!(bounds.iter()\n+    let bound_str = try_opt!(bounds\n+                                 .iter()\n                                  .map(|ty_bound| ty_bound.rewrite(&context, shape))\n                                  .intersperse(Some(\" + \".to_string()))\n                                  .collect::<Option<String>>());"}, {"sha": "1ec1f00073d57352c717275be9c147a7793b189e", "filename": "src/lists.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -275,7 +275,8 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n \n         if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n-            let width = formatting.shape\n+            let width = formatting\n+                .shape\n                 .width\n                 .checked_sub(item_last_line_width + 1)\n                 .unwrap_or(1);\n@@ -397,8 +398,8 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                 let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments.\n                 let test_snippet = &test_snippet[first_newline..];\n-                let first = test_snippet.find(|c: char| !c.is_whitespace())\n-                    .unwrap_or(test_snippet.len());\n+                let first =\n+                    test_snippet.find(|c: char| !c.is_whitespace()).unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments to the next non-whitespace char.\n                 let test_snippet = &test_snippet[..first];\n "}, {"sha": "f0ddf029aef9eab60f0299d8aa749fcc020b59b4", "filename": "src/macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -156,13 +156,13 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             // Format macro invocation as array literal.\n             let extra_offset = macro_name.len();\n             let shape = try_opt!(shape.shrink_left(extra_offset));\n-            let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n-                                                 mk_sp(context.codemap\n-                                                           .span_after(mac.span,\n-                                                                       original_style.opener()),\n-                                                       mac.span.hi - BytePos(1)),\n-                                                 context,\n-                                                 shape));\n+            let rewrite =\n+                try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n+                                       mk_sp(context.codemap.span_after(mac.span,\n+                                                                        original_style.opener()),\n+                                             mac.span.hi - BytePos(1)),\n+                                       context,\n+                                       shape));\n \n             Some(format!(\"{}{}\", macro_name, rewrite))\n         }"}, {"sha": "3f2d78f35ccb0915df8487563fe40356b15bc57c", "filename": "src/missed_spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -83,7 +83,8 @@ impl<'a> FmtVisitor<'a> {\n         let local_end = self.codemap.lookup_byte_offset(span.hi);\n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n-        let big_snippet = &local_begin.fm\n+        let big_snippet = &local_begin\n+                               .fm\n                                .src\n                                .as_ref()\n                                .unwrap()"}, {"sha": "37a569ce67ddbb29a192d93cf72e1c2e275453cd", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -42,7 +42,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n-    let mut result = String::with_capacity(stripped_str.len()\n+    let mut result = String::with_capacity(stripped_str\n+                                               .len()\n                                                .checked_next_power_of_two()\n                                                .unwrap_or(usize::max_value()));\n     result.push_str(fmt.opener);"}, {"sha": "9cac8b4a0e01727162a41d217ab256f01567f589", "filename": "src/types.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -206,7 +206,8 @@ fn rewrite_segment(path_context: PathContext,\n                     .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n-                let next_span_lo = param_list.last()\n+                let next_span_lo = param_list\n+                    .last()\n                     .unwrap()\n                     .get_span()\n                     .hi + BytePos(1);\n@@ -297,28 +298,28 @@ fn format_function_type<'a, I>(inputs: I,\n     // 1 for (\n     let offset = shape.indent + 1;\n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let items = itemize_list(context.codemap,\n-                             // FIXME Would be nice to avoid this allocation,\n-                             // but I couldn't get the types to work out.\n-                             inputs.map(|i| ArgumentKind::Regular(Box::new(i)))\n-                                 .chain(variadic_arg),\n-                             \")\",\n-                             |arg| match *arg {\n-                                 ArgumentKind::Regular(ref ty) => ty.span().lo,\n-                                 ArgumentKind::Variadic(start) => start,\n-                             },\n-                             |arg| match *arg {\n-                                 ArgumentKind::Regular(ref ty) => ty.span().hi,\n-                                 ArgumentKind::Variadic(start) => start + BytePos(3),\n-                             },\n-                             |arg| match *arg {\n-                                 ArgumentKind::Regular(ref ty) => {\n-                                     ty.rewrite(context, Shape::legacy(budget, offset))\n-                                 }\n-                                 ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n-                             },\n-                             list_lo,\n-                             span.hi);\n+    let items =\n+        itemize_list(context.codemap,\n+                     // FIXME Would be nice to avoid this allocation,\n+                     // but I couldn't get the types to work out.\n+                     inputs.map(|i| ArgumentKind::Regular(Box::new(i))).chain(variadic_arg),\n+                     \")\",\n+                     |arg| match *arg {\n+                         ArgumentKind::Regular(ref ty) => ty.span().lo,\n+                         ArgumentKind::Variadic(start) => start,\n+                     },\n+                     |arg| match *arg {\n+                         ArgumentKind::Regular(ref ty) => ty.span().hi,\n+                         ArgumentKind::Variadic(start) => start + BytePos(3),\n+                     },\n+                     |arg| match *arg {\n+                         ArgumentKind::Regular(ref ty) => {\n+                             ty.rewrite(context, Shape::legacy(budget, offset))\n+                         }\n+                         ArgumentKind::Variadic(_) => Some(\"...\".to_owned()),\n+                     },\n+                     list_lo,\n+                     span.hi);\n \n     let list_str = try_opt!(format_fn_args(items, Shape::legacy(budget, offset), context.config));\n \n@@ -680,7 +681,8 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n         // 6 = \"for<> \".len(), 4 = \"for<\".\n         // This doesn't work out so nicely for mutliline situation with lots of\n         // rightward drift. If that is a problem, we could use the list stuff.\n-        result.push_str(&try_opt!(bare_fn.lifetimes\n+        result.push_str(&try_opt!(bare_fn\n+                                      .lifetimes\n                                       .iter()\n                                       .map(|l| {\n                                                l.rewrite(context,"}, {"sha": "1d836d8dc676b2f228f2526f32ef092a259022da", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -127,7 +127,8 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n // Find the end of a TyParam\n #[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n-    typaram.bounds\n+    typaram\n+        .bounds\n         .last()\n         .map_or(typaram.span, |bound| match *bound {\n             ast::RegionTyParamBound(ref lt) => lt.span,\n@@ -278,7 +279,8 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n             // indentation.\n             // A special check for the last line, since the caller may\n             // place trailing characters on this line.\n-            if snippet.lines()\n+            if snippet\n+                   .lines()\n                    .rev()\n                    .next()\n                    .unwrap()"}, {"sha": "f78b781feffddc7c4a2166b2fa28fdd44ebe6d64", "filename": "src/visitor.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4efa22983a676fc78dafc3d39ff81f062e72120/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=e4efa22983a676fc78dafc3d39ff81f062e72120", "patch": "@@ -476,7 +476,8 @@ impl<'a> FmtVisitor<'a> {\n             return true;\n         }\n \n-        let outers: Vec<_> = attrs.iter()\n+        let outers: Vec<_> = attrs\n+            .iter()\n             .filter(|a| a.style == ast::AttrStyle::Outer)\n             .cloned()\n             .collect();\n@@ -487,10 +488,10 @@ impl<'a> FmtVisitor<'a> {\n         let first = &outers[0];\n         self.format_missing_with_indent(source!(self, first.span).lo);\n \n-        let rewrite = outers.rewrite(&self.get_context(),\n-                                     Shape::legacy(self.config.max_width -\n-                                                   self.block_indent.width(),\n-                                                   self.block_indent))\n+        let rewrite = outers\n+            .rewrite(&self.get_context(),\n+                     Shape::legacy(self.config.max_width - self.block_indent.width(),\n+                                   self.block_indent))\n             .unwrap();\n         self.buffer.push_str(&rewrite);\n         let last = outers.last().unwrap();"}]}