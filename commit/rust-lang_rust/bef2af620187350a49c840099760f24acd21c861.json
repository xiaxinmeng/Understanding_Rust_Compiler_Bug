{"sha": "bef2af620187350a49c840099760f24acd21c861", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZjJhZjYyMDE4NzM1MGE0OWM4NDAwOTk3NjBmMjRhY2QyMWM4NjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-25T20:40:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-25T20:40:27Z"}, "message": "Auto merge of #30017 - nrc:fmt, r=brson", "tree": {"sha": "9deb3089b49e1c4d2b88792ccdcda017619a2c96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9deb3089b49e1c4d2b88792ccdcda017619a2c96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bef2af620187350a49c840099760f24acd21c861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bef2af620187350a49c840099760f24acd21c861", "html_url": "https://github.com/rust-lang/rust/commit/bef2af620187350a49c840099760f24acd21c861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bef2af620187350a49c840099760f24acd21c861/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bb91be05f3e947364de8f6781124003ce2404ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb91be05f3e947364de8f6781124003ce2404ab", "html_url": "https://github.com/rust-lang/rust/commit/1bb91be05f3e947364de8f6781124003ce2404ab"}, {"sha": "5fb6531903c4e425f48a859463bee20cfcc7f7c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb6531903c4e425f48a859463bee20cfcc7f7c5", "html_url": "https://github.com/rust-lang/rust/commit/5fb6531903c4e425f48a859463bee20cfcc7f7c5"}], "stats": {"total": 3492, "additions": 1981, "deletions": 1511}, "files": [{"sha": "f8483a8ed9b406d75df80a6517606ba2add5dfea", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -131,11 +131,12 @@ pub struct Arc<T: ?Sized> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n@@ -152,11 +153,12 @@ pub struct Weak<T: ?Sized> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n@@ -226,7 +228,7 @@ impl<T> Arc<T> {\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n         // See `drop` for why all these atomics are like this\n         if this.inner().strong.compare_and_swap(1, 0, Release) != 1 {\n-            return Err(this)\n+            return Err(this);\n         }\n \n         atomic::fence(Acquire);\n@@ -265,7 +267,7 @@ impl<T: ?Sized> Arc<T> {\n \n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX {\n-                continue\n+                continue;\n             }\n \n             // NOTE: this code currently ignores the possibility of overflow\n@@ -276,7 +278,7 @@ impl<T: ?Sized> Arc<T> {\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n             if this.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n-                return Weak { _ptr: this._ptr }\n+                return Weak { _ptr: this._ptr };\n             }\n         }\n     }\n@@ -568,14 +570,14 @@ impl<T: ?Sized> Drop for Arc<T> {\n         let ptr = *self._ptr;\n         // if ptr.is_null() { return }\n         if ptr as *mut u8 as usize == 0 || ptr as *mut u8 as usize == mem::POST_DROP_USIZE {\n-            return\n+            return;\n         }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n         // same logic applies to the below `fetch_sub` to the `weak` count.\n         if self.inner().strong.fetch_sub(1, Release) != 1 {\n-            return\n+            return;\n         }\n \n         // This fence is needed to prevent reordering of use of the data and\n@@ -634,7 +636,7 @@ impl<T: ?Sized> Weak<T> {\n             // confirmed via the CAS below.\n             let n = inner.strong.load(Relaxed);\n             if n == 0 {\n-                return None\n+                return None;\n             }\n \n             // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n@@ -645,7 +647,7 @@ impl<T: ?Sized> Weak<T> {\n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             let old = inner.strong.compare_and_swap(n, n + 1, Relaxed);\n             if old == n {\n-                return Some(Arc { _ptr: self._ptr })\n+                return Some(Arc { _ptr: self._ptr });\n             }\n         }\n     }\n@@ -687,7 +689,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { _ptr: self._ptr }\n+        return Weak { _ptr: self._ptr };\n     }\n }\n \n@@ -723,7 +725,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n         // see comments above for why this check is here\n         if ptr as *mut u8 as usize == 0 || ptr as *mut u8 as usize == mem::POST_DROP_USIZE {\n-            return\n+            return;\n         }\n \n         // If we find out that we were the last weak pointer, then its time to\n@@ -933,8 +935,7 @@ mod tests {\n \n     struct Canary(*mut atomic::AtomicUsize);\n \n-    impl Drop for Canary\n-    {\n+    impl Drop for Canary {\n         fn drop(&mut self) {\n             unsafe {\n                 match *self {\n@@ -948,7 +949,7 @@ mod tests {\n \n     #[test]\n     fn manually_share_arc() {\n-        let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);\n \n         let (tx, rx) = channel();"}, {"sha": "804c593467e5b723a3feb9b15e5d3af74e38939b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -88,8 +88,7 @@ use core::convert::From;\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\",\n            issue = \"27779\")]\n-pub const HEAP: ExchangeHeapSingleton =\n-    ExchangeHeapSingleton { _force_singleton: () };\n+pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n \n /// This the singleton type used solely for `boxed::HEAP`.\n #[unstable(feature = \"box_heap\",\n@@ -238,7 +237,7 @@ impl<T> Box<T> {\n     }\n }\n \n-impl<T : ?Sized> Box<T> {\n+impl<T: ?Sized> Box<T> {\n     /// Constructs a box from the raw pointer.\n     ///\n     /// After this function call, pointer is owned by resulting box.\n@@ -535,8 +534,7 @@ pub trait FnBox<A> {\n }\n \n #[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n-impl<A,F> FnBox<A> for F\n-    where F: FnOnce<A>\n+impl<A, F> FnBox<A> for F where F: FnOnce<A>\n {\n     type Output = F::Output;\n \n@@ -546,7 +544,7 @@ impl<A,F> FnBox<A> for F\n }\n \n #[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n-impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> {\n+impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -555,7 +553,7 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> {\n }\n \n #[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n-impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n+impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -564,7 +562,7 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {"}, {"sha": "e7da6d04d3f8fce438f9832dd03401b51136c585", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -74,8 +74,7 @@ fn test_show() {\n \n #[test]\n fn deref() {\n-    fn homura<T: Deref<Target = i32>>(_: T) {\n-    }\n+    fn homura<T: Deref<Target = i32>>(_: T) {}\n     homura(Box::new(765));\n }\n "}, {"sha": "7e7e3c619cb3a9d6552d43e99110d0171b4cb596", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -18,7 +18,7 @@\n use core::{isize, usize};\n \n #[allow(improper_ctypes)]\n-extern {\n+extern \"C\" {\n     #[allocator]\n     fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n     fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);"}, {"sha": "404c7522403cd06c928b3101468389d65199ffbc", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -196,9 +196,10 @@ impl<T: ?Sized> !marker::Send for Rc<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !marker::Sync for Rc<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n \n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n@@ -482,7 +483,6 @@ impl<T: ?Sized> Drop for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n-\n     /// Makes a clone of the `Rc<T>`.\n     ///\n     /// When you clone an `Rc<T>`, it will create another pointer to the data and\n@@ -678,21 +678,21 @@ impl<T: ?Sized + Ord> Ord for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+Hash> Hash for Rc<T> {\n+impl<T: ?Sized + Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> {\n+impl<T: ?Sized + fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n@@ -731,9 +731,10 @@ impl<T: ?Sized> !marker::Send for Weak<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n@@ -810,7 +811,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-\n     /// Makes a clone of the `Weak<T>`.\n     ///\n     /// This increases the weak reference count.\n@@ -832,7 +832,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }"}, {"sha": "f53bc404b8885b2083452ec5474f078f9cad7969", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -41,7 +41,7 @@ use libc::{c_int, c_void, size_t};\n                not(target_os = \"android\"),\n                not(target_env = \"musl\")),\n            link(name = \"pthread\"))]\n-extern {\n+extern \"C\" {\n     fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n     fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n     fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;"}, {"sha": "1befbd61d6d44c402a67189529b45ee5a5ec6901", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -79,7 +79,7 @@ mod imp {\n     use libc;\n     use MIN_ALIGN;\n \n-    extern {\n+    extern \"C\" {\n         // Apparently android doesn't have posix_memalign\n         #[cfg(target_os = \"android\")]\n         fn memalign(align: libc::size_t, size: libc::size_t) -> *mut libc::c_void;\n@@ -180,7 +180,7 @@ mod imp {\n         } else {\n             let ptr = HeapAlloc(GetProcessHeap(), 0, (size + align) as SIZE_T) as *mut u8;\n             if ptr.is_null() {\n-                return ptr\n+                return ptr;\n             }\n             align_ptr(ptr, align)\n         }\n@@ -196,7 +196,7 @@ mod imp {\n                                   header.0 as LPVOID,\n                                   (size + align) as SIZE_T) as *mut u8;\n             if new.is_null() {\n-                return new\n+                return new;\n             }\n             align_ptr(new, align)\n         }"}, {"sha": "abc15df804d496c9389e6c95f0ebe2809171816a", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -168,8 +168,8 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let start = round_up(after_tydesc, align);\n \n-        //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n-        //       start, size, align, is_done);\n+        // debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n+        //        start, size, align, is_done);\n         if is_done {\n             ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n         }\n@@ -201,8 +201,11 @@ struct TyDesc {\n     align: usize,\n }\n \n-trait AllTypes { fn dummy(&self) { } }\n-impl<T:?Sized> AllTypes for T { }\n+trait AllTypes {\n+    fn dummy(&self) {}\n+}\n+\n+impl<T: ?Sized> AllTypes for T {}\n \n unsafe fn get_tydesc<T>() -> *const TyDesc {\n     use std::raw::TraitObject;\n@@ -624,7 +627,7 @@ mod tests {\n         for _ in 0..100000 {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!(1, 2, 3, 4, 5),\n+                array: vec![1, 2, 3, 4, 5],\n             });\n         }\n     }\n@@ -635,7 +638,7 @@ mod tests {\n         b.iter(|| {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!(1, 2, 3, 4, 5),\n+                array: vec![1, 2, 3, 4, 5],\n             })\n         })\n     }\n@@ -645,7 +648,7 @@ mod tests {\n         b.iter(|| {\n             let _: Box<_> = box Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!(1, 2, 3, 4, 5),\n+                array: vec![1, 2, 3, 4, 5],\n             };\n         })\n     }\n@@ -657,7 +660,7 @@ mod tests {\n             arena.alloc(|| {\n                 Noncopy {\n                     string: \"hello world\".to_string(),\n-                    array: vec!(1, 2, 3, 4, 5),\n+                    array: vec![1, 2, 3, 4, 5],\n                 }\n             })\n         })"}, {"sha": "06ff8581b5e6ed537b70a750feb8a743c5404b03", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 66, "deletions": 28, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -151,7 +151,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::iter::{FromIterator};\n+use core::iter::FromIterator;\n use core::mem::swap;\n use core::ptr;\n use core::fmt;\n@@ -186,7 +186,9 @@ impl<T: Clone> Clone for BinaryHeap<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BinaryHeap<T> {\n     #[inline]\n-    fn default() -> BinaryHeap<T> { BinaryHeap::new() }\n+    fn default() -> BinaryHeap<T> {\n+        BinaryHeap::new()\n+    }\n }\n \n #[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\n@@ -207,7 +209,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BinaryHeap<T> { BinaryHeap { data: vec![] } }\n+    pub fn new() -> BinaryHeap<T> {\n+        BinaryHeap { data: vec![] }\n+    }\n \n     /// Creates an empty `BinaryHeap` with a specific capacity.\n     /// This preallocates enough memory for `capacity` elements,\n@@ -296,7 +300,9 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(4);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize { self.data.capacity() }\n+    pub fn capacity(&self) -> usize {\n+        self.data.capacity()\n+    }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n@@ -419,11 +425,13 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         match self.data.get_mut(0) {\n             None => return item,\n-            Some(top) => if *top > item {\n-                swap(&mut item, top);\n-            } else {\n-                return item;\n-            },\n+            Some(top) => {\n+                if *top > item {\n+                    swap(&mut item, top);\n+                } else {\n+                    return item;\n+                }\n+            }\n         }\n \n         self.sift_down(0);\n@@ -522,7 +530,9 @@ impl<T: Ord> BinaryHeap<T> {\n \n             while hole.pos() > start {\n                 let parent = (hole.pos() - 1) / 2;\n-                if hole.element() <= hole.get(parent) { break; }\n+                if hole.element() <= hole.get(parent) {\n+                    break;\n+                }\n                 hole.move_to(parent);\n             }\n         }\n@@ -541,7 +551,9 @@ impl<T: Ord> BinaryHeap<T> {\n                     child = right;\n                 }\n                 // if we are already in order, stop.\n-                if hole.element() >= hole.get(child) { break; }\n+                if hole.element() >= hole.get(child) {\n+                    break;\n+                }\n                 hole.move_to(child);\n                 child = 2 * hole.pos() + 1;\n             }\n@@ -555,11 +567,15 @@ impl<T: Ord> BinaryHeap<T> {\n \n     /// Returns the length of the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.data.len() }\n+    pub fn len(&self) -> usize {\n+        self.data.len()\n+    }\n \n     /// Checks if the binary heap is empty.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n     ///\n@@ -575,7 +591,9 @@ impl<T: Ord> BinaryHeap<T> {\n \n     /// Drops all items from the binary heap.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.drain(); }\n+    pub fn clear(&mut self) {\n+        self.drain();\n+    }\n }\n \n /// Hole represents a hole in a slice i.e. an index without valid value\n@@ -603,7 +621,9 @@ impl<'a, T> Hole<'a, T> {\n     }\n \n     #[inline(always)]\n-    fn pos(&self) -> usize { self.pos }\n+    fn pos(&self) -> usize {\n+        self.pos\n+    }\n \n     /// Return a reference to the element removed\n     #[inline(always)]\n@@ -647,7 +667,7 @@ impl<'a, T> Drop for Hole<'a, T> {\n \n /// `BinaryHeap` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter <'a, T: 'a> {\n+pub struct Iter<'a, T: 'a> {\n     iter: slice::Iter<'a, T>,\n }\n \n@@ -664,16 +684,22 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.iter.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -690,16 +716,22 @@ impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -716,16 +748,22 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -753,7 +791,7 @@ impl<T> From<BinaryHeap<T>> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BinaryHeap<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BinaryHeap<T> {\n         BinaryHeap::from(iter.into_iter().collect::<Vec<_>>())\n     }\n }\n@@ -796,7 +834,7 @@ impl<'a, T> IntoIterator for &'a BinaryHeap<T> where T: Ord {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iterable: I) {\n         let iter = iterable.into_iter();\n         let (lower, _) = iter.size_hint();\n \n@@ -810,7 +848,7 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }"}, {"sha": "bfd4c2e96b587acc7a41513c18e7fd8706878e3c", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -28,7 +28,10 @@ use self::Cow::*;\n pub use core::borrow::{Borrow, BorrowMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B> where B: ToOwned, <B as ToOwned>::Owned: 'a {\n+impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>\n+    where B: ToOwned,\n+          <B as ToOwned>::Owned: 'a\n+{\n     fn borrow(&self) -> &B {\n         &**self\n     }\n@@ -53,7 +56,9 @@ pub trait ToOwned {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ToOwned for T where T: Clone {\n     type Owned = T;\n-    fn to_owned(&self) -> T { self.clone() }\n+    fn to_owned(&self) -> T {\n+        self.clone()\n+    }\n }\n \n /// A clone-on-write smart pointer.\n@@ -85,14 +90,16 @@ impl<T> ToOwned for T where T: Clone {\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {\n+pub enum Cow<'a, B: ?Sized + 'a>\n+    where B: ToOwned\n+{\n     /// Borrowed data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Borrowed(&'a B),\n \n     /// Owned data.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Owned(<B as ToOwned>::Owned)\n+    Owned(<B as ToOwned>::Owned),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -103,7 +110,7 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B> where B: ToOwned {\n             Owned(ref o) => {\n                 let b: &B = o.borrow();\n                 Owned(b.to_owned())\n-            },\n+            }\n         }\n     }\n }\n@@ -131,7 +138,7 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n                 *self = Owned(borrowed.to_owned());\n                 self.to_mut()\n             }\n-            Owned(ref mut owned) => owned\n+            Owned(ref mut owned) => owned,\n         }\n     }\n \n@@ -154,7 +161,7 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n     pub fn into_owned(self) -> <B as ToOwned>::Owned {\n         match self {\n             Borrowed(borrowed) => borrowed.to_owned(),\n-            Owned(owned) => owned\n+            Owned(owned) => owned,\n         }\n     }\n }\n@@ -166,7 +173,7 @@ impl<'a, B: ?Sized> Deref for Cow<'a, B> where B: ToOwned {\n     fn deref(&self) -> &B {\n         match *self {\n             Borrowed(borrowed) => borrowed,\n-            Owned(ref owned) => owned.borrow()\n+            Owned(ref owned) => owned.borrow(),\n         }\n     }\n }\n@@ -183,8 +190,9 @@ impl<'a, B: ?Sized> Ord for Cow<'a, B> where B: Ord + ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n-    B: PartialEq<C> + ToOwned, C: ToOwned,\n+impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B>\n+    where B: PartialEq<C> + ToOwned,\n+          C: ToOwned\n {\n     #[inline]\n     fn eq(&self, other: &Cow<'b, C>) -> bool {\n@@ -193,18 +201,17 @@ impl<'a, 'b, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, C>> for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned,\n-{\n+impl<'a, B: ?Sized> PartialOrd for Cow<'a, B> where B: PartialOrd + ToOwned {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n-    B: fmt::Debug + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Debug,\n+impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B>\n+    where B: fmt::Debug + ToOwned,\n+          <B as ToOwned>::Owned: fmt::Debug\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -215,9 +222,9 @@ impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n-    B: fmt::Display + ToOwned,\n-    <B as ToOwned>::Owned: fmt::Display,\n+impl<'a, B: ?Sized> fmt::Display for Cow<'a, B>\n+    where B: fmt::Display + ToOwned,\n+          <B as ToOwned>::Owned: fmt::Display\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -228,8 +235,7 @@ impl<'a, B: ?Sized> fmt::Display for Cow<'a, B> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n-{\n+impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned {\n     #[inline]\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         Hash::hash(&**self, state)\n@@ -245,7 +251,7 @@ pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n+impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B> {\n         self\n     }"}, {"sha": "08b0a39d9b0065a503cfc5f25b19d71489157a61", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 258, "deletions": 157, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -84,46 +84,46 @@ struct AbsIter<T> {\n /// An iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<Traversal<'a, K, V>>\n+    inner: AbsIter<Traversal<'a, K, V>>,\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<MutTraversal<'a, K, V>>\n+    inner: AbsIter<MutTraversal<'a, K, V>>,\n }\n \n /// An owning iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: AbsIter<MoveTraversal<K, V>>\n+    inner: AbsIter<MoveTraversal<K, V>>,\n }\n \n /// An iterator over a BTreeMap's keys.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>,\n }\n \n /// An iterator over a BTreeMap's values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>,\n }\n \n /// An iterator over a sub-range of BTreeMap's entries.\n pub struct Range<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<Traversal<'a, K, V>>\n+    inner: AbsIter<Traversal<'a, K, V>>,\n }\n \n /// A mutable iterator over a sub-range of BTreeMap's entries.\n pub struct RangeMut<'a, K: 'a, V: 'a> {\n-    inner: AbsIter<MutTraversal<'a, K, V>>\n+    inner: AbsIter<MutTraversal<'a, K, V>>,\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Entry<'a, K:'a, V:'a> {\n+pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Vacant(VacantEntry<'a, K, V>),\n@@ -135,14 +135,14 @@ pub enum Entry<'a, K:'a, V:'a> {\n \n /// A vacant Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K:'a, V:'a> {\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K:'a, V:'a> {\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n@@ -151,7 +151,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn new() -> BTreeMap<K, V> {\n-        //FIXME(Gankro): Tune this as a function of size_of<K/V>?\n+        // FIXME(Gankro): Tune this as a function of size_of<K/V>?\n         BTreeMap::with_b(6)\n     }\n \n@@ -189,7 +189,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn clear(&mut self) {\n         let b = self.b;\n         // avoid recursive destructors by manually traversing the tree\n-        for _ in mem::replace(self, BTreeMap::with_b(b)) {};\n+        for _ in mem::replace(self, BTreeMap::with_b(b)) {}\n     }\n \n     // Searching in a B-Tree is pretty straightforward.\n@@ -216,16 +216,21 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv().1),\n-                GoDown(handle) => match handle.force() {\n-                    Leaf(_) => return None,\n-                    Internal(internal_handle) => {\n-                        cur_node = internal_handle.into_edge();\n-                        continue;\n+                GoDown(handle) => {\n+                    match handle.force() {\n+                        Leaf(_) => return None,\n+                        Internal(internal_handle) => {\n+                            cur_node = internal_handle.into_edge();\n+                            continue;\n+                        }\n                     }\n                 }\n             }\n@@ -248,7 +253,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -271,18 +279,23 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n             let cur_node = temp_node;\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv_mut().1),\n-                GoDown(handle) => match handle.force() {\n-                    Leaf(_) => return None,\n-                    Internal(internal_handle) => {\n-                        temp_node = internal_handle.into_edge_mut();\n-                        continue;\n+                GoDown(handle) => {\n+                    match handle.force() {\n+                        Leaf(_) => return None,\n+                        Internal(internal_handle) => {\n+                            temp_node = internal_handle.into_edge_mut();\n+                            continue;\n+                        }\n                     }\n                 }\n             }\n@@ -366,7 +379,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                         // Perfect match, swap the values and return the old one\n                         mem::swap(handle.val_mut(), &mut value);\n                         Finished(Some(value))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         // We need to keep searching, try to get the search stack\n                         // to go down further\n@@ -448,7 +461,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -457,20 +473,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n                         Finished(Some(pusher.seal(handle).remove()))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         // We need to keep searching, try to go down the next edge\n                         match handle.force() {\n                             // We're at a leaf; the key isn't in here\n                             Leaf(_) => Finished(None),\n-                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle)),\n                         }\n                     }\n                 }\n             });\n             match result {\n                 Finished(ret) => return ret.map(|(_, v)| v),\n-                Continue(new_stack) => stack = new_stack\n+                Continue(new_stack) => stack = new_stack,\n             }\n         }\n     }\n@@ -505,7 +521,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n             inner: AbsIter {\n                 traversals: lca,\n                 size: len,\n-            }\n+            },\n         }\n     }\n }\n@@ -534,7 +550,7 @@ impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n /// return from a closure\n enum Continuation<A, B> {\n     Continue(A),\n-    Finished(B)\n+    Finished(B),\n }\n \n /// The stack module provides a safe interface for constructing and manipulating a stack of ptrs\n@@ -549,8 +565,7 @@ mod stack {\n     use super::super::node::handle;\n     use vec::Vec;\n \n-    struct InvariantLifetime<'id>(\n-        marker::PhantomData<::core::cell::Cell<&'id ()>>);\n+    struct InvariantLifetime<'id>(marker::PhantomData<::core::cell::Cell<&'id ()>>);\n \n     impl<'id> InvariantLifetime<'id> {\n         fn new() -> InvariantLifetime<'id> {\n@@ -585,7 +600,7 @@ mod stack {\n     type Stack<K, V> = Vec<StackItem<K, V>>;\n \n     /// A `PartialSearchStack` handles the construction of a search stack.\n-    pub struct PartialSearchStack<'a, K:'a, V:'a> {\n+    pub struct PartialSearchStack<'a, K: 'a, V: 'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         next: *mut Node<K, V>,\n@@ -594,7 +609,7 @@ mod stack {\n     /// A `SearchStack` represents a full path to an element or an edge of interest. It provides\n     /// methods depending on the type of what the path points to for removing an element, inserting\n     /// a new element, and manipulating to element at the top of the stack.\n-    pub struct SearchStack<'a, K:'a, V:'a, Type, NodeType> {\n+    pub struct SearchStack<'a, K: 'a, V: 'a, Type, NodeType> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         top: node::Handle<*mut Node<K, V>, Type, NodeType>,\n@@ -603,7 +618,7 @@ mod stack {\n     /// A `PartialSearchStack` that doesn't hold a reference to the next node, and is just\n     /// just waiting for a `Handle` to that next node to be pushed. See `PartialSearchStack::with`\n     /// for more details.\n-    pub struct Pusher<'id, 'a, K:'a, V:'a> {\n+    pub struct Pusher<'id, 'a, K: 'a, V: 'a> {\n         map: &'a mut BTreeMap<K, V>,\n         stack: Stack<K, V>,\n         _marker: InvariantLifetime<'id>,\n@@ -656,9 +671,8 @@ mod stack {\n         /// Pushes the requested child of the stack's current top on top of the stack. If the child\n         /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n         /// yielded.\n-        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>,\n-                                                     handle::Edge,\n-                                                     handle::Internal>)\n+        pub fn push(mut self,\n+                    mut edge: node::Handle<IdRef<'id, Node<K, V>>, handle::Edge, handle::Internal>)\n                     -> PartialSearchStack<'a, K, V> {\n             self.stack.push(edge.as_raw());\n             PartialSearchStack {\n@@ -669,9 +683,11 @@ mod stack {\n         }\n \n         /// Converts the PartialSearchStack into a SearchStack.\n-        pub fn seal<Type, NodeType>\n-                   (self, mut handle: node::Handle<IdRef<'id, Node<K, V>>, Type, NodeType>)\n-                    -> SearchStack<'a, K, V, Type, NodeType> {\n+        pub fn seal<Type, NodeType>(self,\n+                                    mut handle: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                             Type,\n+                                                             NodeType>)\n+                                    -> SearchStack<'a, K, V, Type, NodeType> {\n             SearchStack {\n                 map: self.map,\n                 stack: self.stack,\n@@ -694,9 +710,7 @@ mod stack {\n         /// Converts the stack into a mutable reference to the value it points to, with a lifetime\n         /// tied to the original tree.\n         pub fn into_top(mut self) -> &'a mut V {\n-            unsafe {\n-                &mut *(self.top.from_raw_mut().val_mut() as *mut V)\n-            }\n+            unsafe { &mut *(self.top.from_raw_mut().val_mut() as *mut V) }\n         }\n     }\n \n@@ -778,13 +792,13 @@ mod stack {\n                         return SearchStack {\n                             map: self.map,\n                             stack: self.stack,\n-                            top: leaf_handle.as_raw()\n-                        }\n+                            top: leaf_handle.as_raw(),\n+                        };\n                     }\n                     Internal(mut internal_handle) => {\n                         let mut right_handle = internal_handle.right_edge();\n \n-                        //We're not a proper leaf stack, let's get to work.\n+                        // We're not a proper leaf stack, let's get to work.\n                         self.stack.push(right_handle.as_raw());\n \n                         let mut temp_node = right_handle.edge_mut();\n@@ -800,9 +814,9 @@ mod stack {\n                                     return SearchStack {\n                                         map: self.map,\n                                         stack: self.stack,\n-                                        top: handle.as_raw()\n-                                    }\n-                                },\n+                                        top: handle.as_raw(),\n+                                    };\n+                                }\n                                 Internal(kv_handle) => {\n                                     // This node is internal, go deeper\n                                     let mut handle = kv_handle.into_left_edge();\n@@ -830,7 +844,8 @@ mod stack {\n                 self.map.length += 1;\n \n                 // Insert the key and value into the leaf at the top of the stack\n-                let (mut insertion, inserted_ptr) = self.top.from_raw_mut()\n+                let (mut insertion, inserted_ptr) = self.top\n+                                                        .from_raw_mut()\n                                                         .insert_as_leaf(key, val);\n \n                 loop {\n@@ -840,24 +855,29 @@ mod stack {\n                             // inserting now.\n                             return &mut *inserted_ptr;\n                         }\n-                        Split(key, val, right) => match self.stack.pop() {\n-                            // The last insertion triggered a split, so get the next element on the\n-                            // stack to recursively insert the split node into.\n-                            None => {\n-                                // The stack was empty; we've split the root, and need to make a\n-                                // a new one. This is done in-place because we can't move the\n-                                // root out of a reference to the tree.\n-                                Node::make_internal_root(&mut self.map.root, self.map.b,\n-                                                         key, val, right);\n-\n-                                self.map.depth += 1;\n-                                return &mut *inserted_ptr;\n-                            }\n-                            Some(mut handle) => {\n-                                // The stack wasn't empty, do the insertion and recurse\n-                                insertion = handle.from_raw_mut()\n-                                                  .insert_as_internal(key, val, right);\n-                                continue;\n+                        Split(key, val, right) => {\n+                            match self.stack.pop() {\n+                                // The last insertion triggered a split, so get the next element on\n+                                // the stack to recursively insert the split node into.\n+                                None => {\n+                                    // The stack was empty; we've split the root, and need to make a\n+                                    // a new one. This is done in-place because we can't move the\n+                                    // root out of a reference to the tree.\n+                                    Node::make_internal_root(&mut self.map.root,\n+                                                             self.map.b,\n+                                                             key,\n+                                                             val,\n+                                                             right);\n+\n+                                    self.map.depth += 1;\n+                                    return &mut *inserted_ptr;\n+                                }\n+                                Some(mut handle) => {\n+                                    // The stack wasn't empty, do the insertion and recurse\n+                                    insertion = handle.from_raw_mut()\n+                                                      .insert_as_internal(key, val, right);\n+                                    continue;\n+                                }\n                             }\n                         }\n                     }\n@@ -869,7 +889,7 @@ mod stack {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -879,7 +899,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -888,7 +908,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n-    fn extend<I: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n@@ -912,8 +932,7 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| a == b)\n+        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n@@ -945,7 +964,8 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n+    where K: Borrow<Q>,\n+          Q: Ord\n {\n     type Output = V;\n \n@@ -987,8 +1007,8 @@ enum StackOp<T> {\n     Push(T),\n     Pop,\n }\n-impl<K, V, E, T> Iterator for AbsIter<T> where\n-    T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+impl<K, V, E, T> Iterator for AbsIter<T>\n+    where T: DoubleEndedIterator<Item = TraversalItem<K, V, E>> + Traverse<E>\n {\n     type Item = (K, V);\n \n@@ -1002,23 +1022,29 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n             let op = match self.traversals.back_mut() {\n                 None => return None,\n                 // The queue wasn't empty, so continue along the node in its head\n-                Some(iter) => match iter.next() {\n-                    // The head is empty, so Pop it off and continue the process\n-                    None => Pop,\n-                    // The head yielded an edge, so make that the new head\n-                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    // The head yielded an entry, so yield that\n-                    Some(Elem(kv)) => {\n-                        self.size -= 1;\n-                        return Some(kv)\n+                Some(iter) => {\n+                    match iter.next() {\n+                        // The head is empty, so Pop it off and continue the process\n+                        None => Pop,\n+                        // The head yielded an edge, so make that the new head\n+                        Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                        // The head yielded an entry, so yield that\n+                        Some(Elem(kv)) => {\n+                            self.size -= 1;\n+                            return Some(kv);\n+                        }\n                     }\n                 }\n             };\n \n             // Handle any operation as necessary, without a conflicting borrow of the queue\n             match op {\n-                Push(item) => { self.traversals.push_back(item); },\n-                Pop => { self.traversals.pop_back(); },\n+                Push(item) => {\n+                    self.traversals.push_back(item);\n+                }\n+                Pop => {\n+                    self.traversals.pop_back();\n+                }\n             }\n         }\n     }\n@@ -1028,46 +1054,60 @@ impl<K, V, E, T> Iterator for AbsIter<T> where\n     }\n }\n \n-impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n-    T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+impl<K, V, E, T> DoubleEndedIterator for AbsIter<T>\n+    where T: DoubleEndedIterator<Item = TraversalItem<K, V, E>> + Traverse<E>\n {\n     // next_back is totally symmetric to next\n     #[inline]\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n             let op = match self.traversals.front_mut() {\n                 None => return None,\n-                Some(iter) => match iter.next_back() {\n-                    None => Pop,\n-                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    Some(Elem(kv)) => {\n-                        self.size -= 1;\n-                        return Some(kv)\n+                Some(iter) => {\n+                    match iter.next_back() {\n+                        None => Pop,\n+                        Some(Edge(next)) => Push(Traverse::traverse(next)),\n+                        Some(Elem(kv)) => {\n+                            self.size -= 1;\n+                            return Some(kv);\n+                        }\n                     }\n                 }\n             };\n \n             match op {\n-                Push(item) => { self.traversals.push_front(item); },\n-                Pop => { self.traversals.pop_front(); }\n+                Push(item) => {\n+                    self.traversals.push_front(item);\n+                }\n+                Pop => {\n+                    self.traversals.pop_front();\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, K, V> Clone for Iter<'a, K, V> {\n-    fn clone(&self) -> Iter<'a, K, V> { Iter { inner: self.inner.clone() } }\n+    fn clone(&self) -> Iter<'a, K, V> {\n+        Iter { inner: self.inner.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n@@ -1076,12 +1116,18 @@ impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n@@ -1090,70 +1136,102 @@ impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n-    fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n-    fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(K, V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n impl<'a, K, V> Clone for Keys<'a, K, V> {\n-    fn clone(&self) -> Keys<'a, K, V> { Keys { inner: self.inner.clone() } }\n+    fn clone(&self) -> Keys<'a, K, V> {\n+        Keys { inner: self.inner.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n-    fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a K)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n impl<'a, K, V> Clone for Values<'a, K, V> {\n-    fn clone(&self) -> Values<'a, K, V> { Values { inner: self.inner.clone() } }\n+    fn clone(&self) -> Values<'a, K, V> {\n+        Values { inner: self.inner.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n-    fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn next(&mut self) -> Option<(&'a V)> {\n+        self.inner.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a V)> {\n+        self.inner.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n impl<'a, K, V> Clone for Range<'a, K, V> {\n-    fn clone(&self) -> Range<'a, K, V> { Range { inner: self.inner.clone() } }\n+    fn clone(&self) -> Range<'a, K, V> {\n+        Range { inner: self.inner.clone() }\n+    }\n }\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next()\n+    }\n }\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next_back()\n+    }\n }\n \n impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next()\n+    }\n }\n impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n-    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next_back()\n+    }\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n@@ -1251,7 +1329,7 @@ impl<K, V> BTreeMap<K, V> {\n             inner: AbsIter {\n                 traversals: lca,\n                 size: len,\n-            }\n+            },\n         }\n     }\n \n@@ -1283,7 +1361,7 @@ impl<K, V> BTreeMap<K, V> {\n             inner: AbsIter {\n                 traversals: lca,\n                 size: len,\n-            }\n+            },\n         }\n     }\n \n@@ -1303,7 +1381,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        fn first<A, B>((a, _): (A, B)) -> A {\n+            a\n+        }\n         let first: fn((&'a K, &'a V)) -> &'a K = first; // coerce to fn pointer\n \n         Keys { inner: self.iter().map(first) }\n@@ -1325,7 +1405,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n+        fn second<A, B>((_, b): (A, B)) -> B {\n+            b\n+        }\n         let second: fn((&'a K, &'a V)) -> &'a V = second; // coerce to fn pointer\n \n         Values { inner: self.iter().map(second) }\n@@ -1344,7 +1426,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.length }\n+    pub fn len(&self) -> usize {\n+        self.length\n+    }\n \n     /// Returns true if the map contains no elements.\n     ///\n@@ -1359,7 +1443,9 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n }\n \n macro_rules! range_impl {\n@@ -1518,12 +1604,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&self, min: Bound<&Min>,\n+    pub fn range<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&self,\n+                                                               min: Bound<&Min>,\n                                                                max: Bound<&Max>)\n-        -> Range<K, V> where\n-        K: Borrow<Min> + Borrow<Max>,\n+                                                               -> Range<K, V>\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n-        range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n+        range_impl!(&self.root,\n+                    min,\n+                    max,\n+                    as_slices_internal,\n+                    iter,\n+                    Range,\n+                    edges,\n+                    [])\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map, starting\n@@ -1552,13 +1646,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range_mut<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&mut self, min: Bound<&Min>,\n+    pub fn range_mut<Min: ?Sized + Ord = K, Max: ?Sized + Ord = K>(&mut self,\n+                                                                   min: Bound<&Min>,\n                                                                    max: Bound<&Max>)\n-        -> RangeMut<K, V> where\n-        K: Borrow<Min> + Borrow<Max>,\n+                                                                   -> RangeMut<K, V>\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n-        range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n-                                                                      edges_mut, [mut])\n+        range_impl!(&mut self.root,\n+                    min,\n+                    max,\n+                    as_slices_internal_mut,\n+                    iter_mut,\n+                    RangeMut,\n+                    edges_mut,\n+                    [mut])\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n@@ -1586,23 +1687,18 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n-                        Finished(Occupied(OccupiedEntry {\n-                            stack: pusher.seal(handle)\n-                        }))\n-                    },\n+                        Finished(Occupied(OccupiedEntry { stack: pusher.seal(handle) }))\n+                    }\n                     GoDown(handle) => {\n                         match handle.force() {\n                             Leaf(leaf_handle) => {\n                                 Finished(Vacant(VacantEntry {\n                                     stack: pusher.seal(leaf_handle),\n                                     key: key,\n                                 }))\n-                            },\n+                            }\n                             Internal(internal_handle) => {\n-                                Continue((\n-                                    pusher.push(internal_handle),\n-                                    key\n-                                ))\n+                                Continue((pusher.push(internal_handle), key))\n                             }\n                         }\n                     }\n@@ -1619,19 +1715,24 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Ord, Q: Ord {\n+impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n+    where K: Borrow<Q> + Ord,\n+          Q: Ord\n+{\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n                 Found(handle) => return Some(handle.into_kv().0),\n-                GoDown(handle) => match handle.force() {\n-                    Leaf(_) => return None,\n-                    Internal(internal_handle) => {\n-                        cur_node = internal_handle.into_edge();\n-                        continue;\n+                GoDown(handle) => {\n+                    match handle.force() {\n+                        Leaf(_) => return None,\n+                        Internal(internal_handle) => {\n+                            cur_node = internal_handle.into_edge();\n+                            continue;\n+                        }\n                     }\n                 }\n             }\n@@ -1648,20 +1749,20 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Or\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n                         Finished(Some(pusher.seal(handle).remove()))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         // We need to keep searching, try to go down the next edge\n                         match handle.force() {\n                             // We're at a leaf; the key isn't in here\n                             Leaf(_) => Finished(None),\n-                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle)),\n                         }\n                     }\n                 }\n             });\n             match result {\n                 Finished(ret) => return ret.map(|(k, _)| k),\n-                Continue(new_stack) => stack = new_stack\n+                Continue(new_stack) => stack = new_stack,\n             }\n         }\n     }\n@@ -1677,7 +1778,7 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Or\n                     Found(mut handle) => {\n                         mem::swap(handle.key_mut(), &mut key);\n                         Finished(Some(key))\n-                    },\n+                    }\n                     GoDown(handle) => {\n                         match handle.force() {\n                             Leaf(leaf_handle) => {"}, {"sha": "26479b3f559b94a9f94733c0edeb36fb0734b279", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 165, "deletions": 168, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -122,7 +122,8 @@ fn test_rounding() {\n // from the start of a mallocated array.\n #[inline]\n fn calculate_offsets(keys_size: usize,\n-                     vals_size: usize, vals_align: usize,\n+                     vals_size: usize,\n+                     vals_align: usize,\n                      edges_align: usize)\n                      -> (usize, usize) {\n     let vals_offset = round_up_to_next(keys_size, vals_align);\n@@ -136,13 +137,14 @@ fn calculate_offsets(keys_size: usize,\n // Returns a tuple of (minimum required alignment, array_size),\n // from the start of a mallocated array.\n #[inline]\n-fn calculate_allocation(keys_size: usize, keys_align: usize,\n-                        vals_size: usize, vals_align: usize,\n-                        edges_size: usize, edges_align: usize)\n+fn calculate_allocation(keys_size: usize,\n+                        keys_align: usize,\n+                        vals_size: usize,\n+                        vals_align: usize,\n+                        edges_size: usize,\n+                        edges_align: usize)\n                         -> (usize, usize) {\n-    let (_, edges_offset) = calculate_offsets(keys_size,\n-                                              vals_size, vals_align,\n-                                                         edges_align);\n+    let (_, edges_offset) = calculate_offsets(keys_size, vals_size, vals_align, edges_align);\n     let end_of_edges = edges_offset + edges_size;\n \n     let min_align = cmp::max(keys_align, cmp::max(vals_align, edges_align));\n@@ -171,14 +173,16 @@ fn calculate_allocation_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize,\n             (0, 1)\n         }\n     } else {\n-        ((capacity + 1) * mem::size_of::<Node<K, V>>(), mem::align_of::<Node<K, V>>())\n+        ((capacity + 1) * mem::size_of::<Node<K, V>>(),\n+         mem::align_of::<Node<K, V>>())\n     };\n \n-    calculate_allocation(\n-            keys_size, keys_align,\n-            vals_size, vals_align,\n-            edges_size, edges_align\n-    )\n+    calculate_allocation(keys_size,\n+                         keys_align,\n+                         vals_size,\n+                         vals_align,\n+                         edges_size,\n+                         edges_align)\n }\n \n fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, usize) {\n@@ -191,11 +195,7 @@ fn calculate_offsets_generic<K, V>(capacity: usize, is_leaf: bool) -> (usize, us\n         mem::align_of::<Node<K, V>>()\n     };\n \n-    calculate_offsets(\n-            keys_size,\n-            vals_size, vals_align,\n-                       edges_align\n-    )\n+    calculate_offsets(keys_size, vals_size, vals_align, edges_align)\n }\n \n /// An iterator over a slice that owns the elements of the slice but not the allocation.\n@@ -285,8 +285,7 @@ impl<K, V> Drop for Node<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         if self.keys.is_null() ||\n-            (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE })\n-        {\n+           (unsafe { self.keys.get() as *const K as usize == mem::POST_DROP_USIZE }) {\n             // Since we have #[unsafe_no_drop_flag], we have to watch\n             // out for the sentinel value being stored in self.keys. (Using\n             // null is technically a violation of the `Unique`\n@@ -314,7 +313,9 @@ impl<K, V> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, false);\n \n         let buffer = heap::allocate(size, alignment);\n-        if buffer.is_null() { ::alloc::oom(); }\n+        if buffer.is_null() {\n+            ::alloc::oom();\n+        }\n \n         let (vals_offset, edges_offset) = calculate_offsets_generic::<K, V>(capacity, false);\n \n@@ -332,7 +333,9 @@ impl<K, V> Node<K, V> {\n         let (alignment, size) = calculate_allocation_generic::<K, V>(capacity, true);\n \n         let buffer = unsafe { heap::allocate(size, alignment) };\n-        if buffer.is_null() { ::alloc::oom(); }\n+        if buffer.is_null() {\n+            ::alloc::oom();\n+        }\n \n         let (vals_offset, _) = calculate_offsets_generic::<K, V>(capacity, true);\n \n@@ -346,25 +349,25 @@ impl<K, V> Node<K, V> {\n     }\n \n     unsafe fn destroy(&mut self) {\n-        let (alignment, size) =\n-                calculate_allocation_generic::<K, V>(self.capacity(), self.is_leaf());\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(self.capacity(),\n+                                                                     self.is_leaf());\n         heap::deallocate(*self.keys as *mut u8, size, alignment);\n     }\n \n     #[inline]\n     pub fn as_slices<'a>(&'a self) -> (&'a [K], &'a [V]) {\n-        unsafe {(\n-            slice::from_raw_parts(*self.keys, self.len()),\n-            slice::from_raw_parts(*self.vals, self.len()),\n-        )}\n+        unsafe {\n+            (slice::from_raw_parts(*self.keys, self.len()),\n+             slice::from_raw_parts(*self.vals, self.len()))\n+        }\n     }\n \n     #[inline]\n     pub fn as_slices_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V]) {\n-        unsafe {(\n-            slice::from_raw_parts_mut(*self.keys, self.len()),\n-            slice::from_raw_parts_mut(*self.vals, self.len()),\n-        )}\n+        unsafe {\n+            (slice::from_raw_parts_mut(*self.keys, self.len()),\n+             slice::from_raw_parts_mut(*self.vals, self.len()))\n+        }\n     }\n \n     #[inline]\n@@ -376,8 +379,8 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 let data = match self.edges {\n-                    None => heap::EMPTY as *const Node<K,V>,\n-                    Some(ref p) => **p as *const Node<K,V>,\n+                    None => heap::EMPTY as *const Node<K, V>,\n+                    Some(ref p) => **p as *const Node<K, V>,\n                 };\n                 slice::from_raw_parts(data, self.len() + 1)\n             }\n@@ -403,8 +406,8 @@ impl<K, V> Node<K, V> {\n         } else {\n             unsafe {\n                 let data = match self.edges {\n-                    None => heap::EMPTY as *mut Node<K,V>,\n-                    Some(ref mut p) => **p as *mut Node<K,V>,\n+                    None => heap::EMPTY as *mut Node<K, V>,\n+                    Some(ref mut p) => **p as *mut Node<K, V>,\n                 };\n                 slice::from_raw_parts_mut(data, len + 1)\n             }\n@@ -573,29 +576,49 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n-                  -> SearchResult<NodeRef> where K: Borrow<Q>, Q: Ord {\n+    pub fn search<Q: ?Sized, NodeRef: Deref<Target = Node<K, V>>>(node: NodeRef,\n+                                                                  key: &Q)\n+                                                                  -> SearchResult<NodeRef>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for usizes.\n         match node.as_slices_internal().search_linear(key) {\n-            (index, true) => Found(Handle { node: node, index: index, marker: PhantomData }),\n-            (index, false) => GoDown(Handle { node: node, index: index, marker: PhantomData }),\n+            (index, true) => {\n+                Found(Handle {\n+                    node: node,\n+                    index: index,\n+                    marker: PhantomData,\n+                })\n+            }\n+            (index, false) => {\n+                GoDown(Handle {\n+                    node: node,\n+                    index: index,\n+                    marker: PhantomData,\n+                })\n+            }\n         }\n     }\n }\n \n // Public interface\n-impl <K, V> Node<K, V> {\n+impl<K, V> Node<K, V> {\n     /// Make a leaf root from scratch\n     pub fn make_leaf_root(b: usize) -> Node<K, V> {\n         Node::new_leaf(capacity_from_b(b))\n     }\n \n     /// Make an internal root and swap it with an old root\n-    pub fn make_internal_root(left_and_out: &mut Node<K,V>, b: usize, key: K, value: V,\n-            right: Node<K,V>) {\n-        let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n+    pub fn make_internal_root(left_and_out: &mut Node<K, V>,\n+                              b: usize,\n+                              key: K,\n+                              value: V,\n+                              right: Node<K, V>) {\n+        let node = mem::replace(left_and_out,\n+                                unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n         unsafe {\n             ptr::write(left_and_out.keys_mut().get_unchecked_mut(0), key);\n@@ -611,7 +634,9 @@ impl <K, V> Node<K, V> {\n     }\n \n     /// Does the node not contain any key-value pairs\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// How many key-value pairs the node can fit\n     pub fn capacity(&self) -> usize {\n@@ -634,7 +659,7 @@ impl <K, V> Node<K, V> {\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n+impl<K, V, NodeRef: Deref<Target = Node<K, V>>, Type, NodeType> Handle<NodeRef, Type, NodeType> {\n     /// Returns a reference to the node that contains the pointed-to edge or key/value pair. This\n     /// is very different from `edge` and `edge_mut` because those return children of the node\n     /// returned by `node`.\n@@ -643,8 +668,8 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type, NodeType> Handle<NodeRef, Ty\n     }\n }\n \n-impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef, Type, NodeType> Handle<NodeRef, Type, NodeType>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Converts a handle into one that stores the same information using a raw pointer. This can\n     /// be useful in conjunction with `from_raw` when the type system is insufficient for\n@@ -687,9 +712,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n     /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n     /// making it more suitable for moving down a chain of nodes.\n     pub fn into_edge(self) -> &'a Node<K, V> {\n-        unsafe {\n-            self.node.edges().get_unchecked(self.index)\n-        }\n+        unsafe { self.node.edges().get_unchecked(self.index) }\n     }\n }\n \n@@ -698,13 +721,11 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     /// because the returned pointer has a larger lifetime than what would be returned by\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n     pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n-        unsafe {\n-            self.node.edges_mut().get_unchecked_mut(self.index)\n-        }\n+        unsafe { self.node.edges_mut().get_unchecked_mut(self.index) }\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n+impl<K, V, NodeRef: Deref<Target = Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     // This doesn't exist because there are no uses for it,\n     // but is fine to add, analogous to edge_mut.\n     //\n@@ -715,10 +736,12 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>> Handle<NodeRef, handle::Edge, hand\n \n pub enum ForceResult<NodeRef, Type> {\n     Leaf(Handle<NodeRef, Type, handle::Leaf>),\n-    Internal(Handle<NodeRef, Type, handle::Internal>)\n+    Internal(Handle<NodeRef, Type, handle::Internal>),\n }\n \n-impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n+impl<K, V, NodeRef: Deref<Target = Node<K, V>>, Type>\n+    Handle<NodeRef, Type, handle::LeafOrInternal>\n+{\n     /// Figure out whether this handle is pointing to something in a leaf node or to something in\n     /// an internal node, clarifying the type according to the result.\n     pub fn force(self) -> ForceResult<NodeRef, Type> {\n@@ -737,16 +760,15 @@ impl<K, V, NodeRef: Deref<Target=Node<K, V>>, Type> Handle<NodeRef, Type, handle\n         }\n     }\n }\n-impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n     /// Returns a *mut V to the inserted value, because the caller may want this when\n     /// they're done mutating the tree, but we don't want to borrow anything for now.\n-    pub fn insert_as_leaf(mut self, key: K, value: V) ->\n-            (InsertionResult<K, V>, *mut V) {\n+    pub fn insert_as_leaf(mut self, key: K, value: V) -> (InsertionResult<K, V>, *mut V) {\n         if !self.node.is_full() {\n             // The element can fit, just insert it\n             (Fit, unsafe { self.node.insert_kv(self.index, key, value) as *mut _ })\n@@ -771,21 +793,22 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Leaf> where\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n-        unsafe {\n-            self.node.edges_mut().get_unchecked_mut(self.index)\n-        }\n+        unsafe { self.node.edges_mut().get_unchecked_mut(self.index) }\n     }\n \n     /// Tries to insert this key-value pair at the given index in this internal node\n     /// If the node is full, we have to split it.\n-    pub fn insert_as_internal(mut self, key: K, value: V, right: Node<K, V>)\n-            -> InsertionResult<K, V> {\n+    pub fn insert_as_internal(mut self,\n+                              key: K,\n+                              value: V,\n+                              right: Node<K, V>)\n+                              -> InsertionResult<K, V> {\n         if !self.node.is_full() {\n             // The element can fit, just insert it\n             unsafe {\n@@ -856,8 +879,8 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n     }\n }\n \n-impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::Edge, NodeType>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n     /// This is unsafe because the handle might point to the first edge in the node, which has no\n@@ -889,10 +912,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n         let (keys, vals) = self.node.as_slices();\n         unsafe {\n-            (\n-                keys.get_unchecked(self.index),\n-                vals.get_unchecked(self.index)\n-            )\n+            (keys.get_unchecked(self.index),\n+             vals.get_unchecked(self.index))\n         }\n     }\n }\n@@ -904,10 +925,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n         let (keys, vals) = self.node.as_slices_mut();\n         unsafe {\n-            (\n-                keys.get_unchecked_mut(self.index),\n-                vals.get_unchecked_mut(self.index)\n-            )\n+            (keys.get_unchecked_mut(self.index),\n+             vals.get_unchecked_mut(self.index))\n         }\n     }\n \n@@ -923,8 +942,10 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target=Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n-                                                                         NodeType> {\n+\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target = Node<K, V>> + 'a, NodeType> Handle<NodeRef,\n+                                                                                  handle::KV,\n+                                                                                  NodeType> {\n     // These are fine to include, but are currently unneeded.\n     //\n     // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n@@ -942,8 +963,8 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Target=Node<K, V>> + 'a, NodeType> Handle<\n     // }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n-    NodeRef: 'a + Deref<Target=Node<K, V>> + DerefMut,\n+impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n+    where NodeRef: 'a + Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n@@ -960,8 +981,8 @@ impl<'a, K: 'a, V: 'a, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n     }\n }\n \n-impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n     /// to by this handle.\n@@ -984,8 +1005,8 @@ impl<K, V, NodeRef, NodeType> Handle<NodeRef, handle::KV, NodeType> where\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut,\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Removes the key/value pair at the handle's location.\n     ///\n@@ -997,8 +1018,8 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Leaf> where\n     }\n }\n \n-impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where\n-    NodeRef: Deref<Target=Node<K, V>> + DerefMut\n+impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal>\n+    where NodeRef: Deref<Target = Node<K, V>> + DerefMut\n {\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n@@ -1071,7 +1092,8 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::KV, handle::Internal> where\n         let right = self.node.remove_edge(self.index + 1);\n \n         // Give left right's stuff.\n-        self.left_edge().edge_mut()\n+        self.left_edge()\n+            .edge_mut()\n             .absorb(key, val, right);\n     }\n }\n@@ -1082,8 +1104,9 @@ impl<K, V> Node<K, V> {\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self, index: usize) -> Handle<&mut Node<K, V>, handle::KV,\n-                                                       handle::LeafOrInternal> {\n+    pub fn kv_handle(&mut self,\n+                     index: usize)\n+                     -> Handle<&mut Node<K, V>, handle::KV, handle::LeafOrInternal> {\n         // Necessary for correctness, but in a private module\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n         Handle {\n@@ -1111,7 +1134,7 @@ impl<K, V> Node<K, V> {\n \n                     ptr: Unique::new(*self.keys as *mut u8),\n                     capacity: self.capacity(),\n-                    is_leaf: self.is_leaf()\n+                    is_leaf: self.is_leaf(),\n                 },\n                 head_is_edge: true,\n                 tail_is_edge: true,\n@@ -1160,16 +1183,12 @@ impl<K, V> Node<K, V> {\n     // This must be followed by insert_edge on an internal node.\n     #[inline]\n     unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n-        ptr::copy(\n-            self.keys().as_ptr().offset(index as isize),\n-            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n-            self.len() - index\n-        );\n-        ptr::copy(\n-            self.vals().as_ptr().offset(index as isize),\n-            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n-            self.len() - index\n-        );\n+        ptr::copy(self.keys().as_ptr().offset(index as isize),\n+                  self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n+                  self.len() - index);\n+        ptr::copy(self.vals().as_ptr().offset(index as isize),\n+                  self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n+                  self.len() - index);\n \n         ptr::write(self.keys_mut().get_unchecked_mut(index), key);\n         ptr::write(self.vals_mut().get_unchecked_mut(index), val);\n@@ -1182,11 +1201,9 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to insert_kv.\n     #[inline]\n     unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n-        ptr::copy(\n-            self.edges().as_ptr().offset(index as isize),\n-            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n-            self.len() - index\n-        );\n+        ptr::copy(self.edges().as_ptr().offset(index as isize),\n+                  self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n+                  self.len() - index);\n         ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n     }\n \n@@ -1215,16 +1232,12 @@ impl<K, V> Node<K, V> {\n         let key = ptr::read(self.keys().get_unchecked(index));\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n-        ptr::copy(\n-            self.keys().as_ptr().offset(index as isize + 1),\n-            self.keys_mut().as_mut_ptr().offset(index as isize),\n-            self.len() - index - 1\n-        );\n-        ptr::copy(\n-            self.vals().as_ptr().offset(index as isize + 1),\n-            self.vals_mut().as_mut_ptr().offset(index as isize),\n-            self.len() - index - 1\n-        );\n+        ptr::copy(self.keys().as_ptr().offset(index as isize + 1),\n+                  self.keys_mut().as_mut_ptr().offset(index as isize),\n+                  self.len() - index - 1);\n+        ptr::copy(self.vals().as_ptr().offset(index as isize + 1),\n+                  self.vals_mut().as_mut_ptr().offset(index as isize),\n+                  self.len() - index - 1);\n \n         self._len -= 1;\n \n@@ -1236,12 +1249,10 @@ impl<K, V> Node<K, V> {\n     unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n-        ptr::copy(\n-            self.edges().as_ptr().offset(index as isize + 1),\n-            self.edges_mut().as_mut_ptr().offset(index as isize),\n-            // index can be == len+1, so do the +1 first to avoid underflow.\n-            (self.len() + 1) - index\n-        );\n+        ptr::copy(self.edges().as_ptr().offset(index as isize + 1),\n+                  self.edges_mut().as_mut_ptr().offset(index as isize),\n+                  // index can be == len+1, so do the +1 first to avoid underflow.\n+                  (self.len() + 1) - index);\n \n         edge\n     }\n@@ -1264,22 +1275,16 @@ impl<K, V> Node<K, V> {\n         unsafe {\n             right._len = self.len() / 2;\n             let right_offset = self.len() - right.len();\n-            ptr::copy_nonoverlapping(\n-                self.keys().as_ptr().offset(right_offset as isize),\n-                right.keys_mut().as_mut_ptr(),\n-                right.len()\n-            );\n-            ptr::copy_nonoverlapping(\n-                self.vals().as_ptr().offset(right_offset as isize),\n-                right.vals_mut().as_mut_ptr(),\n-                right.len()\n-            );\n+            ptr::copy_nonoverlapping(self.keys().as_ptr().offset(right_offset as isize),\n+                                     right.keys_mut().as_mut_ptr(),\n+                                     right.len());\n+            ptr::copy_nonoverlapping(self.vals().as_ptr().offset(right_offset as isize),\n+                                     right.vals_mut().as_mut_ptr(),\n+                                     right.len());\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping(\n-                    self.edges().as_ptr().offset(right_offset as isize),\n-                    right.edges_mut().as_mut_ptr(),\n-                    right.len() + 1\n-                );\n+                ptr::copy_nonoverlapping(self.edges().as_ptr().offset(right_offset as isize),\n+                                         right.edges_mut().as_mut_ptr(),\n+                                         right.len() + 1);\n             }\n \n             let key = ptr::read(self.keys().get_unchecked(right_offset - 1));\n@@ -1305,22 +1310,18 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n-            ptr::copy_nonoverlapping(\n-                right.keys().as_ptr(),\n-                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                right.len()\n-            );\n-            ptr::copy_nonoverlapping(\n-                right.vals().as_ptr(),\n-                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                right.len()\n-            );\n+            ptr::copy_nonoverlapping(right.keys().as_ptr(),\n+                                     self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n+                                     right.len());\n+            ptr::copy_nonoverlapping(right.vals().as_ptr(),\n+                                     self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n+                                     right.len());\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping(\n-                    right.edges().as_ptr(),\n-                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n-                    right.len() + 1\n-                );\n+                ptr::copy_nonoverlapping(right.edges().as_ptr(),\n+                                         self.edges_mut()\n+                                             .as_mut_ptr()\n+                                             .offset(old_len as isize + 1),\n+                                         right.len() + 1);\n             }\n \n             right.destroy();\n@@ -1382,7 +1383,7 @@ struct MoveTraversalImpl<K, V> {\n     // For deallocation when we are done iterating.\n     ptr: Unique<u8>,\n     capacity: usize,\n-    is_leaf: bool\n+    is_leaf: bool,\n }\n \n unsafe impl<K: Sync, V: Sync> Sync for MoveTraversalImpl<K, V> {}\n@@ -1395,14 +1396,14 @@ impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n     fn next_kv(&mut self) -> Option<(K, V)> {\n         match (self.keys.next(), self.vals.next()) {\n             (Some(k), Some(v)) => Some((k, v)),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n     fn next_kv_back(&mut self) -> Option<(K, V)> {\n         match (self.keys.next_back(), self.vals.next_back()) {\n             (Some(k), Some(v)) => Some((k, v)),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -1428,8 +1429,7 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n         for _ in self.vals.by_ref() {}\n         for _ in self.edges.by_ref() {}\n \n-        let (alignment, size) =\n-                calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n+        let (alignment, size) = calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n         unsafe { heap::deallocate(*self.ptr, size, alignment) };\n     }\n }\n@@ -1467,27 +1467,24 @@ pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n \n impl<K, V, E, Impl> Iterator for AbsTraversal<Impl>\n-        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+    where Impl: TraversalImpl<Item = (K, V), Edge = E>\n+{\n     type Item = TraversalItem<K, V, E>;\n \n     fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        self.next_edge_item().map(Edge).or_else(||\n-            self.next_kv_item().map(Elem)\n-        )\n+        self.next_edge_item().map(Edge).or_else(|| self.next_kv_item().map(Elem))\n     }\n }\n \n impl<K, V, E, Impl> DoubleEndedIterator for AbsTraversal<Impl>\n-        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+    where Impl: TraversalImpl<Item = (K, V), Edge = E>\n+{\n     fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        self.next_edge_item_back().map(Edge).or_else(||\n-            self.next_kv_item_back().map(Elem)\n-        )\n+        self.next_edge_item_back().map(Edge).or_else(|| self.next_kv_item_back().map(Elem))\n     }\n }\n \n-impl<K, V, E, Impl> AbsTraversal<Impl>\n-        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+impl<K, V, E, Impl> AbsTraversal<Impl> where Impl: TraversalImpl<Item = (K, V), Edge = E> {\n     /// Advances the iterator and returns the item if it's an edge. Returns None\n     /// and does nothing if the first item is not an edge.\n     pub fn next_edge_item(&mut self) -> Option<E> {"}, {"sha": "8d741f9e34a1418503b1b3a11c4c38453e516816", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 143, "deletions": 61, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -34,51 +34,51 @@ use Bound;\n /// normally only possible through `Cell`, `RefCell`, global state, I/O, or unsafe code.\n #[derive(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BTreeSet<T>{\n+pub struct BTreeSet<T> {\n     map: BTreeMap<T, ()>,\n }\n \n /// An iterator over a BTreeSet's items.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    iter: Keys<'a, T, ()>\n+    iter: Keys<'a, T, ()>,\n }\n \n /// An owning iterator over a BTreeSet's items.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    iter: Map<::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n+    iter: Map<::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>,\n }\n \n /// An iterator over a sub-range of BTreeSet's items.\n pub struct Range<'a, T: 'a> {\n-    iter: Map<::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n+    iter: Map<::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>,\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Difference<'a, T:'a> {\n+pub struct Difference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T:'a> {\n+pub struct SymmetricDifference<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Intersection<'a, T:'a> {\n+pub struct Intersection<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T:'a> {\n+pub struct Union<'a, T: 'a> {\n     a: Peekable<Iter<'a, T>>,\n     b: Peekable<Iter<'a, T>>,\n }\n@@ -161,12 +161,15 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_range\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27787\")]\n-    pub fn range<'a, Min: ?Sized + Ord = T, Max: ?Sized + Ord = T>(&'a self, min: Bound<&Min>,\n+    pub fn range<'a, Min: ?Sized + Ord = T, Max: ?Sized + Ord = T>(&'a self,\n+                                                                   min: Bound<&Min>,\n                                                                    max: Bound<&Max>)\n-        -> Range<'a, T> where\n-        T: Borrow<Min> + Borrow<Max>,\n+                                                                   -> Range<'a, T>\n+        where T: Borrow<Min> + Borrow<Max>\n     {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        fn first<A, B>((a, _): (A, B)) -> A {\n+            a\n+        }\n         let first: fn((&'a T, &'a ())) -> &'a T = first; // coerce to fn pointer\n \n         Range { iter: self.map.range(min, max).map(first) }\n@@ -194,7 +197,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        Difference{a: self.iter().peekable(), b: other.iter().peekable()}\n+        Difference {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Visits the values representing the symmetric difference, in ascending order.\n@@ -216,9 +222,13 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> SymmetricDifference<'a, T> {\n-        SymmetricDifference{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn symmetric_difference<'a>(&'a self,\n+                                    other: &'a BTreeSet<T>)\n+                                    -> SymmetricDifference<'a, T> {\n+        SymmetricDifference {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Visits the values representing the intersection, in ascending order.\n@@ -240,9 +250,11 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n-        -> Intersection<'a, T> {\n-        Intersection{a: self.iter().peekable(), b: other.iter().peekable()}\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n+        Intersection {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Visits the values representing the union, in ascending order.\n@@ -263,7 +275,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union{a: self.iter().peekable(), b: other.iter().peekable()}\n+        Union {\n+            a: self.iter().peekable(),\n+            b: other.iter().peekable(),\n+        }\n     }\n \n     /// Returns the number of elements in the set.\n@@ -279,7 +294,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.map.len() }\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n \n     /// Returns true if the set contains no elements.\n     ///\n@@ -294,7 +311,9 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Clears the set, removing all values.\n     ///\n@@ -329,7 +348,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.map.contains_key(value)\n     }\n \n@@ -339,7 +361,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n     #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n-    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T> where T: Borrow<Q>, Q: Ord {\n+    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         Recover::get(&self.map, value)\n     }\n \n@@ -482,7 +507,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.map.remove(value).is_some()\n     }\n \n@@ -492,14 +520,17 @@ impl<T: Ord> BTreeSet<T> {\n     /// but the ordering on the borrowed form *must* match the\n     /// ordering on the value type.\n     #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n-    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T> where T: Borrow<Q>, Q: Ord {\n+    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n+        where T: Borrow<Q>,\n+              Q: Ord\n+    {\n         Recover::take(&mut self.map, value)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> BTreeSet<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n         set.extend(iter);\n         set\n@@ -524,7 +555,9 @@ impl<T> IntoIterator for BTreeSet<T> {\n     /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        fn first<A, B>((a, _): (A, B)) -> A {\n+            a\n+        }\n         let first: fn((T, ())) -> T = first; // coerce to fn pointer\n \n         IntoIter { iter: self.map.into_iter().map(first) }\n@@ -544,7 +577,7 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: IntoIterator<Item=T>>(&mut self, iter: Iter) {\n+    fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }\n@@ -553,7 +586,7 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n@@ -665,18 +698,26 @@ impl<T: Debug> Debug for BTreeSet<T> {\n }\n \n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> { Iter { iter: self.iter.clone() } }\n+    fn clone(&self) -> Iter<'a, T> {\n+        Iter { iter: self.iter.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n-    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.iter.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n@@ -686,42 +727,56 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n impl<T> Iterator for IntoIter<T> {\n     type Item = T;\n \n-    fn next(&mut self) -> Option<T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n-    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n impl<'a, T> Clone for Range<'a, T> {\n-    fn clone(&self) -> Range<'a, T> { Range { iter: self.iter.clone() } }\n+    fn clone(&self) -> Range<'a, T> {\n+        Range { iter: self.iter.clone() }\n+    }\n }\n impl<'a, T> Iterator for Range<'a, T> {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n }\n impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n-    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        self.iter.next_back()\n+    }\n }\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n-                        short: Ordering, long: Ordering) -> Ordering {\n+fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n-        (None    , _       ) => short,\n-        (_       , None    ) => long,\n+        (None, _) => short,\n+        (_, None) => long,\n         (Some(x1), Some(y1)) => x1.cmp(y1),\n     }\n }\n \n impl<'a, T> Clone for Difference<'a, T> {\n     fn clone(&self) -> Difference<'a, T> {\n-        Difference { a: self.a.clone(), b: self.b.clone() }\n+        Difference {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -731,17 +786,25 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n-                Greater => { self.b.next(); }\n+                Less => return self.a.next(),\n+                Equal => {\n+                    self.a.next();\n+                    self.b.next();\n+                }\n+                Greater => {\n+                    self.b.next();\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, T> Clone for SymmetricDifference<'a, T> {\n     fn clone(&self) -> SymmetricDifference<'a, T> {\n-        SymmetricDifference { a: self.a.clone(), b: self.b.clone() }\n+        SymmetricDifference {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -751,8 +814,11 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.a.next(); self.b.next(); }\n+                Less => return self.a.next(),\n+                Equal => {\n+                    self.a.next();\n+                    self.b.next();\n+                }\n                 Greater => return self.b.next(),\n             }\n         }\n@@ -761,7 +827,10 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n impl<'a, T> Clone for Intersection<'a, T> {\n     fn clone(&self) -> Intersection<'a, T> {\n-        Intersection { a: self.a.clone(), b: self.b.clone() }\n+        Intersection {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -771,23 +840,33 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None    , _       ) => None,\n-                (_       , None    ) => None,\n+                (None, _) => None,\n+                (_, None) => None,\n                 (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n             };\n             match o_cmp {\n-                None          => return None,\n-                Some(Less)    => { self.a.next(); }\n-                Some(Equal)   => { self.b.next(); return self.a.next() }\n-                Some(Greater) => { self.b.next(); }\n+                None => return None,\n+                Some(Less) => {\n+                    self.a.next();\n+                }\n+                Some(Equal) => {\n+                    self.b.next();\n+                    return self.a.next();\n+                }\n+                Some(Greater) => {\n+                    self.b.next();\n+                }\n             }\n         }\n     }\n }\n \n impl<'a, T> Clone for Union<'a, T> {\n     fn clone(&self) -> Union<'a, T> {\n-        Union { a: self.a.clone(), b: self.b.clone() }\n+        Union {\n+            a: self.a.clone(),\n+            b: self.b.clone(),\n+        }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -797,8 +876,11 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less    => return self.a.next(),\n-                Equal   => { self.b.next(); return self.a.next() }\n+                Less => return self.a.next(),\n+                Equal => {\n+                    self.b.next();\n+                    return self.a.next();\n+                }\n                 Greater => return self.b.next(),\n             }\n         }"}, {"sha": "717c1d13af4bd1152c66d036833af68c8a8b346c", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -20,7 +20,7 @@\n \n use core::marker;\n use core::fmt;\n-use core::iter::{FromIterator};\n+use core::iter::FromIterator;\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n \n // FIXME(contentions): implement union family of methods? (general design may be\n@@ -43,11 +43,13 @@ pub struct EnumSet<E> {\n impl<E> Copy for EnumSet<E> {}\n \n impl<E> Clone for EnumSet<E> {\n-    fn clone(&self) -> EnumSet<E> { *self }\n+    fn clone(&self) -> EnumSet<E> {\n+        *self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n+impl<E: CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt.debug_set().entries(self).finish()\n     }\n@@ -79,18 +81,22 @@ pub trait CLike {\n     fn from_usize(usize) -> Self;\n }\n \n-fn bit<E:CLike>(e: &E) -> usize {\n+fn bit<E: CLike>(e: &E) -> usize {\n     use core::usize;\n     let value = e.to_usize();\n     assert!(value < usize::BITS,\n-            \"EnumSet only supports up to {} variants.\", usize::BITS - 1);\n+            \"EnumSet only supports up to {} variants.\",\n+            usize::BITS - 1);\n     1 << value\n }\n \n-impl<E:CLike> EnumSet<E> {\n+impl<E: CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n     pub fn new() -> EnumSet<E> {\n-        EnumSet {bits: 0, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: 0,\n+            marker: marker::PhantomData,\n+        }\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n@@ -124,14 +130,18 @@ impl<E:CLike> EnumSet<E> {\n \n     /// Returns the union of both `EnumSets`.\n     pub fn union(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits,\n-                 marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits | e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n \n     /// Returns the intersection of both `EnumSets`.\n     pub fn intersection(&self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits,\n-                 marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits & e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n@@ -159,35 +169,47 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n-impl<E:CLike> Sub for EnumSet<E> {\n+impl<E: CLike> Sub for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & !e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits & !e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> BitOr for EnumSet<E> {\n+impl<E: CLike> BitOr for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits | e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits | e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> BitAnd for EnumSet<E> {\n+impl<E: CLike> BitAnd for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits & e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits & e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> BitXor for EnumSet<E> {\n+impl<E: CLike> BitXor for EnumSet<E> {\n     type Output = EnumSet<E>;\n \n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n-        EnumSet {bits: self.bits ^ e.bits, marker: marker::PhantomData}\n+        EnumSet {\n+            bits: self.bits ^ e.bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n@@ -209,13 +231,17 @@ impl<E> Clone for Iter<E> {\n     }\n }\n \n-impl<E:CLike> Iter<E> {\n+impl<E: CLike> Iter<E> {\n     fn new(bits: usize) -> Iter<E> {\n-        Iter { index: 0, bits: bits, marker: marker::PhantomData }\n+        Iter {\n+            index: 0,\n+            bits: bits,\n+            marker: marker::PhantomData,\n+        }\n     }\n }\n \n-impl<E:CLike> Iterator for Iter<E> {\n+impl<E: CLike> Iterator for Iter<E> {\n     type Item = E;\n \n     fn next(&mut self) -> Option<E> {\n@@ -239,16 +265,17 @@ impl<E:CLike> Iterator for Iter<E> {\n     }\n }\n \n-impl<E:CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I: IntoIterator<Item=E>>(iter: I) -> EnumSet<E> {\n+impl<E: CLike> FromIterator<E> for EnumSet<E> {\n+    fn from_iter<I: IntoIterator<Item = E>>(iter: I) -> EnumSet<E> {\n         let mut ret = EnumSet::new();\n         ret.extend(iter);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n+impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike\n+{\n     type Item = E;\n     type IntoIter = Iter<E>;\n \n@@ -257,8 +284,8 @@ impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike {\n     }\n }\n \n-impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item=E>>(&mut self, iter: I) {\n+impl<E: CLike> Extend<E> for EnumSet<E> {\n+    fn extend<I: IntoIterator<Item = E>>(&mut self, iter: I) {\n         for element in iter {\n             self.insert(element);\n         }\n@@ -267,7 +294,7 @@ impl<E:CLike> Extend<E> for EnumSet<E> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, E: 'a + CLike + Copy> Extend<&'a E> for EnumSet<E> {\n-    fn extend<I: IntoIterator<Item=&'a E>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a E>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }"}, {"sha": "18cfb5b76fef27c7c3ce890cce031ab6f1fa40c8", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -76,8 +76,11 @@\n extern crate rustc_unicode;\n extern crate alloc;\n \n-#[cfg(test)] #[macro_use] extern crate std;\n-#[cfg(test)] extern crate test;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate std;\n+#[cfg(test)]\n+extern crate test;\n \n pub use binary_heap::BinaryHeap;\n pub use btree_map::BTreeMap;"}, {"sha": "631857f8e3c56e472d7cf6e706f04ad9631c4a45", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 75, "deletions": 54, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -44,8 +44,8 @@ struct Rawlink<T> {\n }\n \n impl<T> Copy for Rawlink<T> {}\n-unsafe impl<T:Send> Send for Rawlink<T> {}\n-unsafe impl<T:Sync> Sync for Rawlink<T> {}\n+unsafe impl<T: Send> Send for Rawlink<T> {}\n+unsafe impl<T: Sync> Sync for Rawlink<T> {}\n \n struct Node<T> {\n     next: Link<T>,\n@@ -55,7 +55,7 @@ struct Node<T> {\n \n /// An iterator over references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T:'a> {\n+pub struct Iter<'a, T: 'a> {\n     head: &'a Link<T>,\n     tail: Rawlink<Node<T>>,\n     nelem: usize,\n@@ -75,7 +75,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n \n /// An iterator over mutable references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T:'a> {\n+pub struct IterMut<'a, T: 'a> {\n     list: &'a mut LinkedList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n@@ -86,19 +86,19 @@ pub struct IterMut<'a, T:'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    list: LinkedList<T>\n+    list: LinkedList<T>,\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer\n impl<T> Rawlink<T> {\n     /// Like Option::None for Rawlink\n     fn none() -> Rawlink<T> {\n-        Rawlink{p: ptr::null_mut()}\n+        Rawlink { p: ptr::null_mut() }\n     }\n \n     /// Like Option::Some for Rawlink\n     fn some(n: &mut T) -> Rawlink<T> {\n-        Rawlink{p: n}\n+        Rawlink { p: n }\n     }\n \n     /// Convert the `Rawlink` into an Option value\n@@ -139,13 +139,17 @@ impl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n impl<T> Clone for Rawlink<T> {\n     #[inline]\n     fn clone(&self) -> Rawlink<T> {\n-        Rawlink{p: self.p}\n+        Rawlink { p: self.p }\n     }\n }\n \n impl<T> Node<T> {\n     fn new(v: T) -> Node<T> {\n-        Node{value: v, next: None, prev: Rawlink::none()}\n+        Node {\n+            value: v,\n+            next: None,\n+            prev: Rawlink::none(),\n+        }\n     }\n \n     /// Update the `prev` link on `next`, then set self's next pointer.\n@@ -192,7 +196,7 @@ impl<T> LinkedList<T> {\n             self.length -= 1;\n             match front_node.next.take() {\n                 Some(node) => self.list_head = link_no_prev(node),\n-                None => self.list_tail = Rawlink::none()\n+                None => self.list_tail = Rawlink::none(),\n             }\n             front_node\n         })\n@@ -220,7 +224,7 @@ impl<T> LinkedList<T> {\n                 self.list_tail = tail.prev;\n                 match tail.prev.resolve_mut() {\n                     None => self.list_head.take(),\n-                    Some(tail_prev) => tail_prev.next.take()\n+                    Some(tail_prev) => tail_prev.next.take(),\n                 }\n             })\n         }\n@@ -230,15 +234,21 @@ impl<T> LinkedList<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for LinkedList<T> {\n     #[inline]\n-    fn default() -> LinkedList<T> { LinkedList::new() }\n+    fn default() -> LinkedList<T> {\n+        LinkedList::new()\n+    }\n }\n \n impl<T> LinkedList<T> {\n     /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> LinkedList<T> {\n-        LinkedList{list_head: None, list_tail: Rawlink::none(), length: 0}\n+        LinkedList {\n+            list_head: None,\n+            list_tail: Rawlink::none(),\n+            length: 0,\n+        }\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -274,7 +284,7 @@ impl<T> LinkedList<T> {\n                 self.length = other.length;\n                 self.list_head = other.list_head.take();\n                 self.list_tail = other.list_tail.take();\n-            },\n+            }\n             Some(tail) => {\n                 // Carefully empty `other`.\n                 let o_tail = other.list_tail.take();\n@@ -296,7 +306,11 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n-        Iter{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n+        Iter {\n+            nelem: self.len(),\n+            head: &self.list_head,\n+            tail: self.list_tail,\n+        }\n     }\n \n     /// Provides a forward iterator with mutable references.\n@@ -307,7 +321,7 @@ impl<T> LinkedList<T> {\n             nelem: self.len(),\n             head: Rawlink::from(&mut self.list_head),\n             tail: self.list_tail,\n-            list: self\n+            list: self,\n         }\n     }\n \n@@ -452,9 +466,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        unsafe {\n-            self.list_tail.resolve().map(|tail| &tail.value)\n-        }\n+        unsafe { self.list_tail.resolve().map(|tail| &tail.value) }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -481,9 +493,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        unsafe {\n-            self.list_tail.resolve_mut().map(|tail| &mut tail.value)\n-        }\n+        unsafe { self.list_tail.resolve_mut().map(|tail| &mut tail.value) }\n     }\n \n     /// Adds an element first in the list.\n@@ -532,7 +542,7 @@ impl<T> LinkedList<T> {\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|box Node{value, ..}| value)\n+        self.pop_front_node().map(|box Node { value, .. }| value)\n     }\n \n     /// Appends an element to the back of a list\n@@ -568,7 +578,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|box Node{value, ..}| value)\n+        self.pop_back_node().map(|box Node { value, .. }| value)\n     }\n \n     /// Splits the list into two at the given index. Returns everything after the given index,\n@@ -617,7 +627,7 @@ impl<T> LinkedList<T> {\n                 iter.next();\n             }\n             iter.head\n-        }  else {\n+        } else {\n             // better off starting from the end\n             let mut iter = self.iter_mut();\n             for _ in 0..len - 1 - (at - 1) {\n@@ -641,7 +651,7 @@ impl<T> LinkedList<T> {\n         let second_part = LinkedList {\n             list_head: second_part_head,\n             list_tail: self.list_tail,\n-            length: len - at\n+            length: len - at,\n         };\n \n         // Fix the tail ptr of the first part\n@@ -760,7 +770,9 @@ impl<'a, A> IterMut<'a, A> {\n         //\n         // The inserted node will not appear in further iteration.\n         match unsafe { self.head.resolve_mut() } {\n-            None => { self.list.push_back_node(ins_node); }\n+            None => {\n+                self.list.push_back_node(ins_node);\n+            }\n             Some(node) => {\n                 let prev_node = match unsafe { node.prev.resolve_mut() } {\n                     None => return self.list.push_front_node(ins_node),\n@@ -830,11 +842,9 @@ impl<'a, A> IterMut<'a, A> {\n                issue = \"27794\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {\n-            return None\n-        }\n-        unsafe {\n-            self.head.resolve_mut().map(|head| &mut head.value)\n+            return None;\n         }\n+        unsafe { self.head.resolve_mut().map(|head| &mut head.value) }\n     }\n }\n \n@@ -843,7 +853,9 @@ impl<A> Iterator for IntoIter<A> {\n     type Item = A;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.list.pop_front() }\n+    fn next(&mut self) -> Option<A> {\n+        self.list.pop_front()\n+    }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -854,15 +866,17 @@ impl<A> Iterator for IntoIter<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n+    fn next_back(&mut self) -> Option<A> {\n+        self.list.pop_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> ExactSizeIterator for IntoIter<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for LinkedList<A> {\n-    fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> LinkedList<A> {\n         let mut ret = LinkedList::new();\n         ret.extend(iter);\n         ret\n@@ -877,7 +891,7 @@ impl<T> IntoIterator for LinkedList<T> {\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter{list: self}\n+        IntoIter { list: self }\n     }\n }\n \n@@ -903,28 +917,28 @@ impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for LinkedList<A> {\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n-        for elt in iter { self.push_back(elt); }\n+    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n+        for elt in iter {\n+            self.push_back(elt);\n+        }\n     }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for LinkedList<A> {\n     fn eq(&self, other: &LinkedList<A>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().eq(other.iter())\n+        self.len() == other.len() && self.iter().eq(other.iter())\n     }\n \n     fn ne(&self, other: &LinkedList<A>) -> bool {\n-        self.len() != other.len() ||\n-            self.iter().ne(other.iter())\n+        self.len() != other.len() || self.iter().ne(other.iter())\n     }\n }\n \n@@ -974,7 +988,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n mod tests {\n     use std::clone::Clone;\n     use std::iter::{Iterator, IntoIterator, Extend};\n-    use std::option::Option::{Some, None, self};\n+    use std::option::Option::{self, Some, None};\n     use std::__rand::{thread_rng, Rng};\n     use std::thread;\n     use std::vec::Vec;\n@@ -991,13 +1005,16 @@ mod tests {\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n         match list.list_head {\n-            None => { assert_eq!(0, list.length); return }\n+            None => {\n+                assert_eq!(0, list.length);\n+                return;\n+            }\n             Some(ref node) => node_ptr = &**node,\n         }\n         loop {\n             match unsafe { (last_ptr, node_ptr.prev.resolve()) } {\n-                (None   , None      ) => {}\n-                (None   , _         ) => panic!(\"prev link for list_head\"),\n+                (None, None) => {}\n+                (None, _) => panic!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {\n                     assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n                 }\n@@ -1054,8 +1071,8 @@ mod tests {\n         }\n \n         // Non-empty to non-empty\n-        let v = vec![1,2,3,4,5];\n-        let u = vec![9,8,1,2,3,4,5];\n+        let v = vec![1, 2, 3, 4, 5];\n+        let u = vec![9, 8, 1, 2, 3, 4, 5];\n         let mut m = list_from(&v);\n         let mut n = list_from(&u);\n         m.append(&mut n);\n@@ -1077,7 +1094,7 @@ mod tests {\n \n     #[test]\n     fn test_insert_prev() {\n-        let mut m = list_from(&[0,2,4,6,8]);\n+        let mut m = list_from(&[0, 2, 4, 6, 8]);\n         let len = m.len();\n         {\n             let mut it = m.iter_mut();\n@@ -1099,17 +1116,21 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(),\n+                   [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n     }\n \n     #[test]\n     fn test_send() {\n-        let n = list_from(&[1,2,3]);\n+        let n = list_from(&[1, 2, 3]);\n         thread::spawn(move || {\n             check_links(&n);\n-            let a: &[_] = &[&1,&2,&3];\n+            let a: &[_] = &[&1, &2, &3];\n             assert_eq!(a, &n.iter().collect::<Vec<_>>()[..]);\n-        }).join().ok().unwrap();\n+        })\n+            .join()\n+            .ok()\n+            .unwrap();\n     }\n \n     #[test]\n@@ -1179,7 +1200,7 @@ mod tests {\n                         v.remove(0);\n                     }\n                 }\n-                2 | 4 =>  {\n+                2 | 4 => {\n                     m.push_front(-i);\n                     v.insert(0, -i);\n                 }"}, {"sha": "c70aa67366b342edd2fca8a398b86a483306ed45", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -22,26 +22,38 @@ pub trait RangeArgument<T> {\n     /// Start index (inclusive)\n     ///\n     /// Return start value if present, else `None`.\n-    fn start(&self) -> Option<&T> { None }\n+    fn start(&self) -> Option<&T> {\n+        None\n+    }\n \n     /// End index (exclusive)\n     ///\n     /// Return end value if present, else `None`.\n-    fn end(&self) -> Option<&T> { None }\n+    fn end(&self) -> Option<&T> {\n+        None\n+    }\n }\n \n \n impl<T> RangeArgument<T> for RangeFull {}\n \n impl<T> RangeArgument<T> for RangeFrom<T> {\n-    fn start(&self) -> Option<&T> { Some(&self.start) }\n+    fn start(&self) -> Option<&T> {\n+        Some(&self.start)\n+    }\n }\n \n impl<T> RangeArgument<T> for RangeTo<T> {\n-    fn end(&self) -> Option<&T> { Some(&self.end) }\n+    fn end(&self) -> Option<&T> {\n+        Some(&self.end)\n+    }\n }\n \n impl<T> RangeArgument<T> for Range<T> {\n-    fn start(&self) -> Option<&T> { Some(&self.start) }\n-    fn end(&self) -> Option<&T> { Some(&self.end) }\n+    fn start(&self) -> Option<&T> {\n+        Some(&self.start)\n+    }\n+    fn end(&self) -> Option<&T> {\n+        Some(&self.end)\n+    }\n }"}, {"sha": "82cadd7ac0d889f1d6594c7012a925cb5e75d335", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -156,7 +156,9 @@ mod hack {\n     }\n \n     #[inline]\n-    pub fn to_vec<T>(s: &[T]) -> Vec<T> where T: Clone {\n+    pub fn to_vec<T>(s: &[T]) -> Vec<T>\n+        where T: Clone\n+    {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.push_all(s);\n         vector\n@@ -535,15 +537,19 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn split<F>(&self, pred: F) -> Split<T, F> where F: FnMut(&T) -> bool {\n+    pub fn split<F>(&self, pred: F) -> Split<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::split(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F> where F: FnMut(&T) -> bool {\n+    pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::split_mut(self, pred)\n     }\n \n@@ -567,7 +573,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F> where F: FnMut(&T) -> bool {\n+    pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::splitn(self, n, pred)\n     }\n \n@@ -580,7 +588,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n-                         where F: FnMut(&T) -> bool {\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::splitn_mut(self, n, pred)\n     }\n \n@@ -605,7 +614,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F> where F: FnMut(&T) -> bool {\n+    pub fn rsplitn<F>(&self, n: usize, pred: F) -> RSplitN<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::rsplitn(self, n, pred)\n     }\n \n@@ -618,8 +629,9 @@ impl<T> [T] {\n     /// slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>\n-                      where F: FnMut(&T) -> bool {\n+    pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n         core_slice::SliceExt::rsplitn_mut(self, n, pred)\n     }\n \n@@ -633,7 +645,9 @@ impl<T> [T] {\n     /// assert!(!v.contains(&50));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains(&self, x: &T) -> bool where T: PartialEq {\n+    pub fn contains(&self, x: &T) -> bool\n+        where T: PartialEq\n+    {\n         core_slice::SliceExt::contains(self, x)\n     }\n \n@@ -649,7 +663,9 @@ impl<T> [T] {\n     /// assert!(!v.starts_with(&[10, 50]));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+    pub fn starts_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n         core_slice::SliceExt::starts_with(self, needle)\n     }\n \n@@ -665,7 +681,9 @@ impl<T> [T] {\n     /// assert!(!v.ends_with(&[50, 30]));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n+    pub fn ends_with(&self, needle: &[T]) -> bool\n+        where T: PartialEq\n+    {\n         core_slice::SliceExt::ends_with(self, needle)\n     }\n \n@@ -692,7 +710,9 @@ impl<T> [T] {\n     /// assert!(match r { Ok(1...4) => true, _ => false, });\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+        where T: Ord\n+    {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n@@ -729,7 +749,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where F: FnMut(&T) -> Ordering {\n+    pub fn binary_search_by<F>(&self, f: F) -> Result<usize, usize>\n+        where F: FnMut(&T) -> Ordering\n+    {\n         core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n@@ -749,7 +771,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort(&mut self) where T: Ord {\n+    pub fn sort(&mut self)\n+        where T: Ord\n+    {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n \n@@ -772,7 +796,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n+    pub fn sort_by<F>(&mut self, compare: F)\n+        where F: FnMut(&T, &T) -> Ordering\n+    {\n         merge_sort(self, compare)\n     }\n \n@@ -796,14 +822,18 @@ impl<T> [T] {\n     /// assert!(dst == [3, 4, 5]);\n     /// ```\n     #[unstable(feature = \"clone_from_slice\", issue = \"27750\")]\n-    pub fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n+    pub fn clone_from_slice(&mut self, src: &[T]) -> usize\n+        where T: Clone\n+    {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n \n     /// Copies `self` into a new `Vec`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn to_vec(&self) -> Vec<T> where T: Clone {\n+    pub fn to_vec(&self) -> Vec<T>\n+        where T: Clone\n+    {\n         // NB see hack module in this file\n         hack::to_vec(self)\n     }\n@@ -886,7 +916,11 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n-            if first { first = false } else { result.push(sep.clone()) }\n+            if first {\n+                first = false\n+            } else {\n+                result.push(sep.clone())\n+            }\n             result.push_all(v.borrow())\n         }\n         result\n@@ -903,33 +937,43 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Borrow<[T]> for Vec<T> {\n-    fn borrow(&self) -> &[T] { &self[..] }\n+    fn borrow(&self) -> &[T] {\n+        &self[..]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> BorrowMut<[T]> for Vec<T> {\n-    fn borrow_mut(&mut self) -> &mut [T] { &mut self[..] }\n+    fn borrow_mut(&mut self) -> &mut [T] {\n+        &mut self[..]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> ToOwned for [T] {\n     type Owned = Vec<T>;\n     #[cfg(not(test))]\n-    fn to_owned(&self) -> Vec<T> { self.to_vec() }\n+    fn to_owned(&self) -> Vec<T> {\n+        self.to_vec()\n+    }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec`, which is required for this method\n     // definition, is not available. Since we don't require this method for testing purposes, I'll\n     // just stub it\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n-    fn to_owned(&self) -> Vec<T> { panic!(\"not available with cfg(test)\") }\n+    fn to_owned(&self) -> Vec<T> {\n+        panic!(\"not available with cfg(test)\")\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+fn insertion_sort<T, F>(v: &mut [T], mut compare: F)\n+    where F: FnMut(&T, &T) -> Ordering\n+{\n     let len = v.len() as isize;\n     let buf_v = v.as_mut_ptr();\n \n@@ -945,8 +989,7 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n             // rather than <=, to maintain stability.\n \n             // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 &&\n-                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+            while j > 0 && compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n                 j -= 1;\n             }\n \n@@ -959,17 +1002,17 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n             if i != j {\n                 let tmp = ptr::read(read_ptr);\n-                ptr::copy(&*buf_v.offset(j),\n-                          buf_v.offset(j + 1),\n-                          (i - j) as usize);\n+                ptr::copy(&*buf_v.offset(j), buf_v.offset(j + 1), (i - j) as usize);\n                 ptr::copy_nonoverlapping(&tmp, buf_v.offset(j), 1);\n                 mem::forget(tmp);\n             }\n         }\n     }\n }\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n+    where F: FnMut(&T, &T) -> Ordering\n+{\n     // warning: this wildly uses unsafe.\n     const BASE_INSERTION: usize = 32;\n     const LARGE_INSERTION: usize = 16;\n@@ -998,7 +1041,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     let mut working_space = Vec::with_capacity(2 * len);\n     // these both are buffers of length `len`.\n     let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe {buf_dat.offset(len as isize)};\n+    let mut buf_tmp = unsafe { buf_dat.offset(len as isize) };\n \n     // length `len`.\n     let buf_v = v.as_ptr();\n@@ -1010,7 +1053,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // We could hardcode the sorting comparisons here, and we could\n     // manipulate/step the pointers themselves, rather than repeatedly\n     // .offset-ing.\n-    for start in (0.. len).step_by(insertion) {\n+    for start in (0..len).step_by(insertion) {\n         // start <= i < len;\n         for i in start..cmp::min(start + insertion, len) {\n             // j satisfies: start <= j <= i;\n@@ -1024,8 +1067,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n \n                 // start <= j - 1 < len, so .offset(j - 1) is in\n                 // bounds.\n-                while j > start as isize &&\n-                        compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n+                while j > start as isize && compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n                     j -= 1;\n                 }\n \n@@ -1035,9 +1077,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // j + 1 could be `len` (for the last `i`), but in\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n-                ptr::copy(&*buf_dat.offset(j),\n-                          buf_dat.offset(j + 1),\n-                          i - j as usize);\n+                ptr::copy(&*buf_dat.offset(j), buf_dat.offset(j + 1), i - j as usize);\n                 ptr::copy_nonoverlapping(read_ptr, buf_dat.offset(j), 1);\n             }\n         }"}, {"sha": "72560e17250a69b42baa3a9360004d32c5ebc3cf", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -57,7 +57,7 @@ pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use rustc_unicode::str::{SplitWhitespace};\n+pub use rustc_unicode::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n \n@@ -95,8 +95,8 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.borrow().len()).sum::<usize>();\n+        let len = sep.len() * (self.len() - 1) +\n+                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n@@ -122,18 +122,22 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n #[derive(Clone)]\n #[unstable(feature = \"str_utf16\", issue = \"27714\")]\n pub struct Utf16Units<'a> {\n-    encoder: Utf16Encoder<Chars<'a>>\n+    encoder: Utf16Encoder<Chars<'a>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Utf16Units<'a> {\n     type Item = u16;\n \n     #[inline]\n-    fn next(&mut self) -> Option<u16> { self.encoder.next() }\n+    fn next(&mut self) -> Option<u16> {\n+        self.encoder.next()\n+    }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.encoder.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.encoder.size_hint()\n+    }\n }\n \n // Return the initial codepoint accumulator for the first byte.\n@@ -151,16 +155,16 @@ macro_rules! utf8_acc_cont_byte {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Borrow<str> for String {\n     #[inline]\n-    fn borrow(&self) -> &str { &self[..] }\n+    fn borrow(&self) -> &str {\n+        &self[..]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for str {\n     type Owned = String;\n     fn to_owned(&self) -> String {\n-        unsafe {\n-            String::from_utf8_unchecked(self.as_bytes().to_owned())\n-        }\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_owned()) }\n     }\n }\n \n@@ -1450,13 +1454,16 @@ impl str {\n             // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n             // for the definition of `Final_Sigma`.\n             debug_assert!('\u03a3'.len_utf8() == 2);\n-            let is_word_final =\n-                case_ignoreable_then_cased(from[..i].chars().rev()) &&\n-                !case_ignoreable_then_cased(from[i + 2..].chars());\n-            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n+            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev()) &&\n+                                !case_ignoreable_then_cased(from[i + 2..].chars());\n+            to.push_str(if is_word_final {\n+                \"\u03c2\"\n+            } else {\n+                \"\u03c3\"\n+            });\n         }\n \n-        fn case_ignoreable_then_cased<I: Iterator<Item=char>>(iter: I) -> bool {\n+        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n             use rustc_unicode::derived_property::{Cased, Case_Ignorable};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),"}, {"sha": "9f09facdaf7e221d51f812c23e1b84e149c6c29f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -61,9 +61,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> String {\n-        String {\n-            vec: Vec::new(),\n-        }\n+        String { vec: Vec::new() }\n     }\n \n     /// Creates a new string buffer with the given capacity.\n@@ -92,9 +90,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> String {\n-        String {\n-            vec: Vec::with_capacity(capacity),\n-        }\n+        String { vec: Vec::with_capacity(capacity) }\n     }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n@@ -167,7 +163,12 @@ impl String {\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n         match str::from_utf8(&vec) {\n             Ok(..) => Ok(String { vec: vec }),\n-            Err(e) => Err(FromUtf8Error { bytes: vec, error: e })\n+            Err(e) => {\n+                Err(FromUtf8Error {\n+                    bytes: vec,\n+                    error: e,\n+                })\n+            }\n         }\n     }\n \n@@ -240,9 +241,7 @@ impl String {\n         let mut res = String::with_capacity(total);\n \n         if i > 0 {\n-            unsafe {\n-                res.as_mut_vec().push_all(&v[..i])\n-            };\n+            unsafe { res.as_mut_vec().push_all(&v[..i]) };\n         }\n \n         // subseqidx is the index of the first byte of the subsequence we're\n@@ -280,10 +279,10 @@ impl String {\n                     }\n                     3 => {\n                         match (byte, safe_get(v, i, total)) {\n-                            (0xE0         , 0xA0 ... 0xBF) => (),\n-                            (0xE1 ... 0xEC, 0x80 ... 0xBF) => (),\n-                            (0xED         , 0x80 ... 0x9F) => (),\n-                            (0xEE ... 0xEF, 0x80 ... 0xBF) => (),\n+                            (0xE0, 0xA0...0xBF) => (),\n+                            (0xE1...0xEC, 0x80...0xBF) => (),\n+                            (0xED, 0x80...0x9F) => (),\n+                            (0xEE...0xEF, 0x80...0xBF) => (),\n                             _ => {\n                                 error!();\n                                 continue;\n@@ -298,9 +297,9 @@ impl String {\n                     }\n                     4 => {\n                         match (byte, safe_get(v, i, total)) {\n-                            (0xF0         , 0x90 ... 0xBF) => (),\n-                            (0xF1 ... 0xF3, 0x80 ... 0xBF) => (),\n-                            (0xF4         , 0x80 ... 0x8F) => (),\n+                            (0xF0, 0x90...0xBF) => (),\n+                            (0xF1...0xF3, 0x80...0xBF) => (),\n+                            (0xF4, 0x80...0x8F) => (),\n                             _ => {\n                                 error!();\n                                 continue;\n@@ -326,9 +325,7 @@ impl String {\n             }\n         }\n         if subseqidx < total {\n-            unsafe {\n-                res.as_mut_vec().push_all(&v[subseqidx..total])\n-            };\n+            unsafe { res.as_mut_vec().push_all(&v[subseqidx..total]) };\n         }\n         Cow::Owned(res)\n     }\n@@ -388,9 +385,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n-        String {\n-            vec: Vec::from_raw_parts(buf, length, capacity),\n-        }\n+        String { vec: Vec::from_raw_parts(buf, length, capacity) }\n     }\n \n     /// Converts a vector of bytes to a `String` without checking that the\n@@ -567,10 +562,10 @@ impl String {\n                 unsafe {\n                     // Attempt to not use an intermediate buffer by just pushing bytes\n                     // directly onto this string.\n-                    let slice = slice::from_raw_parts_mut (\n-                        self.vec.as_mut_ptr().offset(cur_len as isize),\n-                        ch_len\n-                    );\n+                    let slice = slice::from_raw_parts_mut(self.vec\n+                                                              .as_mut_ptr()\n+                                                              .offset(cur_len as isize),\n+                                                          ch_len);\n                     let used = ch.encode_utf8(slice).unwrap_or(0);\n                     self.vec.set_len(cur_len + used);\n                 }\n@@ -630,7 +625,7 @@ impl String {\n     pub fn pop(&mut self) -> Option<char> {\n         let len = self.len();\n         if len == 0 {\n-            return None\n+            return None;\n         }\n \n         let ch = self.char_at_reverse(len);\n@@ -742,7 +737,9 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.vec.len() }\n+    pub fn len(&self) -> usize {\n+        self.vec.len()\n+    }\n \n     /// Returns true if the string contains no bytes\n     ///\n@@ -756,7 +753,9 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Truncates the string, returning it to 0 length.\n     ///\n@@ -802,7 +801,9 @@ impl String {\n     #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\",\n                issue = \"27711\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeArgument<usize> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain\n+        where R: RangeArgument<usize>\n+    {\n         // Memory safety\n         //\n         // The String version of Drain does not have the memory safety issues\n@@ -852,11 +853,15 @@ impl FromUtf8Error {\n     /// Consumes this error, returning the bytes that were attempted to make a\n     /// `String` with.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n+    pub fn into_bytes(self) -> Vec<u8> {\n+        self.bytes\n+    }\n \n     /// Access the underlying UTF8-error that was the cause of this error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn utf8_error(&self) -> Utf8Error { self.error }\n+    pub fn utf8_error(&self) -> Utf8Error {\n+        self.error\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -886,7 +891,7 @@ impl Clone for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n-    fn from_iter<I: IntoIterator<Item=char>>(iterable: I) -> String {\n+    fn from_iter<I: IntoIterator<Item = char>>(iterable: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterable);\n         buf\n@@ -895,7 +900,7 @@ impl FromIterator<char> for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> FromIterator<&'a str> for String {\n-    fn from_iter<I: IntoIterator<Item=&'a str>>(iterable: I) -> String {\n+    fn from_iter<I: IntoIterator<Item = &'a str>>(iterable: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterable);\n         buf\n@@ -904,7 +909,7 @@ impl<'a> FromIterator<&'a str> for String {\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl FromIterator<String> for String {\n-    fn from_iter<I: IntoIterator<Item=String>>(iterable: I) -> String {\n+    fn from_iter<I: IntoIterator<Item = String>>(iterable: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterable);\n         buf\n@@ -913,7 +918,7 @@ impl FromIterator<String> for String {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<char> for String {\n-    fn extend<I: IntoIterator<Item=char>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = char>>(&mut self, iterable: I) {\n         let iterator = iterable.into_iter();\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n@@ -925,14 +930,14 @@ impl Extend<char> for String {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a> Extend<&'a char> for String {\n-    fn extend<I: IntoIterator<Item=&'a char>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iterable: I) {\n         self.extend(iterable.into_iter().cloned());\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: IntoIterator<Item=&'a str>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iterable: I) {\n         for s in iterable {\n             self.push_str(s)\n         }\n@@ -941,7 +946,7 @@ impl<'a> Extend<&'a str> for String {\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n-    fn extend<I: IntoIterator<Item=String>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = String>>(&mut self, iterable: I) {\n         for s in iterable {\n             self.push_str(&s)\n         }\n@@ -973,9 +978,13 @@ impl<'a, 'b> Pattern<'a> for &'b String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n-    fn eq(&self, other: &String) -> bool { PartialEq::eq(&self[..], &other[..]) }\n+    fn eq(&self, other: &String) -> bool {\n+        PartialEq::eq(&self[..], &other[..])\n+    }\n     #[inline]\n-    fn ne(&self, other: &String) -> bool { PartialEq::ne(&self[..], &other[..]) }\n+    fn ne(&self, other: &String) -> bool {\n+        PartialEq::ne(&self[..], &other[..])\n+    }\n }\n \n macro_rules! impl_eq {"}, {"sha": "8c1f98bbd07c5232fe486e40696aa61e517547c5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 71, "deletions": 57, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -248,7 +248,10 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Vec<T> {\n-        Vec { buf: RawVec::new(), len: 0 }\n+        Vec {\n+            buf: RawVec::new(),\n+            len: 0,\n+        }\n     }\n \n     /// Constructs a new, empty `Vec<T>` with the specified capacity.\n@@ -280,7 +283,10 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize) -> Vec<T> {\n-        Vec { buf: RawVec::with_capacity(capacity), len: 0 }\n+        Vec {\n+            buf: RawVec::with_capacity(capacity),\n+            len: 0,\n+        }\n     }\n \n     /// Creates a `Vec<T>` directly from the raw components of another vector.\n@@ -329,8 +335,7 @@ impl<T> Vec<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize,\n-                                 capacity: usize) -> Vec<T> {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, length: usize, capacity: usize) -> Vec<T> {\n         Vec {\n             buf: RawVec::from_raw_parts(ptr, capacity),\n             len: length,\n@@ -547,9 +552,12 @@ impl<T> Vec<T> {\n         assert!(index <= len);\n \n         // space for the new element\n-        if len == self.buf.cap() { self.buf.double(); }\n+        if len == self.buf.cap() {\n+            self.buf.double();\n+        }\n \n-        unsafe { // infallible\n+        unsafe {\n+            // infallible\n             // The spot to put the new value\n             {\n                 let p = self.as_mut_ptr().offset(index as isize);\n@@ -582,7 +590,8 @@ impl<T> Vec<T> {\n     pub fn remove(&mut self, index: usize) -> T {\n         let len = self.len();\n         assert!(index < len);\n-        unsafe { // infallible\n+        unsafe {\n+            // infallible\n             let ret;\n             {\n                 // the place we are taking from.\n@@ -613,7 +622,9 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, [2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> bool\n+    {\n         let len = self.len();\n         let mut del = 0;\n         {\n@@ -623,7 +634,7 @@ impl<T> Vec<T> {\n                 if !f(&v[i]) {\n                     del += 1;\n                 } else if del > 0 {\n-                    v.swap(i-del, i);\n+                    v.swap(i - del, i);\n                 }\n             }\n         }\n@@ -650,7 +661,9 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         // This will panic or abort if we would allocate > isize::MAX bytes\n         // or if the length increment would overflow for zero-sized types.\n-        if self.len == self.buf.cap() { self.buf.double(); }\n+        if self.len == self.buf.cap() {\n+            self.buf.double();\n+        }\n         unsafe {\n             let end = self.as_mut_ptr().offset(self.len as isize);\n             ptr::write(end, value);\n@@ -702,14 +715,13 @@ impl<T> Vec<T> {\n         self.reserve(other.len());\n         let len = self.len();\n         unsafe {\n-            ptr::copy_nonoverlapping(\n-                other.as_ptr(),\n-                self.get_unchecked_mut(len),\n-                other.len());\n+            ptr::copy_nonoverlapping(other.as_ptr(), self.get_unchecked_mut(len), other.len());\n         }\n \n         self.len += other.len();\n-        unsafe { other.set_len(0); }\n+        unsafe {\n+            other.set_len(0);\n+        }\n     }\n \n     /// Create a draining iterator that removes the specified range in the vector\n@@ -738,7 +750,9 @@ impl<T> Vec<T> {\n     #[unstable(feature = \"drain\",\n                reason = \"recently added, matches RFC\",\n                issue = \"27711\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n+        where R: RangeArgument<usize>\n+    {\n         // Memory safety\n         //\n         // When the Drain is first created, it shortens the length of\n@@ -760,9 +774,8 @@ impl<T> Vec<T> {\n             self.set_len(start);\n             // Use the borrow in the IterMut to indicate borrowing behavior of the\n             // whole Drain iterator (like &mut T).\n-            let range_slice = slice::from_raw_parts_mut(\n-                                        self.as_mut_ptr().offset(start as isize),\n-                                        end - start);\n+            let range_slice = slice::from_raw_parts_mut(self.as_mut_ptr().offset(start as isize),\n+                                                        end - start);\n             Drain {\n                 tail_start: end,\n                 tail_len: len - end,\n@@ -799,7 +812,9 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.len }\n+    pub fn len(&self) -> usize {\n+        self.len\n+    }\n \n     /// Returns `true` if the vector contains no elements.\n     ///\n@@ -813,7 +828,9 @@ impl<T> Vec<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Splits the collection into two at the given index.\n     ///\n@@ -847,14 +864,12 @@ impl<T> Vec<T> {\n             self.set_len(at);\n             other.set_len(other_len);\n \n-            ptr::copy_nonoverlapping(\n-                self.as_ptr().offset(at as isize),\n-                other.as_mut_ptr(),\n-                other.len());\n+            ptr::copy_nonoverlapping(self.as_ptr().offset(at as isize),\n+                                     other.as_mut_ptr(),\n+                                     other.len());\n         }\n         other\n     }\n-\n }\n \n impl<T: Clone> Vec<T> {\n@@ -937,9 +952,7 @@ impl<T: Clone> Vec<T> {\n             // similarly fast) when T is Copy. LLVM is easily confused, so any\n             // extra operations during the loop can prevent this optimisation.\n             unsafe {\n-                ptr::write(\n-                    self.get_unchecked_mut(len),\n-                    other.get_unchecked(i).clone());\n+                ptr::write(self.get_unchecked_mut(len), other.get_unchecked(i).clone());\n                 self.set_len(len + 1);\n             }\n         }\n@@ -1021,7 +1034,9 @@ impl<T: PartialEq> Vec<T> {\n             // Duplicate, advance r. End of vec. Truncate to w.\n \n             let ln = self.len();\n-            if ln <= 1 { return; }\n+            if ln <= 1 {\n+                return;\n+            }\n \n             // Avoid bounds checks by using raw pointers.\n             let p = self.as_mut_ptr();\n@@ -1063,9 +1078,11 @@ pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T:Clone> Clone for Vec<T> {\n+impl<T: Clone> Clone for Vec<T> {\n     #[cfg(not(test))]\n-    fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n+    fn clone(&self) -> Vec<T> {\n+        <[T]>::to_vec(&**self)\n+    }\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Instead use the\n@@ -1158,31 +1175,27 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n-\n     #[inline]\n     fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n         self\n@@ -1216,7 +1229,7 @@ impl<T> ops::DerefMut for Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I: IntoIterator<Item=T>>(iterable: I) -> Vec<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iterable: I) -> Vec<T> {\n         // Unroll the first iteration, as the vector is going to be\n         // expanded on this iteration in every case when the iterable is not\n         // empty, but the loop in extend_desugared() is not going to see the\n@@ -1271,7 +1284,11 @@ impl<T> IntoIterator for Vec<T> {\n             };\n             let buf = ptr::read(&self.buf);\n             mem::forget(self);\n-            IntoIter { _buf: buf, ptr: begin, end: end }\n+            IntoIter {\n+                _buf: buf,\n+                ptr: begin,\n+                end: end,\n+            }\n         }\n     }\n }\n@@ -1299,13 +1316,13 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iterable: I) {\n         self.extend_desugared(iterable.into_iter())\n     }\n }\n \n impl<T> Vec<T> {\n-    fn extend_desugared<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n+    fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n         // This function should be the moral equivalent of:\n         //\n         //      for item in iterator {\n@@ -1328,7 +1345,7 @@ impl<T> Vec<T> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n@@ -1466,7 +1483,7 @@ impl<'a> From<&'a str> for Vec<u8> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n-    fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {\n+    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n@@ -1494,13 +1511,13 @@ impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n pub struct IntoIter<T> {\n     _buf: RawVec<T>,\n     ptr: *const T,\n-    end: *const T\n+    end: *const T,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for IntoIter<T> { }\n+unsafe impl<T: Send> Send for IntoIter<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for IntoIter<T> { }\n+unsafe impl<T: Sync> Sync for IntoIter<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n@@ -1534,7 +1551,12 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let diff = (self.end as usize) - (self.ptr as usize);\n         let size = mem::size_of::<T>();\n-        let exact = diff / (if size == 0 {1} else {size});\n+        let exact = diff /\n+                    (if size == 0 {\n+                         1\n+                     } else {\n+                         size\n+                     });\n         (exact, Some(exact))\n     }\n \n@@ -1605,11 +1627,7 @@ impl<'a, T> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt|\n-            unsafe {\n-                ptr::read(elt as *const _)\n-            }\n-        )\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -1621,19 +1639,15 @@ impl<'a, T> Iterator for Drain<'a, T> {\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt|\n-            unsafe {\n-                ptr::read(elt as *const _)\n-            }\n-        )\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // exhaust self first\n-        while let Some(_) = self.next() { }\n+        while let Some(_) = self.next() {}\n \n         if self.tail_len > 0 {\n             unsafe {"}, {"sha": "26b9944f062ce8b8c993b23c2353f59347c9c427", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 394, "deletions": 307, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -52,7 +52,6 @@ pub struct VecDeque<T> {\n     // to where data should be written.\n     // If tail == head the buffer is empty. The length of the ringbuffer\n     // is defined as the distance between the two.\n-\n     tail: usize,\n     head: usize,\n     buf: RawVec<T>,\n@@ -77,7 +76,9 @@ impl<T> Drop for VecDeque<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for VecDeque<T> {\n     #[inline]\n-    fn default() -> VecDeque<T> { VecDeque::new() }\n+    fn default() -> VecDeque<T> {\n+        VecDeque::new()\n+    }\n }\n \n impl<T> VecDeque<T> {\n@@ -124,12 +125,16 @@ impl<T> VecDeque<T> {\n \n     /// Returns true if and only if the buffer is at capacity\n     #[inline]\n-    fn is_full(&self) -> bool { self.cap() - self.len() == 1 }\n+    fn is_full(&self) -> bool {\n+        self.cap() - self.len() == 1\n+    }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index.\n     #[inline]\n-    fn wrap_index(&self, idx: usize) -> usize { wrap_index(idx, self.cap()) }\n+    fn wrap_index(&self, idx: usize) -> usize {\n+        wrap_index(idx, self.cap())\n+    }\n \n     /// Returns the index in the underlying buffer for a given logical element\n     /// index + addend.\n@@ -148,40 +153,65 @@ impl<T> VecDeque<T> {\n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap(), \"cpy dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(dst + len <= self.cap(),\n+                      \"cpy dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        debug_assert!(src + len <= self.cap(), \"cpy dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(src + len <= self.cap(),\n+                      \"cpy dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        ptr::copy(\n-            self.ptr().offset(src as isize),\n-            self.ptr().offset(dst as isize),\n-            len);\n+        ptr::copy(self.ptr().offset(src as isize),\n+                  self.ptr().offset(dst as isize),\n+                  len);\n     }\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n     unsafe fn copy_nonoverlapping(&self, dst: usize, src: usize, len: usize) {\n-        debug_assert!(dst + len <= self.cap(), \"cno dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(dst + len <= self.cap(),\n+                      \"cno dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        debug_assert!(src + len <= self.cap(), \"cno dst={} src={} len={} cap={}\", dst, src, len,\n+        debug_assert!(src + len <= self.cap(),\n+                      \"cno dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n                       self.cap());\n-        ptr::copy_nonoverlapping(\n-            self.ptr().offset(src as isize),\n-            self.ptr().offset(dst as isize),\n-            len);\n+        ptr::copy_nonoverlapping(self.ptr().offset(src as isize),\n+                                 self.ptr().offset(dst as isize),\n+                                 len);\n     }\n \n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n     unsafe fn wrap_copy(&self, dst: usize, src: usize, len: usize) {\n         #[allow(dead_code)]\n-        fn diff(a: usize, b: usize) -> usize {if a <= b {b - a} else {a - b}}\n-        debug_assert!(cmp::min(diff(dst, src),\n-                               self.cap() - diff(dst, src)) + len <= self.cap(),\n-                      \"wrc dst={} src={} len={} cap={}\", dst, src, len, self.cap());\n+        fn diff(a: usize, b: usize) -> usize {\n+            if a <= b {\n+                b - a\n+            } else {\n+                a - b\n+            }\n+        }\n+        debug_assert!(cmp::min(diff(dst, src), self.cap() - diff(dst, src)) + len <= self.cap(),\n+                      \"wrc dst={} src={} len={} cap={}\",\n+                      dst,\n+                      src,\n+                      len,\n+                      self.cap());\n \n-        if src == dst || len == 0 { return }\n+        if src == dst || len == 0 {\n+            return;\n+        }\n \n         let dst_after_src = self.wrap_sub(dst, src) < len;\n \n@@ -304,13 +334,16 @@ impl<T> VecDeque<T> {\n         //              H                 T\n         // C [o o o o o . . . . . . . . . o o ]\n \n-        if self.tail <= self.head { // A\n+        if self.tail <= self.head {\n+            // A\n             // Nop\n-        } else if self.head < old_cap - self.tail { // B\n+        } else if self.head < old_cap - self.tail {\n+            // B\n             self.copy_nonoverlapping(old_cap, 0, self.head);\n             self.head += old_cap;\n             debug_assert!(self.head > self.tail);\n-        } else { // C\n+        } else {\n+            // C\n             let new_tail = new_cap - (old_cap - self.tail);\n             self.copy_nonoverlapping(new_tail, self.tail, old_cap - self.tail);\n             self.tail = new_tail;\n@@ -419,7 +452,8 @@ impl<T> VecDeque<T> {\n         let ri = self.wrap_add(self.tail, i);\n         let rj = self.wrap_add(self.tail, j);\n         unsafe {\n-            ptr::swap(self.ptr().offset(ri as isize), self.ptr().offset(rj as isize))\n+            ptr::swap(self.ptr().offset(ri as isize),\n+                      self.ptr().offset(rj as isize))\n         }\n     }\n \n@@ -436,7 +470,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize { self.cap() - 1 }\n+    pub fn capacity(&self) -> usize {\n+        self.cap() - 1\n+    }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n     /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n@@ -483,14 +519,15 @@ impl<T> VecDeque<T> {\n     pub fn reserve(&mut self, additional: usize) {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n-        let new_cap = used_cap\n-            .checked_add(additional)\n-            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .expect(\"capacity overflow\");\n+        let new_cap = used_cap.checked_add(additional)\n+                              .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+                              .expect(\"capacity overflow\");\n \n         if new_cap > self.capacity() {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n         }\n     }\n \n@@ -619,7 +656,7 @@ impl<T> VecDeque<T> {\n         Iter {\n             tail: self.tail,\n             head: self.head,\n-            ring: unsafe { self.buffer_as_slice() }\n+            ring: unsafe { self.buffer_as_slice() },\n         }\n     }\n \n@@ -681,7 +718,7 @@ impl<T> VecDeque<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (&mut buf[tail .. head], empty)\n+                (&mut buf[tail..head], empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);\n@@ -704,7 +741,9 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { count(self.tail, self.head, self.cap()) }\n+    pub fn len(&self) -> usize {\n+        count(self.tail, self.head, self.cap())\n+    }\n \n     /// Returns true if the buffer contains no elements\n     ///\n@@ -719,7 +758,9 @@ impl<T> VecDeque<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Create a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items from start to end. The element\n@@ -751,7 +792,9 @@ impl<T> VecDeque<T> {\n     #[unstable(feature = \"drain\",\n                reason = \"matches collection reform specification, waiting for dust to settle\",\n                issue = \"27711\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<T> where R: RangeArgument<usize> {\n+    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n+        where R: RangeArgument<usize>\n+    {\n         // Memory safety\n         //\n         // When the Drain is first created, the source deque is shortened to\n@@ -839,7 +882,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        if !self.is_empty() { Some(&self[0]) } else { None }\n+        if !self.is_empty() {\n+            Some(&self[0])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the\n@@ -863,7 +910,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        if !self.is_empty() { Some(&mut self[0]) } else { None }\n+        if !self.is_empty() {\n+            Some(&mut self[0])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Provides a reference to the back element, or `None` if the sequence is\n@@ -883,7 +934,11 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        if !self.is_empty() { Some(&self[self.len() - 1]) } else { None }\n+        if !self.is_empty() {\n+            Some(&self[self.len() - 1])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the\n@@ -908,7 +963,11 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n         let len = self.len();\n-        if !self.is_empty() { Some(&mut self[len - 1]) } else { None }\n+        if !self.is_empty() {\n+            Some(&mut self[len - 1])\n+        } else {\n+            None\n+        }\n     }\n \n     /// Removes the first element and returns it, or `None` if the sequence is\n@@ -955,13 +1014,17 @@ impl<T> VecDeque<T> {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n             debug_assert!(!self.is_full());\n         }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n-        unsafe { self.buffer_write(tail, value); }\n+        unsafe {\n+            self.buffer_write(tail, value);\n+        }\n     }\n \n     /// Appends an element to the back of a buffer\n@@ -981,7 +1044,9 @@ impl<T> VecDeque<T> {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n             debug_assert!(!self.is_full());\n         }\n \n@@ -1130,7 +1195,9 @@ impl<T> VecDeque<T> {\n         if self.is_full() {\n             let old_cap = self.cap();\n             self.buf.double();\n-            unsafe { self.handle_cap_increase(old_cap); }\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n             debug_assert!(!self.is_full());\n         }\n \n@@ -1163,7 +1230,9 @@ impl<T> VecDeque<T> {\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+        match (contiguous,\n+               distance_to_tail <= distance_to_head,\n+               idx >= self.tail) {\n             (true, true, _) if index == 0 => {\n                 // push_front\n                 //\n@@ -1176,134 +1245,148 @@ impl<T> VecDeque<T> {\n                 //\n \n                 self.tail = self.wrap_sub(self.tail, 1);\n-            },\n-            (true, true, _) => unsafe {\n-                // contiguous, insert closer to tail:\n-                //\n-                //             T   I         H\n-                //      [. . . o o A o o o o . . . . . .]\n-                //\n-                //           T               H\n-                //      [. . o o I A o o o o . . . . . .]\n-                //           M M\n-                //\n-                // contiguous, insert closer to tail and tail is 0:\n-                //\n-                //\n-                //       T   I         H\n-                //      [o o A o o o o . . . . . . . . .]\n-                //\n-                //                       H             T\n-                //      [o I A o o o o o . . . . . . . o]\n-                //       M                             M\n-\n-                let new_tail = self.wrap_sub(self.tail, 1);\n-\n-                self.copy(new_tail, self.tail, 1);\n-                // Already moved the tail, so we only copy `index - 1` elements.\n-                self.copy(self.tail, self.tail + 1, index - 1);\n-\n-                self.tail = new_tail;\n-            },\n-            (true, false, _) => unsafe {\n-                //  contiguous, insert closer to head:\n-                //\n-                //             T       I     H\n-                //      [. . . o o o o A o o . . . . . .]\n-                //\n-                //             T               H\n-                //      [. . . o o o o I A o o . . . . .]\n-                //                       M M M\n-\n-                self.copy(idx + 1, idx, self.head - idx);\n-                self.head = self.wrap_add(self.head, 1);\n-            },\n-            (false, true, true) => unsafe {\n-                // discontiguous, insert closer to tail, tail section:\n-                //\n-                //                   H         T   I\n-                //      [o o o o o o . . . . . o o A o o]\n-                //\n-                //                   H       T\n-                //      [o o o o o o . . . . o o I A o o]\n-                //                           M M\n-\n-                self.copy(self.tail - 1, self.tail, index);\n-                self.tail -= 1;\n-            },\n-            (false, false, true) => unsafe {\n-                // discontiguous, insert closer to head, tail section:\n-                //\n-                //           H             T         I\n-                //      [o o . . . . . . . o o o o o A o]\n-                //\n-                //             H           T\n-                //      [o o o . . . . . . o o o o o I A]\n-                //       M M M                         M\n-\n-                // copy elements up to new head\n-                self.copy(1, 0, self.head);\n-\n-                // copy last element into empty spot at bottom of buffer\n-                self.copy(0, self.cap() - 1, 1);\n-\n-                // move elements from idx to end forward not including ^ element\n-                self.copy(idx + 1, idx, self.cap() - 1 - idx);\n+            }\n+            (true, true, _) => {\n+                unsafe {\n+                    // contiguous, insert closer to tail:\n+                    //\n+                    //             T   I         H\n+                    //      [. . . o o A o o o o . . . . . .]\n+                    //\n+                    //           T               H\n+                    //      [. . o o I A o o o o . . . . . .]\n+                    //           M M\n+                    //\n+                    // contiguous, insert closer to tail and tail is 0:\n+                    //\n+                    //\n+                    //       T   I         H\n+                    //      [o o A o o o o . . . . . . . . .]\n+                    //\n+                    //                       H             T\n+                    //      [o I A o o o o o . . . . . . . o]\n+                    //       M                             M\n+\n+                    let new_tail = self.wrap_sub(self.tail, 1);\n+\n+                    self.copy(new_tail, self.tail, 1);\n+                    // Already moved the tail, so we only copy `index - 1` elements.\n+                    self.copy(self.tail, self.tail + 1, index - 1);\n+\n+                    self.tail = new_tail;\n+                }\n+            }\n+            (true, false, _) => {\n+                unsafe {\n+                    //  contiguous, insert closer to head:\n+                    //\n+                    //             T       I     H\n+                    //      [. . . o o o o A o o . . . . . .]\n+                    //\n+                    //             T               H\n+                    //      [. . . o o o o I A o o . . . . .]\n+                    //                       M M M\n+\n+                    self.copy(idx + 1, idx, self.head - idx);\n+                    self.head = self.wrap_add(self.head, 1);\n+                }\n+            }\n+            (false, true, true) => {\n+                unsafe {\n+                    // discontiguous, insert closer to tail, tail section:\n+                    //\n+                    //                   H         T   I\n+                    //      [o o o o o o . . . . . o o A o o]\n+                    //\n+                    //                   H       T\n+                    //      [o o o o o o . . . . o o I A o o]\n+                    //                           M M\n+\n+                    self.copy(self.tail - 1, self.tail, index);\n+                    self.tail -= 1;\n+                }\n+            }\n+            (false, false, true) => {\n+                unsafe {\n+                    // discontiguous, insert closer to head, tail section:\n+                    //\n+                    //           H             T         I\n+                    //      [o o . . . . . . . o o o o o A o]\n+                    //\n+                    //             H           T\n+                    //      [o o o . . . . . . o o o o o I A]\n+                    //       M M M                         M\n \n-                self.head += 1;\n-            },\n-            (false, true, false) if idx == 0 => unsafe {\n-                // discontiguous, insert is closer to tail, head section,\n-                // and is at index zero in the internal buffer:\n-                //\n-                //       I                   H     T\n-                //      [A o o o o o o o o o . . . o o o]\n-                //\n-                //                           H   T\n-                //      [A o o o o o o o o o . . o o o I]\n-                //                               M M M\n+                    // copy elements up to new head\n+                    self.copy(1, 0, self.head);\n \n-                // copy elements up to new tail\n-                self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n+                    // copy last element into empty spot at bottom of buffer\n+                    self.copy(0, self.cap() - 1, 1);\n \n-                // copy last element into empty spot at bottom of buffer\n-                self.copy(self.cap() - 1, 0, 1);\n+                    // move elements from idx to end forward not including ^ element\n+                    self.copy(idx + 1, idx, self.cap() - 1 - idx);\n \n-                self.tail -= 1;\n-            },\n-            (false, true, false) => unsafe {\n-                // discontiguous, insert closer to tail, head section:\n-                //\n-                //             I             H     T\n-                //      [o o o A o o o o o o . . . o o o]\n-                //\n-                //                           H   T\n-                //      [o o I A o o o o o o . . o o o o]\n-                //       M M                     M M M M\n-\n-                // copy elements up to new tail\n-                self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n-\n-                // copy last element into empty spot at bottom of buffer\n-                self.copy(self.cap() - 1, 0, 1);\n+                    self.head += 1;\n+                }\n+            }\n+            (false, true, false) if idx == 0 => {\n+                unsafe {\n+                    // discontiguous, insert is closer to tail, head section,\n+                    // and is at index zero in the internal buffer:\n+                    //\n+                    //       I                   H     T\n+                    //      [A o o o o o o o o o . . . o o o]\n+                    //\n+                    //                           H   T\n+                    //      [A o o o o o o o o o . . o o o I]\n+                    //                               M M M\n+\n+                    // copy elements up to new tail\n+                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n+\n+                    // copy last element into empty spot at bottom of buffer\n+                    self.copy(self.cap() - 1, 0, 1);\n \n-                // move elements from idx-1 to end forward not including ^ element\n-                self.copy(0, 1, idx - 1);\n+                    self.tail -= 1;\n+                }\n+            }\n+            (false, true, false) => {\n+                unsafe {\n+                    // discontiguous, insert closer to tail, head section:\n+                    //\n+                    //             I             H     T\n+                    //      [o o o A o o o o o o . . . o o o]\n+                    //\n+                    //                           H   T\n+                    //      [o o I A o o o o o o . . o o o o]\n+                    //       M M                     M M M M\n+\n+                    // copy elements up to new tail\n+                    self.copy(self.tail - 1, self.tail, self.cap() - self.tail);\n+\n+                    // copy last element into empty spot at bottom of buffer\n+                    self.copy(self.cap() - 1, 0, 1);\n \n-                self.tail -= 1;\n-            },\n-            (false, false, false) => unsafe {\n-                // discontiguous, insert closer to head, head section:\n-                //\n-                //               I     H           T\n-                //      [o o o o A o o . . . . . . o o o]\n-                //\n-                //                     H           T\n-                //      [o o o o I A o o . . . . . o o o]\n-                //                 M M M\n+                    // move elements from idx-1 to end forward not including ^ element\n+                    self.copy(0, 1, idx - 1);\n \n-                self.copy(idx + 1, idx, self.head - idx);\n-                self.head += 1;\n+                    self.tail -= 1;\n+                }\n+            }\n+            (false, false, false) => {\n+                unsafe {\n+                    // discontiguous, insert closer to head, head section:\n+                    //\n+                    //               I     H           T\n+                    //      [o o o o A o o . . . . . . o o o]\n+                    //\n+                    //                     H           T\n+                    //      [o o o o I A o o . . . . . o o o]\n+                    //                 M M M\n+\n+                    self.copy(idx + 1, idx, self.head - idx);\n+                    self.head += 1;\n+                }\n             }\n         }\n \n@@ -1357,121 +1440,133 @@ impl<T> VecDeque<T> {\n \n         let idx = self.wrap_add(self.tail, index);\n \n-        let elem = unsafe {\n-            Some(self.buffer_read(idx))\n-        };\n+        let elem = unsafe { Some(self.buffer_read(idx)) };\n \n         let distance_to_tail = index;\n         let distance_to_head = self.len() - index;\n \n         let contiguous = self.is_contiguous();\n \n-        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n-            (true, true, _) => unsafe {\n-                // contiguous, remove closer to tail:\n-                //\n-                //             T   R         H\n-                //      [. . . o o x o o o o . . . . . .]\n-                //\n-                //               T           H\n-                //      [. . . . o o o o o o . . . . . .]\n-                //               M M\n-\n-                self.copy(self.tail + 1, self.tail, index);\n-                self.tail += 1;\n-            },\n-            (true, false, _) => unsafe {\n-                // contiguous, remove closer to head:\n-                //\n-                //             T       R     H\n-                //      [. . . o o o o x o o . . . . . .]\n-                //\n-                //             T           H\n-                //      [. . . o o o o o o . . . . . . .]\n-                //                     M M\n-\n-                self.copy(idx, idx + 1, self.head - idx - 1);\n-                self.head -= 1;\n-            },\n-            (false, true, true) => unsafe {\n-                // discontiguous, remove closer to tail, tail section:\n-                //\n-                //                   H         T   R\n-                //      [o o o o o o . . . . . o o x o o]\n-                //\n-                //                   H           T\n-                //      [o o o o o o . . . . . . o o o o]\n-                //                               M M\n-\n-                self.copy(self.tail + 1, self.tail, index);\n-                self.tail = self.wrap_add(self.tail, 1);\n-            },\n-            (false, false, false) => unsafe {\n-                // discontiguous, remove closer to head, head section:\n-                //\n-                //               R     H           T\n-                //      [o o o o x o o . . . . . . o o o]\n-                //\n-                //                   H             T\n-                //      [o o o o o o . . . . . . . o o o]\n-                //               M M\n-\n-                self.copy(idx, idx + 1, self.head - idx - 1);\n-                self.head -= 1;\n-            },\n-            (false, false, true) => unsafe {\n-                // discontiguous, remove closer to head, tail section:\n-                //\n-                //             H           T         R\n-                //      [o o o . . . . . . o o o o o x o]\n-                //\n-                //           H             T\n-                //      [o o . . . . . . . o o o o o o o]\n-                //       M M                         M M\n-                //\n-                // or quasi-discontiguous, remove next to head, tail section:\n-                //\n-                //       H                 T         R\n-                //      [. . . . . . . . . o o o o o x o]\n-                //\n-                //                         T           H\n-                //      [. . . . . . . . . o o o o o o .]\n-                //                                   M\n-\n-                // draw in elements in the tail section\n-                self.copy(idx, idx + 1, self.cap() - idx - 1);\n-\n-                // Prevents underflow.\n-                if self.head != 0 {\n-                    // copy first element into empty spot\n-                    self.copy(self.cap() - 1, 0, 1);\n-\n-                    // move elements in the head section backwards\n-                    self.copy(0, 1, self.head - 1);\n+        match (contiguous,\n+               distance_to_tail <= distance_to_head,\n+               idx >= self.tail) {\n+            (true, true, _) => {\n+                unsafe {\n+                    // contiguous, remove closer to tail:\n+                    //\n+                    //             T   R         H\n+                    //      [. . . o o x o o o o . . . . . .]\n+                    //\n+                    //               T           H\n+                    //      [. . . . o o o o o o . . . . . .]\n+                    //               M M\n+\n+                    self.copy(self.tail + 1, self.tail, index);\n+                    self.tail += 1;\n+                }\n+            }\n+            (true, false, _) => {\n+                unsafe {\n+                    // contiguous, remove closer to head:\n+                    //\n+                    //             T       R     H\n+                    //      [. . . o o o o x o o . . . . . .]\n+                    //\n+                    //             T           H\n+                    //      [. . . o o o o o o . . . . . . .]\n+                    //                     M M\n+\n+                    self.copy(idx, idx + 1, self.head - idx - 1);\n+                    self.head -= 1;\n+                }\n+            }\n+            (false, true, true) => {\n+                unsafe {\n+                    // discontiguous, remove closer to tail, tail section:\n+                    //\n+                    //                   H         T   R\n+                    //      [o o o o o o . . . . . o o x o o]\n+                    //\n+                    //                   H           T\n+                    //      [o o o o o o . . . . . . o o o o]\n+                    //                               M M\n+\n+                    self.copy(self.tail + 1, self.tail, index);\n+                    self.tail = self.wrap_add(self.tail, 1);\n+                }\n+            }\n+            (false, false, false) => {\n+                unsafe {\n+                    // discontiguous, remove closer to head, head section:\n+                    //\n+                    //               R     H           T\n+                    //      [o o o o x o o . . . . . . o o o]\n+                    //\n+                    //                   H             T\n+                    //      [o o o o o o . . . . . . . o o o]\n+                    //               M M\n+\n+                    self.copy(idx, idx + 1, self.head - idx - 1);\n+                    self.head -= 1;\n                 }\n+            }\n+            (false, false, true) => {\n+                unsafe {\n+                    // discontiguous, remove closer to head, tail section:\n+                    //\n+                    //             H           T         R\n+                    //      [o o o . . . . . . o o o o o x o]\n+                    //\n+                    //           H             T\n+                    //      [o o . . . . . . . o o o o o o o]\n+                    //       M M                         M M\n+                    //\n+                    // or quasi-discontiguous, remove next to head, tail section:\n+                    //\n+                    //       H                 T         R\n+                    //      [. . . . . . . . . o o o o o x o]\n+                    //\n+                    //                         T           H\n+                    //      [. . . . . . . . . o o o o o o .]\n+                    //                                   M\n+\n+                    // draw in elements in the tail section\n+                    self.copy(idx, idx + 1, self.cap() - idx - 1);\n+\n+                    // Prevents underflow.\n+                    if self.head != 0 {\n+                        // copy first element into empty spot\n+                        self.copy(self.cap() - 1, 0, 1);\n+\n+                        // move elements in the head section backwards\n+                        self.copy(0, 1, self.head - 1);\n+                    }\n \n-                self.head = self.wrap_sub(self.head, 1);\n-            },\n-            (false, true, false) => unsafe {\n-                // discontiguous, remove closer to tail, head section:\n-                //\n-                //           R               H     T\n-                //      [o o x o o o o o o o . . . o o o]\n-                //\n-                //                           H       T\n-                //      [o o o o o o o o o o . . . . o o]\n-                //       M M M                       M M\n+                    self.head = self.wrap_sub(self.head, 1);\n+                }\n+            }\n+            (false, true, false) => {\n+                unsafe {\n+                    // discontiguous, remove closer to tail, head section:\n+                    //\n+                    //           R               H     T\n+                    //      [o o x o o o o o o o . . . o o o]\n+                    //\n+                    //                           H       T\n+                    //      [o o o o o o o o o o . . . . o o]\n+                    //       M M M                       M M\n \n-                // draw in elements up to idx\n-                self.copy(1, 0, idx);\n+                    // draw in elements up to idx\n+                    self.copy(1, 0, idx);\n \n-                // copy last element into empty spot\n-                self.copy(0, self.cap() - 1, 1);\n+                    // copy last element into empty spot\n+                    self.copy(0, self.cap() - 1, 1);\n \n-                // move elements from tail to end forward, excluding the last one\n-                self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n+                    // move elements from tail to end forward, excluding the last one\n+                    self.copy(self.tail + 1, self.tail, self.cap() - self.tail - 1);\n \n-                self.tail = self.wrap_add(self.tail, 1);\n+                    self.tail = self.wrap_add(self.tail, 1);\n+                }\n             }\n         }\n \n@@ -1587,14 +1682,16 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(&v[..], &[2, 4]);\n     /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n-    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> bool\n+    {\n         let len = self.len();\n         let mut del = 0;\n         for i in 0..len {\n             if !f(&self[i]) {\n                 del += 1;\n             } else if del > 0 {\n-                self.swap(i-del, i);\n+                self.swap(i - del, i);\n             }\n         }\n         if del > 0 {\n@@ -1655,10 +1752,10 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n \n /// `VecDeque` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T:'a> {\n+pub struct Iter<'a, T: 'a> {\n     ring: &'a [T],\n     tail: usize,\n-    head: usize\n+    head: usize,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1668,7 +1765,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n         Iter {\n             ring: self.ring,\n             tail: self.tail,\n-            head: self.head\n+            head: self.head,\n         }\n     }\n }\n@@ -1711,7 +1808,7 @@ impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IterMut<'a, T:'a> {\n+pub struct IterMut<'a, T: 'a> {\n     ring: &'a mut [T],\n     tail: usize,\n     head: usize,\n@@ -1845,13 +1942,15 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n             (_, 0) => {\n                 source_deque.head = drain_tail;\n             }\n-            _ => unsafe {\n-                if tail_len <= head_len {\n-                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n-                } else {\n-                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+            _ => {\n+                unsafe {\n+                    if tail_len <= head_len {\n+                        source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                        source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                    } else {\n+                        source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                        source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                    }\n                 }\n             }\n         }\n@@ -1864,11 +1963,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt|\n-            unsafe {\n-                ptr::read(elt)\n-            }\n-        )\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n     }\n \n     #[inline]\n@@ -1881,11 +1976,7 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt|\n-            unsafe {\n-                ptr::read(elt)\n-            }\n-        )\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n     }\n }\n \n@@ -1895,8 +1986,7 @@ impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| a.eq(b))\n+        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a.eq(b))\n     }\n }\n \n@@ -1948,7 +2038,7 @@ impl<A> IndexMut<usize> for VecDeque<A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for VecDeque<A> {\n-    fn from_iter<T: IntoIterator<Item=A>>(iterable: T) -> VecDeque<A> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iterable: T) -> VecDeque<A> {\n         let iterator = iterable.into_iter();\n         let (lower, _) = iterator.size_hint();\n         let mut deq = VecDeque::with_capacity(lower);\n@@ -1965,9 +2055,7 @@ impl<T> IntoIterator for VecDeque<T> {\n     /// Consumes the list into a front-to-back iterator yielding elements by\n     /// value.\n     fn into_iter(self) -> IntoIter<T> {\n-        IntoIter {\n-            inner: self,\n-        }\n+        IntoIter { inner: self }\n     }\n }\n \n@@ -1993,7 +2081,7 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for VecDeque<A> {\n-    fn extend<T: IntoIterator<Item=A>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n         for elt in iter {\n             self.push_back(elt);\n         }\n@@ -2002,7 +2090,7 @@ impl<A> Extend<A> for VecDeque<A> {\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n@@ -2049,7 +2137,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq= VecDeque::<i32>::with_capacity(101);\n+        let mut deq = VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -2204,10 +2292,8 @@ mod tests {\n                         }\n \n                         // Check that we drain the correct values\n-                        let drained: VecDeque<_> =\n-                            tester.drain(drain_start..drain_end).collect();\n-                        let drained_expected: VecDeque<_> =\n-                            (drain_start..drain_end).collect();\n+                        let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n+                        let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n                         assert_eq!(drained, drained_expected);\n \n                         // We shouldn't have changed the capacity or made the\n@@ -2217,8 +2303,9 @@ mod tests {\n                         assert!(tester.head < tester.cap());\n \n                         // We should see the correct values in the VecDeque\n-                        let expected: VecDeque<_> =\n-                            (0..drain_start).chain(drain_end..len).collect();\n+                        let expected: VecDeque<_> = (0..drain_start)\n+                                                        .chain(drain_end..len)\n+                                                        .collect();\n                         assert_eq!(expected, tester);\n                     }\n                 }"}, {"sha": "c5f0800e71fbb34450614123f6a3fd9303b91531", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -82,7 +82,7 @@ impl Drop for Bytes {\n }\n \n #[link(name = \"miniz\", kind = \"static\")]\n-extern {\n+extern \"C\" {\n     /// Raw miniz compression function.\n     fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n                                   src_buf_len: size_t,"}, {"sha": "2cd046dc38ab19f60674f6d5e4bb1aed054b0313", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -187,7 +187,7 @@ impl<'a> Parser<'a> {\n         Parser {\n             input: s,\n             cur: s.char_indices().peekable(),\n-            errors: vec!(),\n+            errors: vec![],\n         }\n     }\n \n@@ -236,7 +236,7 @@ impl<'a> Parser<'a> {\n             if c.is_whitespace() {\n                 self.cur.next();\n             } else {\n-                break\n+                break;\n             }\n         }\n     }\n@@ -274,9 +274,7 @@ impl<'a> Parser<'a> {\n             ArgumentIs(i)\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => {\n-                    ArgumentNamed(self.word())\n-                }\n+                Some(&(_, c)) if c.is_alphabetic() => ArgumentNamed(self.word()),\n                 _ => ArgumentNext,\n             }\n         }\n@@ -294,7 +292,7 @@ impl<'a> Parser<'a> {\n             ty: &self.input[..0],\n         };\n         if !self.consume(':') {\n-            return spec\n+            return spec;\n         }\n \n         // fill character\n@@ -419,7 +417,7 @@ impl<'a> Parser<'a> {\n                 found = true;\n                 self.cur.next();\n             } else {\n-                break\n+                break;\n             }\n         }\n         if found {\n@@ -447,7 +445,7 @@ mod tests {\n             precision: CountImplied,\n             width: CountImplied,\n             ty: \"\",\n-        }\n+        };\n     }\n \n     fn musterr(s: &str) {"}, {"sha": "c744121f84369114c49aa6bd15100e98ac20caaf", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 449, "deletions": 426, "changes": 875, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -98,7 +98,9 @@\n #![feature(str_char)]\n #![cfg_attr(test, feature(rustc_private))]\n \n-#[cfg(test)] #[macro_use] extern crate log;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate log;\n \n use self::Name::*;\n use self::HasArg::*;\n@@ -174,7 +176,7 @@ pub struct OptGroup {\n     /// Whether option has an argument\n     pub hasarg: HasArg,\n     /// How often it can occur\n-    pub occur: Occur\n+    pub occur: Occur,\n }\n \n /// Describes whether an option is given at all or has a value.\n@@ -239,7 +241,7 @@ impl Name {\n     fn to_string(&self) -> String {\n         match *self {\n             Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_owned()\n+            Long(ref s) => s.to_owned(),\n         }\n     }\n }\n@@ -257,33 +259,37 @@ impl OptGroup {\n         } = (*self).clone();\n \n         match (short_name.len(), long_name.len()) {\n-            (0,0) => panic!(\"this long-format option was given no name\"),\n-            (0,_) => Opt {\n-                name: Long((long_name)),\n-                hasarg: hasarg,\n-                occur: occur,\n-                aliases: Vec::new()\n-            },\n-            (1,0) => Opt {\n-                name: Short(short_name.char_at(0)),\n-                hasarg: hasarg,\n-                occur: occur,\n-                aliases: Vec::new()\n-            },\n-            (1,_) => Opt {\n-                name: Long((long_name)),\n-                hasarg: hasarg,\n-                occur: occur,\n-                aliases: vec!(\n-                    Opt {\n-                        name: Short(short_name.char_at(0)),\n-                        hasarg: hasarg,\n-                        occur:  occur,\n-                        aliases: Vec::new()\n-                    }\n-                )\n-            },\n-            (_,_) => panic!(\"something is wrong with the long-form opt\")\n+            (0, 0) => panic!(\"this long-format option was given no name\"),\n+            (0, _) => {\n+                Opt {\n+                    name: Long((long_name)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: Vec::new(),\n+                }\n+            }\n+            (1, 0) => {\n+                Opt {\n+                    name: Short(short_name.char_at(0)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: Vec::new(),\n+                }\n+            }\n+            (1, _) => {\n+                Opt {\n+                    name: Long((long_name)),\n+                    hasarg: hasarg,\n+                    occur: occur,\n+                    aliases: vec![Opt {\n+                                      name: Short(short_name.char_at(0)),\n+                                      hasarg: hasarg,\n+                                      occur: occur,\n+                                      aliases: Vec::new(),\n+                                  }],\n+                }\n+            }\n+            (_, _) => panic!(\"something is wrong with the long-form opt\"),\n         }\n     }\n }\n@@ -292,7 +298,7 @@ impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n         match find_opt(&self.opts[..], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n-            None => panic!(\"No option '{}' defined\", nm)\n+            None => panic!(\"No option '{}' defined\", nm),\n         }\n     }\n \n@@ -331,7 +337,7 @@ impl Matches {\n         for nm in names {\n             match self.opt_val(&nm[..]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n-                _ => ()\n+                _ => (),\n             }\n         }\n         None\n@@ -347,7 +353,7 @@ impl Matches {\n         for v in &r {\n             match *v {\n                 Val(ref s) => acc.push((*s).clone()),\n-                _ => ()\n+                _ => (),\n             }\n         }\n         acc\n@@ -361,7 +367,7 @@ impl Matches {\n         }\n         match vals[0] {\n             Val(ref s) => Some((*s).clone()),\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -378,11 +384,10 @@ impl Matches {\n         } else {\n             match vals[0] {\n                 Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_owned())\n+                _ => Some(def.to_owned()),\n             }\n         }\n     }\n-\n }\n \n fn is_arg(arg: &str) -> bool {\n@@ -393,7 +398,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n     // Search main options.\n     let pos = opts.iter().position(|opt| opt.name == nm);\n     if pos.is_some() {\n-        return pos\n+        return pos;\n     }\n \n     // Search in aliases.\n@@ -422,7 +427,7 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Req\n+        occur: Req,\n     }\n }\n \n@@ -442,7 +447,7 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Optional\n+        occur: Optional,\n     }\n }\n \n@@ -460,7 +465,7 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n         hint: \"\".to_owned(),\n         desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Optional\n+        occur: Optional,\n     }\n }\n \n@@ -479,7 +484,7 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n         hint: \"\".to_owned(),\n         desc: desc.to_owned(),\n         hasarg: No,\n-        occur: Multi\n+        occur: Multi,\n     }\n }\n \n@@ -499,7 +504,7 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Maybe,\n-        occur: Optional\n+        occur: Optional,\n     }\n }\n \n@@ -520,7 +525,7 @@ pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> Op\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: Yes,\n-        occur: Multi\n+        occur: Multi,\n     }\n }\n \n@@ -530,7 +535,8 @@ pub fn opt(short_name: &str,\n            desc: &str,\n            hint: &str,\n            hasarg: HasArg,\n-           occur: Occur) -> OptGroup {\n+           occur: Occur)\n+           -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n@@ -539,28 +545,18 @@ pub fn opt(short_name: &str,\n         hint: hint.to_owned(),\n         desc: desc.to_owned(),\n         hasarg: hasarg,\n-        occur: occur\n+        occur: occur,\n     }\n }\n \n impl fmt::Display for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            ArgumentMissing(ref nm) => {\n-                write!(f, \"Argument to option '{}' missing.\", *nm)\n-            }\n-            UnrecognizedOption(ref nm) => {\n-                write!(f, \"Unrecognized option: '{}'.\", *nm)\n-            }\n-            OptionMissing(ref nm) => {\n-                write!(f, \"Required option '{}' missing.\", *nm)\n-            }\n-            OptionDuplicated(ref nm) => {\n-                write!(f, \"Option '{}' given more than once.\", *nm)\n-            }\n-            UnexpectedArgument(ref nm) => {\n-                write!(f, \"Option '{}' does not take an argument.\", *nm)\n-            }\n+            ArgumentMissing(ref nm) => write!(f, \"Argument to option '{}' missing.\", *nm),\n+            UnrecognizedOption(ref nm) => write!(f, \"Unrecognized option: '{}'.\", *nm),\n+            OptionMissing(ref nm) => write!(f, \"Required option '{}' missing.\", *nm),\n+            OptionDuplicated(ref nm) => write!(f, \"Option '{}' given more than once.\", *nm),\n+            UnexpectedArgument(ref nm) => write!(f, \"Option '{}' does not take an argument.\", *nm),\n         }\n     }\n }\n@@ -577,7 +573,9 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n-    fn f(_x: usize) -> Vec<Optval> { Vec::new() }\n+    fn f(_x: usize) -> Vec<Optval> {\n+        Vec::new()\n+    }\n \n     let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n@@ -590,7 +588,10 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n-            while j < l { free.push(args[j].clone()); j += 1; }\n+            while j < l {\n+                free.push(args[j].clone());\n+                j += 1;\n+            }\n             break;\n         } else {\n             let mut names;\n@@ -599,10 +600,9 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                 let tail = &cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = vec!(Long(tail.to_owned()));\n+                    names = vec![Long(tail.to_owned())];\n                 } else {\n-                    names =\n-                        vec!(Long(tail_eq[0].to_owned()));\n+                    names = vec![Long(tail_eq[0].to_owned())];\n                     i_arg = Some(tail_eq[1].to_owned());\n                 }\n             } else {\n@@ -612,23 +612,22 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     let ch = cur.char_at(j);\n                     let opt = Short(ch);\n \n-                    /* In a series of potential options (eg. -aheJ), if we\n-                       see one which takes an argument, we assume all\n-                       subsequent characters make up the argument. This\n-                       allows options such as -L/usr/local/lib/foo to be\n-                       interpreted correctly\n-                    */\n+                    // In a series of potential options (eg. -aheJ), if we\n+                    // see one which takes an argument, we assume all\n+                    // subsequent characters make up the argument. This\n+                    // allows options such as -L/usr/local/lib/foo to be\n+                    // interpreted correctly\n \n                     let opt_id = match find_opt(&opts, opt.clone()) {\n-                      Some(id) => id,\n-                      None => return Err(UnrecognizedOption(opt.to_string()))\n+                        Some(id) => id,\n+                        None => return Err(UnrecognizedOption(opt.to_string())),\n                     };\n \n                     names.push(opt);\n \n                     let arg_follows = match opts[opt_id].hasarg {\n                         Yes | Maybe => true,\n-                        No => false\n+                        No => false,\n                     };\n \n                     let next = j + ch.len_utf8();\n@@ -644,44 +643,42 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             for nm in &names {\n                 name_pos += 1;\n                 let optid = match find_opt(&opts, (*nm).clone()) {\n-                  Some(id) => id,\n-                  None => return Err(UnrecognizedOption(nm.to_string()))\n+                    Some(id) => id,\n+                    None => return Err(UnrecognizedOption(nm.to_string())),\n                 };\n                 match opts[optid].hasarg {\n-                  No => {\n-                    if name_pos == names.len() && !i_arg.is_none() {\n-                        return Err(UnexpectedArgument(nm.to_string()));\n-                    }\n-                    let v = &mut vals[optid];\n-                    v.push(Given);\n-                  }\n-                  Maybe => {\n-                    if !i_arg.is_none() {\n-                        let v = &mut vals[optid];\n-                        v.push(Val((i_arg.clone())\n-                            .unwrap()));\n-                    } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(&args[i + 1][..]) {\n+                    No => {\n+                        if name_pos == names.len() && !i_arg.is_none() {\n+                            return Err(UnexpectedArgument(nm.to_string()));\n+                        }\n                         let v = &mut vals[optid];\n                         v.push(Given);\n-                    } else {\n-                        i += 1;\n-                        let v = &mut vals[optid];\n-                        v.push(Val(args[i].clone()));\n                     }\n-                  }\n-                  Yes => {\n-                    if !i_arg.is_none() {\n-                        let v = &mut vals[optid];\n-                        v.push(Val(i_arg.clone().unwrap()));\n-                    } else if i + 1 == l {\n-                        return Err(ArgumentMissing(nm.to_string()));\n-                    } else {\n-                        i += 1;\n-                        let v = &mut vals[optid];\n-                        v.push(Val(args[i].clone()));\n+                    Maybe => {\n+                        if !i_arg.is_none() {\n+                            let v = &mut vals[optid];\n+                            v.push(Val((i_arg.clone()).unwrap()));\n+                        } else if name_pos < names.len() || i + 1 == l || is_arg(&args[i + 1][..]) {\n+                            let v = &mut vals[optid];\n+                            v.push(Given);\n+                        } else {\n+                            i += 1;\n+                            let v = &mut vals[optid];\n+                            v.push(Val(args[i].clone()));\n+                        }\n+                    }\n+                    Yes => {\n+                        if !i_arg.is_none() {\n+                            let v = &mut vals[optid];\n+                            v.push(Val(i_arg.clone().unwrap()));\n+                        } else if i + 1 == l {\n+                            return Err(ArgumentMissing(nm.to_string()));\n+                        } else {\n+                            i += 1;\n+                            let v = &mut vals[optid];\n+                            v.push(Val(args[i].clone()));\n+                        }\n                     }\n-                  }\n                 }\n             }\n         }\n@@ -700,7 +697,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     Ok(Matches {\n         opts: opts,\n         vals: vals,\n-        free: free\n+        free: free,\n     })\n }\n \n@@ -783,7 +780,8 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         row\n     });\n \n-    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief,\n+    format!(\"{}\\n\\nOptions:\\n{}\\n\",\n+            brief,\n             rows.collect::<Vec<String>>().join(\"\\n\"))\n }\n \n@@ -836,19 +834,19 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n \n #[derive(Copy, Clone)]\n enum SplitWithinState {\n-    A,  // leading whitespace, initial state\n-    B,  // words\n-    C,  // internal and trailing whitespace\n+    A, // leading whitespace, initial state\n+    B, // words\n+    C, // internal and trailing whitespace\n }\n #[derive(Copy, Clone)]\n enum Whitespace {\n     Ws, // current char is whitespace\n-    Cr  // current char is not whitespace\n+    Cr, // current char is not whitespace\n }\n #[derive(Copy, Clone)]\n enum LengthLimit {\n     UnderLim, // current char makes current substring still fit in limit\n-    OverLim   // current char makes current substring no longer fit in limit\n+    OverLim, // current char makes current substring no longer fit in limit\n }\n \n \n@@ -863,8 +861,8 @@ enum LengthLimit {\n ///\n /// Panics during iteration if the string contains a non-whitespace\n /// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n-    F: FnMut(&str) -> bool\n+fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool\n+    where F: FnMut(&str) -> bool\n {\n     // Just for fun, let's write this as a state machine:\n \n@@ -883,18 +881,31 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n     }\n \n     let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n-        let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n-        let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n+        let whitespace = if c.is_whitespace() {\n+            Ws\n+        } else {\n+            Cr\n+        };\n+        let limit = if (i - slice_start + 1) <= lim {\n+            UnderLim\n+        } else {\n+            OverLim\n+        };\n \n         state = match (state, whitespace, limit) {\n-            (A, Ws, _)        => { A }\n-            (A, Cr, _)        => { slice_start = i; last_start = i; B }\n-\n-            (B, Cr, UnderLim) => { B }\n-            (B, Cr, OverLim)  if (i - last_start + 1) > lim\n-                            => panic!(\"word starting with {} longer than limit!\",\n-                                      &ss[last_start..i + 1]),\n-            (B, Cr, OverLim)  => {\n+            (A, Ws, _) => A,\n+            (A, Cr, _) => {\n+                slice_start = i;\n+                last_start = i;\n+                B\n+            }\n+\n+            (B, Cr, UnderLim) => B,\n+            (B, Cr, OverLim) if (i - last_start + 1) > lim => {\n+                panic!(\"word starting with {} longer than limit!\",\n+                       &ss[last_start..i + 1])\n+            }\n+            (B, Cr, OverLim) => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 slice_start = last_start;\n                 B\n@@ -903,7 +914,7 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n                 last_end = i;\n                 C\n             }\n-            (B, Ws, OverLim)  => {\n+            (B, Ws, OverLim) => {\n                 last_end = i;\n                 *cont = it(&ss[slice_start..last_end]);\n                 A\n@@ -913,20 +924,18 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n                 last_start = i;\n                 B\n             }\n-            (C, Cr, OverLim)  => {\n+            (C, Cr, OverLim) => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n-            (C, Ws, OverLim)  => {\n+            (C, Ws, OverLim) => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 A\n             }\n-            (C, Ws, UnderLim) => {\n-                C\n-            }\n+            (C, Ws, UnderLim) => C,\n         };\n \n         *cont\n@@ -935,7 +944,11 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n     ss.char_indices().all(|x| machine(&mut cont, x));\n \n     // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont && match state { B | C => true, A => false } {\n+    while cont &&\n+          match state {\n+        B | C => true,\n+        A => false,\n+    } {\n         machine(&mut cont, (fake_i, ' '));\n         fake_i += 1;\n     }\n@@ -946,19 +959,21 @@ fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n fn test_split_within() {\n     fn t(s: &str, i: usize, u: &[String]) {\n         let mut v = Vec::new();\n-        each_split_within(s, i, |s| { v.push(s.to_string()); true });\n-        assert!(v.iter().zip(u).all(|(a,b)| a == b));\n+        each_split_within(s, i, |s| {\n+            v.push(s.to_string());\n+            true\n+        });\n+        assert!(v.iter().zip(u).all(|(a, b)| a == b));\n     }\n     t(\"\", 0, &[]);\n     t(\"\", 15, &[]);\n     t(\"hello\", 15, &[\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, &[\n-        \"Mary had a\".to_string(),\n-        \"little lamb\".to_string(),\n-        \"Little lamb\".to_string()\n-    ]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::usize::MAX,\n-        &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n+      15,\n+      &[\"Mary had a\".to_string(), \"little lamb\".to_string(), \"Little lamb\".to_string()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n+      ::std::usize::MAX,\n+      &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n }\n \n #[cfg(test)]\n@@ -972,442 +987,446 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test=20\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => { panic!(\"test_reqopt failed (long arg)\"); }\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!(m.opt_present(\"t\"));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => {\n+                panic!(\"test_reqopt failed (long arg)\");\n+            }\n         }\n-        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => { panic!(\"test_reqopt failed (short arg)\"); }\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => {\n+                panic!(\"test_reqopt failed (short arg)\");\n+            }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionMissing(_)) => {},\n-          _ => panic!()\n+            Err(OptionMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n-        let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n+        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionDuplicated(_)) => {},\n-          _ => panic!()\n+            Err(OptionDuplicated(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test=20\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(!m.opt_present(\"test\"));\n-            assert!(!m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(!m.opt_present(\"test\"));\n+                assert!(!m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n-        let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n+        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionDuplicated(_)) => {},\n-          _ => panic!()\n+            Err(OptionDuplicated(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert!(m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert!(m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!(m.opt_present(\"test\"));\n-            assert!(m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert!(m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(!m.opt_present(\"test\"));\n-            assert!(!m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(!m.opt_present(\"test\"));\n+                assert!(!m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"--test=20\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(UnexpectedArgument(_)) => {},\n-          _ => panic!()\n+            Err(UnexpectedArgument(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = vec!(\"--test\".to_string(), \"-t\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"--test\".to_string(), \"-t\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Err(OptionDuplicated(_)) => {},\n-          _ => panic!()\n+            Err(OptionDuplicated(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = vec!(\"-t\".to_string(), \"20\".to_string());\n-        let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n+        let args = vec![\"-t\".to_string(), \"20\".to_string()];\n+        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            // The next variable after the flag is just a free argument\n+            Ok(ref m) => {\n+                // The next variable after the flag is just a free argument\n \n-            assert!(m.free[0] == \"20\");\n-          }\n-          _ => panic!()\n+                assert!(m.free[0] == \"20\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = vec!(\"-v\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"-v\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"v\"), 1);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"v\"), 1);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = vec!(\"-v\".to_string(), \"-v\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"-v\".to_string(), \"-v\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"v\"), 2);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"v\"), 2);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = vec!(\"-vv\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"-vv\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"v\"), 2);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"v\"), 2);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = vec!(\"--verbose\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"--verbose\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"verbose\"), 1);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"verbose\"), 1);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = vec!(\"--verbose\".to_string(), \"--verbose\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"--verbose\".to_string(), \"--verbose\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"verbose\"), 2);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"verbose\"), 2);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = vec!(\"--verbose\".to_string(), \"-v\".to_string(),\n-                        \"-vv\".to_string(), \"verbose\".to_string());\n-        let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n+        let args = vec![\"--verbose\".to_string(),\n+                        \"-v\".to_string(),\n+                        \"-vv\".to_string(),\n+                        \"verbose\".to_string()];\n+        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert_eq!(m.opt_count(\"verbose\"), 4);\n-            assert_eq!(m.opt_count(\"v\"), 4);\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert_eq!(m.opt_count(\"verbose\"), 4);\n+                assert_eq!(m.opt_count(\"v\"), 4);\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = vec!(\"--test=20\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test=20\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string(), \"20\".to_string());\n+        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Ok(ref m) => {\n-            assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-            assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!((m.opt_present(\"test\")));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!((m.opt_present(\"t\")));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = vec!(\"blah\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"blah\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(!m.opt_present(\"test\"));\n-            assert!(!m.opt_present(\"t\"));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(!m.opt_present(\"test\"));\n+                assert!(!m.opt_present(\"t\"));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = vec!(\"--test\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--test\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-t\".to_string());\n+        let short_args = vec![\"-t\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(ArgumentMissing(_)) => {},\n-          _ => panic!()\n+            Err(ArgumentMissing(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = vec!(\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-              assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-              assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-              let pair = m.opt_strs(\"test\");\n-              assert!(pair[0] == \"20\");\n-              assert!(pair[1] == \"30\");\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.opt_present(\"test\"));\n+                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n+                assert!(m.opt_present(\"t\"));\n+                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n+                let pair = m.opt_strs(\"test\");\n+                assert!(pair[0] == \"20\");\n+                assert!(pair[1] == \"30\");\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = vec!(\"--untest\".to_string());\n-        let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n+        let long_args = vec![\"--untest\".to_string()];\n+        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n         let rs = getopts(&long_args, &opts);\n         match rs {\n-          Err(UnrecognizedOption(_)) => {},\n-          _ => panic!()\n+            Err(UnrecognizedOption(_)) => {}\n+            _ => panic!(),\n         }\n-        let short_args = vec!(\"-u\".to_string());\n+        let short_args = vec![\"-u\".to_string()];\n         match getopts(&short_args, &opts) {\n-          Err(UnrecognizedOption(_)) => {},\n-          _ => panic!()\n+            Err(UnrecognizedOption(_)) => {}\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_combined() {\n-        let args =\n-            vec!(\"prog\".to_string(),\n-                 \"free1\".to_string(),\n-                 \"-s\".to_string(),\n-                 \"20\".to_string(),\n-                 \"free2\".to_string(),\n-                 \"--flag\".to_string(),\n-                 \"--long=30\".to_string(),\n-                 \"-f\".to_string(),\n-                 \"-m\".to_string(),\n-                 \"40\".to_string(),\n-                 \"-m\".to_string(),\n-                 \"50\".to_string(),\n-                 \"-n\".to_string(),\n-                 \"-A B\".to_string(),\n-                 \"-n\".to_string(),\n-                 \"-60 70\".to_string());\n-        let opts =\n-            vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n-              optflag(\"\", \"flag\", \"a flag\"),\n-              reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n-              optflag(\"f\", \"\", \"another flag\"),\n-              optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n-              optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-              optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\"));\n+        let args = vec![\"prog\".to_string(),\n+                        \"free1\".to_string(),\n+                        \"-s\".to_string(),\n+                        \"20\".to_string(),\n+                        \"free2\".to_string(),\n+                        \"--flag\".to_string(),\n+                        \"--long=30\".to_string(),\n+                        \"-f\".to_string(),\n+                        \"-m\".to_string(),\n+                        \"40\".to_string(),\n+                        \"-m\".to_string(),\n+                        \"50\".to_string(),\n+                        \"-n\".to_string(),\n+                        \"-A B\".to_string(),\n+                        \"-n\".to_string(),\n+                        \"-60 70\".to_string()];\n+        let opts = vec![optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n+                        optflag(\"\", \"flag\", \"a flag\"),\n+                        reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n+                        optflag(\"f\", \"\", \"another flag\"),\n+                        optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n+                        optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n+                        optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n         let rs = getopts(&args, &opts);\n         match rs {\n-          Ok(ref m) => {\n-            assert!(m.free[0] == \"prog\");\n-            assert!(m.free[1] == \"free1\");\n-            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n-            assert!(m.free[2] == \"free2\");\n-            assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n-            assert!((m.opt_present(\"f\")));\n-            let pair = m.opt_strs(\"m\");\n-            assert!(pair[0] == \"40\");\n-            assert!(pair[1] == \"50\");\n-            let pair = m.opt_strs(\"n\");\n-            assert!(pair[0] == \"-A B\");\n-            assert!(pair[1] == \"-60 70\");\n-            assert!((!m.opt_present(\"notpresent\")));\n-          }\n-          _ => panic!()\n+            Ok(ref m) => {\n+                assert!(m.free[0] == \"prog\");\n+                assert!(m.free[1] == \"free1\");\n+                assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n+                assert!(m.free[2] == \"free2\");\n+                assert!((m.opt_present(\"flag\")));\n+                assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n+                assert!((m.opt_present(\"f\")));\n+                let pair = m.opt_strs(\"m\");\n+                assert!(pair[0] == \"40\");\n+                assert!(pair[1] == \"50\");\n+                let pair = m.opt_strs(\"n\");\n+                assert!(pair[0] == \"-A B\");\n+                assert!(pair[1] == \"-60 70\");\n+                assert!((!m.opt_present(\"notpresent\")));\n+            }\n+            _ => panic!(),\n         }\n     }\n \n     #[test]\n     fn test_multi() {\n-        let opts = vec!(optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n-                     optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                     optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n+        let opts = vec![optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n+                        optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n+                        optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n \n-        let args_single = vec!(\"-e\".to_string(), \"foo\".to_string());\n+        let args_single = vec![\"-e\".to_string(), \"foo\".to_string()];\n         let matches_single = &match getopts(&args_single, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(_) => panic!()\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(_) => panic!(),\n         };\n         assert!(matches_single.opts_present(&[\"e\".to_string()]));\n         assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n@@ -1422,11 +1441,13 @@ mod tests {\n         assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n                    \"foo\");\n \n-        let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n-                             \"foo\".to_string());\n+        let args_both = vec![\"-e\".to_string(),\n+                             \"foo\".to_string(),\n+                             \"--encrypt\".to_string(),\n+                             \"foo\".to_string()];\n         let matches_both = &match getopts(&args_both, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(_) => panic!()\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(_) => panic!(),\n         };\n         assert!(matches_both.opts_present(&[\"e\".to_string()]));\n         assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n@@ -1437,7 +1458,8 @@ mod tests {\n         assert!(!matches_both.opts_present(&[]));\n \n         assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\");\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(),\n+                   \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n                    \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n@@ -1446,12 +1468,12 @@ mod tests {\n \n     #[test]\n     fn test_nospace() {\n-        let args = vec!(\"-Lfoo\".to_string(), \"-M.\".to_string());\n-        let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                     optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n+        let args = vec![\"-Lfoo\".to_string(), \"-M.\".to_string()];\n+        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                        optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n         let matches = &match getopts(&args, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(_) => panic!()\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(_) => panic!(),\n         };\n         assert!(matches.opts_present(&[\"L\".to_string()]));\n         assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n@@ -1462,12 +1484,12 @@ mod tests {\n \n     #[test]\n     fn test_nospace_conflict() {\n-        let args = vec!(\"-vvLverbose\".to_string(), \"-v\".to_string() );\n-        let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                     optflagmulti(\"v\", \"verbose\", \"Verbose\"));\n+        let args = vec![\"-vvLverbose\".to_string(), \"-v\".to_string()];\n+        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n+                        optflagmulti(\"v\", \"verbose\", \"Verbose\")];\n         let matches = &match getopts(&args, &opts) {\n-          result::Result::Ok(m) => m,\n-          result::Result::Err(e) => panic!( \"{}\", e )\n+            result::Result::Ok(m) => m,\n+            result::Result::Err(e) => panic!(\"{}\", e),\n         };\n         assert!(matches.opts_present(&[\"L\".to_string()]));\n         assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n@@ -1483,21 +1505,22 @@ mod tests {\n             occur: Occur::Req,\n             aliases: Vec::new(),\n         };\n-        short.aliases = vec!(Opt { name: Name::Short('b'),\n-                                hasarg: HasArg::Yes,\n-                                occur: Occur::Req,\n-                                aliases: Vec::new() });\n+        short.aliases = vec![Opt {\n+                                 name: Name::Short('b'),\n+                                 hasarg: HasArg::Yes,\n+                                 occur: Occur::Req,\n+                                 aliases: Vec::new(),\n+                             }];\n         let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert!(verbose.long_to_short() == short);\n     }\n \n     #[test]\n     fn test_aliases_long_and_short() {\n-        let opts = vec!(\n-            optflagmulti(\"a\", \"apple\", \"Desc\"));\n+        let opts = vec![optflagmulti(\"a\", \"apple\", \"Desc\")];\n \n-        let args = vec!(\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string());\n+        let args = vec![\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string()];\n \n         let matches = getopts(&args, &opts).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n@@ -1506,13 +1529,11 @@ mod tests {\n \n     #[test]\n     fn test_usage() {\n-        let optgroups = vec!(\n-            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            optopt(\"a\", \"012345678901234567890123456789\",\n-                             \"Desc\", \"VAL\"),\n-            optflag(\"k\", \"kiwi\", \"Desc\"),\n-            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n+        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n+                             optflag(\"k\", \"kiwi\", \"Desc\"),\n+                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n \n         let expected =\n \"Usage: fruits\n@@ -1538,11 +1559,13 @@ Options:\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n-        let optgroups = vec!(\n-            optflag(\"k\", \"kiwi\",\n-                \"This is a long description which won't be wrapped..+..\"), // 54\n-            optflag(\"a\", \"apple\",\n-                \"This is a long description which _will_ be wrapped..+..\"));\n+        let optgroups = vec![optflag(\"k\",\n+                                     \"kiwi\",\n+                                     // 54\n+                                     \"This is a long description which won't be wrapped..+..\"),\n+                             optflag(\"a\",\n+                                     \"apple\",\n+                                     \"This is a long description which _will_ be wrapped..+..\")];\n \n         let expected =\n \"Usage: fruits\n@@ -1562,12 +1585,14 @@ Options:\n \n     #[test]\n     fn test_usage_description_multibyte_handling() {\n-        let optgroups = vec!(\n-            optflag(\"k\", \"k\\u{2013}w\\u{2013}\",\n-                \"The word kiwi is normally spelled with two i's\"),\n-            optflag(\"a\", \"apple\",\n-                \"This \\u{201C}description\\u{201D} has some characters that could \\\n-confuse the line wrapping; an apple costs 0.51\u20ac in some parts of Europe.\"));\n+        let optgroups = vec![optflag(\"k\",\n+                                     \"k\\u{2013}w\\u{2013}\",\n+                                     \"The word kiwi is normally spelled with two i's\"),\n+                             optflag(\"a\",\n+                                     \"apple\",\n+                                     \"This \\u{201C}description\\u{201D} has some characters that \\\n+                                      could confuse the line wrapping; an apple costs 0.51\u20ac in \\\n+                                      some parts of Europe.\")];\n \n         let expected =\n \"Usage: fruits\n@@ -1588,13 +1613,11 @@ Options:\n \n     #[test]\n     fn test_short_usage() {\n-        let optgroups = vec!(\n-            reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-            optopt(\"a\", \"012345678901234567890123456789\",\n-                     \"Desc\", \"VAL\"),\n-            optflag(\"k\", \"kiwi\", \"Desc\"),\n-            optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-            optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n+        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n+                             optflag(\"k\", \"kiwi\", \"Desc\"),\n+                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n \n         let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n         let generated_usage = short_usage(\"fruits\", &optgroups);"}, {"sha": "14a8d78c0b264d0b468a3ca53774d60fa453faa3", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -416,10 +416,10 @@ impl<'a> Id<'a> {\n                 _ => return Err(()),\n             }\n             if !chars.all(is_constituent) {\n-                return Err(())\n+                return Err(());\n             }\n         }\n-        return Ok(Id{ name: name });\n+        return Ok(Id { name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -496,11 +496,10 @@ pub trait Labeller<'a,N,E> {\n /// Escape tags in such a way that it is suitable for inclusion in a\n /// Graphviz HTML label.\n pub fn escape_html(s: &str) -> String {\n-    s\n-        .replace(\"&\", \"&amp;\")\n-        .replace(\"\\\"\", \"&quot;\")\n-        .replace(\"<\", \"&lt;\")\n-        .replace(\">\", \"&gt;\")\n+    s.replace(\"&\", \"&amp;\")\n+     .replace(\"\\\"\", \"&quot;\")\n+     .replace(\"<\", \"&lt;\")\n+     .replace(\">\", \"&gt;\")\n }\n \n impl<'a> LabelText<'a> {\n@@ -523,9 +522,11 @@ impl<'a> LabelText<'a> {\n             // not escaping \\\\, since Graphviz escString needs to\n             // interpret backslashes; see EscStr above.\n             '\\\\' => f(c),\n-            _ => for c in c.escape_default() {\n-                f(c)\n-            },\n+            _ => {\n+                for c in c.escape_default() {\n+                    f(c)\n+                }\n+            }\n         }\n     }\n     fn escape_str(s: &str) -> String {\n@@ -553,11 +554,13 @@ impl<'a> LabelText<'a> {\n     fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n-            LabelStr(s) => if s.contains('\\\\') {\n-                (&*s).escape_default().into_cow()\n-            } else {\n-                s\n-            },\n+            LabelStr(s) => {\n+                if s.contains('\\\\') {\n+                    (&*s).escape_default().into_cow()\n+                } else {\n+                    s\n+                }\n+            }\n             HtmlStr(s) => s,\n         }\n     }\n@@ -738,7 +741,12 @@ mod tests {\n     }\n \n     fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n-        Edge { from: from, to: to, label: label, style: style }\n+        Edge {\n+            from: from,\n+            to: to,\n+            label: label,\n+            style: style,\n+        }\n     }\n \n     struct LabelledGraph {\n@@ -1009,7 +1017,7 @@ r#\"digraph single_cyclic_node {\n \n     #[test]\n     fn hasse_diagram() {\n-        let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n+        let labels = AllNodesLabelled(vec![\"{x,y}\", \"{x}\", \"{y}\", \"{}\"]);\n         let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n                                               labels,\n                                               vec![edge(0, 1, \"\", Style::None),\n@@ -1033,7 +1041,7 @@ r#\"digraph hasse_diagram {\n \n     #[test]\n     fn left_aligned_text() {\n-        let labels = AllNodesLabelled(vec!(\n+        let labels = AllNodesLabelled(vec![\n             \"if test {\\\n            \\\\l    branch1\\\n            \\\\l} else {\\\n@@ -1043,7 +1051,7 @@ r#\"digraph hasse_diagram {\n            \\\\l\",\n             \"branch1\",\n             \"branch2\",\n-            \"afterward\"));\n+            \"afterward\"]);\n \n         let mut writer = Vec::new();\n "}, {"sha": "f1ebf16737831a96ec0970ff279058f3d262743b", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -49,7 +49,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n     if let Some(m) = mods {\n         for s in m.split(',') {\n             if s.is_empty() {\n-                continue\n+                continue;\n             }\n             let mut parts = s.split('=');\n             let (log_level, name) = match (parts.next(),\n@@ -69,13 +69,13 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n                         Some(num) => (num, Some(part0)),\n                         _ => {\n                             println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n-                            continue\n+                            continue;\n                         }\n                     }\n                 }\n                 _ => {\n                     println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n-                    continue\n+                    continue;\n                 }\n             };\n             dirs.push(LogDirective {"}, {"sha": "850c5511dd57d49b12e8d1fa4bda1d86b266f497", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -296,7 +296,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n             n => {\n                 let filter = mem::transmute::<_, &String>(n);\n                 if !args.to_string().contains(filter) {\n-                    return\n+                    return;\n                 }\n             }\n         }\n@@ -375,7 +375,7 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again.\n     if level > unsafe { LOG_LEVEL } {\n-        return false\n+        return false;\n     }\n \n     // This assertion should never get tripped unless we're in an at_exit\n@@ -393,9 +393,7 @@ fn enabled(level: u32, module: &str, iter: slice::Iter<directive::LogDirective>)\n     for directive in iter.rev() {\n         match directive.name {\n             Some(ref name) if !module.starts_with(&name[..]) => {}\n-            Some(..) | None => {\n-                return level <= directive.level\n-            }\n+            Some(..) | None => return level <= directive.level,\n         }\n     }\n     level <= DEFAULT_LOG_LEVEL"}, {"sha": "e2c157f98a6a4d2b11ed1e5fc9fe90ab1c9ec9bc", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -12,8 +12,8 @@\n \n use {Rng, SeedableRng, Rand};\n \n-const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key\n-const STATE_WORDS  : usize = 16;\n+const KEY_WORDS: usize = 8; // 8 words for the 256-bit key\n+const STATE_WORDS: usize = 16;\n const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as of this writing\n \n /// A random number generator that uses the ChaCha20 algorithm [1].\n@@ -77,7 +77,6 @@ fn core(output: &mut [u32; STATE_WORDS], input: &[u32; STATE_WORDS]) {\n }\n \n impl ChaChaRng {\n-\n     /// Create an ChaCha random number generator using the default\n     /// fixed key of 8 zero words.\n     pub fn new_unseeded() -> ChaChaRng {\n@@ -173,7 +172,6 @@ impl Rng for ChaChaRng {\n }\n \n impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n-\n     fn reseed(&mut self, seed: &'a [u32]) {\n         // reset state\n         self.init(&[0; KEY_WORDS]);"}, {"sha": "8cd7ac06f991bda5fc35f645fd7f8f68730d883d", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -89,7 +89,7 @@ impl Gamma {\n \n         let repr = match shape {\n             1.0 => One(Exp::new(1.0 / scale)),\n-            0.0 ... 1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n+            0.0...1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n             _ => Large(GammaLargeShape::new_raw(shape, scale)),\n         };\n         Gamma { repr: repr }\n@@ -153,7 +153,8 @@ impl IndependentSample<f64> for GammaLargeShape {\n         loop {\n             let StandardNormal(x) = rng.gen::<StandardNormal>();\n             let v_cbrt = 1.0 + self.c * x;\n-            if v_cbrt <= 0.0 { // a^3 <= 0 iff a <= 0\n+            if v_cbrt <= 0.0 {\n+                // a^3 <= 0 iff a <= 0\n                 continue;\n             }\n "}, {"sha": "a54c8df2352ac363b6ac519d350bb651cf2ed0b2", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -118,8 +118,10 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         for item in &mut *items {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n-                None => panic!(\"WeightedChoice::new called with a total weight larger than a \\\n-                                usize can contain\"),\n+                None => {\n+                    panic!(\"WeightedChoice::new called with a total weight larger than a usize \\\n+                            can contain\")\n+                }\n             };\n \n             item.weight = running_total;\n@@ -199,7 +201,6 @@ mod ziggurat_tables;\n /// * `pdf`: the probability density function\n /// * `zero_case`: manual sampling from the tail when we chose the\n ///    bottom box (i.e. i == 0)\n-\n // the perf improvement (25-50%) is definitely worth the extra code\n // size from force-inlining.\n #[inline(always)]"}, {"sha": "1f56a82eba86eea72dfe576f32a2fe42254a4b41", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -54,7 +54,6 @@ static EMPTY: IsaacRng = IsaacRng {\n };\n \n impl IsaacRng {\n-\n     /// Create an ISAAC random number generator using the default\n     /// fixed seed.\n     pub fn new_unseeded() -> IsaacRng {\n@@ -403,7 +402,7 @@ impl Isaac64Rng {\n         // abbreviations\n         let mut a = self.a;\n         let mut b = self.b + self.c;\n-        const MIDPOINT: usize =  RAND_SIZE_64 / 2;\n+        const MIDPOINT: usize = RAND_SIZE_64 / 2;\n         const MP_VEC: [(usize, usize); 2] = [(0, MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind {\n             ($x:expr) => {"}, {"sha": "247dcd03b5d7abbd04ffe3f1ea76168bebcc9d12", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -306,10 +306,9 @@ impl<'a, R: Rng> Iterator for AsciiGenerator<'a, R> {\n     type Item = char;\n \n     fn next(&mut self) -> Option<char> {\n-        const GEN_ASCII_STR_CHARSET: &'static [u8] =\n-            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-              abcdefghijklmnopqrstuvwxyz\\\n-              0123456789\";\n+        const GEN_ASCII_STR_CHARSET: &'static [u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                                       abcdefghijklmnopqrstuvwxyz\\\n+                                                       0123456789\";\n         Some(*self.rng.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n     }\n }"}, {"sha": "34b7f37a6788f98f2023edc20898809d454ed2c0", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef2af620187350a49c840099760f24acd21c861/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=bef2af620187350a49c840099760f24acd21c861", "patch": "@@ -202,7 +202,7 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K}\n tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n \n-impl<T:Rand> Rand for Option<T> {\n+impl<T: Rand> Rand for Option<T> {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n         if rng.gen() {"}]}