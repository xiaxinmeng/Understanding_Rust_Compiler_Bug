{"sha": "9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OTBlMDQ2NmQ5NTFkMWIwMDIwYWUzOGUyYTRjMGQ4YzQzY2ZlYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-19T12:37:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T16:35:25Z"}, "message": "rustc: allow handling cycle errors gracefully in on-demand.", "tree": {"sha": "f4e0f8d6801c1f3a202606b151cd65caa8fe61a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4e0f8d6801c1f3a202606b151cd65caa8fe61a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "html_url": "https://github.com/rust-lang/rust/commit/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba11640179bbde334b525146d3a164999412cc73", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba11640179bbde334b525146d3a164999412cc73", "html_url": "https://github.com/rust-lang/rust/commit/ba11640179bbde334b525146d3a164999412cc73"}], "stats": {"total": 158, "additions": 104, "deletions": 54}, "files": [{"sha": "9f45e66f0d937116c255fc65484d64086a67c82b", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n use std::ops::Index;\n use std::hash::Hash;\n use std::marker::PhantomData;\n@@ -67,6 +68,11 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         assert!(old_value.is_none());\n     }\n \n+    pub fn entry(&mut self, k: M::Key) -> Entry<M::Key, M::Value> {\n+        self.write(&k);\n+        self.map.entry(k)\n+    }\n+\n     pub fn contains_key(&self, k: &M::Key) -> bool {\n         self.read(k);\n         self.map.contains_key(k)"}, {"sha": "26c92e3e7ecf72dee18d354a5d7f09d56a083be3", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 70, "deletions": 30, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -13,10 +13,9 @@ use hir::def_id::{CrateNum, DefId};\n use middle::const_val::ConstVal;\n use mir;\n use ty::{self, Ty, TyCtxt};\n-use util::common::MemoizationMap;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n-use std::cell::RefCell;\n+use std::cell::{RefCell, RefMut};\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -66,8 +65,13 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n+pub struct CycleError<'a> {\n+    span: Span,\n+    cycle: RefMut<'a, [(Span, Query)]>\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    fn report_cycle(self, span: Span, cycle: &[(Span, Query)]) {\n+    pub fn report_cycle(self, CycleError { span, cycle }: CycleError) {\n         assert!(!cycle.is_empty());\n \n         let mut err = struct_span_err!(self.sess, span, E0391,\n@@ -88,24 +92,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn cycle_check<F, R>(self, span: Span, query: Query, compute: F) -> R\n+    fn cycle_check<F, R>(self, span: Span, query: Query, compute: F)\n+                         -> Result<R, CycleError<'a>>\n         where F: FnOnce() -> R\n     {\n         {\n             let mut stack = self.maps.query_stack.borrow_mut();\n             if let Some((i, _)) = stack.iter().enumerate().rev()\n                                        .find(|&(_, &(_, ref q))| *q == query) {\n-                let cycle = &stack[i..];\n-                self.report_cycle(span, cycle);\n-                return R::from_cycle_error(self.global_tcx());\n+                return Err(CycleError {\n+                    span: span,\n+                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n+                });\n             }\n             stack.push((span, query));\n         }\n \n         let result = compute();\n \n         self.maps.query_stack.borrow_mut().pop();\n-        result\n+\n+        Ok(result)\n     }\n }\n \n@@ -140,7 +147,7 @@ macro_rules! define_maps {\n        pub $name:ident: $node:ident($K:ty) -> $V:ty),*) => {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            pub query_stack: RefCell<Vec<(Span, Query)>>,\n+            query_stack: RefCell<Vec<(Span, Query)>>,\n             $($(#[$attr])* pub $name: RefCell<DepTrackingMap<queries::$name<$tcx>>>),*\n         }\n \n@@ -182,7 +189,60 @@ macro_rules! define_maps {\n         $(impl<$tcx> DepTrackingMapConfig for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n-            fn to_dep_node(key: &$K) -> DepNode<DefId> { DepNode::$node(*key) }\n+\n+            #[allow(unused)]\n+            fn to_dep_node(key: &$K) -> DepNode<DefId> {\n+                use dep_graph::DepNode::*;\n+\n+                $node(*key)\n+            }\n+        }\n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                                  mut span: Span,\n+                                  key: $K,\n+                                  f: F)\n+                                  -> Result<R, CycleError<'a>>\n+                where F: FnOnce(&$V) -> R\n+            {\n+                if let Some(result) = tcx.maps.$name.borrow().get(&key) {\n+                    return Ok(f(result));\n+                }\n+\n+                // FIXME(eddyb) Get more valid Span's on queries.\n+                if span == DUMMY_SP {\n+                    span = key.default_span(tcx);\n+                }\n+\n+                let _task = tcx.dep_graph.in_task(Self::to_dep_node(&key));\n+\n+                let result = tcx.cycle_check(span, Query::$name(key), || {\n+                    let provider = tcx.maps.providers[key.map_crate()].$name;\n+                    provider(tcx.global_tcx(), key)\n+                })?;\n+\n+                Ok(f(&tcx.maps.$name.borrow_mut().entry(key).or_insert(result)))\n+            }\n+\n+            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n+                           -> Result<$V, CycleError<'a>> {\n+                Self::try_get_with(tcx, span, key, Clone::clone)\n+            }\n+\n+            $(#[$attr])*\n+            pub fn get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) -> $V {\n+                Self::try_get(tcx, span, key).unwrap_or_else(|e| {\n+                    tcx.report_cycle(e);\n+                    Value::from_cycle_error(tcx.global_tcx())\n+                })\n+            }\n+\n+            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n+                match Self::try_get_with(tcx, span, key, |_| ()) {\n+                    Ok(()) => {}\n+                    Err(e) => tcx.report_cycle(e)\n+                }\n+            }\n         })*\n \n         pub struct Providers<$tcx> {\n@@ -203,26 +263,6 @@ macro_rules! define_maps {\n                 Providers { $($name),* }\n             }\n         }\n-\n-        impl<'a, $tcx, 'lcx> Maps<$tcx> {\n-            $($(#[$attr])*\n-              pub fn $name(&self,\n-                           tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                           mut span: Span,\n-                           key: $K) -> $V {\n-                self.$name.memoize(key, || {\n-                    // FIXME(eddyb) Get more valid Span's on queries.\n-                    if span == DUMMY_SP {\n-                        span = key.default_span(tcx);\n-                    }\n-\n-                    tcx.cycle_check(span, Query::$name(key), || {\n-                        let provider = self.providers[key.map_crate()].$name;\n-                        provider(tcx.global_tcx(), key)\n-                    })\n-                })\n-            })*\n-        }\n     }\n }\n "}, {"sha": "5ab0c9e5655190847955e2fffd1194e0cc51a610", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -75,6 +75,8 @@ pub use self::context::{Lift, TypeckTables};\n \n pub use self::trait_def::{TraitDef, TraitFlags};\n \n+pub use self::maps::queries;\n+\n pub mod adjustment;\n pub mod cast;\n pub mod error;\n@@ -1947,7 +1949,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn item_tables(self, def_id: DefId) -> &'gcx TypeckTables<'gcx> {\n-        self.maps.typeck_tables(self, DUMMY_SP, def_id)\n+        queries::typeck_tables::get(self, DUMMY_SP, def_id)\n     }\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n@@ -2055,12 +2057,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        self.maps.custom_coerce_unsized_kind(self, DUMMY_SP, did)\n+        queries::custom_coerce_unsized_kind::get(self, DUMMY_SP, did)\n     }\n \n     pub fn associated_item(self, def_id: DefId) -> AssociatedItem {\n         if !def_id.is_local() {\n-            return self.maps.associated_item(self, DUMMY_SP, def_id);\n+            return queries::associated_item::get(self, DUMMY_SP, def_id);\n         }\n \n         self.maps.associated_item.memoize(def_id, || {\n@@ -2165,7 +2167,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n         if !def_id.is_local() {\n-            return self.maps.associated_item_def_ids(self, DUMMY_SP, def_id);\n+            return queries::associated_item_def_ids::get(self, DUMMY_SP, def_id);\n         }\n \n         self.maps.associated_item_def_ids.memoize(def_id, || {\n@@ -2200,7 +2202,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n     pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n-        self.maps.impl_trait_ref(self, DUMMY_SP, id)\n+        queries::impl_trait_ref::get(self, DUMMY_SP, id)\n     }\n \n     // Returns `ty::VariantDef` if `def` refers to a struct,\n@@ -2279,37 +2281,37 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n     pub fn item_type(self, did: DefId) -> Ty<'gcx> {\n-        self.maps.ty(self, DUMMY_SP, did)\n+        queries::ty::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n     pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n-        self.maps.trait_def(self, DUMMY_SP, did)\n+        queries::trait_def::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n     pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n-        self.maps.adt_def(self, DUMMY_SP, did)\n+        queries::adt_def::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its generics.\n     pub fn item_generics(self, did: DefId) -> &'gcx Generics {\n-        self.maps.generics(self, DUMMY_SP, did)\n+        queries::generics::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n     pub fn item_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        self.maps.predicates(self, DUMMY_SP, did)\n+        queries::predicates::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n     pub fn item_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n-        self.maps.super_predicates(self, DUMMY_SP, did)\n+        queries::super_predicates::get(self, DUMMY_SP, did)\n     }\n \n     /// Given the did of an item, returns its MIR, borrowed immutably.\n     pub fn item_mir(self, did: DefId) -> Ref<'gcx, Mir<'gcx>> {\n-        self.maps.mir(self, DUMMY_SP, did).borrow()\n+        queries::mir::get(self, DUMMY_SP, did).borrow()\n     }\n \n     /// If `type_needs_drop` returns true, then `ty` is definitely\n@@ -2361,7 +2363,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n-        self.maps.variances(self, DUMMY_SP, item_id)\n+        queries::variances::get(self, DUMMY_SP, item_id)\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n@@ -2436,11 +2438,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        self.maps.closure_kind(self, DUMMY_SP, def_id)\n+        queries::closure_kind::get(self, DUMMY_SP, def_id)\n     }\n \n     pub fn closure_type(self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        self.maps.closure_type(self, DUMMY_SP, def_id)\n+        queries::closure_type::get(self, DUMMY_SP, def_id)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "1b19e79d489d6697106e1afb2a2e77f8ed40224e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -47,7 +47,7 @@ macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident $($name:ident => $compute:block)*) => {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n             $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n-                                    -> <ty::maps::queries::$name<$lt> as\n+                                    -> <ty::queries::$name<$lt> as\n                                         DepTrackingMapConfig>::Value {\n                 assert!(!$def_id.is_local());\n "}, {"sha": "e73700f04fa4e5317ac3ca07c17c3460466da3b6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             discr: variant.discr,\n             evaluated_discr: match variant.discr {\n                 ty::VariantDiscr::Explicit(def_id) => {\n-                    tcx.maps.monomorphic_const_eval(tcx, DUMMY_SP, def_id).ok()\n+                    ty::queries::monomorphic_const_eval::get(tcx, DUMMY_SP, def_id).ok()\n                 }\n                 ty::VariantDiscr::Relative(_) => None\n             },"}, {"sha": "aae3947df1424df15165dab24b2e0e9c22af6baf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -243,7 +243,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n         let default_needs_object_self = |p: &ty::TypeParameterDef| {\n             if is_object && p.has_default {\n-                if tcx.maps.ty(tcx, span, p.def_id).has_self_ty() {\n+                if ty::queries::ty::get(tcx, span, p.def_id).has_self_ty() {\n                     // There is no suitable inference default for a type parameter\n                     // that references self, in an object type.\n                     return true;\n@@ -310,7 +310,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    tcx.maps.ty(tcx, span, def.def_id).subst_spanned(tcx, substs, Some(span))\n+                    ty::queries::ty::get(tcx, span, def.def_id)\n+                        .subst_spanned(tcx, substs, Some(span))\n                 }\n             } else {\n                 // We've already errored above about the mismatch.\n@@ -599,7 +600,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        self.tcx().maps.ty(self.tcx(), span, did).subst(self.tcx(), substs)\n+        ty::queries::ty::get(self.tcx(), span, did).subst(self.tcx(), substs)\n     }\n \n     /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n@@ -985,7 +986,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(&path.segments);\n \n-                let ty = tcx.maps.ty(tcx, span, def_id);\n+                let ty = ty::queries::ty::get(tcx, span, def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n                 } else {"}, {"sha": "83adbdaf0307d3d9eefc93b99cce208b61554d69", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                  def_id: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {\n-        self.tcx.maps.type_param_predicates(self.tcx, span, (self.item_def_id, def_id))\n+        ty::queries::type_param_predicates::get(self.tcx, span, (self.item_def_id, def_id))\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n@@ -532,7 +532,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n         hir::ItemTrait(..) => {\n             tcx.item_generics(def_id);\n             tcx.lookup_trait_def(def_id);\n-            tcx.maps.super_predicates(tcx, it.span, def_id);\n+            ty::queries::super_predicates::get(tcx, it.span, def_id);\n             tcx.item_predicates(def_id);\n         },\n         hir::ItemStruct(ref struct_def, _) |\n@@ -836,7 +836,7 @@ fn super_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Now require that immediate supertraits are converted,\n     // which will, in turn, reach indirect supertraits.\n     for bound in superbounds.iter().filter_map(|p| p.to_opt_poly_trait_ref()) {\n-        tcx.maps.super_predicates(tcx, item.span, bound.def_id());\n+        ty::queries::super_predicates::get(tcx, item.span, bound.def_id());\n     }\n \n     ty::GenericPredicates {"}, {"sha": "6825572b26c83cfa83eb9b154e4b2d2275fb1f41", "filename": "src/test/compile-fail/cycle-trait-default-type-trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs?ref=9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "patch": "@@ -13,6 +13,7 @@\n \n trait Foo<X = Box<Foo>> {\n     //~^ ERROR unsupported cyclic reference\n+    //~| ERROR unsupported cyclic reference\n }\n \n fn main() { }"}]}