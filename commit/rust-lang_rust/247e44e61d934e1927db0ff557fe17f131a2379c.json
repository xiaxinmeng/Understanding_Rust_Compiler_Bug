{"sha": "247e44e61d934e1927db0ff557fe17f131a2379c", "node_id": "C_kwDOAAsO6NoAKDI0N2U0NGU2MWQ5MzRlMTkyN2RiMGZmNTU3ZmUxN2YxMzFhMjM3OWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-31T05:27:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-31T05:27:07Z"}, "message": "Auto merge of #106324 - compiler-errors:rollup-2m9njin, r=compiler-errors\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #105903 (Unify id-based thread parking implementations)\n - #106232 (CFI: Monomorphize transparent ADTs before typeid)\n - #106248 (Revert \"Implement allow-by-default `multiple_supertrait_upcastable` lint\")\n - #106286 (Make tidy errors red)\n - #106295 (Extend scraped examples layout GUI test for position of buttons)\n - #106305 ( bootstrap: Get rid of tail_args in stream_cargo)\n - #106310 (Dont use `--merge-base` during bootstrap formatting subcommand)\n - #106314 (Fix panic on `x build --help`)\n - #106317 (Only deduplicate stack traces for good path bugs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e0f648a4cd8ac657596da6df01a38feba82530da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0f648a4cd8ac657596da6df01a38feba82530da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/247e44e61d934e1927db0ff557fe17f131a2379c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/247e44e61d934e1927db0ff557fe17f131a2379c", "html_url": "https://github.com/rust-lang/rust/commit/247e44e61d934e1927db0ff557fe17f131a2379c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/247e44e61d934e1927db0ff557fe17f131a2379c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5570cda1870a399532c34b36c89fe0b03d59c72c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5570cda1870a399532c34b36c89fe0b03d59c72c", "html_url": "https://github.com/rust-lang/rust/commit/5570cda1870a399532c34b36c89fe0b03d59c72c"}, {"sha": "d798e228eacfae98f54f15accea21ee7a3eaefcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d798e228eacfae98f54f15accea21ee7a3eaefcd", "html_url": "https://github.com/rust-lang/rust/commit/d798e228eacfae98f54f15accea21ee7a3eaefcd"}], "stats": {"total": 1006, "additions": 428, "deletions": 578}, "files": [{"sha": "f99e58e59b8e55d48bcb40f6153be3a1ed397531", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -2675,9 +2675,9 @@ dependencies = [\n \n [[package]]\n name = \"owo-colors\"\n-version = \"3.4.0\"\n+version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"decf7381921fea4dcb2549c5667eda59b3ec297ab7e2b5fc33eac69d2e7da87b\"\n+checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n [[package]]\n name = \"packed_simd_2\"\n@@ -5203,9 +5203,9 @@ dependencies = [\n \n [[package]]\n name = \"termcolor\"\n-version = \"1.1.2\"\n+version = \"1.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2dfed899f0eb03f32ee8c6a0aabdb8a7949659e3466561fc0adf54e26d88c5f4\"\n+checksum = \"bab24d30b911b2376f3a13cc2cd443142f0c81dda04c118693e35b3835757755\"\n dependencies = [\n  \"winapi-util\",\n ]\n@@ -5309,6 +5309,7 @@ dependencies = [\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n+ \"termcolor\",\n  \"walkdir\",\n ]\n "}, {"sha": "30179e978725c2ba38f9157f8744accad2194882", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -1199,8 +1199,8 @@ static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n             };\n \n             // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for `ExplicitBug`, which has an unhelpful message and backtrace.\n-            if !info.payload().is::<rustc_errors::ExplicitBug>() {\n+            // Don't do this for `GoodPathBug`, which already emits its own more useful backtrace.\n+            if !info.payload().is::<rustc_errors::GoodPathBug>() {\n                 (*DEFAULT_HOOK)(info);\n \n                 // Separate the output with an empty line\n@@ -1237,7 +1237,9 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     // a .span_bug or .bug call has already printed what\n     // it wants to print.\n-    if !info.payload().is::<rustc_errors::ExplicitBug>() {\n+    if !info.payload().is::<rustc_errors::ExplicitBug>()\n+        && !info.payload().is::<rustc_errors::GoodPathBug>()\n+    {\n         let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n         handler.emit_diagnostic(&mut d);\n     }"}, {"sha": "0455f0d7383ae67e9d50b7058b7853498c33b9bb", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -40,12 +40,13 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::HashStableContext;\n use rustc_span::{Loc, Span};\n \n+use std::any::Any;\n use std::borrow::Cow;\n+use std::fmt;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n use std::panic;\n use std::path::Path;\n-use std::{error, fmt};\n \n use termcolor::{Color, ColorSpec};\n \n@@ -361,16 +362,11 @@ pub use rustc_span::fatal_error::{FatalError, FatalErrorMarker};\n \n /// Signifies that the compiler died with an explicit call to `.bug`\n /// or `.span_bug` rather than a failed assertion, etc.\n-#[derive(Copy, Clone, Debug)]\n pub struct ExplicitBug;\n \n-impl fmt::Display for ExplicitBug {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"parser internal bug\")\n-    }\n-}\n-\n-impl error::Error for ExplicitBug {}\n+/// Signifies that the compiler died with an explicit call to `.delay_good_path_bug`\n+/// rather than a failed assertion, etc.\n+pub struct GoodPathBug;\n \n pub use diagnostic::{\n     AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n@@ -507,7 +503,11 @@ impl Drop for HandlerInner {\n \n         if !self.has_errors() {\n             let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n-            self.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n+            self.flush_delayed(\n+                bugs,\n+                \"no errors encountered even though `delay_span_bug` issued\",\n+                ExplicitBug,\n+            );\n         }\n \n         // FIXME(eddyb) this explains what `delayed_good_path_bugs` are!\n@@ -520,6 +520,7 @@ impl Drop for HandlerInner {\n             self.flush_delayed(\n                 bugs.into_iter().map(DelayedDiagnostic::decorate),\n                 \"no warnings or errors encountered even though `delayed_good_path_bugs` issued\",\n+                GoodPathBug,\n             );\n         }\n \n@@ -1203,7 +1204,11 @@ impl Handler {\n     pub fn flush_delayed(&self) {\n         let mut inner = self.inner.lock();\n         let bugs = std::mem::replace(&mut inner.delayed_span_bugs, Vec::new());\n-        inner.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n+        inner.flush_delayed(\n+            bugs,\n+            \"no errors encountered even though `delay_span_bug` issued\",\n+            ExplicitBug,\n+        );\n     }\n }\n \n@@ -1580,6 +1585,7 @@ impl HandlerInner {\n         &mut self,\n         bugs: impl IntoIterator<Item = Diagnostic>,\n         explanation: impl Into<DiagnosticMessage> + Copy,\n+        panic_with: impl Any + Send + 'static,\n     ) {\n         let mut no_bugs = true;\n         for mut bug in bugs {\n@@ -1607,7 +1613,7 @@ impl HandlerInner {\n \n         // Panic with `ExplicitBug` to avoid \"unexpected panic\" messages.\n         if !no_bugs {\n-            panic::panic_any(ExplicitBug);\n+            panic::panic_any(panic_with);\n         }\n     }\n "}, {"sha": "deb37bdebda638a77701537f008000a80452a4d6", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -160,8 +160,6 @@ declare_features! (\n     (active, intrinsics, \"1.0.0\", None, None),\n     /// Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n     (active, lang_items, \"1.0.0\", None, None),\n-    /// Allows the `multiple_supertrait_upcastable` lint.\n-    (active, multiple_supertrait_upcastable, \"CURRENT_RUSTC_VERSION\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items."}, {"sha": "1275d6f223c7a38ebe5fbfd42cc50c04c4990149", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -61,7 +61,6 @@ mod late;\n mod let_underscore;\n mod levels;\n mod methods;\n-mod multiple_supertrait_upcastable;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n@@ -96,7 +95,6 @@ use hidden_unicode_codepoints::*;\n use internal::*;\n use let_underscore::*;\n use methods::*;\n-use multiple_supertrait_upcastable::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n@@ -231,7 +229,6 @@ late_lint_methods!(\n             InvalidAtomicOrdering: InvalidAtomicOrdering,\n             NamedAsmLabels: NamedAsmLabels,\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n-            MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n         ]\n     ]\n );"}, {"sha": "5861b826b1ca337309631b1ed4c5e0947f9adaf7", "filename": "compiler/rustc_lint/src/multiple_supertrait_upcastable.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,63 +0,0 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n-\n-use rustc_errors::DelayDm;\n-use rustc_hir as hir;\n-use rustc_span::sym;\n-\n-declare_lint! {\n-    /// The `multiple_supertrait_upcastable` lint detects when an object-safe trait has multiple\n-    /// supertraits.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust\n-    /// trait A {}\n-    /// trait B {}\n-    ///\n-    /// #[warn(multiple_supertrait_upcastable)]\n-    /// trait C: A + B {}\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// To support upcasting with multiple supertraits, we need to store multiple vtables and this\n-    /// can result in extra space overhead, even if no code actually uses upcasting.\n-    /// This lint allows users to identify when such scenarios occur and to decide whether the\n-    /// additional overhead is justified.\n-    pub MULTIPLE_SUPERTRAIT_UPCASTABLE,\n-    Allow,\n-    \"detect when an object-safe trait has multiple supertraits\",\n-    @feature_gate = sym::multiple_supertrait_upcastable;\n-}\n-\n-declare_lint_pass!(MultipleSupertraitUpcastable => [MULTIPLE_SUPERTRAIT_UPCASTABLE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MultipleSupertraitUpcastable {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        let def_id = item.owner_id.to_def_id();\n-        if let hir::ItemKind::Trait(_, _, _, _, _) = item.kind\n-            && cx.tcx.is_object_safe(def_id)\n-        {\n-            let direct_super_traits_iter = cx.tcx\n-                    .super_predicates_of(def_id)\n-                    .predicates\n-                    .into_iter()\n-                    .filter_map(|(pred, _)| pred.to_opt_poly_trait_pred());\n-            if direct_super_traits_iter.count() > 1 {\n-                cx.struct_span_lint(\n-                    MULTIPLE_SUPERTRAIT_UPCASTABLE,\n-                    cx.tcx.def_span(def_id),\n-                    DelayDm(|| {\n-                        format!(\n-                            \"`{}` is object-safe and has multiple supertraits\",\n-                            item.ident,\n-                        )\n-                    }),\n-                    |diag| diag,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "85510fa2c660c53c700764823d1150eb3721927e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -944,7 +944,6 @@ symbols! {\n         mul,\n         mul_assign,\n         mul_with_overflow,\n-        multiple_supertrait_upcastable,\n         must_not_suspend,\n         must_use,\n         naked,"}, {"sha": "e9b85705086b55fc81aea67c4faf66436da0ce56", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -164,6 +164,7 @@ fn encode_const<'tcx>(\n \n /// Encodes a FnSig using the Itanium C++ ABI with vendor extended type qualifiers and types for\n /// Rust types that are not used at the FFI boundary.\n+#[instrument(level = \"trace\", skip(tcx, dict))]\n fn encode_fnsig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_sig: &FnSig<'tcx>,\n@@ -653,6 +654,7 @@ fn encode_ty<'tcx>(\n // Transforms a ty:Ty for being encoded and used in the substitution dictionary. It transforms all\n // c_void types into unit types unconditionally, and generalizes all pointers if\n // TransformTyOptions::GENERALIZE_POINTERS option is set.\n+#[instrument(level = \"trace\", skip(tcx))]\n fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptions) -> Ty<'tcx> {\n     let mut ty = ty;\n \n@@ -698,7 +700,7 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                     !is_zst\n                 });\n                 if let Some(field) = field {\n-                    let ty0 = tcx.type_of(field.did);\n+                    let ty0 = tcx.bound_type_of(field.did).subst(tcx, substs);\n                     // Generalize any repr(transparent) user-defined type that is either a pointer\n                     // or reference, and either references itself or any other type that contains or\n                     // references itself, to avoid a reference cycle.\n@@ -827,6 +829,7 @@ fn transform_substs<'tcx>(\n \n /// Returns a type metadata identifier for the specified FnAbi using the Itanium C++ ABI with vendor\n /// extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n+#[instrument(level = \"trace\", skip(tcx))]\n pub fn typeid_for_fnabi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_abi: &FnAbi<'tcx, Ty<'tcx>>,"}, {"sha": "9857f0516baa217f84fc0e66223c4e53bf0da7a4", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -87,7 +87,6 @@\n #![warn(missing_debug_implementations)]\n #![warn(missing_docs)]\n #![allow(explicit_outlives_requirements)]\n-#![cfg_attr(not(bootstrap), warn(multiple_supertrait_upcastable))]\n //\n // Library features:\n #![feature(alloc_layout_extra)]\n@@ -192,7 +191,6 @@\n #![feature(unsized_fn_params)]\n #![feature(c_unwind)]\n #![feature(with_negative_coherence)]\n-#![cfg_attr(not(bootstrap), feature(multiple_supertrait_upcastable))]\n //\n // Rustdoc features:\n #![feature(doc_cfg)]"}, {"sha": "7152300abcbf3a446cca031d797040d23abb2353", "filename": "library/core/src/error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -28,7 +28,6 @@ use crate::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[rustc_has_incoherent_inherent_impls]\n-#[cfg_attr(not(bootstrap), allow(multiple_supertrait_upcastable))]\n pub trait Error: Debug + Display {\n     /// The lower-level source of this error, if any.\n     ///"}, {"sha": "0e3fef4ead31aefd1703f83966fffe0ce6ecb6af", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -95,7 +95,6 @@\n #![warn(missing_docs)]\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n-#![cfg_attr(not(bootstrap), warn(multiple_supertrait_upcastable))]\n //\n // Library features:\n #![feature(const_align_offset)]\n@@ -232,7 +231,6 @@\n #![feature(unsized_fn_params)]\n #![feature(asm_const)]\n #![feature(const_transmute_copy)]\n-#![cfg_attr(not(bootstrap), feature(multiple_supertrait_upcastable))]\n //\n // Target features:\n #![feature(arm_target_feature)]"}, {"sha": "9865a945bad1d17389586da7633767f04eba3991", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -34,7 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n mod condvar;"}, {"sha": "1608b8cb642dc858ba13482b2d1f5c72a0ba6bfa", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -65,9 +65,9 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::thread_parker::Parker;\n     use crate::pin::Pin;\n     use crate::sync::Arc;\n+    use crate::sys_common::thread_parking::Parker;\n \n     pub struct Notifier(Arc<Parker>);\n \n@@ -87,14 +87,14 @@ pub mod wait_notify {\n         /// called, this will return immediately, otherwise the current thread\n         /// is blocked until notified.\n         pub fn wait(self) {\n-            // This is not actually `unsafe`, but it uses the `Parker` API,\n-            // which needs `unsafe` on some platforms.\n+            // SAFETY:\n+            // This is only ever called on one thread.\n             unsafe { Pin::new(&*self.0).park() }\n         }\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(Parker::new_internal());\n+        let inner = Arc::new(Parker::new());\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,107 +0,0 @@\n-//! Thread parking based on SGX events.\n-\n-use super::abi::{thread, usercalls};\n-use crate::io::ErrorKind;\n-use crate::pin::Pin;\n-use crate::ptr::{self, NonNull};\n-use crate::sync::atomic::AtomicPtr;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::time::Duration;\n-use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n-\n-// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n-// be valid pointers\n-const EMPTY: *mut u8 = ptr::invalid_mut(1);\n-const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n-\n-pub struct Parker {\n-    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n-    /// A state change to NOTIFIED must be done with release ordering\n-    /// and be observed with acquire ordering so that operations after\n-    /// `thread::park` returns will not occur before the unpark message\n-    /// was sent.\n-    state: AtomicPtr<u8>,\n-}\n-\n-impl Parker {\n-    /// Construct the thread parker. The UNIX parker implementation\n-    /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n-        unsafe { parker.write(Parker::new_internal()) }\n-    }\n-\n-    pub(super) fn new_internal() -> Parker {\n-        Parker { state: AtomicPtr::new(EMPTY) }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let mut prev = EMPTY;\n-            loop {\n-                // Guard against changing TCS addresses by always setting the state to\n-                // the current value.\n-                let tcs = thread::current().as_ptr();\n-                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n-                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n-                    assert!(event & EV_UNPARK == EV_UNPARK);\n-                    prev = tcs;\n-                } else {\n-                    // The state was definitely changed by another thread at this point.\n-                    // The only time this occurs is when the state is changed to NOTIFIED.\n-                    // We observed this change with acquire ordering, so we can simply\n-                    // change the state to EMPTY with a relaxed store.\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // At this point, the token was definately read with acquire ordering,\n-        // so this can be a relaxed store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n-        let tcs = thread::current().as_ptr();\n-\n-        if self.state.load(Acquire) != NOTIFIED {\n-            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n-                match usercalls::wait(EV_UNPARK, timeout) {\n-                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n-                    Err(e) => {\n-                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n-                    }\n-                }\n-\n-                // Swap to provide acquire ordering even if the timeout occurred\n-                // before the token was set. This situation can result in spurious\n-                // wakeups on the next call to `park_timeout`, but it is better to let\n-                // those be handled by the user than do some perhaps unnecessary, but\n-                // always expensive guarding.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        // The token was already read with `acquire` ordering, this can be a store.\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            // There is a thread waiting, wake it up.\n-            let tcs = NonNull::new(state).unwrap();\n-            // This will fail if the thread has already terminated or its TCS is destroyed\n-            // by the time the signal is sent, but that is fine. If another thread receives\n-            // the same TCS, it will receive this notification as a spurious wakeup, but\n-            // all users of `wait` should and (internally) do guard against those where\n-            // necessary.\n-            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n-        }\n-    }\n-}"}, {"sha": "0006cd4f1be2502a1bdc182be8fb37d3981effde", "filename": "library/std/src/sys/sgx/thread_parking.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parking.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -0,0 +1,23 @@\n+use super::abi::usercalls;\n+use crate::io::ErrorKind;\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+pub type ThreadId = fortanix_sgx_abi::Tcs;\n+\n+pub use super::abi::thread::current;\n+\n+pub fn park(_hint: usize) {\n+    usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+    if let Err(e) = usercalls::wait(EV_UNPARK, timeout) {\n+        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+    }\n+}\n+\n+pub fn unpark(tid: ThreadId, _hint: usize) {\n+    let _ = usercalls::send(EV_UNPARK, Some(tid));\n+}"}, {"sha": "30a96be14300a8f8c07fb2f81cf52af12e640ef6", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -40,7 +40,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n \n #[cfg(target_os = \"espidf\")]"}, {"sha": "7657605b52f0d99d70db8599d5cb5d5b32d86be2", "filename": "library/std/src/sys/unix/thread_parker/netbsd.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,113 +0,0 @@\n-use crate::ffi::{c_int, c_void};\n-use crate::pin::Pin;\n-use crate::ptr::{null, null_mut};\n-use crate::sync::atomic::{\n-    AtomicU64,\n-    Ordering::{Acquire, Relaxed, Release},\n-};\n-use crate::time::Duration;\n-use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n-\n-extern \"C\" {\n-    fn ___lwp_park60(\n-        clock_id: clockid_t,\n-        flags: c_int,\n-        ts: *mut timespec,\n-        unpark: lwpid_t,\n-        hint: *const c_void,\n-        unparkhint: *const c_void,\n-    ) -> c_int;\n-    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n-}\n-\n-/// The thread is not parked and the token is not available.\n-///\n-/// Zero cannot be a valid LWP id, since it is used as empty value for the unpark\n-/// argument in _lwp_park.\n-const EMPTY: u64 = 0;\n-/// The token is available. Do not park anymore.\n-const NOTIFIED: u64 = u64::MAX;\n-\n-pub struct Parker {\n-    /// The parker state. Contains either one of the two state values above or the LWP\n-    /// id of the parked thread.\n-    state: AtomicU64,\n-}\n-\n-impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicU64::new(EMPTY) })\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        // If the token has already been made available, we can skip\n-        // a bit of work, so check for it here.\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Loop to guard against spurious wakeups.\n-                loop {\n-                    ___lwp_park60(0, 0, null_mut(), 0, hint, null());\n-                    if self.state.load(Acquire) == NOTIFIED {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // At this point, the change to NOTIFIED has always been observed with acquire\n-        // ordering, so we can just use a relaxed store here (instead of a swap).\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        if self.state.load(Acquire) != NOTIFIED {\n-            let parked = _lwp_self() as u64;\n-            let hint = self.state.as_mut_ptr().cast();\n-            let mut timeout = timespec {\n-                // Saturate so that the operation will definitely time out\n-                // (even if it is after the heat death of the universe).\n-                tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n-                tv_nsec: dur.subsec_nanos().into(),\n-            };\n-\n-            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n-                // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n-                // above.\n-                ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, hint, null());\n-                // Use a swap to get acquire ordering even if the token was set after\n-                // the timeout occurred.\n-                self.state.swap(EMPTY, Acquire);\n-                return;\n-            }\n-        }\n-\n-        self.state.store(EMPTY, Relaxed);\n-    }\n-\n-    // Does not actually need `Pin`, but the pthread implementation does.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-        if !matches!(state, EMPTY | NOTIFIED) {\n-            let lwp = state as lwpid_t;\n-            let hint = self.state.as_mut_ptr().cast();\n-\n-            // If the parking thread terminated and did not actually park, this will\n-            // probably return an error, which is OK. In the worst case, another\n-            // thread has received the same LWP id. It will then receive a spurious\n-            // wakeup, but those are allowable per the API contract. The same reasoning\n-            // applies if a timeout occurred before this call, but the state was not\n-            // yet reset.\n-\n-            // SAFETY:\n-            // The syscall has no invariants to hold. Only unsafe because it is an\n-            // extern function.\n-            unsafe {\n-                _lwp_unpark(lwp, hint);\n-            }\n-        }\n-    }\n-}"}, {"sha": "b709fada3b4a805f1421f7c408f9ac266caf9115", "filename": "library/std/src/sys/unix/thread_parking/darwin.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fdarwin.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -46,7 +46,7 @@ unsafe impl Sync for Parker {}\n unsafe impl Send for Parker {}\n \n impl Parker {\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         let semaphore = dispatch_semaphore_create(0);\n         assert!(\n             !semaphore.is_null(),", "previous_filename": "library/std/src/sys/unix/thread_parker/darwin.rs"}, {"sha": "185333c072f49246d1315347e1040da660f1ad59", "filename": "library/std/src/sys/unix/thread_parking/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -24,7 +24,7 @@ cfg_if::cfg_if! {\n         pub use darwin::Parker;\n     } else if #[cfg(target_os = \"netbsd\")] {\n         mod netbsd;\n-        pub use netbsd::Parker;\n+        pub use netbsd::{current, park, park_timeout, unpark, ThreadId};\n     } else {\n         mod pthread;\n         pub use pthread::Parker;", "previous_filename": "library/std/src/sys/unix/thread_parker/mod.rs"}, {"sha": "3be08122138ab249790f19cf3c21566ee254fcf8", "filename": "library/std/src/sys/unix/thread_parking/netbsd.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fnetbsd.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -0,0 +1,52 @@\n+use crate::ffi::{c_int, c_void};\n+use crate::ptr;\n+use crate::time::Duration;\n+use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n+\n+extern \"C\" {\n+    fn ___lwp_park60(\n+        clock_id: clockid_t,\n+        flags: c_int,\n+        ts: *mut timespec,\n+        unpark: lwpid_t,\n+        hint: *const c_void,\n+        unparkhint: *const c_void,\n+    ) -> c_int;\n+    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n+}\n+\n+pub type ThreadId = lwpid_t;\n+\n+#[inline]\n+pub fn current() -> ThreadId {\n+    unsafe { _lwp_self() }\n+}\n+\n+#[inline]\n+pub fn park(hint: usize) {\n+    unsafe {\n+        ___lwp_park60(0, 0, ptr::null_mut(), 0, ptr::invalid(hint), ptr::null());\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, hint: usize) {\n+    let mut timeout = timespec {\n+        // Saturate so that the operation will definitely time out\n+        // (even if it is after the heat death of the universe).\n+        tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n+        tv_nsec: dur.subsec_nanos().into(),\n+    };\n+\n+    // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n+    // above.\n+    unsafe {\n+        ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, ptr::invalid(hint), ptr::null());\n+    }\n+}\n+\n+#[inline]\n+pub fn unpark(tid: ThreadId, hint: usize) {\n+    unsafe {\n+        _lwp_unpark(tid, ptr::invalid(hint));\n+    }\n+}"}, {"sha": "082d25e68f587ad9a424b076b348a2814b011894", "filename": "library/std/src/sys/unix/thread_parking/pthread.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parking%2Fpthread.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -99,7 +99,7 @@ impl Parker {\n     ///\n     /// # Safety\n     /// The constructed parker must never be moved.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         // Use the default mutex implementation to allow for simpler initialization.\n         // This could lead to undefined behaviour when deadlocking. This is avoided\n         // by not deadlocking. Note in particular the unlocking operation before any", "previous_filename": "library/std/src/sys/unix/thread_parker/pthread.rs"}, {"sha": "77359abe429950869a9c82bbb5477e1a2f3cd6af", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -33,7 +33,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod time;\n cfg_if::cfg_if! {\n     if #[cfg(not(target_vendor = \"uwp\"))] {"}, {"sha": "5d43676adbb11f0428d99c796fe58eaa3b3b2c45", "filename": "library/std/src/sys/windows/thread_parking.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parking.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -97,7 +97,7 @@ const NOTIFIED: i8 = 1;\n impl Parker {\n     /// Construct the Windows parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Self { state: AtomicI8::new(EMPTY) });\n     }\n ", "previous_filename": "library/std/src/sys/windows/thread_parker.rs"}, {"sha": "6b24b0e9aa8be85129f6a62bfb074db63d39e7ec", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -30,7 +30,7 @@ pub mod process;\n pub mod thread;\n pub mod thread_info;\n pub mod thread_local_dtor;\n-pub mod thread_parker;\n+pub mod thread_parking;\n pub mod wstr;\n pub mod wtf8;\n "}, {"sha": "588e7b27826f6633ed6ba4c6b8f8f95192c52aac", "filename": "library/std/src/sys_common/thread_parking/futex.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Ffutex.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -35,7 +35,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct the futex parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Self { state: AtomicU32::new(EMPTY) });\n     }\n ", "previous_filename": "library/std/src/sys_common/thread_parker/futex.rs"}, {"sha": "3209bffe353ed81b775a8b7869789824d1a052b1", "filename": "library/std/src/sys_common/thread_parking/generic.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fgeneric.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -19,7 +19,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct the generic parker. The UNIX parker implementation\n     /// requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Parker {\n             state: AtomicUsize::new(EMPTY),\n             lock: Mutex::new(()),", "previous_filename": "library/std/src/sys_common/thread_parker/generic.rs"}, {"sha": "e98169597c378011d3e044251d69e813fbd119f6", "filename": "library/std/src/sys_common/thread_parking/id.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fid.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -0,0 +1,108 @@\n+//! Thread parking using thread ids.\n+//!\n+//! Some platforms (notably NetBSD) have thread parking primitives whose semantics\n+//! match those offered by `thread::park`, with the difference that the thread to\n+//! be unparked is referenced by a platform-specific thread id. Since the thread\n+//! parker is constructed before that id is known, an atomic state variable is used\n+//! to manage the park state and propagate the thread id. This also avoids platform\n+//! calls in the case where `unpark` is called before `park`.\n+\n+use crate::cell::UnsafeCell;\n+use crate::pin::Pin;\n+use crate::sync::atomic::{\n+    fence, AtomicI8,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::thread_parking::{current, park, park_timeout, unpark, ThreadId};\n+use crate::time::Duration;\n+\n+pub struct Parker {\n+    state: AtomicI8,\n+    tid: UnsafeCell<Option<ThreadId>>,\n+}\n+\n+const PARKED: i8 = -1;\n+const EMPTY: i8 = 0;\n+const NOTIFIED: i8 = 1;\n+\n+impl Parker {\n+    pub fn new() -> Parker {\n+        Parker { state: AtomicI8::new(EMPTY), tid: UnsafeCell::new(None) }\n+    }\n+\n+    /// Create a new thread parker. UNIX requires this to happen in-place.\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n+        parker.write(Parker::new())\n+    }\n+\n+    /// # Safety\n+    /// * must always be called from the same thread\n+    /// * must be called before the state is set to PARKED\n+    unsafe fn init_tid(&self) {\n+        // The field is only ever written to from this thread, so we don't need\n+        // synchronization to read it here.\n+        if self.tid.get().read().is_none() {\n+            // Because this point is only reached once, before the state is set\n+            // to PARKED for the first time, the non-atomic write here can not\n+            // conflict with reads by other threads.\n+            self.tid.get().write(Some(current()));\n+            // Ensure that the write can be observed by all threads reading the\n+            // state. Synchronizes with the acquire barrier in `unpark`.\n+            fence(Release);\n+        }\n+    }\n+\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        self.init_tid();\n+\n+        // Changes NOTIFIED to EMPTY and EMPTY to PARKED.\n+        let mut state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            // Loop to guard against spurious wakeups.\n+            while state == PARKED {\n+                park(self.state.as_mut_ptr().addr());\n+                state = self.state.load(Acquire);\n+            }\n+\n+            // Since the state change has already been observed with acquire\n+            // ordering, the state can be reset with a relaxed store instead\n+            // of a swap.\n+            self.state.store(EMPTY, Relaxed);\n+        }\n+    }\n+\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        self.init_tid();\n+\n+        let state = self.state.fetch_sub(1, Acquire).wrapping_sub(1);\n+        if state == PARKED {\n+            park_timeout(dur, self.state.as_mut_ptr().addr());\n+            // Swap to ensure that we observe all state changes with acquire\n+            // ordering, even if the state has been changed after the timeout\n+            // occured.\n+            self.state.swap(EMPTY, Acquire);\n+        }\n+    }\n+\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if state == PARKED {\n+            // Synchronize with the release fence in `init_tid` to observe the\n+            // write to `tid`.\n+            fence(Acquire);\n+            // # Safety\n+            // The thread id is initialized before the state is set to `PARKED`\n+            // for the first time and is not written to from that point on\n+            // (negating the need for an atomic read).\n+            let tid = unsafe { self.tid.get().read().unwrap_unchecked() };\n+            // It is possible that the waiting thread woke up because of a timeout\n+            // and terminated before this call is made. This call then returns an\n+            // error or wakes up an unrelated thread. The platform API and\n+            // environment does allow this, however.\n+            unpark(tid, self.state.as_mut_ptr().addr());\n+        }\n+    }\n+}\n+\n+unsafe impl Send for Parker {}\n+unsafe impl Sync for Parker {}"}, {"sha": "0ead6633c3501bd5302a4f11c3865267cd6b5d8d", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -11,13 +11,17 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         pub use futex::Parker;\n+    } else if #[cfg(any(\n+        target_os = \"netbsd\",\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n+        mod id;\n+        pub use id::Parker;\n     } else if #[cfg(target_os = \"solid_asp3\")] {\n         mod wait_flag;\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n-    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n-        pub use crate::sys::thread_parker::Parker;\n+        pub use crate::sys::thread_parking::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;", "previous_filename": "library/std/src/sys_common/thread_parker/mod.rs"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -41,7 +41,7 @@ pub struct Parker {\n impl Parker {\n     /// Construct a parker for the current thread. The UNIX parker\n     /// implementation requires this to happen in-place.\n-    pub unsafe fn new(parker: *mut Parker) {\n+    pub unsafe fn new_in_place(parker: *mut Parker) {\n         parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n     }\n ", "previous_filename": "library/std/src/sys_common/thread_parker/wait_flag.rs"}, {"sha": "7acda8e98f18fcf75bf3b8f97334832b949bb0f6", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -173,7 +173,7 @@ use crate::sync::Arc;\n use crate::sys::thread as imp;\n use crate::sys_common::thread;\n use crate::sys_common::thread_info;\n-use crate::sys_common::thread_parker::Parker;\n+use crate::sys_common::thread_parking::Parker;\n use crate::sys_common::{AsInner, IntoInner};\n use crate::time::Duration;\n \n@@ -1216,7 +1216,7 @@ impl Thread {\n             let ptr = Arc::get_mut_unchecked(&mut arc).as_mut_ptr();\n             addr_of_mut!((*ptr).name).write(name);\n             addr_of_mut!((*ptr).id).write(ThreadId::new());\n-            Parker::new(addr_of_mut!((*ptr).parker));\n+            Parker::new_in_place(addr_of_mut!((*ptr).parker));\n             Pin::new_unchecked(arc.assume_init())\n         };\n "}, {"sha": "66bc0f023b6c9833c610b93d1386fbfde3412d01", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -97,18 +97,36 @@ impl RunConfig<'_> {\n         self.builder.build.build\n     }\n \n-    /// Return a `-p=x -p=y` string suitable for passing to a cargo invocation.\n+    /// Return a list of crate names selected by `run.paths`.\n     pub fn cargo_crates_in_set(&self) -> Interned<Vec<String>> {\n         let mut crates = Vec::new();\n         for krate in &self.paths {\n             let path = krate.assert_single_path();\n             let crate_name = self.builder.crate_paths[&path.path];\n-            crates.push(format!(\"-p={crate_name}\"));\n+            crates.push(crate_name.to_string());\n         }\n         INTERNER.intern_list(crates)\n     }\n }\n \n+/// A description of the crates in this set, suitable for passing to `builder.info`.\n+///\n+/// `crates` should be generated by [`RunConfig::cargo_crates_in_set`].\n+pub fn crate_description(crates: &[impl AsRef<str>]) -> String {\n+    if crates.is_empty() {\n+        return \"\".into();\n+    }\n+\n+    let mut descr = String::from(\" {\");\n+    descr.push_str(crates[0].as_ref());\n+    for krate in &crates[1..] {\n+        descr.push_str(\", \");\n+        descr.push_str(krate.as_ref());\n+    }\n+    descr.push('}');\n+    descr\n+}\n+\n struct StepDescription {\n     default: bool,\n     only_hosts: bool,"}, {"sha": "32e5d414061eccdfe402fcc7393bdbecfac493e3", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -99,19 +99,13 @@ impl Step for Std {\n             cargo_subcommand(builder.kind),\n         );\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n-            \"Checking stage{} std artifacts ({} -> {})\",\n+            \"Checking stage{} library artifacts ({} -> {})\",\n             builder.top_stage, &compiler.host, target\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder),\n-            &libstd_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n+        run_cargo(builder, cargo, &libstd_stamp(builder, compiler, target), vec![], true);\n \n         // We skip populating the sysroot in non-zero stage because that'll lead\n         // to rlib/rmeta conflicts if std gets built during this session.\n@@ -155,19 +149,13 @@ impl Step for Std {\n         for krate in builder.in_tree_crates(\"test\", Some(target)) {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n-            \"Checking stage{} std test/bench/example targets ({} -> {})\",\n+            \"Checking stage{} library test/bench/example targets ({} -> {})\",\n             builder.top_stage, &compiler.host, target\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder),\n-            &libstd_test_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n+        run_cargo(builder, cargo, &libstd_test_stamp(builder, compiler, target), vec![], true);\n     }\n }\n \n@@ -231,19 +219,13 @@ impl Step for Rustc {\n         for krate in builder.in_tree_crates(\"rustc-main\", Some(target)) {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n             \"Checking stage{} compiler artifacts ({} -> {})\",\n             builder.top_stage, &compiler.host, target\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder),\n-            &librustc_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n+        run_cargo(builder, cargo, &librustc_stamp(builder, compiler, target), vec![], true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n@@ -290,6 +272,7 @@ impl Step for CodegenBackend {\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n         rustc_cargo_env(builder, &mut cargo, target);\n+        cargo.args(args(builder));\n \n         builder.info(&format!(\n             \"Checking stage{} {} artifacts ({} -> {})\",\n@@ -299,7 +282,6 @@ impl Step for CodegenBackend {\n         run_cargo(\n             builder,\n             cargo,\n-            args(builder),\n             &codegen_backend_stamp(builder, compiler, target, backend),\n             vec![],\n             true,\n@@ -355,11 +337,13 @@ impl Step for RustAnalyzer {\n             cargo.arg(\"--benches\");\n         }\n \n+        cargo.args(args(builder));\n+\n         builder.info(&format!(\n             \"Checking stage{} {} artifacts ({} -> {})\",\n             compiler.stage, \"rust-analyzer\", &compiler.host.triple, target.triple\n         ));\n-        run_cargo(builder, cargo, args(builder), &stamp(builder, compiler, target), vec![], true);\n+        run_cargo(builder, cargo, &stamp(builder, compiler, target), vec![], true);\n \n         /// Cargo's output path in a given stage, compiled by a particular\n         /// compiler for the specified target.\n@@ -413,6 +397,8 @@ macro_rules! tool_check_step {\n                     cargo.arg(\"--all-targets\");\n                 }\n \n+                cargo.args(args(builder));\n+\n                 // Enable internal lints for clippy and rustdoc\n                 // NOTE: this doesn't enable lints for any other tools unless they explicitly add `#![warn(rustc::internal)]`\n                 // See https://github.com/rust-lang/rust/pull/80573#issuecomment-754010776\n@@ -428,7 +414,6 @@ macro_rules! tool_check_step {\n                 run_cargo(\n                     builder,\n                     cargo,\n-                    args(builder),\n                     &stamp(builder, compiler, target),\n                     vec![],\n                     true,"}, {"sha": "468efc1114c43f3ff8e6735b4e87313a8f5739bb", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -9,11 +9,10 @@ use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n-use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::builder::{crate_description, Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n-use crate::config::TargetSelection;\n use crate::util::t;\n-use crate::{Build, Mode, Subcommand};\n+use crate::{Build, Compiler, Mode, Subcommand};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct CleanAll {}\n@@ -40,7 +39,7 @@ macro_rules! clean_crate_tree {\n     ( $( $name:ident, $mode:path, $root_crate:literal);+ $(;)? ) => { $(\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n         pub struct $name {\n-            target: TargetSelection,\n+            compiler: Compiler,\n             crates: Interned<Vec<String>>,\n         }\n \n@@ -54,22 +53,21 @@ macro_rules! clean_crate_tree {\n \n             fn make_run(run: RunConfig<'_>) {\n                 let builder = run.builder;\n-                if builder.top_stage != 0 {\n-                    panic!(\"non-stage-0 clean not supported for individual crates\");\n-                }\n-                builder.ensure(Self { crates: run.cargo_crates_in_set(), target: run.target });\n+                let compiler = builder.compiler(builder.top_stage, run.target);\n+                builder.ensure(Self { crates: run.cargo_crates_in_set(), compiler });\n             }\n \n             fn run(self, builder: &Builder<'_>) -> Self::Output {\n-                let compiler = builder.compiler(0, self.target);\n-                let mut cargo = builder.bare_cargo(compiler, $mode, self.target, \"clean\");\n+                let compiler = self.compiler;\n+                let target = compiler.host;\n+                let mut cargo = builder.bare_cargo(compiler, $mode, target, \"clean\");\n                 for krate in &*self.crates {\n                     cargo.arg(krate);\n                 }\n \n                 builder.info(&format!(\n-                    \"Cleaning stage{} {} artifacts ({} -> {})\",\n-                    compiler.stage, stringify!($name).to_lowercase(), &compiler.host, self.target\n+                    \"Cleaning{} stage{} {} artifacts ({} -> {})\",\n+                    crate_description(&self.crates), compiler.stage, stringify!($name).to_lowercase(), &compiler.host, target,\n                 ));\n \n                 // NOTE: doesn't use `run_cargo` because we don't want to save a stamp file,"}, {"sha": "f9a04f2e91dbf3733510d9a88d02fb61b8365128", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -18,6 +18,7 @@ use std::str;\n \n use serde::Deserialize;\n \n+use crate::builder::crate_description;\n use crate::builder::Cargo;\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -110,7 +111,10 @@ impl Step for Std {\n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n             builder.ensure(Std::new(compiler_to_use, target));\n-            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n+            builder.info(&format!(\n+                \"Uplifting stage1 library ({} -> {})\",\n+                compiler_to_use.host, target\n+            ));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n@@ -126,19 +130,18 @@ impl Step for Std {\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"build\");\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n \n         builder.info(&format!(\n-            \"Building stage{} std artifacts ({} -> {})\",\n-            compiler.stage, &compiler.host, target\n+            \"Building{} stage{} library artifacts ({} -> {})\",\n+            crate_description(&self.crates),\n+            compiler.stage,\n+            &compiler.host,\n+            target,\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            self.crates.to_vec(),\n-            &libstd_stamp(builder, compiler, target),\n-            target_deps,\n-            false,\n-        );\n+        run_cargo(builder, cargo, &libstd_stamp(builder, compiler, target), target_deps, false);\n \n         builder.ensure(StdLink::from_std(\n             self,\n@@ -425,7 +428,7 @@ impl Step for StdLink {\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n         builder.info(&format!(\n-            \"Copying stage{} std from stage{} ({} -> {} / {})\",\n+            \"Copying stage{} library from stage{} ({} -> {} / {})\",\n             target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n         ));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n@@ -714,18 +717,18 @@ impl Step for Rustc {\n             }\n         }\n \n+        for krate in &*self.crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n         builder.info(&format!(\n-            \"Building stage{} compiler artifacts ({} -> {})\",\n-            compiler.stage, &compiler.host, target\n+            \"Building{} stage{} compiler artifacts ({} -> {})\",\n+            crate_description(&self.crates),\n+            compiler.stage,\n+            &compiler.host,\n+            target,\n         ));\n-        run_cargo(\n-            builder,\n-            cargo,\n-            self.crates.to_vec(),\n-            &librustc_stamp(builder, compiler, target),\n-            vec![],\n-            false,\n-        );\n+        run_cargo(builder, cargo, &librustc_stamp(builder, compiler, target), vec![], false);\n \n         builder.ensure(RustcLink::from_rustc(\n             self,\n@@ -981,7 +984,7 @@ impl Step for CodegenBackend {\n             \"Building stage{} codegen backend {} ({} -> {})\",\n             compiler.stage, backend, &compiler.host, target\n         ));\n-        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false);\n+        let files = run_cargo(builder, cargo, &tmp_stamp, vec![], false);\n         if builder.config.dry_run() {\n             return;\n         }\n@@ -1405,7 +1408,6 @@ pub fn add_to_sysroot(\n pub fn run_cargo(\n     builder: &Builder<'_>,\n     cargo: Cargo,\n-    tail_args: Vec<String>,\n     stamp: &Path,\n     additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n@@ -1431,7 +1433,7 @@ pub fn run_cargo(\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let ok = stream_cargo(builder, cargo, tail_args, &mut |msg| {\n+    let ok = stream_cargo(builder, cargo, &mut |msg| {\n         let (filenames, crate_types) = match msg {\n             CargoMessage::CompilerArtifact {\n                 filenames,\n@@ -1546,7 +1548,6 @@ pub fn run_cargo(\n pub fn stream_cargo(\n     builder: &Builder<'_>,\n     cargo: Cargo,\n-    tail_args: Vec<String>,\n     cb: &mut dyn FnMut(CargoMessage<'_>),\n ) -> bool {\n     let mut cargo = Command::from(cargo);\n@@ -1566,10 +1567,6 @@ pub fn stream_cargo(\n     }\n     cargo.arg(\"--message-format\").arg(message_format).stdout(Stdio::piped());\n \n-    for arg in tail_args {\n-        cargo.arg(arg);\n-    }\n-\n     builder.verbose(&format!(\"running: {:?}\", cargo));\n     let mut child = match cargo.spawn() {\n         Ok(child) => child,"}, {"sha": "9bad9046ecc2c4fed4a122d5d2a60ccf2adda4c1", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -12,6 +12,7 @@ use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n \n+use crate::builder::crate_description;\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n use crate::compile;\n@@ -558,7 +559,8 @@ fn doc_std(\n     requested_crates: &[String],\n ) {\n     builder.info(&format!(\n-        \"Documenting stage{} std ({}) in {} format\",\n+        \"Documenting{} stage{} library ({}) in {} format\",\n+        crate_description(requested_crates),\n         stage,\n         target,\n         format.as_str()"}, {"sha": "2c6d201d18fbeacc697c03f990d8770d04bfa8ff", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -352,32 +352,32 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // fn usage()\n         let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n-            // We have an unfortunate situation here: some Steps use `builder.in_tree_crates` to determine their paths.\n-            // To determine those crates, we need to run `cargo metadata`, which means we need all submodules to be checked out.\n-            // That takes a while to run, so only do it when paths were explicitly requested, not on all CLI errors.\n-            // `Build::new` won't load submodules for the `setup` command.\n-            let cmd = if verbose {\n-                println!(\"note: updating submodules before printing available paths\");\n-                \"build\"\n-            } else {\n-                \"setup\"\n-            };\n-            let config = Config::parse(&[cmd.to_string()]);\n-            let build = Build::new(config);\n-            let paths = Builder::get_help(&build, subcommand);\n-\n             println!(\"{}\", opts.usage(subcommand_help));\n-            if let Some(s) = paths {\n-                if verbose {\n+            if verbose {\n+                // We have an unfortunate situation here: some Steps use `builder.in_tree_crates` to determine their paths.\n+                // To determine those crates, we need to run `cargo metadata`, which means we need all submodules to be checked out.\n+                // That takes a while to run, so only do it when paths were explicitly requested, not on all CLI errors.\n+                // `Build::new` won't load submodules for the `setup` command.\n+                let cmd = if verbose {\n+                    println!(\"note: updating submodules before printing available paths\");\n+                    \"build\"\n+                } else {\n+                    \"setup\"\n+                };\n+                let config = Config::parse(&[cmd.to_string()]);\n+                let build = Build::new(config);\n+                let paths = Builder::get_help(&build, subcommand);\n+\n+                if let Some(s) = paths {\n                     println!(\"{}\", s);\n                 } else {\n-                    println!(\n-                        \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                        subcommand.as_str()\n-                    );\n+                    panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n                 }\n-            } else if verbose {\n-                panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n+            } else {\n+                println!(\n+                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                    subcommand.as_str()\n+                );\n             }\n             crate::detail_exit(exit_code);\n         };"}, {"sha": "84e4611895965ce22dfa63b7d75516813c113821", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -79,24 +79,19 @@ fn update_rustfmt_version(build: &Builder<'_>) {\n ///\n /// Returns `None` if all files should be formatted.\n fn get_modified_rs_files(build: &Builder<'_>) -> Option<Vec<String>> {\n-    let Ok(remote) = get_rust_lang_rust_remote() else {return None;};\n+    let Ok(remote) = get_rust_lang_rust_remote() else { return None; };\n     if !verify_rustfmt_version(build) {\n         return None;\n     }\n+\n+    let merge_base =\n+        output(build.config.git().arg(\"merge-base\").arg(&format!(\"{remote}/master\")).arg(\"HEAD\"));\n     Some(\n-        output(\n-            build\n-                .config\n-                .git()\n-                .arg(\"diff-index\")\n-                .arg(\"--name-only\")\n-                .arg(\"--merge-base\")\n-                .arg(&format!(\"{remote}/master\")),\n-        )\n-        .lines()\n-        .map(|s| s.trim().to_owned())\n-        .filter(|f| Path::new(f).extension().map_or(false, |ext| ext == \"rs\"))\n-        .collect(),\n+        output(build.config.git().arg(\"diff-index\").arg(\"--name-only\").arg(merge_base.trim()))\n+            .lines()\n+            .map(|s| s.trim().to_owned())\n+            .filter(|f| Path::new(f).extension().map_or(false, |ext| ext == \"rs\"))\n+            .collect(),\n     )\n }\n "}, {"sha": "d5bec268a45672365183fb1b4fb7df694f23d5ca", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -11,6 +11,7 @@ use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n \n+use crate::builder::crate_description;\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n use crate::compile;\n@@ -2154,8 +2155,12 @@ impl Step for Crate {\n         }\n \n         builder.info(&format!(\n-            \"{} {:?} stage{} ({} -> {})\",\n-            test_kind, self.crates, compiler.stage, &compiler.host, target\n+            \"{}{} stage{} ({} -> {})\",\n+            test_kind,\n+            crate_description(&self.crates),\n+            compiler.stage,\n+            &compiler.host,\n+            target\n         ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cargo.into());"}, {"sha": "63026bd44d475277d388b9a3b8d37d237a0e8842", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -72,7 +72,7 @@ impl Step for ToolBuild {\n \n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n-        let is_expected = compile::stream_cargo(builder, cargo, vec![], &mut |msg| {\n+        let is_expected = compile::stream_cargo(builder, cargo, &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             match tool {\n                 \"rls\" | \"cargo\" | \"clippy-driver\" | \"miri\" | \"rustfmt\" => {}"}, {"sha": "b9c33914360ba08c6b9144c556fdde42ccf70de5", "filename": "src/test/codegen/sanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -131,6 +131,13 @@ pub struct Type13<'a> {\n     member3: &'a Type13<'a>,\n }\n \n+// Helper type to allow `Type14<Bar>` to be a unique ID\n+pub struct Bar;\n+\n+// repr(transparent) parameterized type\n+#[repr(transparent)]\n+pub struct Type14<T>(T);\n+\n pub fn foo0(_: ()) { }\n // CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]]\n pub fn foo1(_: c_void, _: ()) { }\n@@ -425,6 +432,12 @@ pub fn foo145(_: Type13, _: Type13) { }\n // CHECK: define{{.*}}foo145{{.*}}!type ![[TYPE145:[0-9]+]]\n pub fn foo146(_: Type13, _: Type13, _: Type13) { }\n // CHECK: define{{.*}}foo146{{.*}}!type ![[TYPE146:[0-9]+]]\n+pub fn foo147(_: Type14<Bar>) { }\n+// CHECK: define{{.*}}foo147{{.*}}!type ![[TYPE147:[0-9]+]]\n+pub fn foo148(_: Type14<Bar>, _: Type14<Bar>) { }\n+// CHECK: define{{.*}}foo148{{.*}}!type ![[TYPE148:[0-9]+]]\n+pub fn foo149(_: Type14<Bar>, _: Type14<Bar>, _: Type14<Bar>) { }\n+// CHECK: define{{.*}}foo149{{.*}}!type ![[TYPE149:[0-9]+]]\n \n // CHECK: ![[TYPE0]] = !{i64 0, !\"_ZTSFvvE\"}\n // CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvvvE\"}\n@@ -570,6 +583,9 @@ pub fn foo146(_: Type13, _: Type13, _: Type13) { }\n // CHECK: ![[TYPE141]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3FooE\"}\n // CHECK: ![[TYPE142]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3FooS_E\"}\n // CHECK: ![[TYPE143]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3FooS_S_E\"}\n-// CHECK: ![[TYPE144]] = !{i64 0, !\"_ZTSFvu3refIu3refIvEEE\"}\n-// CHECK: ![[TYPE145]] = !{i64 0, !\"_ZTSFvu3refIu3refIvEES0_E\"}\n-// CHECK: ![[TYPE146]] = !{i64 0, !\"_ZTSFvu3refIu3refIvEES0_S0_E\"}\n+// CHECK: ![[TYPE144]] = !{i64 0, !\"_ZTSFvu3refIvEE\"}\n+// CHECK: ![[TYPE145]] = !{i64 0, !\"_ZTSFvu3refIvES_E\"}\n+// CHECK: ![[TYPE146]] = !{i64 0, !\"_ZTSFvu3refIvES_S_E\"}\n+// CHECK: ![[TYPE147]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3BarE\n+// CHECK: ![[TYPE148]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3BarS_E\n+// CHECK: ![[TYPE149]] = !{i64 0, !\"_ZTSFvu{{[0-9]+}}NtC{{[[:print:]]+}}_51sanitizer_cfi_emit_type_metadata_id_itanium_cxx_abi3BarS_S_E"}, {"sha": "95102528ec11d7343f8c18c61c0bb4ade224fe0d", "filename": "src/test/rustdoc-gui/scrape-examples-layout.goml", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-layout.goml", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-layout.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-layout.goml?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -33,3 +33,17 @@ assert-property: (\n     \".more-scraped-examples .scraped-example:nth-child(6) .code-wrapper .src-line-numbers\",\n     {\"clientWidth\": |clientWidth|}\n )\n+\n+// Check that for both mobile and desktop sizes, the buttons in scraped examples are displayed\n+// correctly.\n+\n+store-value: (offset_y, 4)\n+\n+// First with desktop\n+assert-position: (\".scraped-example .code-wrapper\", {\"y\": 255})\n+assert-position: (\".scraped-example .code-wrapper .prev\", {\"y\": 255 + |offset_y|})\n+\n+// Then with mobile\n+size: (600, 600)\n+assert-position: (\".scraped-example .code-wrapper\", {\"y\": 314})\n+assert-position: (\".scraped-example .code-wrapper .prev\", {\"y\": 314 + |offset_y|})"}, {"sha": "0467dea621b4c2a063b4de2f83ba99ac4905bfb8", "filename": "src/test/ui/feature-gates/feature-gate-multiple_supertrait_upcastable.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,12 +0,0 @@\n-// check-pass\n-\n-#![deny(multiple_supertrait_upcastable)]\n-//~^ WARNING unknown lint: `multiple_supertrait_upcastable`\n-//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n-//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n-#![warn(multiple_supertrait_upcastable)]\n-//~^ WARNING unknown lint: `multiple_supertrait_upcastable`\n-//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n-//~| WARNING unknown lint: `multiple_supertrait_upcastable`\n-\n-fn main() {}"}, {"sha": "1f725f35417785e05aad434e5797fa07f181ec32", "filename": "src/test/ui/feature-gates/feature-gate-multiple_supertrait_upcastable.stderr", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-multiple_supertrait_upcastable.stderr?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,57 +0,0 @@\n-warning: unknown lint: `multiple_supertrait_upcastable`\n-  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:3:1\n-   |\n-LL | #![deny(multiple_supertrait_upcastable)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `multiple_supertrait_upcastable` lint is unstable\n-   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n-   = note: `#[warn(unknown_lints)]` on by default\n-\n-warning: unknown lint: `multiple_supertrait_upcastable`\n-  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:7:1\n-   |\n-LL | #![warn(multiple_supertrait_upcastable)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `multiple_supertrait_upcastable` lint is unstable\n-   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n-\n-warning: unknown lint: `multiple_supertrait_upcastable`\n-  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:3:1\n-   |\n-LL | #![deny(multiple_supertrait_upcastable)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `multiple_supertrait_upcastable` lint is unstable\n-   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n-\n-warning: unknown lint: `multiple_supertrait_upcastable`\n-  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:7:1\n-   |\n-LL | #![warn(multiple_supertrait_upcastable)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `multiple_supertrait_upcastable` lint is unstable\n-   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n-\n-warning: unknown lint: `multiple_supertrait_upcastable`\n-  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:3:1\n-   |\n-LL | #![deny(multiple_supertrait_upcastable)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `multiple_supertrait_upcastable` lint is unstable\n-   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n-\n-warning: unknown lint: `multiple_supertrait_upcastable`\n-  --> $DIR/feature-gate-multiple_supertrait_upcastable.rs:7:1\n-   |\n-LL | #![warn(multiple_supertrait_upcastable)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `multiple_supertrait_upcastable` lint is unstable\n-   = help: add `#![feature(multiple_supertrait_upcastable)]` to the crate attributes to enable\n-\n-warning: 6 warnings emitted\n-"}, {"sha": "64bf59e5d3aa51273644444971b0c760cea5954f", "filename": "src/test/ui/object-safety/issue-106247.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftest%2Fui%2Fobject-safety%2Fissue-106247.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftest%2Fui%2Fobject-safety%2Fissue-106247.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fissue-106247.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#![deny(where_clauses_object_safety)]\n+\n+pub trait Trait {\n+    fn method(&self) where Self: Sync;\n+}\n+\n+fn main() {}"}, {"sha": "3c6ab86e4c65ce205360978cd76a534124bad1e0", "filename": "src/test/ui/traits/trait-upcasting/multiple_supertrait_upcastable.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.rs?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,10 +0,0 @@\n-#![feature(multiple_supertrait_upcastable)]\n-#![deny(multiple_supertrait_upcastable)]\n-\n-trait A {}\n-trait B {}\n-\n-trait C: A + B {}\n-//~^ ERROR `C` is object-safe and has multiple supertraits\n-\n-fn main() {}"}, {"sha": "ad80a009ece80674a72773efc993d868bdecea2a", "filename": "src/test/ui/traits/trait-upcasting/multiple_supertrait_upcastable.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5570cda1870a399532c34b36c89fe0b03d59c72c/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple_supertrait_upcastable.stderr?ref=5570cda1870a399532c34b36c89fe0b03d59c72c", "patch": "@@ -1,14 +0,0 @@\n-error: `C` is object-safe and has multiple supertraits\n-  --> $DIR/multiple_supertrait_upcastable.rs:7:1\n-   |\n-LL | trait C: A + B {}\n-   | ^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/multiple_supertrait_upcastable.rs:2:9\n-   |\n-LL | #![deny(multiple_supertrait_upcastable)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "fff83a1d097b3f6364c180781b8bfdb6ec886dc6", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -11,6 +11,7 @@ miropt-test-tools = { path = \"../miropt-test-tools\" }\n lazy_static = \"1\"\n walkdir = \"2\"\n ignore = \"0.4.18\"\n+termcolor = \"1.1.3\"\n \n [[bin]]\n name = \"rust-tidy\""}, {"sha": "40a46c630d70a2de59e468ae5ac75eab44ed717a", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -80,15 +80,6 @@ fn check_if_error_code_is_test_in_explanation(f: &str, err_code: &str) -> bool {\n     ignore_found\n }\n \n-macro_rules! some_or_continue {\n-    ($e:expr) => {\n-        match $e {\n-            Some(e) => e,\n-            None => continue,\n-        }\n-    };\n-}\n-\n fn extract_error_codes(\n     f: &str,\n     error_codes: &mut HashMap<String, ErrorCodeStatus>,\n@@ -122,10 +113,16 @@ fn extract_error_codes(\n                     Some((file_name, _)) => file_name,\n                 },\n             };\n-            let path = some_or_continue!(path.parent())\n+\n+            let Some(parent) = path.parent() else {\n+                continue;\n+            };\n+\n+            let path = parent\n                 .join(md_file_name)\n                 .canonicalize()\n                 .expect(\"failed to canonicalize error explanation file path\");\n+\n             match read_to_string(&path) {\n                 Ok(content) => {\n                     let has_test = check_if_error_code_is_test_in_explanation(&content, &err_code);\n@@ -215,8 +212,6 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     // * #[error = \"E0111\"]\n     let regex = Regex::new(r#\"[(,\"\\s](E\\d{4})[,)\"]\"#).unwrap();\n \n-    println!(\"Checking which error codes lack tests...\");\n-\n     for path in paths {\n         walk(path, &mut filter_dirs, &mut |entry, contents| {\n             let file_name = entry.file_name();\n@@ -245,20 +240,15 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n         });\n     }\n     if found_explanations == 0 {\n-        eprintln!(\"No error code explanation was tested!\");\n-        *bad = true;\n+        tidy_error!(bad, \"No error code explanation was tested!\");\n     }\n     if found_tests == 0 {\n-        eprintln!(\"No error code was found in compilation errors!\");\n-        *bad = true;\n+        tidy_error!(bad, \"No error code was found in compilation errors!\");\n     }\n     if explanations.is_empty() {\n-        eprintln!(\"No error code explanation was found!\");\n-        *bad = true;\n+        tidy_error!(bad, \"No error code explanation was found!\");\n     }\n     if errors.is_empty() {\n-        println!(\"Found {} error codes\", error_codes.len());\n-\n         for (err_code, error_status) in &error_codes {\n             if !error_status.has_test && !EXEMPTED_FROM_TEST.contains(&err_code.as_str()) {\n                 errors.push(format!(\"Error code {err_code} needs to have at least one UI test!\"));\n@@ -310,11 +300,6 @@ pub fn check(paths: &[&Path], bad: &mut bool) {\n     }\n     errors.sort();\n     for err in &errors {\n-        eprintln!(\"{err}\");\n-    }\n-    println!(\"Found {} error(s) in error codes\", errors.len());\n-    if !errors.is_empty() {\n-        *bad = true;\n+        tidy_error!(bad, \"{err}\");\n     }\n-    println!(\"Done!\");\n }"}, {"sha": "ce7e7ac5cd4caad70a7754c6b02054352ee3eb06", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -3,6 +3,10 @@\n //! This library contains the tidy lints and exposes it\n //! to be used by tools.\n \n+use std::fmt::Display;\n+\n+use termcolor::WriteColor;\n+\n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n /// * The expression that failed\n@@ -26,18 +30,27 @@ macro_rules! t {\n }\n \n macro_rules! tidy_error {\n-    ($bad:expr, $fmt:expr) => ({\n-        *$bad = true;\n-        eprint!(\"tidy error: \");\n-        eprintln!($fmt);\n-    });\n-    ($bad:expr, $fmt:expr, $($arg:tt)*) => ({\n-        *$bad = true;\n-        eprint!(\"tidy error: \");\n-        eprintln!($fmt, $($arg)*);\n+    ($bad:expr, $($fmt:tt)*) => ({\n+        $crate::tidy_error($bad, format_args!($($fmt)*)).expect(\"failed to output error\");\n     });\n }\n \n+fn tidy_error(bad: &mut bool, args: impl Display) -> std::io::Result<()> {\n+    use std::io::Write;\n+    use termcolor::{Color, ColorChoice, ColorSpec, StandardStream};\n+\n+    *bad = true;\n+\n+    let mut stderr = StandardStream::stdout(ColorChoice::Auto);\n+    stderr.set_color(ColorSpec::new().set_fg(Some(Color::Red)))?;\n+\n+    write!(&mut stderr, \"tidy error\")?;\n+    stderr.set_color(&ColorSpec::new())?;\n+\n+    writeln!(&mut stderr, \": {args}\")?;\n+    Ok(())\n+}\n+\n pub mod alphabetical;\n pub mod bins;\n pub mod debug_artifacts;"}]}