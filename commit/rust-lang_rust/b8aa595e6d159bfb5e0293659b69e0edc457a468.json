{"sha": "b8aa595e6d159bfb5e0293659b69e0edc457a468", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YWE1OTVlNmQxNTliZmI1ZTAyOTM2NTliNjllMGVkYzQ1N2E0Njg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-10T21:05:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-10T21:05:58Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "01c3c1ef7415103c4d48a28cf57be47cba5cc624", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01c3c1ef7415103c4d48a28cf57be47cba5cc624"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8aa595e6d159bfb5e0293659b69e0edc457a468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8aa595e6d159bfb5e0293659b69e0edc457a468", "html_url": "https://github.com/rust-lang/rust/commit/b8aa595e6d159bfb5e0293659b69e0edc457a468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8aa595e6d159bfb5e0293659b69e0edc457a468/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be95ca4b17203a3aed27c17c1e93b76c9477e5bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/be95ca4b17203a3aed27c17c1e93b76c9477e5bc", "html_url": "https://github.com/rust-lang/rust/commit/be95ca4b17203a3aed27c17c1e93b76c9477e5bc"}, {"sha": "b6179602bea71607a9ea63197eca423fcce5f7b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6179602bea71607a9ea63197eca423fcce5f7b0", "html_url": "https://github.com/rust-lang/rust/commit/b6179602bea71607a9ea63197eca423fcce5f7b0"}], "stats": {"total": 4071, "additions": 2631, "deletions": 1440}, "files": [{"sha": "7bf0bcab64066b886d1d5677f4ce0f46fcc9173a", "filename": "RELEASES.md", "status": "modified", "additions": 185, "deletions": 1, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,3 +1,187 @@\n+Version 1.20.0 (2017-08-31)\n+===========================\n+\n+Language\n+--------\n+- [Associated constants in traits is now stabilised.][42809]\n+- [A lot of macro bugs are now fixed.][42913]\n+\n+Compiler\n+--------\n+\n+- [Struct fields are now properly coerced to the expected field type.][42807]\n+- [Enabled wasm LLVM backend][42571] WASM can now be built with the\n+  `wasm32-experimental-emscripten` target.\n+- [Changed some of the error messages to be more helpful.][42033]\n+- [Add support for RELRO(RELocation Read-Only) for platforms that support\n+  it.][43170]\n+- [rustc now reports the total number of errors on compilation failure][43015]\n+  previously this was only the number of errors in the pass that failed.\n+- [Expansion in rustc has been sped up 29x.][42533]\n+- [added `msp430-none-elf` target.][43099]\n+- [rustc will now suggest one-argument enum variant to fix type mismatch when\n+  applicable][43178]\n+- [Fixes backtraces on Redox][43228]\n+- [rustc now identifies different versions of same crate when absolute paths of\n+  different types match in an error message.][42826]\n+\n+Libraries\n+---------\n+\n+\n+- [Relaxed Debug constraints on `{HashMap,BTreeMap}::{Keys,Values}`.][42854]\n+- [Impl `PartialEq`, `Eq`, `PartialOrd`, `Ord`, `Debug`, `Hash` for unsized\n+  tuples.][43011]\n+- [Impl `fmt::{Display, Debug}` for `Ref`, `RefMut`, `MutexGuard`,\n+  `RwLockReadGuard`, `RwLockWriteGuard`][42822]\n+- [Impl `Clone` for `DefaultHasher`.][42799]\n+- [Impl `Sync` for `SyncSender`.][42397]\n+- [Impl `FromStr` for `char`][42271]\n+- [Fixed how `{f32, f64}::{is_sign_negative, is_sign_positive}` handles\n+  NaN.][42431]\n+- [allow messages in the `unimplemented!()` macro.][42155]\n+  ie. `unimplemented!(\"Waiting for 1.21 to be stable\")`\n+- [`pub(restricted)` is now supported in the `thread_local!` macro.][43185]\n+- [Upgrade to Unicode 10.0.0][42999]\n+- [Reimplemented `{f32, f64}::{min, max}` in Rust instead of using CMath.][42430]\n+- [Skip the main thread's manual stack guard on Linux][43072]\n+- [Iterator::nth for `ops::{Range, RangeFrom}` is now done in O(1) time][43077]\n+- [`#[repr(align(N))]` attribute max number is now 2^31 - 1.][43097] This was\n+  previously 2^15.\n+- [`{OsStr, Path}::Display` now avoids allocations where possible][42613]\n+\n+Stabilized APIs\n+---------------\n+\n+- [`CStr::into_c_string`]\n+- [`CString::as_c_str`]\n+- [`CString::into_boxed_c_str`]\n+- [`Chain::get_mut`]\n+- [`Chain::get_ref`]\n+- [`Chain::into_inner`]\n+- [`Option::get_or_insert_with`]\n+- [`Option::get_or_insert`]\n+- [`OsStr::into_os_string`]\n+- [`OsString::into_boxed_os_str`]\n+- [`Take::get_mut`]\n+- [`Take::get_ref`]\n+- [`Utf8Error::error_len`]\n+- [`char::EscapeDebug`]\n+- [`char::escape_debug`]\n+- [`compile_error!`]\n+- [`f32::from_bits`]\n+- [`f32::to_bits`]\n+- [`f64::from_bits`]\n+- [`f64::to_bits`]\n+- [`mem::ManuallyDrop`]\n+- [`slice::sort_unstable_by_key`]\n+- [`slice::sort_unstable_by`]\n+- [`slice::sort_unstable`]\n+- [`ste::from_boxed_utf8_unchecked`]\n+- [`str::as_bytes_mut`]\n+- [`str::as_bytes_mut`]\n+- [`str::from_utf8_mut`]\n+- [`str::from_utf8_unchecked_mut`]\n+- [`str::get_mut`]\n+- [`str::get_unchecked_mut`]\n+- [`str::get_unchecked`]\n+- [`str::get`]\n+- [`str::into_boxed_bytes`]\n+\n+\n+Cargo\n+-----\n+- [Cargo API token location moved from `~/.cargo/config` to\n+  `~/cargo/credentials`.][cargo/3978]\n+- [Cargo will now build `main.rs` binaries that are in sub-directories of\n+  `src/bin`.][cargo/4214] ie. Having `src/bin/server/main.rs` and\n+  `src/bin/client/main.rs` generates `target/debug/server` and `target/debug/client`\n+- [You can now specify version of a binary when installed through\n+  `cargo install` using `--vers`.][cargo/4229]\n+- [Added `--no-fail-fast` flag to cargo to run all benchmarks regardless of\n+  failure.][cargo/4248]\n+- [Changed the convention around which file is the crate root.][cargo/4259]\n+- [The `include`/`exclude` property in `Cargo.toml` now accepts gitignore paths\n+  instead of glob patterns][cargo/4270]. Glob patterns are now deprecated.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Functions with `'static` in their return types will now not be as usable as\n+  if they were using lifetime parameters instead.][42417]\n+- [The reimplementation of `{f32, f64}::is_sign_{negative, positive}` now\n+  takes the sign of NaN into account where previously didn't.][42430] \n+\n+[42033]: https://github.com/rust-lang/rust/pull/42033\n+[42155]: https://github.com/rust-lang/rust/pull/42155\n+[42271]: https://github.com/rust-lang/rust/pull/42271\n+[42397]: https://github.com/rust-lang/rust/pull/42397\n+[42417]: https://github.com/rust-lang/rust/pull/42417\n+[42430]: https://github.com/rust-lang/rust/pull/42430\n+[42431]: https://github.com/rust-lang/rust/pull/42431\n+[42533]: https://github.com/rust-lang/rust/pull/42533\n+[42571]: https://github.com/rust-lang/rust/pull/42571\n+[42613]: https://github.com/rust-lang/rust/pull/42613\n+[42799]: https://github.com/rust-lang/rust/pull/42799\n+[42807]: https://github.com/rust-lang/rust/pull/42807\n+[42809]: https://github.com/rust-lang/rust/pull/42809\n+[42822]: https://github.com/rust-lang/rust/pull/42822\n+[42826]: https://github.com/rust-lang/rust/pull/42826\n+[42854]: https://github.com/rust-lang/rust/pull/42854\n+[42913]: https://github.com/rust-lang/rust/pull/42913\n+[42999]: https://github.com/rust-lang/rust/pull/42999\n+[43011]: https://github.com/rust-lang/rust/pull/43011\n+[43015]: https://github.com/rust-lang/rust/pull/43015\n+[43072]: https://github.com/rust-lang/rust/pull/43072\n+[43077]: https://github.com/rust-lang/rust/pull/43077\n+[43097]: https://github.com/rust-lang/rust/pull/43097\n+[43099]: https://github.com/rust-lang/rust/pull/43099\n+[43170]: https://github.com/rust-lang/rust/pull/43170\n+[43178]: https://github.com/rust-lang/rust/pull/43178\n+[43185]: https://github.com/rust-lang/rust/pull/43185\n+[43228]: https://github.com/rust-lang/rust/pull/43228\n+[cargo/3978]: https://github.com/rust-lang/cargo/pull/3978\n+[cargo/4214]: https://github.com/rust-lang/cargo/pull/4214\n+[cargo/4229]: https://github.com/rust-lang/cargo/pull/4229\n+[cargo/4248]: https://github.com/rust-lang/cargo/pull/4248\n+[cargo/4259]: https://github.com/rust-lang/cargo/pull/4259\n+[cargo/4270]: https://github.com/rust-lang/cargo/pull/4270\n+[`CStr::into_c_string`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html#method.into_c_string\n+[`CString::as_c_str`]: https://doc.rust-lang.org/std/ffi/struct.CString.html#method.as_c_str\n+[`CString::into_boxed_c_str`]: https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_boxed_c_str\n+[`Chain::get_mut`]: https://doc.rust-lang.org/std/io/struct.Chain.html#method.get_mut\n+[`Chain::get_ref`]: https://doc.rust-lang.org/std/io/struct.Chain.html#method.get_ref\n+[`Chain::into_inner`]: https://doc.rust-lang.org/std/io/struct.Chain.html#method.into_inner\n+[`Option::get_or_insert_with`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.get_or_insert_with\n+[`Option::get_or_insert`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.get_or_insert\n+[`OsStr::into_os_string`]: https://doc.rust-lang.org/std/ffi/struct.OsStr.html#method.into_os_string\n+[`OsString::into_boxed_os_str`]: https://doc.rust-lang.org/std/ffi/struct.OsString.html#method.into_boxed_os_str\n+[`Take::get_mut`]: https://doc.rust-lang.org/std/io/struct.Take.html#method.get_mut\n+[`Take::get_ref`]: https://doc.rust-lang.org/std/io/struct.Take.html#method.get_ref\n+[`Utf8Error::error_len`]: https://doc.rust-lang.org/std/str/struct.Utf8Error.html#method.error_len\n+[`char::EscapeDebug`]: https://doc.rust-lang.org/std/char/struct.EscapeDebug.html\n+[`char::escape_debug`]: https://doc.rust-lang.org/std/primitive.char.html#method.escape_debug\n+[`compile_error!`]: https://doc.rust-lang.org/std/macro.compile_error.html\n+[`f32::from_bits`]: https://doc.rust-lang.org/std/primitive.f32.html#method.from_bits\n+[`f32::to_bits`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_bits\n+[`f64::from_bits`]: https://doc.rust-lang.org/std/primitive.f64.html#method.from_bits\n+[`f64::to_bits`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_bits\n+[`mem::ManuallyDrop`]: https://doc.rust-lang.org/std/mem/union.ManuallyDrop.html\n+[`slice::sort_unstable_by_key`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable_by_key\n+[`slice::sort_unstable_by`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable_by\n+[`slice::sort_unstable`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable\n+[`ste::from_boxed_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_boxed_utf8_unchecked.html\n+[`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n+[`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n+[`str::from_utf8_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_mut.html\n+[`str::from_utf8_unchecked_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked_mut.html\n+[`str::get_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.get_mut\n+[`str::get_unchecked_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.get_unchecked_mut\n+[`str::get_unchecked`]: https://doc.rust-lang.org/std/primitive.str.html#method.get_unchecked\n+[`str::get`]: https://doc.rust-lang.org/std/primitive.str.html#method.get\n+[`str::into_boxed_bytes`]: https://doc.rust-lang.org/std/primitive.str.html#method.into_boxed_bytes\n+\n+\n Version 1.19.0 (2017-07-20)\n ===========================\n \n@@ -1679,7 +1863,7 @@ Tooling\n \n * [Test binaries now support a `--test-threads` argument to specify the number\n   of threads used to run tests, and which acts the same as the\n-  `RUST_TEST_THREADS` environment variable](https://github.com/rust-lang/rust/pull/35414)  \n+  `RUST_TEST_THREADS` environment variable](https://github.com/rust-lang/rust/pull/35414)\n * [The test runner now emits a warning when tests run over 60 seconds](https://github.com/rust-lang/rust/pull/35405)\n * [rustdoc: Fix methods in search results](https://github.com/rust-lang/rust/pull/34752)\n * [`rust-lldb` warns about unsupported versions of LLDB](https://github.com/rust-lang/rust/pull/34646)"}, {"sha": "38897993d435de0d02c6dcc50469de7ac2b31e3c", "filename": "src/Cargo.lock", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -75,7 +75,7 @@ version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -88,7 +88,7 @@ dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -99,7 +99,7 @@ version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -135,7 +135,7 @@ dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -200,7 +200,7 @@ dependencies = [\n  \"ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -234,7 +234,7 @@ dependencies = [\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -302,7 +302,7 @@ dependencies = [\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -341,7 +341,7 @@ version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"socket2 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -354,7 +354,7 @@ version = \"0.3.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -456,7 +456,7 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -472,7 +472,7 @@ name = \"flate2\"\n version = \"0.2.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -496,7 +496,7 @@ version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -521,7 +521,7 @@ version = \"0.6.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -662,7 +662,7 @@ name = \"jobserver\"\n version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -714,7 +714,7 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.27\"\n+version = \"0.2.29\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -725,7 +725,7 @@ dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -738,7 +738,7 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cmake 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -750,7 +750,7 @@ version = \"1.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -771,7 +771,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -801,15 +801,15 @@ name = \"memchr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -818,7 +818,7 @@ version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -843,7 +843,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -919,7 +919,7 @@ name = \"num_cpus\"\n version = \"1.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -935,7 +935,7 @@ dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-sys 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -950,7 +950,7 @@ version = \"0.9.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1072,7 +1072,7 @@ name = \"rand\"\n version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1604,7 +1604,7 @@ dependencies = [\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1709,7 +1709,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1828,7 +1828,7 @@ name = \"syntex_errors\"\n version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1850,7 +1850,7 @@ version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1865,7 +1865,7 @@ version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1896,7 +1896,7 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1931,7 +1931,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2120,7 +2120,7 @@ name = \"xattr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2189,7 +2189,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d52e477b23bf52cd3ca0f9fc6c5d14be954eec97e3b9cdfbd962d911bd533caf\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"719aa0af4c241fa71d396ffdfe584aa758f08f35b4680ec3f03ecc2c3fe69b76\"\n+\"checksum libc 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8a014d9226c2cc402676fbe9ea2e15dd5222cd1dd57f576b5b283178c944a264\"\n \"checksum libgit2-sys 0.6.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df18a822100352d9863b302faf6f8f25c0e77f0e60feb40e5dbe1238b7f13b1d\"\n \"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n \"checksum libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd64ef8ee652185674455c1d450b83cbc8ad895625d543b5324d923f82e4d8\""}, {"sha": "d7f795e4055341c3322ff47d7b83db2bd1a73c90", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -427,7 +427,7 @@ impl<'a> Builder<'a> {\n             } else {\n                 self.sysroot(compiler)\n             })\n-            .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n+            .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n             .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler));\n         cmd"}, {"sha": "e9cf71c32fe9a2d83821dffcdf8b7543fac7757b", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -19,7 +19,7 @@\n SPEC = re.compile(\n     r'^(?:(?P<void>V)|(?P<id>[iusfIUSF])(?:\\((?P<start>\\d+)-(?P<end>\\d+)\\)|'\n     r'(?P<width>\\d+)(:?/(?P<llvm_width>\\d+))?)'\n-    r'|(?P<reference>\\d+))(?P<index>\\.\\d+)?(?P<modifiers>[vShdnwusfDMC]*)(?P<force_width>x\\d+)?'\n+    r'|(?P<reference>\\d+))(?P<index>\\.\\d+)?(?P<modifiers>[vShdnwusfDMCNW]*)(?P<force_width>x\\d+)?'\n     r'(?:(?P<pointer>Pm|Pc)(?P<llvm_pointer>/.*)?|(?P<bitcast>->.*))?$'\n )\n \n@@ -246,6 +246,12 @@ def modify(self, spec, width, previous):\n             return Vector(self._elem, self._length // 2)\n         elif spec == 'd':\n             return Vector(self._elem, self._length * 2)\n+        elif spec == 'N':\n+            elem = self._elem.__class__(self._elem.bitwidth() // 2)\n+            return Vector(elem, self._length * 2)\n+        elif spec == 'W':\n+            elem = self._elem.__class__(self._elem.bitwidth() * 2)\n+            return Vector(elem, self._length // 2)\n         elif spec.startswith('x'):\n             new_bitwidth = int(spec[1:])\n             return Vector(self._elem, new_bitwidth // self._elem.bitwidth())\n@@ -714,6 +720,8 @@ def parse_args():\n         - 'd': double the length of the vector (u32x2 -> u32x4)\n         - 'n': narrow the element of the vector (u32x4 -> u16x4)\n         - 'w': widen the element of the vector (u16x4 -> u32x4)\n+        - 'N': half the length of the vector element (u32x4 -> u16x8)\n+        - 'W': double the length of the vector element (u16x8 -> u32x4)\n         - 'u': force a number (vector or scalar) to be unsigned int (f32x4 -> u32x4)\n         - 's': force a number (vector or scalar) to be signed int (u32x4 -> i32x4)\n         - 'f': force a number (vector or scalar) to be float (u32x4 -> f32x4)"}, {"sha": "c70791be030f7afa3710b4f7fe7abfed59542de8", "filename": "src/etc/platform-intrinsics/powerpc.json", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -72,6 +72,55 @@\n             \"llvm\": \"vmin{0.kind}{0.data_type_short}\",\n             \"ret\": \"i(8-32)\",\n             \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"sub{0.kind}{0.data_type_short}s\",\n+            \"width\": [128],\n+            \"llvm\": \"vsub{0.kind}{0.data_type_short}s\",\n+            \"ret\": \"i(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"subc\",\n+            \"width\": [128],\n+            \"llvm\": \"vsubcuw\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"add{0.kind}{0.data_type_short}s\",\n+            \"width\": [128],\n+            \"llvm\": \"vadd{0.kind}{0.data_type_short}s\",\n+            \"ret\": \"i(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"addc\",\n+            \"width\": [128],\n+            \"llvm\": \"vaddcuw\",\n+            \"ret\": \"u32\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"mule{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vmule{0.kind}{1.data_type_short}\",\n+            \"ret\": \"i(16-32)\",\n+            \"args\": [\"0N\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"mulo{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vmulo{0.kind}{1.data_type_short}\",\n+            \"ret\": \"i(16-32)\",\n+            \"args\": [\"0N\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"avg{0.kind}{0.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vavg{0.kind}{0.data_type_short}\",\n+            \"ret\": \"i(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n         }\n     ]\n }"}, {"sha": "8cea6c482c33d0a65c7a146f43dfd21fc3098d98", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1037,7 +1037,7 @@ impl<'a, K: 'a, V: 'a, NodeType>\n         Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n \n     pub fn into_kv_mut(self) -> (&'a mut K, &'a mut V) {\n-        let (mut keys, mut vals) = self.node.into_slices_mut();\n+        let (keys, vals) = self.node.into_slices_mut();\n         unsafe {\n             (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n         }\n@@ -1047,7 +1047,7 @@ impl<'a, K: 'a, V: 'a, NodeType>\n impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n         unsafe {\n-            let (mut keys, mut vals) = self.node.reborrow_mut().into_slices_mut();\n+            let (keys, vals) = self.node.reborrow_mut().into_slices_mut();\n             (keys.get_unchecked_mut(self.idx), vals.get_unchecked_mut(self.idx))\n         }\n     }"}, {"sha": "160c0ba2ab0e3482f56771f1950a73a3d107bc71", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1751,7 +1751,7 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n     type Item = &'a mut T;\n     type IntoIter = slice::IterMut<'a, T>;\n \n-    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+    fn into_iter(self) -> slice::IterMut<'a, T> {\n         self.iter_mut()\n     }\n }"}, {"sha": "2068c2c9c5fb56268f5ece03cd97bc06d1022dc6", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -2394,7 +2394,7 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n-    fn into_iter(mut self) -> IterMut<'a, T> {\n+    fn into_iter(self) -> IterMut<'a, T> {\n         self.iter_mut()\n     }\n }\n@@ -2558,7 +2558,7 @@ impl<'a, T> Place<T> for PlaceBack<'a, T> {\n impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n     type Owner = &'a mut T;\n \n-    unsafe fn finalize(mut self) -> &'a mut T {\n+    unsafe fn finalize(self) -> &'a mut T {\n         let head = self.vec_deque.head;\n         self.vec_deque.head = self.vec_deque.wrap_add(head, 1);\n         &mut *(self.vec_deque.ptr().offset(head as isize))\n@@ -2605,7 +2605,7 @@ impl<'a, T> Place<T> for PlaceFront<'a, T> {\n impl<'a, T> InPlace<T> for PlaceFront<'a, T> {\n     type Owner = &'a mut T;\n \n-    unsafe fn finalize(mut self) -> &'a mut T {\n+    unsafe fn finalize(self) -> &'a mut T {\n         self.vec_deque.tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n         &mut *(self.vec_deque.ptr().offset(self.vec_deque.tail as isize))\n     }"}, {"sha": "ec6525485f7a1d2a5107d4490f90ae8370936d51", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -110,11 +110,13 @@ use self::Ordering::*;\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used\n     /// by `==`.\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n@@ -625,6 +627,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// let result = std::f64::NAN.partial_cmp(&1.0);\n     /// assert_eq!(result, None);\n     /// ```\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n@@ -640,6 +643,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// assert_eq!(result, false);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n@@ -661,6 +665,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// assert_eq!(result, true);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n@@ -681,6 +686,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// assert_eq!(result, false);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n@@ -702,6 +708,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// assert_eq!(result, true);\n     /// ```\n     #[inline]\n+    #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {"}, {"sha": "73d518b570a113df576e597c906efa6068499d3d", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -214,9 +214,16 @@ impl<A: Step> Iterator for ops::Range<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            let mut n = self.start.add_one();\n-            mem::swap(&mut n, &mut self.start);\n-            Some(n)\n+            // We check for overflow here, even though it can't actually\n+            // happen. Adding this check does however help llvm vectorize loops\n+            // for some ranges that don't get vectorized otherwise,\n+            // and this won't actually result in an extra check in an optimized build.\n+            if let Some(mut n) = self.start.add_usize(1) {\n+                mem::swap(&mut n, &mut self.start);\n+                Some(n)\n+            } else {\n+                None\n+            }\n         } else {\n             None\n         }"}, {"sha": "684b81a27f82e39291addc166bcbd503416d1a4b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[macro_export]\n+// This stability attribute is totally useless.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n+macro_rules! __rust_unstable_column {\n+    () => {\n+        column!()\n+    }\n+}\n+\n /// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n #[allow_internal_unstable]\n@@ -18,7 +28,7 @@ macro_rules! panic {\n     );\n     ($msg:expr) => ({\n         static _MSG_FILE_LINE_COL: (&'static str, &'static str, u32, u32) =\n-            ($msg, file!(), line!(), column!());\n+            ($msg, file!(), line!(), __rust_unstable_column!());\n         $crate::panicking::panic(&_MSG_FILE_LINE_COL)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n@@ -27,7 +37,7 @@ macro_rules! panic {\n         // insufficient, since the user may have\n         // `#[forbid(dead_code)]` and which cannot be overridden.\n         static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =\n-            (file!(), line!(), column!());\n+            (file!(), line!(), __rust_unstable_column!());\n         $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)\n     });\n }"}, {"sha": "c5b3fbca1a6dd492e313c6782cd44b2a2e43fa2c", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -187,7 +187,7 @@ mod impls {\n         where F : FnMut<A>\n     {\n         type Output = F::Output;\n-        extern \"rust-call\" fn call_once(mut self, args: A) -> F::Output {\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }"}, {"sha": "aecf2ee9325eee9dde0a13cef3d65e293610c147", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -872,7 +872,7 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n-    fn into_iter(mut self) -> IterMut<'a, T> {\n+    fn into_iter(self) -> IterMut<'a, T> {\n         self.iter_mut()\n     }\n }"}, {"sha": "20cfb02afcc7707149236dd940066532ccc151c2", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -909,7 +909,7 @@ impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n-    fn into_iter(mut self) -> IterMut<'a, T> {\n+    fn into_iter(self) -> IterMut<'a, T> {\n         self.iter_mut()\n     }\n }"}, {"sha": "8c31d2e83d3524f797c1417cd27c0db7587028fb", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -105,27 +105,27 @@ fn test_chunks_last() {\n \n #[test]\n fn test_chunks_mut_count() {\n-    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     let c = v.chunks_mut(3);\n     assert_eq!(c.count(), 2);\n \n-    let mut v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let c2 = v2.chunks_mut(2);\n     assert_eq!(c2.count(), 3);\n \n-    let mut v3: &mut [i32] = &mut [];\n+    let v3: &mut [i32] = &mut [];\n     let c3 = v3.chunks_mut(2);\n     assert_eq!(c3.count(), 0);\n }\n \n #[test]\n fn test_chunks_mut_nth() {\n-    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     let mut c = v.chunks_mut(2);\n     assert_eq!(c.nth(1).unwrap()[1], 3);\n     assert_eq!(c.next().unwrap()[0], 4);\n \n-    let mut v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let mut c2 = v2.chunks_mut(3);\n     assert_eq!(c2.nth(1).unwrap()[1], 4);\n     assert_eq!(c2.next(), None);\n@@ -194,7 +194,7 @@ fn get_range() {\n \n #[test]\n fn get_mut_range() {\n-    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n     assert_eq!(v.get_mut(..), Some(&mut [0, 1, 2, 3, 4, 5][..]));\n     assert_eq!(v.get_mut(..2), Some(&mut [0, 1][..]));\n     assert_eq!(v.get_mut(2..), Some(&mut [2, 3, 4, 5][..]));"}, {"sha": "5b609f192e1c2b11d351febd6d23b72e3e99c2d6", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -521,6 +521,7 @@ define_dep_nodes!( <'tcx>\n     [] IsAllocator(DefId),\n     [] IsPanicRuntime(DefId),\n     [] ExternCrate(DefId),\n+    [] LintLevels,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "352d25dad659c0447aae9d72c7da8ca14d6371a3", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -640,8 +640,6 @@ for ty::TypeckTables<'tcx> {\n \n             ref cast_kinds,\n \n-            // FIXME(#41184): This is still ignored at the moment.\n-            lints: _,\n             ref used_trait_imports,\n             tainted_by_errors,\n             ref free_region_map,"}, {"sha": "9f70b4834ddc5d71b0700be42671d9e584a3678f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -415,8 +415,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// -------- this type is the same as a type argument in the other type, not highlighted\n     /// ```\n     fn highlight_outer(&self,\n-                       mut value: &mut DiagnosticStyledString,\n-                       mut other_value: &mut DiagnosticStyledString,\n+                       value: &mut DiagnosticStyledString,\n+                       other_value: &mut DiagnosticStyledString,\n                        name: String,\n                        sub: &ty::subst::Substs<'tcx>,\n                        pos: usize,"}, {"sha": "6ee06dc0a8163775af63b54ef02a158aa2e4091d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 198, "deletions": 573, "changes": 771, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -23,29 +23,25 @@\n //! previous lint state is pushed onto a stack and the ast is then recursed\n //! upon.  As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n+\n use self::TargetLint::*;\n \n+use rustc_back::slice;\n+use lint::{EarlyLintPassObject, LateLintPassObject};\n+use lint::{Level, Lint, LintId, LintPass, LintBuffer};\n+use lint::levels::{LintLevelSets, LintLevelsBuilder};\n use middle::privacy::AccessLevels;\n+use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n+use session::{config, early_error, Session};\n use traits::Reveal;\n use ty::{self, TyCtxt};\n-use session::{config, early_error, Session};\n-use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n-use lint::{EarlyLintPassObject, LateLintPassObject};\n-use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n-use lint::builtin;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use util::nodemap::FxHashMap;\n \n-use std::cmp;\n use std::default::Default as StdDefault;\n-use std::mem;\n-use std::fmt;\n use std::cell::{Ref, RefCell};\n-use syntax::attr;\n use syntax::ast;\n-use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n-use errors::{self, Diagnostic, DiagnosticBuilder};\n+use errors::DiagnosticBuilder;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit as hir_visit;\n@@ -69,9 +65,6 @@ pub struct LintStore {\n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n \n-    /// Current levels of each lint, and where they were set.\n-    levels: LintLevels,\n-\n     /// Map of registered lint groups to what lints they expand to. The bool\n     /// is true if the lint group was added by a plugin.\n     lint_groups: FxHashMap<&'static str, (Vec<LintId>, bool)>,\n@@ -81,78 +74,23 @@ pub struct LintStore {\n     future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n \n-\n-#[derive(Default)]\n-struct LintLevels {\n-    /// Current levels of each lint, and where they were set.\n-    levels: FxHashMap<LintId, LevelSource>,\n-\n-    /// Maximum level a lint can be\n-    lint_cap: Option<Level>,\n-}\n-\n-\n pub struct LintSession<'a, PassObject> {\n     /// Reference to the store of registered lints.\n     lints: Ref<'a, LintStore>,\n \n-    /// The current lint levels.\n-    levels: LintLevels,\n-\n-    /// When recursing into an attributed node of the ast which modifies lint\n-    /// levels, this stack keeps track of the previous lint levels of whatever\n-    /// was modified.\n-    stack: Vec<(LintId, LevelSource)>,\n-\n     /// Trait objects for each lint pass.\n     passes: Option<Vec<PassObject>>,\n }\n \n \n-/// When you call `add_lint` on the session, you wind up storing one\n-/// of these, which records a \"potential lint\" at a particular point.\n-#[derive(PartialEq, RustcEncodable, RustcDecodable)]\n-pub struct EarlyLint {\n-    /// what lint is this? (e.g., `dead_code`)\n-    pub id: LintId,\n-\n-    /// the main message\n-    pub diagnostic: Diagnostic,\n-}\n-\n-impl fmt::Debug for EarlyLint {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"EarlyLint\")\n-            .field(\"id\", &self.id)\n-            .field(\"span\", &self.diagnostic.span)\n-            .field(\"diagnostic\", &self.diagnostic)\n-            .finish()\n-    }\n-}\n-\n-pub trait IntoEarlyLint {\n-    fn into_early_lint(self, id: LintId) -> EarlyLint;\n-}\n-\n-impl<'a, S: Into<MultiSpan>> IntoEarlyLint for (S, &'a str) {\n-    fn into_early_lint(self, id: LintId) -> EarlyLint {\n-        let (span, msg) = self;\n-        let mut diagnostic = Diagnostic::new(errors::Level::Warning, msg);\n-        diagnostic.set_span(span);\n-        EarlyLint {\n-            id,\n-            diagnostic,\n-        }\n-    }\n-}\n-\n-impl IntoEarlyLint for Diagnostic {\n-    fn into_early_lint(self, id: LintId) -> EarlyLint {\n-        EarlyLint {\n-            id,\n-            diagnostic: self,\n-        }\n-    }\n+/// Lints that are buffered up early on in the `Session` before the\n+/// `LintLevels` is calculated\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+pub struct BufferedEarlyLint {\n+    pub lint_id: LintId,\n+    pub ast_id: ast::NodeId,\n+    pub span: MultiSpan,\n+    pub msg: String,\n }\n \n /// Extra information for a future incompatibility lint. See the call\n@@ -176,19 +114,27 @@ enum TargetLint {\n     Removed(String),\n }\n \n-enum FindLintError {\n+pub enum FindLintError {\n     NotFound,\n     Removed,\n }\n \n+pub enum CheckLintNameResult<'a> {\n+    Ok(&'a [LintId]),\n+    // Lint doesn't exist\n+    NoLint,\n+    // The lint is either renamed or removed. This is the warning\n+    // message.\n+    Warning(String),\n+}\n+\n impl LintStore {\n     pub fn new() -> LintStore {\n         LintStore {\n             lints: vec![],\n             early_passes: Some(vec![]),\n             late_passes: Some(vec![]),\n             by_name: FxHashMap(),\n-            levels: LintLevels::default(),\n             future_incompatible: FxHashMap(),\n             lint_groups: FxHashMap(),\n         }\n@@ -241,8 +187,6 @@ impl LintStore {\n                     (Some(sess), true)  => sess.err(&msg[..]),\n                 }\n             }\n-\n-            self.levels.set(id, (lint.default_level, Default));\n         }\n     }\n \n@@ -291,96 +235,93 @@ impl LintStore {\n         self.by_name.insert(name.into(), Removed(reason.into()));\n     }\n \n-    fn find_lint(&self, lint_name: &str) -> Result<LintId, FindLintError> {\n+    pub fn find_lints(&self, lint_name: &str) -> Result<Vec<LintId>, FindLintError> {\n         match self.by_name.get(lint_name) {\n-            Some(&Id(lint_id)) => Ok(lint_id),\n+            Some(&Id(lint_id)) => Ok(vec![lint_id]),\n             Some(&Renamed(_, lint_id)) => {\n-                Ok(lint_id)\n+                Ok(vec![lint_id])\n             },\n             Some(&Removed(_)) => {\n                 Err(FindLintError::Removed)\n             },\n-            None => Err(FindLintError::NotFound)\n-        }\n-    }\n-\n-    pub fn process_command_line(&mut self, sess: &Session) {\n-        for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            check_lint_name_cmdline(sess, self,\n-                                    &lint_name[..], level);\n-\n-            let lint_flag_val = Symbol::intern(&lint_name);\n-            match self.find_lint(&lint_name[..]) {\n-                Ok(lint_id) => self.levels.set(lint_id, (level, CommandLine(lint_flag_val))),\n-                Err(FindLintError::Removed) => { }\n-                Err(_) => {\n-                    match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n-                                                 .collect::<FxHashMap<&'static str,\n-                                                                      Vec<LintId>>>()\n-                                                 .get(&lint_name[..]) {\n-                        Some(v) => {\n-                            for lint_id in v {\n-                                self.levels.set(*lint_id, (level, CommandLine(lint_flag_val)));\n-                            }\n-                        }\n-                        None => {\n-                            // The lint or lint group doesn't exist.\n-                            // This is an error, but it was handled\n-                            // by check_lint_name_cmdline.\n-                        }\n-                    }\n+            None => {\n+                match self.lint_groups.get(lint_name) {\n+                    Some(v) => Ok(v.0.clone()),\n+                    None => Err(FindLintError::Removed)\n                 }\n             }\n         }\n-\n-        self.levels.set_lint_cap(sess.opts.lint_cap);\n     }\n-}\n-\n \n-impl LintLevels {\n-    fn get_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.get(&lint) {\n-            Some(&s) => s,\n-            None => (Allow, Default),\n-        }\n-    }\n+    // Checks the validity of lint names derived from the command line\n+    pub fn check_lint_name_cmdline(&self,\n+                                   sess: &Session,\n+                                   lint_name: &str,\n+                                   level: Level) {\n+        let db = match self.check_lint_name(lint_name) {\n+            CheckLintNameResult::Ok(_) => None,\n+            CheckLintNameResult::Warning(ref msg) => {\n+                Some(sess.struct_warn(msg))\n+            },\n+            CheckLintNameResult::NoLint => {\n+                Some(struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name))\n+            }\n+        };\n \n-    fn set(&mut self, lint: LintId, mut lvlsrc: LevelSource) {\n-        if let Some(cap) = self.lint_cap {\n-            lvlsrc.0 = cmp::min(lvlsrc.0, cap);\n-        }\n-        if lvlsrc.0 == Allow {\n-            self.levels.remove(&lint);\n-        } else {\n-            self.levels.insert(lint, lvlsrc);\n+        if let Some(mut db) = db {\n+            let msg = format!(\"requested on the command line with `{} {}`\",\n+                              match level {\n+                                  Level::Allow => \"-A\",\n+                                  Level::Warn => \"-W\",\n+                                  Level::Deny => \"-D\",\n+                                  Level::Forbid => \"-F\",\n+                              },\n+                              lint_name);\n+            db.note(&msg);\n+            db.emit();\n         }\n     }\n \n-    fn set_lint_cap(&mut self, lint_cap: Option<Level>) {\n-        self.lint_cap = lint_cap;\n-        if let Some(cap) = lint_cap {\n-            for (_, level) in &mut self.levels {\n-                level.0 = cmp::min(level.0, cap);\n+    /// Checks the name of a lint for its existence, and whether it was\n+    /// renamed or removed. Generates a DiagnosticBuilder containing a\n+    /// warning for renamed and removed lints. This is over both lint\n+    /// names from attributes and those passed on the command line. Since\n+    /// it emits non-fatal warnings and there are *two* lint passes that\n+    /// inspect attributes, this is only run from the late pass to avoid\n+    /// printing duplicate warnings.\n+    pub fn check_lint_name(&self, lint_name: &str) -> CheckLintNameResult {\n+        match self.by_name.get(lint_name) {\n+            Some(&Renamed(ref new_name, _)) => {\n+                CheckLintNameResult::Warning(\n+                    format!(\"lint {} has been renamed to {}\", lint_name, new_name)\n+                )\n+            },\n+            Some(&Removed(ref reason)) => {\n+                CheckLintNameResult::Warning(\n+                    format!(\"lint {} has been removed: {}\", lint_name, reason)\n+                )\n+            },\n+            None => {\n+                match self.lint_groups.get(lint_name) {\n+                    None => CheckLintNameResult::NoLint,\n+                    Some(ids) => CheckLintNameResult::Ok(&ids.0),\n+                }\n             }\n+            Some(&Id(ref id)) => CheckLintNameResult::Ok(slice::ref_slice(id)),\n         }\n     }\n }\n \n-\n impl<'a, PassObject: LintPassObject> LintSession<'a, PassObject> {\n     /// Creates a new `LintSession`, by moving out the `LintStore`'s initial\n     /// lint levels and pass objects. These can be restored using the `restore`\n     /// method.\n     fn new(store: &'a RefCell<LintStore>) -> LintSession<'a, PassObject> {\n         let mut s = store.borrow_mut();\n-        let levels = mem::replace(&mut s.levels, LintLevels::default());\n         let passes = PassObject::take_passes(&mut *s);\n         drop(s);\n         LintSession {\n             lints: store.borrow(),\n-            stack: Vec::new(),\n-            levels,\n             passes,\n         }\n     }\n@@ -389,17 +330,10 @@ impl<'a, PassObject: LintPassObject> LintSession<'a, PassObject> {\n     fn restore(self, store: &RefCell<LintStore>) {\n         drop(self.lints);\n         let mut s = store.borrow_mut();\n-        s.levels = self.levels;\n         PassObject::restore_passes(&mut *s, self.passes);\n     }\n-\n-    fn get_source(&self, lint_id: LintId) -> LevelSource {\n-        self.levels.get_source(lint_id)\n-    }\n }\n \n-\n-\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n@@ -416,6 +350,8 @@ pub struct LateContext<'a, 'tcx: 'a> {\n \n     /// The store of registered lints and the lint levels.\n     lint_sess: LintSession<'tcx, LateLintPassObject>,\n+\n+    last_ast_node_with_lint_attrs: ast::NodeId,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -427,8 +363,12 @@ pub struct EarlyContext<'a> {\n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n \n+    builder: LintLevelsBuilder<'a>,\n+\n     /// The store of registered lints and the lint levels.\n     lint_sess: LintSession<'a, EarlyLintPassObject>,\n+\n+    buffered: LintBuffer,\n }\n \n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n@@ -442,135 +382,6 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n     $cx.lint_sess_mut().passes = Some(passes);\n }) }\n \n-/// Parse the lint attributes into a vector, with `Err`s for malformed lint\n-/// attributes. Writing this as an iterator is an enormous mess.\n-// See also the hir version just below.\n-pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n-    let mut out = vec![];\n-    for attr in attrs {\n-        let r = gather_attr(attr);\n-        out.extend(r.into_iter());\n-    }\n-    out\n-}\n-\n-pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n-    let mut out = vec![];\n-\n-    let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n-        None => return out,\n-        Some(lvl) => lvl,\n-    };\n-\n-    let meta = unwrap_or!(attr.meta(), return out);\n-    attr::mark_used(attr);\n-\n-    let metas = if let Some(metas) = meta.meta_item_list() {\n-        metas\n-    } else {\n-        out.push(Err(meta.span));\n-        return out;\n-    };\n-\n-    for li in metas {\n-        out.push(li.word().map_or(Err(li.span), |word| Ok((word.name(), level, word.span))));\n-    }\n-\n-    out\n-}\n-\n-/// Emit a lint as a warning or an error (or not at all)\n-/// according to `level`.\n-///\n-/// This lives outside of `Context` so it can be used by checks\n-/// in trans that run after the main lint pass is finished. Most\n-/// lints elsewhere in the compiler should call\n-/// `Session::add_lint()` instead.\n-pub fn raw_emit_lint<S: Into<MultiSpan>>(sess: &Session,\n-                                         lints: &LintStore,\n-                                         lint: &'static Lint,\n-                                         lvlsrc: LevelSource,\n-                                         span: Option<S>,\n-                                         msg: &str) {\n-    raw_struct_lint(sess, lints, lint, lvlsrc, span, msg).emit();\n-}\n-\n-pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n-                              lints: &LintStore,\n-                              lint: &'static Lint,\n-                              lvlsrc: LevelSource,\n-                              span: Option<S>,\n-                              msg: &str)\n-                              -> DiagnosticBuilder<'a>\n-    where S: Into<MultiSpan>\n-{\n-    let (level, source) = lvlsrc;\n-    if level == Allow {\n-        return sess.diagnostic().struct_dummy();\n-    }\n-\n-    let name = lint.name_lower();\n-\n-    // Except for possible note details, forbid behaves like deny.\n-    let effective_level = if level == Forbid { Deny } else { level };\n-\n-    let mut err = match (effective_level, span) {\n-        (Warn, Some(sp)) => sess.struct_span_warn(sp, &msg[..]),\n-        (Warn, None)     => sess.struct_warn(&msg[..]),\n-        (Deny, Some(sp)) => sess.struct_span_err(sp, &msg[..]),\n-        (Deny, None)     => sess.struct_err(&msg[..]),\n-        _ => bug!(\"impossible level in raw_emit_lint\"),\n-    };\n-\n-    match source {\n-        Default => {\n-            sess.diag_note_once(&mut err, lint,\n-                                &format!(\"#[{}({})] on by default\", level.as_str(), name));\n-        },\n-        CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Warn => \"-W\", Deny => \"-D\", Forbid => \"-F\",\n-                Allow => bug!(\"earlier conditional return should handle Allow case\")\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n-                sess.diag_note_once(&mut err, lint,\n-                                    &format!(\"requested on the command line with `{} {}`\",\n-                                             flag, hyphen_case_lint_name));\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(&mut err, lint,\n-                                    &format!(\"`{} {}` implied by `{} {}`\",\n-                                             flag, hyphen_case_lint_name, flag,\n-                                             hyphen_case_flag_val));\n-            }\n-        },\n-        Node(lint_attr_name, src) => {\n-            sess.diag_span_note_once(&mut err, lint, src, \"lint level defined here\");\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(&mut err, lint,\n-                                    &format!(\"#[{}({})] implied by #[{}({})]\",\n-                                             level_str, name, level_str, lint_attr_name));\n-            }\n-        }\n-    }\n-\n-    // Check for future incompatibility lints and issue a stronger warning.\n-    if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n-        let explanation = format!(\"this was previously accepted by the compiler \\\n-                                   but is being phased out; \\\n-                                   it will become a hard error in a future release!\");\n-        let citation = format!(\"for more information, see {}\",\n-                               future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n-\n-    err\n-}\n-\n-\n pub trait LintPassObject: Sized {\n     fn take_passes(store: &mut LintStore) -> Option<Vec<Self>>;\n     fn restore_passes(store: &mut LintStore, passes: Option<Vec<Self>>);\n@@ -607,67 +418,24 @@ pub trait LintContext<'tcx>: Sized {\n     fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n     fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n \n-    /// Get the level of `lint` at the current position of the lint\n-    /// traversal.\n-    fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lint_sess().get_source(LintId::of(lint)).0\n-    }\n-\n-    fn level_src(&self, lint: &'static Lint) -> Option<LevelSource> {\n-        let ref levels = self.lint_sess().levels;\n-        levels.levels.get(&LintId::of(lint)).map(|ls| match ls {\n-            &(Warn, _) => {\n-                let lint_id = LintId::of(builtin::WARNINGS);\n-                let warn_src = levels.get_source(lint_id);\n-                if warn_src.0 != Warn {\n-                    warn_src\n-                } else {\n-                    *ls\n-                }\n-            }\n-            _ => *ls\n-        })\n-    }\n-\n     fn lookup_and_emit<S: Into<MultiSpan>>(&self,\n                                            lint: &'static Lint,\n                                            span: Option<S>,\n                                            msg: &str) {\n-        let (level, src) = match self.level_src(lint) {\n-            None => return,\n-            Some(pair) => pair,\n-        };\n-\n-        raw_emit_lint(&self.sess(), self.lints(), lint, (level, src), span, msg);\n+        self.lookup(lint, span, msg).emit();\n     }\n \n     fn lookup<S: Into<MultiSpan>>(&self,\n                                   lint: &'static Lint,\n                                   span: Option<S>,\n                                   msg: &str)\n-                                  -> DiagnosticBuilder {\n-        let (level, src) = match self.level_src(lint) {\n-            None => return self.sess().diagnostic().struct_dummy(),\n-            Some(pair) => pair,\n-        };\n-\n-        raw_struct_lint(&self.sess(), self.lints(), lint, (level, src), span, msg)\n-    }\n+                                  -> DiagnosticBuilder;\n \n     /// Emit a lint at the appropriate level, for a particular span.\n     fn span_lint<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: S, msg: &str) {\n         self.lookup_and_emit(lint, Some(span), msg);\n     }\n \n-    fn early_lint(&self, early_lint: &EarlyLint) {\n-        let span = early_lint.diagnostic.span.primary_span().expect(\"early lint w/o primary span\");\n-        let mut err = self.struct_span_lint(early_lint.id.lint,\n-                                            span,\n-                                            &early_lint.diagnostic.message());\n-        err.copy_details_not_message(&early_lint.diagnostic);\n-        err.emit();\n-    }\n-\n     fn struct_span_lint<S: Into<MultiSpan>>(&self,\n                                             lint: &'static Lint,\n                                             span: S,\n@@ -680,12 +448,10 @@ pub trait LintContext<'tcx>: Sized {\n     fn span_lint_note(&self, lint: &'static Lint, span: Span, msg: &str,\n                       note_span: Span, note: &str) {\n         let mut err = self.lookup(lint, Some(span), msg);\n-        if self.current_level(lint) != Level::Allow {\n-            if note_span == span {\n-                err.note(note);\n-            } else {\n-                err.span_note(note_span, note);\n-            }\n+        if note_span == span {\n+            err.note(note);\n+        } else {\n+            err.span_note(note_span, note);\n         }\n         err.emit();\n     }\n@@ -695,9 +461,7 @@ pub trait LintContext<'tcx>: Sized {\n                       msg: &str, help: &str) {\n         let mut err = self.lookup(lint, Some(span), msg);\n         self.span_lint(lint, span, msg);\n-        if self.current_level(lint) != Level::Allow {\n-            err.span_help(span, help);\n-        }\n+        err.span_help(span, help);\n         err.emit();\n     }\n \n@@ -710,94 +474,10 @@ pub trait LintContext<'tcx>: Sized {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n                           attrs: &'tcx [ast::Attribute],\n                           f: F)\n-        where F: FnOnce(&mut Self),\n-    {\n-        // Parse all of the lint attributes, and then add them all to the\n-        // current dictionary of lint information. Along the way, keep a history\n-        // of what we changed so we can roll everything back after invoking the\n-        // specified closure\n-        let mut pushed = 0;\n-\n-        for result in gather_attrs(attrs) {\n-            let (is_group, lint_level_spans) = match result {\n-                Err(span) => {\n-                    span_err!(self.sess(), span, E0452,\n-                              \"malformed lint attribute\");\n-                    continue;\n-                }\n-                Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name.as_str()) {\n-                        Ok(lint_id) => (false, vec![(lint_id, level, span)]),\n-                        Err(FindLintError::NotFound) => {\n-                            match self.lints().lint_groups.get(&*lint_name.as_str()) {\n-                                Some(&(ref v, _)) => (true,\n-                                                      v.iter()\n-                                                      .map(|lint_id: &LintId|\n-                                                           (*lint_id, level, span))\n-                                                      .collect()),\n-                                None => {\n-                                    // The lint or lint group doesn't exist.\n-                                    // This is an error, but it was handled\n-                                    // by check_lint_name_attribute.\n-                                    continue;\n-                                }\n-                            }\n-                        }\n-                        Err(FindLintError::Removed) => continue,\n-                    }\n-                }\n-            };\n-\n-            let lint_attr_name = result.expect(\"lint attribute should be well-formed\").0;\n-\n-            for (lint_id, level, span) in lint_level_spans {\n-                let (now, now_source) = self.lint_sess().get_source(lint_id);\n-                if now == Forbid && level != Forbid {\n-                    let forbidden_lint_name = match now_source {\n-                        LintSource::Default => lint_id.to_string(),\n-                        LintSource::Node(name, _) => name.to_string(),\n-                        LintSource::CommandLine(name) => name.to_string(),\n-                    };\n-                    let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n-                                                            \"{}({}) overruled by outer forbid({})\",\n-                                                            level.as_str(), lint_attr_name,\n-                                                            forbidden_lint_name);\n-                    diag_builder.span_label(span, \"overruled by previous forbid\");\n-                    match now_source {\n-                        LintSource::Default => &mut diag_builder,\n-                        LintSource::Node(_, forbid_source_span) => {\n-                            diag_builder.span_label(forbid_source_span,\n-                                                    \"`forbid` level set here\")\n-                        },\n-                        LintSource::CommandLine(_) => {\n-                            diag_builder.note(\"`forbid` lint level was set on command line\")\n-                        }\n-                    }.emit();\n-                    if is_group { // don't set a separate error for every lint in the group\n-                        break;\n-                    }\n-                } else if now != level {\n-                    let cx = self.lint_sess_mut();\n-                    cx.stack.push((lint_id, (now, now_source)));\n-                    pushed += 1;\n-                    cx.levels.set(lint_id, (level, Node(lint_attr_name, span)));\n-                }\n-            }\n-        }\n-\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-\n-        // rollback\n-        let cx = self.lint_sess_mut();\n-        for _ in 0..pushed {\n-            let (lint, lvlsrc) = cx.stack.pop().unwrap();\n-            cx.levels.set(lint, lvlsrc);\n-        }\n-    }\n+        where F: FnOnce(&mut Self);\n }\n \n \n@@ -808,6 +488,16 @@ impl<'a> EarlyContext<'a> {\n             sess,\n             krate,\n             lint_sess: LintSession::new(&sess.lint_store),\n+            builder: LintLevelSets::builder(sess),\n+            buffered: sess.buffered_lints.borrow_mut().take().unwrap(),\n+        }\n+    }\n+\n+    fn check_id(&mut self, id: ast::NodeId) {\n+        for early_lint in self.buffered.take(id) {\n+            self.lookup_and_emit(early_lint.lint_id.lint,\n+                                 Some(early_lint.span.clone()),\n+                                 &early_lint.msg);\n         }\n     }\n }\n@@ -841,6 +531,32 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n         debug!(\"late context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, late_passes, attrs);\n     }\n+\n+    fn lookup<S: Into<MultiSpan>>(&self,\n+                                  lint: &'static Lint,\n+                                  span: Option<S>,\n+                                  msg: &str)\n+                                  -> DiagnosticBuilder {\n+        let id = self.last_ast_node_with_lint_attrs;\n+        match span {\n+            Some(s) => self.tcx.struct_span_lint_node(lint, id, s, msg),\n+            None => self.tcx.struct_lint_node(lint, id, msg),\n+        }\n+    }\n+\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &'tcx [ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let prev = self.last_ast_node_with_lint_attrs;\n+        self.last_ast_node_with_lint_attrs = id;\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.last_ast_node_with_lint_attrs = prev;\n+    }\n }\n \n impl<'a> LintContext<'a> for EarlyContext<'a> {\n@@ -872,6 +588,28 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, early_passes, attrs);\n     }\n+\n+    fn lookup<S: Into<MultiSpan>>(&self,\n+                                  lint: &'static Lint,\n+                                  span: Option<S>,\n+                                  msg: &str)\n+                                  -> DiagnosticBuilder {\n+        self.builder.struct_lint(lint, span.map(|s| s.into()), msg)\n+    }\n+\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &'a [ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let push = self.builder.push(attrs);\n+        self.check_id(id);\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.builder.pop(push);\n+    }\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n@@ -893,15 +631,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n-    // Output any lints that were previously added to the session.\n-    fn visit_id(&mut self, id: ast::NodeId) {\n-        let lints = self.sess().lints.borrow_mut().take(id);\n-        for early_lint in lints.iter().chain(self.tables.lints.get(id)) {\n-            debug!(\"LateContext::visit_id: id={:?} early_lint={:?}\", id, early_lint);\n-            self.early_lint(early_lint);\n-        }\n-    }\n-\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let old_tables = self.tables;\n         self.tables = self.tcx.body_tables(body);\n@@ -917,7 +646,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             cx.with_param_env(it.id, |cx| {\n                 run_lints!(cx, check_item, late_passes, it);\n                 hir_visit::walk_item(cx, it);\n@@ -927,7 +656,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             cx.with_param_env(it.id, |cx| {\n                 run_lints!(cx, check_foreign_item, late_passes, it);\n                 hir_visit::walk_foreign_item(cx, it);\n@@ -942,7 +671,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        self.with_lint_attrs(&e.attrs, |cx| {\n+        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n             run_lints!(cx, check_expr_post, late_passes, e);\n@@ -984,7 +713,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.with_lint_attrs(&s.attrs, |cx| {\n+        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, late_passes, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n@@ -994,7 +723,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: ast::NodeId) {\n-        self.with_lint_attrs(&v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, late_passes, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, late_passes, v, g);\n@@ -1017,7 +746,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        self.with_lint_attrs(&l.attrs, |cx| {\n+        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n@@ -1045,7 +774,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n             cx.with_param_env(trait_item.id, |cx| {\n                 run_lints!(cx, check_trait_item, late_passes, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n@@ -1055,7 +784,7 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n             cx.with_param_env(impl_item.id, |cx| {\n                 run_lints!(cx, check_impl_item, late_passes, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n@@ -1080,22 +809,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        check_lint_name_attribute(self, attr);\n         run_lints!(self, check_attribute, late_passes, attr);\n     }\n }\n \n impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     fn visit_item(&mut self, it: &'a ast::Item) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n             ast_visit::walk_item(cx, it);\n             run_lints!(cx, check_item_post, early_passes, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n-        self.with_lint_attrs(&it.attrs, |cx| {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, early_passes, it);\n             ast_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, early_passes, it);\n@@ -1104,24 +832,27 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         run_lints!(self, check_pat, early_passes, p);\n+        self.check_id(p.id);\n         ast_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        self.with_lint_attrs(&e.attrs, |cx| {\n+        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n \n     fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n         run_lints!(self, check_stmt, early_passes, s);\n+        self.check_id(s.id);\n         ast_visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, decl: &'a ast::FnDecl,\n                 span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n+        self.check_id(id);\n         ast_visit::walk_fn(self, fk, decl, span);\n         run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n@@ -1133,19 +864,20 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, early_passes, s, ident, g, item_id);\n+        self.check_id(s.id());\n         ast_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, early_passes, s, ident, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n-        self.with_lint_attrs(&s.attrs, |cx| {\n+        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, early_passes, s);\n             ast_visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(&v.node.attrs, |cx| {\n+        self.with_lint_attrs(item_id, &v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, early_passes, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, early_passes, v, g);\n@@ -1154,6 +886,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n         run_lints!(self, check_ty, early_passes, t);\n+        self.check_id(t.id);\n         ast_visit::walk_ty(self, t);\n     }\n \n@@ -1163,19 +896,21 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n         run_lints!(self, check_mod, early_passes, m, s, n);\n+        self.check_id(n);\n         ast_visit::walk_mod(self, m);\n         run_lints!(self, check_mod_post, early_passes, m, s, n);\n     }\n \n     fn visit_local(&mut self, l: &'a ast::Local) {\n-        self.with_lint_attrs(&l.attrs, |cx| {\n+        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'a ast::Block) {\n         run_lints!(self, check_block, early_passes, b);\n+        self.check_id(b.id);\n         ast_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, early_passes, b);\n     }\n@@ -1195,15 +930,15 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n-        self.with_lint_attrs(&trait_item.attrs, |cx| {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, early_passes, trait_item);\n             ast_visit::walk_trait_item(cx, trait_item);\n             run_lints!(cx, check_trait_item_post, early_passes, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'a ast::ImplItem) {\n-        self.with_lint_attrs(&impl_item.attrs, |cx| {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, early_passes, impl_item);\n             ast_visit::walk_impl_item(cx, impl_item);\n             run_lints!(cx, check_impl_item_post, early_passes, impl_item);\n@@ -1212,6 +947,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n         run_lints!(self, check_lifetime, early_passes, lt);\n+        self.check_id(lt.id);\n     }\n \n     fn visit_lifetime_def(&mut self, lt: &'a ast::LifetimeDef) {\n@@ -1220,11 +956,13 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n \n     fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n+        self.check_id(id);\n         ast_visit::walk_path(self, p);\n     }\n \n     fn visit_path_list_item(&mut self, prefix: &'a ast::Path, item: &'a ast::PathListItem) {\n         run_lints!(self, check_path_list_item, early_passes, item);\n+        self.check_id(item.node.id);\n         ast_visit::walk_path_list_item(self, prefix, item);\n     }\n \n@@ -1233,110 +971,7 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     }\n \n     fn visit_mac_def(&mut self, _mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        let lints = self.sess.lints.borrow_mut().take(id);\n-        for early_lint in lints {\n-            self.early_lint(&early_lint);\n-        }\n-    }\n-}\n-\n-enum CheckLintNameResult {\n-    Ok,\n-    // Lint doesn't exist\n-    NoLint,\n-    // The lint is either renamed or removed. This is the warning\n-    // message.\n-    Warning(String),\n-}\n-\n-/// Checks the name of a lint for its existence, and whether it was\n-/// renamed or removed. Generates a DiagnosticBuilder containing a\n-/// warning for renamed and removed lints. This is over both lint\n-/// names from attributes and those passed on the command line. Since\n-/// it emits non-fatal warnings and there are *two* lint passes that\n-/// inspect attributes, this is only run from the late pass to avoid\n-/// printing duplicate warnings.\n-fn check_lint_name(lint_cx: &LintStore,\n-                   lint_name: &str) -> CheckLintNameResult {\n-    match lint_cx.by_name.get(lint_name) {\n-        Some(&Renamed(ref new_name, _)) => {\n-            CheckLintNameResult::Warning(\n-                format!(\"lint {} has been renamed to {}\", lint_name, new_name)\n-            )\n-        },\n-        Some(&Removed(ref reason)) => {\n-            CheckLintNameResult::Warning(\n-                format!(\"lint {} has been removed: {}\", lint_name, reason)\n-            )\n-        },\n-        None => {\n-            match lint_cx.lint_groups.get(lint_name) {\n-                None => {\n-                    CheckLintNameResult::NoLint\n-                }\n-                Some(_) => {\n-                    /* lint group exists */\n-                    CheckLintNameResult::Ok\n-                }\n-            }\n-        }\n-        Some(_) => {\n-            /* lint exists */\n-            CheckLintNameResult::Ok\n-        }\n-    }\n-}\n-\n-// Checks the validity of lint names derived from attributes\n-fn check_lint_name_attribute(cx: &LateContext, attr: &ast::Attribute) {\n-    for result in gather_attr(attr) {\n-        match result {\n-            Err(_) => {\n-                // Malformed lint attr. Reported by with_lint_attrs\n-                continue;\n-            }\n-            Ok((lint_name, _, span)) => {\n-                match check_lint_name(&cx.lint_sess.lints, &lint_name.as_str()) {\n-                    CheckLintNameResult::Ok => (),\n-                    CheckLintNameResult::Warning(ref msg) => {\n-                        cx.span_lint(builtin::RENAMED_AND_REMOVED_LINTS,\n-                                     span, msg);\n-                    }\n-                    CheckLintNameResult::NoLint => {\n-                        cx.span_lint(builtin::UNKNOWN_LINTS, span,\n-                                     &format!(\"unknown lint: `{}`\",\n-                                              lint_name));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Checks the validity of lint names derived from the command line\n-fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n-                           lint_name: &str, level: Level) {\n-    let db = match check_lint_name(lint_cx, lint_name) {\n-        CheckLintNameResult::Ok => None,\n-        CheckLintNameResult::Warning(ref msg) => {\n-            Some(sess.struct_warn(msg))\n-        },\n-        CheckLintNameResult::NoLint => {\n-            Some(struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name))\n-        }\n-    };\n-\n-    if let Some(mut db) = db {\n-        let msg = format!(\"requested on the command line with `{} {}`\",\n-                          match level {\n-                              Level::Allow => \"-A\",\n-                              Level::Warn => \"-W\",\n-                              Level::Deny => \"-D\",\n-                              Level::Forbid => \"-F\",\n-                          },\n-                          lint_name);\n-        db.note(&msg);\n-        db.emit();\n+        self.check_id(id);\n     }\n }\n \n@@ -1355,10 +990,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),\n+        last_ast_node_with_lint_attrs: ast::CRATE_NODE_ID,\n     };\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(&krate.attrs, |cx| {\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         run_lints!(cx, check_crate, late_passes, krate);\n@@ -1368,16 +1004,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         run_lints!(cx, check_crate_post, late_passes, krate);\n     });\n \n-    // If we missed any lints added to the session, then there's a bug somewhere\n-    // in the iteration code.\n-    if let Some((id, v)) = tcx.sess.lints.borrow().get_any() {\n-        for early_lint in v {\n-            span_bug!(early_lint.diagnostic.span.clone(),\n-                      \"unprocessed lint {:?} at {}\",\n-                      early_lint, tcx.hir.node_to_string(*id));\n-        }\n-    }\n-\n     // Put the lint store levels and passes back in the session.\n     cx.lint_sess.restore(&tcx.sess.lint_store);\n }\n@@ -1386,13 +1012,7 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     let mut cx = EarlyContext::new(sess, krate);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(&krate.attrs, |cx| {\n-        // Lints may be assigned to the whole crate.\n-        let lints = cx.sess.lints.borrow_mut().take(ast::CRATE_NODE_ID);\n-        for early_lint in lints {\n-            cx.early_lint(&early_lint);\n-        }\n-\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         run_lints!(cx, check_crate, early_passes, krate);\n@@ -1405,11 +1025,11 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // Put the lint store levels and passes back in the session.\n     cx.lint_sess.restore(&sess.lint_store);\n \n-    // If we missed any lints added to the session, then there's a bug somewhere\n-    // in the iteration code.\n-    for (_, v) in sess.lints.borrow().get_any() {\n-        for early_lint in v {\n-            span_bug!(early_lint.diagnostic.span.clone(), \"unprocessed lint {:?}\", early_lint);\n+    // Emit all buffered lints from early on in the session now that we've\n+    // calculated the lint levels for all AST nodes.\n+    for (_id, lints) in cx.buffered.map {\n+        for early_lint in lints {\n+            span_bug!(early_lint.span, \"failed to process bufferd lint here\");\n         }\n     }\n }\n@@ -1425,8 +1045,13 @@ impl Decodable for LintId {\n     fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n         let s = d.read_str()?;\n         ty::tls::with(|tcx| {\n-            match tcx.sess.lint_store.borrow().find_lint(&s) {\n-                Ok(id) => Ok(id),\n+            match tcx.sess.lint_store.borrow().find_lints(&s) {\n+                Ok(ids) => {\n+                    if ids.len() != 0 {\n+                        panic!(\"invalid lint-id `{}`\", s);\n+                    }\n+                    Ok(ids[0])\n+                }\n                 Err(_) => panic!(\"invalid lint-id `{}`\", s),\n             }\n         })"}, {"sha": "ab9d4f75597b995897c05e588a501497e80181c4", "filename": "src/librustc/lint/levels.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,343 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp;\n+\n+use errors::DiagnosticBuilder;\n+use hir::HirId;\n+use lint::builtin;\n+use lint::context::CheckLintNameResult;\n+use lint::{self, Lint, LintId, Level, LintSource};\n+use session::Session;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::codemap::MultiSpan;\n+use syntax::symbol::Symbol;\n+use util::nodemap::FxHashMap;\n+\n+pub struct LintLevelSets {\n+    list: Vec<LintSet>,\n+    lint_cap: Level,\n+}\n+\n+enum LintSet {\n+    CommandLine {\n+        // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+        // flag.\n+        specs: FxHashMap<LintId, (Level, LintSource)>,\n+    },\n+\n+    Node {\n+        specs: FxHashMap<LintId, (Level, LintSource)>,\n+        parent: u32,\n+    },\n+}\n+\n+impl LintLevelSets {\n+    pub fn new(sess: &Session) -> LintLevelSets {\n+        let mut me = LintLevelSets {\n+            list: Vec::new(),\n+            lint_cap: Level::Forbid,\n+        };\n+        me.process_command_line(sess);\n+        return me\n+    }\n+\n+    pub fn builder(sess: &Session) -> LintLevelsBuilder {\n+        LintLevelsBuilder::new(sess, LintLevelSets::new(sess))\n+    }\n+\n+    fn process_command_line(&mut self, sess: &Session) {\n+        let store = sess.lint_store.borrow();\n+        let mut specs = FxHashMap();\n+        self.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n+\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n+            store.check_lint_name_cmdline(sess, &lint_name, level);\n+\n+            // If the cap is less than this specified level, e.g. if we've got\n+            // `--cap-lints allow` but we've also got `-D foo` then we ignore\n+            // this specification as the lint cap will set it to allow anyway.\n+            let level = cmp::min(level, self.lint_cap);\n+\n+            let lint_flag_val = Symbol::intern(lint_name);\n+            let ids = match store.find_lints(&lint_name) {\n+                Ok(ids) => ids,\n+                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n+            };\n+            for id in ids {\n+                let src = LintSource::CommandLine(lint_flag_val);\n+                specs.insert(id, (level, src));\n+            }\n+        }\n+\n+        self.list.push(LintSet::CommandLine {\n+            specs: specs,\n+        });\n+    }\n+\n+    fn get_lint_level(&self, lint: &'static Lint, idx: u32)\n+        -> (Level, LintSource)\n+    {\n+        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx);\n+\n+        // If `level` is none then we actually assume the default level for this\n+        // lint.\n+        let mut level = level.unwrap_or(lint.default_level);\n+\n+        // If we're about to issue a warning, check at the last minute for any\n+        // directives against the warnings \"lint\". If, for example, there's an\n+        // `allow(warnings)` in scope then we want to respect that instead.\n+        if level == Level::Warn {\n+            let (warnings_level, warnings_src) =\n+                self.get_lint_id_level(LintId::of(lint::builtin::WARNINGS), idx);\n+            if let Some(configured_warning_level) = warnings_level {\n+                if configured_warning_level != Level::Warn {\n+                    level = configured_warning_level;\n+                    src = warnings_src;\n+                }\n+            }\n+        }\n+\n+        // Ensure that we never exceed the `--cap-lints` argument.\n+        level = cmp::min(level, self.lint_cap);\n+\n+        return (level, src)\n+    }\n+\n+    fn get_lint_id_level(&self, id: LintId, mut idx: u32)\n+        -> (Option<Level>, LintSource)\n+    {\n+        loop {\n+            match self.list[idx as usize] {\n+                LintSet::CommandLine { ref specs } => {\n+                    if let Some(&(level, src)) = specs.get(&id) {\n+                        return (Some(level), src)\n+                    }\n+                    return (None, LintSource::Default)\n+                }\n+                LintSet::Node { ref specs, parent } => {\n+                    if let Some(&(level, src)) = specs.get(&id) {\n+                        return (Some(level), src)\n+                    }\n+                    idx = parent;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct LintLevelsBuilder<'a> {\n+    sess: &'a Session,\n+    sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, u32>,\n+    cur: u32,\n+    warn_about_weird_lints: bool,\n+}\n+\n+pub struct BuilderPush {\n+    prev: u32,\n+}\n+\n+impl<'a> LintLevelsBuilder<'a> {\n+    pub fn new(sess: &'a Session, sets: LintLevelSets) -> LintLevelsBuilder<'a> {\n+        assert_eq!(sets.list.len(), 1);\n+        LintLevelsBuilder {\n+            sess,\n+            sets,\n+            cur: 0,\n+            id_to_set: FxHashMap(),\n+            warn_about_weird_lints: sess.buffered_lints.borrow().is_some(),\n+        }\n+    }\n+\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be be\n+    /// passed to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attriutes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g. a #[forbid] can't be switched to\n+    ///   #[allow]\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub fn push(&mut self, attrs: &[ast::Attribute]) -> BuilderPush {\n+        let mut specs = FxHashMap();\n+        let store = self.sess.lint_store.borrow();\n+        let sess = self.sess;\n+        let bad_attr = |span| {\n+            span_err!(sess, span, E0452,\n+                      \"malformed lint attribute\");\n+        };\n+        for attr in attrs {\n+            let level = match attr.name().and_then(|name| Level::from_str(&name.as_str())) {\n+                None => continue,\n+                Some(lvl) => lvl,\n+            };\n+\n+            let meta = unwrap_or!(attr.meta(), continue);\n+            attr::mark_used(attr);\n+\n+            let metas = if let Some(metas) = meta.meta_item_list() {\n+                metas\n+            } else {\n+                bad_attr(meta.span);\n+                continue\n+            };\n+\n+            for li in metas {\n+                let word = match li.word() {\n+                    Some(word) => word,\n+                    None => {\n+                        bad_attr(li.span);\n+                        continue\n+                    }\n+                };\n+                let name = word.name();\n+                match store.check_lint_name(&name.as_str()) {\n+                    CheckLintNameResult::Ok(ids) => {\n+                        let src = LintSource::Node(name, li.span);\n+                        for id in ids {\n+                            specs.insert(*id, (level, src));\n+                        }\n+                    }\n+                    CheckLintNameResult::Warning(ref msg) => {\n+                        if self.warn_about_weird_lints {\n+                            self.struct_lint(builtin::RENAMED_AND_REMOVED_LINTS,\n+                                             Some(li.span.into()),\n+                                             msg)\n+                                .emit();\n+                        }\n+                    }\n+                    CheckLintNameResult::NoLint => {\n+                        if self.warn_about_weird_lints {\n+                            self.struct_lint(builtin::UNKNOWN_LINTS,\n+                                             Some(li.span.into()),\n+                                             &format!(\"unknown lint: `{}`\", name))\n+                                .emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (id, &(level, ref src)) in specs.iter() {\n+            if level == Level::Forbid {\n+                continue\n+            }\n+            let forbid_src = match self.sets.get_lint_id_level(*id, self.cur) {\n+                (Some(Level::Forbid), src) => src,\n+                _ => continue,\n+            };\n+            let forbidden_lint_name = match forbid_src {\n+                LintSource::Default => id.to_string(),\n+                LintSource::Node(name, _) => name.to_string(),\n+                LintSource::CommandLine(name) => name.to_string(),\n+            };\n+            let (lint_attr_name, lint_attr_span) = match *src {\n+                LintSource::Node(name, span) => (name, span),\n+                _ => continue,\n+            };\n+            let mut diag_builder = struct_span_err!(self.sess,\n+                                                    lint_attr_span,\n+                                                    E0453,\n+                                                    \"{}({}) overruled by outer forbid({})\",\n+                                                    level.as_str(),\n+                                                    lint_attr_name,\n+                                                    forbidden_lint_name);\n+            diag_builder.span_label(lint_attr_span, \"overruled by previous forbid\");\n+            match forbid_src {\n+                LintSource::Default => &mut diag_builder,\n+                LintSource::Node(_, forbid_source_span) => {\n+                    diag_builder.span_label(forbid_source_span,\n+                                            \"`forbid` level set here\")\n+                },\n+                LintSource::CommandLine(_) => {\n+                    diag_builder.note(\"`forbid` lint level was set on command line\")\n+                }\n+            }.emit();\n+            // don't set a separate error for every lint in the group\n+            break\n+        }\n+\n+        let prev = self.cur;\n+        if specs.len() > 0 {\n+            self.cur = self.sets.list.len() as u32;\n+            self.sets.list.push(LintSet::Node {\n+                specs: specs,\n+                parent: prev,\n+            });\n+        }\n+\n+        BuilderPush {\n+            prev: prev,\n+        }\n+    }\n+\n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub fn pop(&mut self, push: BuilderPush) {\n+        self.cur = push.prev;\n+    }\n+\n+    /// Used to emit a lint-related diagnostic based on the current state of\n+    /// this lint context.\n+    pub fn struct_lint(&self,\n+                       lint: &'static Lint,\n+                       span: Option<MultiSpan>,\n+                       msg: &str)\n+        -> DiagnosticBuilder<'a>\n+    {\n+        let (level, src) = self.sets.get_lint_level(lint, self.cur);\n+        lint::struct_lint_level(self.sess, lint, level, src, span, msg)\n+    }\n+\n+    /// Registers the ID provided with the current set of lints stored in\n+    /// this context.\n+    pub fn register_id(&mut self, id: HirId) {\n+        self.id_to_set.insert(id, self.cur);\n+    }\n+\n+    pub fn build(self) -> LintLevelSets {\n+        self.sets\n+    }\n+\n+    pub fn build_map(self) -> LintLevelMap {\n+        LintLevelMap {\n+            sets: self.sets,\n+            id_to_set: self.id_to_set,\n+        }\n+    }\n+}\n+\n+pub struct LintLevelMap {\n+    sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, u32>,\n+}\n+\n+impl LintLevelMap {\n+    /// If the `id` was previously registered with `register_id` when building\n+    /// this `LintLevelMap` this returns the corresponding lint level and source\n+    /// of the lint level for the lint provided.\n+    ///\n+    /// If the `id` was not previously registered, returns `None`. If `None` is\n+    /// returned then the parent of `id` should be acquired and this function\n+    /// should be called again.\n+    pub fn level_and_source(&self, lint: &'static Lint, id: HirId)\n+        -> Option<(Level, LintSource)>\n+    {\n+        self.id_to_set.get(&id).map(|idx| {\n+            self.sets.get_lint_level(lint, *idx)\n+        })\n+    }\n+}"}, {"sha": "c64e1c08082a5637fcfbecf68eba67ebafac13e5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 227, "deletions": 9, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -31,20 +31,27 @@\n pub use self::Level::*;\n pub use self::LintSource::*;\n \n+use std::rc::Rc;\n+\n+use errors::DiagnosticBuilder;\n+use hir::def_id::{CrateNum, LOCAL_CRATE};\n+use hir::intravisit::{self, FnKind};\n use hir;\n-use hir::intravisit::FnKind;\n-use std::hash;\n+use session::Session;\n use std::ascii::AsciiExt;\n-use syntax_pos::Span;\n-use syntax::visit as ast_visit;\n+use std::hash;\n use syntax::ast;\n+use syntax::codemap::MultiSpan;\n use syntax::symbol::Symbol;\n+use syntax::visit as ast_visit;\n+use syntax_pos::Span;\n+use ty::TyCtxt;\n+use ty::maps::Providers;\n+use util::nodemap::NodeMap;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        raw_struct_lint, FutureIncompatibleInfo, EarlyLint, IntoEarlyLint};\n-\n-pub use lint::table::LintTable;\n+                        check_crate, check_ast_crate,\n+                        FutureIncompatibleInfo, BufferedEarlyLint};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -351,4 +358,215 @@ pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;\n mod context;\n-mod table;\n+mod levels;\n+\n+pub use self::levels::{LintLevelSets, LintLevelMap};\n+\n+pub struct LintBuffer {\n+    map: NodeMap<Vec<BufferedEarlyLint>>,\n+}\n+\n+impl LintBuffer {\n+    pub fn new() -> LintBuffer {\n+        LintBuffer { map: NodeMap() }\n+    }\n+\n+    pub fn add_lint(&mut self,\n+                    lint: &'static Lint,\n+                    id: ast::NodeId,\n+                    sp: MultiSpan,\n+                    msg: &str) {\n+        let early_lint = BufferedEarlyLint {\n+            lint_id: LintId::of(lint),\n+            ast_id: id,\n+            span: sp,\n+            msg: msg.to_string(),\n+        };\n+        let arr = self.map.entry(id).or_insert(Vec::new());\n+        if !arr.contains(&early_lint) {\n+            arr.push(early_lint);\n+        }\n+    }\n+\n+    pub fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n+        self.map.remove(&id).unwrap_or(Vec::new())\n+    }\n+\n+    pub fn get_any(&self) -> Option<&[BufferedEarlyLint]> {\n+        let key = self.map.keys().next().map(|k| *k);\n+        key.map(|k| &self.map[&k][..])\n+    }\n+}\n+\n+pub fn struct_lint_level<'a>(sess: &'a Session,\n+                             lint: &'static Lint,\n+                             level: Level,\n+                             src: LintSource,\n+                             span: Option<MultiSpan>,\n+                             msg: &str)\n+    -> DiagnosticBuilder<'a>\n+{\n+    let mut err = match (level, span) {\n+        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n+        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n+        (Level::Warn, None) => sess.struct_warn(msg),\n+        (Level::Deny, Some(span)) |\n+        (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n+        (Level::Deny, None) |\n+        (Level::Forbid, None) => sess.struct_err(msg),\n+    };\n+\n+    let name = lint.name_lower();\n+    match src {\n+        LintSource::Default => {\n+            sess.diag_note_once(\n+                &mut err,\n+                lint,\n+                &format!(\"#[{}({})] on by default\", level.as_str(), name));\n+        }\n+        LintSource::CommandLine(lint_flag_val) => {\n+            let flag = match level {\n+                Level::Warn => \"-W\",\n+                Level::Deny => \"-D\",\n+                Level::Forbid => \"-F\",\n+                Level::Allow => panic!(),\n+            };\n+            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+            if lint_flag_val.as_str() == name {\n+                sess.diag_note_once(\n+                    &mut err,\n+                    lint,\n+                    &format!(\"requested on the command line with `{} {}`\",\n+                             flag, hyphen_case_lint_name));\n+            } else {\n+                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                sess.diag_note_once(\n+                    &mut err,\n+                    lint,\n+                    &format!(\"`{} {}` implied by `{} {}`\",\n+                             flag, hyphen_case_lint_name, flag,\n+                             hyphen_case_flag_val));\n+            }\n+        }\n+        LintSource::Node(lint_attr_name, src) => {\n+            sess.diag_span_note_once(&mut err, lint, src, \"lint level defined here\");\n+            if lint_attr_name.as_str() != name {\n+                let level_str = level.as_str();\n+                sess.diag_note_once(&mut err, lint,\n+                                    &format!(\"#[{}({})] implied by #[{}({})]\",\n+                                             level_str, name, level_str, lint_attr_name));\n+            }\n+        }\n+    }\n+\n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    if let Some(future_incompatible) = lints.future_incompatible(LintId::of(lint)) {\n+        let explanation = format!(\"this was previously accepted by the compiler \\\n+                                   but is being phased out; \\\n+                                   it will become a hard error in a future release!\");\n+        let citation = format!(\"for more information, see {}\",\n+                               future_incompatible.reference);\n+        err.warn(&explanation);\n+        err.note(&citation);\n+    }\n+\n+    return err\n+}\n+\n+fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n+    -> Rc<LintLevelMap>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+    let mut builder = LintLevelMapBuilder {\n+        levels: LintLevelSets::builder(tcx.sess),\n+        tcx: tcx,\n+    };\n+    let krate = tcx.hir.krate();\n+\n+    builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n+        intravisit::walk_crate(builder, krate);\n+    });\n+\n+    Rc::new(builder.levels.build_map())\n+}\n+\n+struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n+    levels: levels::LintLevelsBuilder<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n+    fn with_lint_attrs<F>(&mut self,\n+                          id: ast::NodeId,\n+                          attrs: &[ast::Attribute],\n+                          f: F)\n+        where F: FnOnce(&mut Self)\n+    {\n+        let push = self.levels.push(attrs);\n+        self.levels.register_id(self.tcx.hir.definitions().node_to_hir_id(id));\n+        f(self);\n+        self.levels.pop(push);\n+    }\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n+        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+            intravisit::walk_item(builder, it);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n+        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+            intravisit::walk_foreign_item(builder, it);\n+        })\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n+        self.with_lint_attrs(e.id, &e.attrs, |builder| {\n+            intravisit::walk_expr(builder, e);\n+        })\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.with_lint_attrs(s.id, &s.attrs, |builder| {\n+            intravisit::walk_struct_field(builder, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n+        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |builder| {\n+            intravisit::walk_variant(builder, v, g, item_id);\n+        })\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n+        self.with_lint_attrs(l.id, &l.attrs, |builder| {\n+            intravisit::walk_local(builder, l);\n+        })\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |builder| {\n+            intravisit::walk_trait_item(builder, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |builder| {\n+            intravisit::walk_impl_item(builder, impl_item);\n+        });\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.lint_levels = lint_levels;\n+}"}, {"sha": "f2dab25229ae4e0ec3ed063c38dbd8b70d328637", "filename": "src/librustc/lint/table.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/be95ca4b17203a3aed27c17c1e93b76c9477e5bc/src%2Flibrustc%2Flint%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be95ca4b17203a3aed27c17c1e93b76c9477e5bc/src%2Flibrustc%2Flint%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Ftable.rs?ref=be95ca4b17203a3aed27c17c1e93b76c9477e5bc", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use syntax_pos::MultiSpan;\n-use util::nodemap::NodeMap;\n-\n-use super::{Lint, LintId, EarlyLint, IntoEarlyLint};\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct LintTable {\n-    map: NodeMap<Vec<EarlyLint>>\n-}\n-\n-impl LintTable {\n-    pub fn new() -> Self {\n-        LintTable { map: NodeMap() }\n-    }\n-\n-    pub fn add_lint<S: Into<MultiSpan>>(&mut self,\n-                                        lint: &'static Lint,\n-                                        id: ast::NodeId,\n-                                        sp: S,\n-                                        msg: String)\n-    {\n-        self.add_lint_diagnostic(lint, id, (sp, &msg[..]))\n-    }\n-\n-    pub fn add_lint_diagnostic<M>(&mut self,\n-                                  lint: &'static Lint,\n-                                  id: ast::NodeId,\n-                                  msg: M)\n-        where M: IntoEarlyLint,\n-    {\n-        let lint_id = LintId::of(lint);\n-        let early_lint = msg.into_early_lint(lint_id);\n-        let arr = self.map.entry(id).or_insert(vec![]);\n-        if !arr.contains(&early_lint) {\n-            arr.push(early_lint);\n-        }\n-    }\n-\n-    pub fn get(&self, id: ast::NodeId) -> &[EarlyLint] {\n-        self.map.get(&id).map(|v| &v[..]).unwrap_or(&[])\n-    }\n-\n-    pub fn take(&mut self, id: ast::NodeId) -> Vec<EarlyLint> {\n-        self.map.remove(&id).unwrap_or(vec![])\n-    }\n-\n-    pub fn transfer(&mut self, into: &mut LintTable) {\n-        into.map.extend(self.map.drain());\n-    }\n-\n-    /// Returns the first (id, lint) pair that is non-empty. Used to\n-    /// implement a sanity check in lints that all node-ids are\n-    /// visited.\n-    pub fn get_any(&self) -> Option<(&ast::NodeId, &Vec<EarlyLint>)> {\n-        self.map.iter()\n-                .filter(|&(_, v)| !v.is_empty())\n-                .next()\n-    }\n-}\n-"}, {"sha": "4e08bc90c7c3a5064bf80005a566bfdbc26e3bcc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -17,11 +17,11 @@ use hir::{self, Item_, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n-use middle::privacy;\n-use ty::{self, TyCtxt};\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use lint;\n+use middle::privacy;\n+use ty::{self, TyCtxt};\n use util::nodemap::FxHashSet;\n \n use syntax::{ast, codemap};\n@@ -299,7 +299,9 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n+fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt,\n+                                    id: ast::NodeId,\n+                                    attrs: &[ast::Attribute]) -> bool {\n     if attr::contains_name(attrs, \"lang\") {\n         return true;\n     }\n@@ -315,14 +317,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n         return true;\n     }\n \n-    let dead_code = lint::builtin::DEAD_CODE.name_lower();\n-    for attr in lint::gather_attrs(attrs) {\n-        match attr {\n-            Ok((name, lint::Allow, _)) if name == &*dead_code => return true,\n-            _ => (),\n-        }\n-    }\n-    false\n+    tcx.lint_level_at_node(lint::builtin::DEAD_CODE, id).0 == lint::Allow\n }\n \n // This visitor seeds items that\n@@ -338,14 +333,17 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   or\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n-struct LifeSeeder<'k> {\n+struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<ast::NodeId>,\n     krate: &'k hir::Crate,\n+    tcx: TyCtxt<'k, 'tcx, 'tcx>,\n }\n \n-impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n+impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n+        let allow_dead_code = has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                               item.id,\n+                                                               &item.attrs);\n         if allow_dead_code {\n             self.worklist.push(item.id);\n         }\n@@ -360,7 +358,9 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                     match trait_item.node {\n                         hir::TraitItemKind::Const(_, Some(_)) |\n                         hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n-                            if has_allow_dead_code_or_lang_attr(&trait_item.attrs) {\n+                            if has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                                trait_item.id,\n+                                                                &trait_item.attrs) {\n                                 self.worklist.push(trait_item.id);\n                             }\n                         }\n@@ -372,7 +372,9 @@ impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n-                            has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n+                            has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                             impl_item.id,\n+                                                             &impl_item.attrs) {\n                         self.worklist.push(impl_item_ref.id.node_id);\n                     }\n                 }\n@@ -408,6 +410,7 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut life_seeder = LifeSeeder {\n         worklist,\n         krate,\n+        tcx,\n     };\n     krate.visit_all_item_likes(&mut life_seeder);\n \n@@ -472,17 +475,19 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         !field.is_positional()\n             && !self.symbol_is_live(field.id, None)\n             && !is_marker_field\n-            && !has_allow_dead_code_or_lang_attr(&field.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::Variant_) -> bool {\n         !self.symbol_is_live(variant.data.id(), None)\n-            && !has_allow_dead_code_or_lang_attr(&variant.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx,\n+                                                 variant.data.id(),\n+                                                 &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n         !self.symbol_is_live(fi.id, None)\n-            && !has_allow_dead_code_or_lang_attr(&fi.attrs)\n+            && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n     }\n \n     // id := node id of an item's definition.\n@@ -528,11 +533,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                       node_type: &str) {\n         if !name.as_str().starts_with(\"_\") {\n             self.tcx\n-                .sess\n-                .add_lint(lint::builtin::DEAD_CODE,\n-                          id,\n-                          span,\n-                          format!(\"{} is never used: `{}`\", node_type, name));\n+                .lint_node(lint::builtin::DEAD_CODE,\n+                           id,\n+                           span,\n+                           &format!(\"{} is never used: `{}`\", node_type, name));\n         }\n     }\n }"}, {"sha": "fcf366788b22394a1901ccbc2e54bfae531076fe", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -56,11 +56,11 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n         match self.unsafe_context.root {\n             SafeContext => {\n                 if is_lint {\n-                    self.tcx.sess.add_lint(lint::builtin::SAFE_EXTERN_STATICS,\n-                                           node_id,\n-                                           span,\n-                                           format!(\"{} requires unsafe function or \\\n-                                                    block (error E0133)\", description));\n+                    self.tcx.lint_node(lint::builtin::SAFE_EXTERN_STATICS,\n+                                       node_id,\n+                                       span,\n+                                       &format!(\"{} requires unsafe function or \\\n+                                                 block (error E0133)\", description));\n                 } else {\n                     // Report an error.\n                     struct_span_err!("}, {"sha": "a432e49dbaf0f05374c96f79eeb9dd81bc1e82c9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1487,12 +1487,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        format!(\"variable `{}` is assigned to, but never used\",\n-                                name));\n+                    self.ir.tcx.lint_node(lint::builtin::UNUSED_VARIABLES, id, sp,\n+                        &format!(\"variable `{}` is assigned to, but never used\",\n+                                 name));\n                 } else if name != \"self\" {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                        format!(\"unused variable: `{}`\", name));\n+                    self.ir.tcx.lint_node(lint::builtin::UNUSED_VARIABLES, id, sp,\n+                        &format!(\"unused variable: `{}`\", name));\n                 }\n             }\n             true\n@@ -1514,11 +1514,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn report_dead_assign(&self, id: NodeId, sp: Span, var: Variable, is_argument: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_argument {\n-                self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n-                    format!(\"value passed to `{}` is never read\", name));\n+                self.ir.tcx.lint_node(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n+                    &format!(\"value passed to `{}` is never read\", name));\n             } else {\n-                self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n-                    format!(\"value assigned to `{}` is never read\", name));\n+                self.ir.tcx.lint_node(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n+                    &format!(\"value assigned to `{}` is never read\", name));\n             }\n         }\n     }"}, {"sha": "5158c7e94af4c3025c1626cae5e91909fff1d599", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -493,7 +493,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"use of deprecated item\")\n             };\n \n-            self.sess.add_lint(lint::builtin::DEPRECATED, id, span, msg);\n+            self.lint_node(lint::builtin::DEPRECATED, id, span, &msg);\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n@@ -737,31 +737,31 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n-        sess.add_lint(lint::builtin::STABLE_FEATURES,\n+        tcx.lint_node(lint::builtin::STABLE_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,\n-                      format_stable_since_msg(version));\n+                      &format_stable_since_msg(version));\n     }\n \n     let index = tcx.stability.borrow();\n     for (used_lib_feature, level) in &index.used_features {\n         match remaining_lib_features.remove(used_lib_feature) {\n             Some(span) => {\n                 if let &attr::StabilityLevel::Stable { since: ref version } = level {\n-                    sess.add_lint(lint::builtin::STABLE_FEATURES,\n+                    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n                                   ast::CRATE_NODE_ID,\n                                   span,\n-                                  format_stable_since_msg(&version.as_str()));\n+                                  &format_stable_since_msg(&version.as_str()));\n                 }\n             }\n             None => ( /* used but undeclared, handled during the previous ast visit */ )\n         }\n     }\n \n     for &span in remaining_lib_features.values() {\n-        sess.add_lint(lint::builtin::UNUSED_FEATURES,\n+        tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n                       ast::CRATE_NODE_ID,\n                       span,\n-                      \"unused or unknown feature\".to_string());\n+                      \"unused or unknown feature\");\n     }\n }"}, {"sha": "be39f95b98899b788a115303386b14d5d81b7746", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -79,7 +79,7 @@ pub struct Session {\n     // if the value stored here has been affected by path remapping.\n     pub working_dir: (String, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n-    pub lints: RefCell<lint::LintTable>,\n+    pub buffered_lints: RefCell<Option<lint::LintBuffer>>,\n     /// Set of (LintId, Option<Span>, message) tuples tracking lint\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690).\n@@ -307,22 +307,15 @@ impl Session {\n         self.diagnostic().unimpl(msg)\n     }\n \n-    pub fn add_lint<S: Into<MultiSpan>>(&self,\n-                                        lint: &'static lint::Lint,\n-                                        id: ast::NodeId,\n-                                        sp: S,\n-                                        msg: String)\n-    {\n-        self.lints.borrow_mut().add_lint(lint, id, sp, msg);\n-    }\n-\n-    pub fn add_lint_diagnostic<M>(&self,\n-                                  lint: &'static lint::Lint,\n-                                  id: ast::NodeId,\n-                                  msg: M)\n-        where M: lint::IntoEarlyLint,\n-    {\n-        self.lints.borrow_mut().add_lint_diagnostic(lint, id, msg);\n+    pub fn buffer_lint<S: Into<MultiSpan>>(&self,\n+                                           lint: &'static lint::Lint,\n+                                           id: ast::NodeId,\n+                                           sp: S,\n+                                           msg: &str) {\n+        match *self.buffered_lints.borrow_mut() {\n+            Some(ref mut buffer) => buffer.add_lint(lint, id, sp.into(), msg),\n+            None => bug!(\"can't buffer lints after HIR lowering\"),\n+        }\n     }\n \n     pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n@@ -708,7 +701,7 @@ pub fn build_session_(sopts: config::Options,\n         local_crate_source_file,\n         working_dir,\n         lint_store: RefCell::new(lint::LintStore::new()),\n-        lints: RefCell::new(lint::LintTable::new()),\n+        buffered_lints: RefCell::new(Some(lint::LintBuffer::new())),\n         one_time_diagnostics: RefCell::new(FxHashSet()),\n         plugin_llvm_passes: RefCell::new(Vec::new()),\n         plugin_attributes: RefCell::new(Vec::new()),"}, {"sha": "e4042c48bf332e612c8d8540270cd06c10e3c7d7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -279,8 +279,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let mut self_match_impls = vec![];\n         let mut fuzzy_match_impls = vec![];\n \n-        self.tcx.trait_def(trait_ref.def_id)\n-            .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n+        self.tcx.for_each_relevant_impl(\n+            trait_ref.def_id, trait_self_ty, |def_id| {\n                 let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n@@ -397,10 +397,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                               trait_ref.skip_binder().self_ty(),\n                                               true);\n         let mut impl_candidates = Vec::new();\n-        let trait_def = self.tcx.trait_def(trait_ref.def_id());\n \n         match simp {\n-            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+            Some(simp) => self.tcx.for_each_impl(trait_ref.def_id(), |def_id| {\n                 let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let imp_simp = fast_reject::simplify_type(self.tcx,\n                                                           imp.self_ty(),\n@@ -412,7 +411,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 impl_candidates.push(imp);\n             }),\n-            None => trait_def.for_each_impl(self.tcx, |def_id| {\n+            None => self.tcx.for_each_impl(trait_ref.def_id(), |def_id| {\n                 impl_candidates.push(\n                     self.tcx.impl_trait_ref(def_id).unwrap());\n             })\n@@ -501,11 +500,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // weird effect -- the diagnostic is reported as a lint, and\n         // the builder which is returned is marked as canceled.\n \n-        let mut err =\n-            struct_span_err!(self.tcx.sess,\n-                             error_span,\n-                             E0276,\n-                             \"impl has stricter requirements than trait\");\n+        let msg = \"impl has stricter requirements than trait\";\n+        let mut err = match lint_id {\n+            Some(node_id) => {\n+                self.tcx.struct_span_lint_node(EXTRA_REQUIREMENT_IN_IMPL,\n+                                               node_id,\n+                                               error_span,\n+                                               msg)\n+            }\n+            None => {\n+                struct_span_err!(self.tcx.sess,\n+                                 error_span,\n+                                 E0276,\n+                                 \"{}\", msg)\n+            }\n+        };\n \n         if let Some(trait_item_span) = self.tcx.hir.span_if_local(trait_item_def_id) {\n             let span = self.tcx.sess.codemap().def_span(trait_item_span);\n@@ -516,13 +525,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             error_span,\n             format!(\"impl has extra requirement {}\", requirement));\n \n-        if let Some(node_id) = lint_id {\n-            self.tcx.sess.add_lint_diagnostic(EXTRA_REQUIREMENT_IN_IMPL,\n-                                              node_id,\n-                                              (*err).clone());\n-            err.cancel();\n-        }\n-\n         err\n     }\n "}, {"sha": "67c7ecda6490ebab31eae82710bcabc33ea5c23d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -572,7 +572,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n {\n     debug!(\"fully_normalize(value={:?})\", value);\n \n-    let mut selcx = &mut SelectionContext::new(infcx);\n+    let selcx = &mut SelectionContext::new(infcx);\n     // FIXME (@jroesch) ISSUE 26721\n     // I'm not sure if this is a bug or not, needs further investigation.\n     // It appears that by reusing the fulfillment_cx here we incur more"}, {"sha": "2e2daeb984591071f44e5ece85edacf053a008b8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -504,7 +504,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             never_obligation.predicate = never_obligation.predicate.map_bound(|mut trait_pred| {\n                 // Swap out () with ! so we can check if the trait is impld for !\n                 {\n-                    let mut trait_ref = &mut trait_pred.trait_ref;\n+                    let trait_ref = &mut trait_pred.trait_ref;\n                     let unit_substs = trait_ref.substs;\n                     let mut never_substs = Vec::with_capacity(unit_substs.len());\n                     never_substs.push(From::from(tcx.types.never));\n@@ -522,11 +522,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             if raise_warning {\n-                tcx.sess.add_lint(lint::builtin::RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n-                                  obligation.cause.body_id,\n-                                  obligation.cause.span,\n-                                  format!(\"code relies on type inference rules which are likely \\\n-                                           to change\"));\n+                tcx.lint_node(lint::builtin::RESOLVE_TRAIT_ON_DEFAULTED_UNIT,\n+                              obligation.cause.body_id,\n+                              obligation.cause.span,\n+                              &format!(\"code relies on type inference rules which are likely \\\n+                                        to change\"));\n             }\n         }\n         Ok(ret)\n@@ -1619,10 +1619,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={:?})\", obligation);\n \n-        let def = self.tcx().trait_def(obligation.predicate.def_id());\n-\n-        def.for_each_relevant_impl(\n-            self.tcx(),\n+        self.tcx().for_each_relevant_impl(\n+            obligation.predicate.def_id(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n                 self.probe(|this, snapshot| { /* [1] */"}, {"sha": "7c916e162a4fffcaef56ef60a2fa21074737dc61", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -300,7 +300,8 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                                       -> Rc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n-    let mut trait_impls: Vec<DefId> = tcx.trait_impls_of(trait_id).iter().collect();\n+    let mut trait_impls = Vec::new();\n+    tcx.for_each_impl(trait_id, |impl_did| trait_impls.push(impl_did));\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by"}, {"sha": "c2c52e5fa21b6be2eb28e0a107190cb52e5c3612", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,14 +11,15 @@\n //! type context book-keeping\n \n use dep_graph::DepGraph;\n+use errors::DiagnosticBuilder;\n use session::Session;\n-use lint;\n use middle;\n use hir::TraitMap;\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n+use lint::{self, Lint};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -58,6 +59,7 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n+use syntax::codemap::MultiSpan;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n@@ -258,9 +260,6 @@ pub struct TypeckTables<'tcx> {\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: NodeMap<ty::cast::CastKind>,\n \n-    /// Lints for the body of this fn generated by typeck.\n-    pub lints: lint::LintTable,\n-\n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n     pub used_trait_imports: DefIdSet,\n@@ -291,7 +290,6 @@ impl<'tcx> TypeckTables<'tcx> {\n             liberated_fn_sigs: NodeMap(),\n             fru_field_types: NodeMap(),\n             cast_kinds: NodeMap(),\n-            lints: lint::LintTable::new(),\n             used_trait_imports: DefIdSet(),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n@@ -1529,6 +1527,59 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.mk_substs(iter::once(s).chain(t.into_iter().cloned()).map(Kind::from))\n     }\n+\n+    pub fn lint_node<S: Into<MultiSpan>>(self,\n+                                         lint: &'static Lint,\n+                                         id: NodeId,\n+                                         span: S,\n+                                         msg: &str) {\n+        self.struct_span_lint_node(lint, id, span.into(), msg).emit()\n+    }\n+\n+    pub fn lint_level_at_node(self, lint: &'static Lint, mut id: NodeId)\n+        -> (lint::Level, lint::LintSource)\n+    {\n+        // Right now we insert a `with_ignore` node in the dep graph here to\n+        // ignore the fact that `lint_levels` below depends on the entire crate.\n+        // For now this'll prevent false positives of recompiling too much when\n+        // anything changes.\n+        //\n+        // Once red/green incremental compilation lands we should be able to\n+        // remove this because while the crate changes often the lint level map\n+        // will change rarely.\n+        self.dep_graph.with_ignore(|| {\n+            let sets = self.lint_levels(LOCAL_CRATE);\n+            loop {\n+                let hir_id = self.hir.definitions().node_to_hir_id(id);\n+                if let Some(pair) = sets.level_and_source(lint, hir_id) {\n+                    return pair\n+                }\n+                let next = self.hir.get_parent_node(id);\n+                if next == id {\n+                    bug!(\"lint traversal reached the root of the crate\");\n+                }\n+                id = next;\n+            }\n+        })\n+    }\n+\n+    pub fn struct_span_lint_node<S: Into<MultiSpan>>(self,\n+                                                     lint: &'static Lint,\n+                                                     id: NodeId,\n+                                                     span: S,\n+                                                     msg: &str)\n+        -> DiagnosticBuilder<'tcx>\n+    {\n+        let (level, src) = self.lint_level_at_node(lint, id);\n+        lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+    }\n+\n+    pub fn struct_lint_node(self, lint: &'static Lint, id: NodeId, msg: &str)\n+        -> DiagnosticBuilder<'tcx>\n+    {\n+        let (level, src) = self.lint_level_at_node(lint, id);\n+        lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n+    }\n }\n \n pub trait InternAs<T: ?Sized, R> {"}, {"sha": "900197f3dbd17c0756ebcf3c410e921270924ff0", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         match self.sty {\n             TyAdt(def, substs) => {\n                 {\n-                    let mut substs_set = visited.entry(def.did).or_insert(FxHashSet::default());\n+                    let substs_set = visited.entry(def.did).or_insert(FxHashSet::default());\n                     if !substs_set.insert(substs) {\n                         // We are already calculating the inhabitedness of this type.\n                         // The type must contain a reference to itself. Break the\n@@ -193,7 +193,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                     }\n                 }\n                 let ret = def.uninhabited_from(visited, tcx, substs);\n-                let mut substs_set = visited.get_mut(&def.did).unwrap();\n+                let substs_set = visited.get_mut(&def.did).unwrap();\n                 substs_set.remove(substs);\n                 ret\n             },"}, {"sha": "b121c05f244fdd2ae8a53e5515dfb161d3a4c365", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -12,6 +12,7 @@ use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n+use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference};\n use middle::privacy::AccessLevels;\n@@ -470,12 +471,6 @@ impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::relevant_trait_impls_for<'tcx> {\n-    fn describe(tcx: TyCtxt, (def_id, ty): (DefId, SimplifiedType)) -> String {\n-        format!(\"relevant impls for: `({}, {:?})`\", tcx.item_path_str(def_id), ty)\n-    }\n-}\n-\n impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n@@ -512,6 +507,12 @@ impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the lint levels for items in this crate\")\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -977,10 +978,7 @@ define_maps! { <'tcx>\n     [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] is_mir_available: IsMirAvailable(DefId) -> bool,\n \n-    [] trait_impls_of: TraitImpls(DefId) -> ty::trait_def::TraitImpls,\n-    // Note that TraitDef::for_each_relevant_impl() will do type simplication for you.\n-    [] relevant_trait_impls_for: relevant_trait_impls_for((DefId, SimplifiedType))\n-        -> ty::trait_def::TraitImpls,\n+    [] trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n     [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n     [] is_object_safe: ObjectSafety(DefId) -> bool,\n \n@@ -1008,6 +1006,8 @@ define_maps! { <'tcx>\n     [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n \n     [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+\n+    [] lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1060,10 +1060,6 @@ fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::CrateVariances\n }\n \n-fn relevant_trait_impls_for<'tcx>((def_id, t): (DefId, SimplifiedType)) -> DepConstructor<'tcx> {\n-    DepConstructor::RelevantTraitImpls(def_id, t)\n-}\n-\n fn is_copy_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     DepConstructor::IsCopy\n }\n@@ -1083,3 +1079,7 @@ fn needs_drop_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstruct\n fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n     DepConstructor::Layout\n }\n+\n+fn lint_levels<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::LintLevels\n+}"}, {"sha": "b5aea7e33d61fa7935827a1126691d69a1f02bf0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -494,6 +494,7 @@ impl<'tcx> TyS<'tcx> {\n             TypeVariants::TyFnPtr(..) |\n             TypeVariants::TyDynamic(..) |\n             TypeVariants::TyClosure(..) |\n+            TypeVariants::TyInfer(..) |\n             TypeVariants::TyProjection(..) => false,\n             _ => true,\n         }\n@@ -2515,7 +2516,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         param_env,\n         trait_of_item,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n-        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }\n@@ -2525,7 +2525,6 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n         adt_sized_constraint,\n         adt_dtorck_constraint,\n         trait_impls_of: trait_def::trait_impls_of_provider,\n-        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         param_env,\n         ..*providers\n     };"}, {"sha": "9990472c6b4caa60eb52ff8019f4a42ae2141326", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 64, "deletions": 104, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir;\n use hir::def_id::DefId;\n use hir::map::DefPathHash;\n use traits::specialization_graph;\n use ty::fast_reject;\n use ty::fold::TypeFoldable;\n use ty::{Ty, TyCtxt};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n use std::rc::Rc;\n-use hir;\n \n /// A trait's definition with type information.\n pub struct TraitDef {\n@@ -36,60 +39,12 @@ pub struct TraitDef {\n     pub def_path_hash: DefPathHash,\n }\n \n-// We don't store the list of impls in a flat list because each cached list of\n-// `relevant_impls_for` we would then duplicate all blanket impls. By keeping\n-// blanket and non-blanket impls separate, we can share the list of blanket\n-// impls.\n-#[derive(Clone)]\n pub struct TraitImpls {\n-    blanket_impls: Rc<Vec<DefId>>,\n-    non_blanket_impls: Rc<Vec<DefId>>,\n+    blanket_impls: Vec<DefId>,\n+    /// Impls indexed by their simplified self-type, for fast lookup.\n+    non_blanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n }\n \n-impl TraitImpls {\n-    pub fn iter(&self) -> TraitImplsIter {\n-        TraitImplsIter {\n-            blanket_impls: self.blanket_impls.clone(),\n-            non_blanket_impls: self.non_blanket_impls.clone(),\n-            index: 0\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct TraitImplsIter {\n-    blanket_impls: Rc<Vec<DefId>>,\n-    non_blanket_impls: Rc<Vec<DefId>>,\n-    index: usize,\n-}\n-\n-impl Iterator for TraitImplsIter {\n-    type Item = DefId;\n-\n-    fn next(&mut self) -> Option<DefId> {\n-        if self.index < self.blanket_impls.len() {\n-            let bi_index = self.index;\n-            self.index += 1;\n-            Some(self.blanket_impls[bi_index])\n-        } else {\n-            let nbi_index = self.index - self.blanket_impls.len();\n-            if nbi_index < self.non_blanket_impls.len() {\n-                self.index += 1;\n-                Some(self.non_blanket_impls[nbi_index])\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let items_left = (self.blanket_impls.len() + self.non_blanket_impls.len()) - self.index;\n-        (items_left, Some(items_left))\n-    }\n-}\n-\n-impl ExactSizeIterator for TraitImplsIter {}\n-\n impl<'a, 'gcx, 'tcx> TraitDef {\n     pub fn new(def_id: DefId,\n                unsafety: hir::Unsafety,\n@@ -111,20 +66,36 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                      -> specialization_graph::Ancestors {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n+}\n \n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n-        for impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn for_each_impl<F: FnMut(DefId)>(self, def_id: DefId, mut f: F) {\n+        let impls = self.trait_impls_of(def_id);\n+\n+        for &impl_def_id in impls.blanket_impls.iter() {\n             f(impl_def_id);\n         }\n+\n+        for v in impls.non_blanket_impls.values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n     }\n \n     /// Iterate over every impl that could possibly match the\n     /// self-type `self_ty`.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(self,\n+                                                   def_id: DefId,\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {\n+        let impls = self.trait_impls_of(def_id);\n+\n+        for &impl_def_id in impls.blanket_impls.iter() {\n+            f(impl_def_id);\n+        }\n+\n         // simplify_type(.., false) basically replaces type parameters and\n         // projections with infer-variables. This is, of course, done on\n         // the impl trait-ref when it is instantiated, but not on the\n@@ -137,23 +108,39 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         // replace `S` with anything - this impl of course can't be\n         // selected, and as there are hundreds of similar impls,\n         // considering them would significantly harm performance.\n-        let relevant_impls = if let Some(simplified_self_ty) =\n-                fast_reject::simplify_type(tcx, self_ty, true) {\n-            tcx.relevant_trait_impls_for((self.def_id, simplified_self_ty))\n-        } else {\n-            tcx.trait_impls_of(self.def_id)\n-        };\n \n-        for impl_def_id in relevant_impls.iter() {\n-            f(impl_def_id);\n+        // This depends on the set of all impls for the trait. That is\n+        // unfortunate. When we get red-green recompilation, we would like\n+        // to have a way of knowing whether the set of relevant impls\n+        // changed. The most naive\n+        // way would be to compute the Vec of relevant impls and see whether\n+        // it differs between compilations. That shouldn't be too slow by\n+        // itself - we do quite a bit of work for each relevant impl anyway.\n+        //\n+        // If we want to be faster, we could have separate queries for\n+        // blanket and non-blanket impls, and compare them separately.\n+        //\n+        // I think we'll cross that bridge when we get to it.\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, true) {\n+            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n+                }\n+            }\n+        } else {\n+            for v in impls.non_blanket_impls.values() {\n+                for &impl_def_id in v {\n+                    f(impl_def_id);\n+                }\n+            }\n         }\n     }\n }\n \n // Query provider for `trait_impls_of`.\n pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_id: DefId)\n-                                                -> TraitImpls {\n+                                                -> Rc<TraitImpls> {\n     let remote_impls = if trait_id.is_local() {\n         // Traits defined in the current crate can't have impls in upstream\n         // crates, so we don't bother querying the cstore.\n@@ -163,7 +150,7 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let mut blanket_impls = Vec::new();\n-    let mut non_blanket_impls = Vec::new();\n+    let mut non_blanket_impls = FxHashMap();\n \n     let local_impls = tcx.hir\n                          .trait_impls(trait_id)\n@@ -176,47 +163,20 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             continue\n         }\n \n-        if fast_reject::simplify_type(tcx, impl_self_ty, false).is_some() {\n-            non_blanket_impls.push(impl_def_id);\n+        if let Some(simplified_self_ty) =\n+            fast_reject::simplify_type(tcx, impl_self_ty, false)\n+        {\n+            non_blanket_impls\n+                .entry(simplified_self_ty)\n+                .or_insert(vec![])\n+                .push(impl_def_id);\n         } else {\n             blanket_impls.push(impl_def_id);\n         }\n     }\n \n-    TraitImpls {\n-        blanket_impls: Rc::new(blanket_impls),\n-        non_blanket_impls: Rc::new(non_blanket_impls),\n-    }\n-}\n-\n-// Query provider for `relevant_trait_impls_for`.\n-pub(super) fn relevant_trait_impls_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    (trait_id, self_ty): (DefId, fast_reject::SimplifiedType))\n-    -> TraitImpls\n-{\n-    let all_trait_impls = tcx.trait_impls_of(trait_id);\n-\n-    let relevant: Vec<DefId> = all_trait_impls\n-        .non_blanket_impls\n-        .iter()\n-        .cloned()\n-        .filter(|&impl_def_id| {\n-            let impl_self_ty = tcx.type_of(impl_def_id);\n-            let impl_simple_self_ty = fast_reject::simplify_type(tcx,\n-                                                                 impl_self_ty,\n-                                                                 false).unwrap();\n-            impl_simple_self_ty == self_ty\n-        })\n-        .collect();\n-\n-    if all_trait_impls.non_blanket_impls.len() == relevant.len() {\n-        // If we didn't filter anything out, re-use the existing vec.\n-        all_trait_impls\n-    } else {\n-        TraitImpls {\n-            blanket_impls: all_trait_impls.blanket_impls.clone(),\n-            non_blanket_impls: Rc::new(relevant),\n-        }\n-    }\n+    Rc::new(TraitImpls {\n+        blanket_impls: blanket_impls,\n+        non_blanket_impls: non_blanket_impls,\n+    })\n }"}, {"sha": "2d29a288a260831e780c4eb7b4d1d9a0c37e6463", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n-        self.trait_def(drop_trait).for_each_relevant_impl(self, ty, |impl_did| {\n+        self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n             if let Some(item) = self.associated_items(impl_did).next() {\n                 if let Ok(()) = validate(self, impl_did) {\n                     dtor_did = Some(item.def_id);"}, {"sha": "676c3c51ea2a3d3aca2d09ec8599c32e48c1a646", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -188,7 +188,7 @@ impl<'a> AllocFnFactory<'a> {\n     fn arg_ty(&self,\n               ty: &AllocatorTy,\n               args: &mut Vec<Arg>,\n-              mut ident: &mut FnMut() -> Ident) -> P<Expr> {\n+              ident: &mut FnMut() -> Ident) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {\n                 let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n@@ -263,7 +263,7 @@ impl<'a> AllocFnFactory<'a> {\n     fn ret_ty(&self,\n               ty: &AllocatorTy,\n               args: &mut Vec<Arg>,\n-              mut ident: &mut FnMut() -> Ident,\n+              ident: &mut FnMut() -> Ident,\n               expr: P<Expr>) -> (P<Ty>, P<Expr>)\n     {\n         match *ty {"}, {"sha": "ec88bcf9c79c348713a5928d78ea36c3b0caa6d5", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -434,20 +434,40 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! For mutable loans of content whose mutability derives\n         //! from a local variable, mark the mutability decl as necessary.\n \n-        match loan_path.kind {\n-            LpVar(local_id) |\n-            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n-                self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n-            }\n-            LpDowncast(ref base, _) |\n-            LpExtend(ref base, mc::McInherited, _) |\n-            LpExtend(ref base, mc::McDeclared, _) => {\n-                self.mark_loan_path_as_mutated(&base);\n-            }\n-            LpExtend(_, mc::McImmutable, _) => {\n-                // Nothing to do.\n+        let mut wrapped_path = Some(loan_path);\n+        let mut through_borrow = false;\n+\n+        while let Some(current_path) = wrapped_path {\n+            wrapped_path = match current_path.kind {\n+                LpVar(local_id) => {\n+                    if !through_borrow {\n+                        self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                    }\n+                    None\n+                }\n+                LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n+                    self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n+                    None\n+                }\n+                LpExtend(ref base, mc::McInherited, LpDeref(pointer_kind)) |\n+                LpExtend(ref base, mc::McDeclared, LpDeref(pointer_kind)) => {\n+                    if pointer_kind != mc::Unique {\n+                        through_borrow = true;\n+                    }\n+                    Some(base)\n+                }\n+                LpDowncast(ref base, _) |\n+                LpExtend(ref base, mc::McInherited, _) |\n+                LpExtend(ref base, mc::McDeclared, _) => {\n+                    Some(base)\n+                }\n+                LpExtend(_, mc::McImmutable, _) => {\n+                    // Nothing to do.\n+                    None\n+                }\n             }\n         }\n+\n     }\n \n     pub fn compute_gen_scope(&self,"}, {"sha": "41771738ac623d968c395694becf61df254dd952", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -99,7 +99,7 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_maps = tcx.region_maps(owner_def_id);\n     let body = tcx.hir.body(body_id);\n-    let mut bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n+    let bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n \n     // Eventually, borrowck will always read the MIR, but at the\n     // moment we do not. So, for now, we always force MIR to be"}, {"sha": "a3f8aae472cae39e1d88465f0caeac5f74d73d15", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -23,7 +23,7 @@ use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::lint;\n-use rustc_errors::{Diagnostic, Level, DiagnosticBuilder};\n+use rustc_errors::DiagnosticBuilder;\n \n use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n@@ -351,12 +351,10 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             match arm_index {\n                                 // The arm with the user-specified pattern.\n                                 0 => {\n-                                    let mut diagnostic = Diagnostic::new(Level::Warning,\n-                                                                         \"unreachable pattern\");\n-                                    diagnostic.set_span(pat.span);\n-                                    cx.tcx.sess.add_lint_diagnostic(\n+                                    cx.tcx.lint_node(\n                                             lint::builtin::UNREACHABLE_PATTERNS,\n-                                            hir_pat.id, diagnostic);\n+                                        hir_pat.id, pat.span,\n+                                        \"unreachable pattern\");\n                                 },\n                                 // The arm with the wildcard pattern.\n                                 1 => {\n@@ -371,16 +369,18 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n                         hir::MatchSource::ForLoopDesugar |\n                         hir::MatchSource::Normal => {\n-                            let mut diagnostic = Diagnostic::new(Level::Warning,\n-                                                                 \"unreachable pattern\");\n-                            diagnostic.set_span(pat.span);\n+                            let mut err = cx.tcx.struct_span_lint_node(\n+                                lint::builtin::UNREACHABLE_PATTERNS,\n+                                hir_pat.id,\n+                                pat.span,\n+                                \"unreachable pattern\",\n+                            );\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n-                                diagnostic.span_label(pat.span, \"this is an unreachable pattern\");\n-                                diagnostic.span_note(catchall, \"this pattern matches any value\");\n+                                err.span_label(pat.span, \"this is an unreachable pattern\");\n+                                err.span_note(catchall, \"this pattern matches any value\");\n                             }\n-                            cx.tcx.sess.add_lint_diagnostic(lint::builtin::UNREACHABLE_PATTERNS,\n-                                                            hir_pat.id, diagnostic);\n+                            err.emit();\n                         },\n \n                         // Unreachable patterns in try expressions occur when one of the arms"}, {"sha": "df660d08603adfa1cc2fb31a82d63299d1540902", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -260,7 +260,7 @@ impl<'a, A: Array> Drop for Drain<'a, A> {\n                 let start = source_array_vec.len();\n                 let tail = self.tail_start;\n                 {\n-                    let mut arr = &mut source_array_vec.values as &mut [ManuallyDrop<_>];\n+                    let arr = &mut source_array_vec.values as &mut [ManuallyDrop<_>];\n                     let src = arr.as_ptr().offset(tail as isize);\n                     let dst = arr.as_mut_ptr().offset(start as isize);\n                     ptr::copy(src, dst, self.tail_len);"}, {"sha": "7fc59be780f6e565983e870d3cee6a09c186d21e", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -166,7 +166,7 @@ impl BitMatrix {\n     pub fn add(&mut self, source: usize, target: usize) -> bool {\n         let (start, _) = self.range(source);\n         let (word, mask) = word_mask(target);\n-        let mut vector = &mut self.vector[..];\n+        let vector = &mut self.vector[..];\n         let v1 = vector[start + word];\n         let v2 = v1 | mask;\n         vector[start + word] = v2;"}, {"sha": "42f56aa078276c101d66a15a7fd44435a2485a70", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -259,7 +259,7 @@ impl<'a, I: Idx, T> IntoIterator for &'a mut IndexVec<I, T> {\n     type IntoIter = slice::IterMut<'a, T>;\n \n     #[inline]\n-    fn into_iter(mut self) -> slice::IterMut<'a, T> {\n+    fn into_iter(self) -> slice::IterMut<'a, T> {\n         self.raw.iter_mut()\n     }\n }"}, {"sha": "e331d6c6ae05ae60ac2e3235597c616cf5aa9002", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -89,7 +89,7 @@ pub fn compile_input(sess: &Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans) = {\n-        let krate = match phase_1_parse_input(sess, input) {\n+        let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n                 parse_error.emit();\n@@ -296,9 +296,13 @@ pub struct CompileController<'a> {\n     pub after_llvm: PhaseController<'a>,\n     pub compilation_done: PhaseController<'a>,\n \n+    // FIXME we probably want to group the below options together and offer a\n+    // better API, rather than this ad-hoc approach.\n     pub make_glob_map: MakeGlobMap,\n     // Whether the compiler should keep the ast beyond parsing.\n     pub keep_ast: bool,\n+    // -Zcontinue-parse-after-error\n+    pub continue_parse_after_error: bool,\n }\n \n impl<'a> CompileController<'a> {\n@@ -312,6 +316,7 @@ impl<'a> CompileController<'a> {\n             compilation_done: PhaseController::basic(),\n             make_glob_map: MakeGlobMap::No,\n             keep_ast: false,\n+            continue_parse_after_error: false,\n         }\n     }\n }\n@@ -484,20 +489,22 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n     }\n \n     fn state_when_compilation_done(input: &'a Input,\n-                                    session: &'tcx Session,\n-                                    out_dir: &'a Option<PathBuf>,\n-                                    out_file: &'a Option<PathBuf>)\n-                                    -> Self {\n+                                   session: &'tcx Session,\n+                                   out_dir: &'a Option<PathBuf>,\n+                                   out_file: &'a Option<PathBuf>)\n+                                   -> Self {\n         CompileState {\n             out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n }\n \n-pub fn phase_1_parse_input<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n-    let continue_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n-    sess.diagnostic().set_continue_after_error(continue_after_error);\n+pub fn phase_1_parse_input<'a>(control: &CompileController,\n+                               sess: &'a Session,\n+                               input: &Input)\n+                               -> PResult<'a, ast::Crate> {\n+    sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n \n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n@@ -638,7 +645,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         super::describe_lints(&sess.lint_store.borrow(), true);\n         return Err(CompileIncomplete::Stopped);\n     }\n-    sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n     // Currently, we ignore the name resolution data structures for the purposes of dependency\n     // tracking. Instead we will run name resolution and include its output in the hash of each\n@@ -708,8 +714,8 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         missing_fragment_specifiers.sort();\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n-            let msg = \"missing fragment specifier\".to_string();\n-            sess.add_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+            let msg = \"missing fragment specifier\";\n+            sess.buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n         }\n         if ecx.parse_sess.span_diagnostic.err_count() - ecx.resolve_err_count > err_count {\n             ecx.parse_sess.span_diagnostic.abort_if_errors();\n@@ -772,10 +778,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));\n \n-    time(time_passes,\n-         \"early lint checks\",\n-         || lint::check_ast_crate(sess, &krate));\n-\n     time(time_passes,\n          \"AST validation\",\n          || ast_validation::check_crate(sess, &krate));\n@@ -800,6 +802,10 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         })\n     })?;\n \n+    time(time_passes,\n+         \"early lint checks\",\n+         || lint::check_ast_crate(sess, &krate));\n+\n     // Lower ast -> hir.\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);\n@@ -908,6 +914,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     rustc_const_eval::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n     cstore::provide_local(&mut local_providers);\n+    lint::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n@@ -1198,10 +1205,10 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                          }\n                          Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n                          Some(_) => {\n-                             session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                              ast::CRATE_NODE_ID,\n-                                              a.span,\n-                                              \"invalid `crate_type` value\".to_string());\n+                             session.buffer_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n+                                                 ast::CRATE_NODE_ID,\n+                                                 a.span,\n+                                                 \"invalid `crate_type` value\");\n                              None\n                          }\n                          _ => {"}, {"sha": "6f0a50180d794b5de9f413f4306109d6e7bfea6f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -422,7 +422,7 @@ fn show_content_with_pager(content: &String) {\n \n     match Command::new(pager_name).stdin(Stdio::piped()).spawn() {\n         Ok(mut pager) => {\n-            if let Some(mut pipe) = pager.stdin.as_mut() {\n+            if let Some(pipe) = pager.stdin.as_mut() {\n                 if pipe.write_all(content.as_bytes()).is_err() {\n                     fallback_to_println = true;\n                 }\n@@ -518,7 +518,8 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                         -> CompileController<'a> {\n         let mut control = CompileController::basic();\n \n-        control.keep_ast = sess.opts.debugging_opts.keep_ast || save_analysis(sess);\n+        control.keep_ast = sess.opts.debugging_opts.keep_ast;\n+        control.continue_parse_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n \n         if let Some((ppm, opt_uii)) = parse_pretty(sess, matches) {\n             if ppm.needs_ast_map(&opt_uii) {\n@@ -574,19 +575,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         }\n \n         if save_analysis(sess) {\n-            control.after_analysis.callback = box |state| {\n-                time(state.session.time_passes(), \"save analysis\", || {\n-                    save::process_crate(state.tcx.unwrap(),\n-                                        state.expanded_crate.unwrap(),\n-                                        state.analysis.unwrap(),\n-                                        state.crate_name.unwrap(),\n-                                        None,\n-                                        DumpHandler::new(state.out_dir,\n-                                                         state.crate_name.unwrap()))\n-                });\n-            };\n-            control.after_analysis.run_callback_on_error = true;\n-            control.make_glob_map = resolve::MakeGlobMap::Yes;\n+            enable_save_analysis(&mut control);\n         }\n \n         if sess.print_fuel_crate.is_some() {\n@@ -603,6 +592,23 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     }\n }\n \n+pub fn enable_save_analysis(control: &mut CompileController) {\n+    control.keep_ast = true;\n+    control.after_analysis.callback = box |state| {\n+        time(state.session.time_passes(), \"save analysis\", || {\n+            save::process_crate(state.tcx.unwrap(),\n+                                state.expanded_crate.unwrap(),\n+                                state.analysis.unwrap(),\n+                                state.crate_name.unwrap(),\n+                                None,\n+                                DumpHandler::new(state.out_dir,\n+                                                 state.crate_name.unwrap()))\n+        });\n+    };\n+    control.after_analysis.run_callback_on_error = true;\n+    control.make_glob_map = resolve::MakeGlobMap::Yes;\n+}\n+\n fn save_analysis(sess: &Session) -> bool {\n     sess.opts.debugging_opts.save_analysis\n }\n@@ -1215,7 +1221,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     Registry::new(&all_errors)\n }\n \n-fn get_args() -> Vec<String> {\n+pub fn get_args() -> Vec<String> {\n     env::args_os().enumerate()\n         .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n              early_error(ErrorOutputType::default(),"}, {"sha": "8668ab301543b6aa3826190472437f030e51ce0c", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -119,7 +119,9 @@ fn test_env<F>(source_string: &str,\n         name: driver::anon_src(),\n         input: source_string.to_string(),\n     };\n-    let krate = driver::phase_1_parse_input(&sess, &input).unwrap();\n+    let krate = driver::phase_1_parse_input(&driver::CompileController::basic(),\n+                                            &sess,\n+                                            &input).unwrap();\n     let driver::ExpansionResult { defs, resolutions, mut hir_forest, .. } = {\n         driver::phase_2_configure_and_expand(&sess,\n                                              &cstore,"}, {"sha": "88432e64290316a85ef0bf6b35398fcea7feda13", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -36,7 +36,7 @@ use rustc::ty::{self, Ty};\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n-use lint::{Level, LateContext, LintContext, LintArray};\n+use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n \n use std::collections::HashSet;\n@@ -542,9 +542,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let debug_def = cx.tcx.trait_def(debug);\n             let mut impls = NodeSet();\n-            debug_def.for_each_impl(cx.tcx, |d| {\n+            cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_to_def_id() {\n                     if let Some(node_id) = cx.tcx.hir.as_local_node_id(ty_def) {\n                         impls.insert(node_id);\n@@ -877,16 +876,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n                                              sp,\n                                              \"function cannot return without recurring\");\n-\n             // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n-            if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n-                // offer some help to the programmer.\n-                for call in &self_call_spans {\n-                    db.span_note(*call, \"recursive call site\");\n-                }\n-                db.help(\"a `loop` may express intention \\\n-                         better if this is on purpose\");\n+            // offer some help to the programmer.\n+            for call in &self_call_spans {\n+                db.span_note(*call, \"recursive call site\");\n             }\n+            db.help(\"a `loop` may express intention \\\n+                     better if this is on purpose\");\n             db.emit();\n         }\n "}, {"sha": "ba17df4cdca4b930759bd8dd547ce93f1686209d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -145,22 +145,38 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         }\n \n         let t = cx.tables.expr_ty(&expr);\n-        let warned = match t.sty {\n-            ty::TyTuple(ref tys, _) if tys.is_empty() => return,\n-            ty::TyNever => return,\n-            ty::TyBool => return,\n-            ty::TyAdt(def, _) => check_must_use(cx, def.did, s.span),\n+        let ty_warned = match t.sty {\n+            ty::TyAdt(def, _) => check_must_use(cx, def.did, s.span, \"\"),\n             _ => false,\n         };\n-        if !warned {\n+\n+        let mut fn_warned = false;\n+        let maybe_def = match expr.node {\n+            hir::ExprCall(ref callee, _) => {\n+                match callee.node {\n+                    hir::ExprPath(ref qpath) => Some(cx.tables.qpath_def(qpath, callee.id)),\n+                    _ => None\n+                }\n+            },\n+            hir::ExprMethodCall(..) => {\n+                cx.tables.type_dependent_defs.get(&expr.id).cloned()\n+            },\n+            _ => { None }\n+        };\n+        if let Some(def) = maybe_def {\n+            let def_id = def.def_id();\n+            fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n+        }\n+\n+        if !(ty_warned || fn_warned) {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &LateContext, def_id: DefId, sp: Span) -> bool {\n+        fn check_must_use(cx: &LateContext, def_id: DefId, sp: Span, describe_path: &str) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(\"must_use\") {\n-                    let mut msg = format!(\"unused `{}` which must be used\",\n-                                          cx.tcx.item_path_str(def_id));\n+                    let mut msg = format!(\"unused {}`{}` which must be used\",\n+                                          describe_path, cx.tcx.item_path_str(def_id));\n                     // check for #[must_use=\"...\"]\n                     if let Some(s) = attr.value_str() {\n                         msg.push_str(\": \");"}, {"sha": "225e271e467b3689b49b3ca63f54d9d827b4c703", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -480,7 +480,7 @@ impl CrateStore for cstore::CStore {\n                 _ => {},\n             }\n \n-            let mut bfs_queue = &mut VecDeque::new();\n+            let bfs_queue = &mut VecDeque::new();\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: def::Export, parent: DefId| {\n                 let child = child.def.def_id();\n "}, {"sha": "e6360bd9570fbbb60010f6db3d084fff32219946", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n     }\n \n-    pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, mut f: &mut F)\n+    pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)\n         where F: FnMut(&mut Self, Mutability, Name, NodeId, Span, Ty<'tcx>)\n     {\n         match *pattern.kind {"}, {"sha": "53e3a7ff5a2351e42bfb4fcbc9fdd4cdb44a0a2d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -244,8 +244,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 let mut span = None;\n \n                 self.tcx\n-                    .trait_def(drop_trait_id)\n-                    .for_each_relevant_impl(self.tcx, self.mir.return_ty, |impl_did| {\n+                    .for_each_relevant_impl(drop_trait_id, self.mir.return_ty, |impl_did| {\n                         self.tcx.hir\n                             .as_local_node_id(impl_did)\n                             .and_then(|impl_node_id| self.tcx.hir.find(impl_node_id))"}, {"sha": "787f1ae1e21adc0186d7a58b28eeb7270ab13daf", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -770,7 +770,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                value,\n                obligations);\n \n-        let mut fulfill_cx = &mut self.fulfillment_cx;\n+        let fulfill_cx = &mut self.fulfillment_cx;\n         for obligation in obligations {\n             fulfill_cx.register_predicate_obligation(self.infcx, obligation);\n         }"}, {"sha": "2643ed2a3c07459faef968f4cfbf8c3e5d1b9d0f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -237,10 +237,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         self.check_trait_fn_not_const(sig.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, _| {\n-                                self.session.add_lint(lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n-                                                      trait_item.id, span,\n-                                                      \"patterns aren't allowed in methods \\\n-                                                       without bodies\".to_string());\n+                                self.session.buffer_lint(\n+                                    lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n+                                    trait_item.id, span,\n+                                    \"patterns aren't allowed in methods \\\n+                                     without bodies\");\n                             });\n                         }\n                     }\n@@ -252,7 +253,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 if item.attrs.iter().any(|attr| attr.check_name(\"warn_directory_ownership\")) {\n                     let lint = lint::builtin::LEGACY_DIRECTORY_OWNERSHIP;\n                     let msg = \"cannot declare a new module at this location\";\n-                    self.session.add_lint(lint, item.id, item.span, msg.to_string());\n+                    self.session.buffer_lint(lint, item.id, item.span, msg);\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {"}, {"sha": "d0322e27d66be9f1808fa79a66cfee274354002f", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -76,12 +76,12 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 ErroneousReferencedConstant(_) => {}\n                 TypeckError => {}\n                 _ => {\n-                    self.tcx.sess.add_lint(CONST_ERR,\n-                                           expr.id,\n-                                           expr.span,\n-                                           format!(\"constant evaluation error: {}. This will \\\n-                                                    become a HARD ERROR in the future\",\n-                                                   err.description().into_oneline()))\n+                    self.tcx.lint_node(CONST_ERR,\n+                                       expr.id,\n+                                       expr.span,\n+                                       &format!(\"constant evaluation error: {}. This will \\\n+                                                 become a HARD ERROR in the future\",\n+                                                err.description().into_oneline()));\n                 }\n             }\n         }\n@@ -260,10 +260,10 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     kind: LayoutError(ty::layout::LayoutError::Unknown(_)), ..\n                 }) => {}\n                 Err(msg) => {\n-                    self.tcx.sess.add_lint(CONST_ERR,\n-                                           ex.id,\n-                                           msg.span,\n-                                           msg.description().into_oneline().into_owned())\n+                    self.tcx.lint_node(CONST_ERR,\n+                                       ex.id,\n+                                       msg.span,\n+                                       &msg.description().into_oneline().into_owned());\n                 }\n             }\n         }"}, {"sha": "1bfa5943ee90a1849851be8459648cfa34b6018e", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -223,12 +223,45 @@ To fix this, add a label specifying which loop is being broken out of:\n ```\n 'foo: while break 'foo {}\n ```\n+\"##,\n+\n+E0571: r##\"\n+A `break` statement with an argument appeared in a non-`loop` loop.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0571\n+# let mut i = 1;\n+# fn satisfied(n: usize) -> bool { n % 23 == 0 }\n+let result = while true {\n+    if satisfied(i) {\n+        break 2*i; // error: `break` with value from a `while` loop\n+    }\n+    i += 1;\n+};\n+```\n+\n+The `break` statement can take an argument (which will be the value of the loop\n+expression if the `break` statement is executed) in `loop` loops, but not\n+`for`, `while`, or `while let` loops.\n+\n+Make sure `break value;` statements only occur in `loop` loops:\n+\n+```\n+# let mut i = 1;\n+# fn satisfied(n: usize) -> bool { n % 23 == 0 }\n+let result = loop { // ok!\n+    if satisfied(i) {\n+        break 2*i;\n+    }\n+    i += 1;\n+};\n+```\n \"##\n }\n \n register_diagnostics! {\n     E0226, // only a single explicit lifetime bound is permitted\n     E0472, // asm! is unsupported on this target\n     E0561, // patterns aren't allowed in function pointer types\n-    E0571, // `break` with a value in a non-`loop`-loop\n }"}, {"sha": "b38369665f89c442c7df8a8d2c0bea9cfa9a079c", "filename": "src/librustc_platform_intrinsics/powerpc.rs", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -142,6 +142,146 @@ pub fn find(name: &str) -> Option<Intrinsic> {\n             output: &::U32x4,\n             definition: Named(\"llvm.ppc.altivec.vminuw\")\n         },\n+        \"_vec_subsbs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vsubsbs\")\n+        },\n+        \"_vec_sububs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vsububs\")\n+        },\n+        \"_vec_subshs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vsubshs\")\n+        },\n+        \"_vec_subuhs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vsubuhs\")\n+        },\n+        \"_vec_subsws\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsubsws\")\n+        },\n+        \"_vec_subuws\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsubuws\")\n+        },\n+        \"_vec_subc\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vsubcuw\")\n+        },\n+        \"_vec_addsbs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vaddsbs\")\n+        },\n+        \"_vec_addubs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vaddubs\")\n+        },\n+        \"_vec_addshs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vaddshs\")\n+        },\n+        \"_vec_adduhs\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vadduhs\")\n+        },\n+        \"_vec_addsws\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vaddsws\")\n+        },\n+        \"_vec_adduws\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vadduws\")\n+        },\n+        \"_vec_addc\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vaddcuw\")\n+        },\n+        \"_vec_mulesb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmulesb\")\n+        },\n+        \"_vec_muleub\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmuleub\")\n+        },\n+        \"_vec_mulesh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmulesh\")\n+        },\n+        \"_vec_muleuh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmuleuh\")\n+        },\n+        \"_vec_mulosb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmulosb\")\n+        },\n+        \"_vec_muloub\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmuloub\")\n+        },\n+        \"_vec_mulosh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmulosh\")\n+        },\n+        \"_vec_mulouh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmulouh\")\n+        },\n+        \"_vec_avgsb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vavgsb\")\n+        },\n+        \"_vec_avgub\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vavgub\")\n+        },\n+        \"_vec_avgsh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vavgsh\")\n+        },\n+        \"_vec_avguh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vavguh\")\n+        },\n+        \"_vec_avgsw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vavgsw\")\n+        },\n+        \"_vec_avguw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vavguw\")\n+        },\n         _ => return None,\n     })\n }"}, {"sha": "9fa5fea20d915885d4e3ab06194751fe79efa6ad", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -781,7 +781,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             hir::ItemTrait(.., ref trait_item_refs) => {\n                 self.check_item(item.id).generics().predicates();\n                 for trait_item_ref in trait_item_refs {\n-                    let mut check = self.check_item(trait_item_ref.id.node_id);\n+                    let check = self.check_item(trait_item_ref.id.node_id);\n                     check.generics().predicates();\n                     if trait_item_ref.kind != hir::AssociatedItemKind::Type ||\n                        trait_item_ref.defaultness.has_value() {\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 {\n-                    let mut check = self.check_item(item.id);\n+                    let check = self.check_item(item.id);\n                     check.ty().generics().predicates();\n                     if trait_ref.is_some() {\n                         check.impl_trait_ref();\n@@ -1345,11 +1345,11 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n                                     \"private trait can't be public\"))\n                         .emit();\n                 } else {\n-                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           node_id,\n-                                           self.span,\n-                                           format!(\"private trait `{}` in public \\\n-                                                    interface (error E0445)\", trait_ref));\n+                    self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                       node_id,\n+                                       self.span,\n+                                       &format!(\"private trait `{}` in public \\\n+                                                 interface (error E0445)\", trait_ref));\n                 }\n             }\n         }\n@@ -1393,11 +1393,11 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n                         err.span_label(self.span, \"can't leak private type\");\n                         err.emit();\n                     } else {\n-                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               node_id,\n-                                               self.span,\n-                                               format!(\"private type `{}` in public \\\n-                                                        interface (error E0446)\", ty));\n+                        self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           node_id,\n+                                           self.span,\n+                                           &format!(\"private type `{}` in public \\\n+                                                     interface (error E0446)\", ty));\n                     }\n                 }\n             }"}, {"sha": "a8bb6619bbdda4b7ff9993e4bc27107df2da5b57", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -122,13 +122,13 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n                  directive.span.source_equal(&DUMMY_SP) => {}\n             ImportDirectiveSubclass::ExternCrate => {\n                 let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n-                let msg = \"unused extern crate\".to_string();\n-                resolver.session.add_lint(lint, directive.id, directive.span, msg);\n+                let msg = \"unused extern crate\";\n+             ;   resolver.session.buffer_lint(lint, directive.id, directive.span, msg)\n             }\n             ImportDirectiveSubclass::MacroUse => {\n                 let lint = lint::builtin::UNUSED_IMPORTS;\n-                let msg = \"unused `#[macro_use]` import\".to_string();\n-                resolver.session.add_lint(lint, directive.id, directive.span, msg);\n+                let msg = \"unused `#[macro_use]` import\";\n+                resolver.session.buffer_lint(lint, directive.id, directive.span, msg);\n             }\n             _ => {}\n         }\n@@ -160,9 +160,6 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n                           } else {\n                               String::new()\n                           });\n-        visitor.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                 *id,\n-                                 ms,\n-                                 msg);\n+        visitor.session.buffer_lint(lint::builtin::UNUSED_IMPORTS, *id, ms, &msg);\n     }\n }"}, {"sha": "b4f9ba4e8f78f29dbf961b707988156ac8192800", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -2552,9 +2552,10 @@ impl<'a> Resolver<'a> {\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n                                 let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n-                                self.session.add_lint(lint, id, span,\n+                                self.session.buffer_lint(lint, id, span,\n                                     \"private struct constructors are not usable through \\\n-                                     reexports in outer modules\".to_string());\n+                                     reexports in outer modules\",\n+                                );\n                                 res = Some(PathResolution::new(ctor_def));\n                             }\n                         }\n@@ -2748,7 +2749,7 @@ impl<'a> Resolver<'a> {\n             };\n             if result.base_def() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n+                self.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n             }\n         }\n \n@@ -3486,7 +3487,7 @@ impl<'a> Resolver<'a> {\n                 span.push_span_label(b1.span, msg1);\n                 span.push_span_label(b2.span, msg2);\n                 let msg = format!(\"`{}` is ambiguous\", name);\n-                self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n+                self.session.buffer_lint(lint::builtin::LEGACY_IMPORTS, id, span, &msg);\n             } else {\n                 let mut err =\n                     self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name));\n@@ -3607,8 +3608,8 @@ impl<'a> Resolver<'a> {\n \n     fn warn_legacy_self_import(&self, directive: &'a ImportDirective<'a>) {\n         let (id, span) = (directive.id, directive.span);\n-        let msg = \"`self` no longer imports values\".to_string();\n-        self.session.add_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n+        let msg = \"`self` no longer imports values\";\n+        self.session.buffer_lint(lint::builtin::LEGACY_IMPORTS, id, span, msg);\n     }\n \n     fn check_proc_macro_attrs(&mut self, attrs: &[ast::Attribute]) {"}, {"sha": "98eaa056177ef13c39f51fd05d9128df5dfdaa97", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -319,8 +319,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             };\n             if let Some((id, span)) = id_span {\n                 let lint = lint::builtin::UNUSED_MACROS;\n-                let msg = \"unused macro definition\".to_string();\n-                self.session.add_lint(lint, id, span, msg);\n+                let msg = \"unused macro definition\";\n+                self.session.buffer_lint(lint, id, span, msg);\n             } else {\n                 bug!(\"attempted to create unused macro error, but span not available\");\n             }"}, {"sha": "26c398379dc83256c906a843b2f59639be5b8c0a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -379,7 +379,7 @@ impl<'a> Resolver<'a> {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let mut resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n+            let resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -745,8 +745,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                    (error E0365), consider declaring with `pub`\",\n                                    ident);\n-                self.session.add_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                                      directive.id, directive.span, msg);\n+                self.session.buffer_lint(PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+                                         directive.id,\n+                                         directive.span,\n+                                         &msg);\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n                                  \"`{}` is private, and cannot be reexported\", ident)"}, {"sha": "8cbc5155ddeb721e793cf1565b1e72ba8ac58153", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1464,7 +1464,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                 let mut output = i.to_string(scx.tcx());\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n-                let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n                 cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n                 cgus.dedup();\n                 for &(ref cgu_name, (linkage, _)) in cgus.iter() {"}, {"sha": "63c7b18e8d29054687c954031986ca60fa15a8b0", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -335,7 +335,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                 CodegenUnit::empty(codegen_unit_name.clone())\n             };\n \n-            let mut codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n+            let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n                                                 .or_insert_with(make_codegen_unit);\n \n             let (linkage, visibility) = match trans_item.explicit_linkage(tcx) {"}, {"sha": "ead6e432561294f048d716aeffb7c1e248e449a3", "filename": "src/librustc_trans/time_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_trans%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_trans%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftime_graph.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -70,7 +70,7 @@ impl TimeGraph {\n         {\n             let mut table = self.data.lock().unwrap();\n \n-            let mut data = table.entry(timeline).or_insert(PerThread {\n+            let data = table.entry(timeline).or_insert(PerThread {\n                 timings: Vec::new(),\n                 open_work_package: None,\n             });\n@@ -90,7 +90,7 @@ impl TimeGraph {\n         let end = Instant::now();\n \n         let mut table = self.data.lock().unwrap();\n-        let mut data = table.get_mut(&timeline).unwrap();\n+        let data = table.get_mut(&timeline).unwrap();\n \n         if let Some((start, work_package_kind)) = data.open_work_package {\n             data.timings.push(Timing {"}, {"sha": "2910d25486ed5ad714cf925f9ae24feaec9f71e6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -985,9 +985,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .span_label(data.span, \"only traits may use parentheses\")\n                     .emit();\n             } else {\n-                let msg = \"parenthesized parameters may only be used with a trait\".to_string();\n-                self.tcx().sess.add_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-                                         ast::CRATE_NODE_ID, data.span, msg);\n+                let msg = \"parenthesized parameters may only be used with a trait\";\n+                self.tcx().lint_node(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+                                     ast::CRATE_NODE_ID, data.span, msg);\n             }\n         }\n     }"}, {"sha": "5f256eab9a9c8383a800882b1aa62a4bb9bfeca9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -291,25 +291,25 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n-            fcx.tables.borrow_mut().lints.add_lint(\n+            fcx.tcx.lint_node(\n                 lint::builtin::TRIVIAL_NUMERIC_CASTS,\n                 self.expr.id,\n                 self.span,\n-                format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                         replaced by coercion, this might require type \\\n-                         ascription or a temporary variable\",\n-                        fcx.ty_to_string(t_expr),\n-                        fcx.ty_to_string(t_cast)));\n+                &format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                          replaced by coercion, this might require type \\\n+                          ascription or a temporary variable\",\n+                         fcx.ty_to_string(t_expr),\n+                         fcx.ty_to_string(t_cast)));\n         } else {\n-            fcx.tables.borrow_mut().lints.add_lint(\n+            fcx.tcx.lint_node(\n                 lint::builtin::TRIVIAL_CASTS,\n                 self.expr.id,\n                 self.span,\n-                format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                         replaced by coercion, this might require type \\\n-                         ascription or a temporary variable\",\n-                        fcx.ty_to_string(t_expr),\n-                        fcx.ty_to_string(t_cast)));\n+                &format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                          replaced by coercion, this might require type \\\n+                          ascription or a temporary variable\",\n+                         fcx.ty_to_string(t_expr),\n+                         fcx.ty_to_string(t_cast)));\n         }\n \n     }"}, {"sha": "934a4f9b29689775498bf585460549d951b44843", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1204,7 +1204,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     }\n                 }\n \n-                if let Some(mut augment_error) = augment_error {\n+                if let Some(augment_error) = augment_error {\n                     augment_error(&mut db);\n                 }\n "}, {"sha": "1ccb1e64a98e088b1292155d6562b73f6d4e895e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -58,8 +58,9 @@ pub enum MethodError<'tcx> {\n     ClosureAmbiguity(// DefId of fn trait\n                      DefId),\n \n-    // Found an applicable method, but it is not visible.\n-    PrivateMatch(Def),\n+    // Found an applicable method, but it is not visible. The second argument contains a list of\n+    // not-in-scope traits which may work.\n+    PrivateMatch(Def, Vec<DefId>),\n \n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait."}, {"sha": "6669e75d5a0160a9bb551b15b1f594d47d063306", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -556,7 +556,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // We can't use normalize_associated_types_in as it will pollute the\n             // fcx's fulfillment context after this probe is over.\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n+            let selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n             debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n@@ -738,10 +738,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                      import_id: Option<ast::NodeId>,\n                                                      trait_def_id: DefId,\n                                                      item: ty::AssociatedItem) {\n-        let trait_def = self.tcx.trait_def(trait_def_id);\n-\n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n-        trait_def.for_each_impl(self.tcx, |impl_def_id| {\n+        self.tcx.for_each_impl(trait_def_id, |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n                                                                   impl_def_id={:?}\",\n                    trait_def_id,\n@@ -769,7 +767,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // as it will pollute the fcx's fulfillment context after this probe\n             // is over.\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n+            let selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n \n@@ -1059,7 +1057,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(def) = private_candidate {\n-            return Err(MethodError::PrivateMatch(def));\n+            return Err(MethodError::PrivateMatch(def, out_of_scope_traits));\n         }\n \n         Err(MethodError::NoMatch(NoMatchData::new(static_candidates,"}, {"sha": "56eacc3194d1c8404c60d7c8e6dc073cc768af5c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -311,9 +311,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.sess().span_err(span, &msg);\n             }\n \n-            MethodError::PrivateMatch(def) => {\n-                struct_span_err!(self.tcx.sess, span, E0624,\n-                                 \"{} `{}` is private\", def.kind_name(), item_name).emit();\n+            MethodError::PrivateMatch(def, out_of_scope_traits) => {\n+                let mut err = struct_span_err!(self.tcx.sess, span, E0624,\n+                                               \"{} `{}` is private\", def.kind_name(), item_name);\n+                self.suggest_valid_traits(&mut err, out_of_scope_traits);\n+                err.emit();\n             }\n \n             MethodError::IllegalSizedBound(candidates) => {\n@@ -353,13 +355,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         err.note(&msg[..]);\n     }\n \n-    fn suggest_traits_to_import(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                span: Span,\n-                                rcvr_ty: Ty<'tcx>,\n-                                item_name: ast::Name,\n-                                rcvr_expr: Option<&hir::Expr>,\n-                                valid_out_of_scope_traits: Vec<DefId>) {\n+    fn suggest_valid_traits(&self,\n+                            err: &mut DiagnosticBuilder,\n+                            valid_out_of_scope_traits: Vec<DefId>) -> bool {\n         if !valid_out_of_scope_traits.is_empty() {\n             let mut candidates = valid_out_of_scope_traits;\n             candidates.sort();\n@@ -379,6 +377,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             });\n \n             self.suggest_use_candidates(err, msg, candidates);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn suggest_traits_to_import(&self,\n+                                err: &mut DiagnosticBuilder,\n+                                span: Span,\n+                                rcvr_ty: Ty<'tcx>,\n+                                item_name: ast::Name,\n+                                rcvr_expr: Option<&hir::Expr>,\n+                                valid_out_of_scope_traits: Vec<DefId>) {\n+        if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n "}, {"sha": "d2176b245be11838a1a76d19d3682068958b0747", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1754,10 +1754,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-            self.tables.borrow_mut().lints.add_lint(\n+            self.tcx().lint_node(\n                 lint::builtin::UNREACHABLE_CODE,\n                 id, span,\n-                format!(\"unreachable {}\", kind));\n+                &format!(\"unreachable {}\", kind));\n         }\n     }\n \n@@ -4073,7 +4073,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n-                    method::MethodError::PrivateMatch(def) => def,\n+                    method::MethodError::PrivateMatch(def, _) => def,\n                     _ => Def::Err,\n                 };\n                 if item_name != keywords::Invalid.name() {\n@@ -4240,8 +4240,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n \n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let mut ctxt = enclosing_breakables.find_breakable(blk.id);\n-            let mut coerce = ctxt.coerce.as_mut().unwrap();\n+            let ctxt = enclosing_breakables.find_breakable(blk.id);\n+            let coerce = ctxt.coerce.as_mut().unwrap();\n             if let Some(tail_expr_ty) = tail_expr_ty {\n                 let tail_expr = tail_expr.unwrap();\n                 let cause = self.cause(tail_expr.span,\n@@ -4286,8 +4286,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty\n     }\n \n-    /// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether it is\n-    /// `fn main` if it is a method, `None` otherwise.\n+    /// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether a\n+    /// suggetion can be made, `None` otherwise.\n     pub fn get_fn_decl(&self, blk_id: ast::NodeId) -> Option<(hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n@@ -4298,14 +4298,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 name, node: hir::ItemFn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n-                    // This is less than ideal, it will not present the return type span on any\n-                    // method called `main`, regardless of whether it is actually the entry point.\n-                    Some((decl, name == Symbol::intern(\"main\")))\n+                    // This is less than ideal, it will not suggest a return type span on any\n+                    // method called `main`, regardless of whether it is actually the entry point,\n+                    // but it will still present it as the reason for the expected type.\n+                    Some((decl, name != Symbol::intern(\"main\")))\n                 })\n             } else if let Node::NodeTraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(hir::MethodSig {\n                     ref decl, ..\n                 }, ..), ..\n+            }) = parent {\n+                decl.clone().and_then(|decl| {\n+                    Some((decl, true))\n+                })\n+            } else if let Node::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(hir::MethodSig {\n+                    ref decl, ..\n+                }, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     Some((decl, false))\n@@ -4332,11 +4341,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             blk_id: ast::NodeId) {\n         self.suggest_missing_semicolon(err, expression, expected, cause_span);\n \n-        if let Some((fn_decl, is_main)) = self.get_fn_decl(blk_id) {\n-            // `fn main()` must return `()`, do not suggest changing return type\n-            if !is_main {\n-                self.suggest_missing_return_type(err, &fn_decl, found);\n-            }\n+        if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n+            self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n         }\n     }\n \n@@ -4392,20 +4398,37 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn suggest_missing_return_type(&self,\n                                    err: &mut DiagnosticBuilder<'tcx>,\n                                    fn_decl: &hir::FnDecl,\n-                                   ty: Ty<'tcx>) {\n-\n-        // Only recommend changing the return type for methods that\n+                                   expected: Ty<'tcx>,\n+                                   found: Ty<'tcx>,\n+                                   can_suggest: bool) {\n+        // Only suggest changing the return type for methods that\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n-        if let &hir::FnDecl {\n-            output: hir::FunctionRetTy::DefaultReturn(span), ..\n-        } = fn_decl {\n-            if ty.is_suggestable() {\n+        match (&fn_decl.output, found.is_suggestable(), can_suggest) {\n+            (&hir::FunctionRetTy::DefaultReturn(span), true, true) => {\n                 err.span_suggestion(span,\n                                     \"try adding a return type\",\n-                                    format!(\"-> {} \", ty));\n-            } else {\n+                                    format!(\"-> {} \", found));\n+            }\n+            (&hir::FunctionRetTy::DefaultReturn(span), false, true) => {\n                 err.span_label(span, \"possibly return type missing here?\");\n             }\n+            (&hir::FunctionRetTy::DefaultReturn(span), _, _) => {\n+                // `fn main()` must return `()`, do not suggest changing return type\n+                err.span_label(span, \"expected `()` because of default return type\");\n+            }\n+            (&hir::FunctionRetTy::Return(ref ty), _, _) => {\n+                // Only point to return type if the expected type is the return type, as if they\n+                // are not, the expectation must have been caused by something else.\n+                debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.node);\n+                let sp = ty.span;\n+                let ty = AstConv::ast_ty_to_ty(self, ty);\n+                debug!(\"suggest_missing_return_type: return type sty {:?}\", ty.sty);\n+                debug!(\"suggest_missing_return_type: expected type sty {:?}\", ty.sty);\n+                if ty.sty == expected.sty {\n+                    err.span_label(sp, format!(\"expected `{}` because of return type\",\n+                                               expected));\n+                }\n+            }\n         }\n     }\n \n@@ -4803,8 +4826,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 let mut multispan = MultiSpan::from_span(lifetimes[0].span);\n                 multispan.push_span_label(span_late, note_msg.to_string());\n-                self.tcx.sess.add_lint(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n-                                       lifetimes[0].id, multispan, primary_msg.to_string());\n+                self.tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n+                                   lifetimes[0].id, multispan, primary_msg);\n             }\n             return;\n         }"}, {"sha": "c1711491ee48ca2427d0dbfc4f49d3dee71d160b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           lhs_expr: &'gcx hir::Expr,\n                           lhs_ty: Ty<'tcx>,\n                           rhs_ty: Ty<'tcx>,\n-                          mut err: &mut errors::DiagnosticBuilder) -> bool {\n+                          err: &mut errors::DiagnosticBuilder) -> bool {\n         // If this function returns true it means a note was printed, so we don't need\n         // to print the normal \"implementation of `std::ops::Add` might be missing\" note\n         let mut is_string_addition = false;"}, {"sha": "c18a070300a23c07a90063db44d883996ae80816", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -43,7 +43,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_fru_field_types();\n         wbcx.visit_anon_types();\n         wbcx.visit_cast_types();\n-        wbcx.visit_lints();\n         wbcx.visit_free_region_map();\n         wbcx.visit_generator_sigs();\n         wbcx.visit_generator_interiors();\n@@ -237,10 +236,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n     }\n \n-    fn visit_lints(&mut self) {\n-        self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n-    }\n-\n     fn visit_free_region_map(&mut self) {\n         let free_region_map = self.tcx().lift_to_global(&self.fcx.tables.borrow().free_region_map);\n         let free_region_map = free_region_map.expect(\"all regions in free-region-map are global\");"}, {"sha": "e95d49f00bf76614741c1f0a349c7fc40067155a", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n         } else {\n             \"unused import\".to_string()\n         };\n-        self.tcx.sess.add_lint(lint::builtin::UNUSED_IMPORTS, id, span, msg);\n+        self.tcx.lint_node(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n     }\n }\n "}, {"sha": "0ce5c96da7639859aedac65c926737d45b02b83f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -999,12 +999,12 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if !allow_defaults && p.default.is_some() {\n             if !tcx.sess.features.borrow().default_type_parameter_fallback {\n-                tcx.sess.add_lint(\n+                tcx.lint_node(\n                     lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                     p.id,\n                     p.span,\n-                    format!(\"defaults for type parameters are only allowed in `struct`, \\\n-                             `enum`, `type`, or `trait` definitions.\"));\n+                    &format!(\"defaults for type parameters are only allowed in `struct`, \\\n+                              `enum`, `type`, or `trait` definitions.\"));\n             }\n         }\n "}, {"sha": "e101e29fc6fbb8d86877264ac88dbd6891cef641", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -155,7 +155,9 @@ pub fn run_core(search_paths: SearchPaths,\n     target_features::add_configuration(&mut cfg, &sess);\n     sess.parse_sess.config = cfg;\n \n-    let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n+    let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n+                                                      &sess,\n+                                                      &input));\n \n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n "}, {"sha": "735c9d8af7a8a65ef5ad1440ffedb4c35041aac8", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -32,7 +32,6 @@ use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n-use std::ffi::CString;\n use std::fmt::{self, Write};\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n@@ -529,8 +528,8 @@ extern {\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n-    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n+    fn hoedown_buffer_put(b: *mut hoedown_buffer, c: *const u8, len: libc::size_t);\n }\n \n impl hoedown_buffer {\n@@ -620,8 +619,7 @@ pub fn render(w: &mut fmt::Formatter,\n                                Some(\"rust-example-rendered\"),\n                                None,\n                                playground_button.as_ref().map(String::as_str)));\n-                let output = CString::new(s).unwrap();\n-                hoedown_buffer_puts(ob, output.as_ptr());\n+                hoedown_buffer_put(ob, s.as_ptr(), s.len());\n             })\n         }\n     }\n@@ -630,7 +628,7 @@ pub fn render(w: &mut fmt::Formatter,\n                      level: libc::c_int, data: *const hoedown_renderer_data,\n                      _: libc::size_t) {\n         // hoedown does this, we may as well too\n-        unsafe { hoedown_buffer_puts(ob, \"\\n\\0\".as_ptr() as *const _); }\n+        unsafe { hoedown_buffer_put(ob, \"\\n\".as_ptr(), 1); }\n \n         // Extract the text provided\n         let s = if text.is_null() {\n@@ -681,8 +679,7 @@ pub fn render(w: &mut fmt::Formatter,\n                            <a href='#{id}'>{sec}{}</a></h{lvl}>\",\n                            s, lvl = level, id = id, sec = sec);\n \n-        let text = CString::new(text).unwrap();\n-        unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n+        unsafe { hoedown_buffer_put(ob, text.as_ptr(), text.len()); }\n     }\n \n     extern fn codespan(\n@@ -700,8 +697,9 @@ pub fn render(w: &mut fmt::Formatter,\n         };\n \n         let content = format!(\"<code>{}</code>\", Escape(&content));\n-        let element = CString::new(content).unwrap();\n-        unsafe { hoedown_buffer_puts(ob, element.as_ptr()); }\n+        unsafe {\n+            hoedown_buffer_put(ob, content.as_ptr(), content.len());\n+        }\n         // Return anything except 0, which would mean \"also print the code span verbatim\".\n         1\n     }"}, {"sha": "b1e92b5190f375941a9e1e0c15097f3e96733094", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -91,7 +91,9 @@ pub fn run(input: &str,\n     sess.parse_sess.config =\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n \n-    let krate = panictry!(driver::phase_1_parse_input(&sess, &input));\n+    let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n+                                                      &sess,\n+                                                      &input));\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())"}, {"sha": "7e2229a8f84a3bb014f169112c02eb40901c7e52", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1618,7 +1618,7 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n-    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+    fn into_iter(self) -> IterMut<'a, K, V> {\n         self.iter_mut()\n     }\n }"}, {"sha": "6f7c5a5de42b37a90f75e70fa629219398bb7594", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -563,7 +563,7 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n     ///\n     /// This works similarly to `put`, building an `EmptyBucket` out of the\n     /// taken bucket.\n-    pub fn take(mut self) -> (EmptyBucket<K, V, &'t mut RawTable<K, V>>, K, V) {\n+    pub fn take(self) -> (EmptyBucket<K, V, &'t mut RawTable<K, V>>, K, V) {\n         self.table.size -= 1;\n \n         unsafe {"}, {"sha": "401552a6ec41729a0234ee455e0027ab256dd14a", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -514,7 +514,7 @@ mod tests {\n     #[test]\n     fn downcasting() {\n         let mut a = A;\n-        let mut a = &mut a as &mut (Error + 'static);\n+        let a = &mut a as &mut (Error + 'static);\n         assert_eq!(a.downcast_ref::<A>(), Some(&A));\n         assert_eq!(a.downcast_ref::<B>(), None);\n         assert_eq!(a.downcast_mut::<A>(), Some(&mut A));"}, {"sha": "d986021a18bbc7676e072c4001670aa3ae119b45", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -456,7 +456,7 @@ mod tests {\n     #[test]\n     fn test_slice_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = &mut &in_buf[..];\n+        let reader = &mut &in_buf[..];\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n         let mut buf = [0];"}, {"sha": "5e88a46ecc343016b947bb896a01b0e0d00e96aa", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -14,6 +14,16 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n+#[macro_export]\n+// This stability attribute is totally useless.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n+macro_rules! __rust_unstable_column {\n+    () => {\n+        column!()\n+    }\n+}\n+\n /// The entry point for panic of Rust threads.\n ///\n /// This macro is used to inject panic into a Rust thread, causing the thread to\n@@ -48,7 +58,8 @@ macro_rules! panic {\n     ($msg:expr) => ({\n         $crate::rt::begin_panic($msg, {\n             // static requires less code at runtime, more constant data\n-            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(),\n+                __rust_unstable_column!());\n             &_FILE_LINE_COL\n         })\n     });\n@@ -58,7 +69,8 @@ macro_rules! panic {\n             // used inside a dead function. Just `#[allow(dead_code)]` is\n             // insufficient, since the user may have\n             // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(),\n+                __rust_unstable_column!());\n             &_FILE_LINE_COL\n         })\n     });"}, {"sha": "273c7c1c54a2a902dbde9d3c6318fbae59ea1715", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -152,7 +152,7 @@ impl Barrier {\n             BarrierWaitResult(false)\n         } else {\n             lock.count = 0;\n-            lock.generation_id += 1;\n+            lock.generation_id = lock.generation_id.wrapping_add(1);\n             self.cvar.notify_all();\n             BarrierWaitResult(true)\n         }"}, {"sha": "bb18fe95a9dbfb08cfee8456a364bc2b4f50b7c8", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -267,7 +267,7 @@ impl Once {\n     #[cold]\n     fn call_inner(&'static self,\n                   ignore_poisoning: bool,\n-                  mut init: &mut FnMut(bool)) {\n+                  init: &mut FnMut(bool)) {\n         let mut state = self.state.load(Ordering::SeqCst);\n \n         'outer: loop {"}, {"sha": "1f56a299407edb2fbbb20a41efbaaf4c7da2bcf7", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -12,13 +12,13 @@ pub use self::imp::OsRng;\n \n use mem;\n \n-fn next_u32(mut fill_buf: &mut FnMut(&mut [u8])) -> u32 {\n+fn next_u32(fill_buf: &mut FnMut(&mut [u8])) -> u32 {\n     let mut buf: [u8; 4] = [0; 4];\n     fill_buf(&mut buf);\n     unsafe { mem::transmute::<[u8; 4], u32>(buf) }\n }\n \n-fn next_u64(mut fill_buf: &mut FnMut(&mut [u8])) -> u64 {\n+fn next_u64(fill_buf: &mut FnMut(&mut [u8])) -> u64 {\n     let mut buf: [u8; 8] = [0; 8];\n     fill_buf(&mut buf);\n     unsafe { mem::transmute::<[u8; 8], u64>(buf) }"}, {"sha": "f2487c1b0bd0af4e4b3032413ca4d823484b32cb", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -768,8 +768,8 @@ fn symlink_junction_inner(target: &Path, junction: &Path) -> io::Result<()> {\n \n     unsafe {\n         let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-        let mut db = data.as_mut_ptr()\n-                        as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n+        let db = data.as_mut_ptr()\n+                    as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n         let buf = &mut (*db).ReparseTarget as *mut _;\n         let mut i = 0;\n         // FIXME: this conversion is very hacky"}, {"sha": "1e8a0be80966da3e37e352194a0f04ddec5e0472", "filename": "src/libstd_unicode/tables.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Ftables.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -12,9 +12,32 @@\n \n #![allow(missing_docs, non_upper_case_globals, non_snake_case)]\n \n-/// The version of [Unicode](http://www.unicode.org/)\n-/// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (u64, u64, u64) = (10, 0, 0);\n+/// Represents a Unicode Version.\n+///\n+/// See also: <http://www.unicode.org/versions/>\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+pub struct UnicodeVersion {\n+    /// Major version.\n+    pub major: u32,\n+\n+    /// Minor version.\n+    pub minor: u32,\n+\n+    /// Micro (or Update) version.\n+    pub micro: u32,\n+\n+    // Private field to keep struct expandable.\n+    _priv: (),\n+}\n+\n+/// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+/// `CharExt` and `UnicodeStrPrelude` traits are based on.\n+pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n+    major: 10,\n+    minor: 0,\n+    micro: 0,\n+    _priv: (),\n+};\n \n \n // BoolTrie is a trie for representing a set of Unicode codepoints. It is"}, {"sha": "1fac859242eab676c3e96abffd3af12dc905f714", "filename": "src/libstd_unicode/unicode.py", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd_unicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibstd_unicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Funicode.py?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -560,9 +560,32 @@ def emit_norm_module(f, canon, compat, combine, norm_props):\n             pattern = \"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n             unicode_version = re.search(pattern, readme.read()).groups()\n         rf.write(\"\"\"\n-/// The version of [Unicode](http://www.unicode.org/)\n-/// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (u64, u64, u64) = (%s, %s, %s);\n+/// Represents a Unicode Version.\n+///\n+/// See also: <http://www.unicode.org/versions/>\n+#[derive(Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+pub struct UnicodeVersion {\n+    /// Major version.\n+    pub major: u32,\n+\n+    /// Minor version.\n+    pub minor: u32,\n+\n+    /// Micro (or Update) version.\n+    pub micro: u32,\n+\n+    // Private field to keep struct expandable.\n+    _priv: (),\n+}\n+\n+/// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+/// `CharExt` and `UnicodeStrPrelude` traits are based on.\n+pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n+    major: %s,\n+    minor: %s,\n+    micro: %s,\n+    _priv: (),\n+};\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n                 to_upper, to_lower, to_title) = load_unicode_data(\"UnicodeData.txt\")"}, {"sha": "2ea3fe51d30b201076afabec5076af93b5f7053f", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -162,6 +162,63 @@ For more information about the cfg attribute, read:\n https://doc.rust-lang.org/reference.html#conditional-compilation\n \"##,\n \n+E0552: r##\"\n+A unrecognized representation attribute was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0552\n+#[repr(D)] // error: unrecognized representation hint\n+struct MyStruct {\n+    my_field: usize\n+}\n+```\n+\n+You can use a `repr` attribute to tell the compiler how you want a struct or\n+enum to be laid out in memory.\n+\n+Make sure you're using one of the supported options:\n+\n+```\n+#[repr(C)] // ok!\n+struct MyStruct {\n+    my_field: usize\n+}\n+```\n+\n+For more information about specifying representations, see the [\"Alternative\n+Representations\" section] of the Rustonomicon.\n+\n+[\"Alternative Representations\" section]: https://doc.rust-lang.org/nomicon/other-reprs.html\n+\"##,\n+\n+E0554: r##\"\n+Feature attributes are only allowed on the nightly release channel. Stable or\n+beta compilers will not comply.\n+\n+Example of erroneous code (on a stable compiler):\n+\n+```ignore (depends on release channel)\n+#![feature(non_ascii_idents)] // error: #![feature] may not be used on the\n+                              //        stable release channel\n+```\n+\n+If you need the feature, make sure to use a nightly release of the compiler\n+(but be warned that the feature may be removed or altered in the future).\n+\"##,\n+\n+E0557: r##\"\n+A feature attribute named a feature that has been removed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0557\n+#![feature(managed_boxes)] // error: feature has been removed\n+```\n+\n+Delete the offending feature attribute.\n+\"##,\n+\n E0558: r##\"\n The `export_name` attribute was malformed.\n \n@@ -300,11 +357,8 @@ register_diagnostics! {\n     E0549, // rustc_deprecated attribute must be paired with either stable or unstable attribute\n     E0550, // multiple deprecated attributes\n     E0551, // incorrect meta item\n-    E0552, // unrecognized representation hint\n-    E0554, // #[feature] may not be used on the [] release channel\n     E0555, // malformed feature attribute, expected #![feature(...)]\n     E0556, // malformed feature, expected just one word\n-    E0557, // feature has been removed\n     E0584, // file for module `..` found at both .. and ..\n     E0589, // invalid `repr(align)` attribute\n }"}, {"sha": "b293aa8de38b2944bd5082da7460b3dd4b867d23", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -52,6 +52,16 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::MacEager::expr(cx.expr_u32(topmost, loc.col.to_usize() as u32))\n }\n \n+/* __rust_unstable_column!(): expands to the current column number */\n+pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+                  -> Box<base::MacResult+'static> {\n+    if sp.allows_unstable() {\n+        expand_column(cx, sp, tts)\n+    } else {\n+        cx.span_fatal(sp, \"the __rust_unstable_column macro is unstable\");\n+    }\n+}\n+\n /// file!(): expands to the current filename */\n /// The filemap (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted."}, {"sha": "146bd5d985699fead5fc4050eadc3f426752b4ca", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -211,7 +211,7 @@ pub enum NamedMatch {\n \n fn nameize<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, ms: &[TokenTree], mut res: I)\n                                              -> NamedParseResult {\n-    fn n_rec<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, m: &TokenTree, mut res: &mut I,\n+    fn n_rec<I: Iterator<Item=NamedMatch>>(sess: &ParseSess, m: &TokenTree, res: &mut I,\n              ret_val: &mut HashMap<Ident, Rc<NamedMatch>>)\n              -> Result<(), (syntax_pos::Span, String)> {\n         match *m {\n@@ -445,7 +445,7 @@ pub fn parse(sess: &ParseSess,\n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&parser.token, &token::Eof) {\n             if eof_items.len() == 1 {\n-                let matches = eof_items[0].matches.iter_mut().map(|mut dv| {\n+                let matches = eof_items[0].matches.iter_mut().map(|dv| {\n                     Rc::make_mut(dv).pop().unwrap()\n                 });\n                 return nameize(sess, ms, matches);"}, {"sha": "80b6794d1e3cc4c01aae143a8c5d89faef7f1455", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -86,7 +86,7 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n \n fn trace_macros_note(cx: &mut ExtCtxt, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n-    let mut values: &mut Vec<String> = cx.expansions.entry(sp).or_insert_with(Vec::new);\n+    let values: &mut Vec<String> = cx.expansions.entry(sp).or_insert_with(Vec::new);\n     values.push(message);\n }\n "}, {"sha": "cb0cc2aafb074db7ffdae7cb1d32e60fd45e8b89", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1611,7 +1611,7 @@ fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate,\n             if attr.check_name(\"feature\") {\n                 let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n                 span_err!(span_handler, attr.span, E0554,\n-                          \"#[feature] may not be used on the {} release channel\",\n+                          \"#![feature] may not be used on the {} release channel\",\n                           release_channel);\n             }\n         }"}, {"sha": "85df4eee9134440c3222dcb59378fe94f1779d90", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 125, "deletions": 19, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,55 +9,80 @@\n // except according to those terms.\n \n // Characters and their corresponding confusables were collected from\n-// http://www.unicode.org/Public/security/revision-06/confusables.txt\n+// http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n use syntax_pos::{Span, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n use super::StringReader;\n \n const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n-    ('\u00a0', \"No-Break Space\", ' '),\n-    ('\u1680', \"Ogham Space Mark\", ' '),\n+    ('\u2028', \"Line Separator\", ' '),\n+    ('\u2029', \"Paragraph Separator\", ' '),\n+    ('\u1680', \"Ogham Space mark\", ' '),\n     ('\u2000', \"En Quad\", ' '),\n     ('\u2001', \"Em Quad\", ' '),\n     ('\u2002', \"En Space\", ' '),\n     ('\u2003', \"Em Space\", ' '),\n     ('\u2004', \"Three-Per-Em Space\", ' '),\n     ('\u2005', \"Four-Per-Em Space\", ' '),\n     ('\u2006', \"Six-Per-Em Space\", ' '),\n-    ('\u2007', \"Figure Space\", ' '),\n     ('\u2008', \"Punctuation Space\", ' '),\n     ('\u2009', \"Thin Space\", ' '),\n     ('\u200a', \"Hair Space\", ' '),\n-    ('\u202f', \"Narrow No-Break Space\", ' '),\n     ('\u205f', \"Medium Mathematical Space\", ' '),\n+    ('\u00a0', \"No-Break Space\", ' '),\n+    ('\u2007', \"Figure Space\", ' '),\n+    ('\u202f', \"Narrow No-Break Space\", ' '),\n     ('\u3000', \"Ideographic Space\", ' '),\n+\n     ('\u07fa', \"Nko Lajanyalan\", '_'),\n     ('\ufe4d', \"Dashed Low Line\", '_'),\n     ('\ufe4e', \"Centreline Low Line\", '_'),\n     ('\ufe4f', \"Wavy Low Line\", '_'),\n+    ('\uff3f', \"Fullwidth Low Line\", '_'),\n+\n     ('\u2010', \"Hyphen\", '-'),\n     ('\u2011', \"Non-Breaking Hyphen\", '-'),\n     ('\u2012', \"Figure Dash\", '-'),\n     ('\u2013', \"En Dash\", '-'),\n     ('\u2014', \"Em Dash\", '-'),\n     ('\ufe58', \"Small Em Dash\", '-'),\n+    ('\u06d4', \"Arabic Full Stop\", '-'),\n     ('\u2043', \"Hyphen Bullet\", '-'),\n     ('\u02d7', \"Modifier Letter Minus Sign\", '-'),\n     ('\u2212', \"Minus Sign\", '-'),\n+    ('\u2796', \"Heavy Minus Sign\", '-'),\n+    ('\u2cba', \"Coptic Letter Dialect-P Ni\", '-'),\n     ('\u30fc', \"Katakana-Hiragana Prolonged Sound Mark\", '-'),\n+    ('\uff0d', \"Fullwidth Hyphen-Minus\", '-'),\n+    ('\u2015', \"Horizontal Bar\", '-'),\n+    ('\u2500', \"Box Drawings Light Horizontal\", '-'),\n+    ('\u2501', \"Box Drawings Heavy Horizontal\", '-'),\n+    ('\u31d0', \"CJK Stroke H\", '-'),\n+    ('\ua7f7', \"Latin Epigraphic Letter Dideways\", '-'),\n+    ('\u1173', \"Hangul Jungseong Eu\", '-'),\n+    ('\u3161', \"Hangul Letter Eu\", '-'),\n+    ('\u4e00', \"CJK Unified Ideograph-4E00\", '-'),\n+    ('\u2f00', \"Kangxi Radical One\", '-'),\n+\n+    ('\u060d', \"Arabic Date Separator\", ','),\n     ('\u066b', \"Arabic Decimal Separator\", ','),\n     ('\u201a', \"Single Low-9 Quotation Mark\", ','),\n+    ('\u00b8', \"Cedilla\", ','),\n     ('\ua4f9', \"Lisu Letter Tone Na Po\", ','),\n     ('\uff0c', \"Fullwidth Comma\", ','),\n+\n     ('\u037e', \"Greek Question Mark\", ';'),\n     ('\uff1b', \"Fullwidth Semicolon\", ';'),\n+    ('\ufe14', \"Presentation Form For Vertical Semicolon\", ';'),\n+\n     ('\u0903', \"Devanagari Sign Visarga\", ':'),\n     ('\u0a83', \"Gujarati Sign Visarga\", ':'),\n     ('\uff1a', \"Fullwidth Colon\", ':'),\n     ('\u0589', \"Armenian Full Stop\", ':'),\n     ('\u0703', \"Syriac Supralinear Colon\", ':'),\n     ('\u0704', \"Syriac Sublinear Colon\", ':'),\n+    ('\u16ec', \"Runic Multiple Ponctuation\", ':'),\n     ('\ufe30', \"Presentation Form For Vertical Two Dot Leader\", ':'),\n     ('\u1803', \"Mongolian Full Stop\", ':'),\n     ('\u1809', \"Mongolian Manchu Full Stop\", ':'),\n@@ -68,25 +93,48 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u2236', \"Ratio\", ':'),\n     ('\u02d0', \"Modifier Letter Triangular Colon\", ':'),\n     ('\ua4fd', \"Lisu Letter Tone Mya Jeu\", ':'),\n+    ('\ufe13', \"Presentation Form For Vertical Colon\", ':'),\n+\n     ('\uff01', \"Fullwidth Exclamation Mark\", '!'),\n     ('\u01c3', \"Latin Letter Retroflex Click\", '!'),\n+    ('\u2d51', \"Tifinagh Letter Tuareg Yang\", '!'),\n+    ('\ufe15', \"Presentation Form For Vertical Exclamation Mark\", '!'),\n+\n     ('\u0294', \"Latin Letter Glottal Stop\", '?'),\n+    ('\u0241', \"Latin Capital Letter Glottal Stop\", '?'),\n     ('\u097d', \"Devanagari Letter Glottal Stop\", '?'),\n     ('\u13ae', \"Cherokee Letter He\", '?'),\n+    ('\ua6eb', \"Bamum Letter Ntuu\", '?'),\n     ('\uff1f', \"Fullwidth Question Mark\", '?'),\n+    ('\ufe16', \"Presentation Form For Vertical Question Mark\", '?'),\n+\n     ('\ud834\udd6d', \"Musical Symbol Combining Augmentation Dot\", '.'),\n     ('\u2024', \"One Dot Leader\", '.'),\n-    ('\u06d4', \"Arabic Full Stop\", '.'),\n     ('\u0701', \"Syriac Supralinear Full Stop\", '.'),\n     ('\u0702', \"Syriac Sublinear Full Stop\", '.'),\n     ('\ua60e', \"Vai Full Stop\", '.'),\n     ('\ud802\ude50', \"Kharoshthi Punctuation Dot\", '.'),\n-    ('\u00b7', \"Middle Dot\", '.'),\n     ('\u0660', \"Arabic-Indic Digit Zero\", '.'),\n     ('\u06f0', \"Extended Arabic-Indic Digit Zero\", '.'),\n     ('\ua4f8', \"Lisu Letter Tone Mya Ti\", '.'),\n-    ('\u3002', \"Ideographic Full Stop\", '.'),\n+    ('\u00b7', \"Middle Dot\", '.'),\n     ('\u30fb', \"Katakana Middle Dot\", '.'),\n+    ('\uff65', \"Halfwidth Katakana Middle Dot\", '.'),\n+    ('\u16eb', \"Runic Single Punctuation\", '.'),\n+    ('\u0387', \"Greek Ano Teleia\", '.'),\n+    ('\u2e31', \"Word Separator Middle Dot\", '.'),\n+    ('\ud800\udd01', \"Aegean Word Separator Dot\", '.'),\n+    ('\u2022', \"Bullet\", '.'),\n+    ('\u2027', \"Hyphenation Point\", '.'),\n+    ('\u2219', \"Bullet Operator\", '.'),\n+    ('\u22c5', \"Dot Operator\", '.'),\n+    ('\ua78f', \"Latin Letter Sinological Dot\", '.'),\n+    ('\u1427', \"Canadian Syllabics Final Middle Dot\", '.'),\n+    ('\u1427', \"Canadian Syllabics Final Middle Dot\", '.'),\n+    ('\uff0e', \"Fullwidth Full Stop\", '.'),\n+    ('\u3002', \"Ideographic Full Stop\", '.'),\n+    ('\ufe12', \"Presentation Form For Vertical Ideographic Full Stop\", '.'),\n+\n     ('\u055d', \"Armenian Comma\", '\\''),\n     ('\uff07', \"Fullwidth Apostrophe\", '\\''),\n     ('\u2018', \"Left Single Quotation Mark\", '\\''),\n@@ -96,15 +144,18 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u2035', \"Reversed Prime\", '\\''),\n     ('\u055a', \"Armenian Apostrophe\", '\\''),\n     ('\u05f3', \"Hebrew Punctuation Geresh\", '\\''),\n+    ('`', \"Greek Accent\", '\\''),\n     ('\u1fef', \"Greek Varia\", '\\''),\n     ('\uff40', \"Fullwidth Grave Accent\", '\\''),\n+    ('\u00b4', \"Acute Accent\", '\\''),\n     ('\u0384', \"Greek Tonos\", '\\''),\n     ('\u1ffd', \"Greek Oxia\", '\\''),\n     ('\u1fbd', \"Greek Koronis\", '\\''),\n     ('\u1fbf', \"Greek Psili\", '\\''),\n     ('\u1ffe', \"Greek Dasia\", '\\''),\n     ('\u02b9', \"Modifier Letter Prime\", '\\''),\n     ('\u0374', \"Greek Numeral Sign\", '\\''),\n+    ('\u02c8', \"Modifier Letter Vertical Line\", '\\''),\n     ('\u02ca', \"Modifier Letter Acute Accent\", '\\''),\n     ('\u02cb', \"Modifier Letter Grave Accent\", '\\''),\n     ('\u02f4', \"Modifier Letter Middle Grave Accent\", '\\''),\n@@ -116,6 +167,12 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u05d9', \"Hebrew Letter Yod\", '\\''),\n     ('\u07f4', \"Nko High Tone Apostrophe\", '\\''),\n     ('\u07f5', \"Nko Low Tone Apostrophe\", '\\''),\n+    ('\u144a', \"Canadian Syllabics West-Cree P\", '\\''),\n+    ('\u16cc', \"Runic Letter Short-Twig-Sol S\", '\\''),\n+    ('\ud81b\udf51', \"Miao Sign Aspiration\", '\\''),\n+    ('\ud81b\udf52', \"Miao Sign Reformed Voicing\", '\\''),\n+\n+    ('\u1cd3', \"Vedic Sign Nihshvasa\", '\"'),\n     ('\uff02', \"Fullwidth Quotation Mark\", '\"'),\n     ('\u201c', \"Left Double Quotation Mark\", '\"'),\n     ('\u201d', \"Right Double Quotation Mark\", '\"'),\n@@ -132,12 +189,15 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u05f2', \"Hebrew Ligature Yiddish Double Yod\", '\"'),\n     ('\u275e', \"Heavy Double Comma Quotation Mark Ornament\", '\"'),\n     ('\u275d', \"Heavy Double Turned Comma Quotation Mark Ornament\", '\"'),\n+\n+    ('\uff08', \"Fullwidth Left Parenthesis\", '('),\n     ('\u2768', \"Medium Left Parenthesis Ornament\", '('),\n     ('\ufd3e', \"Ornate Left Parenthesis\", '('),\n-    ('\uff08', \"Fullwidth Left Parenthesis\", '('),\n+\n+    ('\uff09', \"Fullwidth Right Parenthesis\", ')'),\n     ('\u2769', \"Medium Right Parenthesis Ornament\", ')'),\n     ('\ufd3f', \"Ornate Right Parenthesis\", ')'),\n-    ('\uff09', \"Fullwidth Right Parenthesis\", ')'),\n+\n     ('\uff3b', \"Fullwidth Left Square Bracket\", '['),\n     ('\u2772', \"Light Left Tortoise Shell Bracket Ornament\", '['),\n     ('\u300c', \"Left Corner Bracket\", '['),\n@@ -147,6 +207,7 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u3016', \"Left White Lenticular Bracket\", '['),\n     ('\u3018', \"Left White Tortoise Shell Bracket\", '['),\n     ('\u301a', \"Left White Square Bracket\", '['),\n+\n     ('\uff3d', \"Fullwidth Right Square Bracket\", ']'),\n     ('\u2773', \"Light Right Tortoise Shell Bracket Ornament\", ']'),\n     ('\u300d', \"Right Corner Bracket\", ']'),\n@@ -156,49 +217,94 @@ const UNICODE_ARRAY: &'static [(char, &'static str, char)] = &[\n     ('\u3017', \"Right White Lenticular Bracket\", ']'),\n     ('\u3019', \"Right White Tortoise Shell Bracket\", ']'),\n     ('\u301b', \"Right White Square Bracket\", ']'),\n+\n     ('\u2774', \"Medium Left Curly Bracket Ornament\", '{'),\n+    ('\ud834\udd14', \"Musical Symbol Brace\", '{'),\n+    ('\uff5b', \"Fullwidth Left Curly Bracket\", '{'),\n+\n     ('\u2775', \"Medium Right Curly Bracket Ornament\", '}'),\n+    ('\uff5d', \"Fullwidth Right Curly Bracket\", '}'),\n+\n     ('\u204e', \"Low Asterisk\", '*'),\n     ('\u066d', \"Arabic Five Pointed Star\", '*'),\n     ('\u2217', \"Asterisk Operator\", '*'),\n+    ('\ud800\udf1f', \"Old Italic Letter Ess\", '*'),\n+    ('\uff0a', \"Fullwidth Asterisk\", '*'),\n+\n     ('\u1735', \"Philippine Single Punctuation\", '/'),\n     ('\u2041', \"Caret Insertion Point\", '/'),\n     ('\u2215', \"Division Slash\", '/'),\n     ('\u2044', \"Fraction Slash\", '/'),\n     ('\u2571', \"Box Drawings Light Diagonal Upper Right To Lower Left\", '/'),\n     ('\u27cb', \"Mathematical Rising Diagonal\", '/'),\n     ('\u29f8', \"Big Solidus\", '/'),\n-    ('\u31d3', \"Cjk Stroke Sp\", '/'),\n+    ('\ud834\ude3a', \"Greek Instrumental Notation Symbol-47\", '/'),\n+    ('\u31d3', \"CJK Stroke Sp\", '/'),\n     ('\u3033', \"Vertical Kana Repeat Mark Upper Half\", '/'),\n-    ('\u4e3f', \"Cjk Unified Ideograph-4E3F\", '/'),\n+    ('\u2cc6', \"Coptic Capital Letter Old Coptic Esh\", '/'),\n+    ('\u30ce', \"Katakana Letter No\", '/'),\n+    ('\u4e3f', \"CJK Unified Ideograph-4E3F\", '/'),\n     ('\u2f03', \"Kangxi Radical Slash\", '/'),\n+    ('\uff0f', \"Fullwidth Solidus\", '/'),\n+\n     ('\uff3c', \"Fullwidth Reverse Solidus\", '\\\\'),\n     ('\ufe68', \"Small Reverse Solidus\", '\\\\'),\n     ('\u2216', \"Set Minus\", '\\\\'),\n     ('\u27cd', \"Mathematical Falling Diagonal\", '\\\\'),\n     ('\u29f5', \"Reverse Solidus Operator\", '\\\\'),\n     ('\u29f9', \"Big Reverse Solidus\", '\\\\'),\n+    ('\u29f9', \"Greek Vocal Notation Symbol-16\", '\\\\'),\n+    ('\u29f9', \"Greek Instrumental Symbol-48\", '\\\\'),\n+    ('\u31d4', \"CJK Stroke D\", '\\\\'),\n+    ('\u4e36', \"CJK Unified Ideograph-4E36\", '\\\\'),\n+    ('\u2f02', \"Kangxi Radical Dot\", '\\\\'),\n     ('\u3001', \"Ideographic Comma\", '\\\\'),\n     ('\u30fd', \"Katakana Iteration Mark\", '\\\\'),\n-    ('\u31d4', \"Cjk Stroke D\", '\\\\'),\n-    ('\u4e36', \"Cjk Unified Ideograph-4E36\", '\\\\'),\n-    ('\u2f02', \"Kangxi Radical Dot\", '\\\\'),\n+\n     ('\ua778', \"Latin Small Letter Um\", '&'),\n+    ('\uff06', \"Fullwidth Ampersand\", '&'),\n+\n+    ('\u16ed', \"Runic Cros Punctuation\", '+'),\n+    ('\u2795', \"Heavy Plus Sign\", '+'),\n+    ('\ud800\ude9b', \"Lycian Letter H\", '+'),\n     ('\ufb29', \"Hebrew Letter Alternative Plus Sign\", '+'),\n+    ('\uff0b', \"Fullwidth Plus Sign\", '+'),\n+\n     ('\u2039', \"Single Left-Pointing Angle Quotation Mark\", '<'),\n     ('\u276e', \"Heavy Left-Pointing Angle Quotation Mark Ornament\", '<'),\n     ('\u02c2', \"Modifier Letter Left Arrowhead\", '<'),\n+    ('\ud834\ude36', \"Greek Instrumental Symbol-40\", '<'),\n+    ('\u1438', \"Canadian Syllabics Pa\", '<'),\n+    ('\u16b2', \"Runic Letter Kauna\", '<'),\n+    ('\u276c', \"Medium Left-Pointing Angle Bracket Ornament\", '<'),\n+    ('\u27e8', \"Mathematical Left Angle Bracket\", '<'),\n+    ('\u2329', \"Left-Pointing Angle Bracket\", '<'),\n     ('\u3008', \"Left Angle Bracket\", '<'),\n+    ('\u31db', \"CJK Stroke Pd\", '<'),\n+    ('\u304f', \"Hiragana Letter Ku\", '<'),\n+    ('\ud847\udfe8', \"CJK Unified Ideograph-21FE8\", '<'),\n     ('\u300a', \"Left Double Angle Bracket\", '<'),\n+    ('\uff1c', \"Fullwidth Less-Than Sign\", '<'),\n+\n+    ('\u1400', \"Canadian Syllabics Hyphen\", '='),\n+    ('\u2e40', \"Double Hyphen\", '='),\n+    ('\u30a0', \"Katakana-Hiragana Double Hyphen\", '='),\n     ('\ua4ff', \"Lisu Punctuation Full Stop\", '='),\n+    ('\uff1d', \"Fullwidth Equals Sign\", '='),\n+\n     ('\u203a', \"Single Right-Pointing Angle Quotation Mark\", '>'),\n     ('\u276f', \"Heavy Right-Pointing Angle Quotation Mark Ornament\", '>'),\n     ('\u02c3', \"Modifier Letter Right Arrowhead\", '>'),\n+    ('\ud834\ude37', \"Greek Instrumental Symbol-42\", '>'),\n+    ('\u1433', \"Canadian Syllabics Po\", '>'),\n+    ('\ud81b\udf3f', \"Miao Letter Archaic Zza\", '>'),\n+    ('\u276d', \"Medium Right-Pointing Angle Bracket Ornament\", '>'),\n+    ('\u27e9', \"Mathematical Right Angle Bracket\", '>'),\n+    ('\u232a', \"Right-Pointing Angle Bracket\", '>'),\n     ('\u3009', \"Right Angle Bracket\", '>'),\n     ('\u300b', \"Right Double Angle Bracket\", '>'),\n-    ('\u2cba', \"Coptic Capital Letter Dialect-P Ni\", '-'),\n-    ('\u0241', \"Latin Capital Letter Glottal Stop\", '?'),\n-    ('\u2cc6', \"Coptic Capital Letter Old Coptic Esh\", '/'), ];\n+    ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'), ];\n+\n \n const ASCII_ARRAY: &'static [(char, &'static str)] = &[\n     (' ', \"Space\"),"}, {"sha": "df1bae523a5c9492681f4dc974ef648540bbf68f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -5526,12 +5526,11 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parse a static item from a foreign module\n+    /// Parse a static item from a foreign module.\n+    /// Assumes that the `static` keyword is already parsed.\n     fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n                                  -> PResult<'a, ForeignItem> {\n-        self.expect_keyword(keywords::Static)?;\n         let mutbl = self.eat_keyword(keywords::Mut);\n-\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n@@ -6005,19 +6004,23 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n         let visibility = self.parse_visibility(false)?;\n \n-        if self.check_keyword(keywords::Static) {\n-            // FOREIGN STATIC ITEM\n+        // FOREIGN STATIC ITEM\n+        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n+        if self.check_keyword(keywords::Static) || self.token.is_keyword(keywords::Const) {\n+            if self.token.is_keyword(keywords::Const) {\n+                self.diagnostic()\n+                    .struct_span_err(self.span, \"extern items cannot be `const`\")\n+                    .span_suggestion(self.span, \"instead try using\", \"static\".to_owned())\n+                    .emit();\n+            }\n+            self.bump(); // `static` or `const`\n             return Ok(Some(self.parse_item_foreign_static(visibility, lo, attrs)?));\n         }\n+        // FOREIGN FUNCTION ITEM\n         if self.check_keyword(keywords::Fn) {\n-            // FOREIGN FUNCTION ITEM\n             return Ok(Some(self.parse_item_foreign_fn(visibility, lo, attrs)?));\n         }\n \n-        if self.check_keyword(keywords::Const) {\n-            return Err(self.span_fatal(self.span, \"extern items cannot be `const`\"));\n-        }\n-\n         // FIXME #5668: this will occur for a macro invocation:\n         match self.parse_macro_use_or_failure(attrs, true, false, lo, visibility)? {\n             Some(item) => {"}, {"sha": "16b06424c92fc847acb0ec7b6ea2ab0f63319ca1", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -529,7 +529,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Actually builds the expression which the format_args! block will be\n     /// expanded to\n-    fn into_expr(mut self) -> P<ast::Expr> {\n+    fn into_expr(self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n         let mut counts = Vec::new();\n         let mut pats = Vec::new();"}, {"sha": "5eab81dd28fc4bc526eb41ef7fcd8ba609a8f562", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -89,6 +89,7 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     use syntax::ext::source_util::*;\n     register! {\n         line: expand_line,\n+        __rust_unstable_column: expand_column_gated,\n         column: expand_column,\n         file: expand_file,\n         stringify: expand_stringify,"}, {"sha": "ba0c4fbe173bbb8dde137ebc5ea7d42d4f841036", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -278,10 +278,12 @@ static Optional<Reloc::Model> fromRust(LLVMRustRelocMode RustReloc) {\n     return Reloc::RWPI;\n   case LLVMRustRelocMode::ROPIRWPI:\n     return Reloc::ROPI_RWPI;\n-#endif\n+#else\n   default:\n-    llvm_unreachable(\"Bad RelocModel.\");\n+    break;\n+#endif\n   }\n+  llvm_unreachable(\"Bad RelocModel.\");\n }\n \n #if LLVM_RUSTLLVM"}, {"sha": "f42d1006bf5c1c18a3bdfe4539ce84879b54e68c", "filename": "src/test/compile-fail-fulldeps/proc-macro/attributes-included.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,6 +11,7 @@\n // aux-build:attributes-included.rs\n \n #![feature(proc_macro, rustc_attrs)]\n+#![warn(unused)]\n \n extern crate attributes_included;\n "}, {"sha": "ccaf01932d46684001261207044f9f76f23c7751", "filename": "src/test/compile-fail/E0010.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2FE0010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2FE0010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0010.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(box_syntax)]\n+#![allow(warnings)]\n \n const CON : Box<i32> = box 0; //~ ERROR E0010\n                               //~| NOTE allocation not allowed in"}, {"sha": "c7d5665cd2c58482f12a3ff9a35cd77ddc1a3bdd", "filename": "src/test/compile-fail/E0394.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2FE0394.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2FE0394.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0394.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n static A: u32 = 0;\n static B: u32 = A;\n //~^ ERROR E0394"}, {"sha": "cb9fb973a01939e332b0bd3cc310be2c6312ac56", "filename": "src/test/compile-fail/bad-lint-cap2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap2.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -10,6 +10,7 @@\n \n // compile-flags: --cap-lints deny\n \n+#![warn(unused)]\n #![deny(warnings)]\n \n use std::option; //~ ERROR"}, {"sha": "c9394954c5fbd3485c99e74abf0a6e8b9f3d1ce6", "filename": "src/test/compile-fail/bad-lint-cap3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-lint-cap3.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -10,6 +10,7 @@\n \n // compile-flags: --cap-lints warn\n \n+#![warn(unused)]\n #![deny(warnings)]\n #![feature(rustc_attrs)]\n "}, {"sha": "3642add32597b781cf416664c77ff0e6a418820b", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -12,6 +12,7 @@\n \n // gate-test-drop_types_in_const\n \n+#![allow(warnings)]\n #![feature(box_syntax)]\n \n use std::marker;"}, {"sha": "0fd41a17b2c9c0554a141b0695196be76ff9537f", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,7 +11,7 @@\n // Evaluation of constants in refutable patterns goes through\n // different compiler control-flow paths.\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, warnings)]\n \n use std::fmt;\n use std::{i8, i16, i32, i64, isize};"}, {"sha": "bc944948f3d8b846eb0a6e0208921680a0d52f1a", "filename": "src/test/compile-fail/const-match-pattern-arm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fconst-match-pattern-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fconst-match-pattern-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-match-pattern-arm.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n const x: bool = match Some(true) {\n     Some(value) => true,\n     //~^ ERROR: constant contains unimplemented expression type [E0019]"}, {"sha": "360895d30b0b7e39866ea4ba4e754299dbf1fb84", "filename": "src/test/compile-fail/feature-gate-dropck-ugeh.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dropck-ugeh.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -28,7 +28,6 @@ struct Foo<T> { data: Vec<T> }\n impl<T> Drop for Foo<T> {\n     #[unsafe_destructor_blind_to_params] // This is the UGEH attribute\n     //~^ ERROR unsafe_destructor_blind_to_params has been replaced\n-    //~^^ WARN: use of deprecated attribute\n     fn drop(&mut self) { }\n }\n "}, {"sha": "d8f9f5543e43964f7d84cc541190849d92f1ed99", "filename": "src/test/compile-fail/issue-14227.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(safe_extern_statics, warnings)]\n+\n extern {\n     pub static symbol: ();\n }"}, {"sha": "08c3f7a7c15451a6d5dcc647f555bc563f386b9c", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(safe_extern_statics)]\n+\n mod Y {\n     pub type X = usize;\n     extern {"}, {"sha": "cde1bbbe4927a427d1603026ce0ad771bf8a165f", "filename": "src/test/compile-fail/issue-17450.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-17450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-17450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17450.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(dead_code)]\n+#![allow(dead_code, warnings)]\n \n static mut x: isize = 3;\n static mut y: isize = unsafe {"}, {"sha": "4857c2fb446b519e9097ea3154705d5f571c4397", "filename": "src/test/compile-fail/issue-17718-const-naming.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-naming.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #[deny(warnings)]\n \n const foo: isize = 3;"}, {"sha": "8e0df283cdbebe839936be20c1dd597c7635ea12", "filename": "src/test/compile-fail/issue-17718-references.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n struct Struct { a: usize }\n \n const C: usize = 1;"}, {"sha": "5996c8e5438783fe2defdf81e9da1e12f9821386", "filename": "src/test/compile-fail/issue-18937.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18937.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -26,7 +26,7 @@ trait A<'a> {\n }\n \n impl<'a> A<'a> for B {\n-    fn foo<F>(&mut self, f: F) //~ ERROR E0276\n+    fn foo<F>(&mut self, f: F) //~ ERROR impl has stricter\n         //~^ WARNING future release\n         where F: fmt::Debug + 'static,\n     {"}, {"sha": "057c99f930510aa9a6add482b10a499f1b550991", "filename": "src/test/compile-fail/issue-28075.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28075.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -12,7 +12,7 @@\n \n // aux-build:lint_stability.rs\n \n-#![allow(unused_imports)]\n+#![allow(warnings)]\n \n extern crate lint_stability;\n "}, {"sha": "7d2541966a4810a3a2f6bebc0fb2b860e364e825", "filename": "src/test/compile-fail/issue-28113.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(warnings)]\n+\n const X: u8 =\n     || -> u8 { 5 }()\n     //~^ ERROR calls in constants are limited to constant functions"}, {"sha": "3c4d6b42b503dfc72956de56d5fd5346878ff5ec", "filename": "src/test/compile-fail/issue-28324.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(safe_extern_statics)]\n+\n extern {\n     static error_message_count: u32;\n }"}, {"sha": "d1af39a6c1872497cf27b4236535e6e76dcf6024", "filename": "src/test/compile-fail/issue-30730.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-30730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-30730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30730.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #![deny(warnings)] //~ NOTE: lint level defined here\n use std::thread;\n //~^ ERROR: unused import"}, {"sha": "d5733f98193874735004ab2e09bfdf5dc1514176", "filename": "src/test/compile-fail/issue-37515.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-37515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-37515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37515.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(rustc_attrs)]\n+#![warn(unused)]\n \n type Z = for<'x> Send;\n //~^ WARN type alias is never used"}, {"sha": "bd32317ae78086b3e709bd9a19a1859aed2f35b9", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(box_syntax)]\n #![feature(const_fn)]\n+#![allow(warnings)]\n \n use std::cell::RefCell;\n "}, {"sha": "9f84190ea18a1f3e8bb598ae2a53b89e1f038aba", "filename": "src/test/compile-fail/lint-removed-allow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-removed-allow.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,7 +11,8 @@\n // No warnings about removed lint when\n // allow(renamed_and_removed_lints)\n \n+#![allow(renamed_and_removed_lints)]\n+\n #[deny(raw_pointer_derive)]\n-#[allow(renamed_and_removed_lints)]\n #[deny(unused_variables)]\n fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "e1da5086612fd7d5eacb4bd77bce414550ada9e6", "filename": "src/test/compile-fail/lint-removed-cmdline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-removed-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-removed-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-removed-cmdline.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -16,5 +16,7 @@\n // error-pattern:lint raw_pointer_derive has been removed\n // error-pattern:requested on the command line with `-D raw_pointer_derive`\n \n+#![warn(unused)]\n+\n #[deny(warnings)]\n fn main() { let unused = (); }"}, {"sha": "ae010b64bfdfc75cfe945d07385ae90293638bbd", "filename": "src/test/compile-fail/lint-renamed-allow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-renamed-allow.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,7 +11,8 @@\n // No warnings about renamed lint when\n // allow(renamed_and_removed_lints)\n \n+#![allow(renamed_and_removed_lints)]\n+\n #[deny(unknown_features)]\n-#[allow(renamed_and_removed_lints)]\n #[deny(unused)]\n fn main() { let unused = (); } //~ ERROR unused"}, {"sha": "8443518b3f5681c682c188f1e98905768b50bb2b", "filename": "src/test/compile-fail/lint-stability-deprecated.rs", "status": "modified", "additions": 111, "deletions": 111, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -13,9 +13,9 @@\n // aux-build:stability_cfg1.rs\n // aux-build:stability_cfg2.rs\n \n-#![deny(deprecated)]\n+#![warn(deprecated)]\n #![allow(dead_code)]\n-#![feature(staged_api, test_feature)]\n+#![feature(staged_api, test_feature, rustc_attrs)]\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -32,41 +32,41 @@ mod cross_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-\n-        deprecated_unstable(); //~ ERROR use of deprecated item\n-        foo.method_deprecated_unstable(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        deprecated(); //~ WARN use of deprecated item\n+        foo.method_deprecated(); //~ WARN use of deprecated item\n+        Foo::method_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+\n+        deprecated_text(); //~ WARN use of deprecated item: text\n+        foo.method_deprecated_text(); //~ WARN use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+\n+        deprecated_unstable(); //~ WARN use of deprecated item\n+        foo.method_deprecated_unstable(); //~ WARN use of deprecated item\n+        Foo::method_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo>::method_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+\n+        deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        foo.method_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        Foo::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::method_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n \n         unstable();\n         foo.method_unstable();\n@@ -106,30 +106,30 @@ mod cross_crate {\n \n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n-        //~^ ERROR use of deprecated item\n+        //~^ WARN use of deprecated item\n \n-        let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+        let _ = DeprecatedStruct { //~ WARN use of deprecated item\n+            i: 0 //~ WARN use of deprecated item\n         };\n         let _ = DeprecatedUnstableStruct {\n-            //~^ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+            //~^ WARN use of deprecated item\n+            i: 0 //~ WARN use of deprecated item\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n-        let _ = DeprecatedUnstableUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated item\n+        let _ = DeprecatedUnstableUnitStruct; //~ WARN use of deprecated item\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n-        let _ = Enum::DeprecatedUnstableVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated item\n+        let _ = Enum::DeprecatedUnstableVariant; //~ WARN use of deprecated item\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n-        let _ = DeprecatedUnstableTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated item\n+        let _ = DeprecatedUnstableTupleStruct (1); //~ WARN use of deprecated item\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n \n@@ -138,28 +138,28 @@ mod cross_crate {\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n-        macro_test_arg!(deprecated_unstable_text()); //~ ERROR use of deprecated item: text\n-        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n+        macro_test_arg!(deprecated_text()); //~ WARN use of deprecated item: text\n+        macro_test_arg!(deprecated_unstable_text()); //~ WARN use of deprecated item: text\n+        macro_test_arg!(macro_test_arg!(deprecated_text())); //~ WARN use of deprecated item: text\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated_unstable(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_unstable_text(&foo); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -175,10 +175,10 @@ mod cross_crate {\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_unstable(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_unstable_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_unstable(); //~ WARN use of deprecated item\n+        foo.trait_deprecated_unstable_text(); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -187,9 +187,9 @@ mod cross_crate {\n     struct S;\n \n     impl UnstableTrait for S { }\n-    impl DeprecatedTrait for S {} //~ ERROR use of deprecated item: text\n+    impl DeprecatedTrait for S {} //~ WARN use of deprecated item: text\n     trait LocalTrait : UnstableTrait { }\n-    trait LocalTrait2 : DeprecatedTrait { } //~ ERROR use of deprecated item: text\n+    trait LocalTrait2 : DeprecatedTrait { } //~ WARN use of deprecated item: text\n \n     impl Trait for S {\n         fn trait_stable(&self) {}\n@@ -208,7 +208,7 @@ mod inheritance {\n         stable_mod::unstable();\n         stable_mod::stable();\n \n-        unstable_mod::deprecated(); //~ ERROR use of deprecated item\n+        unstable_mod::deprecated(); //~ WARN use of deprecated item\n         unstable_mod::unstable();\n \n         let _ = Unstable::UnstableVariant;\n@@ -330,23 +330,23 @@ mod this_crate {\n         type Foo = MethodTester;\n         let foo = MethodTester;\n \n-        deprecated(); //~ ERROR use of deprecated item\n-        foo.method_deprecated(); //~ ERROR use of deprecated item\n-        Foo::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::method_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-\n-        deprecated_text(); //~ ERROR use of deprecated item: text\n-        foo.method_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Foo::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::method_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        deprecated(); //~ WARN use of deprecated item\n+        foo.method_deprecated(); //~ WARN use of deprecated item\n+        Foo::method_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::method_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+\n+        deprecated_text(); //~ WARN use of deprecated item: text\n+        foo.method_deprecated_text(); //~ WARN use of deprecated item: text\n+        Foo::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::method_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n \n         unstable();\n         foo.method_unstable();\n@@ -385,34 +385,34 @@ mod this_crate {\n         <Foo as Trait>::trait_stable_text(&foo);\n \n         let _ = DeprecatedStruct {\n-            //~^ ERROR use of deprecated item\n-            i: 0 //~ ERROR use of deprecated item\n+            //~^ WARN use of deprecated item\n+            i: 0 //~ WARN use of deprecated item\n         };\n         let _ = UnstableStruct { i: 0 };\n         let _ = StableStruct { i: 0 };\n \n-        let _ = DeprecatedUnitStruct; //~ ERROR use of deprecated item\n+        let _ = DeprecatedUnitStruct; //~ WARN use of deprecated item\n         let _ = UnstableUnitStruct;\n         let _ = StableUnitStruct;\n \n-        let _ = Enum::DeprecatedVariant; //~ ERROR use of deprecated item\n+        let _ = Enum::DeprecatedVariant; //~ WARN use of deprecated item\n         let _ = Enum::UnstableVariant;\n         let _ = Enum::StableVariant;\n \n-        let _ = DeprecatedTupleStruct (1); //~ ERROR use of deprecated item\n+        let _ = DeprecatedTupleStruct (1); //~ WARN use of deprecated item\n         let _ = UnstableTupleStruct (1);\n         let _ = StableTupleStruct (1);\n     }\n \n     fn test_method_param<Foo: Trait>(foo: Foo) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        Trait::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        <Foo as Trait>::trait_deprecated(&foo); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n-        Trait::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n-        <Foo as Trait>::trait_deprecated_text(&foo); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        Trait::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        <Foo as Trait>::trait_deprecated(&foo); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n+        Trait::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n+        <Foo as Trait>::trait_deprecated_text(&foo); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         Trait::trait_unstable(&foo);\n         <Foo>::trait_unstable(&foo);\n@@ -428,8 +428,8 @@ mod this_crate {\n     }\n \n     fn test_method_object(foo: &Trait) {\n-        foo.trait_deprecated(); //~ ERROR use of deprecated item\n-        foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n+        foo.trait_deprecated(); //~ WARN use of deprecated item\n+        foo.trait_deprecated_text(); //~ WARN use of deprecated item: text\n         foo.trait_unstable();\n         foo.trait_unstable_text();\n         foo.trait_stable();\n@@ -439,15 +439,15 @@ mod this_crate {\n     #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n     fn test_fn_body() {\n         fn fn_in_body() {}\n-        fn_in_body(); //~ ERROR use of deprecated item: text\n+        fn_in_body(); //~ WARN use of deprecated item: text\n     }\n \n     impl MethodTester {\n         #[unstable(feature = \"test_feature\", issue = \"0\")]\n         #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n         fn test_method_body(&self) {\n             fn fn_in_body() {}\n-            fn_in_body(); //~ ERROR use of deprecated item: text\n+            fn_in_body(); //~ WARN use of deprecated item: text\n         }\n     }\n \n@@ -459,9 +459,9 @@ mod this_crate {\n \n     struct S;\n \n-    impl DeprecatedTrait for S { } //~ ERROR use of deprecated item\n+    impl DeprecatedTrait for S { } //~ WARN use of deprecated item\n \n-    trait LocalTrait : DeprecatedTrait { } //~ ERROR use of deprecated item\n+    trait LocalTrait : DeprecatedTrait { } //~ WARN use of deprecated item\n }\n \n-fn main() {}\n+#[rustc_error] fn main() {} //~ ERROR: compilation successful"}, {"sha": "5593499758346d37c7cd001c55e95cd0579e2716", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -9,16 +9,18 @@\n // except according to those terms.\n //\n \n-#![deny(overflowing_literals)]\n-#![deny(const_err)]\n+#![warn(overflowing_literals)]\n+#![warn(const_err)]\n+#![feature(rustc_attrs)]\n \n #[allow(unused_variables)]\n-fn main() {\n-    let x2: i8 = --128; //~ error: literal out of range for i8\n-    //~^ error: attempt to negate with overflow\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    let x2: i8 = --128; //~ warn: literal out of range for i8\n+    //~^ warn: attempt to negate with overflow\n \n-    let x = -3.40282357e+38_f32; //~ error: literal out of range for f32\n-    let x =  3.40282357e+38_f32; //~ error: literal out of range for f32\n-    let x = -1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n-    let x =  1.7976931348623159e+308_f64; //~ error: literal out of range for f64\n+    let x = -3.40282357e+38_f32; //~ warn: literal out of range for f32\n+    let x =  3.40282357e+38_f32; //~ warn: literal out of range for f32\n+    let x = -1.7976931348623159e+308_f64; //~ warn: literal out of range for f64\n+    let x =  1.7976931348623159e+308_f64; //~ warn: literal out of range for f64\n }"}, {"sha": "26d00755da33b0f28d45971354fff0fc0f16cfc4", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -47,6 +47,26 @@ fn main() {\n     let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n     fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n \n+    let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n+    *a = 4;\n+\n+    let mut a = 5;\n+    let mut b = (&mut a,);\n+    *b.0 = 4; //~^ ERROR: variable does not need to be mutable\n+\n+    let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n+    let mut f = || {\n+      *x += 1;\n+    };\n+    f();\n+\n+    fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n+        &mut arg[..] //~^ ERROR: variable does not need to be mutable\n+    }\n+\n+    let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n+    v.push(());\n+\n     // positive cases\n     let mut a = 2;\n     a = 3;"}, {"sha": "1d947684792dd9a78964528e836dedbc15ab5d13", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #![allow(dead_code)]\n #![deny(non_snake_case)]\n "}, {"sha": "d056d6be806f7828b62aa20fbea8905e2155ba29", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types, trivial_numeric_casts)]"}, {"sha": "1e0cc0f5357fb6f7cce36fddfb8ab5130cb32567", "filename": "src/test/compile-fail/never-assign-dead-code.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnever-assign-dead-code.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -10,12 +10,12 @@\n \n // Test that an assignment of type ! makes the rest of the block dead code.\n \n-#![feature(never_type)]\n-#![deny(unused, unreachable_code)]\n+#![feature(never_type, rustc_attrs)]\n+#![warn(unused)]\n \n-fn main() {\n-    let x: ! = panic!(\"aah\"); //~ ERROR unused\n-    drop(x); //~ ERROR unreachable\n-    //~^ ERROR unreachable\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    let x: ! = panic!(\"aah\"); //~ WARN unused\n+    drop(x); //~ WARN unreachable\n+    //~^ WARN unreachable\n }\n-"}, {"sha": "4d41f8ba47d014334ed82e4e7e3ba01024df2bb8", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,6 +11,7 @@\n #![feature(associated_consts)]\n #![feature(conservative_impl_trait)]\n #![feature(decl_macro)]\n+#![allow(warnings)]\n \n mod m {\n     fn priv_fn() {}"}, {"sha": "a5581664f741859baa603fd7c7b140a73f850d60", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,6 +11,7 @@\n // aux-build:private-inferred-type.rs\n \n #![feature(conservative_impl_trait)]\n+#![allow(warnings)]\n \n extern crate private_inferred_type as ext;\n "}, {"sha": "abc92c86eec6aefddfc8ade1bee69e92f565445c", "filename": "src/test/compile-fail/rust-unstable-column-gated.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Frust-unstable-column-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Frust-unstable-column-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frust-unstable-column-gated.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    println!(\"{}\", __rust_unstable_column!());\n+    //~^ERROR the __rust_unstable_column macro is unstable\n+}"}, {"sha": "a855b08f06691f8603411e21c6d921ffe4b0a1fc", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -14,6 +14,7 @@\n \n static mut a: Box<isize> = box 3;\n //~^ ERROR allocations are not allowed in statics\n-//~^^ ERROR destructors in statics are an unstable feature\n+//~| ERROR destructors in statics are an unstable feature\n+//~| WARN: constant evaluation error\n \n fn main() {}"}, {"sha": "ad568b41fcbf3622bf8acbaf47925e2d8eed3c95", "filename": "src/test/compile-fail/struct-path-self-type-mismatch.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-self-type-mismatch.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -20,17 +20,15 @@ impl Bar for Foo<i32> {\n }\n \n impl<T> Foo<T> {\n-    fn new<U>(u: U) -> Foo<U> {\n+    fn new<U>(u: U) -> Foo<U> { //~ NOTE expected `Foo<U>` because of return type\n         Self {\n         //~^ ERROR mismatched types\n-        //~| expected type parameter, found a different type parameter\n-        //~| expected type `Foo<U>`\n-        //~| found type `Foo<T>`\n+        //~| NOTE expected type parameter, found a different type parameter\n+        //~| NOTE expected type `Foo<U>`\n             inner: u\n             //~^ ERROR mismatched types\n-            //~| expected type parameter, found a different type parameter\n-            //~| expected type `T`\n-            //~| found type `U`\n+            //~| NOTE expected type parameter, found a different type parameter\n+            //~| NOTE expected type `T`\n         }\n     }\n }"}, {"sha": "46ea4a06a3bd8a41a9dcf2ecbc950bedb5eda83b", "filename": "src/test/compile-fail/unreachable-try-pattern.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Funreachable-try-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fcompile-fail%2Funreachable-try-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funreachable-try-pattern.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(never_type)]\n-#![deny(unreachable_code)]\n-#![deny(unreachable_patterns)]\n+#![feature(never_type, rustc_attrs)]\n+#![warn(unreachable_code)]\n+#![warn(unreachable_patterns)]\n \n enum Void {}\n \n@@ -26,8 +26,8 @@ fn bar(x: Result<!, i32>) -> Result<u32, i32> {\n \n fn foo(x: Result<!, i32>) -> Result<u32, i32> {\n     let y = (match x { Ok(n) => Ok(n as u32), Err(e) => Err(e) })?;\n-    //~^ ERROR unreachable pattern\n-    //~| ERROR unreachable expression\n+    //~^ WARN unreachable pattern\n+    //~| WARN unreachable expression\n     Ok(y)\n }\n \n@@ -37,11 +37,12 @@ fn qux(x: Result<u32, Void>) -> Result<u32, i32> {\n \n fn vom(x: Result<u32, Void>) -> Result<u32, i32> {\n     let y = (match x { Ok(n) => Ok(n), Err(e) => Err(e) })?;\n-    //~^ ERROR unreachable pattern\n+    //~^ WARN unreachable pattern\n     Ok(y)\n }\n \n-fn main() {\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n     let _ = bar(Err(123));\n     let _ = foo(Err(123));\n     let _ = qux(Ok(123));"}, {"sha": "152ddfb193fc5d590cc87f237f04de9d80ee1aa6", "filename": "src/test/run-pass/issue-43057.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Frun-pass%2Fissue-43057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Frun-pass%2Fissue-43057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43057.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+macro_rules! column {\n+    ($i:ident) => {\n+        $i\n+    };\n+}\n+\n+fn foo() -> ! {\n+    panic!();\n+}\n+\n+fn main() {}"}, {"sha": "2c9d07f190d265a537189c195b175c8733d14216", "filename": "src/test/rustdoc/nul-error.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Frustdoc%2Fnul-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Frustdoc%2Fnul-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fnul-error.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/fn.foo.html '//code' ''\n+#[doc = \"Attempted to pass a string containing `\\0`\"]\n+pub fn foo() {}"}, {"sha": "19ce2362134543b90d49bb515a0823bb2534eddb", "filename": "src/test/ui-fulldeps/lint-plugin-cmdline-allow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -14,6 +14,7 @@\n // compile-flags: -A test-lint\n \n #![feature(plugin)]\n+#![warn(unused)]\n #![plugin(lint_plugin_test)]\n \n fn lintme() { }"}, {"sha": "7c9c4e9903908d0741c4b0f9d25dbe56b14bab97", "filename": "src/test/ui-fulldeps/lint-plugin-cmdline-allow.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint-plugin-cmdline-allow.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,8 +1,13 @@\n warning: function is never used: `lintme`\n-  --> $DIR/lint-plugin-cmdline-allow.rs:19:1\n+  --> $DIR/lint-plugin-cmdline-allow.rs:20:1\n    |\n-19 | fn lintme() { }\n+20 | fn lintme() { }\n    | ^^^^^^^^^^^^^^^\n    |\n-   = note: #[warn(dead_code)] on by default\n+note: lint level defined here\n+  --> $DIR/lint-plugin-cmdline-allow.rs:17:9\n+   |\n+17 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(dead_code)] implied by #[warn(unused)]\n "}, {"sha": "20c7dc416f3bb339851af79389f335581b014b89", "filename": "src/test/ui/block-result/block-must-not-have-result-res.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fblock-must-not-have-result-res.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/block-must-not-have-result-res.rs:15:9\n    |\n+14 |     fn drop(&mut self) {\n+   |                        - expected `()` because of default return type\n 15 |         true //~  ERROR mismatched types\n    |         ^^^^ expected (), found bool\n    |"}, {"sha": "cd8c28cd2cfa8eb0716d78ff675ff7b63b7b819e", "filename": "src/test/ui/block-result/issue-13624.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-13624.rs:17:5\n    |\n+16 |   pub fn get_enum_struct_variant() -> () {\n+   |                                       -- expected `()` because of return type\n 17 |     Enum::EnumStructVariant { x: 1, y: 2, z: 3 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum `a::Enum`\n    |"}, {"sha": "c6113ae0c9f6016a6f518dd53be2d2c013601af3", "filename": "src/test/ui/block-result/issue-22645.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fissue-22645.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fissue-22645.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-22645.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,6 +11,9 @@ error[E0277]: the trait bound `{integer}: Scalar` is not satisfied\n error[E0308]: mismatched types\n   --> $DIR/issue-22645.rs:25:3\n    |\n+23 | fn main() {\n+   |           - expected `()` because of default return type\n+24 |   let b = Bob + 3.5;\n 25 |   b + 3 //~ ERROR E0277\n    |   ^^^^^ expected (), found struct `Bob`\n    |"}, {"sha": "29dbd5a8cf5999db93ca037d544dd2510f7ba668", "filename": "src/test/ui/block-result/issue-5500.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fissue-5500.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fblock-result%2Fissue-5500.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-5500.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5500.rs:12:5\n    |\n+11 | fn main() {\n+   |           - expected `()` because of default return type\n 12 |     &panic!()\n    |     ^^^^^^^^^ expected (), found reference\n    |"}, {"sha": "108d7e1ea22a15c17cf916ec8188c37168e0423f", "filename": "src/test/ui/check_match/issue-43253.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(exclusive_range_pattern)]\n+#![warn(unreachable_patterns)]\n \n fn main() {\n     // These cases should generate no warning.\n@@ -48,4 +49,4 @@ fn main() {\n         9...9 => {},\n         _ => {},\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a1cb3963914c9a42e98628f986ed424f8883eb92", "filename": "src/test/ui/check_match/issue-43253.stderr", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,20 +1,24 @@\n warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:36:9\n+  --> $DIR/issue-43253.rs:37:9\n    |\n-36 |         9 => {},\n+37 |         9 => {},\n    |         ^\n    |\n-   = note: #[warn(unreachable_patterns)] on by default\n+note: lint level defined here\n+  --> $DIR/issue-43253.rs:12:9\n+   |\n+12 | #![warn(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n \n warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:42:9\n+  --> $DIR/issue-43253.rs:43:9\n    |\n-42 |         8...9 => {},\n+43 |         8...9 => {},\n    |         ^^^^^\n \n warning: unreachable pattern\n-  --> $DIR/issue-43253.rs:48:9\n+  --> $DIR/issue-43253.rs:49:9\n    |\n-48 |         9...9 => {},\n+49 |         9...9 => {},\n    |         ^^^^^\n "}, {"sha": "e58251c846f8dae0da64f9c7f019431fd423ff24", "filename": "src/test/ui/compare-method/proj-outlives-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,4 +1,4 @@\n-error[E0276]: impl has stricter requirements than trait\n+error: impl has stricter requirements than trait\n   --> $DIR/proj-outlives-region.rs:19:5\n    |\n 14 |     fn foo() where T: 'a;"}, {"sha": "95db68fea5cf73c534715e841758a84560b663dc", "filename": "src/test/ui/compare-method/region-unrelated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,4 +1,4 @@\n-error[E0276]: impl has stricter requirements than trait\n+error: impl has stricter requirements than trait\n   --> $DIR/region-unrelated.rs:19:5\n    |\n 14 |     fn foo() where T: 'a;"}, {"sha": "a77d7b118956653e8b5df8dca22188f27a3b21c2", "filename": "src/test/ui/extern-const.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fextern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fextern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-const.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z continue-parse-after-error\n+\n+extern \"C\" {\n+    const C: u8; //~ ERROR extern items cannot be `const`\n+}\n+\n+fn main() {\n+    let x = C;\n+}"}, {"sha": "c5a3149e85a7a70737fe14f45311de9cc64ccda4", "filename": "src/test/ui/extern-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fextern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fextern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern-const.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,8 @@\n+error: extern items cannot be `const`\n+  --> $DIR/extern-const.rs:14:5\n+   |\n+14 |     const C: u8; //~ ERROR extern items cannot be `const`\n+   |     ^^^^^ help: instead try using: `static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "5aea5f2ca06423823f51bbee89a1b0f0a66de551", "filename": "src/test/ui/lint/fn_must_use.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Ffn_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Ffn_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffn_must_use.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![warn(unused_must_use)]\n+\n+struct MyStruct {\n+    n: usize\n+}\n+\n+impl MyStruct {\n+    #[must_use]\n+    fn need_to_use_this_method_value(&self) -> usize {\n+        self.n\n+    }\n+}\n+\n+#[must_use=\"it's important\"]\n+fn need_to_use_this_value() -> bool {\n+    false\n+}\n+\n+fn main() {\n+    need_to_use_this_value();\n+\n+    let m = MyStruct { n: 2 };\n+    m.need_to_use_this_method_value();\n+}"}, {"sha": "20eb7452aea7163b200f252f09482f150b44ffff", "filename": "src/test/ui/lint/fn_must_use.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Ffn_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Ffn_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffn_must_use.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,18 @@\n+warning: unused return value of `need_to_use_this_value` which must be used: it's important\n+  --> $DIR/fn_must_use.rs:30:5\n+   |\n+30 |     need_to_use_this_value();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/fn_must_use.rs:11:9\n+   |\n+11 | #![warn(unused_must_use)]\n+   |         ^^^^^^^^^^^^^^^\n+\n+warning: unused return value of `MyStruct::need_to_use_this_method_value` which must be used\n+  --> $DIR/fn_must_use.rs:33:5\n+   |\n+33 |     m.need_to_use_this_method_value();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "a79dacbc1c959c4388a8a597436f7f20fed30980", "filename": "src/test/ui/lint/outer-forbid.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -16,7 +16,13 @@\n \n #![forbid(unused, non_snake_case)]\n \n-#[allow(unused, unused_variables, bad_style)]\n+#[allow(unused_variables)]\n+fn foo() {}\n+\n+#[allow(unused)]\n+fn bar() {}\n+\n+#[allow(bad_style)]\n fn main() {\n     println!(\"hello forbidden world\")\n }"}, {"sha": "67a1f4f88adc64767addf31df7bcc2501c40674f", "filename": "src/test/ui/lint/outer-forbid.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,29 +1,29 @@\n-error[E0453]: allow(unused) overruled by outer forbid(unused)\n+error[E0453]: allow(unused_variables) overruled by outer forbid(unused)\n   --> $DIR/outer-forbid.rs:19:9\n    |\n 17 | #![forbid(unused, non_snake_case)]\n    |           ------ `forbid` level set here\n 18 | \n-19 | #[allow(unused, unused_variables, bad_style)]\n-   |         ^^^^^^ overruled by previous forbid\n+19 | #[allow(unused_variables)]\n+   |         ^^^^^^^^^^^^^^^^ overruled by previous forbid\n \n-error[E0453]: allow(unused_variables) overruled by outer forbid(unused)\n-  --> $DIR/outer-forbid.rs:19:17\n+error[E0453]: allow(unused) overruled by outer forbid(unused)\n+  --> $DIR/outer-forbid.rs:22:9\n    |\n 17 | #![forbid(unused, non_snake_case)]\n    |           ------ `forbid` level set here\n-18 | \n-19 | #[allow(unused, unused_variables, bad_style)]\n-   |                 ^^^^^^^^^^^^^^^^ overruled by previous forbid\n+...\n+22 | #[allow(unused)]\n+   |         ^^^^^^ overruled by previous forbid\n \n error[E0453]: allow(bad_style) overruled by outer forbid(non_snake_case)\n-  --> $DIR/outer-forbid.rs:19:35\n+  --> $DIR/outer-forbid.rs:25:9\n    |\n 17 | #![forbid(unused, non_snake_case)]\n    |                   -------------- `forbid` level set here\n-18 | \n-19 | #[allow(unused, unused_variables, bad_style)]\n-   |                                   ^^^^^^^^^ overruled by previous forbid\n+...\n+25 | #[allow(bad_style)]\n+   |         ^^^^^^^^^ overruled by previous forbid\n \n error: aborting due to 3 previous errors\n "}, {"sha": "8c63d7d6f91c5267666d4f9a8d979e2132cd4cf4", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:26:5\n    |\n+25 | fn a() -> Foo {\n+   |           --- expected `Foo` because of return type\n 26 |     Some(Foo { bar: 1 })\n    |     ^^^^^^^^^^^^^^^^^^^^ expected struct `Foo`, found enum `std::option::Option`\n    |\n@@ -10,6 +12,8 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:30:5\n    |\n+29 | fn a2() -> Foo {\n+   |            --- expected `Foo` because of return type\n 30 |     Ok(Foo { bar: 1})\n    |     ^^^^^^^^^^^^^^^^^ expected struct `Foo`, found enum `std::result::Result`\n    |\n@@ -19,6 +23,8 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:34:5\n    |\n+33 | fn b() -> Option<Foo> {\n+   |           ----------- expected `std::option::Option<Foo>` because of return type\n 34 |     Foo { bar: 1 }\n    |     ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found struct `Foo`\n    |\n@@ -28,6 +34,8 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:38:5\n    |\n+37 | fn c() -> Result<Foo, Bar> {\n+   |           ---------------- expected `std::result::Result<Foo, Bar>` because of return type\n 38 |     Foo { bar: 1 }\n    |     ^^^^^^^^^^^^^^ expected enum `std::result::Result`, found struct `Foo`\n    |\n@@ -37,6 +45,9 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:49:5\n    |\n+41 | fn d() -> X<X<String, String>, String> {\n+   |           ---------------------------- expected `X<X<std::string::String, std::string::String>, std::string::String>` because of return type\n+...\n 49 |     x\n    |     ^ expected struct `std::string::String`, found integral variable\n    |\n@@ -46,6 +57,9 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/abridged.rs:60:5\n    |\n+52 | fn e() -> X<X<String, String>, String> {\n+   |           ---------------------------- expected `X<X<std::string::String, std::string::String>, std::string::String>` because of return type\n+...\n 60 |     x\n    |     ^ expected struct `std::string::String`, found integral variable\n    |"}, {"sha": "367a2560155588aa7ab644e28cd91e445a997b3b", "filename": "src/test/ui/path-lookahead.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fpath-lookahead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fpath-lookahead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpath-lookahead.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -10,6 +10,8 @@\n \n // run-pass\n \n+#![warn(unused)]\n+\n // Parser test for #37765\n \n fn with_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `with_parens`"}, {"sha": "9936a1eb81e2a9fdd39a3a24b25e6ea7dfad46e9", "filename": "src/test/ui/path-lookahead.stderr", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fpath-lookahead.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fpath-lookahead.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpath-lookahead.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,26 +1,31 @@\n warning: unnecessary parentheses around `return` value\n-  --> $DIR/path-lookahead.rs:16:10\n+  --> $DIR/path-lookahead.rs:18:10\n    |\n-16 |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n+18 |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(unused_parens)] on by default\n \n warning: function is never used: `with_parens`\n-  --> $DIR/path-lookahead.rs:15:1\n+  --> $DIR/path-lookahead.rs:17:1\n    |\n-15 | / fn with_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `with_parens`\n-16 | |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n-17 | | }\n+17 | / fn with_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `with_parens`\n+18 | |   return (<T as ToString>::to_string(&arg)); //~WARN unnecessary parentheses around `return` value\n+19 | | }\n    | |_^\n    |\n-   = note: #[warn(dead_code)] on by default\n+note: lint level defined here\n+  --> $DIR/path-lookahead.rs:13:9\n+   |\n+13 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(dead_code)] implied by #[warn(unused)]\n \n warning: function is never used: `no_parens`\n-  --> $DIR/path-lookahead.rs:19:1\n+  --> $DIR/path-lookahead.rs:21:1\n    |\n-19 | / fn no_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `no_parens`\n-20 | |   return <T as ToString>::to_string(&arg);\n-21 | | }\n+21 | / fn no_parens<T: ToString>(arg: T) -> String { //~WARN function is never used: `no_parens`\n+22 | |   return <T as ToString>::to_string(&arg);\n+23 | | }\n    | |_^\n "}, {"sha": "9f4562fe297180fac5c8f86ca0321a64ebec014c", "filename": "src/test/ui/reachable/expr_unary.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_unary.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,8 +1,20 @@\n+error: unreachable expression\n+  --> $DIR/expr_unary.rs:18:28\n+   |\n+18 |     let x: ! = ! { return; 22 };\n+   |                            ^^\n+   |\n+note: lint level defined here\n+  --> $DIR/expr_unary.rs:14:9\n+   |\n+14 | #![deny(unreachable_code)]\n+   |         ^^^^^^^^^^^^^^^^\n+\n error[E0600]: cannot apply unary operator `!` to type `!`\n   --> $DIR/expr_unary.rs:18:16\n    |\n 18 |     let x: ! = ! { return; 22 };\n    |                ^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "f59d2845108fbd93807eb638106ad5d603beac63", "filename": "src/test/ui/span/issue-24690.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -11,10 +11,13 @@\n //! A test to ensure that helpful `note` messages aren't emitted more often\n //! than necessary.\n \n-// Although there are three errors, we should only get two \"lint level defined\n+#![feature(rustc_attrs)]\n+\n+// Although there are three warnings, we should only get two \"lint level defined\n // here\" notes pointing at the `warnings` span, one for each error type.\n-#![deny(warnings)]\n+#![warn(unused)]\n \n+#[rustc_error]\n fn main() {\n     let theTwo = 2;\n     let theOtherTwo = 2;"}, {"sha": "4f1c870d87457b4448dab4f73b0737b7d3be4afa", "filename": "src/test/ui/span/issue-24690.stderr", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,34 +1,37 @@\n-error: variable `theTwo` should have a snake case name such as `the_two`\n-  --> $DIR/issue-24690.rs:19:9\n+warning: unused variable: `theOtherTwo`\n+  --> $DIR/issue-24690.rs:23:9\n    |\n-19 |     let theTwo = 2;\n-   |         ^^^^^^\n+23 |     let theOtherTwo = 2;\n+   |         ^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/issue-24690.rs:16:9\n+  --> $DIR/issue-24690.rs:18:9\n    |\n-16 | #![deny(warnings)]\n-   |         ^^^^^^^^\n-   = note: #[deny(non_snake_case)] implied by #[deny(warnings)]\n+18 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(unused_variables)] implied by #[warn(unused)]\n \n-error: variable `theOtherTwo` should have a snake case name such as `the_other_two`\n-  --> $DIR/issue-24690.rs:20:9\n+warning: variable `theTwo` should have a snake case name such as `the_two`\n+  --> $DIR/issue-24690.rs:22:9\n    |\n-20 |     let theOtherTwo = 2;\n-   |         ^^^^^^^^^^^\n+22 |     let theTwo = 2;\n+   |         ^^^^^^\n+   |\n+   = note: #[warn(non_snake_case)] on by default\n \n-error: unused variable: `theOtherTwo`\n-  --> $DIR/issue-24690.rs:20:9\n+warning: variable `theOtherTwo` should have a snake case name such as `the_other_two`\n+  --> $DIR/issue-24690.rs:23:9\n    |\n-20 |     let theOtherTwo = 2;\n+23 |     let theOtherTwo = 2;\n    |         ^^^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/issue-24690.rs:16:9\n-   |\n-16 | #![deny(warnings)]\n-   |         ^^^^^^^^\n-   = note: #[deny(unused_variables)] implied by #[deny(warnings)]\n \n-error: aborting due to 3 previous errors\n+error: compilation successful\n+  --> $DIR/issue-24690.rs:21:1\n+   |\n+21 | / fn main() {\n+22 | |     let theTwo = 2;\n+23 | |     let theOtherTwo = 2;\n+24 | |     println!(\"{}\", theTwo);\n+25 | | }\n+   | |_^\n "}, {"sha": "b7aae39c4692710c349a1b60586d84a60070fcdd", "filename": "src/test/ui/span/macro-span-replacement.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n+\n macro_rules! m {\n     ($a:tt $b:tt) => {\n         $b $a;"}, {"sha": "af03aa6a369082662b86b4618923a3362f0c82b4", "filename": "src/test/ui/span/macro-span-replacement.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-span-replacement.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,11 +1,16 @@\n warning: struct is never used: `S`\n-  --> $DIR/macro-span-replacement.rs:13:9\n+  --> $DIR/macro-span-replacement.rs:15:9\n    |\n-13 |         $b $a;\n+15 |         $b $a;\n    |         ^^^^^^\n ...\n-18 |     m!(S struct);\n+20 |     m!(S struct);\n    |     ------------- in this macro invocation\n    |\n-   = note: #[warn(dead_code)] on by default\n+note: lint level defined here\n+  --> $DIR/macro-span-replacement.rs:11:9\n+   |\n+11 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(dead_code)] implied by #[warn(unused)]\n "}, {"sha": "66536b29c0298dfa9ae0de164a8cfb0d9948f6cf", "filename": "src/test/ui/span/multispan-import-lint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![warn(unused)]\n+\n use std::cmp::{Eq, Ord, min, PartialEq, PartialOrd};\n \n fn main() {"}, {"sha": "1fecdea7d0d06a2db513b990df57170d47a98e6c", "filename": "src/test/ui/span/multispan-import-lint.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultispan-import-lint.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1,8 +1,13 @@\n warning: unused imports: `Eq`, `Ord`, `PartialEq`, `PartialOrd`\n-  --> $DIR/multispan-import-lint.rs:11:16\n+  --> $DIR/multispan-import-lint.rs:13:16\n    |\n-11 | use std::cmp::{Eq, Ord, min, PartialEq, PartialOrd};\n+13 | use std::cmp::{Eq, Ord, min, PartialEq, PartialOrd};\n    |                ^^  ^^^       ^^^^^^^^^  ^^^^^^^^^^\n    |\n-   = note: #[warn(unused_imports)] on by default\n+note: lint level defined here\n+  --> $DIR/multispan-import-lint.rs:11:9\n+   |\n+11 | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: #[warn(unused_imports)] implied by #[warn(unused)]\n "}, {"sha": "5c1bd668ac649a1227851a65ae36b960857be949", "filename": "src/test/ui/trait-method-private.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Ftrait-method-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Ftrait-method-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-method-private.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod inner {\n+    pub trait Bar {\n+        fn method(&self);\n+    }\n+\n+    pub struct Foo;\n+\n+    impl Foo {\n+        fn method(&self) {}\n+    }\n+\n+    impl Bar for Foo {\n+        fn method(&self) {}\n+    }\n+}\n+\n+fn main() {\n+    let foo = inner::Foo;\n+    foo.method();\n+}"}, {"sha": "c7a7b689edc515dc40ffe124ee75075c0c624fcb", "filename": "src/test/ui/trait-method-private.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Ftrait-method-private.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftest%2Fui%2Ftrait-method-private.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-method-private.stderr?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -0,0 +1,12 @@\n+error[E0624]: method `method` is private\n+  --> $DIR/trait-method-private.rs:29:9\n+   |\n+29 |     foo.method();\n+   |         ^^^^^^\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following trait is implemented but not in scope, perhaps add a `use` for it:\n+           candidate #1: `use inner::Bar;`\n+\n+error: aborting due to previous error\n+"}, {"sha": "7704f7b1fd52607104cc7fdc435d636c9de1fe90", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1 +1 @@\n-Subproject commit 305bc25d5e105e84ffe261655b46cf74570f6e5b\n+Subproject commit 7704f7b1fd52607104cc7fdc435d636c9de1fe90"}, {"sha": "769748c63c02ddb52000fc01d3d3e65909e6dea3", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8aa595e6d159bfb5e0293659b69e0edc457a468/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b8aa595e6d159bfb5e0293659b69e0edc457a468", "patch": "@@ -1156,9 +1156,21 @@ actual:\\n\\\n     fn compile_test(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let link_args = vec![\"-L\".to_owned(),\n-                             aux_dir.to_str().unwrap().to_owned()];\n-        let args = self.make_compile_args(link_args,\n+        let mut extra_args = vec![\"-L\".to_owned(),\n+                                  aux_dir.to_str().unwrap().to_owned()];\n+        match self.config.mode {\n+            CompileFail | Ui => {\n+                // compile-fail and ui tests tend to have tons of unused code as\n+                // it's just testing various pieces of the compile, but we don't\n+                // want to actually assert warnings about all this code. Instead\n+                // let's just ignore unused code warnings by defaults and tests\n+                // can turn it back on if needed.\n+                extra_args.push(\"-A\".to_owned());\n+                extra_args.push(\"unused\".to_owned());\n+            }\n+            _ => {}\n+        }\n+        let args = self.make_compile_args(extra_args,\n                                           &self.testpaths.file,\n                                           TargetLocation::ThisFile(self.make_exe_name()));\n         self.compose_and_run_compiler(args, None)"}]}