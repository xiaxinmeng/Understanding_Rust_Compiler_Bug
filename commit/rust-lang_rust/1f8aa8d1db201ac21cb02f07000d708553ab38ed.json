{"sha": "1f8aa8d1db201ac21cb02f07000d708553ab38ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOGFhOGQxZGIyMDFhYzIxY2IwMmYwNzAwMGQ3MDg1NTNhYjM4ZWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-05T09:25:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-05T09:25:57Z"}, "message": "Merge pull request #163 from solson/rustup\n\nRustup to rustc 1.19.0-nightly (2d4ed8e0c 2017-05-03)", "tree": {"sha": "98cb02dce6c0675f0c22f17a10f13cb813858933", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98cb02dce6c0675f0c22f17a10f13cb813858933"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f8aa8d1db201ac21cb02f07000d708553ab38ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f8aa8d1db201ac21cb02f07000d708553ab38ed", "html_url": "https://github.com/rust-lang/rust/commit/1f8aa8d1db201ac21cb02f07000d708553ab38ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f8aa8d1db201ac21cb02f07000d708553ab38ed/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8c8813f87f1cd06fba865b3cb9d8cb4d43dcea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8c8813f87f1cd06fba865b3cb9d8cb4d43dcea5", "html_url": "https://github.com/rust-lang/rust/commit/f8c8813f87f1cd06fba865b3cb9d8cb4d43dcea5"}, {"sha": "5f67ba76f5bc6956267f59caa4328c70cc95dc77", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f67ba76f5bc6956267f59caa4328c70cc95dc77", "html_url": "https://github.com/rust-lang/rust/commit/5f67ba76f5bc6956267f59caa4328c70cc95dc77"}], "stats": {"total": 107, "additions": 32, "deletions": 75}, "files": [{"sha": "441c35f5513e058923169f8ba0d071ad7e8144be", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -4,7 +4,7 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate test;\n \n-use self::miri::{eval_main, run_mir_passes};\n+use self::miri::eval_main;\n use self::rustc::session::Session;\n use self::rustc_driver::{driver, CompilerCalls, Compilation};\n use std::cell::RefCell;\n@@ -55,7 +55,6 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n                 .expect(\"no main or start function found\");\n             let entry_def_id = tcx.map.local_def_id(entry_node_id);\n \n-            run_mir_passes(tcx);\n             let memory_size = 100*1024*1024; // 100MB\n             let step_limit = 1000_000;\n             let stack_limit = 100;"}, {"sha": "3f0a6f778b4254d06a41c088d5e58279c9c937e8", "filename": "src/bin/miri.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -74,7 +74,6 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n     state.session.abort_if_errors();\n \n     let tcx = state.tcx.unwrap();\n-    miri::run_mir_passes(tcx);\n     let limits = resource_limits_from_attributes(state);\n \n     if std::env::args().any(|arg| arg == \"--test\") {\n@@ -94,15 +93,13 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n             fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n         }\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n-    } else {\n-        if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n-            let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-            miri::eval_main(tcx, entry_def_id, limits);\n+    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n+        let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n+        miri::eval_main(tcx, entry_def_id, limits);\n \n-            state.session.abort_if_errors();\n-        } else {\n-            println!(\"no main function found, assuming auxiliary build\");\n-        }\n+        state.session.abort_if_errors();\n+    } else {\n+        println!(\"no main function found, assuming auxiliary build\");\n     }\n }\n "}, {"sha": "b9aa499015a8f4008a1b61c65e25ffa29871f20a", "filename": "src/eval_context.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -1,4 +1,3 @@\n-use std::cell::Ref;\n use std::collections::HashMap;\n use std::fmt::Write;\n \n@@ -24,8 +23,6 @@ use memory::{Memory, Pointer};\n use operator;\n use value::{PrimVal, PrimValKind, Value};\n \n-pub type MirRef<'tcx> = Ref<'tcx, mir::Mir<'tcx>>;\n-\n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     pub(crate) tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -48,7 +45,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     pub(crate) steps_remaining: u64,\n \n     /// Drop glue for arrays and slices\n-    pub(crate) seq_drop_glue: MirRef<'tcx>,\n+    pub(crate) seq_drop_glue: &'tcx mir::Mir<'tcx>,\n }\n \n /// A stack frame.\n@@ -58,7 +55,7 @@ pub struct Frame<'tcx> {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     /// The MIR for the function called on this frame.\n-    pub mir: MirRef<'tcx>,\n+    pub mir: &'tcx mir::Mir<'tcx>,\n \n     /// The def_id and substs of the current function\n     pub instance: ty::Instance<'tcx>,\n@@ -302,16 +299,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             DUMMY_SP,\n         );\n         let seq_drop_glue = tcx.alloc_mir(seq_drop_glue);\n-        // Perma-borrow MIR from shims to prevent mutation.\n-        ::std::mem::forget(seq_drop_glue.borrow());\n         EvalContext {\n             tcx,\n             memory: Memory::new(&tcx.data_layout, limits.memory_size),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n-            seq_drop_glue: seq_drop_glue.borrow(),\n+            seq_drop_glue: seq_drop_glue,\n         }\n     }\n \n@@ -385,10 +380,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty.is_sized(self.tcx, &self.tcx.empty_parameter_environment(), DUMMY_SP)\n     }\n \n-    pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, MirRef<'tcx>> {\n+    pub fn load_mir(&self, instance: ty::InstanceDef<'tcx>) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n-            ty::InstanceDef::Item(def_id) => self.tcx.maybe_item_mir(def_id).ok_or_else(|| EvalError::NoMirFor(self.tcx.item_path_str(def_id))),\n+            ty::InstanceDef::Item(def_id) => self.tcx.maybe_optimized_mir(def_id).ok_or_else(|| EvalError::NoMirFor(self.tcx.item_path_str(def_id))),\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n     }\n@@ -450,7 +445,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         span: codemap::Span,\n-        mir: MirRef<'tcx>,\n+        mir: &'tcx mir::Mir<'tcx>,\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n@@ -1028,7 +1023,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n+        self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n@@ -1445,8 +1440,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    pub(super) fn mir(&self) -> MirRef<'tcx> {\n-        Ref::clone(&self.frame().mir)\n+    pub(super) fn mir(&self) -> &'tcx mir::Mir<'tcx> {\n+        self.frame().mir\n     }\n \n     pub(super) fn substs(&self) -> &'tcx Substs<'tcx> {\n@@ -1734,32 +1729,6 @@ fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n     err.emit();\n }\n \n-pub fn run_mir_passes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut passes = ::rustc::mir::transform::Passes::new();\n-    passes.push_hook(Box::new(::rustc_mir::transform::dump_mir::DumpMir));\n-    passes.push_pass(Box::new(::rustc_mir::transform::no_landing_pads::NoLandingPads));\n-    passes.push_pass(Box::new(::rustc_mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\")));\n-\n-    // From here on out, regions are gone.\n-    passes.push_pass(Box::new(::rustc_mir::transform::erase_regions::EraseRegions));\n-\n-    passes.push_pass(Box::new(::rustc_mir::transform::add_call_guards::AddCallGuards));\n-    passes.push_pass(Box::new(::rustc_borrowck::ElaborateDrops));\n-    passes.push_pass(Box::new(::rustc_mir::transform::no_landing_pads::NoLandingPads));\n-    passes.push_pass(Box::new(::rustc_mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\")));\n-\n-    // No lifetime analysis based on borrowing can be done from here on out.\n-    passes.push_pass(Box::new(::rustc_mir::transform::instcombine::InstCombine::new()));\n-    passes.push_pass(Box::new(::rustc_mir::transform::deaggregator::Deaggregator));\n-    passes.push_pass(Box::new(::rustc_mir::transform::copy_prop::CopyPropagation));\n-\n-    passes.push_pass(Box::new(::rustc_mir::transform::simplify::SimplifyLocals));\n-    passes.push_pass(Box::new(::rustc_mir::transform::add_call_guards::AddCallGuards));\n-    passes.push_pass(Box::new(::rustc_mir::transform::dump_mir::Marker(\"PreMiri\")));\n-\n-    passes.run_passes(tcx);\n-}\n-\n // TODO(solson): Upstream these methods into rustc::ty::layout.\n \n pub(super) trait IntegerExt {"}, {"sha": "f373606218c738cd7e5739d755831a0cf06d7cc2", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -9,10 +9,8 @@ extern crate log;\n extern crate log_settings;\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_borrowck;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n-extern crate rustc_mir;\n extern crate syntax;\n \n // From crates.io.\n@@ -40,7 +38,6 @@ pub use eval_context::{\n     ResourceLimits,\n     StackPopCleanup,\n     eval_main,\n-    run_mir_passes,\n };\n \n pub use lvalue::{"}, {"sha": "9660b8f4eec8605e74364ab49fe6dd285a5b3072", "filename": "src/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -399,6 +399,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n+        self.monomorphize(lvalue.ty(self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n }"}, {"sha": "4f599f8ba14fbcb06a04c1060cc18dc9f5fc956e", "filename": "src/step.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -2,8 +2,6 @@\n //!\n //! The main entry point is the `step` method.\n \n-use std::cell::Ref;\n-\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n@@ -12,7 +10,7 @@ use rustc::ty::layout::Layout;\n use rustc::ty::{subst, self};\n \n use error::{EvalResult, EvalError};\n-use eval_context::{EvalContext, StackPopCleanup, MirRef};\n+use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n use syntax::codemap::Span;\n@@ -47,7 +45,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 span: stmt.source_info.span,\n                 instance: self.frame().instance,\n                 ecx: self,\n-                mir: Ref::clone(&mir),\n+                mir,\n                 new_constants: &mut new,\n             }.visit_statement(block, stmt, mir::Location { block, statement_index: stmt_id });\n             if new? == 0 {\n@@ -64,7 +62,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             span: terminator.source_info.span,\n             instance: self.frame().instance,\n             ecx: self,\n-            mir: Ref::clone(&mir),\n+            mir,\n             new_constants: &mut new,\n         }.visit_terminator(block, terminator, mir::Location { block, statement_index: stmt_id });\n         if new? == 0 {\n@@ -142,7 +140,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     span: Span,\n     ecx: &'a mut EvalContext<'b, 'tcx>,\n-    mir: MirRef<'tcx>,\n+    mir: &'tcx mir::Mir<'tcx>,\n     instance: ty::Instance<'tcx>,\n     new_constants: &'a mut EvalResult<'tcx, u64>,\n }\n@@ -209,8 +207,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 if self.ecx.globals.contains_key(&cid) {\n                     return;\n                 }\n-                let mir = Ref::clone(&self.mir);\n-                let mir = Ref::map(mir, |mir| &mir.promoted[index]);\n+                let mir = &self.mir.promoted[index];\n                 self.try(|this| {\n                     let ty = this.ecx.monomorphize(mir.return_ty, this.instance.substs);\n                     this.ecx.globals.insert(cid, Global::uninitialized(ty));"}, {"sha": "93dfe408e31a989f88145a01ef2bcb2cbbe267f6", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -53,13 +53,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => bug!(\"expected thin ptr, got {:?}\", arg),\n                 };\n                 arg = Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(n as u128));\n-                ::eval_context::MirRef::clone(&self.seq_drop_glue)\n+                self.seq_drop_glue\n             },\n             ty::TySlice(elem) => {\n                 instance.substs = self.tcx.mk_substs([\n                     Kind::from(elem),\n                 ].iter().cloned());\n-                ::eval_context::MirRef::clone(&self.seq_drop_glue)\n+                self.seq_drop_glue\n             },\n             _ => self.load_mir(instance.def)?,\n         };"}, {"sha": "78b2a2f3ce252d09ca0dc78c17143e6b041c14ae", "filename": "tests/compiletest.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f8aa8d1db201ac21cb02f07000d708553ab38ed/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f8aa8d1db201ac21cb02f07000d708553ab38ed/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=1f8aa8d1db201ac21cb02f07000d708553ab38ed", "patch": "@@ -5,7 +5,7 @@ use std::io::Write;\n \n fn compile_fail(sysroot: &Path) {\n     let flags = format!(\"--sysroot {} -Dwarnings\", sysroot.to_str().expect(\"non utf8 path\"));\n-    for_all_targets(&sysroot, |target| {\n+    for_all_targets(sysroot, |target| {\n         let mut config = compiletest::default_config();\n         config.host_rustcflags = Some(flags.clone());\n         config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n@@ -79,8 +79,8 @@ fn compile_test() {\n         .expect(\"rustc not found for -vV\")\n         .stdout;\n     let host = std::str::from_utf8(&host).expect(\"sysroot is not utf8\");\n-    let host = host.split(\"\\nhost: \").skip(1).next().expect(\"no host: part in rustc -vV\");\n-    let host = host.split(\"\\n\").next().expect(\"no \\n after host\");\n+    let host = host.split(\"\\nhost: \").nth(1).expect(\"no host: part in rustc -vV\");\n+    let host = host.split('\\n').next().expect(\"no \\n after host\");\n \n     if let Ok(path) = std::env::var(\"MIRI_RUSTC_TEST\") {\n         let mut mir_not_found = Vec::new();\n@@ -148,10 +148,8 @@ fn compile_test() {\n                                 abi.push(text[abi_s.len()..end].to_string());\n                             } else if text.starts_with(limit_s) {\n                                 limits.push(text[limit_s.len()..end].to_string());\n-                            } else {\n-                                if text.find(\"aborting\").is_none() {\n-                                    failed.push(text[..end].to_string());\n-                                }\n+                            } else if text.find(\"aborting\").is_none() {\n+                                failed.push(text[..end].to_string());\n                             }\n                         }\n                         writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n@@ -196,10 +194,10 @@ fn compile_test() {\n         panic!(\"ran miri on rustc test suite. Test failing for convenience\");\n     } else {\n         run_pass();\n-        for_all_targets(&sysroot, |target| {\n+        for_all_targets(sysroot, |target| {\n             miri_pass(\"tests/run-pass\", &target, host);\n         });\n-        compile_fail(&sysroot);\n+        compile_fail(sysroot);\n     }\n }\n \n@@ -218,7 +216,7 @@ fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n     let mut current = v.next();\n     'outer: while let Some(current_val) = current {\n         let mut n = 1;\n-        while let Some(next) = v.next() {\n+        for next in &mut v {\n             if next == current_val {\n                 n += 1;\n             } else {"}]}