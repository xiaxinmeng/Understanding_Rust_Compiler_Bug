{"sha": "bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiY2IxM2RhODhmN2E0YjI1NTA2ZWM4NWYyZjE3MGU2Zjc4ZDVhNTg=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-07-07T22:50:02Z"}, "committer": {"name": "Jared Roesch", "email": "jroesch@MacBook.home", "date": "2015-07-26T02:57:57Z"}, "message": "Implement Default TyParam fallback\n\nThis patch allows type parameter defaults to influence type inference. This is a possible breaking change since it effects the way type inference works and will have different behavior when mixing defaults and literal fallback.", "tree": {"sha": "6a872075699ea6996313f46ed03983da066c423a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a872075699ea6996313f46ed03983da066c423a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "html_url": "https://github.com/rust-lang/rust/commit/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7276d8b7613c81c09feeec3bf94d47c4a5174bc8", "html_url": "https://github.com/rust-lang/rust/commit/7276d8b7613c81c09feeec3bf94d47c4a5174bc8"}], "stats": {"total": 385, "additions": 340, "deletions": 45}, "files": [{"sha": "5339464503b3e3b21435fd0d35c89176440878ed", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 72, "deletions": 6, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -95,6 +95,9 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     normalize: bool,\n \n     err_count_on_creation: usize,\n+\n+    // Default Type Parameter fallbacks\n+    pub defaults: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -350,7 +353,8 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n         fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(errors_will_be_reported)),\n         normalize: false,\n-        err_count_on_creation: tcx.sess.err_count()\n+        err_count_on_creation: tcx.sess.err_count(),\n+        defaults: RefCell::new(FnvHashMap()),\n     }\n }\n \n@@ -653,6 +657,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn unsolved_variables(&self) -> Vec<ty::Ty<'tcx>> {\n+        let mut variables = Vec::new();\n+\n+        let unbound_ty_vars = self.type_variables\n+                                  .borrow()\n+                                  .unsolved_variables()\n+                                  .into_iter().map(|t| self.tcx.mk_var(t));\n+\n+        let unbound_int_vars = self.int_unification_table\n+                                   .borrow_mut()\n+                                   .unsolved_variables()\n+                                   .into_iter().map(|v| self.tcx.mk_int_var(v));\n+\n+        let unbound_float_vars = self.float_unification_table\n+                                     .borrow_mut()\n+                                     .unsolved_variables()\n+                                     .into_iter().map(|v| self.tcx.mk_float_var(v));\n+\n+        variables.extend(unbound_ty_vars);\n+        variables.extend(unbound_int_vars);\n+        variables.extend(unbound_float_vars);\n+        return variables;\n+    }\n+\n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n                       -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n@@ -996,16 +1024,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n+    pub fn type_vars_for_defs(&self,\n+                              defs: &[ty::TypeParameterDef<'tcx>])\n+                              -> Vec<ty::Ty<'tcx>> {\n+        let mut vars = Vec::with_capacity(defs.len());\n+\n+        for def in defs.iter() {\n+            let ty_var = self.next_ty_var();\n+            match def.default {\n+                None => {},\n+                Some(default) => { self.defaults.borrow_mut().insert(ty_var, default); }\n+            }\n+            vars.push(ty_var)\n+        }\n+\n+        vars\n+    }\n+\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n                                      generics: &ty::Generics<'tcx>)\n                                      -> subst::Substs<'tcx>\n     {\n-        let type_params =\n-            generics.types.map(\n-                |_| self.next_ty_var());\n+        let mut type_params = subst::VecPerParamSpace::empty();\n+\n+        for space in subst::ParamSpace::all().iter() {\n+            type_params.replace(*space, self.type_vars_for_defs(generics.types.get_slice(*space)))\n+        }\n+\n         let region_params =\n             generics.regions.map(\n                 |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n@@ -1027,8 +1075,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::SelfSpace) == 0);\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n-        let type_parameter_count = generics.types.len(subst::TypeSpace);\n-        let type_parameters = self.next_ty_vars(type_parameter_count);\n+        let type_parameter_defs = generics.types.get_slice(subst::TypeSpace);\n+        let type_parameters = self.type_vars_for_defs(type_parameter_defs);\n \n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n@@ -1268,6 +1316,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_and_explain_type_error(trace, err);\n     }\n \n+    pub fn report_conflicting_default_types(&self,\n+                                   span: Span,\n+                                   expected: Ty<'tcx>,\n+                                   actual: Ty<'tcx>) {\n+        let trace = TypeTrace {\n+            origin: Misc(span),\n+            values: Types(ty::expected_found {\n+                expected: expected,\n+                found: actual\n+            })\n+        };\n+\n+        self.report_and_explain_type_error(trace, &ty::type_err::terr_ty_param_default_mismatch(ty::expected_found {\n+            expected: expected,\n+            found: actual\n+        }));\n+    }\n+\n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n         span: Span,"}, {"sha": "ebecb0898b4df4b55bbb6a40b269f0bda4ce21a5", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -195,6 +195,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n         escaping_types\n     }\n+\n+    pub fn unsolved_variables(&self) -> Vec<ty::TyVid> {\n+        self.values.iter().enumerate().filter_map(|(i, value)|\n+            match &value.value {\n+                &TypeVariableValue::Known(_) => None,\n+                &TypeVariableValue::Bounded(_) => Some(ty::TyVid { index: i as u32 })\n+            }\n+        ).collect()\n+    }\n }\n \n impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {"}, {"sha": "a08c5e1f73fa20037f04ecde096ce65e6dc08ae4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -2068,6 +2068,7 @@ pub enum TypeError<'tcx> {\n     ConvergenceMismatch(ExpectedFound<bool>),\n     ProjectionNameMismatched(ExpectedFound<ast::Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n+    terr_ty_param_default_mismatch(expected_found<Ty<'tcx>>)\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -5080,6 +5081,11 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 write!(f, \"expected {} associated type bindings, found {}\",\n                        values.expected,\n                        values.found)\n+            },\n+            terr_ty_param_default_mismatch(ref values) => {\n+                write!(f, \"conflicting type parameter defaults {} {}\",\n+                       values.expected,\n+                       values.found)\n             }\n         }\n     }\n@@ -5437,6 +5443,11 @@ impl<'tcx> ctxt<'tcx> {\n                         &format!(\"consider boxing your closure and/or \\\n                                   using it as a trait object\"));\n                 }\n+            },\n+            terr_ty_param_default_mismatch(expected) => {\n+                self.sess.span_note(sp,\n+                    &format!(\"found conflicting defaults {:?} {:?}\",\n+                             expected.expected, expected.found))\n             }\n             _ => {}\n         }"}, {"sha": "7582b7ff61d8830c66b525a9ce6bb654754c5d3c", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -339,5 +339,11 @@ impl<'tcx,K,V> UnificationTable<K>\n     pub fn probe(&mut self, a_id: K) -> Option<V> {\n         self.get(a_id).value.clone()\n     }\n-}\n \n+    pub fn unsolved_variables(&mut self) -> Vec<K> {\n+        self.values\n+            .iter()\n+            .filter_map(|vv| if vv.value.is_some() { None } else { Some(vv.key()) })\n+            .collect()\n+    }\n+}"}, {"sha": "e3b9b990cb9e57f8451cd25d72594b1ee63f5292", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -309,15 +309,17 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // If they were not explicitly supplied, just construct fresh\n         // variables.\n         let num_supplied_types = supplied_method_types.len();\n-        let num_method_types = pick.item.as_opt_method().unwrap()\n-                                   .generics.types.len(subst::FnSpace);\n+        let method = pick.item.as_opt_method().unwrap();\n+        let method_types = method.generics.types.get_slice(subst::FnSpace);\n+        let num_method_types = method_types.len();\n+\n         let method_types = {\n             if num_supplied_types == 0 {\n-                self.fcx.infcx().next_ty_vars(num_method_types)\n+                self.fcx.infcx().type_vars_for_defs(method_types)\n             } else if num_method_types == 0 {\n                 span_err!(self.tcx().sess, self.span, E0035,\n                     \"does not take type parameters\");\n-                self.fcx.infcx().next_ty_vars(num_method_types)\n+                self.fcx.infcx().type_vars_for_defs(method_types)\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");"}, {"sha": "2ca5a88fb06ddbaae974aa929960fa9c60392c67", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -167,15 +167,16 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let trait_def = fcx.tcx().lookup_trait_def(trait_def_id);\n \n-    let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n+    let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n+    let expected_number_of_input_types = type_parameter_defs.len();\n     let input_types = match opt_input_types {\n         Some(input_types) => {\n             assert_eq!(expected_number_of_input_types, input_types.len());\n             input_types\n         }\n \n         None => {\n-            fcx.inh.infcx.next_ty_vars(expected_number_of_input_types)\n+            fcx.inh.infcx.type_vars_for_defs(type_parameter_defs)\n         }\n     };\n "}, {"sha": "88bd000cfdd65340fb1907a907e84fe4680030f5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -1207,8 +1207,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             !method.generics.regions.is_empty_in(subst::FnSpace)\n         {\n             let method_types =\n-                self.infcx().next_ty_vars(\n-                    method.generics.types.len(subst::FnSpace));\n+                self.infcx().type_vars_for_defs(\n+                    method.generics.types.get_slice(subst::FnSpace));\n \n             // In general, during probe we erase regions. See\n             // `impl_self_ty()` for an explanation."}, {"sha": "e226b0b21a1e3bc17adebc87ce428b5b79d433a4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 98, "deletions": 30, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -108,6 +108,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n+use std::collections::HashSet;\n use std::mem::replace;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -1255,28 +1256,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Apply \"fallbacks\" to some types\n-    /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n-    pub fn default_type_parameters(&self) {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &mut ref ty) in &mut self.inh.tables.borrow_mut().node_types {\n-            let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n-            if self.infcx().type_var_diverges(resolved) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n-            } else {\n-                match self.infcx().type_is_unconstrained_numeric(resolved) {\n-                    UnconstrainedInt => {\n-                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n-                    },\n-                    UnconstrainedFloat => {\n-                        demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n-                    }\n-                    Neither => { }\n-                }\n-            }\n-        }\n-    }\n-\n     #[inline]\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n@@ -1711,11 +1690,98 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn select_all_obligations_and_apply_defaults(&self) {\n-        debug!(\"select_all_obligations_and_apply_defaults\");\n+        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n \n-        self.select_obligations_where_possible();\n-        self.default_type_parameters();\n-        self.select_obligations_where_possible();\n+        debug!(\"select_all_obligations_and_apply_defaults: defaults={:?}\", self.infcx().defaults);\n+\n+        for _ in (0..self.tcx().sess.recursion_limit.get()) {\n+            self.select_obligations_where_possible();\n+\n+            let unsolved_variables = self.inh.infcx.unsolved_variables();\n+            let mut unbound_tyvars = HashSet::new();\n+\n+            // Gather all unconstrainted integer and float variables\n+            for ty in &unsolved_variables {\n+                let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+                if self.infcx().type_var_diverges(resolved) {\n+                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                } else {\n+                    match self.infcx().type_is_unconstrained_numeric(resolved) {\n+                        UnconstrainedInt => {\n+                            unbound_tyvars.insert(resolved);\n+                        },\n+                        UnconstrainedFloat => {\n+                            unbound_tyvars.insert(resolved);\n+                        }\n+                        Neither => {}\n+                    }\n+                }\n+            }\n+\n+            // Collect the set of variables that need fallback applied\n+            for ty in &unsolved_variables {\n+                if self.inh.infcx.defaults.borrow().contains_key(ty) {\n+                    let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+\n+                    debug!(\"select_all_obligations_and_apply_defaults: ty: {:?} with default: {:?}\",\n+                            ty, self.inh.infcx.defaults.borrow().get(ty));\n+\n+                    match resolved.sty {\n+                        ty::TyInfer(ty::TyVar(_)) => {\n+                            unbound_tyvars.insert(ty);\n+                        }\n+\n+                        ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) => {\n+                            unbound_tyvars.insert(ty);\n+                            if unbound_tyvars.contains(resolved) {\n+                                unbound_tyvars.remove(resolved);\n+                            }\n+                        }\n+\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            if unbound_tyvars.is_empty() {\n+                break;\n+            }\n+\n+            // Go through the unbound variables and unify them with the proper fallbacks\n+            for ty in &unbound_tyvars {\n+                // let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+                if self.infcx().type_var_diverges(ty) {\n+                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                } else {\n+                    match self.infcx().type_is_unconstrained_numeric(ty) {\n+                        UnconstrainedInt => {\n+                            demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                        },\n+                        UnconstrainedFloat => {\n+                            demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                        }\n+                        Neither => {\n+                            let default_map = self.inh.infcx.defaults.borrow();\n+                            if let Some(default) = default_map.get(ty) {\n+                                match infer::mk_eqty(self.infcx(), false,\n+                                                     infer::Misc(codemap::DUMMY_SP),\n+                                                     ty, default) {\n+                                    Ok(()) => { /* ok */ }\n+                                    Err(_) => {\n+                                        self.infcx().report_conflicting_default_types(\n+                                            codemap::DUMMY_SP,\n+                                            ty,\n+                                            default)\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            self.select_obligations_where_possible();\n+        }\n     }\n \n     fn select_all_obligations_or_error(&self) {\n@@ -2421,13 +2487,15 @@ pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.tcx();\n \n     let ity = tcx.lookup_item_type(did);\n-    let (n_tps, rps, raw_ty) =\n-        (ity.generics.types.len(subst::TypeSpace),\n+    let (tps, rps, raw_ty) =\n+        (ity.generics.types.get_slice(subst::TypeSpace),\n          ity.generics.regions.get_slice(subst::TypeSpace),\n          ity.ty);\n \n+    debug!(\"impl_self_ty: tps={:?} rps={:?} raw_ty={:?}\", tps, rps, raw_ty);\n+\n     let rps = fcx.inh.infcx.region_vars_for_defs(span, rps);\n-    let tps = fcx.inh.infcx.next_ty_vars(n_tps);\n+    let tps = fcx.inh.infcx.type_vars_for_defs(tps);\n     let substs = subst::Substs::new_type(tps, rps);\n     let substd_ty = fcx.instantiate_type_scheme(span, &substs, &raw_ty);\n \n@@ -4647,7 +4715,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Nothing specified at all: supply inference variables for\n         // everything.\n         if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n-            substs.types.replace(space, fcx.infcx().next_ty_vars(desired.len()));\n+            substs.types.replace(space, fcx.infcx().type_vars_for_defs(&desired[..]));\n             return;\n         }\n "}, {"sha": "900945da1136ba6ab0c556131d2bf7acfe8ccf00", "filename": "src/test/compile-fail/default_ty_param_conflict.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_conflict.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Debug;\n+\n+// Example from the RFC\n+fn foo<F:Default=usize>() -> F { F::default() }\n+fn bar<B:Debug=isize>(b: B) { println!(\"{:?}\", b); }\n+\n+fn main() {\n+    // Here, F is instantiated with $0=uint\n+    let x = foo();\n+\n+    // Here, B is instantiated with $1=uint, and constraint $0 <: $1 is added.\n+    bar(x);\n+}"}, {"sha": "c3e44e55beeb21df379d1800c8a497f53fd0a27e", "filename": "src/test/compile-fail/default_ty_param_type_alias.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdefault_ty_param_type_alias.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+\n+type IntMap<K=usize> = HashMap<K, usize>;\n+\n+fn main() {\n+    let x = IntMap::new();\n+}"}, {"sha": "35f0fcab00175ed438325d1483f5b29c6a77257b", "filename": "src/test/run-pass/default_ty_param_method_call_test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_method_call_test.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn method<A:Default=String>(&self) -> A {\n+        A::default()\n+    }\n+}\n+\n+fn main() {\n+    let f = Foo.method();\n+    println!(\"{}\", f);\n+}"}, {"sha": "b94b759fd113f99e4b4d35986ba3f5e42a72af01", "filename": "src/test/run-pass/default_ty_param_struct.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<A>(A);\n+\n+impl<A:Default=i32> Foo<A> {\n+    fn new() -> Foo<A> {\n+        Foo(A::default())\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo::new();\n+}"}, {"sha": "fbceb60b9a8e712878976a49d6eaa7107c1786af", "filename": "src/test/run-pass/default_ty_param_trait_impl.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Another example from the RFC\n+trait Foo { }\n+trait Bar { }\n+\n+impl<T:Bar=usize> Foo for Vec<T> {} // Impl 1\n+impl Bar for usize { } // Impl 2\n+\n+fn takes_foo<F:Foo>(f: F) { }\n+\n+fn main() {\n+    let x = Vec::new(); // x: Vec<$0>\n+    takes_foo(x); // adds oblig Vec<$0> : Foo\n+}"}, {"sha": "00d7ccf43becc45f77d003c80d7a65312077cbdd", "filename": "src/test/run-pass/default_ty_param_trait_impl_simple.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbcb13da88f7a4b25506ec85f2f170e6f78d5a58/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_trait_impl_simple.rs?ref=bbcb13da88f7a4b25506ec85f2f170e6f78d5a58", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// An example from the RFC\n+trait Foo { fn takes_foo(&self); }\n+trait Bar { }\n+\n+impl<T:Bar=usize> Foo for Vec<T> {\n+    fn takes_foo(&self) {}\n+} // Impl 1\n+\n+impl Bar for usize { } // Impl 2\n+\n+// fn takes_foo<F:Foo>(f: F) { }\n+\n+fn main() {\n+    let x = Vec::new(); // x: Vec<$0>\n+    x.takes_foo(); // adds oblig Vec<$0> : Foo\n+}"}]}