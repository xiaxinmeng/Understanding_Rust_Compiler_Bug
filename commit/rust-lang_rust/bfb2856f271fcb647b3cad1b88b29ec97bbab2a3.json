{"sha": "bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "node_id": "C_kwDOAAsO6NoAKGJmYjI4NTZmMjcxZmNiNjQ3YjNjYWQxYjg4YjI5ZWM5N2JiYWIyYTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T19:03:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-15T19:03:38Z"}, "message": "Auto merge of #93820 - compiler-errors:gat-wfcheck, r=jackh726\n\nRework GAT `where` clause check\n\nrework the GAT where check to use a fixed-point algorithm, and check all GATs in a trait at once\n\nfixes #93278\n\nr? `@jackh726`\ncc `@nikomatsakis`", "tree": {"sha": "dbffdd5b6e26468f827669e55259d651eeb04329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbffdd5b6e26468f827669e55259d651eeb04329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "html_url": "https://github.com/rust-lang/rust/commit/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c", "html_url": "https://github.com/rust-lang/rust/commit/6bf3008f0757c7c89c3f02e0e7eaac5ee30c1c6c"}, {"sha": "f045b214ea52eebdaf0b17a1ca6d4be807abb032", "url": "https://api.github.com/repos/rust-lang/rust/commits/f045b214ea52eebdaf0b17a1ca6d4be807abb032", "html_url": "https://github.com/rust-lang/rust/commit/f045b214ea52eebdaf0b17a1ca6d4be807abb032"}], "stats": {"total": 502, "additions": 306, "deletions": 196}, "files": [{"sha": "55757251e26fdb1c5acd34182b89d07f71f68356", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 272, "deletions": 192, "changes": 464, "blob_url": "https://github.com/rust-lang/rust/blob/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "patch": "@@ -3,7 +3,7 @@ use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -258,248 +258,186 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .emit();\n         }\n     }\n-\n-    check_gat_where_clauses(tcx, trait_item, encl_trait_def_id);\n }\n \n /// Require that the user writes where clauses on GATs for the implicit\n /// outlives bounds involving trait parameters in trait functions and\n /// lifetimes passed as GAT substs. See `self-outlives-lint` test.\n ///\n-/// This trait will be our running example. We are currently WF checking the `Item` item...\n-///\n-/// ```rust\n-/// trait LendingIterator {\n-///   type Item<'me>; // <-- WF checking this trait item\n-///\n-///   fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;\n+/// We use the following trait as an example throughout this function:\n+/// ```rust,ignore (this code fails due to this lint)\n+/// trait IntoIter {\n+///     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n+///     type Item<'a>;\n+///     fn into_iter<'a>(&'a self) -> Self::Iter<'a>;\n /// }\n /// ```\n-fn check_gat_where_clauses(\n-    tcx: TyCtxt<'_>,\n-    trait_item: &hir::TraitItem<'_>,\n-    encl_trait_def_id: DefId,\n-) {\n-    let item = tcx.associated_item(trait_item.def_id);\n-    // If the current trait item isn't a type, it isn't a GAT\n-    if !matches!(item.kind, ty::AssocKind::Type) {\n-        return;\n-    }\n-    let generics: &ty::Generics = tcx.generics_of(trait_item.def_id);\n-    // If the current associated type doesn't have any (own) params, it's not a GAT\n-    // FIXME(jackh726): we can also warn in the more general case\n-    if generics.params.len() == 0 {\n-        return;\n-    }\n-    let associated_items: &ty::AssocItems<'_> = tcx.associated_items(encl_trait_def_id);\n-    let mut clauses: Option<FxHashSet<ty::Predicate<'_>>> = None;\n-    // For every function in this trait...\n-    // In our example, this would be the `next` method\n-    for item in\n-        associated_items.in_definition_order().filter(|item| matches!(item.kind, ty::AssocKind::Fn))\n-    {\n-        // The clauses we that we would require from this function\n-        let mut function_clauses = FxHashSet::default();\n-\n-        let id = hir::HirId::make_owner(item.def_id.expect_local());\n-        let param_env = tcx.param_env(item.def_id.expect_local());\n-\n-        let sig = tcx.fn_sig(item.def_id);\n-        // Get the signature using placeholders. In our example, this would\n-        // convert the late-bound 'a into a free region.\n-        let sig = tcx.liberate_late_bound_regions(item.def_id, sig);\n-        // Collect the arguments that are given to this GAT in the return type\n-        // of  the function signature. In our example, the GAT in the return\n-        // type is `<Self as LendingIterator>::Item<'a>`, so 'a and Self are arguments.\n-        let (regions, types) =\n-            GATSubstCollector::visit(tcx, trait_item.def_id.to_def_id(), sig.output());\n-\n-        // If both regions and types are empty, then this GAT isn't in the\n-        // return type, and we shouldn't try to do clause analysis\n-        // (particularly, doing so would end up with an empty set of clauses,\n-        // since the current method would require none, and we take the\n-        // intersection of requirements of all methods)\n-        if types.is_empty() && regions.is_empty() {\n-            continue;\n-        }\n-\n-        // The types we can assume to be well-formed. In our example, this\n-        // would be &'a mut Self, from the first argument.\n-        let mut wf_tys = FxHashSet::default();\n-        wf_tys.extend(sig.inputs());\n-\n-        // For each region argument (e.g., 'a in our example), check for a\n-        // relationship to the type arguments (e.g., Self). If there is an\n-        // outlives relationship (`Self: 'a`), then we want to ensure that is\n-        // reflected in a where clause on the GAT itself.\n-        for (region, region_idx) in &regions {\n-            // Ignore `'static` lifetimes for the purpose of this lint: it's\n-            // because we know it outlives everything and so doesn't give meaninful\n-            // clues\n-            if region.is_static() {\n+fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRef]) {\n+    // Associates every GAT's def_id to a list of possibly missing bounds detected by this lint.\n+    let mut required_bounds_by_item = FxHashMap::default();\n+\n+    // Loop over all GATs together, because if this lint suggests adding a where-clause bound\n+    // to one GAT, it might then require us to an additional bound on another GAT.\n+    // In our `IntoIter` example, we discover a missing `Self: 'a` bound on `Iter<'a>`, which\n+    // then in a second loop adds a `Self: 'a` bound to `Item` due to the relationship between\n+    // those GATs.\n+    loop {\n+        let mut should_continue = false;\n+        for gat_item in associated_items {\n+            let gat_def_id = gat_item.id.def_id;\n+            let gat_item = tcx.associated_item(gat_def_id);\n+            // If this item is not an assoc ty, or has no substs, then it's not a GAT\n+            if gat_item.kind != ty::AssocKind::Type {\n                 continue;\n             }\n-            for (ty, ty_idx) in &types {\n-                // In our example, requires that Self: 'a\n-                if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n-                    debug!(?ty_idx, ?region_idx);\n-                    debug!(\"required clause: {} must outlive {}\", ty, region);\n-                    // Translate into the generic parameters of the GAT. In\n-                    // our example, the type was Self, which will also be\n-                    // Self in the GAT.\n-                    let ty_param = generics.param_at(*ty_idx, tcx);\n-                    let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n-                        index: ty_param.index,\n-                        name: ty_param.name,\n-                    }));\n-                    // Same for the region. In our example, 'a corresponds\n-                    // to the 'me parameter.\n-                    let region_param = generics.param_at(*region_idx, tcx);\n-                    let region_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_param.def_id,\n-                        index: region_param.index,\n-                        name: region_param.name,\n-                    }));\n-                    // The predicate we expect to see. (In our example,\n-                    // `Self: 'me`.)\n-                    let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_param,\n-                        region_param,\n-                    ));\n-                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                    function_clauses.insert(clause);\n-                }\n-            }\n-        }\n-\n-        // For each region argument (e.g., 'a in our example), also check for a\n-        // relationship to the other region arguments. If there is an\n-        // outlives relationship, then we want to ensure that is\n-        // reflected in a where clause on the GAT itself.\n-        for (region_a, region_a_idx) in &regions {\n-            // Ignore `'static` lifetimes for the purpose of this lint: it's\n-            // because we know it outlives everything and so doesn't give meaninful\n-            // clues\n-            if region_a.is_static() {\n+            let gat_generics = tcx.generics_of(gat_def_id);\n+            // FIXME(jackh726): we can also warn in the more general case\n+            if gat_generics.params.is_empty() {\n                 continue;\n             }\n-            for (region_b, region_b_idx) in &regions {\n-                if region_a == region_b {\n-                    continue;\n-                }\n-                if region_b.is_static() {\n+\n+            // Gather the bounds with which all other items inside of this trait constrain the GAT.\n+            // This is calculated by taking the intersection of the bounds that each item\n+            // constrains the GAT with individually.\n+            let mut new_required_bounds: Option<FxHashSet<ty::Predicate<'_>>> = None;\n+            for item in associated_items {\n+                let item_def_id = item.id.def_id;\n+                // Skip our own GAT, since it does not constrain itself at all.\n+                if item_def_id == gat_def_id {\n                     continue;\n                 }\n \n-                if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n-                    debug!(?region_a_idx, ?region_b_idx);\n-                    debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n-                    // Translate into the generic parameters of the GAT.\n-                    let region_a_param = generics.param_at(*region_a_idx, tcx);\n-                    let region_a_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_a_param.def_id,\n-                        index: region_a_param.index,\n-                        name: region_a_param.name,\n-                    }));\n-                    // Same for the region.\n-                    let region_b_param = generics.param_at(*region_b_idx, tcx);\n-                    let region_b_param = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        def_id: region_b_param.def_id,\n-                        index: region_b_param.index,\n-                        name: region_b_param.name,\n-                    }));\n-                    // The predicate we expect to see.\n-                    let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                        region_a_param,\n-                        region_b_param,\n-                    ));\n-                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                    function_clauses.insert(clause);\n+                let item_hir_id = item.id.hir_id();\n+                let param_env = tcx.param_env(item_def_id);\n+\n+                let item_required_bounds = match item.kind {\n+                    // In our example, this corresponds to `into_iter` method\n+                    hir::AssocItemKind::Fn { .. } => {\n+                        // For methods, we check the function signature's return type for any GATs\n+                        // to constrain. In the `into_iter` case, we see that the return type\n+                        // `Self::Iter<'a>` is a GAT we want to gather any potential missing bounds from.\n+                        let sig: ty::FnSig<'_> = tcx.liberate_late_bound_regions(\n+                            item_def_id.to_def_id(),\n+                            tcx.fn_sig(item_def_id),\n+                        );\n+                        gather_gat_bounds(\n+                            tcx,\n+                            param_env,\n+                            item_hir_id,\n+                            sig.output(),\n+                            // We also assume that all of the function signature's parameter types\n+                            // are well formed.\n+                            &sig.inputs().iter().copied().collect(),\n+                            gat_def_id,\n+                            gat_generics,\n+                        )\n+                    }\n+                    // In our example, this corresponds to the `Iter` and `Item` associated types\n+                    hir::AssocItemKind::Type => {\n+                        // If our associated item is a GAT with missing bounds, add them to\n+                        // the param-env here. This allows this GAT to propagate missing bounds\n+                        // to other GATs.\n+                        let param_env = augment_param_env(\n+                            tcx,\n+                            param_env,\n+                            required_bounds_by_item.get(&item_def_id),\n+                        );\n+                        gather_gat_bounds(\n+                            tcx,\n+                            param_env,\n+                            item_hir_id,\n+                            tcx.explicit_item_bounds(item_def_id)\n+                                .iter()\n+                                .copied()\n+                                .collect::<Vec<_>>(),\n+                            &FxHashSet::default(),\n+                            gat_def_id,\n+                            gat_generics,\n+                        )\n+                    }\n+                    hir::AssocItemKind::Const => None,\n+                };\n+\n+                if let Some(item_required_bounds) = item_required_bounds {\n+                    // Take the intersection of the required bounds for this GAT, and\n+                    // the item_required_bounds which are the ones implied by just\n+                    // this item alone.\n+                    // This is why we use an Option<_>, since we need to distinguish\n+                    // the empty set of bounds from the _uninitialized_ set of bounds.\n+                    if let Some(new_required_bounds) = &mut new_required_bounds {\n+                        new_required_bounds.retain(|b| item_required_bounds.contains(b));\n+                    } else {\n+                        new_required_bounds = Some(item_required_bounds);\n+                    }\n                 }\n             }\n-        }\n \n-        // Imagine we have:\n-        // ```\n-        // trait Foo {\n-        //   type Bar<'me>;\n-        //   fn gimme(&self) -> Self::Bar<'_>;\n-        //   fn gimme_default(&self) -> Self::Bar<'static>;\n-        // }\n-        // ```\n-        // We only want to require clauses on `Bar` that we can prove from *all* functions (in this\n-        // case, `'me` can be `static` from `gimme_default`)\n-        match clauses.as_mut() {\n-            Some(clauses) => {\n-                clauses.drain_filter(|p| !function_clauses.contains(p));\n-            }\n-            None => {\n-                clauses = Some(function_clauses);\n+            if let Some(new_required_bounds) = new_required_bounds {\n+                let required_bounds = required_bounds_by_item.entry(gat_def_id).or_default();\n+                if new_required_bounds.into_iter().any(|p| required_bounds.insert(p)) {\n+                    // Iterate until our required_bounds no longer change\n+                    // Since they changed here, we should continue the loop\n+                    should_continue = true;\n+                }\n             }\n         }\n+        // We know that this loop will eventually halt, since we only set `should_continue` if the\n+        // `required_bounds` for this item grows. Since we are not creating any new region or type\n+        // variables, the set of all region and type bounds that we could ever insert are limited\n+        // by the number of unique types and regions we observe in a given item.\n+        if !should_continue {\n+            break;\n+        }\n     }\n \n-    // If there are any clauses that aren't provable, emit an error\n-    let clauses = clauses.unwrap_or_default();\n-    debug!(?clauses);\n-    if !clauses.is_empty() {\n-        let param_env = tcx.param_env(trait_item.def_id);\n+    for (gat_def_id, required_bounds) in required_bounds_by_item {\n+        let gat_item_hir = tcx.hir().expect_trait_item(gat_def_id);\n+        debug!(?required_bounds);\n+        let param_env = tcx.param_env(gat_def_id);\n+        let gat_hir = gat_item_hir.hir_id();\n \n-        let mut clauses: Vec<_> = clauses\n+        let mut unsatisfied_bounds: Vec<_> = required_bounds\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !region_known_to_outlive(\n-                        tcx,\n-                        trait_item.hir_id(),\n-                        param_env,\n-                        &FxHashSet::default(),\n-                        a,\n-                        b,\n-                    )\n+                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n                 }\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !ty_known_to_outlive(\n-                        tcx,\n-                        trait_item.hir_id(),\n-                        param_env,\n-                        &FxHashSet::default(),\n-                        a,\n-                        b,\n-                    )\n+                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n                 }\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n-            .map(|clause| format!(\"{}\", clause))\n+            .map(|clause| clause.to_string())\n             .collect();\n \n         // We sort so that order is predictable\n-        clauses.sort();\n+        unsatisfied_bounds.sort();\n \n-        if !clauses.is_empty() {\n-            let plural = if clauses.len() > 1 { \"s\" } else { \"\" };\n+        if !unsatisfied_bounds.is_empty() {\n+            let plural = if unsatisfied_bounds.len() > 1 { \"s\" } else { \"\" };\n             let mut err = tcx.sess.struct_span_err(\n-                trait_item.span,\n-                &format!(\"missing required bound{} on `{}`\", plural, trait_item.ident),\n+                gat_item_hir.span,\n+                &format!(\"missing required bound{} on `{}`\", plural, gat_item_hir.ident),\n             );\n \n             let suggestion = format!(\n                 \"{} {}\",\n-                if !trait_item.generics.where_clause.predicates.is_empty() {\n+                if !gat_item_hir.generics.where_clause.predicates.is_empty() {\n                     \",\"\n                 } else {\n                     \" where\"\n                 },\n-                clauses.join(\", \"),\n+                unsatisfied_bounds.join(\", \"),\n             );\n             err.span_suggestion(\n-                trait_item.generics.where_clause.tail_span_for_suggestion(),\n+                gat_item_hir.generics.where_clause.tail_span_for_suggestion(),\n                 &format!(\"add the required where clause{}\", plural),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n \n-            let bound = if clauses.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n+            let bound =\n+                if unsatisfied_bounds.len() > 1 { \"these bounds are\" } else { \"this bound is\" };\n             err.note(&format!(\n                 \"{} currently required to ensure that impls have maximum flexibility\",\n                 bound\n@@ -515,6 +453,143 @@ fn check_gat_where_clauses(\n     }\n }\n \n+/// Add a new set of predicates to the caller_bounds of an existing param_env.\n+fn augment_param_env<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    new_predicates: Option<&FxHashSet<ty::Predicate<'tcx>>>,\n+) -> ty::ParamEnv<'tcx> {\n+    let Some(new_predicates) = new_predicates else {\n+        return param_env;\n+    };\n+\n+    if new_predicates.is_empty() {\n+        return param_env;\n+    }\n+\n+    let bounds =\n+        tcx.mk_predicates(param_env.caller_bounds().iter().chain(new_predicates.iter().cloned()));\n+    // FIXME(compiler-errors): Perhaps there is a case where we need to normalize this\n+    // i.e. traits::normalize_param_env_or_error\n+    ty::ParamEnv::new(bounds, param_env.reveal(), param_env.constness())\n+}\n+\n+/// We use the following trait as an example throughout this function.\n+/// Specifically, let's assume that `to_check` here is the return type\n+/// of `into_iter`, and the GAT we are checking this for is `Iter`.\n+/// ```rust,ignore (this code fails due to this lint)\n+/// trait IntoIter {\n+///     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n+///     type Item<'a>;\n+///     fn into_iter<'a>(&'a self) -> Self::Iter<'a>;\n+/// }\n+/// ```\n+fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    item_hir: hir::HirId,\n+    to_check: T,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    gat_def_id: LocalDefId,\n+    gat_generics: &'tcx ty::Generics,\n+) -> Option<FxHashSet<ty::Predicate<'tcx>>> {\n+    // The bounds we that we would require from `to_check`\n+    let mut bounds = FxHashSet::default();\n+\n+    let (regions, types) = GATSubstCollector::visit(tcx, gat_def_id.to_def_id(), to_check);\n+\n+    // If both regions and types are empty, then this GAT isn't in the\n+    // set of types we are checking, and we shouldn't try to do clause analysis\n+    // (particularly, doing so would end up with an empty set of clauses,\n+    // since the current method would require none, and we take the\n+    // intersection of requirements of all methods)\n+    if types.is_empty() && regions.is_empty() {\n+        return None;\n+    }\n+\n+    for (region_a, region_a_idx) in &regions {\n+        // Ignore `'static` lifetimes for the purpose of this lint: it's\n+        // because we know it outlives everything and so doesn't give meaninful\n+        // clues\n+        if let ty::ReStatic = **region_a {\n+            continue;\n+        }\n+        // For each region argument (e.g., `'a` in our example), check for a\n+        // relationship to the type arguments (e.g., `Self`). If there is an\n+        // outlives relationship (`Self: 'a`), then we want to ensure that is\n+        // reflected in a where clause on the GAT itself.\n+        for (ty, ty_idx) in &types {\n+            // In our example, requires that `Self: 'a`\n+            if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n+                debug!(?ty_idx, ?region_a_idx);\n+                debug!(\"required clause: {} must outlive {}\", ty, region_a);\n+                // Translate into the generic parameters of the GAT. In\n+                // our example, the type was `Self`, which will also be\n+                // `Self` in the GAT.\n+                let ty_param = gat_generics.param_at(*ty_idx, tcx);\n+                let ty_param = tcx\n+                    .mk_ty(ty::Param(ty::ParamTy { index: ty_param.index, name: ty_param.name }));\n+                // Same for the region. In our example, 'a corresponds\n+                // to the 'me parameter.\n+                let region_param = gat_generics.param_at(*region_a_idx, tcx);\n+                let region_param =\n+                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_param.def_id,\n+                        index: region_param.index,\n+                        name: region_param.name,\n+                    }));\n+                // The predicate we expect to see. (In our example,\n+                // `Self: 'me`.)\n+                let clause =\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_param, region_param));\n+                let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                bounds.insert(clause);\n+            }\n+        }\n+\n+        // For each region argument (e.g., `'a` in our example), also check for a\n+        // relationship to the other region arguments. If there is an outlives\n+        // relationship, then we want to ensure that is reflected in the where clause\n+        // on the GAT itself.\n+        for (region_b, region_b_idx) in &regions {\n+            // Again, skip `'static` because it outlives everything. Also, we trivially\n+            // know that a region outlives itself.\n+            if ty::ReStatic == **region_b || region_a == region_b {\n+                continue;\n+            }\n+            if region_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *region_a, *region_b) {\n+                debug!(?region_a_idx, ?region_b_idx);\n+                debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n+                // Translate into the generic parameters of the GAT.\n+                let region_a_param = gat_generics.param_at(*region_a_idx, tcx);\n+                let region_a_param =\n+                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_a_param.def_id,\n+                        index: region_a_param.index,\n+                        name: region_a_param.name,\n+                    }));\n+                // Same for the region.\n+                let region_b_param = gat_generics.param_at(*region_b_idx, tcx);\n+                let region_b_param =\n+                    tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: region_b_param.def_id,\n+                        index: region_b_param.index,\n+                        name: region_b_param.name,\n+                    }));\n+                // The predicate we expect to see.\n+                let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                    region_a_param,\n+                    region_b_param,\n+                ));\n+                let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                bounds.insert(clause);\n+            }\n+        }\n+    }\n+\n+    Some(bounds)\n+}\n+\n /// Given a known `param_env` and a set of well formed types, can we prove that\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>(\n@@ -1024,6 +1099,11 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n \n         FxHashSet::default()\n     });\n+\n+    // Only check traits, don't check trait aliases\n+    if let hir::ItemKind::Trait(_, _, _, _, items) = item.kind {\n+        check_gat_where_clauses(tcx, items);\n+    }\n }\n \n /// Checks all associated type defaults of trait `trait_def_id`."}, {"sha": "300907adbfc11546356902ade82985d5496c45b6", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "patch": "@@ -140,11 +140,19 @@ trait NotInReturn {\n // We obviously error for `Iterator`, but we should also error for `Item`\n trait IterableTwo {\n     type Item<'a>;\n+    //~^ missing required\n     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n     //~^ missing required\n     fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n }\n \n+trait IterableTwoWhere {\n+    type Item<'a>;\n+    //~^ missing required\n+    type Iterator<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n+    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n+}\n+\n // We also should report region outlives clauses. Here, we know that `'y: 'x`,\n // because of `&'x &'y`, so we require that `'b: 'a`.\n trait RegionOutlives {"}, {"sha": "fdb1f50a7764c94d3e61b83ee87851107fc48929", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.stderr", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfb2856f271fcb647b3cad1b88b29ec97bbab2a3/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.stderr?ref=bfb2856f271fcb647b3cad1b88b29ec97bbab2a3", "patch": "@@ -108,8 +108,19 @@ LL |     type Bar<'b>;\n    = note: this bound is currently required to ensure that impls have maximum flexibility\n    = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n+error: missing required bound on `Item`\n+  --> $DIR/self-outlives-lint.rs:142:5\n+   |\n+LL |     type Item<'a>;\n+   |     ^^^^^^^^^^^^^-\n+   |                  |\n+   |                  help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n+\n error: missing required bound on `Iterator`\n-  --> $DIR/self-outlives-lint.rs:143:5\n+  --> $DIR/self-outlives-lint.rs:144:5\n    |\n LL |     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n@@ -119,8 +130,19 @@ LL |     type Iterator<'a>: Iterator<Item = Self::Item<'a>>;\n    = note: this bound is currently required to ensure that impls have maximum flexibility\n    = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n+error: missing required bound on `Item`\n+  --> $DIR/self-outlives-lint.rs:150:5\n+   |\n+LL |     type Item<'a>;\n+   |     ^^^^^^^^^^^^^-\n+   |                  |\n+   |                  help: add the required where clause: `where Self: 'a`\n+   |\n+   = note: this bound is currently required to ensure that impls have maximum flexibility\n+   = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n+\n error: missing required bound on `Bar`\n-  --> $DIR/self-outlives-lint.rs:151:5\n+  --> $DIR/self-outlives-lint.rs:159:5\n    |\n LL |     type Bar<'a, 'b>;\n    |     ^^^^^^^^^^^^^^^^-\n@@ -131,7 +153,7 @@ LL |     type Bar<'a, 'b>;\n    = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n error: missing required bound on `Fut`\n-  --> $DIR/self-outlives-lint.rs:167:5\n+  --> $DIR/self-outlives-lint.rs:175:5\n    |\n LL |     type Fut<'out>;\n    |     ^^^^^^^^^^^^^^-\n@@ -141,5 +163,5 @@ LL |     type Fut<'out>;\n    = note: this bound is currently required to ensure that impls have maximum flexibility\n    = note: we are soliciting feedback, see issue #87479 <https://github.com/rust-lang/rust/issues/87479> for more information\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n "}]}