{"sha": "9ab14a949d64ed220d974773a184e9fecb815cbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYjE0YTk0OWQ2NGVkMjIwZDk3NDc3M2ExODRlOWZlY2I4MTVjYmY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-09T15:58:58Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-10T15:25:10Z"}, "message": "debuginfo: Support for namespaces for types", "tree": {"sha": "851da27e335c5d6b541ee99555572f8f91bdd99c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/851da27e335c5d6b541ee99555572f8f91bdd99c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ab14a949d64ed220d974773a184e9fecb815cbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ab14a949d64ed220d974773a184e9fecb815cbf", "html_url": "https://github.com/rust-lang/rust/commit/9ab14a949d64ed220d974773a184e9fecb815cbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ab14a949d64ed220d974773a184e9fecb815cbf/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93d6328d49e07f8c0ad98f5925c575d9c1b1cc9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/93d6328d49e07f8c0ad98f5925c575d9c1b1cc9b", "html_url": "https://github.com/rust-lang/rust/commit/93d6328d49e07f8c0ad98f5925c575d9c1b1cc9b"}], "stats": {"total": 479, "additions": 343, "deletions": 136}, "files": [{"sha": "e8a78c3318373e5b9690c8a1ad837d8dfb7a9186", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 343, "deletions": 136, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/9ab14a949d64ed220d974773a184e9fecb815cbf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ab14a949d64ed220d974773a184e9fecb815cbf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9ab14a949d64ed220d974773a184e9fecb815cbf", "patch": "@@ -99,8 +99,8 @@ pub struct CrateDebugContext {\n     priv current_debug_location: DebugLocation,\n     priv created_files: HashMap<~str, DIFile>,\n     priv created_types: HashMap<uint, DIType>,\n-    priv namespace_map: HashMap<ast::NodeId, @NamespaceTree>,\n-    priv function_companion_namespaces: HashMap<ast::NodeId, @NamespaceTree>,\n+    priv local_namespace_map: HashMap<ast::NodeId, @NamespaceTree>,\n+    priv extern_namespaces: HashMap<~[ast::Ident], @NamespaceTree>,\n }\n \n impl CrateDebugContext {\n@@ -116,8 +116,8 @@ impl CrateDebugContext {\n             current_debug_location: UnknownLocation,\n             created_files: HashMap::new(),\n             created_types: HashMap::new(),\n-            namespace_map: HashMap::new(),\n-            function_companion_namespaces: HashMap::new(),\n+            local_namespace_map: HashMap::new(),\n+            extern_namespaces: HashMap::new(),\n         };\n     }\n }\n@@ -133,12 +133,10 @@ impl FunctionDebugContext {\n         match *self {\n             FunctionDebugContext(~ref data) => data,\n             DebugInfoDisabled => {\n-                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n-                                        although debug info is disabled!\");\n+                cx.sess.span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionWithoutDebugInfo => {\n-                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n-                                        for function that should be ignored by debug info!\");\n+                cx.sess.span_bug(span, FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -150,15 +148,22 @@ impl FunctionDebugContext {\n         match *self {\n             FunctionDebugContext(~ref mut data) => data,\n             DebugInfoDisabled => {\n-                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n-                                        although debug info is disabled!\");\n+                cx.sess.span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionWithoutDebugInfo => {\n-                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n-                                        for function that should be ignored by debug info!\");\n+                cx.sess.span_bug(span, FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n+\n+    fn debuginfo_disabled_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext although debug info is disabled!\"\n+    }\n+\n+    fn should_be_ignored_message() -> &'static str {\n+        \"debuginfo: Error trying to access FunctionDebugContext for function that should be \\\n+         ignored by debug info!\"\n+    }\n }\n \n struct FunctionDebugContextData {\n@@ -598,7 +603,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         ptr::null()\n     };\n \n-    let namespace_node = debug_context(cx).namespace_map.find_copy(&fn_ast_id);\n+    let namespace_node = debug_context(cx).local_namespace_map.find_copy(&fn_ast_id);\n     let (linkage_name, containing_scope) = match namespace_node {\n         Some(namespace_node) => {\n             (namespace_node.mangled_name_of_contained_item(function_name), namespace_node.scope)\n@@ -657,7 +662,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                                                                                span);\n             visit::walk_block(&mut namespace_visitor, top_level_block, ());\n         }\n-        _ => { /* nothing to do */}\n+        _ => { /*nothing to do*/ }\n     }\n \n     return FunctionDebugContext(fn_debug_context);\n@@ -932,7 +937,7 @@ fn declare_local(bcx: @mut Block,\n             assert!(!bcx.fcx.debug_context.get_ref(cx, span).source_locations_enabled);\n             set_debug_location(cx, UnknownLocation);\n         }\n-        _ => { /* fallthrough */ }\n+        _ => { /* nothing to do */ }\n     }\n }\n \n@@ -1050,58 +1055,70 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n \n fn struct_metadata(cx: &mut CrateContext,\n                    struct_type: ty::t,\n-                   fields: ~[ty::field],\n+                   def_id: ast::DefId,\n+                   substs: &ty::substs,\n                    span: Span)\n                 -> DICompositeType {\n     let struct_name = ty_to_str(cx.tcx, struct_type);\n     debug!(\"struct_metadata: %s\", struct_name);\n \n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n-\n-    let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n-    let field_names = do fields.map |field| {\n-        if field.ident.name == special_idents::unnamed_field.name {\n-            ~\"\"\n+    let fields = ty::struct_fields(cx.tcx, def_id, substs);\n+    let field_descriptions = do fields.map |field| {\n+        let name = if field.ident.name == special_idents::unnamed_field.name {\n+            @\"\"\n         } else {\n-            token::ident_to_str(&field.ident).to_owned()\n+            token::ident_to_str(&field.ident)\n+        };\n+\n+        MemberDescription {\n+            name: name,\n+            llvm_type: type_of::type_of(cx, field.mt.ty),\n+            type_metadata: type_metadata(cx, field.mt.ty, span),\n         }\n     };\n-    let field_types_metadata = do fields.map |field| {\n-        type_metadata(cx, field.mt.ty, span)\n-    };\n+\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n+\n+    let file_name = span_start(cx, definition_span).file.name;\n+    let file_metadata = file_metadata(cx, file_name);\n \n     return composite_type_metadata(\n         cx,\n         struct_llvm_type,\n         struct_name,\n-        field_llvm_types,\n-        field_names,\n-        field_types_metadata,\n-        span);\n+        field_descriptions,\n+        containing_scope,\n+        file_metadata,\n+        definition_span);\n }\n \n fn tuple_metadata(cx: &mut CrateContext,\n                   tuple_type: ty::t,\n                   component_types: &[ty::t],\n                   span: Span)\n                -> DICompositeType {\n-\n     let tuple_name = ty_to_str(cx.tcx, tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n-    let component_names = do component_types.map |_| { ~\"\" };\n-    let component_llvm_types = do component_types.map |it| { type_of::type_of(cx, *it) };\n-    let component_types_metadata = do component_types.map |it| {\n-        type_metadata(cx, *it, span)\n+    let component_descriptions = do component_types.map |&component_type| {\n+        MemberDescription {\n+            name: @\"\",\n+            llvm_type: type_of::type_of(cx, component_type),\n+            type_metadata: type_metadata(cx, component_type, span),\n+        }\n     };\n \n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n     return composite_type_metadata(\n         cx,\n         tuple_llvm_type,\n         tuple_name,\n-        component_llvm_types,\n-        component_names,\n-        component_types_metadata,\n+        component_descriptions,\n+        file_metadata,\n+        file_metadata,\n         span);\n }\n \n@@ -1110,13 +1127,24 @@ fn enum_metadata(cx: &mut CrateContext,\n                  enum_def_id: ast::DefId,\n                  span: Span)\n               -> DIType {\n-\n     let enum_name = ty_to_str(cx.tcx, enum_type);\n \n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx,\n+                                                                              enum_def_id,\n+                                                                              span);\n+    let loc = span_start(cx, definition_span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        return composite_type_metadata(cx, Type::nil(), enum_name, [], [], [], span);\n+        return composite_type_metadata(cx,\n+                                       Type::nil(),\n+                                       enum_name,\n+                                       [],\n+                                       file_metadata,\n+                                       file_metadata,\n+                                       definition_span);\n     }\n \n     // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n@@ -1125,7 +1153,7 @@ fn enum_metadata(cx: &mut CrateContext,\n     let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n \n     assert!(Type::enum_discrim(cx) == cx.int_type);\n-    let discriminant_type_metadata = type_metadata(cx, ty::mk_int(), span);\n+    let discriminant_base_type_metadata = type_metadata(cx, ty::mk_int(), codemap::dummy_sp());\n \n     let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n \n@@ -1146,21 +1174,18 @@ fn enum_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n-\n     let discriminant_type_metadata = do enum_name.with_c_str |enum_name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateEnumerationType(\n                 DIB(cx),\n-                file_metadata,\n+                containing_scope,\n                 enum_name,\n                 file_metadata,\n                 loc.line as c_uint,\n                 bytes_to_bits(discriminant_size),\n                 bytes_to_bits(discriminant_align),\n                 create_DIArray(DIB(cx), enumerators_metadata),\n-                discriminant_type_metadata)\n+                discriminant_base_type_metadata)\n         }\n     };\n \n@@ -1172,7 +1197,13 @@ fn enum_metadata(cx: &mut CrateContext,\n         }\n         adt::Univariant(ref struct_def, _) => {\n             assert!(variants.len() == 1);\n-            return adt_struct_metadata(cx, struct_def, variants[0], None, span);\n+            return adt_struct_metadata(cx,\n+                                       struct_def,\n+                                       variants[0],\n+                                       None,\n+                                       containing_scope,\n+                                       file_metadata,\n+                                       span);\n         }\n         adt::General(ref struct_defs) => {\n             let variants_member_metadata: ~[DIDescriptor] = do struct_defs\n@@ -1184,13 +1215,15 @@ fn enum_metadata(cx: &mut CrateContext,\n                         struct_def,\n                         variants[i],\n                         Some(discriminant_type_metadata),\n+                        containing_scope,\n+                        file_metadata,\n                         span);\n \n                     do \"\".with_c_str |name| {\n                         unsafe {\n                             llvm::LLVMDIBuilderCreateMemberType(\n                                 DIB(cx),\n-                                file_metadata,\n+                                containing_scope,\n                                 name,\n                                 file_metadata,\n                                 loc.line as c_uint,\n@@ -1210,7 +1243,7 @@ fn enum_metadata(cx: &mut CrateContext,\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n-                    file_metadata,\n+                    containing_scope,\n                     enum_name,\n                     file_metadata,\n                     loc.line as c_uint,\n@@ -1222,75 +1255,107 @@ fn enum_metadata(cx: &mut CrateContext,\n             }};\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n-            return adt_struct_metadata(cx, struct_def, variants[nndiscr], None, span);\n+            return adt_struct_metadata(cx,\n+                                       struct_def,\n+                                       variants[nndiscr],\n+                                       None,\n+                                       containing_scope,\n+                                       file_metadata,\n+                                       span);\n         }\n     }\n \n     fn adt_struct_metadata(cx: &mut CrateContext,\n                                   struct_def: &adt::Struct,\n                                   variant_info: &ty::VariantInfo,\n                                   discriminant_type_metadata: Option<DIType>,\n+                                  containing_scope: DIScope,\n+                                  file_metadata: DIFile,\n                                   span: Span)\n-                               -> DICompositeType\n-    {\n-        let arg_llvm_types: ~[Type] = do struct_def.fields.map |&ty| { type_of::type_of(cx, ty) };\n-        let arg_metadata: ~[DIType] = do struct_def.fields.iter().enumerate()\n-            .map |(i, &ty)| {\n-                match discriminant_type_metadata {\n-                    Some(metadata) if i == 0 => metadata,\n-                    _                        => type_metadata(cx, ty, span)\n-                }\n-        }.collect();\n-\n+                               -> DICompositeType {\n+        // Get the argument names from the enum variant info\n         let mut arg_names = match variant_info.arg_names {\n-            Some(ref names) => do names.map |ident| { token::ident_to_str(ident).to_owned() },\n-            None => do variant_info.args.map |_| { ~\"\" }\n+            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n+            None => do variant_info.args.map |_| { @\"\" }\n         };\n \n+        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n         if discriminant_type_metadata.is_some() {\n-            arg_names.insert(0, ~\"\");\n+            arg_names.insert(0, @\"\");\n         }\n \n-        let variant_llvm_type = Type::struct_(arg_llvm_types, struct_def.packed);\n-        let variant_name: &str = token::ident_to_str(&variant_info.name);\n+        let arg_descriptions : ~[MemberDescription] =\n+            do struct_def.fields.iter().enumerate().map |(i, &ty)| {\n+                MemberDescription {\n+                    name: arg_names[i].clone(),\n+                    llvm_type: type_of::type_of(cx, ty),\n+                    type_metadata: match discriminant_type_metadata {\n+                        Some(metadata) if i == 0 => metadata,\n+                        _                        => type_metadata(cx, ty, span)\n+                    }\n+                }\n+            }.collect();\n+\n+        let variant_name = token::ident_to_str(&variant_info.name);\n+        let variant_llvm_type = Type::struct_(arg_descriptions.map(|d| d.llvm_type),\n+                                              struct_def.packed);\n+\n+        // Find the source code location of the variant's definition\n+        let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n+            match cx.tcx.items.find(&variant_info.id.node) {\n+                Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n+                ref node => {\n+                    cx.sess.span_warn(span,\n+                        fmt!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n+                              type: %?. This is a bug.\", node));\n+                    codemap::dummy_sp()\n+                }\n+            }\n+        } else {\n+            // For definitions from other crates we have no location information available.\n+            codemap::dummy_sp()\n+        };\n \n         return composite_type_metadata(\n             cx,\n             variant_llvm_type,\n             variant_name,\n-            arg_llvm_types,\n-            arg_names,\n-            arg_metadata,\n-            span);\n+            arg_descriptions,\n+            containing_scope,\n+            file_metadata,\n+            variant_definition_span);\n     }\n }\n \n+struct MemberDescription {\n+    name: @str,\n+    llvm_type: Type,\n+    type_metadata: DIType,\n+}\n+\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n fn composite_type_metadata(cx: &mut CrateContext,\n                            composite_llvm_type: Type,\n                            composite_type_name: &str,\n-                           member_llvm_types: &[Type],\n-                           member_names: &[~str],\n-                           member_type_metadata: &[DIType],\n-                           span: Span)\n+                           member_descriptions: &[MemberDescription],\n+                           containing_scope: DIScope,\n+                           file_metadata: DIFile,\n+                           definition_span: Span)\n                         -> DICompositeType {\n-\n-    let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let loc = span_start(cx, definition_span);\n \n     let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n \n-    let member_metadata: ~[DIDescriptor] = member_llvm_types\n+    let member_metadata: ~[DIDescriptor] = member_descriptions\n         .iter()\n         .enumerate()\n-        .map(|(i, &member_llvm_type)| {\n-            let (member_size, member_align) = size_and_align_of(cx, member_llvm_type);\n+        .map(|(i, member_description)| {\n+            let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n-            let member_name: &str = member_names[i];\n \n-            do member_name.with_c_str |member_name| {\n+            do member_description.name.with_c_str |member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -1302,7 +1367,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n                         bytes_to_bits(member_align),\n                         bytes_to_bits(member_offset),\n                         0,\n-                        member_type_metadata[i])\n+                        member_description.type_metadata)\n                 }\n             }\n         })\n@@ -1312,7 +1377,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n         unsafe {\n             llvm::LLVMDIBuilderCreateStructType(\n                 DIB(cx),\n-                file_metadata,\n+                containing_scope,\n                 name,\n                 file_metadata,\n                 loc.line as c_uint,\n@@ -1323,8 +1388,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n                 create_DIArray(DIB(cx), member_metadata),\n                 0,\n                 ptr::null())\n-    }\n-    };\n+    }};\n }\n \n fn boxed_type_metadata(cx: &mut CrateContext,\n@@ -1333,36 +1397,57 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n                        content_type_metadata: DIType,\n                        span: Span)\n                     -> DICompositeType {\n-\n     let box_type_name = match content_type_name {\n         Some(content_type_name) => fmt!(\"Boxed<%s>\", content_type_name),\n         None                    => ~\"BoxedType\"\n     };\n \n     let box_llvm_type = Type::box(cx, &content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n-    let member_names = [~\"refcnt\", ~\"tydesc\", ~\"prev\", ~\"next\", ~\"val\"];\n-\n     assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n \n     let int_type = ty::mk_int();\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n+    let nil_pointer_type_metadata = type_metadata(cx, nil_pointer_type, codemap::dummy_sp());\n \n-    let member_types_metadata = [\n-        type_metadata(cx, int_type, span),\n-        type_metadata(cx, nil_pointer_type, span),\n-        type_metadata(cx, nil_pointer_type, span),\n-        type_metadata(cx, nil_pointer_type, span),\n-        content_type_metadata\n+    let member_descriptions = [\n+        MemberDescription {\n+            name: @\"refcnt\",\n+            llvm_type: member_llvm_types[0],\n+            type_metadata: type_metadata(cx, int_type, codemap::dummy_sp()),\n+        },\n+        MemberDescription {\n+            name: @\"tydesc\",\n+            llvm_type: member_llvm_types[1],\n+            type_metadata: nil_pointer_type_metadata,\n+        },\n+        MemberDescription {\n+            name: @\"prev\",\n+            llvm_type: member_llvm_types[2],\n+            type_metadata: nil_pointer_type_metadata,\n+        },\n+        MemberDescription {\n+            name: @\"next\",\n+            llvm_type: member_llvm_types[3],\n+            type_metadata: nil_pointer_type_metadata,\n+        },\n+        MemberDescription {\n+            name: @\"val\",\n+            llvm_type: member_llvm_types[4],\n+            type_metadata: content_type_metadata\n+        }\n     ];\n \n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n+\n     return composite_type_metadata(\n         cx,\n         box_llvm_type,\n         box_type_name,\n-        member_llvm_types,\n-        member_names,\n-        member_types_metadata,\n+        member_descriptions,\n+        file_metadata,\n+        file_metadata,\n         span);\n \n     // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n@@ -1420,7 +1505,6 @@ fn vec_metadata(cx: &mut CrateContext,\n     let vec_type_name: &str = fmt!(\"[%s]\", ty_to_str(cx.tcx, element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n-    let member_names = &[~\"fill\", ~\"alloc\", ~\"elements\"];\n \n     let int_type_metadata = type_metadata(cx, ty::mk_int(), span);\n     let array_type_metadata = unsafe {\n@@ -1432,16 +1516,36 @@ fn vec_metadata(cx: &mut CrateContext,\n             create_DIArray(DIB(cx), [llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0, 0)]))\n     };\n \n-    //                           fill               alloc              elements\n-    let member_type_metadata = &[int_type_metadata, int_type_metadata, array_type_metadata];\n+    let member_descriptions = [\n+        MemberDescription {\n+            name: @\"fill\",\n+            llvm_type: member_llvm_types[0],\n+            type_metadata: int_type_metadata,\n+        },\n+        MemberDescription {\n+            name: @\"alloc\",\n+            llvm_type: member_llvm_types[1],\n+            type_metadata: int_type_metadata,\n+        },\n+        MemberDescription {\n+            name: @\"elements\",\n+            llvm_type: member_llvm_types[2],\n+            type_metadata: array_type_metadata,\n+        }\n+    ];\n+\n+    assert!(member_descriptions.len() == member_llvm_types.len());\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n     return composite_type_metadata(\n         cx,\n         vec_llvm_type,\n         vec_type_name,\n-        member_llvm_types,\n-        member_names,\n-        member_type_metadata,\n+        member_descriptions,\n+        file_metadata,\n+        file_metadata,\n         span);\n }\n \n@@ -1475,22 +1579,35 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n     let slice_type_name = ty_to_str(cx.tcx, vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n-    let member_names = &[~\"data_ptr\", ~\"size_in_bytes\"];\n-\n     assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n \n     let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::MutImmutable });\n \n-    let member_type_metadata = &[type_metadata(cx, data_ptr_type, span),\n-                                 type_metadata(cx, ty::mk_uint(), span)];\n+    let member_descriptions = [\n+        MemberDescription {\n+            name: @\"data_ptr\",\n+            llvm_type: member_llvm_types[0],\n+            type_metadata: type_metadata(cx, data_ptr_type, span),\n+        },\n+        MemberDescription {\n+            name: @\"size_in_bytes\",\n+            llvm_type: member_llvm_types[1],\n+            type_metadata: type_metadata(cx, ty::mk_uint(), span),\n+        },\n+    ];\n+\n+    assert!(member_descriptions.len() == member_llvm_types.len());\n+\n+    let loc = span_start(cx, span);\n+    let file_metadata = file_metadata(cx, loc.file.name);\n \n     return composite_type_metadata(\n         cx,\n         slice_llvm_type,\n         slice_type_name,\n-        member_llvm_types,\n-        member_names,\n-        member_type_metadata,\n+        member_descriptions,\n+        file_metadata,\n+        file_metadata,\n         span);\n \n     fn slice_layout_is_correct(cx: &mut CrateContext,\n@@ -1551,7 +1668,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n fn type_metadata(cx: &mut CrateContext,\n                  t: ty::t,\n-                 span: Span)\n+                 usage_site_span: Span)\n               -> DIType {\n     let type_id = ty::type_id(t);\n     match debug_context(cx).created_types.find(&type_id) {\n@@ -1598,46 +1715,46 @@ fn type_metadata(cx: &mut CrateContext,\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    fixed_vec_metadata(cx, i8_t, len + 1, span)\n+                    fixed_vec_metadata(cx, i8_t, len + 1, usage_site_span)\n                 },\n                 ty::vstore_uniq  => {\n-                    let vec_metadata = vec_metadata(cx, i8_t, span);\n+                    let vec_metadata = vec_metadata(cx, i8_t, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n                 ty::vstore_box => {\n-                    let boxed_vec_metadata = boxed_vec_metadata(cx, i8_t, span);\n+                    let boxed_vec_metadata = boxed_vec_metadata(cx, i8_t, usage_site_span);\n                     pointer_type_metadata(cx, t, boxed_vec_metadata)\n                 }\n                 ty::vstore_slice(_region) => {\n-                    vec_slice_metadata(cx, t, i8_t, span)\n+                    vec_slice_metadata(cx, t, i8_t, usage_site_span)\n                 }\n             }\n         },\n         ty::ty_enum(def_id, _) => {\n-            enum_metadata(cx, t, def_id, span)\n+            enum_metadata(cx, t, def_id, usage_site_span)\n         },\n         ty::ty_box(ref mt) => {\n             create_pointer_to_box_metadata(cx, t, mt.ty)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    fixed_vec_metadata(cx, mt.ty, len, span)\n+                    fixed_vec_metadata(cx, mt.ty, len, usage_site_span)\n                 }\n                 ty::vstore_uniq if ty::type_contents(cx.tcx, mt.ty).contains_managed() => {\n-                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, span);\n+                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, boxed_vec_metadata)\n                 }\n                 ty::vstore_uniq => {\n-                    let vec_metadata = vec_metadata(cx, mt.ty, span);\n+                    let vec_metadata = vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, vec_metadata)\n                 }\n                 ty::vstore_box => {\n-                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, span);\n+                    let boxed_vec_metadata = boxed_vec_metadata(cx, mt.ty, usage_site_span);\n                     pointer_type_metadata(cx, t, boxed_vec_metadata)\n                 }\n                 ty::vstore_slice(_) => {\n-                    vec_slice_metadata(cx, t, mt.ty, span)\n+                    vec_slice_metadata(cx, t, mt.ty, usage_site_span)\n                 }\n             }\n         },\n@@ -1647,28 +1764,27 @@ fn type_metadata(cx: &mut CrateContext,\n         ty::ty_uniq(ref mt)    |\n         ty::ty_ptr(ref mt)     |\n         ty::ty_rptr(_, ref mt) => {\n-            let pointee = type_metadata(cx, mt.ty, span);\n+            let pointee = type_metadata(cx, mt.ty, usage_site_span);\n             pointer_type_metadata(cx, t, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n-            subroutine_type_metadata(cx, &barefnty.sig, span)\n+            subroutine_type_metadata(cx, &barefnty.sig, usage_site_span)\n         },\n         ty::ty_closure(ref closurety) => {\n-            subroutine_type_metadata(cx, &closurety.sig, span)\n+            subroutine_type_metadata(cx, &closurety.sig, usage_site_span)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n-            cx.sess.span_note(span, \"debuginfo for trait NYI\");\n+            cx.sess.span_note(usage_site_span, \"debuginfo for trait NYI\");\n             unimplemented_type_metadata(cx, t)\n         },\n-        ty::ty_struct(did, ref substs) => {\n-            let fields = ty::struct_fields(cx.tcx, did, substs);\n-            struct_metadata(cx, t, fields, span)\n+        ty::ty_struct(def_id, ref substs) => {\n+            struct_metadata(cx, t, def_id, substs, usage_site_span)\n         },\n         ty::ty_tup(ref elements) => {\n-            tuple_metadata(cx, t, *elements, span)\n+            tuple_metadata(cx, t, *elements, usage_site_span)\n         },\n         ty::ty_opaque_box => {\n-            cx.sess.span_note(span, \"debuginfo for ty_opaque_box NYI\");\n+            cx.sess.span_note(usage_site_span, \"debuginfo for ty_opaque_box NYI\");\n             unimplemented_type_metadata(cx, t)\n         }\n         _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n@@ -1771,6 +1887,28 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     }\n }\n \n+fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n+                                   def_id: ast::DefId,\n+                                   warning_span: Span)\n+                                -> (DIScope, Span) {\n+    if def_id.crate == ast::LOCAL_CRATE {\n+        let containing_scope = debug_context(cx).local_namespace_map.get_copy(&def_id.node).scope;\n+        let definition_span = match cx.tcx.items.find(&def_id.node) {\n+            Some(&ast_map::node_item(@ast::item { span, _ }, _)) => span,\n+            ref node => {\n+                cx.sess.span_warn(warning_span, fmt!(\"debuginfo::get_namespace_and_span_for_item() \\\n+                                                      - Unexpected node type: %?\", *node));\n+                codemap::dummy_sp()\n+            }\n+        };\n+        (containing_scope, definition_span)\n+    } else {\n+        let item_path = ty::item_path(cx.tcx, def_id);\n+        // For external items there is no span information\n+        (namespace_for_external_item(cx, &item_path).scope, codemap::dummy_sp())\n+    }\n+}\n+\n // This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n // the function's AST to the correct DIScope metadata instance.\n //\n@@ -2260,6 +2398,72 @@ impl NamespaceTree {\n     }\n }\n \n+fn namespace_for_external_item(cx: &mut CrateContext,\n+                               item_path: &ast_map::path)\n+                            -> @NamespaceTree {\n+    if item_path.len() < 2 {\n+        cx.sess.bug(fmt!(\"debuginfo::namespace_for_external_item() - Invalid item_path: %s\",\n+            ast_map::path_to_str(*item_path, token::get_ident_interner())));\n+    }\n+\n+    let path_excluding_item = item_path.slice_to(item_path.len() - 1);\n+    let mut current_key = vec::with_capacity(path_excluding_item.len());\n+    let mut parent_node: Option<@NamespaceTree> = None;\n+    let last_index = path_excluding_item.len() - 1;\n+\n+    for (i, &path_element) in path_excluding_item.iter().enumerate() {\n+        let ident = match path_element {\n+            ast_map::path_mod(ident)            |\n+            ast_map::path_name(ident)           |\n+            ast_map::path_pretty_name(ident, _) => ident\n+        };\n+\n+        current_key.push(ident);\n+\n+        let existing_node = debug_context(cx).extern_namespaces.find_copy(&current_key);\n+        let current_node = match existing_node {\n+            Some(existing_node) => existing_node,\n+            None => {\n+                // create and insert\n+                let parent_scope = match parent_node {\n+                    Some(node) => node.scope,\n+                    None => ptr::null()\n+                };\n+                let namespace_name = token::ident_to_str(&ident);\n+\n+                let namespace_metadata = unsafe {\n+                    do namespace_name.with_c_str |namespace_name| {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name,\n+                            ptr::null(), // cannot reconstruct file ...\n+                            0)           // ... or line information\n+                    }\n+                };\n+\n+                let node = @NamespaceTree {\n+                    ident: ident,\n+                    scope: namespace_metadata,\n+                    parent: parent_node,\n+                };\n+\n+                debug_context(cx).extern_namespaces.insert(current_key.clone(), node);\n+\n+                node\n+            }\n+        };\n+\n+        if i == last_index {\n+            return current_node;\n+        } else {\n+            parent_node = Some(current_node);\n+        }\n+    }\n+\n+    cx.sess.bug(\"debuginfo::namespace_for_external_item() - Code path should be unreachable\");\n+}\n+\n struct NamespaceVisitor<'self> {\n     module_ident: ast::Ident,\n     scope_stack: ~[@NamespaceTree],\n@@ -2369,21 +2573,24 @@ impl<'self> visit::Visitor<()> for NamespaceVisitor<'self> {\n             }\n             ast::item_fn(*) => { /* handled by visit_fn */ }\n             _ => {\n-                debug_context(self.crate_context).namespace_map.insert(item.id,\n-                                                                       *self.scope_stack.last());\n+                debug_context(self.crate_context)\n+                    .local_namespace_map\n+                    .insert(item.id, *self.scope_stack.last());\n             }\n         }\n \n         visit::walk_item(self, item, ());\n     }\n \n     fn visit_fn(&mut self,\n-                function_kind: &visit::fn_kind,\n+                _: &visit::fn_kind,\n                 _: &ast::fn_decl,\n-                block: &ast::Block,\n-                span: Span,\n+                _: &ast::Block,\n+                _: Span,\n                 node_id: ast::NodeId,\n                 _: ()) {\n-        debug_context(self.crate_context).namespace_map.insert(node_id, *self.scope_stack.last());\n+        debug_context(self.crate_context)\n+            .local_namespace_map\n+            .insert(node_id, *self.scope_stack.last());\n     }\n }"}]}