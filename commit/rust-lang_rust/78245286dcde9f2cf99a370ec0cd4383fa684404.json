{"sha": "78245286dcde9f2cf99a370ec0cd4383fa684404", "node_id": "C_kwDOAAsO6NoAKDc4MjQ1Mjg2ZGNkZTlmMmNmOTlhMzcwZWMwY2Q0MzgzZmE2ODQ0MDQ", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-12-31T10:00:54Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-12-31T10:00:54Z"}, "message": "std: use id-based thread parking on SOLID", "tree": {"sha": "595c18d4e82ed2c74443128948582e20253a08d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/595c18d4e82ed2c74443128948582e20253a08d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78245286dcde9f2cf99a370ec0cd4383fa684404", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmOwCFYACgkQcE4BSbAZ\nSzwBtA/9EUYkqwkIRhvOoRWLMr4XHXXHfphhrx5u4+BABz7/FuILxMnL/C2Hcunp\nNkb7TkTu2fj4m00eLY1ikqmJs2Aj+FHGesj8o/nj2awICEQ9RXatrHScmJjWz2F4\nZjdA+gUC2yxNogNEnm9o5MwqGBYEYP4mq37pMqbaaalnEtYEDh23qG48rrLUPzxC\nmD7fzoDhNbgycOX1pef2XhsV/xtWh+XOS0++qFITDoHa+MTQTGCODxYp5dY6pN2k\nDUM3d9yJoXRbCkiK8PUWlgh9lK/kIWpv78QpvfKuml3/j5eiVLOYTvhjDj+kMl/w\nyN/cPBFfpjDDf77qPRfZMW1t9YqtREomatLtijAU7hZARq2BqHmuYft7LNs+RScP\naokFgKSZy/nb/MsGFEZeHr9NWsiThAeiYqSMEWjeLcLOnVuJfJ7ZakDF5SrOuxwW\nRxoel+OBMpsZ75zAlnmxpVj6asdqUmcDLcWsxAyuYQlVzxlTL1cFFQlpq71S7omF\nUChtPSFDMRrENFTSNMg9FzOTLZlhlFjpRwy3mLEG0Y7HrkTPzz8Fn9rbf3p4R5kx\nn+BQk/MyosGFuwFQB/7m8wLhehbGM7ux3ZKkOXpRV/a9Z6o1YNyfCkZ1nW+EciQM\noxyboGX4nZINPvNb44R5Rk6QJc5PVANiDyEqs0UvJur9rT79O44=\n=t79D\n-----END PGP SIGNATURE-----", "payload": "tree 595c18d4e82ed2c74443128948582e20253a08d2\nparent 247e44e61d934e1927db0ff557fe17f131a2379c\nauthor joboet <jonasboettiger@icloud.com> 1672480854 +0100\ncommitter joboet <jonasboettiger@icloud.com> 1672480854 +0100\n\nstd: use id-based thread parking on SOLID\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78245286dcde9f2cf99a370ec0cd4383fa684404", "html_url": "https://github.com/rust-lang/rust/commit/78245286dcde9f2cf99a370ec0cd4383fa684404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78245286dcde9f2cf99a370ec0cd4383fa684404/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "247e44e61d934e1927db0ff557fe17f131a2379c", "url": "https://api.github.com/repos/rust-lang/rust/commits/247e44e61d934e1927db0ff557fe17f131a2379c", "html_url": "https://github.com/rust-lang/rust/commit/247e44e61d934e1927db0ff557fe17f131a2379c"}], "stats": {"total": 219, "additions": 40, "deletions": 179}, "files": [{"sha": "fe9934439d152fddbfa0c417abae9c8a465a7cf6", "filename": "library/std/src/sys/itron/thread_parking.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/78245286dcde9f2cf99a370ec0cd4383fa684404/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78245286dcde9f2cf99a370ec0cd4383fa684404/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs?ref=78245286dcde9f2cf99a370ec0cd4383fa684404", "patch": "@@ -0,0 +1,37 @@\n+use super::abi;\n+use super::error::expect_success_aborting;\n+use super::time::with_tmos;\n+use crate::time::Duration;\n+\n+pub type ThreadId = abi::ID;\n+\n+pub use super::task::current_task_id_aborting as current;\n+\n+pub fn park(_hint: usize) {\n+    match unsafe { abi::slp_tsk() } {\n+        abi::E_OK | abi::E_RLWAI => {}\n+        err => {\n+            expect_success_aborting(err, &\"slp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    match with_tmos(dur, |tmo| unsafe { abi::tslp_tsk(tmo) }) {\n+        abi::E_OK | abi::E_RLWAI | abi::E_TMOUT => {}\n+        err => {\n+            expect_success_aborting(err, &\"tslp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn unpark(id: ThreadId, _hint: usize) {\n+    match unsafe { abi::wup_tsk(id) } {\n+        // It is allowed to try to wake up a destroyed or unrelated task, so we ignore all\n+        // errors that could result from that situation.\n+        abi::E_OK | abi::E_NOEXS | abi::E_OBJ | abi::E_QOVR => {}\n+        err => {\n+            expect_success_aborting(err, &\"wup_tsk\");\n+        }\n+    }\n+}"}, {"sha": "e432edd207754e5151252c136a0946d0821d1a6a", "filename": "library/std/src/sys/itron/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -1,72 +0,0 @@\n-use crate::mem::MaybeUninit;\n-use crate::time::Duration;\n-\n-use super::{\n-    abi,\n-    error::{expect_success, fail},\n-    time::with_tmos,\n-};\n-\n-const CLEAR: abi::FLGPTN = 0;\n-const RAISED: abi::FLGPTN = 1;\n-\n-/// A thread parking primitive that is not susceptible to race conditions,\n-/// but provides no atomic ordering guarantees and allows only one `raise` per wait.\n-pub struct WaitFlag {\n-    flag: abi::ID,\n-}\n-\n-impl WaitFlag {\n-    /// Creates a new wait flag.\n-    pub fn new() -> WaitFlag {\n-        let flag = expect_success(\n-            unsafe {\n-                abi::acre_flg(&abi::T_CFLG {\n-                    flgatr: abi::TA_FIFO | abi::TA_WSGL | abi::TA_CLR,\n-                    iflgptn: CLEAR,\n-                })\n-            },\n-            &\"acre_flg\",\n-        );\n-\n-        WaitFlag { flag }\n-    }\n-\n-    /// Wait for the wait flag to be raised.\n-    pub fn wait(&self) {\n-        let mut token = MaybeUninit::uninit();\n-        expect_success(\n-            unsafe { abi::wai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr()) },\n-            &\"wai_flg\",\n-        );\n-    }\n-\n-    /// Wait for the wait flag to be raised or the timeout to occur.\n-    ///\n-    /// Returns whether the flag was raised (`true`) or the operation timed out (`false`).\n-    pub fn wait_timeout(&self, dur: Duration) -> bool {\n-        let mut token = MaybeUninit::uninit();\n-        let res = with_tmos(dur, |tmout| unsafe {\n-            abi::twai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr(), tmout)\n-        });\n-\n-        match res {\n-            abi::E_OK => true,\n-            abi::E_TMOUT => false,\n-            error => fail(error, &\"twai_flg\"),\n-        }\n-    }\n-\n-    /// Raise the wait flag.\n-    ///\n-    /// Calls to this function should be balanced with the number of successful waits.\n-    pub fn raise(&self) {\n-        expect_success(unsafe { abi::set_flg(self.flag, RAISED) }, &\"set_flg\");\n-    }\n-}\n-\n-impl Drop for WaitFlag {\n-    fn drop(&mut self) {\n-        expect_success(unsafe { abi::del_flg(self.flag) }, &\"del_flg\");\n-    }\n-}"}, {"sha": "923d27fd9369d40219d1777cfef77e5e1332909f", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78245286dcde9f2cf99a370ec0cd4383fa684404/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78245286dcde9f2cf99a370ec0cd4383fa684404/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=78245286dcde9f2cf99a370ec0cd4383fa684404", "patch": "@@ -13,9 +13,9 @@ mod itron {\n     pub(super) mod spin;\n     pub(super) mod task;\n     pub mod thread;\n+    pub mod thread_parking;\n     pub(super) mod time;\n     use super::unsupported;\n-    pub mod wait_flag;\n }\n \n pub mod alloc;\n@@ -43,8 +43,8 @@ pub use self::itron::thread;\n pub mod memchr;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub use self::itron::thread_parking;\n pub mod time;\n-pub use self::itron::wait_flag;\n \n mod rwlock;\n "}, {"sha": "e8e028bb3308f1c480b2ced3e33d6ebda6d370ab", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78245286dcde9f2cf99a370ec0cd4383fa684404/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78245286dcde9f2cf99a370ec0cd4383fa684404/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=78245286dcde9f2cf99a370ec0cd4383fa684404", "patch": "@@ -14,12 +14,10 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         target_os = \"netbsd\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+        target_os = \"solid_asp3\",\n     ))] {\n         mod id;\n         pub use id::Parker;\n-    } else if #[cfg(target_os = \"solid_asp3\")] {\n-        mod wait_flag;\n-        pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parking::Parker;\n     } else {"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247e44e61d934e1927db0ff557fe17f131a2379c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=247e44e61d934e1927db0ff557fe17f131a2379c", "patch": "@@ -1,102 +0,0 @@\n-//! A wait-flag-based thread parker.\n-//!\n-//! Some operating systems provide low-level parking primitives like wait counts,\n-//! event flags or semaphores which are not susceptible to race conditions (meaning\n-//! the wakeup can occur before the wait operation). To implement the `std` thread\n-//! parker on top of these primitives, we only have to ensure that parking is fast\n-//! when the thread token is available, the atomic ordering guarantees are maintained\n-//! and spurious wakeups are minimized.\n-//!\n-//! To achieve this, this parker uses an atomic variable with three states: `EMPTY`,\n-//! `PARKED` and `NOTIFIED`:\n-//! * `EMPTY` means the token has not been made available, but the thread is not\n-//!    currently waiting on it.\n-//! * `PARKED` means the token is not available and the thread is parked.\n-//! * `NOTIFIED` means the token is available.\n-//!\n-//! `park` and `park_timeout` change the state from `EMPTY` to `PARKED` and from\n-//! `NOTIFIED` to `EMPTY`. If the state was `NOTIFIED`, the thread was unparked and\n-//! execution can continue without calling into the OS. If the state was `EMPTY`,\n-//! the token is not available and the thread waits on the primitive (here called\n-//! \"wait flag\").\n-//!\n-//! `unpark` changes the state to `NOTIFIED`. If the state was `PARKED`, the thread\n-//! is or will be sleeping on the wait flag, so we raise it.\n-\n-use crate::pin::Pin;\n-use crate::sync::atomic::AtomicI8;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::sys::wait_flag::WaitFlag;\n-use crate::time::Duration;\n-\n-const EMPTY: i8 = 0;\n-const PARKED: i8 = -1;\n-const NOTIFIED: i8 = 1;\n-\n-pub struct Parker {\n-    state: AtomicI8,\n-    wait_flag: WaitFlag,\n-}\n-\n-impl Parker {\n-    /// Construct a parker for the current thread. The UNIX parker\n-    /// implementation requires this to happen in-place.\n-    pub unsafe fn new_in_place(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            // NOTIFIED => EMPTY\n-            NOTIFIED => return,\n-            // EMPTY => PARKED\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        // Avoid waking up from spurious wakeups (these are quite likely, see below).\n-        loop {\n-            self.wait_flag.wait();\n-\n-            match self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Relaxed) {\n-                Ok(_) => return,\n-                Err(PARKED) => (),\n-                Err(_) => panic!(\"inconsistent park state\"),\n-            }\n-        }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            NOTIFIED => return,\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        self.wait_flag.wait_timeout(dur);\n-\n-        // Either a wakeup or a timeout occurred. Wakeups may be spurious, as there can be\n-        // a race condition when `unpark` is performed between receiving the timeout and\n-        // resetting the state, resulting in the eventflag being set unnecessarily. `park`\n-        // is protected against this by looping until the token is actually given, but\n-        // here we cannot easily tell.\n-\n-        // Use `swap` to provide acquire ordering.\n-        match self.state.swap(EMPTY, Acquire) {\n-            NOTIFIED => (),\n-            PARKED => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if state == PARKED {\n-            self.wait_flag.raise();\n-        }\n-    }\n-}"}]}