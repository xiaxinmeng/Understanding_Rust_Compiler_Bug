{"sha": "b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882", "node_id": "C_kwDOAAsO6NoAKGIwMGQwZmEwYzliOGI4YjI0NjVmODI3ZGZjMDgxZThjOWEwN2Q4ODI", "commit": {"author": {"name": "Nikita Popov", "email": "npopov@redhat.com", "date": "2022-07-25T12:04:26Z"}, "committer": {"name": "Nikita Popov", "email": "npopov@redhat.com", "date": "2022-07-27T14:19:07Z"}, "message": "Reliably signal coordinator thread on panic during ongoing codegen\n\nReplace the separate AbortCodegenOnDrop guard by integrating this\nfunctionality into OngoingCodegen (or rather, the Coordinator part\nof it). This ensures that we send a CodegenAborted message and\nwait for workers to finish even if the panic occurs outside\ncodegen_crate() (e.g. inside join_codegen()).\n\nThis requires some minor changes to the handling of CodegenAborted,\nas it can now occur when the main thread is LLVMing rather than\nCodegenning.", "tree": {"sha": "eb96bc1eda383e46a29e1f6c03a9452ed8f01a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb96bc1eda383e46a29e1f6c03a9452ed8f01a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882", "html_url": "https://github.com/rust-lang/rust/commit/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a1f77dba4c172a914bbbe7d3c789be528a61b9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1f77dba4c172a914bbbe7d3c789be528a61b9a", "html_url": "https://github.com/rust-lang/rust/commit/6a1f77dba4c172a914bbbe7d3c789be528a61b9a"}], "stats": {"total": 119, "additions": 43, "deletions": 76}, "files": [{"sha": "d1643eb271ea3d26b445774c2ed8f9f3544b4e38", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882", "patch": "@@ -37,6 +37,7 @@ use rustc_target::spec::{MergeFunctions, SanitizerSet};\n use std::any::Any;\n use std::fs;\n use std::io;\n+use std::marker::PhantomData;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::str;\n@@ -475,10 +476,13 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         metadata_module,\n         crate_info,\n \n-        coordinator_send,\n         codegen_worker_receive,\n         shared_emitter_main,\n-        future: coordinator_thread,\n+        coordinator: Coordinator {\n+            sender: coordinator_send,\n+            future: Some(coordinator_thread),\n+            phantom: PhantomData,\n+        },\n         output_filenames: tcx.output_filenames(()).clone(),\n     }\n }\n@@ -1273,6 +1277,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         // work to be done.\n         while !codegen_done\n             || running > 0\n+            || main_thread_worker_state == MainThreadWorkerState::LLVMing\n             || (!codegen_aborted\n                 && !(work_items.is_empty()\n                     && needs_fat_lto.is_empty()\n@@ -1492,7 +1497,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                     assert!(!codegen_aborted);\n                     codegen_done = true;\n                     codegen_aborted = true;\n-                    assert_eq!(main_thread_worker_state, MainThreadWorkerState::Codegenning);\n                 }\n                 Message::Done { result: Ok(compiled_module), worker_id } => {\n                     free_worker(worker_id);\n@@ -1539,6 +1543,10 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             }\n         }\n \n+        if codegen_aborted {\n+            return Err(());\n+        }\n+\n         let needs_link = mem::take(&mut needs_link);\n         if !needs_link.is_empty() {\n             assert!(compiled_modules.is_empty());\n@@ -1828,25 +1836,47 @@ impl SharedEmitterMain {\n     }\n }\n \n+pub struct Coordinator<B: ExtraBackendMethods> {\n+    pub sender: Sender<Box<dyn Any + Send>>,\n+    future: Option<thread::JoinHandle<Result<CompiledModules, ()>>>,\n+    // Only used for the Message type.\n+    phantom: PhantomData<B>,\n+}\n+\n+impl<B: ExtraBackendMethods> Coordinator<B> {\n+    fn join(mut self) -> std::thread::Result<Result<CompiledModules, ()>> {\n+        self.future.take().unwrap().join()\n+    }\n+}\n+\n+impl<B: ExtraBackendMethods> Drop for Coordinator<B> {\n+    fn drop(&mut self) {\n+        if let Some(future) = self.future.take() {\n+            // If we haven't joined yet, signal to the coordinator that it should spawn no more\n+            // work, and wait for worker threads to finish.\n+            drop(self.sender.send(Box::new(Message::CodegenAborted::<B>)));\n+            drop(future.join());\n+        }\n+    }\n+}\n+\n pub struct OngoingCodegen<B: ExtraBackendMethods> {\n     pub backend: B,\n     pub metadata: EncodedMetadata,\n     pub metadata_module: Option<CompiledModule>,\n     pub crate_info: CrateInfo,\n-    pub coordinator_send: Sender<Box<dyn Any + Send>>,\n     pub codegen_worker_receive: Receiver<Message<B>>,\n     pub shared_emitter_main: SharedEmitterMain,\n-    pub future: thread::JoinHandle<Result<CompiledModules, ()>>,\n     pub output_filenames: Arc<OutputFilenames>,\n+    pub coordinator: Coordinator<B>,\n }\n \n impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n     pub fn join(self, sess: &Session) -> (CodegenResults, FxHashMap<WorkProductId, WorkProduct>) {\n         let _timer = sess.timer(\"finish_ongoing_codegen\");\n \n         self.shared_emitter_main.check(sess, true);\n-        let future = self.future;\n-        let compiled_modules = sess.time(\"join_worker_thread\", || match future.join() {\n+        let compiled_modules = sess.time(\"join_worker_thread\", || match self.coordinator.join() {\n             Ok(Ok(compiled_modules)) => compiled_modules,\n             Ok(Err(())) => {\n                 sess.abort_if_errors();\n@@ -1894,26 +1924,13 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         // These are generally cheap and won't throw off scheduling.\n         let cost = 0;\n-        submit_codegened_module_to_llvm(&self.backend, &self.coordinator_send, module, cost);\n+        submit_codegened_module_to_llvm(&self.backend, &self.coordinator.sender, module, cost);\n     }\n \n     pub fn codegen_finished(&self, tcx: TyCtxt<'_>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n-        drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n-    }\n-\n-    /// Consumes this context indicating that codegen was entirely aborted, and\n-    /// we need to exit as quickly as possible.\n-    ///\n-    /// This method blocks the current thread until all worker threads have\n-    /// finished, and all worker threads should have exited or be real close to\n-    /// exiting at this point.\n-    pub fn codegen_aborted(self) {\n-        // Signal to the coordinator it should spawn no more work and start\n-        // shutdown.\n-        drop(self.coordinator_send.send(Box::new(Message::CodegenAborted::<B>)));\n-        drop(self.future.join());\n+        drop(self.coordinator.sender.send(Box::new(Message::CodegenComplete::<B>)));\n     }\n \n     pub fn check_for_errors(&self, sess: &Session) {"}, {"sha": "a840b27097492d2fe253255afe85d809ef4cd621", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=b00d0fa0c9b8b8b2465f827dfc081e8c9a07d882", "patch": "@@ -39,7 +39,6 @@ use rustc_target::abi::{Align, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::convert::TryFrom;\n-use std::ops::{Deref, DerefMut};\n use std::time::{Duration, Instant};\n \n use itertools::Itertools;\n@@ -583,7 +582,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         metadata_module,\n         codegen_units.len(),\n     );\n-    let ongoing_codegen = AbortCodegenOnDrop::<B>(Some(ongoing_codegen));\n \n     // Codegen an allocator shim, if necessary.\n     //\n@@ -704,7 +702,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n                 submit_codegened_module_to_llvm(\n                     &backend,\n-                    &ongoing_codegen.coordinator_send,\n+                    &ongoing_codegen.coordinator.sender,\n                     module,\n                     cost,\n                 );\n@@ -714,7 +712,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 submit_pre_lto_module_to_llvm(\n                     &backend,\n                     tcx,\n-                    &ongoing_codegen.coordinator_send,\n+                    &ongoing_codegen.coordinator.sender,\n                     CachedModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: cgu.previous_work_product(tcx),\n@@ -725,7 +723,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             CguReuse::PostLto => {\n                 submit_post_lto_module_to_llvm(\n                     &backend,\n-                    &ongoing_codegen.coordinator_send,\n+                    &ongoing_codegen.coordinator.sender,\n                     CachedModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: cgu.previous_work_product(tcx),\n@@ -752,55 +750,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     }\n \n     ongoing_codegen.check_for_errors(tcx.sess);\n-\n-    ongoing_codegen.into_inner()\n-}\n-\n-/// A curious wrapper structure whose only purpose is to call `codegen_aborted`\n-/// when it's dropped abnormally.\n-///\n-/// In the process of working on rust-lang/rust#55238 a mysterious segfault was\n-/// stumbled upon. The segfault was never reproduced locally, but it was\n-/// suspected to be related to the fact that codegen worker threads were\n-/// sticking around by the time the main thread was exiting, causing issues.\n-///\n-/// This structure is an attempt to fix that issue where the `codegen_aborted`\n-/// message will block until all workers have finished. This should ensure that\n-/// even if the main codegen thread panics we'll wait for pending work to\n-/// complete before returning from the main thread, hopefully avoiding\n-/// segfaults.\n-///\n-/// If you see this comment in the code, then it means that this workaround\n-/// worked! We may yet one day track down the mysterious cause of that\n-/// segfault...\n-struct AbortCodegenOnDrop<B: ExtraBackendMethods>(Option<OngoingCodegen<B>>);\n-\n-impl<B: ExtraBackendMethods> AbortCodegenOnDrop<B> {\n-    fn into_inner(mut self) -> OngoingCodegen<B> {\n-        self.0.take().unwrap()\n-    }\n-}\n-\n-impl<B: ExtraBackendMethods> Deref for AbortCodegenOnDrop<B> {\n-    type Target = OngoingCodegen<B>;\n-\n-    fn deref(&self) -> &OngoingCodegen<B> {\n-        self.0.as_ref().unwrap()\n-    }\n-}\n-\n-impl<B: ExtraBackendMethods> DerefMut for AbortCodegenOnDrop<B> {\n-    fn deref_mut(&mut self) -> &mut OngoingCodegen<B> {\n-        self.0.as_mut().unwrap()\n-    }\n-}\n-\n-impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n-    fn drop(&mut self) {\n-        if let Some(codegen) = self.0.take() {\n-            codegen.codegen_aborted();\n-        }\n-    }\n+    ongoing_codegen\n }\n \n impl CrateInfo {"}]}