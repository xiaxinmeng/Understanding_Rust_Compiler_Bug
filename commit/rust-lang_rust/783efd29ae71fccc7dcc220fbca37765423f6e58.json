{"sha": "783efd29ae71fccc7dcc220fbca37765423f6e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4M2VmZDI5YWU3MWZjY2M3ZGNjMjIwZmJjYTM3NzY1NDIzZjZlNTg=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-18T05:21:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-18T05:21:54Z"}, "message": "Rollup merge of #86843 - FabianWolff:issue-86820, r=lcnr\n\nCheck that const parameters of trait methods have compatible types\n\nThis PR fixes #86820. The problem is that this currently passes the type checker:\n```rust\ntrait Tr {\n    fn foo<const N: u8>(self) -> u8;\n}\n\nimpl Tr for f32 {\n    fn foo<const N: bool>(self) -> u8 { 42 }\n}\n```\ni.e. the type checker fails to check whether const parameters in `impl` methods have the same type as the corresponding declaration in the trait. With my changes, I get, for the above code:\n```\nerror[E0053]: method `foo` has an incompatible const parameter type for trait\n --> test.rs:6:18\n  |\n6 |     fn foo<const N: bool>(self) -> u8 { 42 }\n  |                  ^\n  |\nnote: the const parameter `N` has type `bool`, but the declaration in trait `Tr::foo` has type `u8`\n --> test.rs:2:18\n  |\n2 |     fn foo<const N: u8>(self) -> u8;\n  |                  ^\n\nerror: aborting due to previous error\n```\nThis fixes #86820, where an ICE happens later on because the trait method is declared with a const parameter of type `u8`, but the `impl` uses one of type `usize`:\n> `expected int of size 8, but got size 1`", "tree": {"sha": "2aad8fac8f1dd8b69e4eea0ca434b4c99d37f03b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aad8fac8f1dd8b69e4eea0ca434b4c99d37f03b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/783efd29ae71fccc7dcc220fbca37765423f6e58", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg87pyCRBK7hj4Ov3rIwAAi2kIAD039qHNtOucQm9HQMB5Sekz\nEpSfCKJ0Sc1LNROgI8cbe4k3A0bPSU3ILUhIDwR1jew7B7kmRKzWiIx5Im0EgeEc\nUEYlPFjZJhnQqS/ESgKrzPEDdNRM7UpHfAB+1uEt0SQ6l0ovhNM4ewV/Q2JUf0X+\nFoSSkJx0Scl2yK6rFkYqSqjxx12o13Ffz369Ivzs2cDuBVgecL3OE7KlGngF16F4\nfWGPtLjP7mGLgsgDb/aIeLC0+3h9kU7yn5Lsy731XUwr+eVO6/xZ5z4x8EJm6Err\nIWtsDbyb5jFqaSh8aErwJodgzRaKTD84rcgTQm0iRgF3meI/sCPXXgBL97MghRQ=\n=Vv3e\n-----END PGP SIGNATURE-----\n", "payload": "tree 2aad8fac8f1dd8b69e4eea0ca434b4c99d37f03b\nparent 469935f7a46e1e3f33b2c70919c70570acaeeed7\nparent 9b874c400388a2158b6575e139752b3d0a27645b\nauthor Yuki Okushi <jtitor@2k36.org> 1626585714 +0900\ncommitter GitHub <noreply@github.com> 1626585714 +0900\n\nRollup merge of #86843 - FabianWolff:issue-86820, r=lcnr\n\nCheck that const parameters of trait methods have compatible types\n\nThis PR fixes #86820. The problem is that this currently passes the type checker:\n```rust\ntrait Tr {\n    fn foo<const N: u8>(self) -> u8;\n}\n\nimpl Tr for f32 {\n    fn foo<const N: bool>(self) -> u8 { 42 }\n}\n```\ni.e. the type checker fails to check whether const parameters in `impl` methods have the same type as the corresponding declaration in the trait. With my changes, I get, for the above code:\n```\nerror[E0053]: method `foo` has an incompatible const parameter type for trait\n --> test.rs:6:18\n  |\n6 |     fn foo<const N: bool>(self) -> u8 { 42 }\n  |                  ^\n  |\nnote: the const parameter `N` has type `bool`, but the declaration in trait `Tr::foo` has type `u8`\n --> test.rs:2:18\n  |\n2 |     fn foo<const N: u8>(self) -> u8;\n  |                  ^\n\nerror: aborting due to previous error\n```\nThis fixes #86820, where an ICE happens later on because the trait method is declared with a const parameter of type `u8`, but the `impl` uses one of type `usize`:\n> `expected int of size 8, but got size 1`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/783efd29ae71fccc7dcc220fbca37765423f6e58", "html_url": "https://github.com/rust-lang/rust/commit/783efd29ae71fccc7dcc220fbca37765423f6e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/783efd29ae71fccc7dcc220fbca37765423f6e58/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "469935f7a46e1e3f33b2c70919c70570acaeeed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/469935f7a46e1e3f33b2c70919c70570acaeeed7", "html_url": "https://github.com/rust-lang/rust/commit/469935f7a46e1e3f33b2c70919c70570acaeeed7"}, {"sha": "9b874c400388a2158b6575e139752b3d0a27645b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b874c400388a2158b6575e139752b3d0a27645b", "html_url": "https://github.com/rust-lang/rust/commit/9b874c400388a2158b6575e139752b3d0a27645b"}], "stats": {"total": 106, "additions": 106, "deletions": 0}, "files": [{"sha": "d35868881558e31fafdbe338658060340af6035d", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/783efd29ae71fccc7dcc220fbca37765423f6e58/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783efd29ae71fccc7dcc220fbca37765423f6e58/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=783efd29ae71fccc7dcc220fbca37765423f6e58", "patch": "@@ -66,6 +66,10 @@ crate fn compare_impl_method<'tcx>(\n     {\n         return;\n     }\n+\n+    if let Err(ErrorReported) = compare_const_param_types(tcx, impl_m, trait_m, trait_item_span) {\n+        return;\n+    }\n }\n \n fn compare_predicate_entailment<'tcx>(\n@@ -929,6 +933,68 @@ fn compare_synthetic_generics<'tcx>(\n     if error_found { Err(ErrorReported) } else { Ok(()) }\n }\n \n+fn compare_const_param_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    trait_m: &ty::AssocItem,\n+    trait_item_span: Option<Span>,\n+) -> Result<(), ErrorReported> {\n+    let const_params_of = |def_id| {\n+        tcx.generics_of(def_id).params.iter().filter_map(|param| match param.kind {\n+            GenericParamDefKind::Const { .. } => Some(param.def_id),\n+            _ => None,\n+        })\n+    };\n+    let const_params_impl = const_params_of(impl_m.def_id);\n+    let const_params_trait = const_params_of(trait_m.def_id);\n+\n+    for (const_param_impl, const_param_trait) in iter::zip(const_params_impl, const_params_trait) {\n+        let impl_ty = tcx.type_of(const_param_impl);\n+        let trait_ty = tcx.type_of(const_param_trait);\n+        if impl_ty != trait_ty {\n+            let (impl_span, impl_ident) = match tcx.hir().get_if_local(const_param_impl) {\n+                Some(hir::Node::GenericParam(hir::GenericParam { span, name, .. })) => (\n+                    span,\n+                    match name {\n+                        hir::ParamName::Plain(ident) => Some(ident),\n+                        _ => None,\n+                    },\n+                ),\n+                other => bug!(\n+                    \"expected GenericParam, found {:?}\",\n+                    other.map_or_else(|| \"nothing\".to_string(), |n| format!(\"{:?}\", n))\n+                ),\n+            };\n+            let trait_span = match tcx.hir().get_if_local(const_param_trait) {\n+                Some(hir::Node::GenericParam(hir::GenericParam { span, .. })) => Some(span),\n+                _ => None,\n+            };\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                *impl_span,\n+                E0053,\n+                \"method `{}` has an incompatible const parameter type for trait\",\n+                trait_m.ident\n+            );\n+            err.span_note(\n+                trait_span.map_or_else(|| trait_item_span.unwrap_or(*impl_span), |span| *span),\n+                &format!(\n+                    \"the const parameter{} has type `{}`, but the declaration \\\n+                              in trait `{}` has type `{}`\",\n+                    &impl_ident.map_or_else(|| \"\".to_string(), |ident| format!(\" `{}`\", ident)),\n+                    impl_ty,\n+                    tcx.def_path_str(trait_m.def_id),\n+                    trait_ty\n+                ),\n+            );\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n crate fn compare_const_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_c: &ty::AssocItem,"}, {"sha": "04650403c6bafe70b6b1c7c8be14ff44555d36c7", "filename": "src/test/ui/const-generics/issue-86820.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/783efd29ae71fccc7dcc220fbca37765423f6e58/src%2Ftest%2Fui%2Fconst-generics%2Fissue-86820.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783efd29ae71fccc7dcc220fbca37765423f6e58/src%2Ftest%2Fui%2Fconst-generics%2Fissue-86820.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-86820.rs?ref=783efd29ae71fccc7dcc220fbca37765423f6e58", "patch": "@@ -0,0 +1,25 @@\n+// Regression test for the ICE described in #86820.\n+\n+#![allow(unused,dead_code)]\n+use std::ops::BitAnd;\n+\n+const C: fn() = || is_set();\n+fn is_set() {\n+    0xffu8.bit::<0>();\n+}\n+\n+trait Bits {\n+    fn bit<const I : u8>(self) -> bool;\n+    //~^ NOTE: the const parameter `I` has type `usize`, but the declaration in trait `Bits::bit` has type `u8`\n+}\n+\n+impl Bits for u8 {\n+    fn bit<const I : usize>(self) -> bool {\n+    //~^ ERROR: method `bit` has an incompatible const parameter type for trait [E0053]\n+        let i = 1 << I;\n+        let mask = u8::from(i);\n+        mask & self == mask\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f4396f2f2b0a27599d09e23e60b012529c285b77", "filename": "src/test/ui/const-generics/issue-86820.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/783efd29ae71fccc7dcc220fbca37765423f6e58/src%2Ftest%2Fui%2Fconst-generics%2Fissue-86820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/783efd29ae71fccc7dcc220fbca37765423f6e58/src%2Ftest%2Fui%2Fconst-generics%2Fissue-86820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-86820.stderr?ref=783efd29ae71fccc7dcc220fbca37765423f6e58", "patch": "@@ -0,0 +1,15 @@\n+error[E0053]: method `bit` has an incompatible const parameter type for trait\n+  --> $DIR/issue-86820.rs:17:18\n+   |\n+LL |     fn bit<const I : usize>(self) -> bool {\n+   |                  ^\n+   |\n+note: the const parameter `I` has type `usize`, but the declaration in trait `Bits::bit` has type `u8`\n+  --> $DIR/issue-86820.rs:12:18\n+   |\n+LL |     fn bit<const I : u8>(self) -> bool;\n+   |                  ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}]}