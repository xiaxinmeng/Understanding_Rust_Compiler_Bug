{"sha": "bedbf727855d099963b66cf6619a53d3c073f52a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlZGJmNzI3ODU1ZDA5OTk2M2I2NmNmNjYxOWE1M2QzYzA3M2Y1MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-18T00:09:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-18T00:09:37Z"}, "message": "Auto merge of #50566 - nnethercote:bump, r=petrochenkov\n\nStreamline `StringReader::bump`\n\nThese patches make `bump` smaller and nicer. They speed up most runs for coercions and tuple-stress by 1--3%.", "tree": {"sha": "88291d1dd341f375121d266d896c94af0f570b2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88291d1dd341f375121d266d896c94af0f570b2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bedbf727855d099963b66cf6619a53d3c073f52a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bedbf727855d099963b66cf6619a53d3c073f52a", "html_url": "https://github.com/rust-lang/rust/commit/bedbf727855d099963b66cf6619a53d3c073f52a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bedbf727855d099963b66cf6619a53d3c073f52a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "612ca14b817a2088ab0b6a697279d9e2aff1fb25", "url": "https://api.github.com/repos/rust-lang/rust/commits/612ca14b817a2088ab0b6a697279d9e2aff1fb25", "html_url": "https://github.com/rust-lang/rust/commit/612ca14b817a2088ab0b6a697279d9e2aff1fb25"}, {"sha": "e913d692117e57ea2908461865aa08037f0bd2b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e913d692117e57ea2908461865aa08037f0bd2b9", "html_url": "https://github.com/rust-lang/rust/commit/e913d692117e57ea2908461865aa08037f0bd2b9"}], "stats": {"total": 131, "additions": 66, "deletions": 65}, "files": [{"sha": "672b0b9bbd16da8006ab5ae94f6a6e70fb39725f", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=bedbf727855d099963b66cf6619a53d3c073f52a", "patch": "@@ -238,7 +238,19 @@ fn read_block_comment(rdr: &mut StringReader,\n     debug!(\">>> block comment\");\n     let p = rdr.pos;\n     let mut lines: Vec<String> = Vec::new();\n-    let col = rdr.col;\n+\n+    // Count the number of chars since the start of the line by rescanning.\n+    let mut src_index = rdr.src_index(rdr.filemap.line_begin_pos());\n+    let end_src_index = rdr.src_index(rdr.pos);\n+    assert!(src_index <= end_src_index);\n+    let mut n = 0;\n+    while src_index < end_src_index {\n+        let c = char_at(&rdr.src, src_index);\n+        src_index += c.len_utf8();\n+        n += 1;\n+    }\n+    let col = CharPos(n);\n+\n     rdr.bump();\n     rdr.bump();\n "}, {"sha": "a0434fe6616c735c753e22c26ed470daf0323d5f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 42, "deletions": 64, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=bedbf727855d099963b66cf6619a53d3c073f52a", "patch": "@@ -44,13 +44,11 @@ pub struct StringReader<'a> {\n     pub next_pos: BytePos,\n     /// The absolute offset within the codemap of the current character\n     pub pos: BytePos,\n-    /// The column of the next character to read\n-    pub col: CharPos,\n     /// The current character (which has been read from self.pos)\n     pub ch: Option<char>,\n     pub filemap: Lrc<syntax_pos::FileMap>,\n-    /// If Some, stop reading the source at this position (inclusive).\n-    pub terminator: Option<BytePos>,\n+    /// Stop reading src at this index.\n+    pub end_src_index: usize,\n     /// Whether to record new-lines and multibyte chars in filemap.\n     /// This is only necessary the first time a filemap is lexed.\n     /// If part of a filemap is being re-lexed, this should be set to false.\n@@ -61,7 +59,7 @@ pub struct StringReader<'a> {\n     pub fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     // cache a direct reference to the source text, so that we don't have to\n     // retrieve it via `self.filemap.src.as_ref().unwrap()` all the time.\n-    source_text: Lrc<String>,\n+    src: Lrc<String>,\n     /// Stack of open delimiters and their spans. Used for error message.\n     token: token::Token,\n     span: Span,\n@@ -113,14 +111,7 @@ impl<'a> StringReader<'a> {\n         self.unwrap_or_abort(res)\n     }\n     fn is_eof(&self) -> bool {\n-        if self.ch.is_none() {\n-            return true;\n-        }\n-\n-        match self.terminator {\n-            Some(t) => self.next_pos > t,\n-            None => false,\n-        }\n+        self.ch.is_none()\n     }\n     /// Return the next token. EFFECT: advances the string_reader.\n     pub fn try_next_token(&mut self) -> Result<TokenAndSpan, ()> {\n@@ -176,21 +167,20 @@ impl<'a> StringReader<'a> {\n                                               filemap.name));\n         }\n \n-        let source_text = (*filemap.src.as_ref().unwrap()).clone();\n+        let src = (*filemap.src.as_ref().unwrap()).clone();\n \n         StringReader {\n             sess,\n             next_pos: filemap.start_pos,\n             pos: filemap.start_pos,\n-            col: CharPos(0),\n             ch: Some('\\n'),\n             filemap,\n-            terminator: None,\n+            end_src_index: src.len(),\n             save_new_lines_and_multibyte: true,\n             // dummy values; not read\n             peek_tok: token::Eof,\n             peek_span: syntax_pos::DUMMY_SP,\n-            source_text,\n+            src,\n             fatal_errs: Vec::new(),\n             token: token::Eof,\n             span: syntax_pos::DUMMY_SP,\n@@ -222,7 +212,7 @@ impl<'a> StringReader<'a> {\n         // Seek the lexer to the right byte range.\n         sr.save_new_lines_and_multibyte = false;\n         sr.next_pos = span.lo();\n-        sr.terminator = Some(span.hi());\n+        sr.end_src_index = sr.src_index(span.hi());\n \n         sr.bump();\n \n@@ -326,9 +316,7 @@ impl<'a> StringReader<'a> {\n     /// offending string to the error message\n     fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> FatalError {\n         m.push_str(\": \");\n-        let from = self.byte_offset(from_pos).to_usize();\n-        let to = self.byte_offset(to_pos).to_usize();\n-        m.push_str(&self.source_text[from..to]);\n+        m.push_str(&self.src[self.src_index(from_pos)..self.src_index(to_pos)]);\n         self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n \n@@ -354,8 +342,9 @@ impl<'a> StringReader<'a> {\n         Ok(())\n     }\n \n-    fn byte_offset(&self, pos: BytePos) -> BytePos {\n-        (pos - self.filemap.start_pos)\n+    #[inline]\n+    fn src_index(&self, pos: BytePos) -> usize {\n+        (pos - self.filemap.start_pos).to_usize()\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -386,7 +375,7 @@ impl<'a> StringReader<'a> {\n     fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T\n         where F: FnOnce(&str) -> T\n     {\n-        f(&self.source_text[self.byte_offset(start).to_usize()..self.byte_offset(end).to_usize()])\n+        f(&self.src[self.src_index(start)..self.src_index(end)])\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n@@ -438,47 +427,39 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-\n     /// Advance the StringReader by one character. If a newline is\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n-        let new_pos = self.next_pos;\n-        let new_byte_offset = self.byte_offset(new_pos).to_usize();\n-        let end = self.terminator.map_or(self.source_text.len(), |t| {\n-            self.byte_offset(t).to_usize()\n-        });\n-        if new_byte_offset < end {\n-            let old_ch_is_newline = self.ch.unwrap() == '\\n';\n-            let new_ch = char_at(&self.source_text, new_byte_offset);\n-            let new_ch_len = new_ch.len_utf8();\n-\n-            self.ch = Some(new_ch);\n-            self.pos = new_pos;\n-            self.next_pos = new_pos + Pos::from_usize(new_ch_len);\n-            if old_ch_is_newline {\n+        let next_src_index = self.src_index(self.next_pos);\n+        if next_src_index < self.end_src_index {\n+            let next_ch = char_at(&self.src, next_src_index);\n+            let next_ch_len = next_ch.len_utf8();\n+\n+            if self.ch.unwrap() == '\\n' {\n                 if self.save_new_lines_and_multibyte {\n-                    self.filemap.next_line(self.pos);\n+                    self.filemap.next_line(self.next_pos);\n                 }\n-                self.col = CharPos(0);\n-            } else {\n-                self.col = self.col + CharPos(1);\n             }\n-            if new_ch_len > 1 {\n+            if next_ch_len > 1 {\n                 if self.save_new_lines_and_multibyte {\n-                    self.filemap.record_multibyte_char(self.pos, new_ch_len);\n+                    self.filemap.record_multibyte_char(self.next_pos, next_ch_len);\n                 }\n             }\n-            self.filemap.record_width(self.pos, new_ch);\n+            self.filemap.record_width(self.next_pos, next_ch);\n+\n+            self.ch = Some(next_ch);\n+            self.pos = self.next_pos;\n+            self.next_pos = self.next_pos + Pos::from_usize(next_ch_len);\n         } else {\n             self.ch = None;\n-            self.pos = new_pos;\n+            self.pos = self.next_pos;\n         }\n     }\n \n     pub fn nextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.next_pos).to_usize();\n-        if offset < self.source_text.len() {\n-            Some(char_at(&self.source_text, offset))\n+        let next_src_index = self.src_index(self.next_pos);\n+        if next_src_index < self.end_src_index {\n+            Some(char_at(&self.src, next_src_index))\n         } else {\n             None\n         }\n@@ -489,17 +470,15 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextnextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.next_pos).to_usize();\n-        let s = &self.source_text[..];\n-        if offset >= s.len() {\n-            return None;\n-        }\n-        let next = offset + char_at(s, offset).len_utf8();\n-        if next < s.len() {\n-            Some(char_at(s, next))\n-        } else {\n-            None\n+        let next_src_index = self.src_index(self.next_pos);\n+        if next_src_index < self.end_src_index {\n+            let next_next_src_index =\n+                next_src_index + char_at(&self.src, next_src_index).len_utf8();\n+            if next_next_src_index < self.end_src_index {\n+                return Some(char_at(&self.src, next_next_src_index));\n+            }\n         }\n+        None\n     }\n \n     pub fn nextnextch_is(&self, c: char) -> bool {\n@@ -1359,8 +1338,8 @@ impl<'a> StringReader<'a> {\n                     loop {\n                         self.bump();\n                         if self.ch_is('\\'') {\n-                            let start = self.byte_offset(start).to_usize();\n-                            let end = self.byte_offset(self.pos).to_usize();\n+                            let start = self.src_index(start);\n+                            let end = self.src_index(self.pos);\n                             self.bump();\n                             let span = self.mk_sp(start_with_quote, self.pos);\n                             self.sess.span_diagnostic\n@@ -1369,8 +1348,7 @@ impl<'a> StringReader<'a> {\n                                 .span_suggestion(span,\n                                                  \"if you meant to write a `str` literal, \\\n                                                   use double quotes\",\n-                                                 format!(\"\\\"{}\\\"\",\n-                                                         &self.source_text[start..end]))\n+                                                 format!(\"\\\"{}\\\"\", &self.src[start..end]))\n                                 .emit();\n                             return Ok(token::Literal(token::Str_(Symbol::intern(\"??\")), None))\n                         }"}, {"sha": "281861918fd8eefaecf88570f6d23ae49e993db2", "filename": "src/libsyntax/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstr.rs?ref=bedbf727855d099963b66cf6619a53d3c073f52a", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[inline]\n pub fn char_at(s: &str, byte: usize) -> char {\n     s[byte..].chars().next().unwrap()\n }"}, {"sha": "26ab5d0a34ba54f1a2554d1b3695dad68568021d", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bedbf727855d099963b66cf6619a53d3c073f52a/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=bedbf727855d099963b66cf6619a53d3c073f52a", "patch": "@@ -971,6 +971,15 @@ impl FileMap {\n         lines.push(pos);\n     }\n \n+    /// Return the BytePos of the beginning of the current line.\n+    pub fn line_begin_pos(&self) -> BytePos {\n+        let lines = self.lines.borrow();\n+        match lines.last() {\n+            Some(&line_pos) => line_pos,\n+            None => self.start_pos,\n+        }\n+    }\n+\n     /// Add externally loaded source.\n     /// If the hash of the input doesn't match or no input is supplied via None,\n     /// it is interpreted as an error and the corresponding enum variant is set.\n@@ -1047,6 +1056,7 @@ impl FileMap {\n         self.multibyte_chars.borrow_mut().push(mbc);\n     }\n \n+    #[inline]\n     pub fn record_width(&self, pos: BytePos, ch: char) {\n         let width = match ch {\n             '\\t' =>"}]}