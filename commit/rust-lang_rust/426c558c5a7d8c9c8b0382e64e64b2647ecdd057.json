{"sha": "426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNmM1NThjNWE3ZDhjOWM4YjAzODJlNjRlNjRiMjY0N2VjZGQwNTc=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-02T19:13:59Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:38:09Z"}, "message": "Move trans_field_ptr and struct_field_ptr to mir/lvalue", "tree": {"sha": "e57649ca604e4d42be576f0c8b421763522116df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e57649ca604e4d42be576f0c8b421763522116df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "html_url": "https://github.com/rust-lang/rust/commit/426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "982b8f4f49588ffe47475321a0d59c2beef1c9be", "url": "https://api.github.com/repos/rust-lang/rust/commits/982b8f4f49588ffe47475321a0d59c2beef1c9be", "html_url": "https://github.com/rust-lang/rust/commit/982b8f4f49588ffe47475321a0d59c2beef1c9be"}], "stats": {"total": 348, "additions": 167, "deletions": 181}, "files": [{"sha": "28934407c17ccfda92dc7af8c83b222354726ab7", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -48,17 +48,13 @@ use std;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n-use rustc::mir::tcx::LvalueTy;\n-use mir::lvalue::LvalueRef;\n use common::*;\n use builder::Builder;\n-use glue;\n use base;\n use machine;\n use monomorphize;\n use type_::Type;\n use type_of;\n-use value::Value;\n \n #[derive(Copy, Clone, PartialEq)]\n pub enum BranchKind {\n@@ -471,163 +467,6 @@ pub fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n     }\n }\n \n-/// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    val: LvalueRef<'tcx>,\n-    ix: usize,\n-) -> ValueRef {\n-    let discr = match val.ty {\n-        LvalueTy::Ty { .. } => 0,\n-        LvalueTy::Downcast { variant_index, .. } => variant_index,\n-    };\n-    let t = val.ty.to_ty(bcx.tcx());\n-    let l = bcx.ccx.layout_of(t);\n-    // Note: if this ever needs to generate conditionals (e.g., if we\n-    // decide to do some kind of cdr-coding-like non-unique repr\n-    // someday), it will need to return a possibly-new bcx as well.\n-    match *l {\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, 0);\n-            struct_field_ptr(bcx, &variant,\n-             &compute_fields(bcx.ccx, t, 0, false),\n-             val, ix, false)\n-        }\n-        layout::Vector { count, .. } => {\n-            assert_eq!(discr, 0);\n-            assert!((ix as u64) < count);\n-            bcx.struct_gep(val.llval, ix)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let mut fields = compute_fields(bcx.ccx, t, discr, false);\n-            fields.insert(0, d.to_ty(&bcx.tcx(), false));\n-            struct_field_ptr(bcx, &variants[discr],\n-             &fields,\n-             val, ix + 1, true)\n-        }\n-        layout::UntaggedUnion { .. } => {\n-            let fields = compute_fields(bcx.ccx, t, 0, false);\n-            let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-            bcx.pointercast(val.llval, ty.ptr_to())\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } |\n-        layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n-            let nullfields = compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n-            // The unit-like case might have a nonzero number of unit-like fields.\n-            // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n-            assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-            bcx.pointercast(val.llval, ty.ptr_to())\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n-            assert_eq!(ix, 0);\n-            assert_eq!(discr as u64, nndiscr);\n-            let ty = type_of::type_of(bcx.ccx, nnty);\n-            bcx.pointercast(val.llval, ty.ptr_to())\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            assert_eq!(discr as u64, nndiscr);\n-            struct_field_ptr(bcx, &nonnull,\n-             &compute_fields(bcx.ccx, t, discr, false),\n-             val, ix, false)\n-        }\n-        _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n-    }\n-}\n-\n-fn struct_field_ptr<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    st: &layout::Struct,\n-    fields: &Vec<Ty<'tcx>>,\n-    val: LvalueRef,\n-    ix: usize,\n-    needs_cast: bool\n-) -> ValueRef {\n-    let fty = fields[ix];\n-    let ccx = bcx.ccx;\n-\n-    let ptr_val = if needs_cast {\n-        let fields = st.field_index_by_increasing_offset().map(|i| {\n-            type_of::in_memory_type_of(ccx, fields[i])\n-        }).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        bcx.pointercast(val.llval, real_ty.ptr_to())\n-    } else {\n-        val.llval\n-    };\n-\n-    // Simple case - we can just GEP the field\n-    //   * First field - Always aligned properly\n-    //   * Packed struct - There is no alignment padding\n-    //   * Field is sized - pointer is properly aligned already\n-    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-        bcx.ccx.shared().type_is_sized(fty) {\n-        return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n-    }\n-\n-    // If the type of the last field is [T] or str, then we don't need to do\n-    // any adjusments\n-    match fty.sty {\n-        ty::TySlice(..) | ty::TyStr => {\n-            return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n-        }\n-        _ => ()\n-    }\n-\n-    // There's no metadata available, log the case and just do the GEP.\n-    if !val.has_extra() {\n-        debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-               ix, Value(ptr_val));\n-        return bcx.struct_gep(ptr_val, ix);\n-    }\n-\n-    // We need to get the pointer manually now.\n-    // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n-    // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n-    // because the field may have an arbitrary alignment in the LLVM representation\n-    // anyway.\n-    //\n-    // To demonstrate:\n-    //   struct Foo<T: ?Sized> {\n-    //      x: u16,\n-    //      y: T\n-    //   }\n-    //\n-    // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n-    // the `y` field has 16-bit alignment.\n-\n-    let meta = val.llextra;\n-\n-\n-    let offset = st.offsets[ix].bytes();\n-    let unaligned_offset = C_uint(bcx.ccx, offset);\n-\n-    // Get the alignment of the field\n-    let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n-\n-    // Bump the unaligned offset up to the appropriate alignment using the\n-    // following expression:\n-    //\n-    //   (unaligned offset + (align - 1)) & -align\n-\n-    // Calculate offset\n-    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n-    let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n-                         bcx.neg(align));\n-\n-    debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n-\n-    // Cast and adjust pointer\n-    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n-    let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n-\n-    // Finally, cast back to the type expected\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n-    debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-    bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n-}\n-\n // FIXME this utility routine should be somewhere more general\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }"}, {"sha": "8b182dabf51015af8d736c5a22ef9a6fd734540d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -289,8 +289,8 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, src, i);\n-                let dst_f = adt::trans_field_ptr(bcx, dst, i);\n+                let src_f = src.trans_field_ptr(bcx, i);\n+                let dst_f = dst.trans_field_ptr(bcx, i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n@@ -632,7 +632,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(&bcx, dest_val, i);\n+            let lldestptr = dest_val.trans_field_ptr(&bcx, i);\n             let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {"}, {"sha": "f25864c8f28a4fb4e99ac970ca8a8bcc8c5bbce2", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -411,7 +411,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n                 substs: substs,\n                 variant_index: variant_index,\n             };\n-            let field_ptr = adt::trans_field_ptr(&cx, av, i);\n+            let field_ptr = av.trans_field_ptr(&cx, i);\n             drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg));\n         }\n     }\n@@ -421,7 +421,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(&cx, ptr, i);\n+                let llupvar = ptr.trans_field_ptr(&cx, i);\n                 drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty));\n             }\n         }\n@@ -439,7 +439,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(&cx, ptr, i);\n+                let llfld_a = ptr.trans_field_ptr(&cx, i);\n                 drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));\n             }\n         }\n@@ -453,7 +453,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) ->\n                         substs: substs,\n                         variant_index: Disr::from(discr).0 as usize,\n                     };\n-                    let llfld_a = adt::trans_field_ptr(&cx, ptr, i);\n+                    let llfld_a = ptr.trans_field_ptr(&cx, i);\n                     let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n                         LvalueRef::new_sized_ty(llfld_a, field_ty)\n                     } else {"}, {"sha": "35895e7827e1a5f0d7a23fbee65632e157897105", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -550,11 +550,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // etc.\n                         assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n                         let arg = LvalueRef::new_sized_ty(llarg, arg_type);\n-                        (0..contents.len())\n-                            .map(|i| {\n-                                bcx.load(adt::trans_field_ptr(bcx, arg, i))\n-                            })\n-                            .collect()\n+                        (0..contents.len()).map(|i| bcx.load(arg.trans_field_ptr(bcx, i))).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));"}, {"sha": "a62c25f2afc453472706f55aadfc0a5a410a8e75", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -708,9 +708,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         match tuple.val {\n             Ref(llval) => {\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = adt::trans_field_ptr(\n-                        bcx, LvalueRef::new_sized_ty(llval, tuple.ty), n\n-                    );\n+                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty);\n+                    let ptr = ptr.trans_field_ptr(bcx, n);\n                     let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)"}, {"sha": "a538a16dc95cbd42578311f0ec4998d1c4de5e25", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 156, "deletions": 4, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, layout, Ty, TypeFoldable};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -20,6 +20,9 @@ use consts;\n use machine;\n use type_of::type_of;\n use type_of;\n+use type_::Type;\n+use value::Value;\n+use glue;\n \n use std::ptr;\n \n@@ -38,7 +41,7 @@ pub struct LvalueRef<'tcx> {\n     pub ty: LvalueTy<'tcx>,\n }\n \n-impl<'tcx> LvalueRef<'tcx> {\n+impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n@@ -62,7 +65,7 @@ impl<'tcx> LvalueRef<'tcx> {\n         }\n     }\n \n-    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n             ty::TyArray(_, n) => common::C_uint(ccx, n),\n@@ -77,6 +80,155 @@ impl<'tcx> LvalueRef<'tcx> {\n     pub fn has_extra(&self) -> bool {\n         !self.llextra.is_null()\n     }\n+\n+    pub fn struct_field_ptr(\n+        self,\n+        bcx: &Builder<'a, 'tcx>,\n+        st: &layout::Struct,\n+        fields: &Vec<Ty<'tcx>>,\n+        ix: usize,\n+        needs_cast: bool\n+    ) -> ValueRef {\n+        let fty = fields[ix];\n+        let ccx = bcx.ccx;\n+\n+        let ptr_val = if needs_cast {\n+            let fields = st.field_index_by_increasing_offset().map(|i| {\n+                type_of::in_memory_type_of(ccx, fields[i])\n+            }).collect::<Vec<_>>();\n+            let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n+            bcx.pointercast(self.llval, real_ty.ptr_to())\n+        } else {\n+            self.llval\n+        };\n+\n+        // Simple case - we can just GEP the field\n+        //   * First field - Always aligned properly\n+        //   * Packed struct - There is no alignment padding\n+        //   * Field is sized - pointer is properly aligned already\n+        if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n+            bcx.ccx.shared().type_is_sized(fty) {\n+                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+            }\n+\n+        // If the type of the last field is [T] or str, then we don't need to do\n+        // any adjusments\n+        match fty.sty {\n+            ty::TySlice(..) | ty::TyStr => {\n+                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+            }\n+            _ => ()\n+        }\n+\n+        // There's no metadata available, log the case and just do the GEP.\n+        if !self.has_extra() {\n+            debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+                ix, Value(ptr_val));\n+            return bcx.struct_gep(ptr_val, ix);\n+        }\n+\n+        // We need to get the pointer manually now.\n+        // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n+        // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n+        // because the field may have an arbitrary alignment in the LLVM representation\n+        // anyway.\n+        //\n+        // To demonstrate:\n+        //   struct Foo<T: ?Sized> {\n+        //      x: u16,\n+        //      y: T\n+        //   }\n+        //\n+        // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n+        // the `y` field has 16-bit alignment.\n+\n+        let meta = self.llextra;\n+\n+\n+        let offset = st.offsets[ix].bytes();\n+        let unaligned_offset = C_uint(bcx.ccx, offset);\n+\n+        // Get the alignment of the field\n+        let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n+\n+        // Bump the unaligned offset up to the appropriate alignment using the\n+        // following expression:\n+        //\n+        //   (unaligned offset + (align - 1)) & -align\n+\n+        // Calculate offset\n+        let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n+        let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n+        bcx.neg(align));\n+\n+        debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n+\n+        // Cast and adjust pointer\n+        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n+        let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n+\n+        // Finally, cast back to the type expected\n+        let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n+        debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n+        bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n+    }\n+\n+    /// Access a field, at a point when the value's case is known.\n+    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> ValueRef {\n+        let discr = match self.ty {\n+            LvalueTy::Ty { .. } => 0,\n+            LvalueTy::Downcast { variant_index, .. } => variant_index,\n+        };\n+        let t = self.ty.to_ty(bcx.tcx());\n+        let l = bcx.ccx.layout_of(t);\n+        // Note: if this ever needs to generate conditionals (e.g., if we\n+        // decide to do some kind of cdr-coding-like non-unique repr\n+        // someday), it will need to return a possibly-new bcx as well.\n+        match *l {\n+            layout::Univariant { ref variant, .. } => {\n+                assert_eq!(discr, 0);\n+                self.struct_field_ptr(bcx, &variant,\n+                    &adt::compute_fields(bcx.ccx, t, 0, false), ix, false)\n+            }\n+            layout::Vector { count, .. } => {\n+                assert_eq!(discr, 0);\n+                assert!((ix as u64) < count);\n+                bcx.struct_gep(self.llval, ix)\n+            }\n+            layout::General { discr: d, ref variants, .. } => {\n+                let mut fields = adt::compute_fields(bcx.ccx, t, discr, false);\n+                fields.insert(0, d.to_ty(&bcx.tcx(), false));\n+                self.struct_field_ptr(bcx, &variants[discr], &fields, ix + 1, true)\n+            }\n+            layout::UntaggedUnion { .. } => {\n+                let fields = adt::compute_fields(bcx.ccx, t, 0, false);\n+                let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n+                let nullfields = adt::compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n+                // The unit-like case might have a nonzero number of unit-like fields.\n+                // (e.d., Result of Either with (), as one side.)\n+                let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n+                assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } => {\n+                let nnty = adt::compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n+                assert_eq!(ix, 0);\n+                assert_eq!(discr as u64, nndiscr);\n+                let ty = type_of::type_of(bcx.ccx, nnty);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+                assert_eq!(discr as u64, nndiscr);\n+                self.struct_field_ptr(bcx, &nonnull,\n+                    &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n+            }\n+            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n+        }\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n@@ -152,7 +304,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         } else {\n                             LvalueRef::new_unsized(tr_base.llval, tr_base.llextra, tr_base.ty)\n                         };\n-                        let llprojected = adt::trans_field_ptr(bcx, base, field.index());\n+                        let llprojected = base.trans_field_ptr(bcx, field.index());\n                         (llprojected, base.llextra)\n                     }\n                     mir::ProjectionElem::Index(ref index) => {"}, {"sha": "67fb8cf576d6218afdeafd7bf834024cde76f6de", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/426c558c5a7d8c9c8b0382e64e64b2647ecdd057/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=426c558c5a7d8c9c8b0382e64e64b2647ecdd057", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     substs: self.monomorphize(&substs),\n                                     variant_index: disr.0 as usize,\n                                 };\n-                                let lldest_i = adt::trans_field_ptr(&bcx, val, field_index);\n+                                let lldest_i = val.trans_field_ptr(&bcx, field_index);\n                                 self.store_operand(&bcx, lldest_i, op, None);\n                             }\n                         }"}]}