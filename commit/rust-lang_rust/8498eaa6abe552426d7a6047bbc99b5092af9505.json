{"sha": "8498eaa6abe552426d7a6047bbc99b5092af9505", "node_id": "C_kwDOAAsO6NoAKDg0OThlYWE2YWJlNTUyNDI2ZDdhNjA0N2JiYzk5YjUwOTJhZjk1MDU", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-21T15:43:19Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-21T15:46:01Z"}, "message": "Implement type checking for legacy_const_generics", "tree": {"sha": "c7fc6cf0483aaee175ff8278571fd99a08e9d18e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7fc6cf0483aaee175ff8278571fd99a08e9d18e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8498eaa6abe552426d7a6047bbc99b5092af9505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8498eaa6abe552426d7a6047bbc99b5092af9505", "html_url": "https://github.com/rust-lang/rust/commit/8498eaa6abe552426d7a6047bbc99b5092af9505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8498eaa6abe552426d7a6047bbc99b5092af9505/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ef541b35f955d3d86014ad855511f155d5ebd47", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ef541b35f955d3d86014ad855511f155d5ebd47", "html_url": "https://github.com/rust-lang/rust/commit/2ef541b35f955d3d86014ad855511f155d5ebd47"}], "stats": {"total": 94, "additions": 87, "deletions": 7}, "files": [{"sha": "43cff92f233adb49cc061ccfb437aded9bd598b2", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 68, "deletions": 6, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8498eaa6abe552426d7a6047bbc99b5092af9505/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498eaa6abe552426d7a6047bbc99b5092af9505/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8498eaa6abe552426d7a6047bbc99b5092af9505", "patch": "@@ -28,7 +28,7 @@ use crate::{\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n-    mapping::from_chalk,\n+    mapping::{from_chalk, ToChalk},\n     method_resolution,\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n@@ -279,21 +279,24 @@ impl<'a> InferenceContext<'a> {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n                 let mut res = None;\n+                let mut derefed_callee = callee_ty.clone();\n                 // manual loop to be able to access `derefs.table`\n                 while let Some((callee_deref_ty, _)) = derefs.next() {\n                     res = derefs.table.callable_sig(&callee_deref_ty, args.len());\n                     if res.is_some() {\n+                        derefed_callee = callee_deref_ty;\n                         break;\n                     }\n                 }\n-                let (param_tys, ret_ty): (Vec<Ty>, Ty) = match res {\n+                let (param_tys, ret_ty) = match res {\n                     Some(res) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n                         self.write_expr_adj(*callee, adjustments);\n                         res\n                     }\n                     None => (Vec::new(), self.err_ty()),\n                 };\n+                let indices_to_skip = self.check_legacy_const_generics(derefed_callee, args);\n                 self.register_obligations_for_call(&callee_ty);\n \n                 let expected_inputs = self.expected_inputs_for_expected_output(\n@@ -302,7 +305,7 @@ impl<'a> InferenceContext<'a> {\n                     param_tys.clone(),\n                 );\n \n-                self.check_call_arguments(args, &expected_inputs, &param_tys);\n+                self.check_call_arguments(args, &expected_inputs, &param_tys, &indices_to_skip);\n                 self.normalize_associated_types_in(ret_ty)\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n@@ -952,7 +955,7 @@ impl<'a> InferenceContext<'a> {\n         let expected_inputs =\n             self.expected_inputs_for_expected_output(expected, ret_ty.clone(), param_tys.clone());\n \n-        self.check_call_arguments(args, &expected_inputs, &param_tys);\n+        self.check_call_arguments(args, &expected_inputs, &param_tys, &[]);\n         self.normalize_associated_types_in(ret_ty)\n     }\n \n@@ -983,24 +986,40 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn check_call_arguments(&mut self, args: &[ExprId], expected_inputs: &[Ty], param_tys: &[Ty]) {\n+    fn check_call_arguments(\n+        &mut self,\n+        args: &[ExprId],\n+        expected_inputs: &[Ty],\n+        param_tys: &[Ty],\n+        skip_indices: &[u32],\n+    ) {\n         // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n         for &check_closures in &[false, true] {\n+            let mut skip_indices = skip_indices.into_iter().copied().fuse().peekable();\n             let param_iter = param_tys.iter().cloned().chain(repeat(self.err_ty()));\n             let expected_iter = expected_inputs\n                 .iter()\n                 .cloned()\n                 .chain(param_iter.clone().skip(expected_inputs.len()));\n-            for ((&arg, param_ty), expected_ty) in args.iter().zip(param_iter).zip(expected_iter) {\n+            for (idx, ((&arg, param_ty), expected_ty)) in\n+                args.iter().zip(param_iter).zip(expected_iter).enumerate()\n+            {\n                 let is_closure = matches!(&self.body[arg], Expr::Lambda { .. });\n                 if is_closure != check_closures {\n                     continue;\n                 }\n \n+                while skip_indices.peek().map_or(false, |i| *i < idx as u32) {\n+                    skip_indices.next();\n+                }\n+                if skip_indices.peek().copied() == Some(idx as u32) {\n+                    continue;\n+                }\n+\n                 // the difference between param_ty and expected here is that\n                 // expected is the parameter when the expected *return* type is\n                 // taken into account. So in `let _: &[i32] = identity(&[1, 2])`\n@@ -1140,6 +1159,49 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    /// Returns the argument indices to skip.\n+    fn check_legacy_const_generics(&mut self, callee: Ty, args: &[ExprId]) -> Vec<u32> {\n+        let (func, subst) = match callee.kind(Interner) {\n+            TyKind::FnDef(fn_id, subst) => {\n+                let callable = CallableDefId::from_chalk(self.db, *fn_id);\n+                let func = match callable {\n+                    CallableDefId::FunctionId(f) => f,\n+                    _ => return Vec::new(),\n+                };\n+                (func, subst)\n+            }\n+            _ => return Vec::new(),\n+        };\n+\n+        let data = self.db.function_data(func);\n+        if data.legacy_const_generics_indices.is_empty() {\n+            return Vec::new();\n+        }\n+\n+        // only use legacy const generics if the param count matches with them\n+        if data.params.len() + data.legacy_const_generics_indices.len() != args.len() {\n+            return Vec::new();\n+        }\n+\n+        // check legacy const parameters\n+        for (subst_idx, arg_idx) in data.legacy_const_generics_indices.iter().copied().enumerate() {\n+            let arg = match subst.at(Interner, subst_idx).constant(Interner) {\n+                Some(c) => c,\n+                None => continue, // not a const parameter?\n+            };\n+            if arg_idx >= args.len() as u32 {\n+                continue;\n+            }\n+            let _ty = arg.data(Interner).ty.clone();\n+            let expected = Expectation::none(); // FIXME use actual const ty, when that is lowered correctly\n+            self.infer_expr(args[arg_idx as usize], &expected);\n+            // FIXME: evaluate and unify with the const\n+        }\n+        let mut indices = data.legacy_const_generics_indices.clone();\n+        indices.sort();\n+        indices\n+    }\n+\n     fn builtin_binary_op_return_ty(&mut self, op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Option<Ty> {\n         let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n         let rhs_ty = self.resolve_ty_shallow(&rhs_ty);"}, {"sha": "de27c294f61937375fd69f66f725f6490bac9131", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8498eaa6abe552426d7a6047bbc99b5092af9505/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8498eaa6abe552426d7a6047bbc99b5092af9505/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=8498eaa6abe552426d7a6047bbc99b5092af9505", "patch": "@@ -1,6 +1,6 @@\n use expect_test::expect;\n \n-use super::{check_infer, check_types};\n+use super::{check_infer, check_no_mismatches, check_types};\n \n #[test]\n fn infer_box() {\n@@ -2624,3 +2624,21 @@ pub mod prelude {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn legacy_const_generics() {\n+    check_no_mismatches(\n+        r#\"\n+#[rustc_legacy_const_generics(1, 3)]\n+fn mixed<const N1: &'static str, const N2: bool>(\n+    a: u8,\n+    b: i8,\n+) {}\n+\n+fn f() {\n+    mixed(0, \"\", -1, true);\n+    mixed::<\"\", true>(0, -1);\n+}\n+    \"#,\n+    );\n+}"}]}