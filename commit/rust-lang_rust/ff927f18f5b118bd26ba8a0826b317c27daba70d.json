{"sha": "ff927f18f5b118bd26ba8a0826b317c27daba70d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOTI3ZjE4ZjViMTE4YmQyNmJhOGEwODI2YjMxN2MyN2RhYmE3MGQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T14:59:48Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-21T16:08:14Z"}, "message": "Clean up some FIXMEs in middle:: modules\n\nRename all TODOs to FIXMEs", "tree": {"sha": "6931383a4064c1b662bbe36ee18fd6849668843e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6931383a4064c1b662bbe36ee18fd6849668843e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff927f18f5b118bd26ba8a0826b317c27daba70d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff927f18f5b118bd26ba8a0826b317c27daba70d", "html_url": "https://github.com/rust-lang/rust/commit/ff927f18f5b118bd26ba8a0826b317c27daba70d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff927f18f5b118bd26ba8a0826b317c27daba70d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b", "html_url": "https://github.com/rust-lang/rust/commit/92a45f5582ed8ea4eb439ea2eada31e228d8fe6b"}], "stats": {"total": 212, "additions": 88, "deletions": 124}, "files": [{"sha": "ff80ecd7e74886fe0e50f36651950aec5b8617bb", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ff927f18f5b118bd26ba8a0826b317c27daba70d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff927f18f5b118bd26ba8a0826b317c27daba70d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ff927f18f5b118bd26ba8a0826b317c27daba70d", "patch": "@@ -1359,17 +1359,14 @@ fn field_idx(id: ast::ident, fields: [field]) -> option<uint> {\n }\n \n fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    alt vec::find(get_fields(rec_ty), {|f| str::eq(f.ident, id) }) {\n+    alt check vec::find(get_fields(rec_ty), {|f| str::eq(f.ident, id) }) {\n       some(f) { f }\n-      _ { fail #fmt(\"get_field: bad field id %s\", id); }\n     }\n }\n \n-// TODO: could have a precondition instead of failing\n fn get_fields(rec_ty:t) -> [field] {\n-    alt get(rec_ty).struct {\n+    alt check get(rec_ty).struct {\n       ty_rec(fields) { fields }\n-      _ { fail \"get_fields called on non-record type\"; }\n     }\n }\n \n@@ -2080,14 +2077,11 @@ mod unify {\n                     let err = terr_record_size(expected_len, actual_len);\n                     ret ures_err(err);\n                 }\n-                // TODO: implement an iterator that can iterate over\n-                // two arrays simultaneously.\n-\n-                let result_fields: [field] = [];\n-                let i = 0u;\n-                while i < expected_len {\n-                    let expected_field = expected_fields[i];\n-                    let actual_field = actual_fields[i];\n+\n+                let result_fields = [], i = 0u;\n+                while i < actual_len {\n+                    let expected_field = expected_fields[i],\n+                        actual_field = actual_fields[i];\n                     let u_mut = unify_mut(expected_field.mt.mutbl,\n                                           actual_field.mt.mutbl,\n                                           variance);\n@@ -2127,19 +2121,13 @@ mod unify {\n                     let err = terr_tuple_size(expected_len, actual_len);\n                     ret ures_err(err);\n                 }\n-                // TODO: implement an iterator that can iterate over\n-                // two arrays simultaneously.\n-\n-                let result_elems = [];\n-                let i = 0u;\n-                while i < expected_len {\n-                    let expected_elem = expected_elems[i];\n-                    let actual_elem = actual_elems[i];\n-                    let result = unify_step(\n-                        cx, expected_elem, actual_elem, variance);\n-                    alt result {\n+\n+                let result_elems = [], i = 0u;\n+                while i < actual_len {\n+                    alt unify_step(cx, expected_elems[i], actual_elems[i],\n+                                   variance) {\n                       ures_ok(rty) { result_elems += [rty]; }\n-                      _ { ret result; }\n+                      r { ret r; }\n                     }\n                     i += 1u;\n                 }"}, {"sha": "2ffa191b6d8e6f4a3285ecc2beea20d0f21692ed", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 75, "deletions": 99, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/ff927f18f5b118bd26ba8a0826b317c27daba70d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff927f18f5b118bd26ba8a0826b317c27daba70d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=ff927f18f5b118bd26ba8a0826b317c27daba70d", "patch": "@@ -285,9 +285,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     }\n     fn instantiate(tcx: ty::ctxt, sp: span, mode: mode,\n                    id: ast::def_id, args: [@ast::ty]) -> ty::t {\n-        // TODO: maybe record cname chains so we can do\n-        // \"foo = int\" like OCaml?\n-\n         let ty_param_bounds_and_ty = getter(tcx, mode, id);\n         if vec::len(*ty_param_bounds_and_ty.bounds) == 0u {\n             ret ty_param_bounds_and_ty.ty;\n@@ -783,42 +780,34 @@ fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n //\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n-//\n-// TODO: This logic is quite convoluted; it's a relic of the time when we\n-// actually wrote types directly into the AST and didn't have a type cache.\n-// Could use some cleanup. Consider topologically sorting in phase (1) above.\n mod collect {\n-    type ctxt = {tcx: ty::ctxt};\n-\n-    fn get_enum_variant_types(cx: @ctxt, enum_ty: ty::t,\n-                             variants: [ast::variant],\n-                             ty_params: [ast::ty_param]) {\n+    fn get_enum_variant_types(tcx: ty::ctxt, enum_ty: ty::t,\n+                              variants: [ast::variant],\n+                              ty_params: [ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n-\n-        for variant: ast::variant in variants {\n+        for variant in variants {\n             // Nullary enum constructors get turned into constants; n-ary enum\n             // constructors get turned into functions.\n-\n             let result_ty = if vec::len(variant.node.args) == 0u {\n                 enum_ty\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n                 let args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n-                    let arg_ty = ast_ty_to_ty(cx.tcx, m_collect, va.ty);\n+                    let arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n                     args += [{mode: ast::expl(ast::by_copy), ty: arg_ty}];\n                 }\n                 // FIXME: this will be different for constrained types\n-                ty::mk_fn(cx.tcx,\n+                ty::mk_fn(tcx,\n                           {proto: ast::proto_box,\n                            inputs: args, output: enum_ty,\n                            ret_style: ast::return_val, constraints: []})\n             };\n-            let tpt = {bounds: ty_param_bounds(cx.tcx, m_collect, ty_params),\n+            let tpt = {bounds: ty_param_bounds(tcx, m_collect, ty_params),\n                        ty: result_ty};\n-            cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n-            write_ty(cx.tcx, variant.node.id, result_ty);\n+            tcx.tcache.insert(local_def(variant.node.id), tpt);\n+            write_ty(tcx, variant.node.id, result_ty);\n         }\n     }\n     fn ensure_iface_methods(tcx: ty::ctxt, id: ast::node_id) {\n@@ -830,7 +819,7 @@ mod collect {\n           }\n         }\n     }\n-    fn convert_class_item(cx: @ctxt, ci: ast::class_member) {\n+    fn convert_class_item(tcx: ty::ctxt, ci: ast::class_member) {\n         /* we want to do something here, b/c within the\n          scope of the class, it's ok to refer to fields &\n         methods unqualified */\n@@ -839,76 +828,76 @@ mod collect {\n          class. outside the class, it's done with expr_field */\n         alt ci {\n          ast::instance_var(_,t,_,id) {\n-             let tt = ast_ty_to_ty(cx.tcx, m_collect, t);\n-             write_ty(cx.tcx, id, tt);\n+             let tt = ast_ty_to_ty(tcx, m_collect, t);\n+             write_ty(tcx, id, tt);\n          }\n-         ast::class_method(it) { convert(cx, it); }\n+         ast::class_method(it) { convert(tcx, it); }\n         }\n     }\n-    fn convert(cx: @ctxt, it: @ast::item) {\n+    fn convert(tcx: ty::ctxt, it: @ast::item) {\n         alt it.node {\n           // These don't define types.\n           ast::item_mod(_) | ast::item_native_mod(_) {}\n           ast::item_enum(variants, ty_params) {\n-            let tpt = ty_of_item(cx.tcx, m_collect, it);\n-            write_ty(cx.tcx, it.id, tpt.ty);\n-            get_enum_variant_types(cx, tpt.ty, variants, ty_params);\n+            let tpt = ty_of_item(tcx, m_collect, it);\n+            write_ty(tcx, it.id, tpt.ty);\n+            get_enum_variant_types(tcx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n-            let i_bounds = ty_param_bounds(cx.tcx, m_collect, tps);\n+            let i_bounds = ty_param_bounds(tcx, m_collect, tps);\n             let my_methods = [];\n             for m in ms {\n-                let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n-                let mty = ty_of_method(cx.tcx, m_collect, m);\n+                let bounds = ty_param_bounds(tcx, m_collect, m.tps);\n+                let mty = ty_of_method(tcx, m_collect, m);\n                 my_methods += [{mty: mty, id: m.id, span: m.span}];\n-                let fty = ty::mk_fn(cx.tcx, mty.fty);\n-                cx.tcx.tcache.insert(local_def(m.id),\n+                let fty = ty::mk_fn(tcx, mty.fty);\n+                tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n                                       ty: fty});\n-                write_ty(cx.tcx, m.id, fty);\n+                write_ty(tcx, m.id, fty);\n             }\n-            let selfty = ast_ty_to_ty(cx.tcx, m_collect, selfty);\n-            write_ty(cx.tcx, it.id, selfty);\n+            let selfty = ast_ty_to_ty(tcx, m_collect, selfty);\n+            write_ty(tcx, it.id, selfty);\n             alt ifce {\n               some(t) {\n-                let iface_ty = ast_ty_to_ty(cx.tcx, m_collect, t);\n-                cx.tcx.tcache.insert(local_def(it.id),\n+                let iface_ty = ast_ty_to_ty(tcx, m_collect, t);\n+                tcx.tcache.insert(local_def(it.id),\n                                      {bounds: i_bounds, ty: iface_ty});\n                 alt ty::get(iface_ty).struct {\n                   ty::ty_iface(did, tys) {\n                     if did.crate == ast::local_crate {\n-                        ensure_iface_methods(cx.tcx, did.node);\n+                        ensure_iface_methods(tcx, did.node);\n                     }\n-                    for if_m in *ty::iface_methods(cx.tcx, did) {\n+                    for if_m in *ty::iface_methods(tcx, did) {\n                         alt vec::find(my_methods,\n                                       {|m| if_m.ident == m.mty.ident}) {\n                           some({mty: m, id, span}) {\n                             if m.purity != if_m.purity {\n-                                cx.tcx.sess.span_err(\n+                                tcx.sess.span_err(\n                                     span, \"method `\" + m.ident + \"`'s purity \\\n                                            not match the iface method's \\\n                                            purity\");\n                             }\n                             let mt = compare_impl_method(\n-                                cx.tcx, span, m, vec::len(tps), if_m, tys,\n+                                tcx, span, m, vec::len(tps), if_m, tys,\n                                 selfty);\n-                            let old = cx.tcx.tcache.get(local_def(id));\n+                            let old = tcx.tcache.get(local_def(id));\n                             if old.ty != mt {\n-                                cx.tcx.tcache.insert(local_def(id),\n+                                tcx.tcache.insert(local_def(id),\n                                                      {bounds: old.bounds,\n                                                      ty: mt});\n-                                write_ty(cx.tcx, id, mt);\n+                                write_ty(tcx, id, mt);\n                             }\n                           }\n                           none {\n-                            cx.tcx.sess.span_err(t.span, \"missing method `\" +\n+                            tcx.sess.span_err(t.span, \"missing method `\" +\n                                                  if_m.ident + \"`\");\n                           }\n                         }\n                     }\n                   }\n                   _ {\n-                    cx.tcx.sess.span_fatal(t.span, \"can only implement \\\n+                    tcx.sess.span_fatal(t.span, \"can only implement \\\n                                                     interface types\");\n                   }\n                 }\n@@ -917,81 +906,76 @@ mod collect {\n             }\n           }\n           ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n-            let {bounds, params} = mk_ty_params(cx.tcx, tps);\n-            let t_arg = ty_of_arg(cx.tcx, m_collect, decl.inputs[0]);\n-            let t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n+            let {bounds, params} = mk_ty_params(tcx, tps);\n+            let t_arg = ty_of_arg(tcx, m_collect, decl.inputs[0]);\n+            let t_res = ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n                                    params);\n-            let t_ctor = ty::mk_fn(cx.tcx, {\n+            let t_ctor = ty::mk_fn(tcx, {\n                 proto: ast::proto_box,\n                 inputs: [{mode: ast::expl(ast::by_copy) with t_arg}],\n                 output: t_res,\n                 ret_style: ast::return_val, constraints: []\n             });\n-            let t_dtor = ty::mk_fn(cx.tcx, {\n+            let t_dtor = ty::mk_fn(tcx, {\n                 proto: ast::proto_box,\n-                inputs: [t_arg], output: ty::mk_nil(cx.tcx),\n+                inputs: [t_arg], output: ty::mk_nil(tcx),\n                 ret_style: ast::return_val, constraints: []\n             });\n-            write_ty(cx.tcx, it.id, t_res);\n-            write_ty(cx.tcx, ctor_id, t_ctor);\n-            cx.tcx.tcache.insert(local_def(ctor_id),\n+            write_ty(tcx, it.id, t_res);\n+            write_ty(tcx, ctor_id, t_ctor);\n+            tcx.tcache.insert(local_def(ctor_id),\n                                  {bounds: bounds, ty: t_ctor});\n-            write_ty(cx.tcx, dtor_id, t_dtor);\n+            write_ty(tcx, dtor_id, t_dtor);\n           }\n           ast::item_iface(_, ms) {\n-            let tpt = ty_of_item(cx.tcx, m_collect, it);\n-            write_ty(cx.tcx, it.id, tpt.ty);\n-            ensure_iface_methods(cx.tcx, it.id);\n+            let tpt = ty_of_item(tcx, m_collect, it);\n+            write_ty(tcx, it.id, tpt.ty);\n+            ensure_iface_methods(tcx, it.id);\n           }\n           ast::item_class(tps, members, ctor_id, ctor_decl, ctor_block) {\n               // Write the class type\n-              let {bounds,params} = mk_ty_params(cx.tcx, tps);\n-              let class_ty = ty::mk_class(cx.tcx, local_def(it.id), params);\n+              let {bounds,params} = mk_ty_params(tcx, tps);\n+              let class_ty = ty::mk_class(tcx, local_def(it.id), params);\n               let tpt = {bounds: bounds, ty: class_ty};\n-              cx.tcx.tcache.insert(local_def(it.id), tpt);\n-              write_ty(cx.tcx, it.id, class_ty);\n+              tcx.tcache.insert(local_def(it.id), tpt);\n+              write_ty(tcx, it.id, class_ty);\n               // Write the ctor type\n-              let t_ctor = ty::mk_fn(cx.tcx,\n-                                     ty_of_fn_decl(cx.tcx, m_collect,\n+              let t_ctor = ty::mk_fn(tcx,\n+                                     ty_of_fn_decl(tcx, m_collect,\n                                              ast::proto_any, ctor_decl));\n-              write_ty(cx.tcx, ctor_id, t_ctor);\n-              cx.tcx.tcache.insert(local_def(ctor_id),\n+              write_ty(tcx, ctor_id, t_ctor);\n+              tcx.tcache.insert(local_def(ctor_id),\n                                    {bounds: bounds, ty: t_ctor});\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n               for m in members {\n-                 convert_class_item(cx, m.node.decl);\n+                 convert_class_item(tcx, m.node.decl);\n               }\n           }\n           _ {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let tpt = ty_of_item(cx.tcx, m_collect, it);\n-            write_ty(cx.tcx, it.id, tpt.ty);\n+            let tpt = ty_of_item(tcx, m_collect, it);\n+            write_ty(tcx, it.id, tpt.ty);\n           }\n         }\n     }\n-    fn convert_native(cx: @ctxt, i: @ast::native_item) {\n+    fn convert_native(tcx: ty::ctxt, i: @ast::native_item) {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n         // table.\n-        let tpt = ty_of_native_item(cx.tcx, m_collect, i);\n+        let tpt = ty_of_native_item(tcx, m_collect, i);\n         alt i.node {\n-          ast::native_item_fn(_, _) {\n-            write_ty(cx.tcx, i.id, tpt.ty);\n-          }\n+          ast::native_item_fn(_, _) { write_ty(tcx, i.id, tpt.ty); }\n         }\n     }\n     fn collect_item_types(tcx: ty::ctxt, crate: @ast::crate) {\n-        let cx = @{tcx: tcx};\n-        let visit =\n-            visit::mk_simple_visitor(@{visit_item: bind convert(cx, _),\n-                                       visit_native_item:\n-                                           bind convert_native(cx, _)\n-                                       with\n-                                          *visit::default_simple_visitor()});\n-        visit::visit_crate(*crate, (), visit);\n+        visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n+            visit_item: bind convert(tcx, _),\n+            visit_native_item: bind convert_native(tcx, _)\n+            with *visit::default_simple_visitor()\n+        }));\n     }\n }\n \n@@ -1459,17 +1443,12 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n             demand::with_substs(fcx, pat.span, expected, ctor_ty,\n                                 expected_tps);\n             // Get the number of arguments in this enum variant.\n-            let arg_types =\n-                variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n-                                  expected_tps);\n-            let subpats_len = vec::len::<@ast::pat>(subpats);\n-            if vec::len::<ty::t>(arg_types) > 0u {\n+            let arg_types = variant_arg_types(fcx.ccx, pat.span,\n+                                              v_def_ids.var, expected_tps);\n+            let subpats_len = subpats.len(), arg_len = arg_types.len();\n+            if arg_len > 0u {\n                 // N-ary variant.\n-                let arg_len = vec::len::<ty::t>(arg_types);\n                 if arg_len != subpats_len {\n-                    // TODO: note definition of enum variant\n-                    // TODO (issue #448): Wrap a #fmt string over multiple\n-                    // lines...\n                     let s = #fmt[\"this pattern has %u field%s, but the \\\n                                   corresponding variant has %u field%s\",\n                                  subpats_len,\n@@ -1483,7 +1462,6 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n                     check_pat(fcx, map, subpat, arg_ty);\n                 }\n             } else if subpats_len > 0u {\n-                // TODO: note definition of enum variant\n                 tcx.sess.span_err\n                     (pat.span, #fmt[\"this pattern has %u field%s, \\\n                                      but the corresponding \\\n@@ -1494,11 +1472,9 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n             }\n           }\n           _ {\n-            // FIXME: Switch expected and actual in this message? I\n-            // can never tell.\n             tcx.sess.span_err\n                 (pat.span,\n-                 #fmt[\"mismatched types: expected `%s` but found enum\",\n+                 #fmt[\"mismatched types: expected enum but found `%s`\",\n                       ty_to_str(tcx, expected)]);\n           }\n         }\n@@ -2536,7 +2512,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               // field\n               // For now, this code assumes the class is defined in the local\n               // crate\n-              // TODO: handle field references to classes in external crate\n+              // FIXME: handle field references to classes in external crate\n               let err = \"Class ID is not bound to a class\";\n               let field_ty = alt fcx.ccx.tcx.items.find(base_id.node) {\n                       some(ast_map::node_item(i,_)) {\n@@ -2551,7 +2527,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                       _ { fcx.ccx.tcx.sess.span_bug(expr.span, err); }\n               };\n               // (2) look up what field's type is, and return it\n-              // TODO: actually instantiate any type params\n+              // FIXME: actually instantiate any type params\n               write_ty(tcx, id, field_ty);\n               handled = true;\n           }"}]}