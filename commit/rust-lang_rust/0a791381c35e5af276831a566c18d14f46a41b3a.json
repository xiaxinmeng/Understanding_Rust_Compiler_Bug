{"sha": "0a791381c35e5af276831a566c18d14f46a41b3a", "node_id": "C_kwDOAAsO6NoAKDBhNzkxMzgxYzM1ZTVhZjI3NjgzMWE1NjZjMThkMTRmNDZhNDFiM2E", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-23T15:02:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-23T15:02:36Z"}, "message": "Rollup merge of #104509 - spastorino:use-obligation-ctxt, r=lcnr\n\nUse obligation ctxt instead of dyn TraitEngine\n\nr? `@lcnr`", "tree": {"sha": "dd3fc5621e7bdf11243396fdd92a78402c15fcc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd3fc5621e7bdf11243396fdd92a78402c15fcc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a791381c35e5af276831a566c18d14f46a41b3a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfjYMCRBK7hj4Ov3rIwAA9L8IAEUKFhZGT3tNGqrKjhQH6Bwh\nA1bKjz1hkwNAgXMn/TDHMCFkvSPl6+xxC7IxNJCQN5BEDYcfQLDbNbkA1mrDfgPV\nD95prDbe86mOcEwmaxAPD5XSDrBIod02keqXVbvtK13+gCkh9ONf37ON/hItzn8h\nzEtGT0mRWfpC253hXupj1RdN2Zp9QDfDYuLVf6gjJFYbh5UDKYdpG0r0tUxokTAI\ndekzg84flUo7i/EWtrwY4DWH4pXrt/cXT98pGpqf0FbEDU4rLMv2PXASDBBc1Fsf\nQ54NFQPYh54C9cUhmy/7w2pj7wBgj66okcTMG2B2nwuNT7a8AmzUMI3mLauc4Ew=\n=7NV9\n-----END PGP SIGNATURE-----\n", "payload": "tree dd3fc5621e7bdf11243396fdd92a78402c15fcc0\nparent d3e91918759a44372ea42afd11bbc2644a7883a7\nparent 859b147d4f6683b15f309bf3b997efdefca7767d\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1669215756 +0530\ncommitter GitHub <noreply@github.com> 1669215756 +0530\n\nRollup merge of #104509 - spastorino:use-obligation-ctxt, r=lcnr\n\nUse obligation ctxt instead of dyn TraitEngine\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a791381c35e5af276831a566c18d14f46a41b3a", "html_url": "https://github.com/rust-lang/rust/commit/0a791381c35e5af276831a566c18d14f46a41b3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a791381c35e5af276831a566c18d14f46a41b3a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e91918759a44372ea42afd11bbc2644a7883a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e91918759a44372ea42afd11bbc2644a7883a7", "html_url": "https://github.com/rust-lang/rust/commit/d3e91918759a44372ea42afd11bbc2644a7883a7"}, {"sha": "859b147d4f6683b15f309bf3b997efdefca7767d", "url": "https://api.github.com/repos/rust-lang/rust/commits/859b147d4f6683b15f309bf3b997efdefca7767d", "html_url": "https://github.com/rust-lang/rust/commit/859b147d4f6683b15f309bf3b997efdefca7767d"}], "stats": {"total": 111, "additions": 48, "deletions": 63}, "files": [{"sha": "3f0d0a76027f45ca49a0bc3473037f465bfe799c", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=0a791381c35e5af276831a566c18d14f46a41b3a", "patch": "@@ -46,7 +46,7 @@ use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n-use rustc_infer::traits::{Obligation, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -62,8 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -1055,9 +1054,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Ok(ok) = coerce.coerce(source, target) else {\n                 return false;\n             };\n-            let mut fcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n-            fcx.register_predicate_obligations(self, ok.obligations);\n-            fcx.select_where_possible(&self).is_empty()\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n+            ocx.register_obligations(ok.obligations);\n+            ocx.select_where_possible().is_empty()\n         })\n     }\n "}, {"sha": "59d017545c0324329e651fc31b575eb1f71456b8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0a791381c35e5af276831a566c18d14f46a41b3a", "patch": "@@ -4,13 +4,12 @@ pub mod suggestions;\n \n use super::{\n     FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes, Obligation, ObligationCause,\n-    ObligationCauseCode, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n-    SelectionContext, SelectionError, TraitNotObjectSafe,\n+    ObligationCauseCode, ObligationCtxt, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n-use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n@@ -30,7 +29,6 @@ use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::TypeTrace;\n-use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -354,9 +352,9 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     param_env,\n                     ty.rebind(ty::TraitPredicate { trait_ref, constness, polarity }),\n                 );\n-                let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n-                fulfill_cx.register_predicate_obligation(self, obligation);\n-                if fulfill_cx.select_all_or_error(self).is_empty() {\n+                let ocx = ObligationCtxt::new_in_snapshot(self);\n+                ocx.register_obligation(obligation);\n+                if ocx.select_all_or_error().is_empty() {\n                     return Ok((\n                         ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n                             .expect(\"expected to map DefId to ClosureKind\"),"}, {"sha": "548ca1c1d7faa4abe86ab5dc9050f0c58e2e07c3", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=0a791381c35e5af276831a566c18d14f46a41b3a", "patch": "@@ -31,7 +31,6 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n@@ -403,9 +402,7 @@ pub fn fully_solve_obligation<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     obligation: PredicateObligation<'tcx>,\n ) -> Vec<FulfillmentError<'tcx>> {\n-    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    engine.register_predicate_obligation(infcx, obligation);\n-    engine.select_all_or_error(infcx)\n+    fully_solve_obligations(infcx, [obligation])\n }\n \n /// Process a set of obligations (and any nested obligations that come from them)\n@@ -414,9 +411,9 @@ pub fn fully_solve_obligations<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n ) -> Vec<FulfillmentError<'tcx>> {\n-    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    engine.register_predicate_obligations(infcx, obligations);\n-    engine.select_all_or_error(infcx)\n+    let ocx = ObligationCtxt::new(infcx);\n+    ocx.register_obligations(obligations);\n+    ocx.select_all_or_error()\n }\n \n /// Process a bound (and any nested obligations that come from it) to completion.\n@@ -429,9 +426,16 @@ pub fn fully_solve_bound<'tcx>(\n     ty: Ty<'tcx>,\n     bound: DefId,\n ) -> Vec<FulfillmentError<'tcx>> {\n-    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    engine.register_bound(infcx, param_env, ty, bound, cause);\n-    engine.select_all_or_error(infcx)\n+    let tcx = infcx.tcx;\n+    let trait_ref = ty::TraitRef { def_id: bound, substs: tcx.mk_substs_trait(ty, []) };\n+    let obligation = Obligation {\n+        cause,\n+        recursion_depth: 0,\n+        param_env,\n+        predicate: ty::Binder::dummy(trait_ref).without_const().to_predicate(tcx),\n+    };\n+\n+    fully_solve_obligation(infcx, obligation)\n }\n \n /// Normalizes the predicates and checks whether they hold in an empty environment. If this"}, {"sha": "9a3c0707c7ce950102b9e99a36cac2c10f8a7644", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=0a791381c35e5af276831a566c18d14f46a41b3a", "patch": "@@ -10,14 +10,14 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n-use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n-use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n+use crate::traits::{\n+    self, coherence, FutureCompatOverlapErrorKind, ObligationCause, ObligationCtxt,\n+};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{error_code, DelayDm, Diagnostic};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -204,12 +204,12 @@ fn fulfill_implication<'tcx>(\n \n     // Needs to be `in_snapshot` because this function is used to rebase\n     // substitutions, which may happen inside of a select within a probe.\n-    let mut engine = <dyn TraitEngine<'tcx>>::new_in_snapshot(infcx.tcx);\n+    let ocx = ObligationCtxt::new_in_snapshot(infcx);\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n-    engine.register_predicate_obligations(infcx, obligations.chain(more_obligations));\n+    ocx.register_obligations(obligations.chain(more_obligations));\n \n-    let errors = engine.select_all_or_error(infcx);\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         // no dice!\n         debug!("}, {"sha": "40dbe0b3ff063d927dc78c3de0e2eefb1ab3b113", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=0a791381c35e5af276831a566c18d14f46a41b3a", "patch": "@@ -1,6 +1,5 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n-use crate::traits::ObligationCause;\n-use crate::traits::{TraitEngine, TraitEngineExt};\n+use crate::traits::{ObligationCause, ObligationCtxt};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -72,28 +71,16 @@ fn type_marked_structural<'tcx>(\n     adt_ty: Ty<'tcx>,\n     cause: ObligationCause<'tcx>,\n ) -> bool {\n-    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    let ocx = ObligationCtxt::new(infcx);\n     // require `#[derive(PartialEq)]`\n     let structural_peq_def_id =\n         infcx.tcx.require_lang_item(LangItem::StructuralPeq, Some(cause.span));\n-    fulfillment_cx.register_bound(\n-        infcx,\n-        ty::ParamEnv::empty(),\n-        adt_ty,\n-        structural_peq_def_id,\n-        cause.clone(),\n-    );\n+    ocx.register_bound(cause.clone(), ty::ParamEnv::empty(), adt_ty, structural_peq_def_id);\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n     let structural_teq_def_id =\n         infcx.tcx.require_lang_item(LangItem::StructuralTeq, Some(cause.span));\n-    fulfillment_cx.register_bound(\n-        infcx,\n-        ty::ParamEnv::empty(),\n-        adt_ty,\n-        structural_teq_def_id,\n-        cause,\n-    );\n+    ocx.register_bound(cause, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id);\n \n     // We deliberately skip *reporting* fulfillment errors (via\n     // `report_fulfillment_errors`), for two reasons:\n@@ -104,7 +91,7 @@ fn type_marked_structural<'tcx>(\n     //\n     // 2. We are sometimes doing future-incompatibility lints for\n     //    now, so we do not want unconditional errors here.\n-    fulfillment_cx.select_all_or_error(infcx).is_empty()\n+    ocx.select_all_or_error().is_empty()\n }\n \n /// This implements the traversal over the structure of a given type to try to"}, {"sha": "3ab353c96380230b75d1e3b7902eb8769dfe6abe", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a791381c35e5af276831a566c18d14f46a41b3a/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=0a791381c35e5af276831a566c18d14f46a41b3a", "patch": "@@ -5,16 +5,15 @@\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{self, Canonical};\n use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::query::OutlivesBound;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n use rustc_trait_selection::traits::wf;\n-use rustc_trait_selection::traits::{TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::ObligationCtxt;\n use smallvec::{smallvec, SmallVec};\n \n pub(crate) fn provide(p: &mut Providers) {\n@@ -30,16 +29,16 @@ fn implied_outlives_bounds<'tcx>(\n > {\n     tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(&ocx.infcx, param_env, ty)\n+        compute_implied_outlives_bounds(ocx, param_env, ty)\n     })\n }\n \n fn compute_implied_outlives_bounds<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n-    let tcx = infcx.tcx;\n+    let tcx = ocx.infcx.tcx;\n \n     // Sometimes when we ask what it takes for T: WF, we get back that\n     // U: WF is required; in that case, we push U onto this stack and\n@@ -52,8 +51,6 @@ fn compute_implied_outlives_bounds<'tcx>(\n     let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n         vec![];\n \n-    let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n-\n     while let Some(arg) = wf_args.pop() {\n         if !checked_wf_args.insert(arg) {\n             continue;\n@@ -70,15 +67,15 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n         // bounds can be backward incompatible, e.g. #101951 was caused by\n         // us not dealing with inference vars in `TypeOutlives` predicates.\n-        let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n-            .unwrap_or_default();\n+        let obligations =\n+            wf::obligations(ocx.infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n+                .unwrap_or_default();\n \n         // While these predicates should all be implied by other parts of\n         // the program, they are still relevant as they may constrain\n         // inference variables, which is necessary to add the correct\n         // implied bounds in some cases, mostly when dealing with projections.\n-        fulfill_cx.register_predicate_obligations(\n-            infcx,\n+        ocx.register_obligations(\n             obligations.iter().filter(|o| o.predicate.has_non_region_infer()).cloned(),\n         );\n \n@@ -116,9 +113,9 @@ fn compute_implied_outlives_bounds<'tcx>(\n         }));\n     }\n \n-    // Ensure that those obligations that we had to solve\n-    // get solved *here*.\n-    match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n+    // use further down when computing the implied bounds.\n+    match ocx.select_all_or_error().as_slice() {\n         [] => (),\n         _ => return Err(NoSolution),\n     }\n@@ -130,7 +127,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n             ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n             ty::GenericArgKind::Type(ty_a) => {\n-                let ty_a = infcx.resolve_vars_if_possible(ty_a);\n+                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n                 let mut components = smallvec![];\n                 push_outlives_components(tcx, ty_a, &mut components);\n                 implied_bounds_from_components(r_b, components)"}]}