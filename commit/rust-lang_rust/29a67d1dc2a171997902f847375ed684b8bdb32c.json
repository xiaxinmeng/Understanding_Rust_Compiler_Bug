{"sha": "29a67d1dc2a171997902f847375ed684b8bdb32c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YTY3ZDFkYzJhMTcxOTk3OTAyZjg0NzM3NWVkNjg0YjhiZGIzMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-17T14:42:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-17T14:42:01Z"}, "message": "auto merge of #8272 : DaGenix/rust/digest-md5-impl-not-unrolled, r=cmr\n\nAn MD5 implementation was originally included in #8097, but, since there are a couple different implementations of that digest algorithm (@alco mentioned his implementation on the mailing list just before I opened that PR), it was suggested that I remove it from that PR and open up a new PR to discuss the different implementations and the best way forward. If anyone wants to discuss a different implementation, feel free to present it here and discuss and compare it to this one. I'll just discuss my implementation and I'll leave it to others to present details of theirs.\r\n\r\nThis implementation relies on the FixedBuffer struct from cryptoutil.rs for managing the input buffer, just like the Sha1 and Sha2 digest implementations do. I tried manually unrolling the loops in the compression function, but I got slightly worse performance when I did that.\r\n\r\nOutside of the #[test]s, I also tested the implementation by generating 1,000 inputs of up to 10MB in size and checking the MD5 digest calculated by this code against the MD5 digest calculated by Java's implementation.\r\n\r\nOn my computer, I'm getting the following performance:\r\n\r\n```\r\ntest md5::bench::md5_10 ... bench: 52 ns/iter (+/- 1) = 192 MB/s\r\ntest md5::bench::md5_1k ... bench: 2819 ns/iter (+/- 44) = 363 MB/s\r\ntest md5::bench::md5_64k ... bench: 178566 ns/iter (+/- 4927) = 367 MB/s\r\n```", "tree": {"sha": "bdeb5cbc8e18aa42782e8913b18f7ab765b4fc47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdeb5cbc8e18aa42782e8913b18f7ab765b4fc47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29a67d1dc2a171997902f847375ed684b8bdb32c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29a67d1dc2a171997902f847375ed684b8bdb32c", "html_url": "https://github.com/rust-lang/rust/commit/29a67d1dc2a171997902f847375ed684b8bdb32c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29a67d1dc2a171997902f847375ed684b8bdb32c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90", "html_url": "https://github.com/rust-lang/rust/commit/1942a7a3fb3eb860f225f491c0aa2eb93a7c6e90"}, {"sha": "b00aa12374d01b1caadbcfc2b0de76d8bb884192", "url": "https://api.github.com/repos/rust-lang/rust/commits/b00aa12374d01b1caadbcfc2b0de76d8bb884192", "html_url": "https://github.com/rust-lang/rust/commit/b00aa12374d01b1caadbcfc2b0de76d8bb884192"}], "stats": {"total": 513, "additions": 471, "deletions": 42}, "files": [{"sha": "2bca346061a13b796a373682ac9f57f13a8aa282", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 134, "deletions": 36, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=29a67d1dc2a171997902f847375ed684b8bdb32c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::One;\n+use std::num::{One, Zero, CheckedAdd};\n use std::vec::bytes::{MutableByteVector, copy_memory};\n \n \n@@ -36,6 +36,18 @@ pub fn write_u32_be(dst: &mut[u8], input: u32) {\n     }\n }\n \n+/// Write a u32 into a vector, which must be 4 bytes long. The value is written in little-endian\n+/// format.\n+pub fn write_u32_le(dst: &mut[u8], input: u32) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_le32;\n+    assert!(dst.len() == 4);\n+    unsafe {\n+        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_le32(input as i32);\n+    }\n+}\n+\n /// Read a vector of bytes into a vector of u64s. The values are read in big-endian format.\n pub fn read_u64v_be(dst: &mut[u64], input: &[u8]) {\n     use std::cast::transmute;\n@@ -68,51 +80,90 @@ pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     }\n }\n \n+/// Read a vector of bytes into a vector of u32s. The values are read in little-endian format.\n+pub fn read_u32v_le(dst: &mut[u32], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_le32;\n+    assert!(dst.len() * 4 == input.len());\n+    unsafe {\n+        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_le32(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n \n-/// Returns true if adding the two parameters will result in integer overflow\n-pub fn will_add_overflow<T: Int + Unsigned>(x: T, y: T) -> bool {\n-    // This doesn't handle negative values! Don't copy this code elsewhere without considering if\n-    // negative values are important to you!\n-    let max: T = Bounded::max_value();\n-    return x > max - y;\n+trait ToBits {\n+    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n+    /// high-order value and the 2nd item is the low order value.\n+    fn to_bits(self) -> (Self, Self);\n }\n \n-/// Shifts the second parameter and then adds it to the first. fails!() if there would be unsigned\n-/// integer overflow.\n-pub fn shift_add_check_overflow<T: Int + Unsigned + Clone>(x: T, mut y: T, shift: T) -> T {\n-    if y.leading_zeros() < shift {\n-        fail!(\"Could not add values - integer overflow.\");\n+impl ToBits for u64 {\n+    fn to_bits(self) -> (u64, u64) {\n+        return (self >> 61, self << 3);\n     }\n-    y = y << shift;\n+}\n \n-    if will_add_overflow(x.clone(), y.clone()) {\n-        fail!(\"Could not add values - integer overflow.\");\n-    }\n+/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// overflow.\n+pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    return x + y;\n-}\n+    if new_high_bits > Zero::zero() {\n+        fail!(\"Numeric overflow occured.\")\n+    }\n \n-/// Shifts the second parameter and then adds it to the first, which is a tuple where the first\n-/// element is the high order value. fails!() if there would be unsigned integer overflow.\n-pub fn shift_add_check_overflow_tuple\n-        <T: Int + Unsigned + Clone>\n-        (x: (T, T), mut y: T, shift: T) -> (T, T) {\n-    if y.leading_zeros() < shift {\n-        fail!(\"Could not add values - integer overflow.\");\n+    match bits.checked_add(&new_low_bits) {\n+        Some(x) => return x,\n+        None => fail!(\"Numeric overflow occured.\")\n     }\n-    y = y << shift;\n+}\n \n-    match x {\n-        (hi, low) => {\n-            let one: T = One::one();\n-            if will_add_overflow(low.clone(), y.clone()) {\n-                if will_add_overflow(hi.clone(), one.clone()) {\n-                    fail!(\"Could not add values - integer overflow.\");\n-                } else {\n-                    return (hi + one, low + y);\n-                }\n+/// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n+/// the high order value. fail!() if this would cause numeric overflow.\n+pub fn add_bytes_to_bits_tuple\n+        <T: Int + Unsigned + CheckedAdd + ToBits>\n+        (bits: (T, T), bytes: T) -> (T, T) {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n+    let (hi, low) = bits;\n+\n+    // Add the low order value - if there is no overflow, then add the high order values\n+    // If the addition of the low order values causes overflow, add one to the high order values\n+    // before adding them.\n+    match low.checked_add(&new_low_bits) {\n+        Some(x) => {\n+            if new_high_bits == Zero::zero() {\n+                // This is the fast path - every other alternative will rarely occur in practice\n+                // considering how large an input would need to be for those paths to be used.\n+                return (hi, x);\n             } else {\n-                return (hi, low + y);\n+                match hi.checked_add(&new_high_bits) {\n+                    Some(y) => return (y, x),\n+                    None => fail!(\"Numeric overflow occured.\")\n+                }\n+            }\n+        },\n+        None => {\n+            let one: T = One::one();\n+            let z = match new_high_bits.checked_add(&one) {\n+                Some(w) => w,\n+                None => fail!(\"Numeric overflow occured.\")\n+            };\n+            match hi.checked_add(&z) {\n+                // This re-executes the addition that was already performed earlier when overflow\n+                // occured, this time allowing the overflow to happen. Technically, this could be\n+                // avoided by using the checked add intrinsic directly, but that involves using\n+                // unsafe code and is not really worthwhile considering how infrequently code will\n+                // run in practice. This is the reason that this function requires that the type T\n+                // be Unsigned - overflow is not defined for Signed types. This function could be\n+                // implemented for signed types as well if that were needed.\n+                Some(y) => return (y, low + new_low_bits),\n+                None => fail!(\"Numeric overflow occured.\")\n             }\n         }\n     }\n@@ -300,6 +351,7 @@ mod test {\n     use std::rand::RngUtil;\n     use std::vec;\n \n+    use cryptoutil::{add_bytes_to_bits, add_bytes_to_bits_tuple};\n     use digest::Digest;\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n@@ -324,4 +376,50 @@ mod test {\n \n         assert!(expected == result_str);\n     }\n+\n+    // A normal addition - no overflow occurs\n+    #[test]\n+    fn test_add_bytes_to_bits_ok() {\n+        assert!(add_bytes_to_bits::<u64>(100, 10) == 180);\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_overflow() {\n+        add_bytes_to_bits::<u64>(Bounded::max_value(), 1);\n+    }\n+\n+    // A normal addition - no overflow occurs (fast path)\n+    #[test]\n+    fn test_add_bytes_to_bits_tuple_ok() {\n+        assert!(add_bytes_to_bits_tuple::<u64>((5, 100), 10) == (5, 180));\n+    }\n+\n+    // The low order value overflows into the high order value\n+    #[test]\n+    fn test_add_bytes_to_bits_tuple_ok2() {\n+        assert!(add_bytes_to_bits_tuple::<u64>((5, Bounded::max_value()), 1) == (6, 7));\n+    }\n+\n+    // The value to add is too large to be converted into bits without overflowing its type\n+    #[test]\n+    fn test_add_bytes_to_bits_tuple_ok3() {\n+        assert!(add_bytes_to_bits_tuple::<u64>((5, 0), 0x4000000000000001) == (7, 8));\n+    }\n+\n+    // A simple failure case - adding 1 to the max value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_tuple_overflow() {\n+        add_bytes_to_bits_tuple::<u64>((Bounded::max_value(), Bounded::max_value()), 1);\n+    }\n+\n+    // The value to add is too large to convert to bytes without overflowing its type, but the high\n+    // order value from this conversion overflows when added to the existing high order value\n+    #[test]\n+    #[should_fail]\n+    fn test_add_bytes_to_bits_tuple_overflow2() {\n+        add_bytes_to_bits_tuple::<u64>((Bounded::max_value::<u64>() - 1, 0), 0x8000000000000000);\n+    }\n }"}, {"sha": "8e8b752da80754fa47d50d9cf5fe9961deeabc68", "filename": "src/libextra/crypto/md5.rs", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fmd5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fmd5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fmd5.rs?ref=29a67d1dc2a171997902f847375ed684b8bdb32c", "patch": "@@ -0,0 +1,329 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::uint;\n+\n+use cryptoutil::{write_u32_le, read_u32v_le, FixedBuffer, FixedBuffer64, StandardPadding};\n+use digest::Digest;\n+\n+\n+// A structure that represents that state of a digest computation for the MD5 digest function\n+struct Md5State {\n+    s0: u32,\n+    s1: u32,\n+    s2: u32,\n+    s3: u32\n+}\n+\n+impl Md5State {\n+    fn new() -> Md5State {\n+        return Md5State {\n+            s0: 0x67452301,\n+            s1: 0xefcdab89,\n+            s2: 0x98badcfe,\n+            s3: 0x10325476\n+        };\n+    }\n+\n+    fn reset(&mut self) {\n+        self.s0 = 0x67452301;\n+        self.s1 = 0xefcdab89;\n+        self.s2 = 0x98badcfe;\n+        self.s3 = 0x10325476;\n+    }\n+\n+    fn process_block(&mut self, input: &[u8]) {\n+        fn f(u: u32, v: u32, w: u32) -> u32 {\n+            return (u & v) | (!u & w);\n+        }\n+\n+        fn g(u: u32, v: u32, w: u32) -> u32 {\n+            return (u & w) | (v & !w);\n+        }\n+\n+        fn h(u: u32, v: u32, w: u32) -> u32 {\n+            return u ^ v ^ w;\n+        }\n+\n+        fn i(u: u32, v: u32, w: u32) -> u32 {\n+            return v ^ (u | !w);\n+        }\n+\n+        fn rotate_left(x: u32, n: u32) -> u32 {\n+            return (x << n) | (x >> (32 - n));\n+        }\n+\n+        fn op_f(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + f(x, y, z) + m, s) + x;\n+        }\n+\n+        fn op_g(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + g(x, y, z) + m, s) + x;\n+        }\n+\n+        fn op_h(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + h(x, y, z) + m, s) + x;\n+        }\n+\n+        fn op_i(w: u32, x: u32, y: u32, z: u32, m: u32, s: u32) -> u32 {\n+            return rotate_left(w + i(x, y, z) + m, s) + x;\n+        }\n+\n+        let mut a = self.s0;\n+        let mut b = self.s1;\n+        let mut c = self.s2;\n+        let mut d = self.s3;\n+\n+        let mut data = [0u32, ..16];\n+\n+        read_u32v_le(data, input);\n+\n+        // round 1\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_f(a, b, c, d, data[i] + C1[i], 7);\n+            d = op_f(d, a, b, c, data[i + 1] + C1[i + 1], 12);\n+            c = op_f(c, d, a, b, data[i + 2] + C1[i + 2], 17);\n+            b = op_f(b, c, d, a, data[i + 3] + C1[i + 3], 22);\n+            true\n+        };\n+\n+        // round 2\n+        let mut t = 1;\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_g(a, b, c, d, data[t & 0x0f] + C2[i], 5);\n+            d = op_g(d, a, b, c, data[(t + 5) & 0x0f] + C2[i + 1], 9);\n+            c = op_g(c, d, a, b, data[(t + 10) & 0x0f] + C2[i + 2], 14);\n+            b = op_g(b, c, d, a, data[(t + 15) & 0x0f] + C2[i + 3], 20);\n+            t += 20;\n+            true\n+        };\n+\n+        // round 3\n+        t = 5;\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_h(a, b, c, d, data[t & 0x0f] + C3[i], 4);\n+            d = op_h(d, a, b, c, data[(t + 3) & 0x0f] + C3[i + 1], 11);\n+            c = op_h(c, d, a, b, data[(t + 6) & 0x0f] + C3[i + 2], 16);\n+            b = op_h(b, c, d, a, data[(t + 9) & 0x0f] + C3[i + 3], 23);\n+            t += 12;\n+            true\n+        };\n+\n+        // round 4\n+        t = 0;\n+        do uint::range_step(0, 16, 4) |i| {\n+            a = op_i(a, b, c, d, data[t & 0x0f] + C4[i], 6);\n+            d = op_i(d, a, b, c, data[(t + 7) & 0x0f] + C4[i + 1], 10);\n+            c = op_i(c, d, a, b, data[(t + 14) & 0x0f] + C4[i + 2], 15);\n+            b = op_i(b, c, d, a, data[(t + 21) & 0x0f] + C4[i + 3], 21);\n+            t += 28;\n+            true\n+        };\n+\n+        self.s0 += a;\n+        self.s1 += b;\n+        self.s2 += c;\n+        self.s3 += d;\n+    }\n+}\n+\n+// Round 1 constants\n+static C1: [u32, ..16] = [\n+    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n+    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821\n+];\n+\n+// Round 2 constants\n+static C2: [u32, ..16] = [\n+    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n+    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a\n+];\n+\n+// Round 3 constants\n+static C3: [u32, ..16] = [\n+    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n+    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665\n+];\n+\n+// Round 4 constants\n+static C4: [u32, ..16] = [\n+    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n+    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n+];\n+\n+\n+/// The MD5 Digest algorithm\n+struct Md5 {\n+    priv length_bytes: u64,\n+    priv buffer: FixedBuffer64,\n+    priv state: Md5State,\n+    priv finished: bool,\n+}\n+\n+impl Md5 {\n+    /// Construct a new instance of the MD5 Digest.\n+    pub fn new() -> Md5 {\n+        return Md5 {\n+            length_bytes: 0,\n+            buffer: FixedBuffer64::new(),\n+            state: Md5State::new(),\n+            finished: false\n+        }\n+    }\n+}\n+\n+impl Digest for Md5 {\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished);\n+        // Unlike Sha1 and Sha2, the length value in MD5 is defined as the length of the message mod\n+        // 2^64 - ie: integer overflow is OK.\n+        self.length_bytes += input.len() as u64;\n+        self.buffer.input(input, |d: &[u8]| { self.state.process_block(d); });\n+    }\n+\n+    fn reset(&mut self) {\n+        self.length_bytes = 0;\n+        self.buffer.reset();\n+        self.state.reset();\n+        self.finished = false;\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        if !self.finished {\n+            self.buffer.standard_padding(8, |d: &[u8]| { self.state.process_block(d); });\n+            write_u32_le(self.buffer.next(4), (self.length_bytes << 3) as u32);\n+            write_u32_le(self.buffer.next(4), (self.length_bytes >> 29) as u32);\n+            self.state.process_block(self.buffer.full_buffer());\n+            self.finished = true;\n+        }\n+\n+        write_u32_le(out.mut_slice(0, 4), self.state.s0);\n+        write_u32_le(out.mut_slice(4, 8), self.state.s1);\n+        write_u32_le(out.mut_slice(8, 12), self.state.s2);\n+        write_u32_le(out.mut_slice(12, 16), self.state.s3);\n+    }\n+\n+    fn output_bits(&self) -> uint { 128 }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use cryptoutil::test::test_digest_1million_random;\n+    use digest::Digest;\n+    use md5::Md5;\n+\n+\n+    struct Test {\n+        input: ~str,\n+        output_str: ~str,\n+    }\n+\n+    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n+        // Test that it works when accepting the message all at once\n+        for t in tests.iter() {\n+            sh.input_str(t.input);\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+        // Test that it works when accepting the message in pieces\n+        for t in tests.iter() {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_md5() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"d41d8cd98f00b204e9800998ecf8427e\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"9e107d9d372bb6826bd81d3542a419d6\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"e4d909c290d0fb1ca068ffaddf22cbd0\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = Md5::new();\n+\n+        test_hash(&mut sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_1million_random_md5() {\n+        let mut sh = Md5::new();\n+        test_digest_1million_random(\n+            &mut sh,\n+            64,\n+            \"7707d6ae4e027c70eea2a935c2296f21\");\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+\n+    use md5::Md5;\n+\n+\n+    #[bench]\n+    pub fn md5_10(bh: & mut BenchHarness) {\n+        let mut sh = Md5::new();\n+        let bytes = [1u8, ..10];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn md5_1k(bh: & mut BenchHarness) {\n+        let mut sh = Md5::new();\n+        let bytes = [1u8, ..1024];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn md5_64k(bh: & mut BenchHarness) {\n+        let mut sh = Md5::new();\n+        let bytes = [1u8, ..65536];\n+        do bh.iter {\n+            sh.input(bytes);\n+        }\n+        bh.bytes = bytes.len() as u64;\n+    }\n+}"}, {"sha": "4d4d47feee817c0bb07f4136215d88c327ad027f", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=29a67d1dc2a171997902f847375ed684b8bdb32c", "patch": "@@ -23,7 +23,7 @@\n  */\n \n \n-use cryptoutil::{write_u32_be, read_u32v_be, shift_add_check_overflow, FixedBuffer, FixedBuffer64,\n+use cryptoutil::{write_u32_be, read_u32v_be, add_bytes_to_bits, FixedBuffer, FixedBuffer64,\n     StandardPadding};\n use digest::Digest;\n \n@@ -52,7 +52,7 @@ pub struct Sha1 {\n fn add_input(st: &mut Sha1, msg: &[u8]) {\n     assert!((!st.computed));\n     // Assumes that msg.len() can be converted to u64 without overflow\n-    st.length_bits = shift_add_check_overflow(st.length_bits, msg.len() as u64, 3);\n+    st.length_bits = add_bytes_to_bits(st.length_bits, msg.len() as u64);\n     st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n }\n "}, {"sha": "96f3e13eb2202530edf5125c5b4ce336a3aae44d", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=29a67d1dc2a171997902f847375ed684b8bdb32c", "patch": "@@ -10,8 +10,8 @@\n \n use std::uint;\n \n-use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, shift_add_check_overflow,\n-    shift_add_check_overflow_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n+use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_bytes_to_bits,\n+    add_bytes_to_bits_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n \n@@ -210,7 +210,7 @@ impl Engine512 {\n     fn input(&mut self, input: &[u8]) {\n         assert!(!self.finished)\n         // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = shift_add_check_overflow_tuple(self.length_bits, input.len() as u64, 3);\n+        self.length_bits = add_bytes_to_bits_tuple(self.length_bits, input.len() as u64);\n         self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n \n@@ -602,7 +602,7 @@ impl Engine256 {\n     fn input(&mut self, input: &[u8]) {\n         assert!(!self.finished)\n         // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = shift_add_check_overflow(self.length_bits, input.len() as u64, 3);\n+        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n         self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n "}, {"sha": "da6525f78155887b5723b521131321df99fd3f05", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29a67d1dc2a171997902f847375ed684b8bdb32c/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=29a67d1dc2a171997902f847375ed684b8bdb32c", "patch": "@@ -71,6 +71,8 @@ pub mod treemap;\n mod cryptoutil;\n #[path=\"crypto/digest.rs\"]\n pub mod digest;\n+#[path=\"crypto/md5.rs\"]\n+pub mod md5;\n #[path=\"crypto/sha1.rs\"]\n pub mod sha1;\n #[path=\"crypto/sha2.rs\"]"}]}