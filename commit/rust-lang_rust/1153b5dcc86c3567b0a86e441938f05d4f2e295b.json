{"sha": "1153b5dcc86c3567b0a86e441938f05d4f2e295b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNTNiNWRjYzg2YzM1NjdiMGE4NmU0NDE5MzhmMDVkNGYyZTI5NWI=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-18T23:18:02Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-08-22T21:59:25Z"}, "message": "intern identifiers", "tree": {"sha": "fdcbcea39abecb4ad1ea5145e62e8c013b05e930", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdcbcea39abecb4ad1ea5145e62e8c013b05e930"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1153b5dcc86c3567b0a86e441938f05d4f2e295b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1153b5dcc86c3567b0a86e441938f05d4f2e295b", "html_url": "https://github.com/rust-lang/rust/commit/1153b5dcc86c3567b0a86e441938f05d4f2e295b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1153b5dcc86c3567b0a86e441938f05d4f2e295b/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7317bf8792ebb3f27768109b7d574ee0806cc5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7317bf8792ebb3f27768109b7d574ee0806cc5e5", "html_url": "https://github.com/rust-lang/rust/commit/7317bf8792ebb3f27768109b7d574ee0806cc5e5"}], "stats": {"total": 3126, "additions": 1662, "deletions": 1464}, "files": [{"sha": "30d5fef72ed7e33413d8347f20b7b00c04d395ec", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -225,7 +225,7 @@ fn load_link(mis: ~[@ast::meta_item]) -> (option<~str>,\n     for mis.each |a| {\n         match a.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n-                match *v {\n+                match v {\n                     ~\"name\" => name = some(*s),\n                     ~\"vers\" => vers = some(*s),\n                     ~\"uuid\" => uuid = some(*s),\n@@ -252,15 +252,15 @@ fn load_crate(filename: ~str) -> option<crate> {\n     for c.node.attrs.each |a| {\n         match a.node.value.node {\n             ast::meta_name_value(v, {node: ast::lit_str(s), span: _}) => {\n-                match *v {\n-                    ~\"desc\" => desc = some(*v),\n-                    ~\"sigs\" => sigs = some(*v),\n-                    ~\"crate_type\" => crate_type = some(*v),\n+                match v {\n+                    ~\"desc\" => desc = some(v),\n+                    ~\"sigs\" => sigs = some(v),\n+                    ~\"crate_type\" => crate_type = some(v),\n                     _ => { }\n                 }\n             }\n             ast::meta_list(v, mis) => {\n-                if *v == ~\"link\" {\n+                if v == ~\"link\" {\n                     let (n, v, u) = load_link(mis);\n                     name = n;\n                     vers = v;\n@@ -278,13 +278,15 @@ fn load_crate(filename: ~str) -> option<crate> {\n         mut deps: ~[~str]\n     };\n \n-    fn goto_view_item(e: env, i: @ast::view_item) {\n+    fn goto_view_item(ps: syntax::parse::parse_sess, e: env,\n+                      i: @ast::view_item) {\n         match i.node {\n             ast::view_item_use(ident, metas, id) => {\n                 let name_items =\n                     attr::find_meta_items_by_name(metas, ~\"name\");\n                 let m = if name_items.is_empty() {\n-                    metas + ~[attr::mk_name_value_item_str(@~\"name\", *ident)]\n+                    metas + ~[attr::mk_name_value_item_str(\n+                        ~\"name\", *ps.interner.get(ident))]\n                 } else {\n                     metas\n                 };\n@@ -297,9 +299,9 @@ fn load_crate(filename: ~str) -> option<crate> {\n                         some(value) => {\n                             let name = attr::get_meta_item_name(item);\n \n-                            match *name {\n-                                ~\"vers\" => attr_vers = *value,\n-                                ~\"from\" => attr_from = *value,\n+                            match name {\n+                                ~\"vers\" => attr_vers = value,\n+                                ~\"from\" => attr_from = value,\n                                 _ => ()\n                             }\n                         }\n@@ -311,11 +313,11 @@ fn load_crate(filename: ~str) -> option<crate> {\n                     attr_from\n                 } else {\n                     if !str::is_empty(attr_vers) {\n-                        *attr_name + ~\"@\" + attr_vers\n-                    } else { *attr_name }\n+                        ps.interner.get(attr_name) + ~\"@\" + attr_vers\n+                    } else { *ps.interner.get(attr_name) }\n                 };\n \n-                match *attr_name {\n+                match *ps.interner.get(attr_name) {\n                     ~\"std\" | ~\"core\" => (),\n                     _ => vec::push(e.deps, query)\n                 }\n@@ -330,7 +332,7 @@ fn load_crate(filename: ~str) -> option<crate> {\n         mut deps: ~[]\n     };\n     let v = visit::mk_simple_visitor(@{\n-        visit_view_item: |a| goto_view_item(e, a),\n+        visit_view_item: |a| goto_view_item(sess, e, a),\n         visit_item: |a| goto_item(e, a),\n         with *visit::default_simple_visitor()\n     });"}, {"sha": "9c42b29304d312da3e9af1367957e19e8601dec9", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -238,29 +238,31 @@ fn check_variants_T<T: copy>(\n   filename: ~str,\n   thing_label: ~str,\n   things: ~[T],\n-  stringifier: fn@(@T) -> ~str,\n+  stringifier: fn@(@T, syntax::parse::token::ident_interner) -> ~str,\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n     error!{\"%s contains %u %s objects\", filename,\n            vec::len(things), thing_label};\n \n+    // Assuming we're not generating any token_trees\n+    let intr = syntax::parse::token::mk_fake_ident_interner();\n+\n     let L = vec::len(things);\n \n     if L < 100u {\n         do under(uint::min(L, 20u)) |i| {\n             log(error, ~\"Replacing... #\" + uint::str(i));\n             do under(uint::min(L, 30u)) |j| {\n-                log(error, ~\"With... \" + stringifier(@things[j]));\n+                log(error, ~\"With... \" + stringifier(@things[j], intr));\n                 let crate2 = @replacer(crate, i, things[j], cx.mode);\n                 // It would be best to test the *crate* for stability, but\n                 // testing the string for stability is easier and ok for now.\n                 let handler = diagnostic::mk_handler(none);\n                 let str3 =\n                     @as_str(|a|pprust::print_crate(\n                         codemap,\n-                        // Assuming we're not generating any token_trees\n-                        syntax::parse::token::mk_ident_interner(),\n+                        intr,\n                         diagnostic::mk_span_handler(handler, codemap),\n                         crate2,\n                         filename,\n@@ -422,7 +424,7 @@ fn parse_and_print(code: @~str) -> ~str {\n                pprust::print_crate(\n                    sess.cm,\n                    // Assuming there are no token_trees\n-                   syntax::parse::token::mk_ident_interner(),\n+                   syntax::parse::token::mk_fake_ident_interner(),\n                    sess.span_diagnostic,\n                    crate,\n                    filename,\n@@ -570,7 +572,7 @@ fn check_variants(files: ~[~str], cx: context) {\n                    as_str(|a| pprust::print_crate(\n                        sess.cm,\n                        // Assuming no token_trees\n-                       syntax::parse::token::mk_ident_interner(),\n+                       syntax::parse::token::mk_fake_ident_interner(),\n                        sess.span_diagnostic,\n                        crate,\n                        file,"}, {"sha": "7d9803b4cc38eb68802249e7fe4c6c7fa3293b14", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -30,8 +30,18 @@ fn deserialize_span<D>(_d: D) -> span {\n #[auto_serialize]\n type spanned<T> = {node: T, span: span};\n \n-#[auto_serialize]\n-type ident = @~str;\n+fn serialize_ident<S: serializer>(s: S, i: ident) {\n+    let intr = unsafe{ task::local_data_get(parse::token::interner_key) };\n+\n+    s.emit_str(*(*intr.get()).get(i));\n+}\n+fn deserialize_ident<D: deserializer>(d: D) -> ident  {\n+    let intr = unsafe{ task::local_data_get(parse::token::interner_key) };\n+\n+    (*intr.get()).intern(@d.read_str())\n+}\n+\n+type ident = token::str_num;\n \n // Functions may or may not have names.\n #[auto_serialize]\n@@ -127,9 +137,9 @@ type meta_item = spanned<meta_item_>;\n \n #[auto_serialize]\n enum meta_item_ {\n-    meta_word(ident),\n-    meta_list(ident, ~[@meta_item]),\n-    meta_name_value(ident, lit),\n+    meta_word(~str),\n+    meta_list(~str, ~[@meta_item]),\n+    meta_name_value(~str, lit),\n }\n \n #[auto_serialize]\n@@ -815,36 +825,6 @@ enum inlined_item {\n     ii_dtor(class_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n \n-// Convenience functions\n-\n-pure fn simple_path(id: ident, span: span) -> @path {\n-    @{span: span,\n-      global: false,\n-      idents: ~[id],\n-      rp: none,\n-      types: ~[]}\n-}\n-\n-pure fn empty_span() -> span {\n-    {lo: 0, hi: 0, expn_info: none}\n-}\n-\n-// Convenience implementations\n-\n-impl ident: ops::add<ident,@path> {\n-    pure fn add(&&id: ident) -> @path {\n-        simple_path(self, empty_span()) + id\n-    }\n-}\n-\n-impl @path: ops::add<ident,@path> {\n-    pure fn add(&&id: ident) -> @path {\n-        @{\n-            idents: vec::append_one(self.idents, id)\n-            with *self\n-        }\n-    }\n-}\n \n //\n // Local Variables:"}, {"sha": "2cc8cb23f2e48e74bfc22794385e886799cf7b51", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -4,31 +4,33 @@ import ast::*;\n import print::pprust;\n import ast_util::{path_to_ident, stmt_id};\n import diagnostic::span_handler;\n+import parse::token::ident_interner;\n \n enum path_elt { path_mod(ident), path_name(ident) }\n type path = ~[path_elt];\n \n /* FIXMEs that say \"bad\" are as per #2543 */\n-fn path_to_str_with_sep(p: path, sep: ~str) -> ~str {\n+fn path_to_str_with_sep(p: path, sep: ~str, itr: ident_interner) -> ~str {\n     let strs = do vec::map(p) |e| {\n         match e {\n-          path_mod(s) => /* FIXME (#2543) */ copy *s,\n-          path_name(s) => /* FIXME (#2543) */ copy *s\n+          path_mod(s) => *itr.get(s),\n+          path_name(s) => *itr.get(s)\n         }\n     };\n     str::connect(strs, sep)\n }\n \n-fn path_ident_to_str(p: path, i: ident) -> ~str {\n+fn path_ident_to_str(p: path, i: ident, itr: ident_interner) -> ~str {\n     if vec::is_empty(p) {\n-        /* FIXME (#2543) */ copy *i\n+        //FIXME /* FIXME (#2543) */ copy *i\n+        *itr.get(i)\n     } else {\n-        fmt!{\"%s::%s\", path_to_str(p), *i}\n+        fmt!{\"%s::%s\", path_to_str(p, itr), *itr.get(i)}\n     }\n }\n \n-fn path_to_str(p: path) -> ~str {\n-    path_to_str_with_sep(p, ~\"::\")\n+fn path_to_str(p: path, itr: ident_interner) -> ~str {\n+    path_to_str_with_sep(p, ~\"::\", itr)\n }\n \n enum ast_node {\n@@ -291,43 +293,42 @@ fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n     visit::visit_stmt(stmt, cx, v);\n }\n \n-fn node_id_to_str(map: map, id: node_id) -> ~str {\n+fn node_id_to_str(map: map, id: node_id, itr: ident_interner) -> ~str {\n     match map.find(id) {\n       none => {\n         fmt!{\"unknown node (id=%d)\", id}\n       }\n       some(node_item(item, path)) => {\n-        fmt!{\"item %s (id=%?)\", path_ident_to_str(*path, item.ident), id}\n+        fmt!{\"item %s (id=%?)\", path_ident_to_str(*path, item.ident, itr), id}\n       }\n       some(node_foreign_item(item, abi, path)) => {\n         fmt!{\"foreign item %s with abi %? (id=%?)\",\n-             path_ident_to_str(*path, item.ident), abi, id}\n+             path_ident_to_str(*path, item.ident, itr), abi, id}\n       }\n       some(node_method(m, impl_did, path)) => {\n         fmt!{\"method %s in %s (id=%?)\",\n-             *m.ident, path_to_str(*path), id}\n+             *itr.get(m.ident), path_to_str(*path, itr), id}\n       }\n       some(node_trait_method(tm, impl_did, path)) => {\n         let m = ast_util::trait_method_to_ty_method(*tm);\n         fmt!{\"method %s in %s (id=%?)\",\n-             *m.ident, path_to_str(*path), id}\n+             *itr.get(m.ident), path_to_str(*path, itr), id}\n       }\n       some(node_variant(variant, def_id, path)) => {\n         fmt!{\"variant %s in %s (id=%?)\",\n-             *variant.node.name, path_to_str(*path), id}\n+             *itr.get(variant.node.name), path_to_str(*path, itr), id}\n       }\n       some(node_expr(expr)) => {\n-        fmt!{\"expr %s (id=%?)\",\n-             pprust::expr_to_str(expr), id}\n+        fmt!{\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id}\n       }\n       some(node_stmt(stmt)) => {\n         fmt!{\"stmt %s (id=%?)\",\n-             pprust::stmt_to_str(*stmt), id}\n+             pprust::stmt_to_str(*stmt, itr), id}\n       }\n       // FIXMEs are as per #2410\n       some(node_export(_, path)) => {\n         fmt!{\"export %s (id=%?)\", // add more info here\n-             path_to_str(*path), id}\n+             path_to_str(*path, itr), id}\n       }\n       some(node_arg(_, _)) => { // add more info here\n         fmt!{\"arg (id=%?)\", id}"}, {"sha": "fe1924d1dbec2e88e02cc1741de60d4f636502bc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -21,13 +21,14 @@ pure fn mk_sp(lo: uint, hi: uint) -> span {\n // make this a const, once the compiler supports it\n pure fn dummy_sp() -> span { return mk_sp(0u, 0u); }\n \n-pure fn path_name(p: @path) -> ~str { path_name_i(p.idents) }\n \n-pure fn path_name_i(idents: ~[ident]) -> ~str {\n+\n+pure fn path_name_i(idents: ~[ident], intr: token::ident_interner) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i|*i), ~\"::\")\n+    str::connect(idents.map(|i| *intr.get(i)), ~\"::\")\n }\n \n+\n pure fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }\n \n pure fn local_def(id: node_id) -> def_id { {crate: local_crate, node: id} }\n@@ -408,7 +409,8 @@ fn dtor_dec() -> fn_decl {\n     let nil_t = @{id: 0, node: ty_nil, span: dummy_sp()};\n     // dtor has one argument, of type ()\n     {inputs: ~[{mode: ast::expl(ast::by_ref),\n-                ty: nil_t, ident: @~\"_\", id: 0}],\n+                ty: nil_t, ident: parse::token::special_idents::underscore,\n+                id: 0}],\n      output: nil_t, purity: impure_fn, cf: return_val}\n }\n "}, {"sha": "71fc7f94e362495fd379ebac0c72fa17477ebda4", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -49,23 +49,23 @@ export require_unique_names;\n \n /* Constructors */\n \n-fn mk_name_value_item_str(+name: ast::ident, +value: ~str) ->\n+fn mk_name_value_item_str(name: ~str, +value: ~str) ->\n     @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(@value));\n     return mk_name_value_item(name, value_lit);\n }\n \n-fn mk_name_value_item(+name: ast::ident, +value: ast::lit)\n+fn mk_name_value_item(name: ~str, +value: ast::lit)\n         -> @ast::meta_item {\n     return @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(+name: ast::ident, +items: ~[@ast::meta_item]) ->\n+fn mk_list_item(name: ~str, +items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n     return @dummy_spanned(ast::meta_list(name, items));\n }\n \n-fn mk_word_item(+name: ast::ident) -> @ast::meta_item {\n+fn mk_word_item(name: ~str) -> @ast::meta_item {\n     return @dummy_spanned(ast::meta_word(name));\n }\n \n@@ -78,7 +78,7 @@ fn mk_sugared_doc_attr(text: ~str, lo: uint, hi: uint) -> ast::attribute {\n     let lit = spanned(lo, hi, ast::lit_str(@text));\n     let attr = {\n         style: doc_comment_style(text),\n-        value: spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n+        value: spanned(lo, hi, ast::meta_name_value(~\"doc\", lit)),\n         is_sugared_doc: true\n     };\n     return spanned(lo, hi, attr);\n@@ -98,8 +98,8 @@ fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n fn desugar_doc_attr(attr: ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n-        let meta = mk_name_value_item_str(@~\"doc\",\n-                                     strip_doc_comment_decoration(*comment));\n+        let meta = mk_name_value_item_str(~\"doc\",\n+                                     strip_doc_comment_decoration(comment));\n         return mk_attr(meta);\n     } else {\n         attr\n@@ -108,30 +108,29 @@ fn desugar_doc_attr(attr: ast::attribute) -> ast::attribute {\n \n /* Accessors */\n \n-fn get_attr_name(attr: ast::attribute) -> ast::ident {\n+fn get_attr_name(attr: ast::attribute) -> ~str {\n     get_meta_item_name(@attr.node.value)\n }\n \n-// All \"bad\" FIXME copies are as per #2543\n-fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n+fn get_meta_item_name(meta: @ast::meta_item) -> ~str {\n     match meta.node {\n-      ast::meta_word(n) => /* FIXME (#2543) */ copy n,\n-      ast::meta_name_value(n, _) => /* FIXME (#2543) */ copy n,\n-      ast::meta_list(n, _) => /* FIXME (#2543) */ copy n\n+      ast::meta_word(n) => n,\n+      ast::meta_name_value(n, _) => n,\n+      ast::meta_list(n, _) => n\n     }\n }\n \n /**\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@~str> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> option<~str> {\n     match meta.node {\n-      ast::meta_name_value(_, v) => match v.node {\n-        ast::lit_str(s) => option::some(s),\n+        ast::meta_name_value(_, v) => match v.node {\n+            ast::lit_str(s) => option::some(*s),\n+            _ => option::none\n+        },\n         _ => option::none\n-      },\n-      _ => option::none\n     }\n }\n \n@@ -147,9 +146,7 @@ fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n  * If the meta item is a nam-value type with a string value then returns\n  * a tuple containing the name and string value, otherwise `none`\n  */\n-fn get_name_value_str_pair(\n-    item: @ast::meta_item\n-) -> option<(ast::ident, @~str)> {\n+fn get_name_value_str_pair(item: @ast::meta_item) -> option<(~str, ~str)> {\n     match attr::get_meta_item_value_str(item) {\n       some(value) => {\n         let name = attr::get_meta_item_name(item);\n@@ -163,11 +160,11 @@ fn get_name_value_str_pair(\n /* Searching */\n \n /// Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: ~[ast::attribute], +name: ~str) ->\n+fn find_attrs_by_name(attrs: ~[ast::attribute], name: ~str) ->\n    ~[ast::attribute] {\n     let filter = (\n         fn@(a: ast::attribute) -> option<ast::attribute> {\n-            if *get_attr_name(a) == name {\n+            if get_attr_name(a) == name {\n                 option::some(a)\n             } else { option::none }\n         }\n@@ -176,10 +173,10 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], +name: ~str) ->\n }\n \n /// Searcha list of meta items and return only those with a specific name\n-fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: ~str) ->\n+fn find_meta_items_by_name(metas: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n-        if *get_meta_item_name(m) == name {\n+        if get_meta_item_name(m) == name {\n             option::some(m)\n         } else { option::none }\n     };\n@@ -191,14 +188,9 @@ fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: ~str) ->\n  * comparison is performed structurally.\n  */\n fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n-    debug!{\"looking for %s\",\n-           print::pprust::meta_item_to_str(*needle)};\n     for haystack.each |item| {\n-        debug!{\"looking in %s\",\n-               print::pprust::meta_item_to_str(*item)};\n-        if eq(item, needle) { debug!{\"found it!\"}; return true; }\n+        if eq(item, needle) { return true; }\n     }\n-    #debug(\"found it not :(\");\n     return false;\n }\n \n@@ -223,36 +215,35 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains_name(metas: ~[@ast::meta_item], +name: ~str) -> bool {\n+fn contains_name(metas: ~[@ast::meta_item], name: ~str) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     return vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: ~[ast::attribute], +name: ~str) -> bool {\n+fn attrs_contains_name(attrs: ~[ast::attribute], name: ~str) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n \n-fn first_attr_value_str_by_name(attrs: ~[ast::attribute], +name: ~str)\n-    -> option<@~str> {\n+fn first_attr_value_str_by_name(attrs: ~[ast::attribute], name: ~str)\n+    -> option<~str> {\n+\n     let mattrs = find_attrs_by_name(attrs, name);\n     if vec::len(mattrs) > 0u {\n         return get_meta_item_value_str(attr_meta(mattrs[0]));\n     }\n     return option::none;\n }\n \n-fn last_meta_item_by_name(\n-    items: ~[@ast::meta_item],\n-    +name: ~str\n-) -> option<@ast::meta_item> {\n+fn last_meta_item_by_name(items: ~[@ast::meta_item], name: ~str)\n+    -> option<@ast::meta_item> {\n+\n     let items = attr::find_meta_items_by_name(items, name);\n     vec::last_opt(items)\n }\n \n-fn last_meta_item_value_str_by_name(\n-    items: ~[@ast::meta_item],\n-    +name: ~str\n-) -> option<@~str> {\n+fn last_meta_item_value_str_by_name(items: ~[@ast::meta_item], name: ~str)\n+    -> option<~str> {\n+\n     match last_meta_item_by_name(items, name) {\n       some(item) => match attr::get_meta_item_value_str(item) {\n         some(value) => some(value),\n@@ -262,10 +253,9 @@ fn last_meta_item_value_str_by_name(\n     }\n }\n \n-fn last_meta_item_list_by_name(\n-    items: ~[@ast::meta_item],\n-    +name: ~str\n-) -> option<~[@ast::meta_item]> {\n+fn last_meta_item_list_by_name(items: ~[@ast::meta_item], name: ~str)\n+    -> option<~[@ast::meta_item]> {\n+\n     match last_meta_item_by_name(items, name) {\n       some(item) => attr::get_meta_item_list(item),\n       none => none\n@@ -279,11 +269,11 @@ fn last_meta_item_list_by_name(\n // the item name (See [Fixme-sorting])\n fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     pure fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n-        pure fn key(m: &ast::meta_item) -> ast::ident {\n+        pure fn key(m: &ast::meta_item) -> ~str {\n             match m.node {\n-              ast::meta_word(name) => /* FIXME (#2543) */ copy name,\n-              ast::meta_name_value(name, _) => /* FIXME (#2543) */ copy name,\n-              ast::meta_list(name, _) => /* FIXME (#2543) */ copy name\n+              ast::meta_word(name) => name,\n+              ast::meta_name_value(name, _) => name,\n+              ast::meta_list(name, _) => name\n             }\n         }\n         key(*ma) <= key(*mb)\n@@ -295,7 +285,7 @@ fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     return vec::from_mut(v);\n }\n \n-fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ast::ident) ->\n+fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n \n     return vec::filter_map(items, |item| {\n@@ -335,17 +325,17 @@ fn foreign_abi(attrs: ~[ast::attribute]) -> Either<~str, ast::foreign_abi> {\n       option::none => {\n         either::Right(ast::foreign_abi_cdecl)\n       }\n-      option::some(@~\"rust-intrinsic\") => {\n+      option::some(~\"rust-intrinsic\") => {\n         either::Right(ast::foreign_abi_rust_intrinsic)\n       }\n-      option::some(@~\"cdecl\") => {\n+      option::some(~\"cdecl\") => {\n         either::Right(ast::foreign_abi_cdecl)\n       }\n-      option::some(@~\"stdcall\") => {\n+      option::some(~\"stdcall\") => {\n         either::Right(ast::foreign_abi_stdcall)\n       }\n       option::some(t) => {\n-        either::Left(~\"unsupported abi: \" + *t)\n+        either::Left(~\"unsupported abi: \" + t)\n       }\n     };\n }\n@@ -362,8 +352,8 @@ fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         match attr.node.value.node {\n-          ast::meta_word(@~\"inline\") => ia_hint,\n-          ast::meta_list(@~\"inline\", items) => {\n+          ast::meta_word(~\"inline\") => ia_hint,\n+          ast::meta_list(~\"inline\", items) => {\n             if !vec::is_empty(find_meta_items_by_name(items, ~\"always\")) {\n                 ia_always\n             } else if !vec::is_empty(\n@@ -386,11 +376,11 @@ fn require_unique_names(diagnostic: span_handler,\n         let name = get_meta_item_name(meta);\n \n         // FIXME: How do I silence the warnings? --pcw (#2619)\n-        if map.contains_key(*name) {\n+        if map.contains_key(name) {\n             diagnostic.span_fatal(meta.span,\n-                                  fmt!{\"duplicate meta item `%s`\", *name});\n+                                  fmt!{\"duplicate meta item `%s`\", name});\n         }\n-        map.insert(*name, ());\n+        map.insert(name, ());\n     }\n }\n "}, {"sha": "e5b65b41fc83d7c89380def3c58b3f4bbe7012be", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -84,15 +84,15 @@ mod syntax {\n     export parse;\n }\n \n-type ser_tps_map = map::hashmap<~str, fn@(@ast::expr) -> ~[@ast::stmt]>;\n-type deser_tps_map = map::hashmap<~str, fn@() -> @ast::expr>;\n+type ser_tps_map = map::hashmap<ast::ident, fn@(@ast::expr) -> ~[@ast::stmt]>;\n+type deser_tps_map = map::hashmap<ast::ident, fn@() -> @ast::expr>;\n \n fn expand(cx: ext_ctxt,\n           span: span,\n           _mitem: ast::meta_item,\n           in_items: ~[@ast::item]) -> ~[@ast::item] {\n     fn not_auto_serialize(a: ast::attribute) -> bool {\n-        attr::get_attr_name(a) != @~\"auto_serialize\"\n+        attr::get_attr_name(a) != ~\"auto_serialize\"\n     }\n \n     fn filter_attrs(item: @ast::item) -> @ast::item {\n@@ -156,7 +156,11 @@ impl ext_ctxt: ext_ctxt_helpers {\n         let head = vec::init(base_path.idents);\n         let tail = vec::last(base_path.idents);\n         self.path(base_path.span,\n-                  vec::append(head, ~[@(helper_name + ~\"_\" + *tail)]))\n+                  vec::append(head,\n+                              ~[self.parse_sess().interner.\n+                                intern(@(helper_name + ~\"_\" +\n+                                         *self.parse_sess().interner.get(\n+                                             tail)))]))\n     }\n \n     fn path(span: span, strs: ~[ast::ident]) -> @ast::path {\n@@ -181,7 +185,7 @@ impl ext_ctxt: ext_ctxt_helpers {\n         let args = do vec::map(input_tys) |ty| {\n             {mode: ast::expl(ast::by_ref),\n              ty: ty,\n-             ident: @~\"\",\n+             ident: parse::token::special_idents::invalid,\n              id: self.next_id()}\n         };\n \n@@ -352,7 +356,7 @@ fn ser_variant(cx: ext_ctxt,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n     let vnames = do vec::from_fn(vec::len(tys)) |i| {\n-        @fmt!{\"__v%u\", i}\n+        cx.parse_sess().interner.intern(@fmt!{\"__v%u\", i})\n     };\n     let pats = do vec::from_fn(vec::len(tys)) |i| {\n         cx.binder_pat(tys[i].span, vnames[i])\n@@ -384,7 +388,7 @@ fn is_vec_or_str(ty: @ast::ty) -> bool {\n       // This may be wrong if the user has shadowed (!) str\n       ast::ty_path(@{span: _, global: _, idents: ids,\n                              rp: none, types: _}, _)\n-      if ids == ~[@~\"str\"] => true,\n+      if ids == ~[parse::token::special_idents::str] => true,\n       _ => false\n     }\n }\n@@ -434,7 +438,8 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                                              fld.node.ident,\n                                              ~[]));\n             let s = cx.clone(s);\n-            let f = cx.lit_str(fld.span, fld.node.ident);\n+            let f = cx.lit_str(fld.span, cx.parse_sess().interner.get(\n+                fld.node.ident));\n             let i = cx.lit_uint(fld.span, fidx);\n             let l = ser_lambda(cx, tps, fld.node.mt.ty, cx.clone(s), vf);\n             #ast[stmt]{$(s).emit_rec_field($(f), $(i), $(l));}\n@@ -487,7 +492,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n-            match tps.find(*ident) {\n+            match tps.find(ident) {\n               some(f) => f(v),\n               none => ser_path(cx, tps, path, s, v)\n             }\n@@ -545,43 +550,44 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n              ty: cx.ty_fn(span,\n                           ~[cx.ty_path(span, ~[tp.ident], ~[])],\n                           cx.ty_nil(span)),\n-             ident: @(~\"__s\" + *tp.ident),\n+             ident: cx.ident_of(~\"__s\" + cx.str_of(tp.ident)),\n              id: cx.next_id()});\n \n     debug!{\"tp_inputs = %?\", tp_inputs};\n \n \n     let ser_inputs: ~[ast::arg] =\n         vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[@~\"__S\"], ~[]),\n-                      ident: @~\"__s\",\n+                      ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n+                      ident: cx.ident_of(~\"__s\"),\n                       id: cx.next_id()},\n                      {mode: ast::expl(ast::by_ref),\n                       ty: v_ty,\n-                      ident: @~\"__v\",\n+                      ident: cx.ident_of(~\"__v\"),\n                       id: cx.next_id()}],\n                     tp_inputs);\n \n-    let tps_map = map::str_hash();\n+    let tps_map = map::uint_hash();\n     do vec::iter2(tps, tp_inputs) |tp, arg| {\n         let arg_ident = arg.ident;\n         tps_map.insert(\n-            *tp.ident,\n+            tp.ident,\n             fn@(v: @ast::expr) -> ~[@ast::stmt] {\n                 let f = cx.var_ref(span, arg_ident);\n-                debug!{\"serializing type arg %s\", *arg_ident};\n+                debug!{\"serializing type arg %s\", cx.str_of(arg_ident)};\n                 ~[#ast[stmt]{$(f)($(v));}]\n             });\n     }\n \n     let ser_bnds = @~[\n         ast::bound_trait(cx.ty_path(span,\n-                                    ~[@~\"std\", @~\"serialization\",\n-                                     @~\"serializer\"],\n+                                    ~[cx.ident_of(~\"std\"),\n+                                      cx.ident_of(~\"serialization\"),\n+                                      cx.ident_of(~\"serializer\")],\n                                     ~[]))];\n \n     let ser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: @~\"__S\",\n+        vec::append(~[{ident: cx.ident_of(~\"__S\"),\n                       id: cx.next_id(),\n                       bounds: ser_bnds}],\n                     vec::map(tps, |tp| cx.clone_ty_param(tp)));\n@@ -593,7 +599,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n     let ser_blk = cx.blk(span,\n                          f(cx, tps_map, #ast{ __s }, #ast{ __v }));\n \n-    @{ident: @(~\"serialize_\" + *name),\n+    @{ident: cx.ident_of(~\"serialize_\" + cx.str_of(name)),\n       attrs: ~[],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: ser_inputs,\n@@ -670,7 +676,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         let fields = do vec::from_fn(vec::len(flds)) |fidx| {\n             let fld = flds[fidx];\n             let d = cx.clone(d);\n-            let f = cx.lit_str(fld.span, fld.node.ident);\n+            let f = cx.lit_str(fld.span, @cx.str_of(fld.node.ident));\n             let i = cx.lit_uint(fld.span, fidx);\n             let l = deser_lambda(cx, tps, fld.node.mt.ty, cx.clone(d));\n             {node: {mutbl: fld.node.mt.mutbl,\n@@ -713,7 +719,7 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n             vec::is_empty(path.types) {\n             let ident = path.idents[0];\n \n-            match tps.find(*ident) {\n+            match tps.find(ident) {\n               some(f) => f(),\n               none => deser_path(cx, tps, path, d)\n             }\n@@ -756,23 +762,23 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n              ty: cx.ty_fn(span,\n                           ~[],\n                           cx.ty_path(span, ~[tp.ident], ~[])),\n-             ident: @(~\"__d\" + *tp.ident),\n+             ident: cx.ident_of(~\"__d\" + cx.str_of(tp.ident)),\n              id: cx.next_id()});\n \n     debug!{\"tp_inputs = %?\", tp_inputs};\n \n     let deser_inputs: ~[ast::arg] =\n         vec::append(~[{mode: ast::expl(ast::by_ref),\n-                      ty: cx.ty_path(span, ~[@~\"__D\"], ~[]),\n-                      ident: @~\"__d\",\n+                      ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n+                      ident: cx.ident_of(~\"__d\"),\n                       id: cx.next_id()}],\n                     tp_inputs);\n \n-    let tps_map = map::str_hash();\n+    let tps_map = map::uint_hash();\n     do vec::iter2(tps, tp_inputs) |tp, arg| {\n         let arg_ident = arg.ident;\n         tps_map.insert(\n-            *tp.ident,\n+            tp.ident,\n             fn@() -> @ast::expr {\n                 let f = cx.var_ref(span, arg_ident);\n                 #ast{ $(f)() }\n@@ -782,11 +788,12 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n     let deser_bnds = @~[\n         ast::bound_trait(cx.ty_path(\n             span,\n-            ~[@~\"std\", @~\"serialization\", @~\"deserializer\"],\n+            ~[cx.ident_of(~\"std\"), cx.ident_of(~\"serialization\"),\n+              cx.ident_of(~\"deserializer\")],\n             ~[]))];\n \n     let deser_tps: ~[ast::ty_param] =\n-        vec::append(~[{ident: @~\"__D\",\n+        vec::append(~[{ident: cx.ident_of(~\"__D\"),\n                       id: cx.next_id(),\n                       bounds: deser_bnds}],\n                     vec::map(tps, |tp| {\n@@ -798,7 +805,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n \n     let deser_blk = cx.expr_blk(f(cx, tps_map, #ast[expr]{__d}));\n \n-    @{ident: @(~\"deserialize_\" + *name),\n+    @{ident: cx.ident_of(~\"deserialize_\" + cx.str_of(name)),\n       attrs: ~[],\n       id: cx.next_id(),\n       node: ast::item_fn({inputs: deser_inputs,\n@@ -853,7 +860,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n                     // Generate body s.emit_enum_variant(\"foo\", 0u,\n                     //                                   3u, {|| blk })\n                     |-s, blk| {\n-                        let v_name = cx.lit_str(v_span, v_name);\n+                        let v_name = cx.lit_str(v_span, @cx.str_of(v_name));\n                         let v_id = cx.lit_uint(v_span, vidx);\n                         let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n                         let body = cx.lambda(blk);\n@@ -877,7 +884,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n         }\n     };\n     let lam = cx.lambda(cx.blk(e_span, ~[cx.alt_stmt(arms, e_span, v)]));\n-    let e_name = cx.lit_str(e_span, e_name);\n+    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n     ~[#ast[stmt]{ $(s).emit_enum($(e_name), $(lam)) }]\n }\n \n@@ -935,7 +942,7 @@ fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,\n     arms += ~[impossible_case];\n \n     // Generate code like:\n-    let e_name = cx.lit_str(e_span, e_name);\n+    let e_name = cx.lit_str(e_span, @cx.str_of(e_name));\n     let alt_expr = cx.expr(e_span,\n                    ast::expr_match(#ast{__i}, arms, ast::alt_exhaustive));\n     let var_lambda = #ast{ |__i| $(alt_expr) };"}, {"sha": "bb8a845d731a0f75447b2923fafb7bfd19eb60f4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -23,7 +23,7 @@ type syntax_expander_ =\n // second argument is the origin of the macro, if user-defined\n type syntax_expander = {expander: syntax_expander_, span: option<span>};\n \n-type macro_def = {ident: ast::ident, ext: syntax_extension};\n+type macro_def = {name: ~str, ext: syntax_extension};\n \n // macro_definer is obsolete, remove when #old_macros go away.\n type macro_definer =\n@@ -141,6 +141,9 @@ trait ext_ctxt {\n     fn next_id() -> ast::node_id;\n     pure fn trace_macros() -> bool;\n     fn set_trace_macros(x: bool);\n+    /* for unhygienic identifier transformation */\n+    fn str_of(id: ast::ident) -> ~str;\n+    fn ident_of(st: ~str) -> ast::ident;\n }\n \n fn mk_ctxt(parse_sess: parse::parse_sess,\n@@ -211,6 +214,13 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn set_trace_macros(x: bool) {\n             self.trace_mac = x\n         }\n+\n+        fn str_of(id: ast::ident) -> ~str {\n+            *self.parse_sess.interner.get(id)\n+        }\n+        fn ident_of(st: ~str) -> ast::ident {\n+            self.parse_sess.interner.intern(@st)\n+        }\n     }\n     let imp : ctxt_repr = {\n         parse_sess: parse_sess,\n@@ -264,12 +274,12 @@ fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                   cx.span_fatal(sp, fmt!{\"#%s needs at least %u arguments.\",\n                                          name, min});\n                 }\n-                _ => return elts /* we're good */\n+                _ => return elts /* we are good */\n               }\n           }\n         _ => {\n             cx.span_fatal(sp, fmt!{\"#%s: malformed invocation\", name})\n-          }\n+        }\n       },\n       none => cx.span_fatal(sp, fmt!{\"#%s: missing arguments\", name})\n     }\n@@ -298,22 +308,24 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n     fn ms(m: matcher_) -> matcher {\n         {node: m, span: {lo: 0u, hi: 0u, expn_info: none}}\n     }\n+    let arg_nm = cx.parse_sess().interner.gensym(@~\"arg\");\n \n     let argument_gram = ~[ms(match_seq(~[\n-        ms(match_nonterminal(@~\"arg\",@~\"expr\", 0u))\n+        ms(match_nonterminal(arg_nm, parse::token::special_idents::expr, 0u))\n     ], some(parse::token::COMMA), true, 0u, 1u))];\n \n     let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                    cx.parse_sess().interner, none, arg);\n     let args =\n         match parse_or_else(cx.parse_sess(), cx.cfg(), arg_reader as reader,\n-                          argument_gram).get(@~\"arg\") {\n-          @matched_seq(s, _) => do s.map() |lf| {\n-            match lf {\n-              @matched_nonterminal(parse::token::nt_expr(arg)) => {\n-                arg /* whew! list of exprs, here we come! */\n-              }\n-              _ => fail ~\"badly-structured parse result\"\n+                          argument_gram).get(arg_nm) {\n+          @matched_seq(s, _) => {\n+            do s.map() |lf| {\n+                match lf {\n+                  @matched_nonterminal(parse::token::nt_expr(arg)) =>\n+                    arg, /* whew! list of exprs, here we come! */\n+                  _ => fail ~\"badly-structured parse result\"\n+                }\n             }\n           },\n           _ => fail ~\"badly-structured parse result\""}, {"sha": "b53a0439e59e968c007b8537c39c5200c9609610", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -3,14 +3,16 @@ import base::*;\n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args_no_max(cx,sp,arg,1u,~\"concat_idents\");\n-    let mut res = ~\"\";\n+    let mut res_str = ~\"\";\n     for args.each |e| {\n-        res += *expr_to_ident(cx, e, ~\"expected an ident\");\n+        res_str += *cx.parse_sess().interner.get(\n+            expr_to_ident(cx, e, ~\"expected an ident\"));\n     }\n+    let res = cx.parse_sess().interner.intern(@res_str);\n \n     return @{id: cx.next_id(),\n           callee_id: cx.next_id(),\n-          node: ast::expr_path(@{span: sp, global: false, idents: ~[@res],\n+          node: ast::expr_path(@{span: sp, global: false, idents: ~[res],\n                                  rp: none, types: ~[]}),\n           span: sp};\n }"}, {"sha": "fb083744321172bf6d94d1d9ec4f0c2a8a7381d3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -25,7 +25,9 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n             match mac.node {\n               mac_invoc(pth, args, body) => {\n                 assert (vec::len(pth.idents) > 0u);\n-                let extname = pth.idents[0];\n+                /* using idents and token::special_idents would make the\n+                the macro names be hygienic */\n+                let extname = cx.parse_sess().interner.get(pth.idents[0]);\n                 match exts.find(*extname) {\n                   none => {\n                     cx.span_fatal(pth.span,\n@@ -49,7 +51,7 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   some(macro_defining(ext)) => {\n                     let named_extension = ext(cx, mac.span, args, body);\n-                    exts.insert(*named_extension.ident, named_extension.ext);\n+                    exts.insert(named_extension.name, named_extension.ext);\n                     (ast::expr_rec(~[], none), s)\n                   }\n                   some(expr_tt(_)) => {\n@@ -68,7 +70,9 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n               // finished transitioning.\n               mac_invoc_tt(pth, tts) => {\n                 assert (vec::len(pth.idents) == 1u);\n-                let extname = pth.idents[0];\n+                /* using idents and token::special_idents would make the\n+                the macro names be hygienic */\n+                let extname = cx.parse_sess().interner.get(pth.idents[0]);\n                 match exts.find(*extname) {\n                   none => {\n                     cx.span_fatal(pth.span,\n@@ -146,7 +150,7 @@ fn expand_mod_items(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n               ast::meta_name_value(n, _) => n,\n               ast::meta_list(n, _) => n\n             };\n-            match exts.find(*mname) {\n+            match exts.find(mname) {\n               none | some(normal(_)) | some(macro_defining(_))\n               | some(expr_tt(_)) | some(item_tt(*)) => items,\n               some(item_decorator(dec_fn)) => {\n@@ -194,7 +198,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                    fld: ast_fold) -> option<@ast::item> {\n     match it.node {\n       item_mac({node: mac_invoc_tt(pth, tts), span}) => {\n-        let extname = pth.idents[0];\n+        let extname = cx.parse_sess().interner.get(pth.idents[0]);\n         match exts.find(*extname) {\n           none => {\n             cx.span_fatal(pth.span,\n@@ -211,7 +215,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n                                          ~\"expr macro in item position: \" +\n                                          *extname),\n               mr_def(mdef) => {\n-                exts.insert(*mdef.ident, mdef.ext);\n+                exts.insert(mdef.name, mdef.ext);\n                 none\n               }\n             };"}, {"sha": "9392ea5ad3c01e994a50f50fb03a5c9cc1fd4bbe", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -37,12 +37,13 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                   pieces: ~[piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(_cx: ext_ctxt, ident: ast::ident) -> ~[ast::ident] {\n-        return ~[@~\"extfmt\", @~\"rt\", ident];\n+    fn make_path_vec(_cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n+        let intr = _cx.parse_sess().interner;\n+        return ~[intr.intern(@~\"extfmt\"), intr.intern(@~\"rt\"),\n+                 intr.intern(ident)];\n     }\n-    fn make_rt_path_expr(cx: ext_ctxt, sp: span,\n-                         ident: ast::ident) -> @ast::expr {\n-        let path = make_path_vec(cx, ident);\n+    fn make_rt_path_expr(cx: ext_ctxt, sp: span, nm: @~str) -> @ast::expr {\n+        let path = make_path_vec(cx, nm);\n         return mk_path(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n@@ -94,11 +95,13 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n         fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n+            let intr = cx.parse_sess().interner;\n             return mk_rec_e(cx, sp,\n-                         ~[{ident: @~\"flags\", ex: flags_expr},\n-                          {ident: @~\"width\", ex: width_expr},\n-                          {ident: @~\"precision\", ex: precision_expr},\n-                          {ident: @~\"ty\", ex: ty_expr}]);\n+                         ~[{ident: intr.intern(@~\"flags\"), ex: flags_expr},\n+                           {ident: intr.intern(@~\"width\"), ex: width_expr},\n+                           {ident: intr.intern(@~\"precision\"),\n+                            ex: precision_expr},\n+                           {ident: intr.intern(@~\"ty\"), ex: ty_expr}]);\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n@@ -268,7 +271,10 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     }\n \n     let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);\n-    return mk_call(cx, fmt_sp, ~[@~\"str\", @~\"concat\"], ~[arg_vec]);\n+    return mk_call(cx, fmt_sp,\n+                   ~[cx.parse_sess().interner.intern(@~\"str\"),\n+                     cx.parse_sess().interner.intern(@~\"concat\")],\n+                   ~[arg_vec]);\n }\n //\n // Local Variables:"}, {"sha": "9daaf1645621a14349c7f6521a2c7b353659a79d", "filename": "src/libsyntax/ext/ident_to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fident_to_str.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -6,6 +6,6 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx,sp,arg,1u,option::some(1u),~\"ident_to_str\");\n \n-    return mk_uniq_str(cx, sp, *expr_to_ident(cx, args[0u],\n-                                           ~\"expected an ident\"));\n+    return mk_uniq_str(cx, sp, *cx.parse_sess().interner.get(\n+        expr_to_ident(cx, args[0u], ~\"expected an ident\")));\n }"}, {"sha": "61bb00fd6de8eaece1ab33f968712c5956f0d273", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -6,8 +6,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, tt: ~[ast::token_tree])\n \n     cx.print_backtrace();\n     io::stdout().write_line(\n-        print::pprust::unexpanded_tt_to_str(ast::tt_delim(tt),\n-                                            cx.parse_sess().interner));\n+        print::pprust::tt_to_str(ast::tt_delim(tt),cx.parse_sess().interner));\n \n     //trivial expression\n     return mr_expr(@{id: cx.next_id(), callee_id: cx.next_id(),"}, {"sha": "beda46a2c3b4e066e425f824054ad9d11feb05bb", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -54,7 +54,7 @@ fn expand_proto(cx: ext_ctxt, _sp: span, id: ast::ident,\n     let rdr = tt_rdr as reader;\n     let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n-    let proto = rust_parser.parse_proto(id);\n+    let proto = rust_parser.parse_proto(cx.str_of(id));\n \n     // check for errors\n     visit(proto, cx);"}, {"sha": "45873f81dead0b101a011d09fccbcbf46e4470f8", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -15,14 +15,10 @@ mod syntax {\n     export parse;\n }\n \n-fn ident(s: &str) -> ast::ident {\n-    @(s.to_unique())\n-}\n-\n-fn path(id: ident, span: span) -> @ast::path {\n+fn path(ids: ~[ident], span: span) -> @ast::path {\n     @{span: span,\n       global: false,\n-      idents: ~[id],\n+      idents: ids,\n       rp: none,\n       types: ~[]}\n }\n@@ -94,7 +90,8 @@ trait ext_ctxt_ast_builder {\n \n impl ext_ctxt: ext_ctxt_ast_builder {\n     fn ty_option(ty: @ast::ty) -> @ast::ty {\n-        self.ty_path_ast_builder(path(@~\"option\", self.empty_span())\n+        self.ty_path_ast_builder(path(~[self.ident_of(~\"option\")],\n+                                      self.empty_span())\n                                  .add_ty(ty))\n     }\n \n@@ -126,7 +123,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n                      ty: self.ty_infer(),\n                      pat: @{id: self.next_id(),\n                             node: ast::pat_ident(ast::bind_by_implicit_ref,\n-                                                 path(ident,\n+                                                 path(~[ident],\n                                                       self.empty_span()),\n                                                  none),\n                             span: self.empty_span()},\n@@ -301,6 +298,6 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n \n     fn ty_vars(+ty_params: ~[ast::ty_param]) -> ~[@ast::ty] {\n         ty_params.map(|p| self.ty_path_ast_builder(\n-            path(p.ident, self.empty_span())))\n+            path(~[p.ident], self.empty_span())))\n     }\n }"}, {"sha": "b7ad5c21bd93940ed57024700f66dab3cfe06054", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -21,8 +21,6 @@ that.\n \n import ext::base::ext_ctxt;\n \n-import ast::{ident};\n-\n import proto::{state, protocol, next_state};\n import ast_builder::empty_span;\n \n@@ -36,11 +34,11 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n                 state.span, // use a real span!\n                 fmt!{\"state %s contains no messages, \\\n                       consider stepping to a terminal state instead\",\n-                     *state.name})\n+                      state.name})\n         }\n     }\n \n-    fn visit_message(name: ident, _span: span, _tys: &[@ast::ty],\n+    fn visit_message(name: ~str, _span: span, _tys: &[@ast::ty],\n                      this: state, next: next_state) {\n         match next {\n           some({state: next, tys: next_tys}) => {\n@@ -51,7 +49,7 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n                 self.span_err(\n                     proto.get_state(next).span,\n                     fmt!{\"message %s steps to undefined state, %s\",\n-                         *name, *next});\n+                         name, next});\n             }\n             else {\n                 let next = proto.get_state(next);\n@@ -61,7 +59,7 @@ impl ext_ctxt: proto::visitor<(), (), ()>  {\n                         next.span, // use a real span\n                         fmt!{\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n-                             *name, *next.name,\n+                             name, next.name,\n                              next.ty_params.len(),\n                              next_tys.len()});\n                 }"}, {"sha": "2325e4ed27d58e14ad740235be97a819b19bfe6e", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -70,10 +70,10 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     }\n \n     if self_live.len() > 0 {\n-        let states = str::connect(self_live.map(|s| *s.name), ~\" \");\n+        let states = str::connect(self_live.map(|s| s.name), ~\" \");\n \n         debug!{\"protocol %s is unbounded due to loops involving: %s\",\n-               *proto.name, states};\n+               proto.name, states};\n \n         // Someday this will be configurable with a warning\n         //cx.span_warn(empty_span(),\n@@ -85,7 +85,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n         proto.bounded = some(false);\n     }\n     else {\n-        debug!{\"protocol %s is bounded. yay!\", *proto.name};\n+        debug!{\"protocol %s is bounded. yay!\", proto.name};\n         proto.bounded = some(true);\n     }\n }\n\\ No newline at end of file"}, {"sha": "4dc61e54aa4aef6067860c7399abddc6f03bdf17", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -1,18 +1,17 @@\n // Parsing pipes protocols from token trees.\n \n import parse::parser;\n-import ast::ident;\n import parse::token;\n \n import pipec::*;\n \n trait proto_parser {\n-    fn parse_proto(id: ident) -> protocol;\n+    fn parse_proto(id: ~str) -> protocol;\n     fn parse_state(proto: protocol);\n }\n \n impl parser: proto_parser {\n-    fn parse_proto(id: ident) -> protocol {\n+    fn parse_proto(id: ~str) -> protocol {\n         let proto = protocol(id, self.span);\n \n         self.parse_seq_to_before_end(token::EOF,\n@@ -24,9 +23,11 @@ impl parser: proto_parser {\n \n     fn parse_state(proto: protocol) {\n         let id = self.parse_ident();\n+        let name = *self.interner.get(id);\n+\n         self.expect(token::COLON);\n         let dir = match copy self.token {\n-          token::IDENT(n, _) => self.get_str(n),\n+          token::IDENT(n, _) => self.interner.get(n),\n           _ => fail\n         };\n         self.bump();\n@@ -41,7 +42,7 @@ impl parser: proto_parser {\n         }\n         else { ~[] };\n \n-        let state = proto.add_state_poly(id, dir, typarms);\n+        let state = proto.add_state_poly(name, id, dir, typarms);\n \n         // parse the messages\n         self.parse_unspanned_seq(\n@@ -51,7 +52,7 @@ impl parser: proto_parser {\n     }\n \n     fn parse_message(state: state) {\n-        let mname = self.parse_ident();\n+        let mname = *self.interner.get(self.parse_ident());\n \n         let args = if self.token == token::LPAREN {\n             self.parse_unspanned_seq(token::LPAREN,\n@@ -66,7 +67,7 @@ impl parser: proto_parser {\n \n         let next = match copy self.token {\n           token::IDENT(_, _) => {\n-            let name = self.parse_ident();\n+            let name = *self.interner.get(self.parse_ident());\n             let ntys = if self.token == token::LT {\n                 self.parse_unspanned_seq(token::LT,\n                                          token::GT,"}, {"sha": "b5a1ae588a72cb1be9be3387779b092b7396ee3e", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -13,8 +13,7 @@ import parse;\n import parse::*;\n import proto::*;\n \n-import ast_builder::append_types;\n-import ast_builder::path;\n+import ast_builder::{append_types, path, empty_span};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -47,17 +46,17 @@ impl message: gen_send {\n             debug!(\"pipec: next state exists\");\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n-            let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n+            let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n             let args_ast = (arg_names, tys).map(\n                 |n, t| cx.arg_mode(n, t, ast::by_copy)\n             );\n \n             let pipe_ty = cx.ty_path_ast_builder(\n-                path(this.data_name(), span)\n+                path(~[this.data_name()], span)\n                 .add_tys(cx.ty_vars(this.ty_params)));\n             let args_ast = vec::append(\n-                ~[cx.arg_mode(@~\"pipe\",\n+                ~[cx.arg_mode(cx.ident_of(~\"pipe\"),\n                               pipe_ty,\n                               ast::by_copy)],\n                 args_ast);\n@@ -75,10 +74,10 @@ impl message: gen_send {\n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n                 body += fmt!(\"let %s = pipes::send_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             sp, *next.name);\n-                body += fmt!(\"let %s = pipes::recv_packet_buffered(\\\n+                             sp, next.name);\n+                body += fmt!{\"let %s = pipes::recv_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             rp, *next.name);\n+                             rp, next.name};\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n@@ -91,10 +90,10 @@ impl message: gen_send {\n                 body += fmt!(\"let %s = pipes::entangle();\\n\", pat);\n             }\n             body += fmt!(\"let message = %s::%s(%s);\\n\",\n-                         *this.proto.name,\n-                         *self.name(),\n-                         str::connect(vec::append_one(arg_names, @~\"s\")\n-                                      .map(|x| *x),\n+                         this.proto.name,\n+                         self.name(),\n+                         str::connect(vec::append_one(\n+                             arg_names.map(|x| cx.str_of(x)), ~\"s\"),\n                                       ~\", \"));\n \n             if !try {\n@@ -110,17 +109,15 @@ impl message: gen_send {\n \n             let body = cx.parse_expr(body);\n \n-            let mut rty = cx.ty_path_ast_builder(path(next.data_name(),\n+            let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n                                                       span)\n                                                  .add_tys(next_tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n \n-            let name = if try {\n-                @(~\"try_\" + *self.name())\n-            }\n-            else { self.name() };\n+            let name = cx.ident_of(if try { ~\"try_\" + self.name()\n+                                          } else { self.name() } );\n \n             cx.item_fn_poly(name,\n                             args_ast,\n@@ -131,16 +128,16 @@ impl message: gen_send {\n \n             message(id, span, tys, this, none) => {\n                 debug!{\"pipec: no next state\"};\n-                let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n+                let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n                 let args_ast = (arg_names, tys).map(\n-                    |n, t| cx.arg_mode(n, t, ast::by_copy)\n+                    |n, t| cx.arg_mode(cx.ident_of(n), t, ast::by_copy)\n                 );\n \n                 let args_ast = vec::append(\n-                    ~[cx.arg_mode(@~\"pipe\",\n+                    ~[cx.arg_mode(cx.ident_of(~\"pipe\"),\n                                   cx.ty_path_ast_builder(\n-                                      path(this.data_name(), span)\n+                                      path(~[this.data_name()], span)\n                                       .add_tys(cx.ty_vars(this.ty_params))),\n                                   ast::by_copy)],\n                     args_ast);\n@@ -149,13 +146,13 @@ impl message: gen_send {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| *x), ~\", \") + ~\")\"\n+                    ~\"(\" + str::connect(arg_names, ~\", \") + ~\")\"\n                 };\n \n                 let mut body = ~\"{ \";\n                 body += fmt!{\"let message = %s::%s%s;\\n\",\n-                             *this.proto.name,\n-                             *self.name(),\n+                             this.proto.name,\n+                             self.name(),\n                              message_args};\n \n                 if !try {\n@@ -170,11 +167,11 @@ impl message: gen_send {\n                 let body = cx.parse_expr(body);\n \n                 let name = if try {\n-                    @(~\"try_\" + *self.name())\n+                    ~\"try_\" + self.name()\n                 }\n                 else { self.name() };\n \n-                cx.item_fn_poly(name,\n+                cx.item_fn_poly(cx.ident_of(name),\n                                 args_ast,\n                                 if try {\n                                     cx.ty_option(cx.ty_nil_ast_builder())\n@@ -188,7 +185,7 @@ impl message: gen_send {\n         }\n \n     fn to_ty(cx: ext_ctxt) -> @ast::ty {\n-        cx.ty_path_ast_builder(path(self.name(), self.span())\n+        cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars(self.get_params())))\n     }\n }\n@@ -212,21 +209,23 @@ impl state: to_type_decls {\n             let tys = match next {\n               some({state: next, tys: next_tys}) => {\n                 let next = this.proto.get_state(next);\n-                let next_name = next.data_name();\n+                let next_name = cx.str_of(next.data_name());\n \n                 let dir = match this.dir {\n-                  send => @~\"server\",\n-                  recv => @~\"client\"\n+                  send => ~\"server\",\n+                  recv => ~\"client\"\n                 };\n \n                 vec::append_one(tys,\n-                                cx.ty_path_ast_builder((dir + next_name)\n-                                           .add_tys(next_tys)))\n+                                cx.ty_path_ast_builder(\n+                                    path(~[cx.ident_of(dir),\n+                                           cx.ident_of(next_name)], span)\n+                                    .add_tys(next_tys)))\n               }\n               none => tys\n             };\n \n-            let v = cx.variant(name, span, tys);\n+            let v = cx.variant(cx.ident_of(name), span, tys);\n \n             vec::push(items_msg, v);\n         }\n@@ -258,9 +257,13 @@ impl state: to_type_decls {\n                           self.data_name(),\n                           self.span,\n                           cx.ty_path_ast_builder(\n-                              (@~\"pipes\" + @(dir.to_str() + ~\"_packet\"))\n+                              path(~[cx.ident_of(~\"pipes\"),\n+                                     cx.ident_of(dir.to_str() + ~\"_packet\")],\n+                                   empty_span())\n                               .add_ty(cx.ty_path_ast_builder(\n-                                  (self.proto.name + self.data_name())\n+                                  path(~[cx.ident_of(self.proto.name),\n+                                         self.data_name()],\n+                                       empty_span())\n                                   .add_tys(cx.ty_vars(self.ty_params))))),\n                           self.ty_params));\n         }\n@@ -270,10 +273,14 @@ impl state: to_type_decls {\n                           self.data_name(),\n                           self.span,\n                           cx.ty_path_ast_builder(\n-                              (@~\"pipes\" + @(dir.to_str()\n-                                             + ~\"_packet_buffered\"))\n+                              path(~[cx.ident_of(~\"pipes\"),\n+                                     cx.ident_of(dir.to_str()\n+                                                 + ~\"_packet_buffered\")],\n+                                  empty_span())\n                               .add_tys(~[cx.ty_path_ast_builder(\n-                                  (self.proto.name + self.data_name())\n+                                  path(~[cx.ident_of(self.proto.name),\n+                                         self.data_name()],\n+                                       empty_span())\n                                   .add_tys(cx.ty_vars(self.ty_params))),\n                                          self.proto.buffer_ty_path(cx)])),\n                           self.ty_params));\n@@ -315,16 +322,17 @@ impl protocol: gen_init {\n \n         cx.parse_item(fmt!{\"fn init%s() -> (client::%s, server::%s)\\\n                             { import pipes::has_buffer; %s }\",\n-                           start_state.ty_params.to_source(),\n-                           start_state.to_ty(cx).to_source(),\n-                           start_state.to_ty(cx).to_source(),\n-                           body.to_source()})\n+                           start_state.ty_params.to_source(cx),\n+                           start_state.to_ty(cx).to_source(cx),\n+                           start_state.to_ty(cx).to_source(cx),\n+                           body.to_source(cx)})\n     }\n \n     fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n         ext_cx.rec(self.states.map_to_vec(|s| {\n             let fty = s.to_ty(ext_cx);\n-            ext_cx.field_imm(s.name, #ast { pipes::mk_packet::<$(fty)>() })\n+            ext_cx.field_imm(ext_cx.ident_of(s.name),\n+                             #ast { pipes::mk_packet::<$(fty)>() })\n         }))\n     }\n \n@@ -341,9 +349,11 @@ impl protocol: gen_init {\n             ext_cx.block(\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n-                        fmt!{\"data.%s.set_buffer(buffer)\", *s.name})),\n+                        fmt!{\"data.%s.set_buffer(buffer)\",\n+                             s.name})),\n                 ext_cx.parse_expr(\n-                    fmt!{\"ptr::addr_of(data.%s)\", *self.states[0].name})));\n+                    fmt!{\"ptr::addr_of(data.%s)\",\n+                         self.states[0].name})));\n \n         #ast {{\n             let buffer = $(buffer);\n@@ -357,14 +367,14 @@ impl protocol: gen_init {\n         let mut params: ~[ast::ty_param] = ~[];\n         for (copy self.states).each |s| {\n             for s.ty_params.each |tp| {\n-                match params.find(|tpp| *tp.ident == *tpp.ident) {\n+                match params.find(|tpp| tp.ident == tpp.ident) {\n                   none => vec::push(params, tp),\n                   _ => ()\n                 }\n             }\n         }\n \n-        cx.ty_path_ast_builder(path(@~\"__Buffer\", self.span)\n+        cx.ty_path_ast_builder(path(~[cx.ident_of(~\"__Buffer\")], self.span)\n                                .add_tys(cx.ty_vars(params)))\n     }\n \n@@ -373,7 +383,7 @@ impl protocol: gen_init {\n         let mut params: ~[ast::ty_param] = ~[];\n         let fields = do (copy self.states).map_to_vec |s| {\n             for s.ty_params.each |tp| {\n-                match params.find(|tpp| *tp.ident == *tpp.ident) {\n+                match params.find(|tpp| tp.ident == tpp.ident) {\n                   none => vec::push(params, tp),\n                   _ => ()\n                 }\n@@ -382,11 +392,11 @@ impl protocol: gen_init {\n             let fty = #ast[ty] {\n                 pipes::packet<$(ty)>\n             };\n-            cx.ty_field_imm(s.name, fty)\n+            cx.ty_field_imm(cx.ident_of(s.name), fty)\n         };\n \n         cx.item_ty_poly(\n-            @~\"__Buffer\",\n+            cx.ident_of(~\"__Buffer\"),\n             cx.empty_span(),\n             cx.ty_rec(fields),\n             params)\n@@ -410,56 +420,56 @@ impl protocol: gen_init {\n         }\n \n         vec::push(items,\n-                  cx.item_mod(@~\"client\",\n+                  cx.item_mod(cx.ident_of(~\"client\"),\n                               self.span,\n                               client_states));\n         vec::push(items,\n-                  cx.item_mod(@~\"server\",\n+                  cx.item_mod(cx.ident_of(~\"server\"),\n                               self.span,\n                               server_states));\n \n-        cx.item_mod(self.name, self.span, items)\n+        cx.item_mod(cx.ident_of(self.name), self.span, items)\n     }\n }\n \n trait to_source {\n     // Takes a thing and generates a string containing rust code for it.\n-    fn to_source() -> ~str;\n+    fn to_source(cx: ext_ctxt) -> ~str;\n }\n \n impl @ast::item: to_source {\n-    fn to_source() -> ~str {\n-        item_to_str(self)\n+    fn to_source(cx: ext_ctxt) -> ~str {\n+        item_to_str(self, cx.parse_sess().interner)\n     }\n }\n \n impl ~[@ast::item]: to_source {\n-    fn to_source() -> ~str {\n-        str::connect(self.map(|i| i.to_source()), ~\"\\n\\n\")\n+    fn to_source(cx: ext_ctxt) -> ~str {\n+        str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n     }\n }\n \n impl @ast::ty: to_source {\n-    fn to_source() -> ~str {\n-        ty_to_str(self)\n+    fn to_source(cx: ext_ctxt) -> ~str {\n+        ty_to_str(self, cx.parse_sess().interner)\n     }\n }\n \n impl ~[@ast::ty]: to_source {\n-    fn to_source() -> ~str {\n-        str::connect(self.map(|i| i.to_source()), ~\", \")\n+    fn to_source(cx: ext_ctxt) -> ~str {\n+        str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n     }\n }\n \n impl ~[ast::ty_param]: to_source {\n-    fn to_source() -> ~str {\n-        pprust::typarams_to_str(self)\n+    fn to_source(cx: ext_ctxt) -> ~str {\n+        pprust::typarams_to_str(self, cx.parse_sess().interner)\n     }\n }\n \n impl @ast::expr: to_source {\n-    fn to_source() -> ~str {\n-        pprust::expr_to_str(self)\n+    fn to_source(cx: ext_ctxt) -> ~str {\n+        pprust::expr_to_str(self, cx.parse_sess().interner)\n     }\n }\n "}, {"sha": "62c5329525fecb68f07abe400511c2d51d5d3624", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -1,8 +1,6 @@\n import to_str::ToStr;\n import dvec::{DVec, dvec};\n \n-import ast::{ident};\n-\n import ast_builder::{path, append_types};\n \n enum direction {\n@@ -27,15 +25,15 @@ impl direction {\n     }\n }\n \n-type next_state = option<{state: ident, tys: ~[@ast::ty]}>;\n+type next_state = option<{state: ~str, tys: ~[@ast::ty]}>;\n \n enum message {\n     // name, span, data, current state, next state\n-    message(ident, span, ~[@ast::ty], state, next_state)\n+    message(~str, span, ~[@ast::ty], state, next_state)\n }\n \n impl message {\n-    fn name() -> ident {\n+    fn name() -> ~str {\n         match self {\n           message(id, _, _, _, _) => id\n         }\n@@ -58,7 +56,8 @@ impl message {\n enum state {\n     state_(@{\n         id: uint,\n-        name: ident,\n+        name: ~str,\n+        ident: ast::ident,\n         span: span,\n         dir: direction,\n         ty_params: ~[ast::ty_param],\n@@ -68,7 +67,7 @@ enum state {\n }\n \n impl state {\n-    fn add_message(name: ident, span: span,\n+    fn add_message(name: ~str, span: span,\n                    +data: ~[@ast::ty], next: next_state) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n@@ -78,14 +77,15 @@ impl state {\n         (*self).proto.filename()\n     }\n \n-    fn data_name() -> ident {\n-        self.name\n+    fn data_name() -> ast::ident {\n+        self.ident\n     }\n \n     /// Returns the type that is used for the messages.\n     fn to_ty(cx: ext_ctxt) -> @ast::ty {\n         cx.ty_path_ast_builder\n-            (path(self.name, self.span).add_tys(cx.ty_vars(self.ty_params)))\n+            (path(~[cx.ident_of(self.name)],self.span).add_tys(\n+                cx.ty_vars(self.ty_params)))\n     }\n \n     /// Iterate over the states that can be reached in one message\n@@ -105,37 +105,37 @@ impl state {\n \n type protocol = @protocol_;\n \n-fn protocol(name: ident, +span: span) -> protocol {\n+fn protocol(name: ~str, +span: span) -> protocol {\n     @protocol_(name, span)\n }\n \n struct protocol_ {\n-    let name: ident;\n+    let name: ~str;\n     let span: span;\n     let states: DVec<state>;\n \n     let mut bounded: option<bool>;\n \n-    new(name: ident, span: span) {\n+    new(name: ~str, span: span) {\n         self.name = name;\n         self.span = span;\n         self.states = dvec();\n         self.bounded = none;\n     }\n \n     /// Get a state.\n-    fn get_state(name: ident) -> state {\n+    fn get_state(name: ~str) -> state {\n         self.states.find(|i| i.name == name).get()\n     }\n \n     fn get_state_by_id(id: uint) -> state { self.states[id] }\n \n-    fn has_state(name: ident) -> bool {\n+    fn has_state(name: ~str) -> bool {\n         self.states.find(|i| i.name == name) != none\n     }\n \n     fn filename() -> ~str {\n-        ~\"proto://\" + *self.name\n+        ~\"proto://\" + self.name\n     }\n \n     fn num_states() -> uint { self.states.len() }\n@@ -162,17 +162,14 @@ struct protocol_ {\n }\n \n impl protocol {\n-    fn add_state(name: ident, dir: direction) -> state {\n-        self.add_state_poly(name, dir, ~[])\n-    }\n-\n-    fn add_state_poly(name: ident, dir: direction,\n+    fn add_state_poly(name: ~str, ident: ast::ident, dir: direction,\n                       +ty_params: ~[ast::ty_param]) -> state {\n         let messages = dvec();\n \n         let state = state_(@{\n             id: self.states.len(),\n             name: name,\n+            ident: ident,\n             span: self.span,\n             dir: dir,\n             ty_params: ty_params,\n@@ -188,7 +185,7 @@ impl protocol {\n trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(name: ident, spane: span, tys: &[@ast::ty],\n+    fn visit_message(name: ~str, spane: span, tys: &[@ast::ty],\n                      this: state, next: next_state) -> Tmessage;\n }\n "}, {"sha": "8024f5f9542d092fa2a6a8e5be77b3462b4dd6d5", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -3,6 +3,7 @@ import ast::{crate, expr_, mac_invoc,\n import parse::parser;\n import parse::parser::parse_from_source_str;\n import dvec::{DVec, dvec};\n+import parse::token::ident_interner;\n \n import fold::*;\n import visit::*;\n@@ -26,6 +27,14 @@ enum fragment {\n     from_ty(@ast::ty)\n }\n \n+fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n+    strs.map(|str| cx.parse_sess().interner.intern(@str))\n+}\n+fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n+    cx.parse_sess().interner.intern(@str)\n+}\n+\n+\n trait qq_helper {\n     fn span() -> span;\n     fn visit(aq_ctxt, vt<aq_ctxt>);\n@@ -40,7 +49,7 @@ impl @ast::crate: qq_helper {\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n-                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_crate\"])\n+                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_crate\"]))\n     }\n     fn get_fold_fn() -> ~str {~\"fold_crate\"}\n }\n@@ -55,7 +64,7 @@ impl @ast::expr: qq_helper {\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n-                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_expr\"])\n+                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_expr\"]))\n     }\n     fn get_fold_fn() -> ~str {~\"fold_expr\"}\n }\n@@ -70,7 +79,7 @@ impl @ast::ty: qq_helper {\n     }\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n-                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_ty\"])\n+                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_ty\"]))\n     }\n     fn get_fold_fn() -> ~str {~\"fold_ty\"}\n }\n@@ -80,7 +89,7 @@ impl @ast::item: qq_helper {\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n-                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_item\"])\n+                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_item\"]))\n     }\n     fn get_fold_fn() -> ~str {~\"fold_item\"}\n }\n@@ -90,7 +99,7 @@ impl @ast::stmt: qq_helper {\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n         mk_path(cx, sp,\n-                ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_stmt\"])\n+                ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\", ~\"parse_stmt\"]))\n     }\n     fn get_fold_fn() -> ~str {~\"fold_stmt\"}\n }\n@@ -99,7 +108,8 @@ impl @ast::pat: qq_helper {\n     fn visit(cx: aq_ctxt, v: vt<aq_ctxt>) {visit_pat(self, cx, v);}\n     fn extract_mac() -> option<ast::mac_> {fail}\n     fn mk_parse_fn(cx: ext_ctxt, sp: span) -> @ast::expr {\n-        mk_path(cx, sp, ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"parse_pat\"])\n+        mk_path(cx, sp, ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n+                                      ~\"parse_pat\"]))\n     }\n     fn get_fold_fn() -> ~str {~\"fold_pat\"}\n }\n@@ -159,7 +169,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n         }\n         match (args[0].node) {\n           ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n-          => what = *id[0],\n+            => what = *ecx.parse_sess().interner.get(id[0]),\n           _ => ecx.span_fatal(args[0].span, ~\"expected an identifier\")\n         }\n     }\n@@ -243,19 +253,21 @@ fn finish<T: qq_helper>\n     let cx = ecx;\n \n     let cfg_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ~[@~\"ext_cx\"], @~\"cfg\"), ~[]);\n+        cx, sp, mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n+                          id_ext(cx, ~\"cfg\")), ~[]);\n \n     let parse_sess_call = || mk_call_(\n-        cx, sp, mk_access(cx, sp, ~[@~\"ext_cx\"], @~\"parse_sess\"), ~[]);\n+        cx, sp, mk_access(cx, sp, ids_ext(cx, ~[~\"ext_cx\"]),\n+                          id_ext(cx, ~\"parse_sess\")), ~[]);\n \n     let pcall = mk_call(cx,sp,\n-                       ~[@~\"syntax\", @~\"parse\", @~\"parser\",\n-                        @~\"parse_from_source_str\"],\n+                       ids_ext(cx, ~[~\"syntax\", ~\"parse\", ~\"parser\",\n+                        ~\"parse_from_source_str\"]),\n                        ~[node.mk_parse_fn(cx,sp),\n                         mk_uniq_str(cx,sp, fname),\n                         mk_call(cx,sp,\n-                                ~[@~\"syntax\",@~\"ext\",\n-                                 @~\"qquote\", @~\"mk_file_substr\"],\n+                                ids_ext(cx, ~[~\"syntax\",~\"ext\",\n+                                 ~\"qquote\", ~\"mk_file_substr\"]),\n                                 ~[mk_uniq_str(cx,sp, loc.file.name),\n                                  mk_uint(cx,sp, loc.line),\n                                  mk_uint(cx,sp, loc.col)]),\n@@ -267,16 +279,17 @@ fn finish<T: qq_helper>\n     let mut rcall = pcall;\n     if (g_len > 0u) {\n         rcall = mk_call(cx,sp,\n-                        ~[@~\"syntax\", @~\"ext\", @~\"qquote\", @~\"replace\"],\n+                        ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n+                                      ~\"replace\"]),\n                         ~[pcall,\n                           mk_uniq_vec_e(cx,sp, qcx.gather.map_to_vec(|g| {\n                              mk_call(cx,sp,\n-                                     ~[@~\"syntax\", @~\"ext\",\n-                                      @~\"qquote\", @g.constr],\n+                                     ids_ext(cx, ~[~\"syntax\", ~\"ext\",\n+                                                   ~\"qquote\", g.constr]),\n                                      ~[g.e])})),\n                          mk_path(cx,sp,\n-                                 ~[@~\"syntax\", @~\"ext\", @~\"qquote\",\n-                                  @node.get_fold_fn()])]);\n+                                 ids_ext(cx, ~[~\"syntax\", ~\"ext\", ~\"qquote\",\n+                                               node.get_fold_fn()]))]);\n     }\n     return rcall;\n }\n@@ -331,14 +344,6 @@ fn replace_ty(repls: ~[fragment],\n     }\n }\n \n-fn print_expr(expr: @ast::expr) {\n-    let stdout = io::stdout();\n-    let pp = pprust::rust_printer(stdout);\n-    pprust::print_expr(pp, expr);\n-    pp::eof(pp.s);\n-    stdout.write_str(~\"\\n\");\n-}\n-\n fn mk_file_substr(fname: ~str, line: uint, col: uint) ->\n     codemap::file_substr {\n     codemap::fss_external({filename: fname, line: line, col: col})"}, {"sha": "5b9bac1948f091c42c8b8f9bd22e208598be0cff", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -1,5 +1,5 @@\n import codemap::span;\n-import std::map::{hashmap, str_hash, box_str_hash};\n+import std::map::{hashmap, str_hash, uint_hash};\n import dvec::{DVec, dvec};\n \n import base::*;\n@@ -135,7 +135,7 @@ fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n \n fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n-        {real_binders: box_str_hash::<selector>(),\n+        {real_binders: uint_hash::<selector>(),\n          literal_ast_matchers: dvec()};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n@@ -153,7 +153,7 @@ bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n-    let res = box_str_hash::<arb_depth<matchable>>();\n+    let res = uint_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for b.literal_ast_matchers.each |sel| {\n         match sel(match_expr(e)) { none => return none, _ => () }\n@@ -237,7 +237,7 @@ fn follow_for_trans(cx: ext_ctxt, mmaybe: option<arb_depth<matchable>>,\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n-    let idents: hashmap<ident, ()> = box_str_hash::<()>();\n+    let idents: hashmap<ident, ()> = uint_hash::<()>();\n     fn mark_ident(&&i: ident, _fld: ast_fold, b: bindings,\n                   idents: hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }\n@@ -253,6 +253,12 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n     for idents.each_key |x| { it(x); };\n }\n \n+fn wrong_occurs(cx: ext_ctxt, l: ident, l_c: uint, r: ident, r_c: uint)\n+    -> ~str {\n+    fmt!{\"'%s' occurs %u times, but '%s' occurs %u times\",\n+         *cx.parse_sess().interner.get(l), l_c,\n+         *cx.parse_sess().interner.get(r), r_c}\n+}\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n@@ -279,10 +285,8 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                       some({rep_count: old_len, name: old_name}) => {\n                         let len = vec::len(*ms);\n                         if old_len != len {\n-                            let msg =\n-                                fmt!{\"'%s' occurs %u times, but \", *fv, len} +\n-                                    fmt!{\"'%s' occurs %u times\", *old_name,\n-                                         old_len};\n+                            let msg = wrong_occurs(cx, fv, len,\n+                                                   old_name, old_len);\n                             cx.span_fatal(repeat_me.span, msg);\n                         }\n                       }\n@@ -626,7 +630,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                      _body: ast::mac_body) -> base::macro_def {\n     let args = get_mac_args_no_max(cx, sp, arg, 0u, ~\"macro\");\n \n-    let mut macro_name: option<@~str> = none;\n+    let mut macro_name: option<~str> = none;\n     let mut clauses: ~[@clause] = ~[];\n     for args.each |arg| {\n         match arg.node {\n@@ -643,12 +647,15 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                 match mac.node {\n                   mac_invoc(pth, invoc_arg, body) => {\n                     match path_to_ident(pth) {\n-                      some(id) => match macro_name {\n-                        none => macro_name = some(id),\n-                        some(other_id) => if id != other_id {\n+                      some(id) => {\n+                        let id_str = cx.str_of(id);\n+                        match macro_name {\n+                          none => macro_name = some(id_str),\n+                          some(other_id) => if id_str != other_id {\n                             cx.span_fatal(pth.span,\n                                           ~\"macro name must be \" +\n                                           ~\"consistent\");\n+                          }\n                         }\n                       },\n                       none => cx.span_fatal(pth.span,\n@@ -688,7 +695,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n \n     let ext = |a,b,c,d, move clauses| generic_extension(a,b,c,d,clauses);\n \n-    return {ident:\n+    return {name:\n              match macro_name {\n                some(id) => id,\n                none => cx.span_fatal(sp, ~\"macro definition must have \" +"}, {"sha": "c323f201b8323d6b4f6d0e4afb84f5f41217c790", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -43,14 +43,15 @@ fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n fn expand_stringify(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                     _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::some(1u), ~\"stringify\");\n-    return mk_uniq_str(cx, sp, pprust::expr_to_str(args[0]));\n+    let s = pprust::expr_to_str(args[0], cx.parse_sess().interner);\n+    return mk_uniq_str(cx, sp, s);\n }\n \n fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"file\");\n     return mk_uniq_str(cx, sp,\n-                    str::connect(cx.mod_path().map(|x|*x), ~\"::\"));\n+                    str::connect(cx.mod_path().map(|x| cx.str_of(x)), ~\"::\"));\n }\n \n fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,"}, {"sha": "22f0aeaa2c0c8e270c714582d100ae48c11c4bbb", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -15,10 +15,10 @@ fn expand_trace_macros(cx: ext_ctxt, sp: span,\n     let rdr = tt_rdr as reader;\n     let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);\n \n-    let arg = rust_parser.parse_ident();\n+    let arg = cx.str_of(rust_parser.parse_ident());\n     match arg {\n-      @~\"true\"  => cx.set_trace_macros(true),\n-      @~\"false\" => cx.set_trace_macros(false),\n+      ~\"true\"  => cx.set_trace_macros(true),\n+      ~\"false\" => cx.set_trace_macros(false),\n       _ => cx.span_fatal(sp, ~\"trace_macros! only accepts `true` or `false`\")\n     }\n     let rust_parser = parser(sess, cfg, rdr.dup(), SOURCE_FILE);"}, {"sha": "896b6f6e54fc6a2f39a852fe5215ae6f75b7f2e6", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -10,7 +10,7 @@ import parse::parse_sess;\n import dvec::{DVec, dvec};\n import ast::{matcher, match_tok, match_seq, match_nonterminal, ident};\n import ast_util::mk_sp;\n-import std::map::{hashmap, box_str_hash};\n+import std::map::{hashmap, uint_hash};\n \n /* This is an Earley-like parser, without support for in-grammar nonterminals,\n onlyl calling out to the main rust parser for named nonterminals (which it\n@@ -120,14 +120,14 @@ fn nameize(p_s: parse_sess, ms: ~[matcher], res: ~[@named_match])\n           }\n           {node: match_nonterminal(bind_name, _, idx), span: sp} => {\n             if ret_val.contains_key(bind_name) {\n-                p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"\n-                                               + *bind_name)\n+                p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n+                                               *p_s.interner.get(bind_name))\n             }\n             ret_val.insert(bind_name, res[idx]);\n           }\n         }\n     }\n-    let ret_val = box_str_hash::<@named_match>();\n+    let ret_val = uint_hash::<@named_match>();\n     for ms.each() |m| { n_rec(p_s, m, res, ret_val) }\n     return ret_val;\n }\n@@ -274,7 +274,8 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     match ei.elts[ei.idx].node {\n                       match_nonterminal(bind,name,_) => {\n-                        fmt!{\"%s ('%s')\", *name, *bind}\n+                        fmt!{\"%s ('%s')\", *sess.interner.get(name),\n+                             *sess.interner.get(bind)}\n                       }\n                       _ => fail\n                     } }), ~\" or \");\n@@ -298,7 +299,7 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(rust_parser, *name)));\n+                        parse_nt(rust_parser, *sess.interner.get(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail"}, {"sha": "be7594ff843390c2cf5845ff1ffa5b6e96cd0b5b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -8,6 +8,7 @@ import parse::parser::{parser, SOURCE_FILE};\n import earley_parser::{parse, parse_or_else, success, failure, named_match,\n                        matched_seq, matched_nonterminal, error};\n import std::map::hashmap;\n+import parse::token::special_idents;\n \n fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                      arg: ~[ast::token_tree]) -> base::mac_result {\n@@ -16,14 +17,17 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         {node: m, span: {lo: 0u, hi: 0u, expn_info: none}}\n     }\n \n+    let lhs_nm =  cx.parse_sess().interner.gensym(@~\"lhs\");\n+    let rhs_nm =  cx.parse_sess().interner.gensym(@~\"rhs\");\n+\n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     let argument_gram = ~[\n         ms(match_seq(~[\n-            ms(match_nonterminal(@~\"lhs\",@~\"matchers\", 0u)),\n+            ms(match_nonterminal(lhs_nm, special_idents::matchers, 0u)),\n             ms(match_tok(FAT_ARROW)),\n-            ms(match_nonterminal(@~\"rhs\",@~\"tt\", 1u)),\n+            ms(match_nonterminal(rhs_nm, special_idents::tt, 1u)),\n         ], some(SEMI), false, 0u, 2u)),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n@@ -37,11 +41,11 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                      arg_reader as reader, argument_gram);\n \n     // Extract the arguments:\n-    let lhses:~[@named_match] = match argument_map.get(@~\"lhs\") {\n+    let lhses:~[@named_match] = match argument_map.get(lhs_nm) {\n       @matched_seq(s, sp) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n-    let rhses:~[@named_match] = match argument_map.get(@~\"rhs\") {\n+    let rhses:~[@named_match] = match argument_map.get(rhs_nm) {\n       @matched_seq(s, sp) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n@@ -53,8 +57,9 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n     -> mac_result {\n \n         if cx.trace_macros() {\n-            io::println(fmt!(\"%s! { %s }\", *name,\n-                             print::pprust::unexpanded_tt_to_str(\n+            io::println(fmt!(\"%s! { %s }\",\n+                             cx.str_of(name),\n+                             print::pprust::tt_to_str(\n                                  ast::tt_delim(arg),\n                                  cx.parse_sess().interner)));\n         }\n@@ -103,7 +108,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                               arg, lhses, rhses);\n \n     return mr_def({\n-        ident: name,\n+        name: *cx.parse_sess().interner.get(name),\n         ext: expr_tt({expander: exp, span: some(sp)})\n     });\n }\n\\ No newline at end of file"}, {"sha": "1653c57bf2cf36c99438cc16fd2a532b52826dad", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -47,7 +47,7 @@ fn new_tt_reader(sp_diag: span_handler, itr: ident_interner,\n               mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n                          sep: none, up: tt_frame_up(option::none)},\n               interpolations: match interp { /* just a convienience */\n-                none => std::map::box_str_hash::<@named_match>(),\n+                none => std::map::uint_hash::<@named_match>(),\n                 some(x) => x\n               },\n               mut repeat_idx: ~[mut], mut repeat_len: ~[],\n@@ -100,8 +100,8 @@ enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n-fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n-    fn lis_merge(lhs: lis, rhs: lis) -> lis {\n+fn lockstep_iter_size(t: token_tree, r: tt_reader) -> lis {\n+    fn lis_merge(lhs: lis, rhs: lis, r: tt_reader) -> lis {\n         match lhs {\n           lis_unconstrained => rhs,\n           lis_contradiction(_) => lhs,\n@@ -110,17 +110,19 @@ fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n             lis_contradiction(_) => rhs,\n             lis_constraint(r_len, _) if l_len == r_len => lhs,\n             lis_constraint(r_len, r_id) => {\n+                let l_n = *r.interner.get(l_id);\n+                let r_n = *r.interner.get(r_id);\n                 lis_contradiction(fmt!{\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n-                                        *l_id, l_len, *r_id, r_len})\n+                                        l_n, l_len, r_n, r_len})\n             }\n           }\n         }\n     }\n     match t {\n       tt_delim(tts) | tt_seq(_, tts, _, _) => {\n         vec::foldl(lis_unconstrained, tts, {|lis, tt|\n-            lis_merge(lis, lockstep_iter_size(tt, r)) })\n+            lis_merge(lis, lockstep_iter_size(tt, r), r) })\n       }\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n@@ -230,7 +232,7 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n                     fmt!{\"variable '%s' is still repeating at this depth\",\n-                         *ident});\n+                         *r.interner.get(ident)});\n               }\n             }\n           }"}, {"sha": "05191c677a099a9befc3d215104117048edef4f8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -81,15 +81,14 @@ type ast_fold_precursor = @{\n fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n     return @{node:\n               match mi.node {\n-                meta_word(id) => meta_word(fld.fold_ident(id)),\n+                meta_word(id) => meta_word(id),\n                 meta_list(id, mis) => {\n                   let fold_meta_item = |x|fold_meta_item_(x, fld);\n                   meta_list(/* FIXME: (#2543) */ copy id,\n                             vec::map(mis, fold_meta_item))\n                 }\n                 meta_name_value(id, s) => {\n-                  meta_name_value(fld.fold_ident(id),\n-                                  /* FIXME (#2543) */ copy s)\n+                  meta_name_value(id, /* FIXME (#2543) */ copy s)\n                 }\n               },\n           span: fld.new_span(mi.span)};"}, {"sha": "54b0e3388f701bd8c13590df8eb58c47207475bf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -66,7 +66,7 @@ impl parser: parser_attr {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                        *self.get_str(s), self.span.lo, self.span.hi);\n+                        *self.id_to_str(s), self.span.lo, self.span.hi);\n                 if attr.node.style != ast::attr_outer {\n                   self.fatal(~\"expected outer comment\");\n                 }\n@@ -128,7 +128,7 @@ impl parser: parser_attr {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                        *self.get_str(s), self.span.lo, self.span.hi);\n+                        *self.id_to_str(s), self.span.lo, self.span.hi);\n                 self.bump();\n                 if attr.node.style == ast::attr_inner {\n                   inner_attrs += ~[attr];\n@@ -145,22 +145,22 @@ impl parser: parser_attr {\n \n     fn parse_meta_item() -> @ast::meta_item {\n         let lo = self.span.lo;\n-        let ident = self.parse_ident();\n+        let name = *self.id_to_str(self.parse_ident());\n         match self.token {\n           token::EQ => {\n             self.bump();\n             let lit = self.parse_lit();\n             let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_name_value(ident, lit));\n+            return @spanned(lo, hi, ast::meta_name_value(name, lit));\n           }\n           token::LPAREN => {\n             let inner_items = self.parse_meta_seq();\n             let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_list(ident, inner_items));\n+            return @spanned(lo, hi, ast::meta_list(name, inner_items));\n           }\n           _ => {\n             let mut hi = self.span.hi;\n-            return @spanned(lo, hi, ast::meta_word(ident));\n+            return @spanned(lo, hi, ast::meta_word(name));\n           }\n         }\n     }"}, {"sha": "09edbda4335d5af1c8cfda901d95f67d4548ec8c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -276,7 +276,7 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n                                 srdr: io::Reader) ->\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n-    let itr = parse::token::mk_ident_interner();\n+    let itr = parse::token::mk_fake_ident_interner();\n     let rdr = lexer::new_low_level_string_reader\n         (span_diagnostic, codemap::new_filemap(path, src, 0u, 0u), itr);\n "}, {"sha": "1d260268d3f6b1364a19136d5060c65962f38378", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -85,7 +85,7 @@ impl parser: parser_common {\n \n     fn parse_ident() -> ast::ident {\n         match copy self.token {\n-          token::IDENT(i, _) => { self.bump(); return self.get_str(i); }\n+          token::IDENT(i, _) => { self.bump(); return i; }\n           token::INTERPOLATED(token::nt_ident(*)) => { self.bug(\n               ~\"ident interpolation not converted to real token\"); }\n           _ => { self.fatal(~\"expected ident, found `\"\n@@ -110,6 +110,8 @@ impl parser: parser_common {\n         return if self.token == tok { self.bump(); true } else { false };\n     }\n \n+    // Storing keywords as interned idents instead of strings would be nifty.\n+\n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(word: ~str) {\n         if !self.keywords.contains_key_ref(&word) {\n@@ -119,7 +121,7 @@ impl parser: parser_common {\n \n     fn token_is_word(word: ~str, ++tok: token::token) -> bool {\n         match tok {\n-          token::IDENT(sid, false) => { word == *self.get_str(sid) }\n+          token::IDENT(sid, false) => { *self.id_to_str(sid) == word }\n           _ => { false }\n         }\n     }\n@@ -136,7 +138,7 @@ impl parser: parser_common {\n     fn is_any_keyword(tok: token::token) -> bool {\n         match tok {\n           token::IDENT(sid, false) => {\n-            self.keywords.contains_key_ref(self.get_str(sid))\n+            self.keywords.contains_key_ref(self.id_to_str(sid))\n           }\n           _ => false\n         }\n@@ -148,7 +150,7 @@ impl parser: parser_common {\n         let mut bump = false;\n         let val = match self.token {\n           token::IDENT(sid, false) => {\n-            if word == *self.get_str(sid) {\n+            if word == *self.id_to_str(sid) {\n                 bump = true;\n                 true\n             } else { false }"}, {"sha": "60d2fadb04ce0ae883a27cfacba0ab184b249680", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -78,10 +78,10 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     }\n }\n \n-fn cdir_path_opt(id: ast::ident, attrs: ~[ast::attribute]) -> @~str {\n+fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n     match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-      some(d) => return d,\n-      none => return id\n+      some(d) => d,\n+      none => default\n     }\n }\n \n@@ -90,11 +90,12 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n                         &items: ~[@ast::item]) {\n     match cdir.node {\n       ast::cdir_src_mod(id, attrs) => {\n-        let file_path = cdir_path_opt(@(*id + ~\".rs\"), attrs);\n+        let file_path = cdir_path_opt((cx.sess.interner.get(id) + ~\".rs\"),\n+                                      attrs);\n         let full_path =\n-            if path::path_is_absolute(*file_path) {\n-                *file_path\n-            } else { prefix + path::path_sep() + *file_path };\n+            if path::path_is_absolute(file_path) {\n+                file_path\n+            } else { prefix + path::path_sep() + file_path };\n         let (p0, r0) =\n             new_parser_etc_from_file(cx.sess, cx.cfg, full_path, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n@@ -111,11 +112,11 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: ~str,\n         vec::push(items, i);\n       }\n       ast::cdir_dir_mod(id, cdirs, attrs) => {\n-        let path = cdir_path_opt(id, attrs);\n+        let path = cdir_path_opt(*cx.sess.interner.get(id), attrs);\n         let full_path =\n-            if path::path_is_absolute(*path) {\n-                *path\n-            } else { prefix + path::path_sep() + *path };\n+            if path::path_is_absolute(path) {\n+                path\n+            } else { prefix + path::path_sep() + path };\n         let (m0, a0) = eval_crate_directives_to_mod(\n             cx, cdirs, full_path, none);\n         let i ="}, {"sha": "fea79309c21a0551ffe4e244b9cb6ad2e3bef386", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -6,7 +6,7 @@ import std::map::{hashmap, str_hash};\n import token::{can_begin_expr, is_ident, is_ident_or_path, is_plain_ident,\n                INTERPOLATED};\n import codemap::{span,fss_none};\n-import util::interner;\n+import util::interner::interner;\n import ast_util::{spanned, respan, mk_sp, ident_to_path, operator_prec};\n import lexer::reader;\n import prec::{as_prec, token_to_binop};\n@@ -193,12 +193,14 @@ struct parser {\n     let mut restriction: restriction;\n     let mut quote_depth: uint; // not (yet) related to the quasiquoter\n     let reader: reader;\n+    let interner: interner<@~str>;\n     let keywords: hashmap<~str, ()>;\n     let restricted_keywords: hashmap<~str, ()>;\n \n     new(sess: parse_sess, cfg: ast::crate_cfg, +rdr: reader, ftype: file_type)\n     {\n         self.reader <- rdr;\n+        self.interner = self.reader.interner();\n         let tok0 = self.reader.next_token();\n         let span0 = tok0.sp;\n         self.sess = sess;\n@@ -268,11 +270,10 @@ struct parser {\n     fn warn(m: ~str) {\n         self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n-    pure fn get_str(i: token::str_num) -> @~str {\n-        self.reader.interner().get(i)\n-    }\n     fn get_id() -> node_id { next_node_id(self.sess) }\n \n+    pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n+\n     fn parse_ty_fn(purity: ast::purity) -> ty_ {\n         let proto, bounds;\n         if self.eat_keyword(~\"extern\") {\n@@ -398,9 +399,9 @@ struct parser {\n         }\n     }\n \n-    fn region_from_name(s: option<@~str>) -> @region {\n+    fn region_from_name(s: option<ident>) -> @region {\n         let r = match s {\n-          some (string) => re_named(string),\n+          some (id) => re_named(id),\n           none => re_anon\n         };\n \n@@ -414,8 +415,7 @@ struct parser {\n         match copy self.token {\n           token::IDENT(sid, _) => {\n             self.bump();\n-            let n = self.get_str(sid);\n-            self.region_from_name(some(n))\n+            self.region_from_name(some(sid))\n           }\n           _ => {\n             self.region_from_name(none)\n@@ -430,7 +430,7 @@ struct parser {\n               token::IDENT(sid, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.bump(); self.bump();\n-                    some(self.get_str(sid))\n+                    some(sid)\n                 } else {\n                     none\n                 }\n@@ -583,7 +583,7 @@ struct parser {\n                 let name = self.parse_value_ident();\n                 self.bump();\n                 name\n-            } else { @~\"\" }\n+            } else { token::special_idents::invalid }\n         };\n \n         let t = self.parse_ty(false);\n@@ -678,10 +678,10 @@ struct parser {\n           token::LIT_INT(i, it) => lit_int(i, it),\n           token::LIT_UINT(u, ut) => lit_uint(u, ut),\n           token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n-          token::LIT_FLOAT(s, ft) => lit_float(self.get_str(s), ft),\n-          token::LIT_STR(s) => lit_str(self.get_str(s)),\n-          token::LPAREN => { self.expect(token::RPAREN); lit_nil }\n-          _ => self.unexpected_last(tok)\n+          token::LIT_FLOAT(s, ft) => lit_float(self.id_to_str(s), ft),\n+          token::LIT_STR(s) => lit_str(self.id_to_str(s)),\n+          token::LPAREN => { self.expect(token::RPAREN); lit_nil },\n+          _ => { self.unexpected_last(tok); }\n         }\n     }\n \n@@ -1140,8 +1140,7 @@ struct parser {\n                         self.parse_seq_to_gt(some(token::COMMA),\n                                              |p| p.parse_ty(false))\n                     } else { ~[] };\n-                    e = self.mk_pexpr(lo, hi, expr_field(self.to_expr(e),\n-                                                         self.get_str(i),\n+                    e = self.mk_pexpr(lo, hi, expr_field(self.to_expr(e), i,\n                                                          tys));\n                   }\n                   _ => self.unexpected()\n@@ -2123,9 +2122,6 @@ struct parser {\n     }\n \n     fn expr_is_complete(e: pexpr) -> bool {\n-        log(debug, (~\"expr_is_complete\", self.restriction,\n-                    print::pprust::expr_to_str(*e),\n-                    classify::expr_requires_semi_to_be_stmt(*e)));\n         return self.restriction == RESTRICT_STMT_EXPR &&\n             !classify::expr_requires_semi_to_be_stmt(*e);\n     }\n@@ -2306,8 +2302,9 @@ struct parser {\n \n     fn is_self_ident() -> bool {\n         match self.token {\n-            token::IDENT(sid, false) if ~\"self\" == *self.get_str(sid) => true,\n-            _ => false\n+          token::IDENT(id, false) if id == token::special_idents::self_\n+            => true,\n+          _ => false\n         }\n     }\n \n@@ -2522,11 +2519,13 @@ struct parser {\n         }\n \n         // This is a new-style impl declaration.\n-        let ident = @~\"__extensions__\";     // XXX: clownshoes\n+        // XXX: clownshoes\n+        let ident = token::special_idents::clownshoes_extensions;\n \n         // Parse the type.\n         let ty = self.parse_ty(false);\n \n+\n         // Parse traits, if necessary.\n         let traits = if self.token == token::COLON {\n             self.bump();\n@@ -2595,7 +2594,8 @@ struct parser {\n                       match the_ctor {\n                         some((_, _, _, s_first)) => {\n                           self.span_note(s, #fmt(\"Duplicate constructor \\\n-                                     declaration for class %s\", *class_name));\n+                                     declaration for class %s\",\n+                                     *self.interner.get(class_name)));\n                            self.span_fatal(copy s_first, ~\"First constructor \\\n                                                           declared here\");\n                         }\n@@ -2608,7 +2608,8 @@ struct parser {\n                       match the_dtor {\n                         some((_, _, s_first)) => {\n                           self.span_note(s, #fmt(\"Duplicate destructor \\\n-                                     declaration for class %s\", *class_name));\n+                                     declaration for class %s\",\n+                                     *self.interner.get(class_name)));\n                           self.span_fatal(copy s_first, ~\"First destructor \\\n                                                           declared here\");\n                         }\n@@ -3081,7 +3082,7 @@ struct parser {\n         let ty_params = self.parse_ty_params();\n         // Newtype syntax\n         if self.token == token::EQ {\n-            self.check_restricted_keywords_(*id);\n+            self.check_restricted_keywords_(*self.id_to_str(id));\n             self.bump();\n             let ty = self.parse_ty(false);\n             self.expect(token::SEMI);\n@@ -3297,7 +3298,7 @@ struct parser {\n         let lo = self.span.lo;\n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug!{\"parsed view_path: %s\", *first_ident};\n+        debug!{\"parsed view_path: %s\", *self.id_to_str(first_ident)};\n         match self.token {\n           token::EQ => {\n             // x = foo::bar\n@@ -3323,7 +3324,7 @@ struct parser {\n \n                   token::IDENT(i, _) => {\n                     self.bump();\n-                    vec::push(path, self.get_str(i));\n+                    vec::push(path, i);\n                   }\n \n                   // foo::bar::{a,b,c}\n@@ -3458,8 +3459,8 @@ struct parser {\n \n     fn parse_str() -> @~str {\n         match copy self.token {\n-          token::LIT_STR(s) => { self.bump(); self.get_str(s) }\n-          _ => self.fatal(~\"expected string literal\")\n+          token::LIT_STR(s) => { self.bump(); self.id_to_str(s) }\n+          _ =>  self.fatal(~\"expected string literal\")\n         }\n     }\n "}, {"sha": "8eb9270efe26e567fea76909a141a278bd4db111", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -277,23 +277,83 @@ pure fn is_bar(t: token) -> bool {\n     match t { BINOP(OR) | OROR => true, _ => false }\n }\n \n-type ident_interner = util::interner::interner<@~str>;\n \n mod special_idents {\n-    const underscore : uint = 0u;\n-    const anon : uint = 1u;\n-    const destr : uint = 2u; // 'drop', but that's reserved\n+    import ast::ident;\n+    const underscore : ident = 0u;\n+    const anon : ident = 1u;\n+    const dtor : ident = 2u; // 'drop', but that's reserved\n+    const invalid : ident = 3u; // ''\n+    const unary : ident = 4u;\n+    const not_fn : ident = 5u;\n+    const idx_fn : ident = 6u;\n+    const unary_minus_fn : ident = 7u;\n+    const clownshoes_extensions : ident = 8u;\n+\n+    const self_ : ident = 9u; // 'self'\n+\n+    /* for matcher NTs */\n+    const item : ident = 10u;\n+    const block : ident = 11u;\n+    const stmt : ident = 12u;\n+    const pat : ident = 13u;\n+    const expr : ident = 14u;\n+    const ty : ident = 15u;\n+    const ident : ident = 16u;\n+    const path : ident = 17u;\n+    const tt : ident = 18u;\n+    const matchers : ident = 19u;\n+\n+    const str : ident = 20u; // for the type\n+\n+    /* outside of libsyntax */\n+    const ty_visitor : ident = 21u;\n+    const arg : ident = 22u;\n+    const descrim : ident = 23u;\n+    const clownshoe_abi : ident = 24u;\n+    const clownshoe_stack_shim : ident = 25u;\n+    const tydesc : ident = 26u;\n+    const literally_dtor : ident = 27u;\n+    const main : ident = 28u;\n+    const opaque : ident = 29u;\n+    const blk : ident = 30u;\n+    const static : ident = 31u;\n+    const intrinsic : ident = 32u;\n+\n }\n \n+type ident_interner = util::interner::interner<@~str>;\n+\n+/** Key for thread-local data for sneaking interner information to the\n+ * serializer/deserializer. It sounds like a hack because it is one. */\n+fn interner_key(+_x: @@ident_interner) { }\n+\n fn mk_ident_interner() -> ident_interner {\n     /* the indices here must correspond to the numbers in special_idents */\n-    let init_vec = ~[@~\"_\", @~\"anon\", @~\"drop\"];\n-\n-    let rv = @interner::mk_prefill::<@~str>(|x| str::hash(*x),\n-                                            |x,y| str::eq(*x, *y), init_vec);\n+    let init_vec = ~[@~\"_\", @~\"anon\", @~\"drop\", @~\"\", @~\"unary\", @~\"!\",\n+                     @~\"[]\", @~\"unary-\", @~\"__extensions__\", @~\"self\",\n+                     @~\"item\", @~\"block\", @~\"stmt\", @~\"pat\", @~\"expr\",\n+                     @~\"ty\", @~\"ident\", @~\"path\", @~\"tt\", @~\"matchers\",\n+                     @~\"str\", @~\"ty_visitor\", @~\"arg\", @~\"descrim\",\n+                     @~\"__rust_abi\", @~\"__rust_stack_shim\", @~\"tydesc\",\n+                     @~\"dtor\", @~\"main\", @~\"<opaque>\", @~\"blk\", @~\"static\",\n+                     @~\"intrinsic\"];\n+\n+    let rv = interner::mk_prefill::<@~str>(|x| str::hash(*x),\n+                                           |x,y| str::eq(*x, *y), init_vec);\n+\n+    /* having multiple interners will just confuse the serializer */\n+    unsafe{ assert task::local_data_get(interner_key) == none };\n+    unsafe{ task::local_data_set(interner_key, @rv) };\n     rv\n }\n \n+/* for when we don't care about the contents; doesn't interact with TLD or\n+   serialization */\n+fn mk_fake_ident_interner() -> ident_interner {\n+    interner::mk::<@~str>(|x| str::hash(*x), |x,y| str::eq(*x, *y))\n+}\n+\n /**\n  * All the valid words that have meaning in the Rust language.\n  *"}, {"sha": "573eeffd96843eee0b56359beadbf4032d14f161", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 92, "deletions": 87, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -8,9 +8,7 @@ import ast::{required, provided};\n import ast_util::{operator_prec};\n import dvec::{DVec, dvec};\n import parse::classify::*;\n-import util::interner;\n-\n-type ident_interner = interner::interner<@~str>;\n+import parse::token::ident_interner;\n \n // The ps is stored here to prevent recursive type.\n enum ann_node {\n@@ -47,19 +45,7 @@ fn end(s: ps) {\n     pp::end(s.s);\n }\n \n-fn rust_printer(writer: io::Writer) -> ps {\n-    return @{s: pp::mk_printer(writer, default_columns),\n-             cm: none::<codemap>,\n-             intr: token::mk_ident_interner(),\n-             comments: none::<~[comments::cmnt]>,\n-             literals: none::<~[comments::lit]>,\n-             mut cur_cmnt: 0u,\n-             mut cur_lit: 0u,\n-             boxes: dvec(),\n-             ann: no_ann()};\n-}\n-\n-fn unexpanded_rust_printer(writer: io::Writer, intr: ident_interner) -> ps {\n+fn rust_printer(writer: io::Writer, intr: ident_interner) -> ps {\n     return @{s: pp::mk_printer(writer, default_columns),\n              cm: none::<codemap>,\n              intr: intr,\n@@ -79,7 +65,7 @@ const default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-fn print_crate(cm: codemap, intr: interner::interner<@~str>,\n+fn print_crate(cm: codemap, intr: ident_interner,\n                span_diagnostic: diagnostic::span_handler,\n                crate: @ast::crate, filename: ~str, in: io::Reader,\n                out: io::Writer, ann: pp_ann, is_expanded: bool) {\n@@ -107,41 +93,46 @@ fn print_crate_(s: ps, &&crate: @ast::crate) {\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: @ast::ty) -> ~str { return to_str(ty, print_type); }\n+fn ty_to_str(ty: @ast::ty, intr: ident_interner) -> ~str {\n+    to_str(ty, print_type, intr)\n+}\n \n-fn pat_to_str(pat: @ast::pat) -> ~str { return to_str(pat, print_pat); }\n+fn pat_to_str(pat: @ast::pat, intr: ident_interner) -> ~str {\n+    to_str(pat, print_pat, intr)\n+}\n \n-fn expr_to_str(e: @ast::expr) -> ~str { return to_str(e, print_expr); }\n+fn expr_to_str(e: @ast::expr, intr: ident_interner) -> ~str {\n+    to_str(e, print_expr, intr)\n+}\n \n-fn unexpanded_tt_to_str(tt: ast::token_tree, intr: ident_interner)\n-    -> ~str {\n-    let buffer = io::mem_buffer();\n-    let s = unexpanded_rust_printer(io::mem_buffer_writer(buffer), intr);\n-    print_tt(s, tt);\n-    eof(s.s);\n-    io::mem_buffer_str(buffer)\n+fn tt_to_str(tt: ast::token_tree, intr: ident_interner) -> ~str {\n+    to_str(tt, print_tt, intr)\n }\n \n-fn stmt_to_str(s: ast::stmt) -> ~str { return to_str(s, print_stmt); }\n+fn stmt_to_str(s: ast::stmt, intr: ident_interner) -> ~str {\n+    to_str(s, print_stmt, intr)\n+}\n \n-fn item_to_str(i: @ast::item) -> ~str { return to_str(i, print_item); }\n+fn item_to_str(i: @ast::item, intr: ident_interner) -> ~str {\n+    to_str(i, print_item, intr)\n+}\n \n-fn attr_to_str(i: ast::attribute) -> ~str {\n-    return to_str(i, print_attribute);\n+fn attr_to_str(i: ast::attribute, intr: ident_interner) -> ~str {\n+    to_str(i, print_attribute, intr)\n }\n \n-fn typarams_to_str(tps: ~[ast::ty_param]) -> ~str {\n-    return to_str(tps, print_type_params)\n+fn typarams_to_str(tps: ~[ast::ty_param], intr: ident_interner) -> ~str {\n+    to_str(tps, print_type_params, intr)\n }\n \n-fn path_to_str(&&p: @ast::path) -> ~str {\n-    return to_str(p, |a,b| print_path(a, b, false));\n+fn path_to_str(&&p: @ast::path, intr: ident_interner) -> ~str {\n+    to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n-              params: ~[ast::ty_param]) -> ~str {\n+              params: ~[ast::ty_param], intr: ident_interner) -> ~str {\n     let buffer = io::mem_buffer();\n-    let s = rust_printer(io::mem_buffer_writer(buffer));\n+    let s = rust_printer(io::mem_buffer_writer(buffer), intr);\n     print_fn(s, decl, name, params, none);\n     end(s); // Close the head box\n     end(s); // Close the outer box\n@@ -162,9 +153,9 @@ fn test_fun_to_str() {\n     assert fun_to_str(decl, \"a\", ~[]) == \"fn a()\";\n }\n \n-fn block_to_str(blk: ast::blk) -> ~str {\n+fn block_to_str(blk: ast::blk, intr: ident_interner) -> ~str {\n     let buffer = io::mem_buffer();\n-    let s = rust_printer(io::mem_buffer_writer(buffer));\n+    let s = rust_printer(io::mem_buffer_writer(buffer), intr);\n     // containing cbox, will be closed by print-block at }\n     cbox(s, indent_unit);\n     // head-ibox, will be closed by print-block after {\n@@ -174,16 +165,16 @@ fn block_to_str(blk: ast::blk) -> ~str {\n     io::mem_buffer_str(buffer)\n }\n \n-fn meta_item_to_str(mi: ast::meta_item) -> ~str {\n-    return to_str(@mi, print_meta_item);\n+fn meta_item_to_str(mi: ast::meta_item, intr: ident_interner) -> ~str {\n+    to_str(@mi, print_meta_item, intr)\n }\n \n-fn attribute_to_str(attr: ast::attribute) -> ~str {\n-    return to_str(attr, print_attribute);\n+fn attribute_to_str(attr: ast::attribute, intr: ident_interner) -> ~str {\n+    to_str(attr, print_attribute, intr)\n }\n \n-fn variant_to_str(var: ast::variant) -> ~str {\n-    return to_str(var, print_variant);\n+fn variant_to_str(var: ast::variant, intr: ident_interner) -> ~str {\n+    to_str(var, print_variant, intr)\n }\n \n #[test]\n@@ -349,7 +340,7 @@ fn print_region(s: ps, region: @ast::region) {\n       ast::re_anon => word_space(s, ~\"&\"),\n       ast::re_named(name) => {\n         word(s.s, ~\"&\");\n-        word(s.s, *name);\n+        print_ident(s, name);\n       }\n     }\n }\n@@ -389,7 +380,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         fn print_field(s: ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mutbl);\n-            word(s.s, *f.node.ident);\n+            print_ident(s, f.node.ident);\n             word_space(s, ~\":\");\n             print_type(s, f.node.mt.ty);\n             end(s);\n@@ -446,7 +437,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n     match item.node {\n       ast::item_const(ty, expr) => {\n         head(s, ~\"const\");\n-        word_space(s, *item.ident + ~\":\");\n+        print_ident(s, item.ident);\n+        word_space(s, ~\":\");\n         print_type(s, ty);\n         space(s.s);\n         end(s); // end the head-ibox\n@@ -464,15 +456,17 @@ fn print_item(s: ps, &&item: @ast::item) {\n       }\n       ast::item_mod(_mod) => {\n         head(s, ~\"mod\");\n-        word_nbsp(s, *item.ident);\n+        print_ident(s, item.ident);\n+        nbsp(s);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n       ast::item_foreign_mod(nmod) => {\n         head(s, ~\"extern\");\n         word_nbsp(s, ~\"mod\");\n-        word_nbsp(s, *item.ident);\n+        print_ident(s, item.ident);\n+        nbsp(s);\n         bopen(s);\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n@@ -481,7 +475,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, ~\"type\");\n-        word(s.s, *item.ident);\n+        print_ident(s, item.ident);\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n \n@@ -498,6 +492,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           head(s, ~\"struct\");\n           print_struct(s, struct_def, tps, item.ident, item.span);\n       }\n+\n       ast::item_impl(tps, traits, ty, methods) => {\n         head(s, ~\"impl\");\n         if tps.is_not_empty() {\n@@ -522,7 +517,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n       }\n       ast::item_trait(tps, traits, methods) => {\n         head(s, ~\"trait\");\n-        word(s.s, *item.ident);\n+        print_ident(s, item.ident);\n         print_type_params(s, tps);\n         if vec::len(traits) != 0u {\n             word_space(s, ~\":\");\n@@ -535,7 +530,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n         bclose(s, item.span);\n       }\n       ast::item_mac({node: ast::mac_invoc_tt(pth, tts), _}) => {\n-        head(s, path_to_str(pth) + ~\"! \" + *item.ident);\n+        print_path(s, pth, false);\n+        head(s, ~\"! \");\n+        print_ident(s, item.ident);\n         bopen(s);\n         for tts.each |tt| { print_tt(s, tt);  }\n         bclose(s, item.span);\n@@ -552,7 +549,7 @@ fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n                   span: ast::span) {\n     let mut newtype =\n         vec::len(enum_definition.variants) == 1u &&\n-            str::eq(ident, enum_definition.variants[0].node.name);\n+        ident == enum_definition.variants[0].node.name;\n     if newtype {\n         match enum_definition.variants[0].node.kind {\n             ast::tuple_variant_kind(args) if args.len() == 1 => {}\n@@ -566,7 +563,7 @@ fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n         head(s, ~\"enum\");\n     }\n \n-    word(s.s, *ident);\n+    print_ident(s, ident);\n     print_type_params(s, params);\n     space(s.s);\n     if newtype {\n@@ -599,7 +596,8 @@ fn print_variants(s: ps, variants: ~[ast::variant], span: ast::span) {\n \n fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n                 ident: ast::ident, span: ast::span) {\n-    word_nbsp(s, *ident);\n+    print_ident(s, ident);\n+    nbsp(s);\n     print_type_params(s, tps);\n     if vec::len(struct_def.traits) != 0u {\n         word_space(s, ~\":\");\n@@ -639,7 +637,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n                 if mutability == ast::class_mutable {\n                     word_nbsp(s, ~\"mut\");\n                 }\n-                word(s.s, *ident);\n+                print_ident(s, ident);\n                 word_nbsp(s, ~\":\");\n                 print_type(s, field.node.ty);\n                 word(s.s, ~\";\");\n@@ -684,7 +682,8 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n         s.s.token_tree_last_was_ident = false;\n       }\n       ast::tt_nonterminal(_, name) => {\n-        word(s.s, ~\"$\" + *name);\n+        word(s.s, ~\"$\");\n+        print_ident(s, name);\n         s.s.token_tree_last_was_ident = true;\n       }\n     }\n@@ -693,7 +692,7 @@ fn print_tt(s: ps, tt: ast::token_tree) {\n fn print_variant(s: ps, v: ast::variant) {\n     match v.node.kind {\n         ast::tuple_variant_kind(args) => {\n-            word(s.s, *v.node.name);\n+            print_ident(s, v.node.name);\n             if vec::len(args) > 0u {\n                 popen(s);\n                 fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n@@ -780,7 +779,7 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n     if attr.node.is_sugared_doc {\n         let meta = attr::attr_meta(attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n-        word(s.s, *comment);\n+        word(s.s, comment);\n     } else {\n         word(s.s, ~\"#[\");\n         print_meta_item(s, @attr.node.value);\n@@ -935,7 +934,8 @@ fn print_mac(s: ps, m: ast::mac) {\n         // FIXME: extension 'body' (#2339)\n       }\n       ast::mac_invoc_tt(pth, tts) => {\n-        head(s, path_to_str(pth) + ~\"!\");\n+        print_path(s, pth, false);\n+        head(s, ~\"!\");\n         bopen(s);\n         for tts.each() |tt| { print_tt(s, tt); }\n         bclose(s, m.span);\n@@ -956,7 +956,7 @@ fn print_vstore(s: ps, t: ast::vstore) {\n         ast::re_anon => word(s.s, ~\"&\"),\n         ast::re_named(name) => {\n             word(s.s, ~\"&\");\n-            word(s.s, *name);\n+            print_ident(s, name);\n             word(s.s, ~\".\");\n         }\n       }\n@@ -967,7 +967,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n     fn print_field(s: ps, field: ast::field) {\n         ibox(s, indent_unit);\n         if field.node.mutbl == ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n-        word(s.s, *field.node.ident);\n+        print_ident(s, field.node.ident);\n         word_space(s, ~\":\");\n         print_expr(s, field.node.expr);\n         end(s);\n@@ -1125,7 +1125,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_loop(blk, opt_ident) => {\n         head(s, ~\"loop\");\n         space(s.s);\n-        option::iter(opt_ident, |ident| word_space(s, *ident));\n+        option::iter(opt_ident, |ident| {print_ident(s, ident); space(s.s)});\n         print_block(s, blk);\n       }\n       ast::expr_match(expr, arms, mode) => {\n@@ -1270,7 +1270,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             print_expr_parens_if_not_bot(s, expr);\n         }\n         word(s.s, ~\".\");\n-        word(s.s, *id);\n+        print_ident(s, id);\n         if vec::len(tys) > 0u {\n             word(s.s, ~\"::<\");\n             commasep(s, inconsistent, tys, print_type);\n@@ -1294,12 +1294,12 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_break(opt_ident) => {\n         word(s.s, ~\"break\");\n         space(s.s);\n-        option::iter(opt_ident, |ident| word_space(s, *ident));\n+        option::iter(opt_ident, |ident| {print_ident(s, ident); space(s.s)});\n       }\n       ast::expr_again(opt_ident) => {\n         word(s.s, ~\"again\");\n         space(s.s);\n-        option::iter(opt_ident, |ident| word_space(s, *ident));\n+        option::iter(opt_ident, |ident| {print_ident(s, ident); space(s.s)});\n       }\n       ast::expr_ret(result) => {\n         word(s.s, ~\"return\");\n@@ -1395,7 +1395,7 @@ fn print_decl(s: ps, decl: @ast::decl) {\n     }\n }\n \n-fn print_ident(s: ps, ident: ast::ident) { word(s.s, *ident); }\n+fn print_ident(s: ps, ident: ast::ident) { word(s.s, *s.intr.get(ident)); }\n \n fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n     print_local_decl(s, loc);\n@@ -1410,7 +1410,7 @@ fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     let mut first = true;\n     for path.idents.each |id| {\n         if first { first = false; } else { word(s.s, ~\"::\"); }\n-        word(s.s, *id);\n+        print_ident(s, id);\n     }\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, ~\"::\"); }\n@@ -1471,7 +1471,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         word(s.s, ~\"{\");\n         fn print_field(s: ps, f: ast::field_pat) {\n             cbox(s, indent_unit);\n-            word(s.s, *f.ident);\n+            print_ident(s, f.ident);\n             word_space(s, ~\":\");\n             print_pat(s, f.pat);\n             end(s);\n@@ -1489,7 +1489,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n         word(s.s, ~\"{\");\n         fn print_field(s: ps, f: ast::field_pat) {\n             cbox(s, indent_unit);\n-            word(s.s, *f.ident);\n+            print_ident(s, f.ident);\n             word_space(s, ~\":\");\n             print_pat(s, f.pat);\n             end(s);\n@@ -1542,7 +1542,7 @@ fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: ~[ast::ty_param],\n             opt_self_ty: option<ast::self_ty_>) {\n     head(s, fn_header_info_to_str(opt_self_ty, decl.purity, none));\n-    word(s.s, *name);\n+    print_ident(s, name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n }\n@@ -1568,7 +1568,7 @@ fn print_fn_args(s: ps, decl: ast::fn_decl,\n         if first { first = false; } else { word_space(s, ~\",\"); }\n         if cap_item.is_move { word_nbsp(s, ~\"move\") }\n         else { word_nbsp(s, ~\"copy\") }\n-        word(s.s, *cap_item.name);\n+        print_ident(s, cap_item.name);\n     }\n \n     end(s);\n@@ -1638,7 +1638,7 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, ~\"<\");\n         fn printParam(s: ps, param: ast::ty_param) {\n-            word(s.s, *param.ident);\n+            print_ident(s, param.ident);\n             print_bounds(s, param.bounds);\n         }\n         commasep(s, inconsistent, params, printParam);\n@@ -1649,14 +1649,14 @@ fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::meta_word(name) => word(s.s, *name),\n+      ast::meta_word(name) => word(s.s, name),\n       ast::meta_name_value(name, value) => {\n-        word_space(s, *name);\n+        word_space(s, name);\n         word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, items) => {\n-        word(s.s, *name);\n+        word(s.s, name);\n         popen(s);\n         commasep(s, consistent, items, print_meta_item);\n         pclose(s);\n@@ -1669,7 +1669,8 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, path, _) => {\n         if path.idents[vec::len(path.idents)-1u] != ident {\n-            word_space(s, *ident);\n+            print_ident(s, ident);\n+            space(s.s);\n             word_space(s, ~\"=\");\n         }\n         print_path(s, path, false);\n@@ -1684,7 +1685,7 @@ fn print_view_path(s: ps, &&vp: @ast::view_path) {\n         print_path(s, path, false);\n         word(s.s, ~\"::{\");\n         do commasep(s, inconsistent, idents) |s, w| {\n-            word(s.s, *w.node.name)\n+            print_ident(s, w.node.name);\n         }\n         word(s.s, ~\"}\");\n       }\n@@ -1702,7 +1703,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     match item.node {\n       ast::view_item_use(id, mta, _) => {\n         head(s, ~\"use\");\n-        word(s.s, *id);\n+        print_ident(s, id);\n         if vec::len(mta) > 0u {\n             popen(s);\n             commasep(s, consistent, mta, print_meta_item);\n@@ -1749,10 +1750,12 @@ fn print_arg(s: ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     print_arg_mode(s, input.mode);\n     match input.ty.node {\n-      ast::ty_infer => word(s.s, *input.ident),\n+      ast::ty_infer => print_ident(s, input.ident),\n       _ => {\n-        if str::len(*input.ident) > 0u {\n-            word_space(s, *input.ident + ~\":\");\n+        if input.ident != parse::token::special_idents::invalid {\n+            print_ident(s, input.ident);\n+            word(s.s, ~\":\");\n+            space(s.s);\n         }\n         print_type(s, input.ty);\n       }\n@@ -1768,7 +1771,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     ibox(s, indent_unit);\n     word(s.s, fn_header_info_to_str(opt_self_ty, decl.purity, opt_proto));\n     print_bounds(s, bounds);\n-    match id { some(id) => { word(s.s, ~\" \"); word(s.s, *id); } _ => () }\n+    match id { some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n     match tps { some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n \n@@ -1880,7 +1883,9 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     }\n }\n \n-fn lit_to_str(l: @ast::lit) -> ~str { return to_str(l, print_literal); }\n+fn lit_to_str(l: @ast::lit) -> ~str {\n+    return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n+}\n \n fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n     match s.literals {\n@@ -1961,9 +1966,9 @@ fn print_string(s: ps, st: ~str) {\n     word(s.s, ~\"\\\"\");\n }\n \n-fn to_str<T>(t: T, f: fn@(ps, T)) -> ~str {\n+fn to_str<T>(t: T, f: fn@(ps, T), intr: ident_interner) -> ~str {\n     let buffer = io::mem_buffer();\n-    let s = rust_printer(io::mem_buffer_writer(buffer));\n+    let s = rust_printer(io::mem_buffer_writer(buffer), intr);\n     f(s, t);\n     eof(s.s);\n     io::mem_buffer_str(buffer)"}, {"sha": "5cecd315ac49c73125e393464b93d24bc1f2b1d9", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -21,7 +21,7 @@ fn mk<T: const copy>(+hasher: hashfn<T>, +eqer: eqfn<T>) -> interner<T> {\n fn mk_prefill<T: const copy>(hasher: hashfn<T>, eqer: eqfn<T>,\n                              init: ~[T]) -> interner<T> {\n \n-    let rv = mk(hasher, eqer);\n+    let rv = mk(copy hasher, copy eqer);\n     for init.each() |v| { rv.intern(v); }\n     return rv;\n }\n@@ -30,6 +30,7 @@ fn mk_prefill<T: const copy>(hasher: hashfn<T>, eqer: eqfn<T>,\n /* when traits can extend traits, we should extend index<uint,T> to get [] */\n trait interner<T: const copy> {\n     fn intern(T) -> uint;\n+    fn gensym(T) -> uint;\n     pure fn get(uint) -> T;\n     fn len() -> uint;\n }\n@@ -46,6 +47,12 @@ impl <T: const copy> hash_interner<T>: interner<T> {\n           }\n         }\n     }\n+    fn gensym(val: T) -> uint {\n+        let new_idx = self.vect.len();\n+        // leave out of .map to avoid colliding\n+        self.vect.push(val);\n+        return new_idx;\n+    }\n \n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,"}, {"sha": "51104e97119a660a07336096150e391470d3a899", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -27,9 +27,9 @@ enum fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     match fk {\n       fk_item_fn(name, _) | fk_method(name, _, _)\n-          | fk_ctor(name, _, _, _, _) => /* FIXME (#2543) */ copy name,\n-      fk_anon(*) | fk_fn_block(*) => @~\"anon\",\n-      fk_dtor(*)                  => @~\"drop\"\n+          | fk_ctor(name, _, _, _, _) =>  /* FIXME (#2543) */ copy name,\n+      fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n+      fk_dtor(*)                  => parse::token::special_idents::dtor\n     }\n }\n "}, {"sha": "58e884340e6822eb7790d44cb0b994db10525f68", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -310,24 +310,24 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                    symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n-        {name: option<@~str>,\n-         vers: option<@~str>,\n+        {name: option<~str>,\n+         vers: option<~str>,\n          cmh_items: ~[@ast::meta_item]};\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n-        let mut name: option<@~str> = none;\n-        let mut vers: option<@~str> = none;\n+        let mut name: option<~str> = none;\n+        let mut vers: option<~str> = none;\n         let mut cmh_items: ~[@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if *attr::get_meta_item_name(meta) == ~\"name\" {\n+            if attr::get_meta_item_name(meta) == ~\"name\" {\n                 match attr::get_meta_item_value_str(meta) {\n                   some(v) => { name = some(v); }\n                   none => vec::push(cmh_items, meta)\n                 }\n-            } else if *attr::get_meta_item_name(meta) == ~\"vers\" {\n+            } else if attr::get_meta_item_name(meta) == ~\"vers\" {\n                 match attr::get_meta_item_value_str(meta) {\n                   some(v) => { vers = some(v); }\n                   none => vec::push(cmh_items, meta)\n@@ -341,7 +341,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n                               _crate: ast::crate,\n                               metas: provided_metas,\n-                              dep_hashes: ~[@~str]) -> ~str {\n+                              dep_hashes: ~[~str]) -> ~str {\n         fn len_and_str(s: ~str) -> ~str {\n             return fmt!{\"%u_%s\", str::len(s), s};\n         }\n@@ -357,11 +357,11 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n             let m = m_;\n             match m.node {\n               ast::meta_name_value(key, value) => {\n-                symbol_hasher.write_str(len_and_str(*key));\n+                symbol_hasher.write_str(len_and_str(key));\n                 symbol_hasher.write_str(len_and_str_lit(value));\n               }\n               ast::meta_word(name) => {\n-                symbol_hasher.write_str(len_and_str(*name));\n+                symbol_hasher.write_str(len_and_str(name));\n               }\n               ast::meta_list(_, _) => {\n                 // FIXME (#607): Implement this\n@@ -371,7 +371,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n         }\n \n         for dep_hashes.each |dh| {\n-            symbol_hasher.write_str(len_and_str(*dh));\n+            symbol_hasher.write_str(len_and_str(dh));\n         }\n \n         return truncated_hash_result(symbol_hasher);\n@@ -384,7 +384,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n-                       output: ~str, metas: provided_metas) -> @~str {\n+                       output: ~str, metas: provided_metas) -> ~str {\n         return match metas.name {\n               some(v) => v,\n               none => {\n@@ -400,19 +400,19 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                         str::connect(os, ~\".\")\n                     };\n                 warn_missing(sess, ~\"name\", name);\n-                @name\n+                name\n               }\n             };\n     }\n \n     fn crate_meta_vers(sess: session, _crate: ast::crate,\n-                       metas: provided_metas) -> @~str {\n+                       metas: provided_metas) -> ~str {\n         return match metas.vers {\n               some(v) => v,\n               none => {\n                 let vers = ~\"0.0\";\n                 warn_missing(sess, ~\"vers\", vers);\n-                @vers\n+                vers\n               }\n             };\n     }\n@@ -439,7 +439,7 @@ fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.write_str(*link_meta.name);\n+    symbol_hasher.write_str(link_meta.name);\n     symbol_hasher.write_str(~\"-\");\n     symbol_hasher.write_str(link_meta.extras_hash);\n     symbol_hasher.write_str(~\"-\");\n@@ -497,51 +497,56 @@ fn sanitize(s: ~str) -> ~str {\n     return result;\n }\n \n-fn mangle(ss: path) -> ~str {\n+fn mangle(sess: session, ss: path) -> ~str {\n     // Follow C++ namespace-mangling style\n \n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n     for ss.each |s| {\n         match s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(*s);\n+          let sani = sanitize(sess.str_of(s));\n           n += fmt!{\"%u%s\", str::len(sani), sani};\n         } }\n     }\n     n += ~\"E\"; // End name-sequence.\n     n\n }\n \n-fn exported_name(path: path, hash: @~str, vers: @~str) -> ~str {\n-    return mangle(\n-        vec::append_one(vec::append_one(path, path_name(hash)),\n-                        path_name(vers)));\n+fn exported_name(sess: session, path: path, hash: ~str, vers: ~str) -> ~str {\n+    return mangle(sess,\n+                  vec::append_one(\n+                      vec::append_one(path, path_name(sess.ident_of(hash))),\n+                      path_name(sess.ident_of(vers))));\n }\n \n fn mangle_exported_name(ccx: @crate_ctxt, path: path, t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n-    return exported_name(path, @hash, ccx.link_meta.vers);\n+    return exported_name(ccx.sess, path, hash, ccx.link_meta.vers);\n }\n \n fn mangle_internal_name_by_type_only(ccx: @crate_ctxt,\n-                                     t: ty::t, name: @~str) ->\n+                                     t: ty::t, name: ~str) ->\n    ~str {\n-    let s = @util::ppaux::ty_to_short_str(ccx.tcx, t);\n+    let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n-    return mangle(~[path_name(name), path_name(s), path_name(@hash)]);\n+    return mangle(ccx.sess,\n+                  ~[path_name(ccx.sess.ident_of(name)),\n+                    path_name(ccx.sess.ident_of(s)),\n+                    path_name(ccx.sess.ident_of(hash))]);\n }\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: path,\n-                                        flav: @~str) -> ~str {\n-    return mangle(vec::append_one(path, path_name(@ccx.names(*flav))));\n+                                        flav: ~str) -> ~str {\n+    return mangle(ccx.sess,\n+                  vec::append_one(path, path_name(ccx.names(flav))));\n }\n \n-fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: path) -> ~str {\n-    return mangle(path);\n+fn mangle_internal_name_by_path(ccx: @crate_ctxt, path: path) -> ~str {\n+    return mangle(ccx.sess, path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: @~str) -> ~str {\n-    return ccx.names(*flav);\n+fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: ~str) -> ~str {\n+    return fmt!(\"%s_%u\", flav, ccx.names(flav));\n }\n \n // If the user wants an exe generated we need to invoke\n@@ -577,8 +582,8 @@ fn link_binary(sess: session,\n     let output = if sess.building_library {\n         let long_libname =\n             os::dll_filename(fmt!{\"%s-%s-%s\",\n-                                  *lm.name, lm.extras_hash, *lm.vers});\n-        debug!{\"link_meta.name:  %s\", *lm.name};\n+                                  lm.name, lm.extras_hash, lm.vers});\n+        debug!{\"link_meta.name:  %s\", lm.name};\n         debug!{\"long_libname: %s\", long_libname};\n         debug!{\"out_filename: %s\", out_filename};\n         debug!{\"dirname(out_filename): %s\", path::dirname(out_filename)};"}, {"sha": "65875af6b7f8a645b7aa4a2b681d6f1e23e65b62", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -51,15 +51,15 @@ fn default_configuration(sess: session, argv0: ~str, input: input) ->\n     };\n \n     return ~[ // Target bindings.\n-         attr::mk_word_item(@os::family()),\n-         mk(@~\"target_os\", os::sysname()),\n-         mk(@~\"target_family\", os::family()),\n-         mk(@~\"target_arch\", arch),\n-         mk(@~\"target_word_size\", wordsz),\n-         mk(@~\"target_libc\", libc),\n+         attr::mk_word_item(os::family()),\n+         mk(~\"target_os\", os::sysname()),\n+         mk(~\"target_family\", os::family()),\n+         mk(~\"target_arch\", arch),\n+         mk(~\"target_word_size\", wordsz),\n+         mk(~\"target_libc\", libc),\n          // Build bindings.\n-         mk(@~\"build_compiler\", argv0),\n-         mk(@~\"build_input\", source_name(input))];\n+         mk(~\"build_compiler\", argv0),\n+         mk(~\"build_input\", source_name(input))];\n }\n \n fn build_configuration(sess: session, argv0: ~str, input: input) ->\n@@ -72,9 +72,9 @@ fn build_configuration(sess: session, argv0: ~str, input: input) ->\n     let gen_cfg =\n         {\n             if sess.opts.test && !attr::contains_name(user_cfg, ~\"test\") {\n-                ~[attr::mk_word_item(@~\"test\")]\n+                ~[attr::mk_word_item(~\"test\")]\n             } else {\n-                ~[attr::mk_word_item(@~\"notest\")]\n+                ~[attr::mk_word_item(~\"notest\")]\n             }\n         };\n     return vec::append(vec::append(user_cfg, gen_cfg), default_cfg);\n@@ -86,7 +86,7 @@ fn parse_cfgspecs(cfgspecs: ~[~str]) -> ast::crate_cfg {\n     // varieties of meta_item here. At the moment we just support the\n     // meta_word variant.\n     let mut words = ~[];\n-    for cfgspecs.each |s| { vec::push(words, attr::mk_word_item(@s)); }\n+    for cfgspecs.each |s| { vec::push(words, attr::mk_word_item(s)); }\n     return words;\n }\n \n@@ -169,7 +169,8 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n         creader::read_crates(sess.diagnostic(), *crate, sess.cstore,\n                              sess.filesearch,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                             sess.opts.static));\n+                             sess.opts.static,\n+                             sess.parse_sess.interner));\n \n     let lang_items = time(time_passes, ~\"language item collection\", ||\n          middle::lang_items::collect_language_items(crate, sess));\n@@ -552,7 +553,9 @@ fn build_session_(sopts: @session::options,\n                -> session {\n \n     let target_cfg = build_target_config(sopts, demitter);\n-    let cstore = cstore::mk_cstore();\n+    let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n+                                                    cm);\n+    let cstore = cstore::mk_cstore(p_s.interner);\n     let filesearch = filesearch::mk_filesearch(\n         sopts.maybe_sysroot,\n         sopts.target_triple,\n@@ -561,8 +564,7 @@ fn build_session_(sopts: @session::options,\n     session_(@{targ_cfg: target_cfg,\n                opts: sopts,\n                cstore: cstore,\n-               parse_sess:\n-          parse::new_parse_sess_special_handler(span_diagnostic_handler, cm),\n+               parse_sess: p_s,\n                codemap: cm,\n                // For a library crate, this is always none\n                mut main_fn: none,\n@@ -701,6 +703,7 @@ fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n \n fn list_metadata(sess: session, path: ~str, out: io::Writer) {\n     metadata::loader::list_file_metadata(\n+        sess.parse_sess.interner,\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }\n "}, {"sha": "039a5b4d14a4fb1c9f2fa6a258db044e89827b56", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -204,6 +204,16 @@ impl session {\n     fn borrowck_stats() -> bool { self.debugging_opt(borrowck_stats) }\n     fn borrowck_note_pure() -> bool { self.debugging_opt(borrowck_note_pure) }\n     fn borrowck_note_loan() -> bool { self.debugging_opt(borrowck_note_loan) }\n+\n+    fn str_of(id: ast::ident) -> ~str {\n+        *self.parse_sess.interner.get(id)\n+    }\n+    fn ident_of(st: ~str) -> ast::ident {\n+        self.parse_sess.interner.intern(@st)\n+    }\n+    fn intr() -> syntax::parse::token::ident_interner {\n+        self.parse_sess.interner\n+    }\n }\n \n /// Some reasonable defaults\n@@ -245,7 +255,7 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 ~\"crate_type\") {\n-              option::some(@~\"lib\") => true,\n+              option::some(~\"lib\") => true,\n               _ => false\n             }\n         }\n@@ -273,7 +283,7 @@ mod test {\n             style: ast::attr_outer,\n             value: ast_util::respan(ast_util::dummy_sp(),\n                 ast::meta_name_value(\n-                    @~\"crate_type\",\n+                    ~\"crate_type\",\n                     ast_util::respan(ast_util::dummy_sp(),\n                                      ast::lit_str(@t)))),\n             is_sugared_doc: false"}, {"sha": "bcfdca40ac2a3f174d249462e8ec9bb7dfbc83e6", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -30,12 +30,13 @@ fn inject_libcore_ref(sess: session,\n     let n1 = sess.next_node_id();\n     let n2 = sess.next_node_id();\n \n-    let vi1 = @{node: ast::view_item_use(@~\"core\", ~[], n1),\n+    let vi1 = @{node: ast::view_item_use(sess.ident_of(~\"core\"), ~[], n1),\n                 attrs: ~[],\n                 vis: ast::public,\n                 span: dummy_sp()};\n-    let vp = spanned(ast::view_path_glob(ident_to_path(dummy_sp(), @~\"core\"),\n-                                         n2));\n+    let vp = spanned(ast::view_path_glob(\n+        ident_to_path(dummy_sp(), sess.ident_of(~\"core\")),\n+        n2));\n     let vi2 = @{node: ast::view_item_import(~[vp]),\n                 attrs: ~[],\n                 vis: ast::public,"}, {"sha": "33908f004f564cf4c399f7cecb34dcad0d71e96a", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -62,17 +62,17 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n     }\n }\n \n-fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n     // the one we're going to add.\n \n     // FIXME (#2403): This is sloppy. Instead we should have some mechanism to\n     // indicate to the translation pass which function we want to be main.\n-    fn nomain(&&item: @ast::item) -> option<@ast::item> {\n+    fn nomain(cx: test_ctxt, item: @ast::item) -> option<@ast::item> {\n         match item.node {\n           ast::item_fn(_, _, _) => {\n-            if *item.ident == ~\"main\" {\n+            if item.ident == cx.sess.ident_of(~\"main\") {\n                 option::none\n             } else { option::some(item) }\n           }\n@@ -81,7 +81,8 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     }\n \n     let mod_nomain =\n-        {view_items: m.view_items, items: vec::filter_map(m.items, nomain)};\n+        {view_items: m.view_items, items: vec::filter_map(m.items,\n+                                                          |i| nomain(cx, i))};\n     return fold::noop_fold_mod(mod_nomain, fld);\n }\n \n@@ -99,7 +100,8 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n    option<@ast::item> {\n \n     vec::push(cx.path, i.ident);\n-    debug!{\"current path: %s\", ast_util::path_name_i(cx.path)};\n+    debug!{\"current path: %s\",\n+           ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner)};\n \n     if is_test_fn(i) {\n         match i.node {\n@@ -192,16 +194,17 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     let item_ = ast::item_mod(testmod);\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(@~\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n     let item: ast::item =\n-        {ident: @~\"__test\",\n+        {ident: cx.sess.ident_of(~\"__test\"),\n          attrs: ~[resolve_unexported_attr],\n          id: cx.sess.next_node_id(),\n          node: item_,\n          vis: ast::public,\n          span: dummy_sp()};\n \n-    debug!{\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)};\n+    debug!{\"Synthetic test module:\\n%s\\n\",\n+           pprust::item_to_str(@item, cx.sess.intr())};\n \n     return @item;\n }\n@@ -232,7 +235,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n \n     let item_ = ast::item_fn(decl, ~[], body);\n     let item: ast::item =\n-        {ident: @~\"tests\",\n+        {ident: cx.sess.ident_of(~\"tests\"),\n          attrs: ~[],\n          id: cx.sess.next_node_id(),\n          node: item_,\n@@ -247,18 +250,19 @@ fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n-          some(@~\"std\") => true,\n+          some(~\"std\") => true,\n           _ => false\n         }\n     };\n     if is_std { path }\n-    else { vec::append(~[@~\"std\"], path) }\n+    else { vec::append(~[cx.sess.ident_of(~\"std\")], path) }\n }\n \n // The ast::ty of ~[std::test::test_desc]\n fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n     let test_desc_ty_path =\n-        path_node(mk_path(cx, ~[@~\"test\", @~\"test_desc\"]));\n+        path_node(mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n+                                cx.sess.ident_of(~\"test_desc\")]));\n \n     let test_desc_ty: ast::ty =\n         {id: cx.sess.next_node_id(),\n@@ -296,10 +300,12 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = test.path;\n \n-    debug!{\"encoding %s\", ast_util::path_name_i(path)};\n+    debug!{\"encoding %s\", ast_util::path_name_i(path,\n+                                                cx.sess.parse_sess.interner)};\n \n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(@ast_util::path_name_i(path)));\n+        nospan(ast::lit_str(@ast_util::path_name_i(path, cx.sess.parse_sess\n+                                                   .interner)));\n     let name_expr_inner: @ast::expr =\n         @{id: cx.sess.next_node_id(),\n           callee_id: cx.sess.next_node_id(),\n@@ -313,7 +319,8 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n \n     let name_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: @~\"name\", expr: @name_expr});\n+        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"name\"),\n+                expr: @name_expr});\n \n     let fn_path = path_node(path);\n \n@@ -326,7 +333,8 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n \n     let fn_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: @~\"fn\", expr: fn_wrapper_expr});\n+        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"fn\"),\n+                expr: fn_wrapper_expr});\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -337,7 +345,8 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          span: span};\n \n     let ignore_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: @~\"ignore\", expr: @ignore_expr});\n+        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"ignore\"),\n+                expr: @ignore_expr});\n \n     let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n \n@@ -349,7 +358,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n     let fail_field: ast::field =\n         nospan({mutbl: ast::m_imm,\n-                ident: @~\"should_fail\",\n+                ident: cx.sess.ident_of(~\"should_fail\"),\n                 expr: @fail_expr});\n \n     let desc_rec_: ast::expr_ =\n@@ -404,7 +413,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-    let str_pt = path_node(~[@~\"str\"]);\n+    let str_pt = path_node(~[cx.sess.ident_of(~\"str\")]);\n     let str_ty_inner = @{id: cx.sess.next_node_id(),\n                          node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n                          span: dummy_sp()};\n@@ -423,7 +432,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let args_arg: ast::arg =\n         {mode: ast::expl(ast::by_val),\n          ty: @args_ty,\n-         ident: @~\"args\",\n+         ident: cx.sess.ident_of(~\"args\"),\n          id: cx.sess.next_node_id()};\n \n     let ret_ty = {id: cx.sess.next_node_id(),\n@@ -445,7 +454,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n \n     let item_ = ast::item_fn(decl, ~[], body);\n     let item: ast::item =\n-        {ident: @~\"main\",\n+        {ident: cx.sess.ident_of(~\"main\"),\n          attrs: ~[],\n          id: cx.sess.next_node_id(),\n          node: item_,\n@@ -457,7 +466,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n-    let args_path = path_node(~[@~\"args\"]);\n+    let args_path = path_node(~[cx.sess.ident_of(~\"args\")]);\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n@@ -466,7 +475,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n          node: args_path_expr_, span: dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n-    let test_path = path_node(~[@~\"tests\"]);\n+    let test_path = path_node(~[cx.sess.ident_of(~\"tests\")]);\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n@@ -481,7 +490,9 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n          node: test_call_expr_, span: dummy_sp()};\n \n     // Call std::test::test_main\n-    let test_main_path = path_node(mk_path(cx, ~[@~\"test\", @~\"test_main\"]));\n+    let test_main_path = path_node(\n+        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n+                      cx.sess.ident_of(~\"test_main\")]));\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n "}, {"sha": "15e15a8a54c92e92217284f3c078bcecf2652606", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -134,5 +134,5 @@ fn hash_path(&&s: ~str) -> uint {\n     return h;\n }\n \n-type link_meta = {name: @~str, vers: @~str, extras_hash: ~str};\n+type link_meta = {name: ~str, vers: ~str, extras_hash: ~str};\n "}, {"sha": "2a3b59bf349a95c1d9c019a095fe485527a84b24", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -10,35 +10,37 @@ import syntax::print::pprust;\n import filesearch::filesearch;\n import common::*;\n import dvec::{DVec, dvec};\n+import syntax::parse::token::ident_interner;\n \n export read_crates;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n fn read_crates(diag: span_handler, crate: ast::crate,\n                cstore: cstore::cstore, filesearch: filesearch,\n-               os: loader::os, static: bool) {\n+               os: loader::os, static: bool, intr: ident_interner) {\n     let e = @{diag: diag,\n               filesearch: filesearch,\n               cstore: cstore,\n               os: os,\n               static: static,\n               crate_cache: dvec(),\n-              mut next_crate_num: 1};\n+              mut next_crate_num: 1,\n+              intr: intr};\n     let v =\n         visit::mk_simple_visitor(@{visit_view_item:\n                                        |a| visit_view_item(e, a),\n                                    visit_item: |a| visit_item(e, a)\n-                                      with *visit::default_simple_visitor()});\n+                                   with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(diag, e.crate_cache.get());\n+    warn_if_multiple_versions(e, diag, e.crate_cache.get());\n }\n \n type cache_entry = {\n     cnum: int,\n     span: span,\n-    hash: @~str,\n+    hash: ~str,\n     metas: @~[@ast::meta_item]\n };\n \n@@ -48,16 +50,10 @@ fn dump_crates(crate_cache: DVec<cache_entry>) {\n         debug!{\"cnum: %?\", entry.cnum};\n         debug!{\"span: %?\", entry.span};\n         debug!{\"hash: %?\", entry.hash};\n-        let attrs = ~[\n-            attr::mk_attr(attr::mk_list_item(@~\"link\", *entry.metas))\n-        ];\n-        for attr::find_linkage_attrs(attrs).each |attr| {\n-            debug!{\"meta: %s\", pprust::attr_to_str(attr)};\n-        }\n     }\n }\n \n-fn warn_if_multiple_versions(diag: span_handler,\n+fn warn_if_multiple_versions(e: env, diag: span_handler,\n                              crate_cache: ~[cache_entry]) {\n     import either::*;\n \n@@ -77,17 +73,17 @@ fn warn_if_multiple_versions(diag: span_handler,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!{\"using multiple versions of crate `%s`\", *name});\n+                fmt!{\"using multiple versions of crate `%s`\", name});\n             for matches.each |match_| {\n                 diag.span_note(match_.span, ~\"used here\");\n                 let attrs = ~[\n-                    attr::mk_attr(attr::mk_list_item(@~\"link\", *match_.metas))\n+                    attr::mk_attr(attr::mk_list_item(~\"link\", *match_.metas))\n                 ];\n-                loader::note_linkage_attrs(diag, attrs);\n+                loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n         }\n \n-        warn_if_multiple_versions(diag, non_matches);\n+        warn_if_multiple_versions(e, diag, non_matches);\n     }\n }\n \n@@ -97,7 +93,8 @@ type env = @{diag: span_handler,\n              os: loader::os,\n              static: bool,\n              crate_cache: DVec<cache_entry>,\n-             mut next_crate_num: ast::crate_num};\n+             mut next_crate_num: ast::crate_num,\n+             intr: ident_interner};\n \n fn visit_view_item(e: env, i: @ast::view_item) {\n     match i.node {\n@@ -125,28 +122,28 @@ fn visit_item(e: env, i: @ast::item) {\n         let foreign_name =\n             match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n               some(nn) => {\n-                if *nn == ~\"\" {\n+                if nn == ~\"\" {\n                     e.diag.span_fatal(\n                         i.span,\n                         ~\"empty #[link_name] not allowed; use #[nolink].\");\n                 }\n                 nn\n               }\n-              none => i.ident\n+              none => *e.intr.get(i.ident)\n             };\n         let mut already_added = false;\n         if vec::len(attr::find_attrs_by_name(i.attrs, ~\"nolink\")) == 0u {\n-            already_added = !cstore::add_used_library(cstore, *foreign_name);\n+            already_added = !cstore::add_used_library(cstore, foreign_name);\n         }\n         let link_args = attr::find_attrs_by_name(i.attrs, ~\"link_args\");\n         if vec::len(link_args) > 0u && already_added {\n-            e.diag.span_fatal(i.span, ~\"library '\" + *foreign_name +\n+            e.diag.span_fatal(i.span, ~\"library '\" + foreign_name +\n                               ~\"' already added: can't specify link_args.\");\n         }\n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(a)) {\n               some(linkarg) => {\n-                cstore::add_used_link_args(cstore, *linkarg);\n+                cstore::add_used_link_args(cstore, linkarg);\n               }\n               none => {/* fallthrough */ }\n             }\n@@ -156,27 +153,27 @@ fn visit_item(e: env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: ast::ident, key: ast::ident,\n-                    metas: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, *key);\n+fn metas_with(ident: ~str, key: ~str, metas: ~[@ast::meta_item])\n+    -> ~[@ast::meta_item] {\n+    let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n-        vec::append_one(metas, attr::mk_name_value_item_str(key, *ident))\n+        vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {\n         metas\n     }\n }\n \n-fn metas_with_ident(ident: ast::ident,\n-                    metas: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n-    metas_with(ident, @~\"name\", metas)\n+fn metas_with_ident(ident: ~str, metas: ~[@ast::meta_item])\n+    -> ~[@ast::meta_item] {\n+    metas_with(ident, ~\"name\", metas)\n }\n \n fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n     option<int> {\n \n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n-            && (hash.is_empty() || *c.hash == hash) {\n+            && (hash.is_empty() || c.hash == hash) {\n             return some(c.cnum);\n         }\n     }\n@@ -185,7 +182,7 @@ fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n \n fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n                  hash: ~str, span: span) -> ast::crate_num {\n-    let metas = metas_with_ident(ident, metas);\n+    let metas = metas_with_ident(*e.intr.get(ident), metas);\n \n     match existing_match(e, metas, hash) {\n       none => {\n@@ -197,7 +194,8 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n             metas: metas,\n             hash: hash,\n             os: e.os,\n-            static: e.static\n+            static: e.static,\n+            intr: e.intr\n         };\n         let cinfo = loader::load_library_crate(load_ctxt);\n \n@@ -220,9 +218,9 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n         let cname =\n             match attr::last_meta_item_value_str_by_name(metas, ~\"name\") {\n               option::some(v) => v,\n-              option::none => ident\n+              option::none => *e.intr.get(ident)\n             };\n-        let cmeta = @{name: *cname, data: cdata,\n+        let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n \n         let cstore = e.cstore;\n@@ -242,13 +240,14 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = int_hash::<ast::crate_num>();\n-    for decoder::get_crate_deps(cdata).each |dep| {\n+    for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n-        let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n+        let cmetas = metas_with(dep.vers, ~\"vers\", ~[]);\n         debug!{\"resolving dep crate %s ver: %s hash: %s\",\n-               *dep.name, *dep.vers, *dep.hash};\n-        match existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {\n+               *e.intr.get(dep.name), dep.vers, dep.hash};\n+        match existing_match(e, metas_with_ident(*e.intr.get(cname), cmetas),\n+                             dep.hash) {\n           some(local_cnum) => {\n             debug!{\"already have it\"};\n             // We've already seen this crate\n@@ -260,8 +259,8 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n             let fake_span = ast_util::dummy_sp();\n-            let local_cnum =\n-                resolve_crate(e, cname, cmetas, *dep.hash, fake_span);\n+            let local_cnum = resolve_crate(e, cname, cmetas, dep.hash,\n+                                           fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n         }"}, {"sha": "388e746cb032f9f09e5ebbc93e8dcbced642c8f4", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -54,17 +54,17 @@ fn lookup_method_purity(cstore: cstore::cstore, did: ast::def_id)\n fn each_path(cstore: cstore::cstore, cnum: ast::crate_num,\n              f: fn(decoder::path_entry) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n-    decoder::each_path(crate_data, f);\n+    decoder::each_path(cstore.intr, crate_data, f);\n }\n \n fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    let path = decoder::get_item_path(cdata, def.node);\n+    let path = decoder::get_item_path(cstore.intr, cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec::append(~[ast_map::path_mod(@cdata.name)], path)\n+    vec::append(~[ast_map::path_mod(tcx.sess.ident_of(cdata.name))], path)\n }\n \n enum found_ast {\n@@ -81,37 +81,37 @@ fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::def_id,\n     -> found_ast {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::maybe_get_item_ast(cdata, tcx, def.node,\n+    decoder::maybe_get_item_ast(cstore.intr, cdata, tcx, def.node,\n                                 decode_inlined_item)\n }\n \n fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     -> ~[ty::variant_info] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    return decoder::get_enum_variants(cdata, def.node, tcx)\n+    return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n                      name: option<ast::ident>)\n     -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    do decoder::get_impls_for_mod(cdata, def.node, name) |cnum| {\n+    do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n     }\n }\n \n fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_trait_methods(cdata, def.node, tcx)\n+    decoder::get_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n-    -> option<@DVec<(@~str, ast::self_ty_)>> {\n+    -> option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    return decoder::get_method_names_if_trait(cdata, def.node);\n+    return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n }\n \n fn get_item_attrs(cstore: cstore::cstore,\n@@ -125,7 +125,7 @@ fn get_item_attrs(cstore: cstore::cstore,\n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_fields(cdata, def.node)\n+    decoder::get_class_fields(cstore.intr, cdata, def.node)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n@@ -173,7 +173,7 @@ fn get_impl_method(cstore: cstore::cstore,\n                    def: ast::def_id, mname: ast::ident)\n     -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_impl_method(cdata, def.node, mname)\n+    decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n /* Because classes use the trait format rather than the impl format\n@@ -184,7 +184,7 @@ fn get_class_method(cstore: cstore::cstore,\n                     def: ast::def_id, mname: ast::ident)\n     -> ast::def_id {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_method(cdata, def.node, mname)\n+    decoder::get_class_method(cstore.intr, cdata, def.node, mname)\n }\n \n /* If def names a class with a dtor, return it. Otherwise, return none. */"}, {"sha": "56ea0f028f6a910f3658acdd561a400bd2d17af1", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -5,6 +5,7 @@ import std::map;\n import std::map::hashmap;\n import syntax::{ast, attr};\n import syntax::ast_util::new_def_hash;\n+import syntax::parse::token::ident_interner;\n \n export cstore;\n export cnum_map;\n@@ -57,7 +58,8 @@ type cstore_private =\n       mod_path_map: mod_path_map,\n       mut used_crate_files: ~[~str],\n       mut used_libraries: ~[~str],\n-      mut used_link_args: ~[~str]};\n+      mut used_link_args: ~[~str],\n+      intr: ident_interner};\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n@@ -67,36 +69,37 @@ pure fn p(cstore: cstore) -> cstore_private {\n     match cstore { private(p) => p }\n }\n \n-fn mk_cstore() -> cstore {\n+fn mk_cstore(intr: ident_interner) -> cstore {\n     let meta_cache = map::int_hash::<crate_metadata>();\n     let crate_map = map::int_hash::<ast::crate_num>();\n     let mod_path_map = new_def_hash();\n     return private(@{metas: meta_cache,\n-                  use_crate_map: crate_map,\n-                  mod_path_map: mod_path_map,\n-                  mut used_crate_files: ~[],\n-                  mut used_libraries: ~[],\n-                  mut used_link_args: ~[]});\n+                     use_crate_map: crate_map,\n+                     mod_path_map: mod_path_map,\n+                     mut used_crate_files: ~[],\n+                     mut used_libraries: ~[],\n+                     mut used_link_args: ~[],\n+                     intr: intr});\n }\n \n fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n     return p(cstore).metas.get(cnum);\n }\n \n-fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> @~str {\n+fn get_crate_hash(cstore: cstore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_hash(cdata.data);\n }\n \n-fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> @~str {\n+fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_vers(cdata.data);\n }\n \n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n-    do vec::iter(decoder::get_crate_module_paths(data)) |dp| {\n+    do vec::iter(decoder::get_crate_module_paths(cstore.intr, data)) |dp| {\n         let (did, path) = dp;\n         let d = {crate: cnum, node: did.node};\n         p(cstore).mod_path_map.insert(d, @path);\n@@ -153,32 +156,29 @@ fn find_use_stmt_cnum(cstore: cstore,\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-fn get_dep_hashes(cstore: cstore) -> ~[@~str] {\n-    type crate_hash = {name: @~str, hash: @~str};\n+fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n+    type crate_hash = {name: ~str, hash: ~str};\n     let mut result = ~[];\n \n     for p(cstore).use_crate_map.each_value |cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        debug!{\"Add hash[%s]: %s\", cdata.name, *hash};\n-        vec::push(result, {name: @cdata.name, hash: hash});\n+        debug!{\"Add hash[%s]: %s\", cdata.name, hash};\n+        vec::push(result, {name: cdata.name, hash: hash});\n     };\n-    pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {\n-        *a.name <= *b.name\n-    }\n+    pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n     let sorted = std::sort::merge_sort(lteq, result);\n     debug!{\"sorted:\"};\n     for sorted.each |x| {\n-        debug!{\"  hash[%s]: %s\", *x.name, *x.hash};\n+        debug!{\"  hash[%s]: %s\", x.name, x.hash};\n     }\n-    fn mapper(ch: crate_hash) -> @~str { return ch.hash; }\n+    fn mapper(ch: crate_hash) -> ~str { return ch.hash; }\n     return vec::map(sorted, mapper);\n }\n \n-fn get_path(cstore: cstore, d: ast::def_id) -> ~[ast::ident] {\n-    // let f = bind str::split_str(_, \"::\");\n+fn get_path(cstore: cstore, d: ast::def_id) -> ~[~str] {\n     option::map_default(p(cstore).mod_path_map.find(d), ~[],\n-                        |ds| str::split_str(*ds, ~\"::\").map(|x| @x ) )\n+                        |ds| str::split_str(*ds, ~\"::\"))\n }\n // Local Variables:\n // mode: rust"}, {"sha": "d9bec9fc5b29a0df641c254114dedad25b339308", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 78, "deletions": 67, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -15,6 +15,8 @@ import cmd=cstore::crate_metadata;\n import util::ppaux::ty_to_str;\n import syntax::diagnostic::span_handler;\n import common::*;\n+import syntax::parse::token::ident_interner;\n+\n \n export class_dtor;\n export get_class_fields;\n@@ -212,7 +214,7 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n     return ids;\n }\n \n-fn item_path(item_doc: ebml::doc) -> ast_map::path {\n+fn item_path(intr: ident_interner, item_doc: ebml::doc) -> ast_map::path {\n     let path_doc = ebml::get_doc(item_doc, tag_path);\n \n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n@@ -224,10 +226,10 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     for ebml::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);\n-            vec::push(result, ast_map::path_mod(@str));\n+            vec::push(result, ast_map::path_mod(intr.intern(@str)));\n         } else if tag == tag_path_elt_name {\n             let str = ebml::doc_as_str(elt_doc);\n-            vec::push(result, ast_map::path_name(@str));\n+            vec::push(result, ast_map::path_name(intr.intern(@str)));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -236,9 +238,9 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     return result;\n }\n \n-fn item_name(item: ebml::doc) -> ast::ident {\n+fn item_name(intr: ident_interner, item: ebml::doc) -> ast::ident {\n     let name = ebml::get_doc(item, tag_paths_data_name);\n-    @str::from_bytes(ebml::doc_data(name))\n+    intr.intern(@str::from_bytes(ebml::doc_data(name)))\n }\n \n fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n@@ -304,37 +306,38 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n     item_impl_traits(lookup_item(id, cdata.data), tcx, cdata)\n }\n \n-fn get_impl_method(cdata: cmd, id: ast::node_id,\n+fn get_impl_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n     for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n         let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n-        if item_name(find_item(m_did.node, items)) == name {\n+        if item_name(intr, find_item(m_did.node, items)) == name {\n             found = some(translate_def_id(cdata, m_did));\n         }\n     }\n     option::get(found)\n }\n \n-fn get_class_method(cdata: cmd, id: ast::node_id,\n+fn get_class_method(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let mut found = none;\n     let cls_items = match maybe_find_item(id, items) {\n       some(it) => it,\n       none => fail (fmt!{\"get_class_method: class id not found \\\n-                              when looking up method %s\", *name})\n+                              when looking up method %s\", *intr.get(name)})\n     };\n     for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n-        if item_name(mid) == name {\n+        if item_name(intr, mid) == name {\n             found = some(m_did);\n         }\n     }\n     match found {\n       some(found) => found,\n-      none => fail (fmt!{\"get_class_method: no method named %s\", *name})\n+      none => fail (fmt!{\"get_class_method: no method named %s\",\n+                         *intr.get(name)})\n     }\n }\n \n@@ -387,7 +390,7 @@ struct path_entry {\n }\n \n /// Iterates over all the paths in the given crate.\n-fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n+fn each_path(intr: ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n     let root = ebml::doc(cdata.data);\n     let items = ebml::get_doc(root, tag_items);\n     let items_data = ebml::get_doc(items, tag_items_data);\n@@ -397,8 +400,8 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n     // First, go through all the explicit items.\n     for ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n-            let path = ast_map::path_to_str_with_sep(item_path(item_doc),\n-                                                     ~\"::\");\n+            let path = ast_map::path_to_str_with_sep(\n+                item_path(intr, item_doc), ~\"::\", intr);\n             if path != ~\"\" {\n                 // Extract the def ID.\n                 let def_id = item_def_id(item_doc, cdata);\n@@ -467,8 +470,9 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n     }\n }\n \n-fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n-    item_path(lookup_item(id, cdata.data))\n+fn get_item_path(intr: ident_interner, cdata: cmd, id: ast::node_id)\n+    -> ast_map::path {\n+    item_path(intr, lookup_item(id, cdata.data))\n }\n \n type decode_inlined_item = fn(\n@@ -477,13 +481,13 @@ type decode_inlined_item = fn(\n     path: ast_map::path,\n     par_doc: ebml::doc) -> option<ast::inlined_item>;\n \n-fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n+fn maybe_get_item_ast(intr: ident_interner, cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n                       decode_inlined_item: decode_inlined_item\n                      ) -> csearch::found_ast {\n     debug!{\"Looking up item: %d\", id};\n     let item_doc = lookup_item(id, cdata.data);\n-    let path = vec::init(item_path(item_doc));\n+    let path = vec::init(item_path(intr, item_doc));\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n       some(ii) => csearch::found(ii),\n       none => {\n@@ -503,8 +507,8 @@ fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n     }\n }\n \n-fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> ~[ty::variant_info] {\n+fn get_enum_variants(intr: ident_interner, cdata: cmd, id: ast::node_id,\n+                     tcx: ty::ctxt) -> ~[ty::variant_info] {\n     let data = cdata.data;\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     let item = find_item(id, items);\n@@ -515,7 +519,7 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type({crate: cdata.cnum, node: id}, item,\n                                 tcx, cdata);\n-        let name = item_name(item);\n+        let name = item_name(intr, item);\n         let mut arg_tys: ~[ty::t] = ~[];\n         match ty::get(ctor_ty).struct {\n           ty::ty_fn(f) => {\n@@ -573,8 +577,8 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n     }\n }\n \n-fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n-    -> ~[@method_info] {\n+fn item_impl_methods(intr: ident_interner, cdata: cmd, item: ebml::doc,\n+                     base_tps: uint) -> ~[@method_info] {\n     let mut rslt = ~[];\n     for ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n         let m_did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n@@ -583,15 +587,14 @@ fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n         vec::push(rslt, @{did: translate_def_id(cdata, m_did),\n                     /* FIXME (maybe #2323) tjc: take a look at this. */\n                    n_tps: item_ty_param_count(mth_item) - base_tps,\n-                   ident: item_name(mth_item),\n+                   ident: item_name(intr, mth_item),\n                    self_type: self_ty});\n     }\n     rslt\n }\n \n-fn get_impls_for_mod(cdata: cmd,\n-                     m_id: ast::node_id,\n-                     name: option<ast::ident>,\n+fn get_impls_for_mod(intr: ident_interner, cdata: cmd,\n+                     m_id: ast::node_id, name: option<ast::ident>,\n                      get_cdata: fn(ast::crate_num) -> cmd)\n                   -> @~[@_impl] {\n \n@@ -608,27 +611,27 @@ fn get_impls_for_mod(cdata: cmd,\n         let impl_cdata = get_cdata(local_did.crate);\n         let impl_data = impl_cdata.data;\n         let item = lookup_item(local_did.node, impl_data);\n-        let nm = item_name(item);\n+        let nm = item_name(intr, item);\n         if match name { some(n) => { n == nm } none => { true } } {\n            let base_tps = item_ty_param_count(item);\n            vec::push(result, @{\n                 did: local_did, ident: nm,\n-                methods: item_impl_methods(impl_cdata, item, base_tps)\n+                methods: item_impl_methods(intr, impl_cdata, item, base_tps)\n             });\n         };\n     }\n     @result\n }\n \n /* Works for both classes and traits */\n-fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> @~[ty::method] {\n+fn get_trait_methods(intr: ident_interner, cdata: cmd, id: ast::node_id,\n+                     tcx: ty::ctxt) -> @~[ty::method] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n-        let name = item_name(mth);\n+        let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n         let fty = match ty::get(ty).struct {\n           ty::ty_fn(f) => f,\n@@ -651,8 +654,9 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n // If the item in question is a trait, returns its set of methods and\n // their self types. Otherwise, returns none. This overlaps in an\n // annoying way with get_trait_methods.\n-fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n-                          -> option<@DVec<(@~str, ast::self_ty_)>> {\n+fn get_method_names_if_trait(intr: ident_interner, cdata: cmd,\n+                             node_id: ast::node_id)\n+                          -> option<@DVec<(ast::ident, ast::self_ty_)>> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != 'I' {\n@@ -662,7 +666,7 @@ fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n     let resulting_methods = @dvec();\n     for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n-            (item_name(method), get_self_ty(method)));\n+            (item_name(intr, method), get_self_ty(method)));\n     }\n     return some(resulting_methods);\n }\n@@ -680,15 +684,15 @@ fn get_item_attrs(cdata: cmd,\n }\n \n // Helper function that gets either fields or methods\n-fn get_class_members(cdata: cmd, id: ast::node_id,\n+fn get_class_members(intr: ident_interner, cdata: cmd, id: ast::node_id,\n                      p: fn(char) -> bool) -> ~[ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     for ebml::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n-          let name = item_name(an_item);\n+          let name = item_name(intr, an_item);\n           let did = item_def_id(an_item, cdata);\n           let mt = field_mutability(an_item);\n           vec::push(result, {ident: name, id: did, vis:\n@@ -708,8 +712,9 @@ pure fn family_to_visibility(family: char) -> ast::visibility {\n }\n \n /* 'g' for public field, 'j' for private field, 'N' for inherited field */\n-fn get_class_fields(cdata: cmd, id: ast::node_id) -> ~[ty::field_ty] {\n-    get_class_members(cdata, id, |f| f == 'g' || f == 'j' || f == 'N')\n+fn get_class_fields(intr: ident_interner, cdata: cmd, id: ast::node_id)\n+    -> ~[ty::field_ty] {\n+    get_class_members(intr, cdata, id, |f| f == 'g' || f == 'j' || f == 'N')\n }\n \n fn family_has_type_params(fam_ch: char) -> bool {\n@@ -774,7 +779,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n     for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n-        vec::push(items, attr::mk_word_item(@n));\n+        vec::push(items, attr::mk_word_item(n));\n     };\n     for ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -783,13 +788,13 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n         let v = str::from_bytes(ebml::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        vec::push(items, attr::mk_name_value_item_str(@n, v));\n+        vec::push(items, attr::mk_name_value_item_str(n, v));\n     };\n     for ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n-        vec::push(items, attr::mk_list_item(@n, subitems));\n+        vec::push(items, attr::mk_list_item(n, subitems));\n     };\n     return items;\n }\n@@ -815,17 +820,19 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     return attrs;\n }\n \n-fn list_meta_items(meta_items: ebml::doc, out: io::Writer) {\n+fn list_meta_items(intr: ident_interner,\n+                   meta_items: ebml::doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n-        out.write_str(fmt!{\"%s\\n\", pprust::meta_item_to_str(*mi)});\n+        out.write_str(fmt!{\"%s\\n\", pprust::meta_item_to_str(*mi, intr)});\n     }\n }\n \n-fn list_crate_attributes(md: ebml::doc, hash: @~str, out: io::Writer) {\n-    out.write_str(fmt!{\"=Crate Attributes (%s)=\\n\", *hash});\n+fn list_crate_attributes(intr: ident_interner, md: ebml::doc, hash: ~str,\n+                         out: io::Writer) {\n+    out.write_str(fmt!{\"=Crate Attributes (%s)=\\n\", hash});\n \n     for get_attributes(md).each |attr| {\n-        out.write_str(fmt!{\"%s\\n\", pprust::attribute_to_str(attr)});\n+        out.write_str(fmt!{\"%s\\n\", pprust::attribute_to_str(attr, intr)});\n     }\n \n     out.write_str(~\"\\n\\n\");\n@@ -836,9 +843,9 @@ fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n-                  vers: @~str, hash: @~str};\n+                  vers: ~str, hash: ~str};\n \n-fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n+fn get_crate_deps(intr: ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n     let cratedoc = ebml::doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n@@ -848,42 +855,44 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     }\n     for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         vec::push(deps, {cnum: crate_num,\n-                  name: @docstr(depdoc, tag_crate_dep_name),\n-                  vers: @docstr(depdoc, tag_crate_dep_vers),\n-                  hash: @docstr(depdoc, tag_crate_dep_hash)});\n+                  name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n+                  vers: docstr(depdoc, tag_crate_dep_vers),\n+                  hash: docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: io::Writer) {\n+fn list_crate_deps(intr: ident_interner, data: @~[u8], out: io::Writer) {\n     out.write_str(~\"=External Dependencies=\\n\");\n \n-    for get_crate_deps(data).each |dep| {\n-        out.write_str(fmt!{\"%d %s-%s-%s\\n\",\n-                           dep.cnum, *dep.name, *dep.hash, *dep.vers});\n+    for get_crate_deps(intr, data).each |dep| {\n+        out.write_str(\n+            fmt!{\"%d %s-%s-%s\\n\",\n+                 dep.cnum, *intr.get(dep.name), dep.hash, dep.vers});\n     }\n \n     out.write_str(~\"\\n\");\n }\n \n-fn get_crate_hash(data: @~[u8]) -> @~str {\n+fn get_crate_hash(data: @~[u8]) -> ~str {\n     let cratedoc = ebml::doc(data);\n     let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    return @str::from_bytes(ebml::doc_data(hashdoc));\n+    return str::from_bytes(ebml::doc_data(hashdoc));\n }\n \n-fn get_crate_vers(data: @~[u8]) -> @~str {\n+fn get_crate_vers(data: @~[u8]) -> ~str {\n     let attrs = decoder::get_crate_attributes(data);\n     return match attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), ~\"vers\") {\n       some(ver) => ver,\n-      none => @~\"0.0\"\n+      none => ~\"0.0\"\n     };\n }\n \n-fn iter_crate_items(cdata: cmd, proc: fn(~str, ast::def_id)) {\n-    for each_path(cdata) |path_entry| {\n+fn iter_crate_items(intr: ident_interner,\n+                    cdata: cmd, proc: fn(~str, ast::def_id)) {\n+    for each_path(intr, cdata) |path_entry| {\n         match path_entry.def_like {\n             dl_impl(*) | dl_field => {}\n             dl_def(def) => {\n@@ -893,7 +902,8 @@ fn iter_crate_items(cdata: cmd, proc: fn(~str, ast::def_id)) {\n     }\n }\n \n-fn get_crate_module_paths(cdata: cmd) -> ~[(ast::def_id, ~str)] {\n+fn get_crate_module_paths(intr: ident_interner, cdata: cmd)\n+                                    -> ~[(ast::def_id, ~str)] {\n     fn mod_of_path(p: ~str) -> ~str {\n         str::connect(vec::init(str::split_str(p, ~\"::\")), ~\"::\")\n     }\n@@ -902,7 +912,7 @@ fn get_crate_module_paths(cdata: cmd) -> ~[(ast::def_id, ~str)] {\n     // fowarded path due to renamed import or reexport\n     let mut res = ~[];\n     let mods = map::str_hash();\n-    do iter_crate_items(cdata) |path, did| {\n+    do iter_crate_items(intr, cdata) |path, did| {\n         let m = mod_of_path(path);\n         if str::is_not_empty(m) {\n             // if m has a sub-item, it must be a module\n@@ -919,11 +929,12 @@ fn get_crate_module_paths(cdata: cmd) -> ~[(ast::def_id, ~str)] {\n     }\n }\n \n-fn list_crate_metadata(bytes: @~[u8], out: io::Writer) {\n+fn list_crate_metadata(intr: ident_interner, bytes: @~[u8],\n+                       out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = ebml::doc(bytes);\n-    list_crate_attributes(md, hash, out);\n-    list_crate_deps(bytes, out);\n+    list_crate_attributes(intr, md, hash, out);\n+    list_crate_deps(intr, bytes, out);\n }\n \n // Translates a def_id from an external crate to a def_id for the current"}, {"sha": "e14e64ddd0c6a399cac431288d0bb104c347ea95", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 92, "deletions": 78, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -71,8 +71,8 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ebml_w: ebml::writer, name: ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, *name);\n+fn encode_name(ecx: @encode_ctxt, ebml_w: ebml::writer, name: ident) {\n+    ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n@@ -97,13 +97,15 @@ fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ebml_w: ebml::writer, path: &[ident], &index: ~[entry<~str>],\n-                name: ident) {\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::writer, path: &[ident],\n+                &index: ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     vec::push_all(full_path, path);\n     vec::push(full_path, name);\n-    vec::push(index, {val: ast_util::path_name_i(full_path),\n-                      pos: ebml_w.writer.tell()});\n+    vec::push(index,\n+              {val: ast_util::path_name_i(full_path,\n+                                          ecx.tcx.sess.parse_sess.interner),\n+               pos: ebml_w.writer.tell()});\n }\n \n fn encode_trait_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @trait_ref) {\n@@ -209,7 +211,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(variant.node.id));\n         encode_family(ebml_w, 'v');\n-        encode_name(ebml_w, variant.node.name);\n+        encode_name(ecx, ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_type(ecx.tcx, variant.node.id));\n@@ -227,29 +229,29 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             disr_val = vi[i].disr_val;\n         }\n         encode_type_param_bounds(ebml_w, ecx, ty_params);\n-        encode_path(ebml_w, path, ast_map::path_name(variant.node.name));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n     }\n }\n \n-fn encode_path(ebml_w: ebml::writer,\n-               path: ast_map::path,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::writer, path: ast_map::path,\n                name: ast_map::path_elt) {\n-    fn encode_path_elt(ebml_w: ebml::writer, elt: ast_map::path_elt) {\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                       elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n           ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n \n-        ebml_w.wr_tagged_str(tag, *name);\n+        ebml_w.wr_tagged_str(tag, ecx.tcx.sess.str_of(name));\n     }\n \n     do ebml_w.wr_tag(tag_path) {\n         ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n-        do vec::iter(path) |pe| { encode_path_elt(ebml_w, pe); }\n-        encode_path_elt(ebml_w, name);\n+        do vec::iter(path) |pe| { encode_path_elt(ecx, ebml_w, pe); }\n+        encode_path_elt(ecx, ebml_w, name);\n     }\n }\n \n@@ -258,7 +260,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n-    encode_name(ebml_w, name);\n+    encode_name(ecx, ebml_w, name);\n     debug!{\"(encoding info for module) encoding info for module ID %d\", id};\n \n     // Encode info about all the module children.\n@@ -268,10 +270,11 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n                 let (ident, did) = (item.ident, item.id);\n                 debug!{\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?), exported? %?\",\n-                       *ident,\n-                       did,\n-                       ast_map::node_id_to_str(ecx.tcx.items, did),\n-                       ast_util::is_exported(ident, md)};\n+                        ecx.tcx.sess.str_of(ident),\n+                        did,\n+                        ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n+                                                .sess.parse_sess.interner),\n+                        ast_util::is_exported(ident, md)};\n \n                 ebml_w.start_tag(tag_mod_impl);\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n@@ -281,7 +284,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n         }\n     }\n \n-    encode_path(ebml_w, path, ast_map::path_mod(name));\n+    encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n \n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n@@ -371,10 +374,11 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 vec::push(*global_index, {val: id,\n                                           pos: ebml_w.writer.tell()});\n                 ebml_w.start_tag(tag_items_data_item);\n-                debug!{\"encode_info_for_class: doing %s %d\", *nm, id};\n+                debug!{\"encode_info_for_class: doing %s %d\",\n+                       tcx.sess.str_of(nm), id};\n                 encode_visibility(ebml_w, vis);\n-                encode_name(ebml_w, nm);\n-                encode_path(ebml_w, path, ast_map::path_name(nm));\n+                encode_name(ecx, ebml_w, nm);\n+                encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n                 encode_mutability(ebml_w, mt);\n                 encode_def_id(ebml_w, local_def(id));\n@@ -392,7 +396,8 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           {val: m.id, pos: ebml_w.writer.tell()});\n                 let impl_path = vec::append_one(path,\n                                                 ast_map::path_name(m.ident));\n-                debug!{\"encode_info_for_class: doing %s %d\", *m.ident, m.id};\n+                debug!{\"encode_info_for_class: doing %s %d\",\n+                       ecx.tcx.sess.str_of(m.ident), m.id};\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n                                        should_inline(m.attrs), id, m,\n                                        vec::append(class_tps, m.tps));\n@@ -409,15 +414,16 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                       item: option<inlined_item>, tps: ~[ty_param],\n                       decl: fn_decl) {\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_name(ebml_w, ident);\n+        encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n-        debug!{\"fn name = %s ty = %s its node id = %d\", *ident,\n+        debug!{\"fn name = %s ty = %s its node id = %d\",\n+               ecx.tcx.sess.str_of(ident),\n                util::ppaux::ty_to_str(ecx.tcx, its_ty), id};\n         encode_type(ecx, ebml_w, its_ty);\n-        encode_path(ebml_w, path, ast_map::path_name(ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n            some(it) => {\n              ecx.encode_inlined_item(ecx, ebml_w, path, it);\n@@ -433,14 +439,15 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n-    debug!{\"encode_info_for_method: %d %s %u\", m.id, *m.ident, all_tps.len()};\n+    debug!{\"encode_info_for_method: %d %s %u\", m.id,\n+           ecx.tcx.sess.str_of(m.ident), all_tps.len()};\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     encode_family(ebml_w, purity_fn_family(m.decl.purity));\n     encode_type_param_bounds(ebml_w, ecx, all_tps);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n-    encode_name(ebml_w, m.ident);\n-    encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n+    encode_name(ecx, ebml_w, m.ident);\n+    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n     encode_self_type(ebml_w, m.self_ty.node);\n     if all_tps.len() > 0u || should_inline {\n         ecx.encode_inlined_item(\n@@ -504,7 +511,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n       item_fn(decl, tps, _) => {\n@@ -514,7 +521,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         if tps.len() > 0u || should_inline(item.attrs) {\n             ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n         } else {\n@@ -531,8 +538,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n-        encode_name(ebml_w, item.ident);\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n       item_ty(_, tps) => {\n@@ -542,8 +549,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_family(ebml_w, 'y');\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ebml_w, item.ident);\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n@@ -554,12 +561,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_family(ebml_w, 't');\n             encode_type_param_bounds(ebml_w, ecx, tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-            encode_name(ebml_w, item.ident);\n+            encode_name(ecx, ebml_w, item.ident);\n             for enum_definition.variants.each |v| {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n             ecx.encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n-            encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n             encode_region_param(ecx, ebml_w, item);\n         }\n         encode_enum_variant_info(ecx, ebml_w, item.id,\n@@ -576,10 +583,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         /* Encode the dtor */\n         do option::iter(struct_def.dtor) |dtor| {\n             vec::push(*index, {val: dtor.node.id, pos: ebml_w.writer.tell()});\n-          encode_info_for_fn(ecx, ebml_w, dtor.node.id, @(*item.ident\n-                             + ~\"_dtor\"), path, if tps.len() > 0u {\n-                               some(ii_dtor(dtor, item.ident, tps,\n-                                            local_def(item.id))) }\n+          encode_info_for_fn(ecx, ebml_w, dtor.node.id,\n+                             ecx.tcx.sess.ident_of(\n+                                 ecx.tcx.sess.str_of(item.ident) + ~\"_dtor\"),\n+                             path, if tps.len() > 0u {\n+                                 some(ii_dtor(dtor, item.ident, tps,\n+                                              local_def(item.id))) }\n                              else { none }, tps, ast_util::dtor_dec());\n         }\n \n@@ -596,8 +605,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ebml_w, item.ident);\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_name(ecx, ebml_w, item.ident);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         for struct_def.traits.each |t| {\n            encode_trait_ref(ebml_w, ecx, t);\n@@ -618,7 +627,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 named_field(ident, mutability, vis) => {\n                    ebml_w.start_tag(tag_item_field);\n                    encode_visibility(ebml_w, vis);\n-                   encode_name(ebml_w, ident);\n+                   encode_name(ecx, ebml_w, ident);\n                    encode_def_id(ebml_w, local_def(f.node.id));\n                    ebml_w.end_tag();\n                 }\n@@ -634,7 +643,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                    as a trait */\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_family(ebml_w, purity_fn_family(m.decl.purity));\n-                encode_name(ebml_w, m.ident);\n+                encode_name(ecx, ebml_w, m.ident);\n                 encode_type_param_bounds(ebml_w, ecx, m.tps);\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n                 encode_def_id(ebml_w, local_def(m.id));\n@@ -655,8 +664,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n         /* Encode the constructor */\n         for struct_def.ctor.each |ctor| {\n-            debug!{\"encoding info for ctor %s %d\", *item.ident,\n-                   ctor.node.id};\n+            debug!{\"encoding info for ctor %s %d\",\n+                   ecx.tcx.sess.str_of(item.ident), ctor.node.id};\n             vec::push(*index, {\n                 val: ctor.node.id,\n                 pos: ebml_w.writer.tell()\n@@ -676,7 +685,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_region_param(ecx, ebml_w, item);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ebml_w, item.ident);\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         for methods.each |m| {\n             ebml_w.start_tag(tag_item_impl_method);\n@@ -689,7 +698,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         for traits.each |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, associated_trait)\n         }\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n         let impl_path = vec::append_one(path,\n@@ -709,15 +718,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_region_param(ecx, ebml_w, item);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_name(ebml_w, item.ident);\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n             match ms[i] {\n               required(ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_def_id(ebml_w, local_def(ty_m.id));\n-                encode_name(ebml_w, mty.ident);\n+                encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, ty_m.tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.purity));\n@@ -732,7 +741,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             }\n             i += 1u;\n         }\n-        encode_path(ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         for traits.each |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, associated_trait)\n         }\n@@ -750,13 +759,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n \n             ebml_w.start_tag(tag_items_data_item);\n             encode_def_id(ebml_w, local_def(ty_m.id));\n-            encode_name(ebml_w, ty_m.ident);\n+            encode_name(ecx, ebml_w, ty_m.ident);\n             encode_family(ebml_w,\n                           purity_static_method_family(ty_m.decl.purity));\n             let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n             encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n             encode_type(ecx, ebml_w, polyty.ty);\n-            encode_path(ebml_w, path, ast_map::path_name(ty_m.ident));\n+            encode_path(ecx, ebml_w, path, ast_map::path_name(ty_m.ident));\n             ebml_w.end_tag();\n         }\n \n@@ -786,7 +795,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n-        encode_path(ebml_w, path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n     ebml_w.end_tag();\n@@ -798,7 +807,8 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml_w.start_tag(tag_items_data);\n     vec::push(*index, {val: crate_node_id, pos: ebml_w.writer.tell()});\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n-                        crate_node_id, ~[], @~\"\");\n+                        crate_node_id, ~[],\n+                        syntax::parse::token::special_idents::invalid);\n     visit::visit_crate(*crate, (), visit::mk_vt(@{\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: |i, cx, v, copy ebml_w| {\n@@ -883,7 +893,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::bytes(*name));\n+        ebml_w.writer.write(str::bytes(name));\n         ebml_w.end_tag();\n         ebml_w.end_tag();\n       }\n@@ -892,7 +902,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n           lit_str(value) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n-            ebml_w.writer.write(str::bytes(*name));\n+            ebml_w.writer.write(str::bytes(name));\n             ebml_w.end_tag();\n             ebml_w.start_tag(tag_meta_item_value);\n             ebml_w.writer.write(str::bytes(*value));\n@@ -905,7 +915,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n       meta_list(name, items) => {\n         ebml_w.start_tag(tag_meta_item_list);\n         ebml_w.start_tag(tag_meta_item_name);\n-        ebml_w.writer.write(str::bytes(*name));\n+        ebml_w.writer.write(str::bytes(name));\n         ebml_w.end_tag();\n         for items.each |inner_item| {\n             encode_meta_item(ebml_w, *inner_item);\n@@ -934,22 +944,22 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     fn synthesize_link_attr(ecx: @encode_ctxt, items: ~[@meta_item]) ->\n        attribute {\n \n-        assert (*ecx.link_meta.name != ~\"\");\n-        assert (*ecx.link_meta.vers != ~\"\");\n+        assert (ecx.link_meta.name != ~\"\");\n+        assert (ecx.link_meta.vers != ~\"\");\n \n         let name_item =\n-            attr::mk_name_value_item_str(@~\"name\", *ecx.link_meta.name);\n+            attr::mk_name_value_item_str(~\"name\", ecx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(@~\"vers\", *ecx.link_meta.vers);\n+            attr::mk_name_value_item_str(~\"vers\", ecx.link_meta.vers);\n \n         let other_items =\n             {\n-                let tmp = attr::remove_meta_items_by_name(items, @~\"name\");\n-                attr::remove_meta_items_by_name(tmp, @~\"vers\")\n+                let tmp = attr::remove_meta_items_by_name(items, ~\"name\");\n+                attr::remove_meta_items_by_name(tmp, ~\"vers\")\n             };\n \n         let meta_items = vec::append(~[name_item, vers_item], other_items);\n-        let link_item = attr::mk_list_item(@~\"link\", meta_items);\n+        let link_item = attr::mk_list_item(~\"link\", meta_items);\n \n         return attr::mk_attr(link_item);\n     }\n@@ -959,7 +969,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     for crate.node.attrs.each |attr| {\n         vec::push(\n             attrs,\n-            if *attr::get_attr_name(attr) != ~\"link\" {\n+            if attr::get_attr_name(attr) != ~\"link\" {\n                 attr\n             } else {\n                 match attr.node.value.node {\n@@ -977,16 +987,19 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                     cstore: cstore::cstore) {\n+\n+    fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::cstore)\n+        -> ~[decoder::crate_dep] {\n \n-    fn get_ordered_deps(cstore: cstore::cstore) -> ~[decoder::crate_dep] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n         type numdep = decoder::crate_dep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps: ~[mut numdep] = ~[mut];\n         do cstore::iter_crate_data(cstore) |key, val| {\n-            let dep = {cnum: key, name: @val.name,\n+            let dep = {cnum: key, name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             vec::push(deps, dep);\n@@ -1014,22 +1027,23 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n     // FIXME (#2166): This is not nearly enough to support correct versioning\n     // but is enough to get transitive crate dependencies working.\n     ebml_w.start_tag(tag_crate_deps);\n-    for get_ordered_deps(cstore).each |dep| {\n-        encode_crate_dep(ebml_w, dep);\n+    for get_ordered_deps(ecx, cstore).each |dep| {\n+        encode_crate_dep(ecx, ebml_w, dep);\n     }\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ebml_w: ebml::writer, dep: decoder::crate_dep) {\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                    dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::bytes(*dep.name));\n+    ebml_w.writer.write(str::bytes(ecx.tcx.sess.str_of(dep.name)));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n-    ebml_w.writer.write(str::bytes(*dep.vers));\n+    ebml_w.writer.write(str::bytes(dep.vers));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_hash);\n-    ebml_w.writer.write(str::bytes(*dep.hash));\n+    ebml_w.writer.write(str::bytes(dep.hash));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -1064,7 +1078,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n     let crate_attrs = synthesize_crate_attrs(ecx, crate);\n     encode_attributes(ebml_w, crate_attrs);\n \n-    encode_crate_deps(ebml_w, ecx.cstore);\n+    encode_crate_deps(ecx, ebml_w, ecx.cstore);\n \n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);"}, {"sha": "d4b66a7e4ec872063d19ec393e590fd5f3a054f1", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -7,6 +7,7 @@ import syntax::codemap::span;\n import lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n import filesearch::filesearch;\n import io::WriterUtil;\n+import syntax::parse::token::ident_interner;\n \n export os;\n export os_macos, os_win32, os_linux, os_freebsd;\n@@ -33,15 +34,17 @@ type ctxt = {\n     metas: ~[@ast::meta_item],\n     hash: ~str,\n     os: os,\n-    static: bool\n+    static: bool,\n+    intr: ident_interner\n };\n \n fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n     match find_library_crate(cx) {\n       some(t) => return t,\n       none => {\n         cx.diag.span_fatal(\n-            cx.span, fmt!{\"can't find crate for `%s`\", *cx.ident});\n+            cx.span, fmt!{\"can't find crate for `%s`\",\n+                          *cx.intr.get(cx.ident)});\n       }\n     }\n }\n@@ -66,7 +69,7 @@ fn find_library_crate_aux(cx: ctxt,\n                           filesearch: filesearch::filesearch) ->\n    option<{ident: ~str, data: @~[u8]}> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix: ~str = nn.prefix + *crate_name + ~\"-\";\n+    let prefix: ~str = nn.prefix + crate_name + ~\"-\";\n     let suffix: ~str = nn.suffix;\n \n     let mut matches = ~[];\n@@ -104,19 +107,19 @@ fn find_library_crate_aux(cx: ctxt,\n         some(matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, fmt!{\"multiple matching crates for `%s`\", *crate_name});\n+            cx.span, fmt!{\"multiple matching crates for `%s`\", crate_name});\n         cx.diag.handler().note(~\"candidates:\");\n         for matches.each |match_| {\n             cx.diag.handler().note(fmt!{\"path: %s\", match_.ident});\n             let attrs = decoder::get_crate_attributes(match_.data);\n-            note_linkage_attrs(cx.diag, attrs);\n+            note_linkage_attrs(cx.intr, cx.diag, attrs);\n         }\n         cx.diag.handler().abort_if_errors();\n         none\n     }\n }\n \n-fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @~str {\n+fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> ~str {\n     let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n     match vec::last_opt(name_items) {\n       some(i) => {\n@@ -131,9 +134,10 @@ fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @~str {\n     }\n }\n \n-fn note_linkage_attrs(diag: span_handler, attrs: ~[ast::attribute]) {\n+fn note_linkage_attrs(intr: ident_interner, diag: span_handler,\n+                      attrs: ~[ast::attribute]) {\n     for attr::find_linkage_attrs(attrs).each |attr| {\n-        diag.handler().note(fmt!{\"meta: %s\", pprust::attr_to_str(attr)});\n+        diag.handler().note(fmt!{\"meta: %s\", pprust::attr_to_str(attr,intr)});\n     }\n }\n \n@@ -143,7 +147,7 @@ fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if hash.is_not_empty() {\n         let chash = decoder::get_crate_hash(crate_data);\n-        if *chash != hash { return false; }\n+        if chash != hash { return false; }\n     }\n     metadata_matches(linkage_metas, metas)\n }\n@@ -154,15 +158,8 @@ fn metadata_matches(extern_metas: ~[@ast::meta_item],\n     debug!{\"matching %u metadata requirements against %u items\",\n            vec::len(local_metas), vec::len(extern_metas)};\n \n-    debug!{\"crate metadata:\"};\n-    for extern_metas.each |have| {\n-        debug!{\"  %s\", pprust::meta_item_to_str(*have)};\n-    }\n-\n     for local_metas.each |needed| {\n-        debug!{\"looking for %s\", pprust::meta_item_to_str(*needed)};\n         if !attr::contains(extern_metas, needed) {\n-            debug!{\"missing %s\", pprust::meta_item_to_str(*needed)};\n             return false;\n         }\n     }\n@@ -206,9 +203,10 @@ fn meta_section_name(os: os) -> ~str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(os: os, path: ~str, out: io::Writer) {\n+fn list_file_metadata(intr: ident_interner, os: os, path: ~str,\n+                      out: io::Writer) {\n     match get_metadata_section(os, path) {\n-      option::some(bytes) => decoder::list_crate_metadata(bytes, out),\n+      option::some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::none => {\n         out.write_str(~\"could not find metadata in \" + path + ~\".\\n\");\n       }"}, {"sha": "5b76e0da7f5eaef35bed2574474695c002f578da", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -46,7 +46,7 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n     while !is_last(peek(st)) {\n         rslt += str::from_byte(next_byte(st));\n     }\n-    return @rslt;\n+    return st.tcx.sess.ident_of(rslt);\n }\n \n \n@@ -133,7 +133,7 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n         assert next(st) == '|';\n         ty::br_anon(id)\n       }\n-      '[' => ty::br_named(@parse_str(st, ']')),\n+      '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n       'c' => {\n         let id = parse_int(st);\n         assert next(st) == '|';\n@@ -249,7 +249,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == '[');\n         let mut fields: ~[ty::field] = ~[];\n         while peek(st) != ']' {\n-            let name = @parse_str(st, '=');\n+            let name = st.tcx.sess.ident_of(parse_str(st, '='));\n             vec::push(fields, {ident: name, mt: parse_mt(st, conv)});\n         }\n         st.pos = st.pos + 1u;"}, {"sha": "4158656aa54886d5829fd731686ba4b1cf891304", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -126,14 +126,14 @@ fn enc_region(w: io::Writer, cx: @ctxt, r: ty::region) {\n     match r {\n       ty::re_bound(br) => {\n         w.write_char('b');\n-        enc_bound_region(w, br);\n+        enc_bound_region(w, cx, br);\n       }\n       ty::re_free(id, br) => {\n         w.write_char('f');\n         w.write_char('[');\n         w.write_int(id);\n         w.write_char('|');\n-        enc_bound_region(w, br);\n+        enc_bound_region(w, cx, br);\n         w.write_char(']');\n       }\n       ty::re_scope(nid) => {\n@@ -151,7 +151,7 @@ fn enc_region(w: io::Writer, cx: @ctxt, r: ty::region) {\n     }\n }\n \n-fn enc_bound_region(w: io::Writer, br: ty::bound_region) {\n+fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n     match br {\n       ty::br_self => w.write_char('s'),\n       ty::br_anon(idx) => {\n@@ -161,14 +161,14 @@ fn enc_bound_region(w: io::Writer, br: ty::bound_region) {\n       }\n       ty::br_named(s) => {\n         w.write_char('[');\n-        w.write_str(*s);\n+        w.write_str(cx.tcx.sess.str_of(s));\n         w.write_char(']')\n       }\n       ty::br_cap_avoid(id, br) => {\n         w.write_char('c');\n         w.write_int(id);\n         w.write_char('|');\n-        enc_bound_region(w, *br);\n+        enc_bound_region(w, cx, *br);\n       }\n     }\n }\n@@ -265,7 +265,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_rec(fields) => {\n         w.write_str(&\"R[\");\n         for fields.each |field| {\n-            w.write_str(*field.ident);\n+            w.write_str(cx.tcx.sess.str_of(field.ident));\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n         }"}, {"sha": "34ebeb2fe199cc1532bb8de44f1d629e31f12377", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -83,7 +83,8 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n     debug!{\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path), *ii.ident(),\n+           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n+           ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell()};\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n@@ -94,7 +95,8 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n     }\n \n     debug!{\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path), *ii.ident(),\n+           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n+           ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell()};\n }\n \n@@ -107,7 +109,8 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n     match par_doc.opt_child(c::tag_ast) {\n       none => none,\n       some(ast_doc) => {\n-        debug!{\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)};\n+        debug!{\"> Decoding inlined fn: %s::?\",\n+               ast_map::path_to_str(path, tcx.sess.parse_sess.interner)};\n         let ast_dsr = ebml::ebml_deserializer(ast_doc);\n         let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n@@ -118,14 +121,15 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         let ii = renumber_ast(xcx, raw_ii);\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, ii);\n-        debug!{\"Fn named: %s\", *ii.ident()};\n+        debug!{\"Fn named: %s\", tcx.sess.str_of(ii.ident())};\n         decode_side_tables(xcx, ast_doc);\n         debug!{\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path), *ii.ident()};\n+               ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n+               tcx.sess.str_of(ii.ident())};\n         match ii {\n           ast::ii_item(i) => {\n             debug!{\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i)};\n+                   syntax::print::pprust::item_to_str(i, tcx.sess.intr())};\n           }\n           _ => { }\n         }\n@@ -915,28 +919,26 @@ trait fake_ext_ctxt {\n }\n \n #[cfg(test)]\n-type fake_session = ();\n+type fake_session = parse::parse_sess;\n \n #[cfg(test)]\n impl fake_session: fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg { ~[] }\n-    fn parse_sess() -> parse::parse_sess { parse::new_parse_sess(none) }\n+    fn parse_sess() -> parse::parse_sess { self }\n }\n \n #[cfg(test)]\n fn mk_ctxt() -> fake_ext_ctxt {\n-    () as fake_ext_ctxt\n+    parse::new_parse_sess(none) as fake_ext_ctxt\n }\n \n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n-    debug!{\"in_item = %s\", pprust::item_to_str(in_item)};\n     let mbuf = io::mem_buffer();\n     let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n     encode_item_ast(ebml_w, in_item);\n     let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n     let out_item = decode_item_ast(ebml_doc);\n-    debug!{\"out_item = %s\", pprust::item_to_str(out_item)};\n \n     let exp_str =\n         io::with_str_writer(|w| ast::serialize_item(w, *in_item) );\n@@ -993,7 +995,8 @@ fn test_simplification() {\n     });\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n-        assert pprust::item_to_str(item_out) == pprust::item_to_str(item_exp);\n+        assert pprust::item_to_str(item_out, ext_cx.parse_sess().interner)\n+            == pprust::item_to_str(item_exp, ext_cx.parse_sess().interner);\n       }\n       _ => fail\n     }"}, {"sha": "de6d0621b35df96f737c89acf10c9348cbde817b", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -159,7 +159,7 @@ impl check_loan_ctxt {\n         debug!{\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n                 callee_id=%d, ty=%s)\",\n                pc,\n-               opt_expr.map(|e| pprust::expr_to_str(e) ),\n+               opt_expr.map(|e| pprust::expr_to_str(e, tcx.sess.intr()) ),\n                callee_id,\n                ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id))};\n "}, {"sha": "c0d7521e9f2c8564de37f41eed7b10924c537589", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -90,7 +90,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n     let tcx = bccx.tcx;\n     let old_root_ub = self.root_ub;\n \n-    debug!{\"req_loans_in_expr(ex=%s)\", pprust::expr_to_str(ex)};\n+    debug!{\"req_loans_in_expr(ex=%s)\",\n+           pprust::expr_to_str(ex, tcx.sess.intr())};\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each |borrow| {"}, {"sha": "73c2a46f1fd4f5413a27740f1ad0283b43310126", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -44,15 +44,15 @@ fn check_capture_clause(tcx: ty::ctxt,\n             tcx.sess.span_warn(\n                 cap_item.span,\n                 fmt!{\"captured variable `%s` not used in closure\",\n-                     *cap_item.name});\n+                     tcx.sess.str_of(cap_item.name)});\n         }\n \n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n         if !seen_defs.insert(cap_def_id, ()) {\n             tcx.sess.span_err(\n                 cap_item.span,\n                 fmt!{\"variable `%s` captured more than once\",\n-                     *cap_item.name});\n+                     tcx.sess.str_of(cap_item.name)});\n         }\n     }\n }\n@@ -68,7 +68,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n \n     for (*cap_clause).each |cap_item| {\n         debug!{\"Doing capture var: %s (%?)\",\n-               *cap_item.name, cap_item.id};\n+               tcx.sess.str_of(cap_item.name), cap_item.id};\n \n         let cap_def = tcx.def_map.get(cap_item.id);\n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;"}, {"sha": "9d1846708cc4e18f25263920cf03c7dd1196c7ee", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -91,23 +91,23 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n         match ty::get(ty).struct {\n           ty::ty_bool => {\n             match check ctor {\n-              val(const_int(1i64)) => some(@~\"true\"),\n-              val(const_int(0i64)) => some(@~\"false\")\n+              val(const_int(1i64)) => some(~\"true\"),\n+              val(const_int(0i64)) => some(~\"false\")\n             }\n           }\n           ty::ty_enum(id, _) => {\n             let vid = match check ctor { variant(id) => id };\n             match check vec::find(*ty::enum_variants(tcx, id),\n                                 |v| v.id == vid) {\n-              some(v) => some(v.name)\n+              some(v) => some(tcx.sess.str_of(v.name))\n             }\n           }\n           _ => none\n         }\n       }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-      some(s) => ~\": \" + *s + ~\" not covered\",\n+      some(s) => ~\": \" + s + ~\" not covered\",\n       none => ~\"\"\n     };\n     tcx.sess.span_err(sp, msg);"}, {"sha": "cc63dfc12fc09f168799c4814170e2736cbf6180", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -50,7 +50,7 @@ fn collect_freevars(def_map: resolve3::DefMap, blk: ast::blk)\n               ast::expr_path(path) => {\n                   let mut i = 0;\n                   match def_map.find(expr.id) {\n-                    none => fail (~\"Not found: \" + path_to_str(path)),\n+                    none => fail ~\"path not found\",\n                     some(df) => {\n                       let mut def = df;\n                       while i < depth {"}, {"sha": "8d2f87734bf81ff1b14c4491079056b8f9d63759", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -214,7 +214,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n-    debug!{\"kind::check_expr(%s)\", expr_to_str(e)};\n+    debug!{\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr())};\n \n     // Handle any kind bounds on type parameters\n     do option::iter(cx.tcx.node_type_substs.find(e.id)) |ts| {"}, {"sha": "26360b5b82c9a2c7d27237e930a6f70f056d9b4d", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -102,18 +102,12 @@ struct LanguageItemCollector {\n             meta_name_value(key, literal) => {\n                 match literal.node {\n                     lit_str(value) => {\n-                        self.match_and_collect_item(item_def_id,\n-                                                    *key,\n-                                                    *value);\n-                    }\n-                    _ => {\n-                        // Skip.\n+                        self.match_and_collect_item(item_def_id, key, *value);\n                     }\n+                    _ => {} // Skip.\n                 }\n             }\n-            meta_word(*) | meta_list(*) => {\n-                // Skip.\n-            }\n+            meta_word(*) | meta_list(*) => {} // Skip.\n         }\n     }\n "}, {"sha": "ff97f7592688b76c03a28600d5f4f6ae69e4ebfe", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -246,13 +246,13 @@ impl ctxt {\n \n         for triples.each |pair| {\n             let (meta, level, lintname) = pair;\n-            match self.dict.find(*lintname) {\n+            match self.dict.find(lintname) {\n               none => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n                     meta.span,\n                     fmt!{\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), *lintname});\n+                         level_to_str(level), lintname});\n               }\n               some(lint) => {\n \n@@ -263,7 +263,7 @@ impl ctxt {\n                         meta.span,\n                         fmt!{\"%s(%s) overruled by outer forbid(%s)\",\n                              level_to_str(level),\n-                             *lintname, *lintname});\n+                             lintname, lintname});\n                 }\n \n                 // we do multiple unneeded copies of the\n@@ -433,21 +433,19 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n-    fn is_camel_case(ident: ast::ident) -> bool {\n+    fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n+        let ident = cx.sess.str_of(ident);\n         assert ident.is_not_empty();\n-        let ident = ident_without_trailing_underscores(*ident);\n+        let ident = ident_without_trailing_underscores(ident);\n         let ident = ident_without_leading_underscores(ident);\n         char::is_uppercase(str::char_at(ident, 0)) &&\n             !ident.contains_char('_')\n     }\n \n     fn ident_without_trailing_underscores(ident: ~str) -> ~str {\n         match str::rfind(ident, |c| c != '_') {\n-          some(idx) => ident.slice(0, idx + 1),\n-          none => {\n-            // all underscores\n-            ident\n-          }\n+            some(idx) => (ident).slice(0, idx + 1),\n+            none => { ident } // all underscores\n         }\n     }\n \n@@ -464,7 +462,7 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     fn check_case(cx: ty::ctxt, ident: ast::ident,\n                   expr_id: ast::node_id, item_id: ast::node_id,\n                   span: span) {\n-        if !is_camel_case(ident) {\n+        if !is_camel_case(cx, ident) {\n             cx.sess.span_lint(\n                 non_camel_case_types, expr_id, item_id, span,\n                 ~\"type, variant, or trait must be camel case\");\n@@ -488,7 +486,7 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n-    debug!{\"lint check_pat pat=%s\", pat_to_str(pat)};\n+    debug!{\"lint check_pat pat=%s\", pat_to_str(pat, tcx.sess.intr())};\n \n     do pat_bindings(tcx.def_map, pat) |binding_mode, id, span, path| {\n         match binding_mode {\n@@ -501,7 +499,7 @@ fn check_pat(tcx: ty::ctxt, pat: @ast::pat) {\n                     deprecated_pattern, id, id,\n                     span,\n                     fmt!{\"binding `%s` should use ref or copy mode\",\n-                         *path_to_ident(path)});\n+                         tcx.sess.str_of(path_to_ident(path))});\n             }\n           }\n         }"}, {"sha": "67e2d4a3cefefc49ea1b59c7b3e8052f65d0fa13", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -101,7 +101,7 @@\n  */\n \n import dvec::{DVec, dvec};\n-import std::map::{hashmap, int_hash, str_hash, box_str_hash};\n+import std::map::{hashmap, int_hash, str_hash, uint_hash};\n import syntax::{visit, ast_util};\n import syntax::print::pprust::{expr_to_str};\n import visit::vt;\n@@ -233,7 +233,7 @@ struct ir_maps {\n         self.live_node_map = int_hash();\n         self.variable_map = int_hash();\n         self.capture_map = int_hash();\n-        self.field_map = box_str_hash();\n+        self.field_map = uint_hash();\n         self.var_kinds = ~[];\n         self.lnks = ~[];\n     }\n@@ -286,12 +286,12 @@ struct ir_maps {\n         }\n     }\n \n-    fn variable_name(var: variable) -> ident {\n-        match self.var_kinds[*var] {\n-          vk_local(_, name) | vk_arg(_, name, _) => name,\n-          vk_field(name) => @(~\"self.\" + *name),\n-          vk_self => @~\"self\",\n-          vk_implicit_return => @~\"<implicit-ret>\"\n+    fn variable_name(var: variable) -> ~str {\n+        match copy self.var_kinds[*var] {\n+          vk_local(_, nm) | vk_arg(_, nm, _) => self.tcx.sess.str_of(nm),\n+          vk_field(nm) => ~\"self.\" + self.tcx.sess.str_of(nm),\n+          vk_self => ~\"self\",\n+          vk_implicit_return => ~\"<implicit-ret>\"\n         }\n     }\n \n@@ -1492,7 +1492,8 @@ impl @liveness {\n               none => { /* ok */ }\n               some(lnk_exit) => {\n                 self.tcx.sess.span_err(\n-                    sp, fmt!{\"field `self.%s` is never initialized\", *nm});\n+                    sp, fmt!{\"field `self.%s` is never initialized\",\n+                             self.tcx.sess.str_of(nm)});\n               }\n               some(lnk) => {\n                 self.report_illegal_read(\n@@ -1548,7 +1549,7 @@ impl @liveness {\n \n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n         debug!{\"check_move_from_expr(node %d: %s)\",\n-               expr.id, expr_to_str(expr)};\n+               expr.id, expr_to_str(expr, self.tcx.sess.intr())};\n \n         if self.ir.method_map.contains_key(expr.id) {\n             // actually an rvalue, since this calls a method\n@@ -1664,13 +1665,14 @@ impl @liveness {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     fmt!{\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", *name});\n+                          copy or move mode\", self.tcx.sess.str_of(name)});\n                 return;\n               }\n               vk_field(name) => {\n                 self.tcx.sess.span_err(\n                     move_span,\n-                    fmt!{\"illegal move from field `%s`\", *name});\n+                    fmt!{\"illegal move from field `%s`\",\n+                         self.tcx.sess.str_of(name)});\n                 return;\n               }\n               vk_self => {\n@@ -1711,12 +1713,12 @@ impl @liveness {\n           lnk_freevar(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!{\"capture of %s: `%s`\", msg, *name});\n+                fmt!{\"capture of %s: `%s`\", msg, name});\n           }\n           lnk_expr(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!{\"use of %s: `%s`\", msg, *name});\n+                fmt!{\"use of %s: `%s`\", msg, name});\n           }\n           lnk_exit |\n           lnk_vdef(_) => {\n@@ -1727,9 +1729,9 @@ impl @liveness {\n         }\n     }\n \n-    fn should_warn(var: variable) -> option<ident> {\n+    fn should_warn(var: variable) -> option<~str> {\n         let name = (*self.ir).variable_name(var);\n-        if (*name)[0] == ('_' as u8) {none} else {some(name)}\n+        if name[0] == ('_' as u8) {none} else {some(name)}\n     }\n \n     fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: live_node) {\n@@ -1780,10 +1782,10 @@ impl @liveness {\n                 if is_assigned {\n                     self.tcx.sess.span_warn(\n                         sp, fmt!{\"variable `%s` is assigned to, \\\n-                                  but never used\", *name});\n+                                  but never used\", name});\n                 } else {\n                     self.tcx.sess.span_warn(\n-                        sp, fmt!{\"unused variable: `%s`\", *name});\n+                        sp, fmt!{\"unused variable: `%s`\", name});\n                 }\n             }\n             return true;\n@@ -1796,7 +1798,7 @@ impl @liveness {\n             for self.should_warn(var).each |name| {\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    fmt!{\"value assigned to `%s` is never read\", *name});\n+                    fmt!{\"value assigned to `%s` is never read\", name});\n             }\n         }\n     }"}, {"sha": "8d5be4aa063acb983a3f8305eb6cf5e15788d242", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -263,7 +263,7 @@ impl &mem_categorization_ctxt {\n \n     fn cat_expr(expr: @ast::expr) -> cmt {\n         debug!{\"cat_expr: id=%d expr=%s\",\n-               expr.id, pprust::expr_to_str(expr)};\n+               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr())};\n \n         let tcx = self.tcx;\n         let expr_ty = tcx.ty(expr);\n@@ -468,7 +468,8 @@ impl &mem_categorization_ctxt {\n             self.tcx.sess.span_bug(\n                 node.span(),\n                 fmt!{\"Cannot find field `%s` in type `%s`\",\n-                     *f_name, ty_to_str(self.tcx, base_cmt.ty)});\n+                     self.tcx.sess.str_of(f_name),\n+                     ty_to_str(self.tcx, base_cmt.ty)});\n           }\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n@@ -650,12 +651,13 @@ impl &mem_categorization_ctxt {\n         // in the alt, the id of `local(x)->@` is the `@y` pattern,\n         // and the id of `local(x)->@->@` is the id of the `y` pattern.\n \n+\n+        let _i = indenter();\n+        let tcx = self.tcx;\n         debug!{\"cat_pattern: id=%d pat=%s cmt=%s\",\n-               pat.id, pprust::pat_to_str(pat),\n+               pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                self.cmt_to_repr(cmt)};\n-        let _i = indenter();\n \n-        let tcx = self.tcx;\n         match pat.node {\n           ast::pat_wild => {\n             // _\n@@ -767,7 +769,7 @@ impl &mem_categorization_ctxt {\n \n     fn comp_to_repr(comp: comp_kind) -> ~str {\n         match comp {\n-          comp_field(fld, _) => *fld,\n+          comp_field(fld, _) => self.tcx.sess.str_of(fld),\n           comp_index(*) => ~\"[]\",\n           comp_tuple => ~\"()\",\n           comp_variant(_) => ~\"<enum>\""}, {"sha": "d3fbf598e138eb42f954e5df4b4920c16c30e584", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -14,7 +14,7 @@ type pat_id_map = std::map::hashmap<ident, node_id>;\n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n fn pat_id_map(dm: resolve3::DefMap, pat: @pat) -> pat_id_map {\n-    let map = std::map::box_str_hash();\n+    let map = std::map::uint_hash();\n     do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n     };"}, {"sha": "d3c34ceea4d8651980af12d63757f6f0bb92eb3c", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -254,11 +254,13 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     let mut new_cx = cx;\n     match expr.node {\n       ast::expr_call(*) => {\n-        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr)};\n+        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n+                                                           cx.sess.intr())};\n         new_cx.parent = some(expr.id);\n       }\n       ast::expr_match(subexpr, _, _) => {\n-        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr)};\n+        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr,\n+                                                           cx.sess.intr())};\n         new_cx.parent = some(expr.id);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n@@ -390,8 +392,9 @@ impl determine_rp_ctxt {\n     fn add_rp(id: ast::node_id) {\n         assert id != 0;\n         if self.region_paramd_items.insert(id, ()) {\n-            debug!{\"add region-parameterized item: %d (%s)\",\n-                   id, ast_map::node_id_to_str(self.ast_map, id)};\n+            debug!{\"add region-parameterized item: %d (%s)\", id,\n+                   ast_map::node_id_to_str(self.ast_map, id,\n+                                           self.sess.parse_sess.interner)};\n             self.worklist.push(id);\n         } else {\n             debug!{\"item %d already region-parameterized\", id};\n@@ -401,8 +404,10 @@ impl determine_rp_ctxt {\n     fn add_dep(from: ast::node_id, to: ast::node_id) {\n         debug!{\"add dependency from %d -> %d (%s -> %s)\",\n                from, to,\n-               ast_map::node_id_to_str(self.ast_map, from),\n-               ast_map::node_id_to_str(self.ast_map, to)};\n+               ast_map::node_id_to_str(self.ast_map, from,\n+                                       self.sess.parse_sess.interner),\n+               ast_map::node_id_to_str(self.ast_map, to,\n+                                       self.sess.parse_sess.interner)};\n         let vec = match self.dep_map.find(from) {\n             some(vec) => {vec}\n             none => {\n@@ -448,9 +453,10 @@ impl determine_rp_ctxt {\n     // that flag to false when we enter a method.\n     fn region_is_relevant(r: @ast::region) -> bool {\n         match r.node {\n-          ast::re_anon => self.anon_implies_rp,\n-          ast::re_named(@~\"self\") => true,\n-          ast::re_named(_) => false\n+            ast::re_anon => self.anon_implies_rp,\n+            ast::re_named(id) => {\n+                id == syntax::parse::token::special_idents::self_\n+            }\n         }\n     }\n \n@@ -511,7 +517,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     match ty.node {\n       ast::ty_rptr(r, _) |\n       ast::ty_path(@{rp: some(r), _}, _) => {\n-        debug!{\"referenced type with regions %s\", pprust::ty_to_str(ty)};\n+        debug!{\"referenced type with regions %s\",\n+               pprust::ty_to_str(ty, cx.sess.intr())};\n         if cx.region_is_relevant(r) {\n             cx.add_rp(cx.item_id);\n         }\n@@ -520,7 +527,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n       ast::ty_fn(ast::proto_bare, _, _) |\n       ast::ty_fn(ast::proto_block, _, _) if cx.anon_implies_rp => {\n         debug!(\"referenced bare fn type with regions %s\",\n-               pprust::ty_to_str(ty));\n+               pprust::ty_to_str(ty, cx.sess.intr()));\n         cx.add_rp(cx.item_id);\n       }\n \n@@ -541,7 +548,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n                 let cstore = cx.sess.cstore;\n                 if csearch::get_region_param(cstore, did) {\n                     debug!{\"reference to external, rp'd type %s\",\n-                           pprust::ty_to_str(ty)};\n+                           pprust::ty_to_str(ty, cx.sess.intr())};\n                     cx.add_rp(cx.item_id);\n                 }\n             }"}, {"sha": "d6b057deed5bd966dddd5b85be8f0755529a0f41", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 190, "deletions": 246, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -57,9 +57,10 @@ import dvec::{DVec, dvec};\n import option::{get, is_some};\n import str::{connect, split_str};\n import vec::pop;\n+import syntax::parse::token::ident_interner;\n \n import std::list::{cons, list, nil};\n-import std::map::{hashmap, int_hash, box_str_hash};\n+import std::map::{hashmap, int_hash, uint_hash};\n import str_eq = str::eq;\n \n // Definition mapping\n@@ -250,63 +251,6 @@ fn Atom(n: uint) -> Atom {\n     return n;\n }\n \n-struct AtomTable {\n-    let atoms: hashmap<@~str,Atom>;\n-    let strings: DVec<@~str>;\n-    let mut atom_count: uint;\n-\n-    new() {\n-        self.atoms = hashmap::<@~str,Atom>(|x| str::hash(*x),\n-                                          |x, y| str::eq(*x, *y));\n-        self.strings = dvec();\n-        self.atom_count = 0u;\n-    }\n-\n-    fn intern(string: @~str) -> Atom {\n-        match self.atoms.find(string) {\n-            none => { /* fall through */ }\n-            some(atom) => return atom\n-        }\n-\n-        let atom = Atom(self.atom_count);\n-        self.atom_count += 1u;\n-        self.atoms.insert(string, atom);\n-        self.strings.push(string);\n-\n-        return atom;\n-    }\n-\n-    fn atom_to_str(atom: Atom) -> @~str {\n-        return self.strings.get_elt(atom);\n-    }\n-\n-    fn atoms_to_strs(atoms: ~[Atom], f: fn(@~str) -> bool) {\n-        for atoms.each |atom| {\n-            if !f(self.atom_to_str(atom)) {\n-                return;\n-            }\n-        }\n-    }\n-\n-    fn atoms_to_str(atoms: ~[Atom]) -> @~str {\n-        // XXX: str::connect should do this.\n-        let mut result = ~\"\";\n-        let mut first = true;\n-        for self.atoms_to_strs(atoms) |string| {\n-            if first {\n-                first = false;\n-            } else {\n-                result += ~\"::\";\n-            }\n-\n-            result += *string;\n-        }\n-\n-        // XXX: Shouldn't copy here. We need string builder functionality.\n-        return @result;\n-    }\n-}\n-\n /// Creates a hash table of atoms.\n fn atom_hashmap<V:copy>() -> hashmap<Atom,V> {\n     hashmap::<Atom,V>(uint::hash, uint::eq)\n@@ -601,30 +545,30 @@ struct NameBindings {\n struct PrimitiveTypeTable {\n     let primitive_types: hashmap<Atom,prim_ty>;\n \n-    new(atom_table: @AtomTable) {\n+    new(intr: ident_interner) {\n         self.primitive_types = atom_hashmap();\n \n-        self.intern(atom_table, @~\"bool\",    ty_bool);\n-        self.intern(atom_table, @~\"char\",    ty_int(ty_char));\n-        self.intern(atom_table, @~\"float\",   ty_float(ty_f));\n-        self.intern(atom_table, @~\"f32\",     ty_float(ty_f32));\n-        self.intern(atom_table, @~\"f64\",     ty_float(ty_f64));\n-        self.intern(atom_table, @~\"int\",     ty_int(ty_i));\n-        self.intern(atom_table, @~\"i8\",      ty_int(ty_i8));\n-        self.intern(atom_table, @~\"i16\",     ty_int(ty_i16));\n-        self.intern(atom_table, @~\"i32\",     ty_int(ty_i32));\n-        self.intern(atom_table, @~\"i64\",     ty_int(ty_i64));\n-        self.intern(atom_table, @~\"str\",     ty_str);\n-        self.intern(atom_table, @~\"uint\",    ty_uint(ty_u));\n-        self.intern(atom_table, @~\"u8\",      ty_uint(ty_u8));\n-        self.intern(atom_table, @~\"u16\",     ty_uint(ty_u16));\n-        self.intern(atom_table, @~\"u32\",     ty_uint(ty_u32));\n-        self.intern(atom_table, @~\"u64\",     ty_uint(ty_u64));\n+        self.intern(intr, @~\"bool\",    ty_bool);\n+        self.intern(intr, @~\"char\",    ty_int(ty_char));\n+        self.intern(intr, @~\"float\",   ty_float(ty_f));\n+        self.intern(intr, @~\"f32\",     ty_float(ty_f32));\n+        self.intern(intr, @~\"f64\",     ty_float(ty_f64));\n+        self.intern(intr, @~\"int\",     ty_int(ty_i));\n+        self.intern(intr, @~\"i8\",      ty_int(ty_i8));\n+        self.intern(intr, @~\"i16\",     ty_int(ty_i16));\n+        self.intern(intr, @~\"i32\",     ty_int(ty_i32));\n+        self.intern(intr, @~\"i64\",     ty_int(ty_i64));\n+        self.intern(intr, @~\"str\",     ty_str);\n+        self.intern(intr, @~\"uint\",    ty_uint(ty_u));\n+        self.intern(intr, @~\"u8\",      ty_uint(ty_u8));\n+        self.intern(intr, @~\"u16\",     ty_uint(ty_u16));\n+        self.intern(intr, @~\"u32\",     ty_uint(ty_u32));\n+        self.intern(intr, @~\"u64\",     ty_uint(ty_u64));\n     }\n \n-    fn intern(atom_table: @AtomTable, string: @~str,\n+    fn intern(intr: ident_interner, string: @~str,\n               primitive_type: prim_ty) {\n-        let atom = (*atom_table).intern(string);\n+        let atom = intr.intern(string);\n         self.primitive_types.insert(atom, primitive_type);\n     }\n }\n@@ -643,7 +587,7 @@ struct Resolver {\n     let lang_items: LanguageItems;\n     let crate: @crate;\n \n-    let atom_table: @AtomTable;\n+    let intr: ident_interner;\n \n     let graph_root: @NameBindings;\n \n@@ -694,8 +638,6 @@ struct Resolver {\n         self.lang_items = copy lang_items;\n         self.crate = crate;\n \n-        self.atom_table = @AtomTable();\n-\n         // The outermost module has def ID 0; this is not reflected in the\n         // AST.\n \n@@ -719,15 +661,18 @@ struct Resolver {\n         self.xray_context = NoXray;\n         self.current_trait_refs = none;\n \n-        self.self_atom = (*self.atom_table).intern(@~\"self\");\n-        self.primitive_type_table = @PrimitiveTypeTable(self.atom_table);\n+        self.self_atom = syntax::parse::token::special_idents::self_;\n+        self.primitive_type_table = @PrimitiveTypeTable(self.session.\n+                                                        parse_sess.interner);\n \n         self.namespaces = ~[ ModuleNS, TypeNS, ValueNS ];\n \n         self.def_map = int_hash();\n         self.export_map = int_hash();\n         self.export_map2 = int_hash();\n         self.trait_map = @int_hash();\n+\n+        self.intr = session.intr();\n     }\n \n     /// The main name resolution procedure.\n@@ -844,12 +789,12 @@ struct Resolver {\n                   self.session.span_err(sp,\n                        #fmt(\"Duplicate definition of %s %s\",\n                             namespace_to_str(ns),\n-                            *(*self.atom_table).atom_to_str(name)));\n+                            self.session.str_of(name)));\n                   do child.span_for_namespace(ns).iter() |sp| {\n                       self.session.span_note(sp,\n                            #fmt(\"First definition of %s %s here:\",\n-                            namespace_to_str(ns),\n-                            *(*self.atom_table).atom_to_str(name)));\n+                                namespace_to_str(ns),\n+                                self.session.str_of(name)));\n                   }\n                 }\n                 _ => {}\n@@ -903,7 +848,7 @@ struct Resolver {\n                                     parent: ReducedGraphParent,\n                                     &&visitor: vt<ReducedGraphParent>) {\n \n-        let atom = (*self.atom_table).intern(item.ident);\n+        let atom = item.ident;\n         let sp = item.span;\n \n         match item.node {\n@@ -1037,7 +982,7 @@ struct Resolver {\n                 for methods.each |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n \n-                    let atom = (*self.atom_table).intern(ty_m.ident);\n+                    let atom = ty_m.ident;\n                     // Add it to the trait info if not static,\n                     // add it as a name in the enclosing module otherwise.\n                     match ty_m.self_ty.node {\n@@ -1080,7 +1025,7 @@ struct Resolver {\n                                        parent: ReducedGraphParent,\n                                        &&visitor: vt<ReducedGraphParent>) {\n \n-        let atom = (*self.atom_table).intern(variant.node.name);\n+        let atom = variant.node.name;\n         let (child, _) = self.add_child(atom, parent, ~[ValueNS],\n                                         variant.span);\n \n@@ -1132,18 +1077,15 @@ struct Resolver {\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1u {\n-                                    let atom =\n-                                        (*self.atom_table).intern(ident);\n-                                    (*module_path).push(atom);\n+                                    (*module_path).push(ident);\n                                 }\n                             }\n                         }\n \n                         view_path_glob(module_ident_path, _) |\n                         view_path_list(module_ident_path, _, _) => {\n                             for module_ident_path.idents.each |ident| {\n-                                let atom = (*self.atom_table).intern(ident);\n-                                (*module_path).push(atom);\n+                                (*module_path).push(ident);\n                             }\n                         }\n                     }\n@@ -1152,13 +1094,9 @@ struct Resolver {\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n                         view_path_simple(binding, full_path, _) => {\n-                            let target_atom =\n-                                (*self.atom_table).intern(binding);\n                             let source_ident = full_path.idents.last();\n-                            let source_atom =\n-                                (*self.atom_table).intern(source_ident);\n-                            let subclass = @SingleImport(target_atom,\n-                                                         source_atom);\n+                            let subclass = @SingleImport(binding,\n+                                                         source_ident);\n                             self.build_import_directive(module_,\n                                                         module_path,\n                                                         subclass,\n@@ -1167,8 +1105,7 @@ struct Resolver {\n                         view_path_list(_, source_idents, _) => {\n                             for source_idents.each |source_ident| {\n                                 let name = source_ident.node.name;\n-                                let atom = (*self.atom_table).intern(name);\n-                                let subclass = @SingleImport(atom, atom);\n+                                let subclass = @SingleImport(name, name);\n                                 self.build_import_directive(module_,\n                                                             module_path,\n                                                             subclass,\n@@ -1204,8 +1141,7 @@ struct Resolver {\n                                       module\");\n                             }\n \n-                            let atom = (*self.atom_table).intern(ident);\n-                            module_.exported_names.insert(atom, ident_id);\n+                            module_.exported_names.insert(ident, ident_id);\n                         }\n \n                         view_path_glob(*) => {\n@@ -1234,8 +1170,7 @@ struct Resolver {\n                                 }\n \n                                 for path_list_idents.each |path_list_ident| {\n-                                    let atom = (*self.atom_table).intern\n-                                        (path_list_ident.node.name);\n+                                    let atom = path_list_ident.node.name;\n                                     let id = path_list_ident.node.id;\n                                     module_.exported_names.insert(atom, id);\n                                 }\n@@ -1248,15 +1183,14 @@ struct Resolver {\n             view_item_use(name, _, node_id) => {\n                 match find_use_stmt_cnum(self.session.cstore, node_id) {\n                     some(crate_id) => {\n-                        let atom = (*self.atom_table).intern(name);\n                         let (child_name_bindings, new_parent) =\n                             // should this be in ModuleNS? --tjc\n-                            self.add_child(atom, parent, ~[ModuleNS],\n+                            self.add_child(name, parent, ~[ModuleNS],\n                                            view_item.span);\n \n                         let def_id = { crate: crate_id, node: 0 };\n                         let parent_link = ModuleParentLink\n-                            (self.get_module_from_parent(new_parent), atom);\n+                            (self.get_module_from_parent(new_parent), name);\n \n                         (*child_name_bindings).define_module(parent_link,\n                                                              some(def_id),\n@@ -1278,7 +1212,7 @@ struct Resolver {\n                                             &&visitor:\n                                                 vt<ReducedGraphParent>) {\n \n-        let name = (*self.atom_table).intern(foreign_item.ident);\n+        let name = foreign_item.ident;\n \n         match foreign_item.node {\n             foreign_item_fn(fn_decl, type_parameters) => {\n@@ -1398,7 +1332,7 @@ struct Resolver {\n             // to the trait info.\n \n             match get_method_names_if_trait(self.session.cstore,\n-                                          def_id) {\n+                                            def_id) {\n               none => {\n                 // Nothing to do.\n               }\n@@ -1408,13 +1342,12 @@ struct Resolver {\n                     let (method_name, self_ty) = method_data;\n                     debug!(\"(building reduced graph for \\\n                             external crate) ... adding \\\n-                            trait method '%?'\", method_name);\n-\n-                    let m_atom = self.atom_table.intern(method_name);\n+                            trait method '%s'\",\n+                           self.session.str_of(method_name));\n \n                     // Add it to the trait info if not static.\n                     if self_ty != sty_static {\n-                        interned_method_names.insert(m_atom, ());\n+                        interned_method_names.insert(method_name, ());\n                     }\n                 }\n                 self.trait_info.insert(def_id, interned_method_names);\n@@ -1456,23 +1389,24 @@ struct Resolver {\n         for each_path(self.session.cstore, get(root.def_id).crate)\n                 |path_entry| {\n \n-            debug!{\"(building reduced graph for external crate) found path \\\n-                    entry: %s (%?)\",\n-                   path_entry.path_string,\n-                   path_entry.def_like};\n+            debug!(\"(building reduced graph for external crate) found path \\\n+                        entry: %s (%?)\",\n+                    path_entry.path_string,\n+                    path_entry.def_like);\n \n             let mut pieces = split_str(path_entry.path_string, ~\"::\");\n-            let final_ident = pop(pieces);\n+            let final_ident_str = pop(pieces);\n+            let final_ident = self.session.ident_of(final_ident_str);\n \n             // Find the module we need, creating modules along the way if we\n             // need to.\n \n             let mut current_module = root;\n-            for pieces.each |ident| {\n+            for pieces.each |ident_str| {\n+                let ident = self.session.ident_of(ident_str);\n                 // Create or reuse a graph node for the child.\n-                let atom = (*self.atom_table).intern(@copy ident);\n                 let (child_name_bindings, new_parent) =\n-                    self.add_child(atom,\n+                    self.add_child(ident,\n                                    ModuleReducedGraphParent(current_module),\n                                    // May want a better span\n                                    ~[], dummy_sp());\n@@ -1481,9 +1415,9 @@ struct Resolver {\n                 match child_name_bindings.module_def {\n                     NoModuleDef => {\n                         debug!{\"(building reduced graph for external crate) \\\n-                                autovivifying %s\", ident};\n+                                autovivifying %s\", ident_str};\n                         let parent_link = self.get_parent_link(new_parent,\n-                                                               atom);\n+                                                               ident);\n                         (*child_name_bindings).define_module(parent_link,\n                                                        none, dummy_sp());\n                     }\n@@ -1494,29 +1428,29 @@ struct Resolver {\n             }\n \n             // Add the new child item.\n-            let atom = (*self.atom_table).intern(@copy final_ident);\n             let (child_name_bindings, new_parent) =\n-                self.add_child(atom,\n+                self.add_child(final_ident,\n                                ModuleReducedGraphParent(current_module),\n                               ~[], dummy_sp());\n \n             match path_entry.def_like {\n                 dl_def(def) => {\n                     self.handle_external_def(def, modules,\n                                              child_name_bindings,\n-                                             final_ident, atom, new_parent);\n+                                             self.session.str_of(final_ident),\n+                                             final_ident, new_parent);\n                 }\n                 dl_impl(_) => {\n                     // Because of the infelicitous way the metadata is\n                     // written, we can't process this impl now. We'll get it\n                     // later.\n \n                     debug!{\"(building reduced graph for external crate) \\\n-                            ignoring impl %s\", final_ident};\n+                            ignoring impl %s\", final_ident_str};\n                 }\n                 dl_field => {\n                     debug!{\"(building reduced graph for external crate) \\\n-                            ignoring field %s\", final_ident};\n+                            ignoring field %s\", final_ident_str};\n                 }\n             }\n         }\n@@ -1653,6 +1587,21 @@ struct Resolver {\n         }\n     }\n \n+    fn atoms_to_str(atoms: ~[Atom]) -> ~str {\n+        // XXX: str::connect should do this.\n+        let mut result = ~\"\";\n+        let mut first = true;\n+        for atoms.each() |atom| {\n+            if first {\n+                first = false;\n+            } else {\n+                result += ~\"::\";\n+            }\n+            result += self.session.str_of(atom);\n+        }\n+        // XXX: Shouldn't copy here. We need string builder functionality.\n+        return result;\n+    }\n     /**\n      * Attempts to resolve the given import. The return value indicates\n      * failure if we're certain the name does not exist, indeterminate if we\n@@ -1669,7 +1618,7 @@ struct Resolver {\n \n         debug!{\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n-               *(*self.atom_table).atoms_to_str((*module_path).get()),\n+               self.atoms_to_str((*module_path).get()),\n                self.module_to_str(module_)};\n \n         // One-level renaming imports of the form `import foo = bar;` are\n@@ -1753,14 +1702,14 @@ struct Resolver {\n \n         debug!{\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n-               *(*self.atom_table).atom_to_str(target),\n+               self.session.str_of(target),\n                self.module_to_str(containing_module),\n-               *(*self.atom_table).atom_to_str(source),\n+               self.session.str_of(source),\n                self.module_to_str(module_)};\n \n         if !self.name_is_exported(containing_module, source) {\n             debug!{\"(resolving single import) name `%s` is unexported\",\n-                   *(*self.atom_table).atom_to_str(source)};\n+                   self.session.str_of(source)};\n             return Failed;\n         }\n \n@@ -1966,7 +1915,7 @@ struct Resolver {\n \n             if !self.name_is_exported(containing_module, atom) {\n                 debug!{\"(resolving glob import) name `%s` is unexported\",\n-                       *(*self.atom_table).atom_to_str(atom)};\n+                       self.session.str_of(atom)};\n                 again;\n             }\n \n@@ -2030,7 +1979,7 @@ struct Resolver {\n         for containing_module.children.each |atom, name_bindings| {\n             if !self.name_is_exported(containing_module, atom) {\n                 debug!{\"(resolving glob import) name `%s` is unexported\",\n-                       *(*self.atom_table).atom_to_str(atom)};\n+                       self.session.str_of(atom)};\n                 again;\n             }\n \n@@ -2050,7 +1999,7 @@ struct Resolver {\n \n             debug!{\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`\",\n-                   *(*self.atom_table).atom_to_str(atom),\n+                   self.session.str_of(atom),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_)};\n \n@@ -2103,7 +2052,7 @@ struct Resolver {\n                 Indeterminate => {\n                     debug!{\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n-                            *(*self.atom_table).atom_to_str(name)};\n+                            self.session.str_of(name)};\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n@@ -2112,8 +2061,8 @@ struct Resolver {\n                             // Not a module.\n                             self.session.span_err(span,\n                                                   fmt!{\"not a module: %s\",\n-                                                       *(*self.atom_table).\n-                                                         atom_to_str(name)});\n+                                                       self.session.\n+                                                           str_of(name)});\n                             return Failed;\n                         }\n                         ModuleDef(module_) => {\n@@ -2144,7 +2093,7 @@ struct Resolver {\n \n         debug!{\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n-               *(*self.atom_table).atoms_to_str((*module_path).get()),\n+               self.atoms_to_str((*module_path).get()),\n                self.module_to_str(module_)};\n \n         // The first element of the module path must be in the current scope\n@@ -2181,7 +2130,7 @@ struct Resolver {\n \n         debug!{\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n-               *(*self.atom_table).atom_to_str(name),\n+               self.session.str_of(name),\n                namespace,\n                self.module_to_str(module_)};\n \n@@ -2307,12 +2256,12 @@ struct Resolver {\n                            -> ResolveResult<Target> {\n \n         debug!{\"(resolving name in module) resolving `%s` in `%s`\",\n-               *(*self.atom_table).atom_to_str(name),\n+               self.session.str_of(name),\n                self.module_to_str(module_)};\n \n         if xray == NoXray && !self.name_is_exported(module_, name) {\n             debug!{\"(resolving name in module) name `%s` is unexported\",\n-                   *(*self.atom_table).atom_to_str(name)};\n+                   self.session.str_of(name)};\n             return Failed;\n         }\n \n@@ -2367,7 +2316,7 @@ struct Resolver {\n \n         // We're out of luck.\n         debug!{\"(resolving name in module) failed to resolve %s\",\n-               *(*self.atom_table).atom_to_str(name)};\n+               self.session.str_of(name)};\n         return Failed;\n     }\n \n@@ -2394,8 +2343,8 @@ struct Resolver {\n \n         debug!{\"(resolving one-level naming result) resolving import `%s` = \\\n                 `%s` in `%s`\",\n-                *(*self.atom_table).atom_to_str(target_name),\n-                *(*self.atom_table).atom_to_str(source_name),\n+                self.session.str_of(target_name),\n+                self.session.str_of(source_name),\n                 self.module_to_str(module_)};\n \n         // Find the matching items in the lexical scope chain for every\n@@ -2509,7 +2458,7 @@ struct Resolver {\n                 debug!{\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n                        is_none(module_result),\n-                       *(*self.atom_table).atom_to_str(target_name),\n+                       self.session.str_of(target_name),\n                        self.module_to_str(module_)};\n \n                 import_resolution.module_target = module_result;\n@@ -2617,30 +2566,30 @@ struct Resolver {\n                     ChildNameDefinition(target_def) => {\n                         debug!(\"(computing exports) found child export '%s' \\\n                                 for %?\",\n-                               *self.atom_table.atom_to_str(name),\n+                               self.session.str_of(name),\n                                module_.def_id);\n                         vec::push(exports, {\n                             reexp: false,\n                             id: def_id_of_def(target_def)\n                         });\n                         vec::push(exports2, Export2 {\n                             reexport: false,\n-                            name: copy *self.atom_table.atom_to_str(name),\n+                            name: self.session.str_of(name),\n                             def_id: def_id_of_def(target_def)\n                         });\n                     }\n                     ImportNameDefinition(target_def) => {\n                         debug!(\"(computing exports) found reexport '%s' for \\\n                                 %?\",\n-                               *self.atom_table.atom_to_str(name),\n+                               self.session.str_of(name),\n                                module_.def_id);\n                         vec::push(exports, {\n                             reexp: true,\n                             id: def_id_of_def(target_def)\n                         });\n                         vec::push(exports2, Export2 {\n                             reexport: true,\n-                            name: copy *self.atom_table.atom_to_str(name),\n+                            name: self.session.str_of(name),\n                             def_id: def_id_of_def(target_def)\n                         });\n                     }\n@@ -2690,15 +2639,15 @@ struct Resolver {\n                 match orig_module.children.find(name) {\n                     none => {\n                         debug!{\"!!! (with scope) didn't find `%s` in `%s`\",\n-                               *(*self.atom_table).atom_to_str(name),\n+                               self.session.str_of(name),\n                                self.module_to_str(orig_module)};\n                     }\n                     some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             none => {\n                                 debug!{\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n-                                       *(*self.atom_table).atom_to_str(name),\n+                                       self.session.str_of(name),\n                                        self.module_to_str(orig_module)};\n                             }\n                             some(module_) => {\n@@ -2867,7 +2816,8 @@ struct Resolver {\n     }\n \n     fn resolve_item(item: @item, visitor: ResolveVisitor) {\n-        debug!{\"(resolving item) resolving %s\", *item.ident};\n+        debug!{\"(resolving item) resolving %s\",\n+               self.session.str_of(item.ident)};\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n@@ -2984,16 +2934,14 @@ struct Resolver {\n             }\n \n             item_mod(module_) => {\n-                let atom = (*self.atom_table).intern(item.ident);\n-                do self.with_scope(some(atom)) {\n+                do self.with_scope(some(item.ident)) {\n                     self.resolve_module(module_, item.span, item.ident,\n                                         item.id, visitor);\n                 }\n             }\n \n             item_foreign_mod(foreign_module) => {\n-                let atom = (*self.atom_table).intern(item.ident);\n-                do self.with_scope(some(atom)) {\n+                do self.with_scope(some(item.ident)) {\n                     for foreign_module.items.each |foreign_item| {\n                         match foreign_item.node {\n                             foreign_item_fn(_, type_parameters) => {\n@@ -3021,8 +2969,8 @@ struct Resolver {\n                 // of conditionals.\n \n                 if !self.session.building_library &&\n-                        is_none(self.session.main_fn) &&\n-                        *item.ident == ~\"main\" {\n+                    is_none(self.session.main_fn) &&\n+                    item.ident == syntax::parse::token::special_idents::main {\n \n                     self.session.main_fn = some((item.id, item.span));\n                 }\n@@ -3061,8 +3009,7 @@ struct Resolver {\n                 (*self.type_ribs).push(function_type_rib);\n \n                 for (*type_parameters).eachi |index, type_parameter| {\n-                    let name =\n-                        (*self.atom_table).intern(type_parameter.ident);\n+                    let name = type_parameter.ident;\n                     debug!{\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id};\n                     let def_like = dl_def(def_ty_param\n@@ -3172,15 +3119,15 @@ struct Resolver {\n                 }\n                 some(declaration) => {\n                     for declaration.inputs.each |argument| {\n-                        let name = (*self.atom_table).intern(argument.ident);\n+                        let name = argument.ident;\n                         let def_like = dl_def(def_arg(argument.id,\n                                                       argument.mode));\n                         (*function_value_rib).bindings.insert(name, def_like);\n \n                         self.resolve_type(argument.ty, visitor);\n \n                         debug!{\"(resolving function) recorded argument `%s`\",\n-                               *(*self.atom_table).atom_to_str(name)};\n+                               self.session.str_of(name)};\n                     }\n \n                     self.resolve_type(declaration.output, visitor);\n@@ -3443,7 +3390,7 @@ struct Resolver {\n     }\n \n     fn binding_mode_map(pat: @pat) -> BindingMap {\n-        let result = box_str_hash();\n+        let result = uint_hash();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n             let ident = path_to_ident(path);\n             result.insert(ident,\n@@ -3466,15 +3413,15 @@ struct Resolver {\n                         p.span,\n                         fmt!{\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             *key, i + 1});\n+                             self.session.str_of(key), i + 1});\n                   }\n                   some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.session.span_err(\n                             binding_i.span,\n                             fmt!{\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 *key, i + 1});\n+                                 self.session.str_of(key), i + 1});\n                     }\n                   }\n                 }\n@@ -3486,7 +3433,7 @@ struct Resolver {\n                         binding.span,\n                         fmt!{\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             *key, i + 1});\n+                             self.session.str_of(key), i + 1});\n                 }\n             }\n         }\n@@ -3549,7 +3496,7 @@ struct Resolver {\n                 match self.resolve_path(path, TypeNS, true, visitor) {\n                     some(def) => {\n                         debug!{\"(resolving type) resolved `%s` to type\",\n-                               *path.idents.last()};\n+                               self.session.str_of(path.idents.last())};\n                         result_def = some(def);\n                     }\n                     none => {\n@@ -3564,8 +3511,7 @@ struct Resolver {\n                     none => {\n                         // Check to see whether the name is a primitive type.\n                         if path.idents.len() == 1u {\n-                            let name =\n-                                (*self.atom_table).intern(path.idents.last());\n+                            let name = path.idents.last();\n \n                             match self.primitive_type_table\n                                     .primitive_types\n@@ -3588,14 +3534,16 @@ struct Resolver {\n                         // Write the result into the def map.\n                         debug!{\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n-                               connect(path.idents.map(|x| *x), ~\"::\"),\n+                               connect(path.idents.map(\n+                                   |x| self.session.str_of(x)), ~\"::\"),\n                                path_id};\n                         self.record_def(path_id, def);\n                     }\n                     none => {\n                         self.session.span_err\n                             (ty.span, fmt!{\"use of undeclared type name `%s`\",\n-                                           connect(path.idents.map(|x| *x),\n+                                           connect(path.idents.map(\n+                                               |x| self.session.str_of(x)),\n                                                    ~\"::\")});\n                     }\n                 }\n@@ -3630,13 +3578,13 @@ struct Resolver {\n                     // matching such a variant is simply disallowed (since\n                     // it's rarely what you want).\n \n-                    let atom = (*self.atom_table).intern(path.idents[0]);\n+                    let atom = path.idents[0];\n \n                     match self.resolve_enum_variant_or_const(atom) {\n                         FoundEnumVariant(def) if mode == RefutableMode => {\n                             debug!{\"(resolving pattern) resolving `%s` to \\\n                                     enum variant\",\n-                                   *path.idents[0]};\n+                                    self.session.str_of(atom)};\n \n                             self.record_def(pattern.id, def);\n                         }\n@@ -3645,9 +3593,8 @@ struct Resolver {\n                                                   fmt!{\"declaration of `%s` \\\n                                                         shadows an enum \\\n                                                         that's in scope\",\n-                                                       *(*self.atom_table).\n-                                                            atom_to_str\n-                                                            (atom)});\n+                                                        self.session\n+                                                        .str_of(atom)});\n                         }\n                         FoundConst => {\n                             self.session.span_err(pattern.span,\n@@ -3657,7 +3604,7 @@ struct Resolver {\n                         }\n                         EnumVariantOrConstNotFound => {\n                             debug!{\"(resolving pattern) binding `%s`\",\n-                                   *path.idents[0]};\n+                                   self.session.str_of(atom)};\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -3702,7 +3649,8 @@ struct Resolver {\n                                      self.session.span_err(pattern.span,\n                                        fmt!{\"Identifier %s is bound more \\\n                                              than once in the same pattern\",\n-                                            path_to_str(path)});\n+                                            path_to_str(path, self.session\n+                                                        .intr())});\n                                   }\n                                   // Not bound in the same pattern: do nothing\n                                 }\n@@ -3728,10 +3676,11 @@ struct Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         some(_) => {\n-                            self.session.span_err(path.span,\n-                                                  fmt!{\"not an enum \\\n-                                                        variant: %s\",\n-                                                       *path.idents.last()});\n+                            self.session.span_err(\n+                                path.span,\n+                                fmt!{\"not an enum variant: %s\",\n+                                     self.session.str_of(\n+                                         path.idents.last())});\n                         }\n                         none => {\n                             self.session.span_err(path.span,\n@@ -3768,12 +3717,12 @@ struct Resolver {\n                             self.record_def(pattern.id, definition);\n                         }\n                         _ => {\n-                            self.session.span_err(path.span,\n-                                                  fmt!(\"`%s` does not name a \\\n-                                                        structure\",\n-                                                       connect(path.idents.map\n-                                                               (|x| *x),\n-                                                               ~\"::\")));\n+                            self.session.span_err(\n+                                path.span,\n+                                fmt!(\"`%s` does not name a structure\",\n+                                     connect(path.idents.map(\n+                                         |x| self.session.str_of(x)),\n+                                             ~\"::\")));\n                         }\n                     }\n                 }\n@@ -3888,7 +3837,7 @@ struct Resolver {\n         if xray == NoXray && !self.name_is_exported(containing_module, name) {\n             debug!{\"(resolving definition of name in module) name `%s` is \\\n                     unexported\",\n-                   *(*self.atom_table).atom_to_str(name)};\n+                   self.session.str_of(name)};\n             return NoNameDefinition;\n         }\n \n@@ -3948,7 +3897,7 @@ struct Resolver {\n                 break;\n             }\n \n-            (*module_path_atoms).push((*self.atom_table).intern(ident));\n+            (*module_path_atoms).push(ident);\n         }\n \n         return module_path_atoms;\n@@ -3970,8 +3919,8 @@ struct Resolver {\n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!{\"use of undeclared module `%s`\",\n-                                            *(*self.atom_table).atoms_to_str\n-                                              ((*module_path_atoms).get())});\n+                                           self.atoms_to_str(\n+                                               (*module_path_atoms).get())});\n                 return none;\n             }\n \n@@ -3984,19 +3933,18 @@ struct Resolver {\n             }\n         }\n \n-        let name = (*self.atom_table).intern(path.idents.last());\n+        let name = path.idents.last();\n         match self.resolve_definition_of_name_in_module(containing_module,\n-                                                      name,\n-                                                      namespace,\n-                                                      xray) {\n+                                                        name,\n+                                                        namespace,\n+                                                        xray) {\n             NoNameDefinition => {\n                 // We failed to resolve the name. Report an error.\n-                self.session.span_err(path.span,\n-                                      fmt!{\"unresolved name: %s::%s\",\n-                                           *(*self.atom_table).atoms_to_str\n-                                               ((*module_path_atoms).get()),\n-                                           *(*self.atom_table).atom_to_str\n-                                               (name)});\n+                self.session.span_err(\n+                    path.span,\n+                    fmt!{\"unresolved name: %s::%s\",\n+                         self.atoms_to_str((*module_path_atoms).get()),\n+                         self.session.str_of(name)});\n                 return none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) => {\n@@ -4024,7 +3972,7 @@ struct Resolver {\n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!{\"use of undeclared module `::%s`\",\n-                                            *(*self.atom_table).atoms_to_str\n+                                            self.atoms_to_str\n                                               ((*module_path_atoms).get())});\n                 return none;\n             }\n@@ -4038,19 +3986,18 @@ struct Resolver {\n             }\n         }\n \n-        let name = (*self.atom_table).intern(path.idents.last());\n+        let name = path.idents.last();\n         match self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n                                                       namespace,\n                                                       xray) {\n             NoNameDefinition => {\n                 // We failed to resolve the name. Report an error.\n-                self.session.span_err(path.span,\n-                                      fmt!{\"unresolved name: %s::%s\",\n-                                           *(*self.atom_table).atoms_to_str\n-                                               ((*module_path_atoms).get()),\n-                                           *(*self.atom_table).atom_to_str\n-                                               (name)});\n+                self.session.span_err(\n+                    path.span,\n+                    fmt!{\"unresolved name: %s::%s\", self.atoms_to_str(\n+                        (*module_path_atoms).get()),\n+                         self.session.str_of(name)});\n                 return none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) => {\n@@ -4059,22 +4006,19 @@ struct Resolver {\n         }\n     }\n \n-    fn resolve_identifier_in_local_ribs(identifier: ident,\n+    fn resolve_identifier_in_local_ribs(ident: ident,\n                                         namespace: Namespace,\n                                         span: span)\n                                      -> option<def> {\n-\n-        let name = (*self.atom_table).intern(identifier);\n-\n         // Check the local set of ribs.\n         let mut search_result;\n         match namespace {\n             ValueNS => {\n-                search_result = self.search_ribs(self.value_ribs, name, span,\n+                search_result = self.search_ribs(self.value_ribs, ident, span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n-                search_result = self.search_ribs(self.type_ribs, name, span,\n+                search_result = self.search_ribs(self.type_ribs, ident, span,\n                                                  AllowCapturingSelf);\n             }\n             ModuleNS => {\n@@ -4086,7 +4030,7 @@ struct Resolver {\n             some(dl_def(def)) => {\n                 debug!{\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n-                       *(*self.atom_table).atom_to_str(name),\n+                       self.session.str_of(ident),\n                        def};\n                 return some(def);\n             }\n@@ -4100,11 +4044,9 @@ struct Resolver {\n                                                    namespace: Namespace)\n                                                 -> option<def> {\n \n-        let name = (*self.atom_table).intern(ident);\n-\n         // Check the items.\n         match self.resolve_item_in_lexical_scope(self.current_module,\n-                                               name,\n+                                               ident,\n                                                namespace) {\n \n             Success(target) => {\n@@ -4116,7 +4058,7 @@ struct Resolver {\n                     some(def) => {\n                         debug!{\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n-                               *(*self.atom_table).atom_to_str(name)};\n+                               self.session.str_of(ident)};\n                         return some(def.def);\n                     }\n                 }\n@@ -4149,14 +4091,17 @@ struct Resolver {\n                     some(def) => {\n                         // Write the result into the def map.\n                         debug!{\"(resolving expr) resolved `%s`\",\n-                               connect(path.idents.map(|x| *x), ~\"::\")};\n+                               connect(path.idents.map(\n+                                   |x| self.session.str_of(x)), ~\"::\")};\n                         self.record_def(expr.id, def);\n                     }\n                     none => {\n-                        self.session.span_err(expr.span,\n-                                              fmt!{\"unresolved name: %s\",\n-                                              connect(path.idents.map(|x| *x),\n-                                                      ~\"::\")});\n+                        self.session.span_err(\n+                            expr.span,\n+                            fmt!{\"unresolved name: %s\",\n+                                 connect(path.idents.map(\n+                                     |x| self.session.str_of(x)),\n+                                         ~\"::\")});\n                     }\n                 }\n \n@@ -4202,12 +4147,12 @@ struct Resolver {\n                         self.record_def(expr.id, definition);\n                     }\n                     _ => {\n-                        self.session.span_err(path.span,\n-                                              fmt!{\"`%s` does not name a \\\n-                                                    structure\",\n-                                                   connect(path.idents.map\n-                                                           (|x| *x),\n-                                                           ~\"::\")});\n+                        self.session.span_err(\n+                            path.span,\n+                            fmt!{\"`%s` does not name a structure\",\n+                                 connect(path.idents.map(\n+                                     |x| self.session.str_of(x)),\n+                                         ~\"::\")});\n                     }\n                 }\n \n@@ -4216,22 +4161,21 @@ struct Resolver {\n \n             expr_loop(_, some(label)) => {\n                 do self.with_label_rib {\n-                    let atom = self.atom_table.intern(label);\n                     let def_like = dl_def(def_label(expr.id));\n-                    self.label_ribs.last().bindings.insert(atom, def_like);\n+                    self.label_ribs.last().bindings.insert(label, def_like);\n \n                     visit_expr(expr, (), visitor);\n                 }\n             }\n \n             expr_break(some(label)) | expr_again(some(label)) => {\n-                let atom = self.atom_table.intern(label);\n-                match self.search_ribs(self.label_ribs, atom, expr.span,\n+                match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     none =>\n                         self.session.span_err(expr.span,\n                                               fmt!(\"use of undeclared label \\\n-                                                   `%s`\", *label)),\n+                                                   `%s`\", self.session.str_of(\n+                                                  label))),\n                     some(dl_def(def @ def_label(id))) =>\n                         self.record_def(expr.id, def),\n                     some(_) =>\n@@ -4250,8 +4194,7 @@ struct Resolver {\n     fn record_candidate_traits_for_expr_if_necessary(expr: @expr) {\n         match expr.node {\n             expr_field(_, ident, _) => {\n-                let atom = (*self.atom_table).intern(ident);\n-                let traits = self.search_for_traits_containing_method(atom);\n+                let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             expr_binary(add, _, _) | expr_assign_op(add, _, _) => {\n@@ -4401,7 +4344,7 @@ struct Resolver {\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n                        trait_def_id.node,\n-                       *(*self.atom_table).atom_to_str(name)};\n+                       self.session.str_of(name)};\n                 (*found_traits).push(trait_def_id);\n             }\n             some(_) | none => {\n@@ -4498,6 +4441,7 @@ struct Resolver {\n         }\n     }\n \n+\n     //\n     // Diagnostics\n     //\n@@ -4519,7 +4463,7 @@ struct Resolver {\n                     current_module = module_;\n                 }\n                 BlockParentLink(module_, node_id) => {\n-                    atoms.push((*self.atom_table).intern(@~\"<opaque>\"));\n+                    atoms.push(syntax::parse::token::special_idents::opaque);\n                     current_module = module_;\n                 }\n             }\n@@ -4535,7 +4479,7 @@ struct Resolver {\n             if i < atoms.len() - 1u {\n                 string += ~\"::\";\n             }\n-            string += *(*self.atom_table).atom_to_str(atoms.get_elt(i));\n+            string += self.session.str_of(atoms.get_elt(i));\n \n             if i == 0u {\n                 break;\n@@ -4551,7 +4495,7 @@ struct Resolver {\n \n         debug!{\"Children:\"};\n         for module_.children.each |name, _child| {\n-            debug!{\"* %s\", *(*self.atom_table).atom_to_str(name)};\n+            debug!{\"* %s\", self.session.str_of(name)};\n         }\n \n         debug!{\"Import resolutions:\"};\n@@ -4584,7 +4528,7 @@ struct Resolver {\n             }\n \n             debug!{\"* %s:%s%s%s\",\n-                   *(*self.atom_table).atom_to_str(name),\n+                   self.session.str_of(name),\n                    module_repr, value_repr, type_repr};\n         }\n     }"}, {"sha": "40623e9af93980b7f4ccd71bd5be64dc894c7967", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -95,7 +95,7 @@ type bind_map = ~[{\n \n fn assoc(key: ast::ident, list: bind_map) -> option<binding> {\n     for vec::each(list) |elt| {\n-        if str::eq(elt.ident, key) {\n+        if elt.ident == key {\n             return some(elt.binding);\n         }\n     }\n@@ -232,7 +232,7 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: match_, col: uint,\n             for vec::each(fields) |fname| {\n                 let mut pat = dummy;\n                 for vec::each(fpats) |fpat| {\n-                    if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n+                    if fpat.ident == fname { pat = fpat.pat; break; }\n                 }\n                 vec::push(pats, pat);\n             }\n@@ -334,7 +334,7 @@ fn collect_record_fields(m: match_, col: uint) -> ~[ast::ident] {\n         match br.pats[col].node {\n           ast::pat_rec(fs, _) => {\n             for vec::each(fs) |f| {\n-                if !vec::any(fields, |x| str::eq(f.ident, x)) {\n+                if !vec::any(fields, |x| f.ident == x) {\n                     vec::push(fields, f.ident);\n                 }\n             }\n@@ -351,7 +351,7 @@ fn collect_struct_fields(m: match_, col: uint) -> ~[ast::ident] {\n         match br.pats[col].node {\n           ast::pat_struct(_, fs, _) => {\n             for vec::each(fs) |f| {\n-                if !vec::any(fields, |x| str::eq(f.ident, x)) {\n+                if !vec::any(fields, |x| f.ident == x) {\n                     vec::push(fields, f.ident);\n                 }\n             }\n@@ -550,7 +550,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n         }\n \n         // Index the class fields.\n-        let field_map = std::map::box_str_hash();\n+        let field_map = std::map::uint_hash();\n         for class_fields.eachi |i, class_field| {\n             field_map.insert(class_field.ident, i);\n         }\n@@ -951,7 +951,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         }\n \n         // Index the class fields.\n-        let field_map = std::map::box_str_hash();\n+        let field_map = std::map::uint_hash();\n         for class_fields.eachi |i, class_field| {\n             field_map.insert(class_field.ident, i);\n         }"}, {"sha": "2f838ad8d40eb71d6f3ba20b879c71e47aeee50e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -49,6 +49,7 @@ import type_of::*;\n import common::*;\n import common::result;\n import syntax::ast_map::{path, path_mod, path_name};\n+import syntax::parse::token::special_idents;\n \n import std::smallintmap;\n import option::{is_none, is_some};\n@@ -500,8 +501,8 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     let llalign = llalign_of(ccx, llty);\n     //XXX this triggers duplicate LLVM symbols\n     let name = if false /*ccx.sess.opts.debuginfo*/ {\n-        mangle_internal_name_by_type_only(ccx, t, @~\"tydesc\")\n-    } else { mangle_internal_name_by_seq(ccx, @~\"tydesc\") };\n+        mangle_internal_name_by_type_only(ccx, t, ~\"tydesc\")\n+    } else { mangle_internal_name_by_seq(ccx, ~\"tydesc\") };\n     note_unique_llvm_symbol(ccx, name);\n     log(debug, fmt!{\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name});\n     let gvar = str::as_c_str(name, |buf| {\n@@ -529,9 +530,9 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n     let mut fn_nm;\n     //XXX this triggers duplicate LLVM symbols\n     if false /*ccx.sess.opts.debuginfo*/ {\n-        fn_nm = mangle_internal_name_by_type_only(ccx, t, @(~\"glue_\" + name));\n+        fn_nm = mangle_internal_name_by_type_only(ccx, t, (~\"glue_\" + name));\n     } else {\n-        fn_nm = mangle_internal_name_by_seq(ccx, @(~\"glue_\" + name));\n+        fn_nm = mangle_internal_name_by_seq(ccx, (~\"glue_\" + name));\n     }\n     note_unique_llvm_symbol(ccx, fn_nm);\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n@@ -698,8 +699,9 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(@~\"ty_visitor\");\n-    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(@~\"ty_visitor\");\n+    let ty_visitor_name = special_idents::ty_visitor;\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(ty_visitor_name);\n+    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n     build_return(bcx);\n@@ -1720,7 +1722,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n \n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n-    debug!{\"%s\", expr_to_str(ex)};\n+    debug!{\"%s\", expr_to_str(ex, bcx.tcx().sess.parse_sess.interner)};\n     let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n@@ -1731,7 +1733,8 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n       some(origin) => {\n         let bcx = lhs_res.bcx;\n         debug!{\"user-defined method callee_id: %s\",\n-               ast_map::node_id_to_str(bcx.tcx().items, ex.callee_id)};\n+               ast_map::node_id_to_str(bcx.tcx().items, ex.callee_id,\n+                                       bcx.sess().parse_sess.interner)};\n         let fty = node_id_type(bcx, ex.callee_id);\n \n         let dty = expr_ty(bcx, dst);\n@@ -2164,7 +2167,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n              must_cast: true};\n       }\n       ast_map::node_ctor(nm, _, ct, _, pt) => (pt, nm, ct.span),\n-      ast_map::node_dtor(_, dtor, _, pt) => (pt, @~\"drop\", dtor.span),\n+      ast_map::node_dtor(_, dtor, _, pt) =>\n+          (pt, special_idents::dtor, dtor.span),\n       ast_map::node_trait_method(*) => {\n         ccx.tcx.sess.bug(~\"Can't monomorphize a trait method\")\n       }\n@@ -2198,7 +2202,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     }\n     ccx.monomorphizing.insert(fn_id, depth + 1u);\n \n-    let pt = vec::append(*pt, ~[path_name(@ccx.names(*name))]);\n+    let pt = vec::append(*pt,\n+                         ~[path_name(ccx.names(ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, pt, mono_ty);\n \n     let mk_lldecl = || {\n@@ -2897,9 +2902,9 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n                   &temp_cleanups: ~[ValueRef], ret_flag: option<ValueRef>,\n                   derefs: uint)\n     -> result {\n-    debug!{\"+++ trans_arg_expr on %s\", expr_to_str(e)};\n     let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n+    debug!{\"+++ trans_arg_expr on %s\", expr_to_str(e, ccx.sess.intr())};\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n \n@@ -3436,9 +3441,8 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n \n     let mut temp_cleanups = ~[];\n     for fields.each |fld| {\n-        let ix = option::get(vec::position(ty_fields, |ft| {\n-            str::eq(fld.node.ident, ft.ident)\n-        }));\n+        let ix = option::get(vec::position(ty_fields,\n+            |ft| ft.ident == fld.node.ident));\n         let dst = GEPi(bcx, addr, ~[0u, ix]);\n         bcx = trans_expr_save_in(bcx, fld.node.expr, dst);\n         add_clean_temp_mem(bcx, dst, ty_fields[ix].mt.ty);\n@@ -3450,7 +3454,7 @@ fn trans_rec(bcx: block, fields: ~[ast::field],\n         bcx = cx;\n         // Copy over inherited fields\n         for ty_fields.eachi |i, tf| {\n-            if !vec::any(fields, |f| str::eq(f.node.ident, tf.ident)) {\n+            if !vec::any(fields, |f| f.node.ident == tf.ident) {\n                 let dst = GEPi(bcx, addr, ~[0u, i]);\n                 let base = GEPi(bcx, base_val, ~[0u, i]);\n                 let val = load_if_immediate(bcx, base, tf.mt.ty);\n@@ -3533,7 +3537,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n     for fields.each |field| {\n         let mut found = none;\n         for class_fields.eachi |i, class_field| {\n-            if str::eq(class_field.ident, field.node.ident) {\n+            if class_field.ident == field.node.ident {\n                 found = some((i, class_field.id));\n                 break;\n             }\n@@ -3572,7 +3576,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n             // Copy over inherited fields.\n             for class_fields.eachi |i, class_field| {\n                 let exists = do vec::any(fields) |provided_field| {\n-                    str::eq(provided_field.node.ident, class_field.ident)\n+                   provided_field.node.ident == class_field.ident\n                 };\n                 if exists {\n                     again;\n@@ -3809,7 +3813,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             match check ty::get(expr_ty(bcx, e)).struct {\n               ty::ty_fn({proto, _}) => {\n                 debug!{\"translating fn_block %s with type %s\",\n-                       expr_to_str(e),\n+                       expr_to_str(e, tcx.sess.intr()),\n                        ppaux::ty_to_str(tcx, expr_ty(bcx, e))};\n                 return closure::trans_expr_fn(bcx, proto, decl, body,\n                                            e.id, cap_clause, none, dest);\n@@ -3941,8 +3945,8 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n     let last_use = (lv.kind == lv_owned && last_use_map.contains_key(e.id));\n-    debug!{\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n-           lv.kind as int};\n+    debug!{\"is last use (%s) = %b, %d\", expr_to_str(e, bcx.ccx().sess.intr()),\n+           last_use, lv.kind as int};\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n \n@@ -4016,17 +4020,17 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n     }\n \n     let modpath = vec::append(\n-        ~[path_mod(ccx.link_meta.name)],\n+        ~[path_mod(ccx.sess.ident_of(ccx.link_meta.name))],\n         vec::filter(bcx.fcx.path, |e|\n             match e { path_mod(_) => true, _ => false }\n         ));\n-    let modname = path_str(modpath);\n+    let modname = path_str(ccx.sess, modpath);\n \n     let global = if ccx.module_data.contains_key(modname) {\n         ccx.module_data.get(modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n-            ccx, modpath, @~\"loglevel\");\n+            ccx, modpath, ~\"loglevel\");\n         let global = str::as_c_str(s, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n         });\n@@ -4061,7 +4065,8 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n                     pred_expr: @ast::expr, s: ~str) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n-    let expr_str = s + ~\" \" + expr_to_str(pred_expr) + ~\" failed\";\n+    let expr_str = s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n+        + ~\" failed\";\n     let {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n             trans_temp_expr(bcx, pred_expr)\n@@ -4292,10 +4297,10 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(\"trans_stmt\");\n-    debug!{\"trans_stmt(%s)\", stmt_to_str(s)};\n+    debug!{\"trans_stmt(%s)\", stmt_to_str(s, cx.tcx().sess.intr())};\n \n     if !cx.sess().no_asm_comments() {\n-        add_span_comment(cx, s.span, stmt_to_str(s));\n+        add_span_comment(cx, s.span, stmt_to_str(s, cx.ccx().sess.intr()));\n     }\n \n     let mut bcx = cx;\n@@ -4331,8 +4336,8 @@ fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         cx.ccx.names(name)\n-    } else { ~\"\" };\n-    let llbb: BasicBlockRef = str::as_c_str(s, |buf| {\n+    } else { special_idents::invalid };\n+    let llbb: BasicBlockRef = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n     let bcx = mk_block(llbb, parent, kind, is_lpad, opt_node_info, cx);\n@@ -4543,7 +4548,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         do option::iter(simple_name) |name| {\n-            str::as_c_str(*name, |buf| {\n+            str::as_c_str(cx.ccx().sess.str_of(name), |buf| {\n                 llvm::LLVMSetValueName(val, buf)\n             });\n         }\n@@ -4808,7 +4813,7 @@ fn trans_fn(ccx: @crate_ctxt,\n                   |_bcx| { });\n     if do_time {\n         let end = time::get_time();\n-        log_fn_time(ccx, path_str(path), start, end);\n+        log_fn_time(ccx, path_str(ccx.sess, path), start, end);\n     }\n }\n \n@@ -4824,7 +4829,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     let fn_args = vec::map(args, |varg|\n         {mode: ast::expl(ast::by_copy),\n          ty: varg.ty,\n-         ident: @~\"arg\",\n+         ident: special_idents::arg,\n          id: varg.id});\n     let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id,\n                                param_substs, none);\n@@ -5129,7 +5134,8 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n     ccx.item_symbols.insert(node_id, ps);\n \n     debug!{\"register_fn_fuller created fn %s for item %d with path %s\",\n-           val_str(ccx.tn, llfn), node_id, ast_map::path_to_str(path)};\n+           val_str(ccx.tn, llfn), node_id,\n+           ast_map::path_to_str(path, ccx.sess.parse_sess.interner)};\n \n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n@@ -5252,7 +5258,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n      none if is_none(substs) => {\n        let s = mangle_exported_name(\n            ccx,\n-           vec::append(path, ~[path_name(@ccx.names(~\"dtor\"))]),\n+           vec::append(path, ~[path_name(ccx.names(~\"dtor\"))]),\n            t);\n        ccx.item_symbols.insert(id, s);\n        s\n@@ -5266,7 +5272,7 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n            mangle_exported_name(\n                ccx,\n                vec::append(path,\n-                           ~[path_name(@ccx.names(~\"dtor\"))]),\n+                           ~[path_name(ccx.names(~\"dtor\"))]),\n                mono_ty)\n          }\n          none => {\n@@ -5397,7 +5403,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n                 m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n-    let pth = vec::append(*pth, ~[path_name(@ccx.names(~\"meth\")),\n+    let pth = vec::append(*pth, ~[path_name(ccx.names(~\"meth\")),\n                                   path_name(m.ident)]);\n     let llfn = register_fn_full(ccx, m.span, pth, id, mty);\n     set_inline_hint_if_appr(m.attrs, llfn);\n@@ -5415,7 +5421,7 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n         let path = item_path(ccx, it);\n         for vec::each(enum_definition.variants) |variant| {\n             let p = vec::append(path, ~[path_name(variant.node.name),\n-                                       path_name(@~\"discrim\")]);\n+                                        path_name(special_idents::descrim)]);\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n@@ -5535,7 +5541,7 @@ fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n             do vec::iter(attr_metas) |attr_meta| {\n                 match attr::get_meta_item_list(attr_meta) {\n                   some(list) => {\n-                    let name = *attr::get_meta_item_name(vec::head(list));\n+                    let name = attr::get_meta_item_name(vec::head(list));\n                     push_rtcall(ccx, name, {crate: ast::local_crate,\n                                             node: item.id});\n                   }\n@@ -5551,7 +5557,7 @@ fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n \n fn gather_external_rtcalls(ccx: @crate_ctxt) {\n     do cstore::iter_crate_data(ccx.sess.cstore) |_cnum, cmeta| {\n-        do decoder::each_path(cmeta) |path| {\n+        do decoder::each_path(ccx.sess.intr(), cmeta) |path| {\n             let pathname = path.path_string;\n             match path.def_like {\n               decoder::dl_def(d) => {\n@@ -5624,7 +5630,7 @@ fn decl_crate_map(sess: session::session, mapmeta: link_meta,\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     let mapname = if sess.building_library {\n-        *mapmeta.name + ~\"_\" + *mapmeta.vers + ~\"_\" + mapmeta.extras_hash\n+        mapmeta.name + ~\"_\" + mapmeta.vers + ~\"_\" + mapmeta.extras_hash\n     } else { ~\"toplevel\" };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n@@ -5643,8 +5649,8 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n         let nm = ~\"_rust_crate_map_\" + cdata.name +\n-            ~\"_\" + *cstore::get_crate_vers(cstore, i) +\n-            ~\"_\" + *cstore::get_crate_hash(cstore, i);\n+            ~\"_\" + cstore::get_crate_vers(cstore, i) +\n+            ~\"_\" + cstore::get_crate_hash(cstore, i);\n         let cr = str::as_c_str(nm, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n@@ -5683,8 +5689,8 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n                 if !def.reexp { again; }\n                 let path = match check cx.tcx.items.get(exp_id) {\n                     ast_map::node_export(_, path) => {\n-\n-                        ast_map::path_to_str(*path)\n+                        ast_map::path_to_str(*path,\n+                                             cx.sess.parse_sess.interner)\n                     }\n                 };\n                 vec::push(reexports, (path, def.id));\n@@ -5746,7 +5752,7 @@ fn trans_crate(sess: session::session,\n     // crashes if the module identifer is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-    let llmod_id = *link_meta.name + ~\".rc\";\n+    let llmod_id = link_meta.name + ~\".rc\";\n \n     let llmod = str::as_c_str(llmod_id, |buf| {\n         llvm::LLVMModuleCreateWithNameInContext\n@@ -5776,7 +5782,7 @@ fn trans_crate(sess: session::session,\n     lib::llvm::associate_type(tn, ~\"tydesc\", tydesc_type);\n     let crate_map = decl_crate_map(sess, link_meta, llmod);\n     let dbg_cx = if sess.opts.debuginfo {\n-        option::some(debuginfo::mk_ctxt(llmod_id))\n+        option::some(debuginfo::mk_ctxt(llmod_id, sess.parse_sess.interner))\n     } else {\n         option::none\n     };\n@@ -5808,7 +5814,7 @@ fn trans_crate(sess: session::session,\n           const_globals: int_hash::<ValueRef>(),\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n-          names: new_namegen(),\n+          names: new_namegen(sess.parse_sess.interner),\n           symbol_hasher: symbol_hasher,\n           type_hashcodes: ty::new_ty_hash(),\n           type_short_names: ty::new_ty_hash(),"}, {"sha": "7b2ba7eee3bfcaf8f24d4b9afedcc98bf010252f", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -263,7 +263,9 @@ fn build_closure(bcx0: block,\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n         debug!{\"Node id is %s\",\n-               syntax::ast_map::node_id_to_str(bcx.ccx().tcx.items, nid)};\n+               syntax::ast_map::node_id_to_str\n+                   (bcx.ccx().tcx.items, nid,\n+                    bcx.ccx().sess.parse_sess.interner)};\n         let mut ty = node_id_type(bcx, nid);\n         match cap_var.mode {\n           capture::cap_ref => {\n@@ -359,7 +361,8 @@ fn trans_expr_fn(bcx: block,\n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, id);\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n-    let sub_path = vec::append_one(bcx.fcx.path, path_name(@~\"anon\"));\n+    let sub_path = vec::append_one(bcx.fcx.path,\n+                                   path_name(special_idents::anon));\n     let s = mangle_internal_name_by_path(ccx, sub_path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n "}, {"sha": "19f591f48855bcd007224d17eabe43f7898b59b7", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -20,11 +20,14 @@ import metadata::{csearch};\n import metadata::common::link_meta;\n import syntax::ast_map::path;\n import util::ppaux::ty_to_str;\n+import syntax::parse::token::ident_interner;\n+import syntax::ast::ident;\n \n-type namegen = fn@(~str) -> ~str;\n-fn new_namegen() -> namegen {\n-    let i = @mut 0;\n-    return fn@(prefix: ~str) -> ~str { *i += 1; prefix + int::str(*i) };\n+type namegen = fn@(~str) -> ident;\n+fn new_namegen(intr: ident_interner) -> namegen {\n+    return fn@(prefix: ~str) -> ident {\n+        return intr.gensym(@fmt!(\"%s_%u\", prefix, intr.gensym(@prefix)))\n+    };\n }\n \n type tydesc_info =\n@@ -873,7 +876,7 @@ fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n         llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n     };\n     let g =\n-        str::as_c_str(cx.names(~\"str\"),\n+        str::as_c_str(fmt!{\"str%u\", cx.names(~\"str\")},\n                     |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n@@ -927,7 +930,7 @@ fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n \n fn C_shape(ccx: @crate_ctxt, bytes: ~[u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal = str::as_c_str(ccx.names(~\"shape\"), |buf| {\n+    let llglobal = str::as_c_str(fmt!{\"shape%u\", ccx.names(~\"shape\")}, |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llshape);\n@@ -983,13 +986,13 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n     return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n-fn path_str(p: path) -> ~str {\n+fn path_str(sess: session::session, p: path) -> ~str {\n     let mut r = ~\"\", first = true;\n     for vec::each(p) |e| {\n         match e { ast_map::path_name(s) | ast_map::path_mod(s) => {\n           if first { first = false; }\n           else { r += ~\"::\"; }\n-          r += *s;\n+          r += sess.str_of(s);\n         } }\n     }\n     r\n@@ -1023,7 +1026,7 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n     match ty::field_idx(ident, fields) {\n        none => cx.sess.span_bug(\n            sp, fmt!{\"base expr doesn't appear to \\\n-                         have a field named %s\", *ident}),\n+                         have a field named %s\", cx.sess.str_of(ident)}),\n        some(i) => i\n     }\n }"}, {"sha": "b1b70fe98a88aa4162a5062e90048ee9501661e4", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -7,6 +7,7 @@ import trans::base;\n import trans::build::B;\n import middle::ty;\n import syntax::{ast, codemap, ast_util, ast_map};\n+import syntax::parse::token::ident_interner;\n import codemap::span;\n import ast::ty;\n import pat_util::*;\n@@ -89,9 +90,9 @@ type debug_ctxt = {\n     crate_file: ~str\n };\n \n-fn mk_ctxt(crate: ~str) -> debug_ctxt {\n+fn mk_ctxt(crate: ~str, intr: ident_interner) -> debug_ctxt {\n     {llmetadata: map::int_hash(),\n-     names: new_namegen(),\n+     names: new_namegen(intr),\n      crate_file: crate}\n }\n \n@@ -392,14 +393,15 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n-                               option::get(cx.dbg_cx).names(~\"rec\"),\n+                               cx.sess.str_of(\n+                                   option::get(cx.dbg_cx).names(~\"rec\")),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for fields.each |field| {\n         let field_t = ty::get_field(t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, *field.node.ident,\n+        add_member(scx, cx.sess.str_of(field.node.ident),\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n@@ -635,7 +637,7 @@ fn create_local_var(bcx: block, local: @ast::local)\n         none => create_function(bcx.fcx).node,\n         some(_) => create_block(bcx).node\n     };\n-    let mdnode = create_var(tg, context, *name, filemd.node,\n+    let mdnode = create_var(tg, context, cx.sess.str_of(name), filemd.node,\n                             loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: local.node.id}};\n     update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n@@ -677,8 +679,8 @@ fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.file.name);\n     let context = create_function(bcx.fcx);\n-    let mdnode = create_var(tg, context.node, *arg.ident, filemd.node,\n-                            loc.line as int, tymd.node);\n+    let mdnode = create_var(tg, context.node, cx.sess.str_of(arg.ident),\n+                            filemd.node, loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n     update_cache(cache, tg, argument_metadata(mdval));\n \n@@ -736,10 +738,10 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn(_, decl, _, _) => {\n-            (@dbg_cx.names(~\"fn\"), decl.output, expr.id)\n+            (dbg_cx.names(~\"fn\"), decl.output, expr.id)\n           }\n           ast::expr_fn_block(decl, _, _) => {\n-            (@dbg_cx.names(~\"fn\"), decl.output, expr.id)\n+            (dbg_cx.names(~\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                                      ~\"create_function: \\\n@@ -778,8 +780,9 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let fn_metadata = ~[lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n-                       llstr(*ident),\n-                       llstr(*ident), //XXX fully-qualified C++ name\n+                       llstr(cx.sess.str_of(ident)),\n+                        //XXX fully-qualified C++ name:\n+                       llstr(cx.sess.str_of(ident)),\n                        llstr(~\"\"), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),"}, {"sha": "3b671b1148385ec4a9f490a5127f858104d72107", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -412,10 +412,10 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     return llfn;\n }\n \n-fn link_name(i: @ast::foreign_item) -> ~str {\n+fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> ~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n-      none => return *i.ident,\n-      option::some(ln) => return *ln\n+        none => ccx.sess.str_of(i.ident),\n+        option::some(ln) => ln\n     }\n }\n \n@@ -669,7 +669,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             }\n         }\n \n-        let lname = link_name(foreign_item);\n+        let lname = link_name(ccx, foreign_item);\n         let llbasefn = base_fn(ccx, lname, tys, cc);\n         // Name the shim function\n         let shim_name = lname + ~\"__c_stack_shim\";\n@@ -700,7 +700,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                        cc: lib::llvm::CallConv) {\n         let fcx = new_fn_ctxt(ccx, ~[], decl, none);\n         let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n-        let llbasefn = base_fn(ccx, link_name(item), tys, cc);\n+        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n         let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n@@ -799,7 +799,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id,\n                                some(substs), some(item.span));\n     let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n-    match *item.ident {\n+    match ccx.sess.str_of(item.ident) {\n       // NB: Transitionary, de-mode-ing. Remove the first string of each\n       // pattern when the old intrinsics are gone.\n       ~\"atomic_xchng\" | ~\"atomic_xchg\" => {\n@@ -1001,7 +1001,9 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one(path, ast_map::path_name(@~\"__rust_abi\")));\n+            ccx, vec::append_one(path, ast_map::path_name(\n+                syntax::parse::token::special_idents::clownshoe_abi\n+            )));\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n         trans_fn(ccx, path, decl, body, llfndecl, no_self, none, id);\n@@ -1038,8 +1040,9 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one(path,\n-                                 ast_map::path_name(@~\"__rust_stack_shim\")));\n+            ccx, vec::append_one(path, ast_map::path_name(\n+                syntax::parse::token::special_idents::clownshoe_stack_shim\n+            )));\n         return build_shim_fn_(ccx, shim_name, llrustfn, tys,\n                            lib::llvm::CCallConv,\n                            build_args, build_ret);"}, {"sha": "2c927d2cc5defa9f8fcfd4e0e52277bd9db5f8d0", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -163,7 +163,7 @@ fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n-            name=%s\", method_id, callee_id, *mname);\n+            name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n@@ -361,7 +361,7 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n-    let vt_gvar = str::as_c_str(ccx.names(~\"vtable\"), |buf| {\n+    let vt_gvar = str::as_c_str(ccx.sess.str_of(ccx.names(~\"vtable\")), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n     });\n     llvm::LLVMSetInitializer(vt_gvar, tbl);"}, {"sha": "96169c8a22a4aead0b03763fd6c9e5d398c171bd", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -175,7 +175,8 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n                 none      => cx.tcx.sess.span_bug(e.span, fmt!{\"Unbound node \\\n-                  id %? while traversing %s\", e.id, expr_to_str(e)})\n+                  id %? while traversing %s\", e.id,\n+                  expr_to_str(e, cx.tcx.sess.intr())})\n             }\n           }\n           expr_field(_, _, _) => {"}, {"sha": "7a21bea30d392e7f7c3947db47c6bcf4718b46f4", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -55,8 +55,9 @@ impl reflector {\n \n     fn visit(ty_name: ~str, args: ~[ValueRef]) {\n         let tcx = self.bcx.tcx();\n-        let mth_idx = option::get(ty::method_idx(@(~\"visit_\" + ty_name),\n-                                                 *self.visitor_methods));\n+        let mth_idx = option::get(ty::method_idx(\n+            tcx.sess.ident_of(~\"visit_\" + ty_name),\n+            *self.visitor_methods));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n         let get_lval = |bcx| {\n@@ -157,7 +158,8 @@ impl reflector {\n                 for fields.eachi |i, field| {\n                     self.visit(~\"rec_field\",\n                                ~[self.c_uint(i),\n-                                 self.c_slice(*field.ident)]\n+                                 self.c_slice(\n+                                     bcx.ccx().sess.str_of(field.ident))]\n                                + self.c_mt(field.mt));\n                 }\n             }\n@@ -233,7 +235,8 @@ impl reflector {\n                 for fields.eachi |i, field| {\n                     self.visit(~\"class_field\",\n                                ~[self.c_uint(i),\n-                                self.c_slice(*field.ident)]\n+                                 self.c_slice(\n+                                     bcx.ccx().sess.str_of(field.ident))]\n                                + self.c_mt(field.mt));\n                 }\n             }\n@@ -256,7 +259,8 @@ impl reflector {\n                                       ~[self.c_uint(i),\n                                         self.c_int(v.disr_val),\n                                         self.c_uint(vec::len(v.args)),\n-                                        self.c_slice(*v.name)]) {\n+                                        self.c_slice(\n+                                            bcx.ccx().sess.str_of(v.name))]) {\n                         for v.args.eachi |j, a| {\n                             self.visit(~\"enum_variant_field\",\n                                        ~[self.c_uint(j),\n@@ -291,10 +295,10 @@ impl reflector {\n fn emit_calls_to_trait_visit_ty(bcx: block, t: ty::t,\n                                 visitor_val: ValueRef,\n                                 visitor_trait_id: def_id) -> block {\n-\n+    import syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n-    assert bcx.ccx().tcx.intrinsic_defs.contains_key(@~\"tydesc\");\n-    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(@~\"tydesc\");\n+    assert bcx.ccx().tcx.intrinsic_defs.contains_key(tydesc);\n+    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(tydesc);\n     let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n     let r = reflector({\n         visitor_val: visitor_val,"}, {"sha": "1781fdd7931a17355bc4e7fe19825e4766e6115b", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -391,7 +391,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             let variant_shape = shape_of_variant(ccx, v);\n             add_substr(data, variant_shape);\n \n-            let zname = str::bytes(*v.name) + ~[0u8];\n+            let zname = str::bytes(ccx.sess.str_of(v.name)) + ~[0u8];\n             add_substr(data, zname);\n         }\n         enum_variants += ~[variants];\n@@ -732,9 +732,9 @@ fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_class(did, ref substs) => {\n             let simpl_fields = (if is_some(ty::ty_dtor(tcx, did)) {\n                 // remember the drop flag\n-                  ~[{ident: @~\"drop\", mt: {ty:\n-                                        ty::mk_u8(tcx),\n-                                        mutbl: ast::m_mutbl}}] }\n+                  ~[{ident: syntax::parse::token::special_idents::dtor,\n+                     mt: {ty: ty::mk_u8(tcx),\n+                          mutbl: ast::m_mutbl}}] }\n                 else { ~[] }) +\n                 do ty::lookup_class_fields(tcx, did).map |f| {\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);"}, {"sha": "727bf0d9e086617d32456085c5933b7c1b061e7f", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -81,7 +81,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_foreign_item(i@@{node: foreign_item_fn(_, _), _},\n                                  abi, _) => {\n         if abi == foreign_abi_rust_intrinsic {\n-            let flags = match *i.ident {\n+            let flags = match cx.ccx.sess.str_of(i.ident) {\n               ~\"size_of\" |  ~\"pref_align_of\" | ~\"min_align_of\" |\n               ~\"init\" |  ~\"reinterpret_cast\" |\n               ~\"move_val\" | ~\"move_val_init\" => {"}, {"sha": "773d8f3a684462861ce69512259dbce79ad8dd20", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -616,7 +616,7 @@ fn mk_ctxt(s: session::session,\n       node_types: @smallintmap::mk(),\n       node_type_substs: map::int_hash(),\n       items: amap,\n-      intrinsic_defs: map::box_str_hash(),\n+      intrinsic_defs: map::uint_hash(),\n       freevars: freevars,\n       tcache: ast_util::new_def_hash(),\n       rcache: mk_rcache(),\n@@ -2200,7 +2200,7 @@ pure fn hash_bound_region(br: &bound_region) -> uint {\n     match *br { // no idea if this is any good\n       ty::br_self => 0u,\n       ty::br_anon(idx) => 1u | (idx << 2),\n-      ty::br_named(str) => 2u | (str::hash(str) << 2),\n+      ty::br_named(ident) => 2u | (ident << 2),\n       ty::br_cap_avoid(id, br) =>\n         3u | (id as uint << 2) | hash_bound_region(br)\n     }\n@@ -2310,10 +2310,13 @@ pure fn hash_type_structure(st: &sty) -> uint {\n }\n \n fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n+    //io::println(fmt!(\"%?/%?\", id, cx.node_types.size()));\n     match smallintmap::find(*cx.node_types, id as uint) {\n        some(t) => t,\n-       none => cx.sess.bug(fmt!{\"node_id_to_type: unbound node ID %s\",\n-                                ast_map::node_id_to_str(cx.items, id)})\n+       none => cx.sess.bug(\n+           fmt!{\"node_id_to_type: unbound node ID %s\",\n+                ast_map::node_id_to_str(cx.items, id,\n+                                        cx.sess.parse_sess.interner)})\n     }\n }\n \n@@ -2482,7 +2485,7 @@ fn field_idx(id: ast::ident, fields: ~[field]) -> option<uint> {\n }\n \n fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    match check vec::find(get_fields(rec_ty), |f| str::eq(f.ident, id)) {\n+    match check vec::find(get_fields(rec_ty), |f| f.ident == id) {\n       some(f) => f\n     }\n }\n@@ -2703,9 +2706,9 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         ~\"record elements differ in mutability\"\n       }\n       terr_record_fields(values) => {\n-        fmt!(\"expected a record with field `%s` \\\n-              but found one with field `%s`\",\n-             *values.expected, *values.found)\n+        fmt!(\"expected a record with field `%s` but found one with field \\\n+              `%s`\",\n+             cx.sess.str_of(values.expected), cx.sess.str_of(values.found))\n       }\n       terr_arg_count => ~\"incorrect number of function parameters\",\n       terr_mode_mismatch(values) => {\n@@ -2734,7 +2737,8 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                     vstore_to_str(cx, values.found))\n       }\n       terr_in_field(err, fname) => {\n-        fmt!{\"in field `%s`, %s\", *fname, type_err_to_str(cx, err)}\n+        fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n+             type_err_to_str(cx, err))\n       }\n       terr_sorts(values) => {\n         fmt!{\"expected %s but found %s\",\n@@ -2844,7 +2848,7 @@ fn substd_enum_variants(cx: ctxt,\n }\n \n fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n-    ast_map::path_to_str(item_path(cx, id))\n+    ast_map::path_to_str(item_path(cx, id), cx.sess.parse_sess.interner)\n }\n \n /* If class_id names a class with a dtor, return some(the dtor's id).\n@@ -2909,7 +2913,8 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::append_one(*path, ast_map::path_name(nm))\n           }\n           ast_map::node_dtor(_, _, _, path) => {\n-            vec::append_one(*path, ast_map::path_name(@~\"dtor\"))\n+            vec::append_one(*path, ast_map::path_name(\n+                syntax::parse::token::special_idents::literally_dtor))\n           }\n \n           ast_map::node_stmt(*) | ast_map::node_expr(*) |\n@@ -3062,8 +3067,10 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n          }\n        }\n        _ => {\n-           cx.sess.bug(fmt!{\"class ID not bound to an item: %s\",\n-                            ast_map::node_id_to_str(cx.items, did.node)});\n+           cx.sess.bug(\n+               fmt!{\"class ID not bound to an item: %s\",\n+                    ast_map::node_id_to_str(cx.items, did.node,\n+                                            cx.sess.parse_sess.interner)});\n        }\n     }\n         }\n@@ -3129,7 +3136,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n          }\n        }\n        cx.sess.span_fatal(sp, fmt!{\"Class doesn't have a method \\\n-           named %s\", *name});\n+           named %s\", cx.sess.str_of(name)});\n     }\n     else {\n       csearch::get_class_method(cx.sess.cstore, did, name)"}, {"sha": "76788bd0555528438485b999e1a39ad076c53c19", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -309,8 +309,9 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n       }\n       ast::ty_path(path, id) => {\n         let a_def = match tcx.def_map.find(id) {\n-          none => tcx.sess.span_fatal(ast_ty.span, fmt!{\"unbound path %s\",\n-                                                        path_to_str(path)}),\n+          none => tcx.sess.span_fatal(\n+              ast_ty.span, fmt!{\"unbound path %s\",\n+                                path_to_str(path, tcx.sess.intr())}),\n           some(d) => d\n         };\n         match a_def {"}, {"sha": "9dd5af2cf10616aeb07a94cf35ab01635f054780", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -75,7 +75,7 @@ import rscope::{in_binding_rscope, region_scope, type_rscope};\n import syntax::ast::ty_i;\n import typeck::infer::{resolve_type, force_tvar};\n \n-import std::map::str_hash;\n+import std::map::{str_hash, uint_hash};\n \n type self_info = {\n     self_ty: ty::t,\n@@ -335,7 +335,8 @@ fn check_fn(ccx: @crate_ctxt,\n         do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n             assign(input.ty.span, input.id, some(arg_ty));\n             debug!{\"Argument %s is assigned to %s\",\n-                   *input.ident, fcx.locals.get(input.id).to_str()};\n+                   tcx.sess.str_of(input.ident),\n+                   fcx.locals.get(input.id).to_str()};\n         }\n \n         // Add explicitly-declared locals.\n@@ -347,7 +348,7 @@ fn check_fn(ccx: @crate_ctxt,\n             };\n             assign(local.span, local.node.id, o_ty);\n             debug!{\"Local variable %s is assigned to %s\",\n-                   pat_to_str(local.node.pat),\n+                   pat_to_str(local.node.pat, tcx.sess.intr()),\n                    fcx.locals.get(local.node.id).to_str()};\n             visit::visit_local(local, e, v);\n         };\n@@ -359,7 +360,7 @@ fn check_fn(ccx: @crate_ctxt,\n                   if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.span, p.id, none);\n                 debug!{\"Pattern binding %s is assigned to %s\",\n-                       *path.idents[0],\n+                       tcx.sess.str_of(path.idents[0]),\n                        fcx.locals.get(p.id).to_str()};\n               }\n               _ => {}\n@@ -405,15 +406,15 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method,\n \n fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n                              ~[(ast::ident, span)]) {\n-    let field_names = hashmap::<@~str, span>(|x| str::hash(*x),\n-                                             |x,y| str::eq(*x, *y));\n+    let field_names = uint_hash();\n+\n     for fields.each |p| {\n         let (id, sp) = p;\n         match field_names.find(id) {\n           some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!{\"Duplicate field \\\n                                    name %s in record type declaration\",\n-                                   *id});\n+                                        tcx.sess.str_of(id)});\n             tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n                                           this field occurred here\");\n             break;\n@@ -479,7 +480,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_impl(tps, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n         debug!{\"item_impl %s with id %d rp %b\",\n-               *it.ident, it.id, rp};\n+               ccx.tcx.sess.str_of(it.ident), it.id, rp};\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n             check_method(ccx, m, self_ty, local_def(it.id));\n@@ -555,9 +556,11 @@ impl @fn_ctxt: region_scope {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             match self.in_scope_regions.find(ty::br_named(id)) {\n               some(r) => result::ok(r),\n-              none if *id == ~\"blk\" => result::ok(self.block_region()),\n+              none if id == syntax::parse::token::special_idents::blk\n+                  => result::ok(self.block_region()),\n               none => {\n-                result::err(fmt!{\"named region `%s` not in scope here\", *id})\n+                result::err(fmt!{\"named region `%s` not in scope here\",\n+                                 self.ccx.tcx.sess.str_of(id)})\n               }\n             }\n         }\n@@ -601,8 +604,10 @@ impl @fn_ctxt {\n         match self.node_types.find(ex.id) {\n           some(t) => t,\n           none => {\n-            self.tcx().sess.bug(fmt!{\"no type for expr %d (%s) in fcx %s\",\n-                                     ex.id, expr_to_str(ex), self.tag()});\n+            self.tcx().sess.bug(\n+                fmt!{\"no type for expr %d (%s) in fcx %s\",\n+                     ex.id, expr_to_str(ex, self.ccx.tcx.sess.intr()),\n+                     self.tag()});\n           }\n         }\n     }\n@@ -612,7 +617,9 @@ impl @fn_ctxt {\n           none => {\n             self.tcx().sess.bug(\n                 fmt!{\"no type for node %d: %s in fcx %s\",\n-                     id, ast_map::node_id_to_str(self.tcx().items, id),\n+                     id, ast_map::node_id_to_str(\n+                         self.tcx().items, id,\n+                         self.tcx().sess.parse_sess.interner),\n                      self.tag()});\n           }\n         }\n@@ -623,7 +630,9 @@ impl @fn_ctxt {\n           none => {\n             self.tcx().sess.bug(\n                 fmt!{\"no type substs for node %d: %s in fcx %s\",\n-                     id, ast_map::node_id_to_str(self.tcx().items, id),\n+                     id, ast_map::node_id_to_str(\n+                         self.tcx().items, id,\n+                         self.tcx().sess.parse_sess.interner),\n                      self.tag()});\n           }\n         }\n@@ -842,8 +851,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expected: option<ty::t>,\n                            unifier: fn()) -> bool {\n \n-    debug!{\">> typechecking expr %d (%s)\",\n-           expr.id, syntax::print::pprust::expr_to_str(expr)};\n+    debug!{\n+        \">> typechecking expr %d (%s)\",\n+        expr.id, syntax::print::pprust::expr_to_str(expr,\n+                                                    fcx.ccx.tcx.sess.intr())};\n \n     // A generic function to factor out common logic from call and\n     // overloaded operations\n@@ -1028,10 +1039,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n                         self_ex: @ast::expr, self_t: ty::t,\n-                        opname: ~str, args: ~[@ast::expr])\n+                        opname: ast::ident, args: ~[@ast::expr])\n         -> option<(ty::t, bool)> {\n         let lkup = method::lookup(fcx, op_ex, self_ex, op_ex.id,\n-                     op_ex.callee_id, @opname, self_t, ~[], false);\n+                     op_ex.callee_id, opname, self_t, ~[], false);\n         match lkup.method() {\n           some(origin) => {\n             let {fty: method_ty, bot: bot} = {\n@@ -1100,9 +1111,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n           some(name) => {\n-            match lookup_op_method(fcx, ex,\n-                                 lhs_expr, lhs_resolved_t,\n-                                 name, ~[rhs]) {\n+            match lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n+                                   fcx.tcx().sess.ident_of(name), ~[rhs]) {\n               some(pair) => return pair,\n               _ => ()\n             }\n@@ -1134,7 +1144,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_user_unop(fcx: @fn_ctxt, op_str: ~str, mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n-        match lookup_op_method(fcx, ex, rhs_expr, rhs_t, mname, ~[]) {\n+        match lookup_op_method(fcx, ex, rhs_expr, rhs_t,\n+                               fcx.tcx().sess.ident_of(mname), ~[]) {\n           some((ret_ty, _)) => ret_ty,\n           _ => {\n             fcx.ccx.tcx.sess.span_err(\n@@ -1221,7 +1232,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let fty = ty::mk_fn(tcx, fn_ty);\n \n         debug!{\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr), fcx.infcx.ty_to_str(fty)};\n+               expr_to_str(expr, tcx.sess.intr()), fcx.infcx.ty_to_str(fty)};\n \n         fcx.write_ty(expr.id, fty);\n \n@@ -1315,7 +1326,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 let msg = fmt!{\"attempted access of field `%s` on type `%s`, \\\n                                 but no public field or method with that name \\\n                                 was found\",\n-                               *field, fcx.infcx.ty_to_str(t_err)};\n+                                tcx.sess.str_of(field),\n+                                fcx.infcx.ty_to_str(t_err)};\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n                 fcx.write_ty(expr.id, fcx.infcx.next_ty_var());\n@@ -1788,15 +1800,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             for fields_t.each |f| {\n                 let mut found = false;\n                 for base_fields.each |bf| {\n-                    if str::eq(f.node.ident, bf.ident) {\n+                    if f.node.ident == bf.ident {\n                         demand::suptype(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n                         found = true;\n                     }\n                 }\n                 if !found {\n                     tcx.sess.span_fatal(f.span,\n                                         ~\"unknown field in record update: \" +\n-                                            *f.node.ident);\n+                                        tcx.sess.str_of(f.node.ident));\n                 }\n             }\n           }\n@@ -1873,27 +1885,27 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Look up the class fields and build up a map.\n         let class_fields = ty::lookup_class_fields(tcx, class_id);\n-        let class_field_map = str_hash();\n+        let class_field_map = uint_hash();\n         let mut fields_found = 0;\n         for class_fields.each |field| {\n             // XXX: Check visibility here.\n-            class_field_map.insert(*field.ident, (field.id, false));\n+            class_field_map.insert(field.ident, (field.id, false));\n         }\n \n         // Typecheck each field.\n         for fields.each |field| {\n-            match class_field_map.find(*field.node.ident) {\n+            match class_field_map.find(field.node.ident) {\n                 none => {\n-                    tcx.sess.span_err(field.span,\n-                                      fmt!{\"structure has no field named \\\n-                                            field named `%s`\",\n-                                           *field.node.ident});\n+                    tcx.sess.span_err(\n+                        field.span,\n+                        fmt!{\"structure has no field named field named `%s`\",\n+                             tcx.sess.str_of(field.node.ident)});\n                 }\n                 some((_, true)) => {\n-                    tcx.sess.span_err(field.span,\n-                                      fmt!{\"field `%s` specified more than \\\n-                                            once\",\n-                                           *field.node.ident});\n+                    tcx.sess.span_err(\n+                        field.span,\n+                        fmt!{\"field `%s` specified more than once\",\n+                             tcx.sess.str_of(field.node.ident)});\n                 }\n                 some((field_id, false)) => {\n                     let expected_field_type =\n@@ -1914,11 +1926,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 if fields_found < class_fields.len() {\n                     let mut missing_fields = ~[];\n                     for class_fields.each |class_field| {\n-                        let name = *class_field.ident;\n+                        let name = class_field.ident;\n                         let (_, seen) = class_field_map.get(name);\n                         if !seen {\n                             vec::push(missing_fields,\n-                                      ~\"`\" + name + ~\"`\");\n+                                      ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n                         }\n                     }\n \n@@ -1960,7 +1972,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           none => {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n-            match lookup_op_method(fcx, expr, base, resolved, ~\"index\",\n+            match lookup_op_method(fcx, expr, base, resolved,\n+                                   tcx.sess.ident_of(~\"index\"),\n                                  ~[idx]) {\n               some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n               _ => {\n@@ -1976,7 +1989,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     if bot { fcx.write_bot(expr.id); }\n \n     debug!{\"type of expr %s is %s, expected is %s\",\n-           syntax::print::pprust::expr_to_str(expr),\n+           syntax::print::pprust::expr_to_str(expr, tcx.sess.intr()),\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n            match expected {\n                some(t) => ty_to_str(tcx, t),\n@@ -2456,7 +2469,8 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     for tps_used.eachi |i, b| {\n         if !b {\n             ccx.tcx.sess.span_err(\n-                span, fmt!{\"type parameter `%s` is unused\", *tps[i].ident});\n+                span, fmt!{\"type parameter `%s` is unused\",\n+                           ccx.tcx.sess.str_of(tps[i].ident)});\n         }\n     }\n }\n@@ -2469,7 +2483,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         {mode: ast::expl(m), ty: ty}\n     }\n     let tcx = ccx.tcx;\n-    let (n_tps, inputs, output) = match *it.ident {\n+    let (n_tps, inputs, output) = match ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint(ccx.tcx)),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),\n@@ -2511,14 +2525,16 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         (1u, ~[], ty::mk_nil_ptr(tcx))\n       }\n       ~\"visit_tydesc\" => {\n-        assert ccx.tcx.intrinsic_defs.contains_key(@~\"tydesc\");\n-        assert ccx.tcx.intrinsic_defs.contains_key(@~\"ty_visitor\");\n-        let (_, tydesc_ty) = ccx.tcx.intrinsic_defs.get(@~\"tydesc\");\n-        let (_, visitor_trait) = ccx.tcx.intrinsic_defs.get(@~\"ty_visitor\");\n-        let td_ptr = ty::mk_ptr(ccx.tcx, {ty: tydesc_ty,\n-                                          mutbl: ast::m_imm});\n-        (0u, ~[arg(ast::by_val, td_ptr),\n-               arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n+          let tydesc_name = syntax::parse::token::special_idents::tydesc;\n+          let ty_visitor_name = tcx.sess.ident_of(~\"ty_visitor\");\n+          assert tcx.intrinsic_defs.contains_key(tydesc_name);\n+          assert ccx.tcx.intrinsic_defs.contains_key(ty_visitor_name);\n+          let (_, tydesc_ty) = tcx.intrinsic_defs.get(tydesc_name);\n+          let (_, visitor_trait) = tcx.intrinsic_defs.get(ty_visitor_name);\n+          let td_ptr = ty::mk_ptr(ccx.tcx, {ty: tydesc_ty,\n+                                            mutbl: ast::m_imm});\n+          (0u, ~[arg(ast::by_val, td_ptr),\n+                 arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }\n       ~\"frame_address\" => {\n         let fty = ty::mk_fn(ccx.tcx, {"}, {"sha": "83f62b7a6f1f73854fa2b262d0c4da4203a70cd6", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -215,19 +215,17 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                       fields\",\n                                 ex_f_count, f_count});\n         }\n-        fn matches(name: ast::ident, f: ty::field) -> bool {\n-            str::eq(name, f.ident)\n-        }\n+\n         for fields.each |f| {\n-            match vec::find(ex_fields, |a| matches(f.ident, a)) {\n+            match vec::find(ex_fields, |a| f.ident == a.ident) {\n               some(field) => {\n                 check_pat(pcx, f.pat, field.mt.ty);\n               }\n               none => {\n                 tcx.sess.span_fatal(pat.span,\n                                     fmt!{\"mismatched types: did not \\\n                                           expect a record with a field `%s`\",\n-                                         *f.ident});\n+                                          tcx.sess.str_of(f.ident)});\n               }\n             }\n         }\n@@ -259,7 +257,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 // OK.\n             }\n             ast::def_class(*) => {\n-                let name = syntax::print::pprust::path_to_str(path);\n+                let name = pprust::path_to_str(path, tcx.sess.intr());\n                 tcx.sess.span_err(pat.span,\n                                   fmt!(\"mismatched types: expected `%s` but \\\n                                         found `%s`\",\n@@ -278,7 +276,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         }\n \n         // Index the class fields.\n-        let field_map = std::map::box_str_hash();\n+        let field_map = std::map::uint_hash();\n         for class_fields.eachi |i, class_field| {\n             field_map.insert(class_field.ident, i);\n         }\n@@ -297,10 +295,11 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                     found_fields.insert(index, ());\n                 }\n                 none => {\n-                    let name = syntax::print::pprust::path_to_str(path);\n+                    let name = pprust::path_to_str(path, tcx.sess.intr());\n                     tcx.sess.span_err(pat.span,\n                                       fmt!(\"struct `%s` does not have a field\n-                                            named `%s`\", name, *field.ident));\n+                                            named `%s`\", name,\n+                                           tcx.sess.str_of(field.ident)));\n                 }\n             }\n         }\n@@ -313,7 +312,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 }\n                 tcx.sess.span_err(pat.span,\n                                   fmt!(\"pattern does not mention field `%s`\",\n-                                       *field.ident));\n+                                       tcx.sess.str_of(field.ident)));\n             }\n         }\n "}, {"sha": "2b953bcdd8e001b1b5f3f439bb56e5ac8b5c3ff8", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -107,7 +107,8 @@ struct lookup {\n     // Entrypoint:\n     fn method() -> option<method_map_entry> {\n         debug!{\"method lookup(m_name=%s, self_ty=%s, %?)\",\n-               *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty),\n+               self.fcx.tcx().sess.str_of(self.m_name),\n+               self.fcx.infcx.ty_to_str(self.self_ty),\n                ty::get(self.self_ty).struct};\n \n         // Determine if there are any inherent methods we can call.\n@@ -533,7 +534,9 @@ struct lookup {\n                 debug!{\"(adding inherent and extension candidates) \\\n                         adding candidates from impl: %s\",\n                         node_id_to_str(self.tcx().items,\n-                                       implementation.did.node)};\n+                                       implementation.did.node,\n+                                       self.fcx.tcx().sess.parse_sess\n+                                           .interner)};\n                 self.add_candidates_from_impl(implementation, mode);\n             }\n           }\n@@ -572,9 +575,11 @@ struct lookup {\n \n     fn def_id_to_str(def_id: ast::def_id) -> ~str {\n         if def_id.crate == ast::local_crate {\n-            node_id_to_str(self.tcx().items, def_id.node)\n+            node_id_to_str(self.tcx().items, def_id.node,\n+                           self.fcx.tcx().sess.parse_sess.interner)\n         } else {\n-            ast_map::path_to_str(csearch::get_item_path(self.tcx(), def_id))\n+            ast_map::path_to_str(csearch::get_item_path(self.tcx(), def_id),\n+                                 self.fcx.tcx().sess.parse_sess.interner)\n         }\n     }\n "}, {"sha": "87701a01bdf4aed66f1bafe02d9848beee35bab0", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -156,7 +156,8 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n }\n \n fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n-    debug!{\"visit_expr(e=%s)\", pprust::expr_to_str(e)};\n+    debug!{\"visit_expr(e=%s)\",\n+           pprust::expr_to_str(e, rcx.fcx.tcx().sess.intr())};\n \n     match e.node {\n       ast::expr_path(*) => {"}, {"sha": "d6c8d1cd2f70ae3e9caf88ee7f08a0d0586ccdbb", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -287,7 +287,7 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n \n fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %?: %s\",\n-           ex.id, expr_to_str(ex));\n+           ex.id, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::expr_path(*) => {"}, {"sha": "15251098b1f2f0196029550278d3bfd4b13fb03d", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -117,7 +117,7 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!{\"Type for pattern binding %s (id %d) resolved to %s\",\n-           pat_to_str(p), p.id,\n+           pat_to_str(p, wbcx.fcx.ccx.tcx.sess.intr()), p.id,\n            wbcx.fcx.infcx.ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n                                    p.id))};\n@@ -130,7 +130,7 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     match resolve_type(wbcx.fcx.infcx, var_ty, resolve_all | force_all) {\n       result::ok(lty) => {\n         debug!{\"Type for local %s (id %d) resolved to %s\",\n-               pat_to_str(l.node.pat), l.node.id,\n+               pat_to_str(l.node.pat, wbcx.fcx.ccx.tcx.sess.intr()),l.node.id,\n                wbcx.fcx.infcx.ty_to_str(lty)};\n         write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n       }"}, {"sha": "b7f39f4ba405adebd34de5d327980956ba43fcb7", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -164,6 +164,7 @@ struct CoherenceChecker {\n     // Create a mapping containing a MethodInfo for every provided\n     // method in every trait.\n     fn build_provided_methods_map(crate: @crate) {\n+        let sess = self.crate_context.tcx.sess;\n \n         let pmm = self.crate_context.provided_methods_map;\n \n@@ -173,7 +174,8 @@ struct CoherenceChecker {\n                   item_trait(_, _, trait_methods) => {\n                     for trait_methods.each |trait_method| {\n                         debug!{\"(building provided methods map) checking \\\n-                                trait `%s` with id %d\", *item.ident, item.id};\n+                                trait `%s` with id %d\",\n+                                sess.str_of(item.ident), item.id};\n \n                         match trait_method {\n                             required(_) => { /* fall through */}\n@@ -193,7 +195,7 @@ struct CoherenceChecker {\n                                               methods map) adding \\\n                                               method `%s` to entry for \\\n                                               existing trait\",\n-                                              *mi.ident};\n+                                              sess.str_of(mi.ident)};\n                                       let mut method_infos = mis;\n                                       push(method_infos, mi);\n                                       pmm.insert(item.id, method_infos);\n@@ -204,7 +206,7 @@ struct CoherenceChecker {\n                                       debug!{\"(building provided \\\n                                               methods map) creating new \\\n                                               entry for method `%s`\",\n-                                              *mi.ident};\n+                                              sess.str_of(mi.ident)};\n                                       pmm.insert(item.id, ~[mi]);\n                                     }\n                                 }\n@@ -227,7 +229,8 @@ struct CoherenceChecker {\n         // inherent methods and extension methods.\n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n-                debug!{\"(checking coherence) item '%s'\", *item.ident};\n+                debug!{\"(checking coherence) item '%s'\",\n+                       self.crate_context.tcx.sess.str_of(item.ident)};\n \n                 match item.node {\n                     item_impl(_, associated_traits, _, _) => {\n@@ -269,7 +272,7 @@ struct CoherenceChecker {\n         if associated_traits.len() == 0 {\n             debug!{\"(checking implementation) no associated traits for item \\\n                     '%s'\",\n-                   *item.ident};\n+                   self.crate_context.tcx.sess.str_of(item.ident)};\n \n             match get_base_type_def_id(self.inference_context,\n                                        item.span,\n@@ -292,9 +295,10 @@ struct CoherenceChecker {\n                 self.trait_ref_to_trait_def_id(associated_trait);\n             debug!{\"(checking implementation) adding impl for trait \\\n                     '%s', item '%s'\",\n-                   ast_map::node_id_to_str(self.crate_context.tcx.items,\n-                                           trait_did.node),\n-                   *item.ident};\n+                    ast_map::node_id_to_str(\n+                        self.crate_context.tcx.items, trait_did.node,\n+                        self.crate_context.tcx.sess.parse_sess.interner),\n+                    self.crate_context.tcx.sess.str_of(item.ident)};\n \n             let implementation = self.create_impl_from_item(item);\n             self.add_trait_method(trait_did, implementation);\n@@ -567,7 +571,8 @@ struct CoherenceChecker {\n     fn create_impl_from_item(item: @item) -> @Impl {\n \n         fn add_provided_methods(inherent_methods: ~[@MethodInfo],\n-                                all_provided_methods: ~[@MethodInfo])\n+                                all_provided_methods: ~[@MethodInfo],\n+                                sess: driver::session::session)\n             -> ~[@MethodInfo] {\n \n             let mut methods = inherent_methods;\n@@ -583,8 +588,9 @@ struct CoherenceChecker {\n                 }\n \n                 if !method_inherent_to_impl {\n-                    debug!{\"(creating impl) adding provided method `%s` to \\\n-                            impl\", *provided_method.ident};\n+                    debug!{\n+                        \"(creating impl) adding provided method `%s` to impl\",\n+                        sess.str_of(provided_method.ident)};\n                     push(methods, provided_method);\n                 }\n             }\n@@ -625,8 +631,9 @@ struct CoherenceChecker {\n                             // trait.\n \n                             // XXX: could probably be doing this with filter.\n-                            methods = add_provided_methods(methods,\n-                                                           all_provided);\n+                            methods = add_provided_methods(\n+                                methods, all_provided,\n+                                self.crate_context.tcx.sess);\n                         }\n                     }\n                 }\n@@ -717,11 +724,11 @@ struct CoherenceChecker {\n                                            self_type.ty) {\n                     none => {\n                         let session = self.crate_context.tcx.sess;\n-                        session.bug(fmt!{\"no base type for external impl \\\n-                                          with no trait: %s (type %s)!\",\n-                                         *implementation.ident,\n-                                         ty_to_str(self.crate_context.tcx,\n-                                                   self_type.ty)});\n+                        session.bug(fmt!{\n+                            \"no base type for external impl \\\n+                             with no trait: %s (type %s)!\",\n+                             session.str_of(implementation.ident),\n+                             ty_to_str(self.crate_context.tcx,self_type.ty)});\n                     }\n                     some(_) => {\n                         // Nothing to do."}, {"sha": "5359e43401cf749b002b4b62e34dca147ffeb296", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -30,7 +30,9 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     // There ought to be a better approach. Attributes?\n \n     for crate.node.module.items.each |crate_item| {\n-        if *crate_item.ident == ~\"intrinsic\" {\n+        if crate_item.ident\n+            == syntax::parse::token::special_idents::intrinsic {\n+\n             match crate_item.node {\n               ast::item_mod(m) => {\n                 for m.items.each |intrinsic_item| {\n@@ -246,29 +248,29 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n         tcx.sess.span_err(\n             sp, fmt!{\"method `%s`'s purity does \\\n                           not match the trait method's \\\n-                          purity\", *impl_m.ident});\n+                          purity\", tcx.sess.str_of(impl_m.ident)});\n     }\n \n     // is this check right?\n     if impl_m.self_ty != trait_m.self_ty {\n         tcx.sess.span_err(\n             sp, fmt!{\"method `%s`'s self type does \\\n                           not match the trait method's \\\n-                          self type\", *impl_m.ident});\n+                          self type\", tcx.sess.str_of(impl_m.ident)});\n     }\n \n     if impl_m.tps != trait_m.tps {\n-        tcx.sess.span_err(sp, ~\"method `\" + *trait_m.ident +\n+        tcx.sess.span_err(sp, ~\"method `\" + tcx.sess.str_of(trait_m.ident) +\n                           ~\"` has an incompatible set of type parameters\");\n         return;\n     }\n \n     if vec::len(impl_m.fty.inputs) != vec::len(trait_m.fty.inputs) {\n         tcx.sess.span_err(sp,fmt!{\"method `%s` has %u parameters \\\n                                    but the trait has %u\",\n-                                  *trait_m.ident,\n-                                  vec::len(impl_m.fty.inputs),\n-                                  vec::len(trait_m.fty.inputs)});\n+                                   tcx.sess.str_of(trait_m.ident),\n+                                   vec::len(impl_m.fty.inputs),\n+                                   vec::len(trait_m.fty.inputs)});\n         return;\n     }\n \n@@ -299,7 +301,8 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     };\n     require_same_types(\n         tcx, none, false, sp, impl_fty, trait_fty,\n-        || ~\"method `\" + *trait_m.ident + ~\"` has an incompatible type\");\n+        || ~\"method `\" + tcx.sess.str_of(trait_m.ident)\n+           + ~\"` has an incompatible type\");\n     return;\n \n     // Replaces bound references to the self region with `with_r`.\n@@ -351,7 +354,8 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n                     none => {\n                       tcx.sess.span_err(\n                           a_trait_ty.path.span,\n-                          fmt!{\"missing method `%s`\", *trait_m.ident});\n+                          fmt!{\"missing method `%s`\",\n+                               tcx.sess.str_of(trait_m.ident)});\n                     }\n                   }\n                 }\n@@ -402,7 +406,8 @@ fn convert_methods(ccx: @crate_ctxt,\n fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.contains_key(it.id);\n-    debug!{\"convert: item %s with id %d rp %b\", *it.ident, it.id, rp};\n+    debug!{\"convert: item %s with id %d rp %b\", tcx.sess.str_of(it.ident),\n+           it.id, rp};\n     match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n@@ -607,7 +612,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n                    rp: false, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n         debug!{\"type of %s (id %d) is %s\",\n-               *it.ident, it.id, ty_to_str(tcx, tpt.ty)};\n+               tcx.sess.str_of(it.ident), it.id, ty_to_str(tcx, tpt.ty)};\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }"}, {"sha": "f11b09913afa228dcda40b187aabbdec765981a3", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -1,4 +1,5 @@\n import result::result;\n+import syntax::parse::token::special_idents;\n \n trait region_scope {\n     fn anon_region(span: span) -> result<ty::region, ~str>;\n@@ -11,7 +12,7 @@ impl empty_rscope: region_scope {\n         result::ok(ty::re_static)\n     }\n     fn named_region(_span: span, id: ast::ident) -> result<ty::region, ~str> {\n-        if *id == ~\"static\" { result::ok(ty::re_static) }\n+        if id == special_idents::static { result::ok(ty::re_static) }\n         else { result::err(~\"only the static region is allowed here\") }\n     }\n }\n@@ -28,7 +29,7 @@ impl type_rscope: region_scope {\n     }\n     fn named_region(span: span, id: ast::ident) -> result<ty::region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n-            if *id == ~\"self\" {\n+            if id == special_idents::self_ {\n                 self.anon_region(span)\n             } else {\n                 result::err(~\"named regions other than `self` are not \\"}, {"sha": "42b7bc19cc842b71bdc52e4f5f78d3368d6c83df", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -84,7 +84,9 @@ fn local_rhs_span(l: @ast::local, def: span) -> span {\n fn is_main_name(path: syntax::ast_map::path) -> bool {\n     // FIXME (#34): path should be a constrained type, so we know\n     // the call to last doesn't fail.\n-    vec::last(path) == syntax::ast_map::path_name(@~\"main\")\n+    vec::last(path) == syntax::ast_map::path_name(\n+        syntax::parse::token::special_idents::main\n+    )\n }\n \n //"}, {"sha": "e22fa9fb173d100cd3f54af6a16c5ff6d1adef58", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -106,7 +106,7 @@ fn explain_region_and_span(cx: ctxt, region: ty::region)\n \n fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n     match br {\n-      br_named(str)                  => fmt!{\"&%s\", *str},\n+      br_named(id)                   => fmt!(\"&%s\", cx.sess.str_of(id)),\n       br_self if cx.sess.ppregions() => ~\"&<self>\",\n       br_self                        => ~\"&self\",\n \n@@ -161,7 +161,8 @@ fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n       }\n       _ => { cx.sess.bug(\n           fmt!{\"re_scope refers to %s\",\n-               ast_map::node_id_to_str(cx.items, node_id)}) }\n+               ast_map::node_id_to_str(cx.items, node_id,\n+                                       cx.sess.parse_sess.interner)}) }\n     }\n }\n \n@@ -257,7 +258,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         s += proto_ty_to_str(cx, proto);\n         match ident {\n-          some(i) => { s += ~\" \"; s += *i; }\n+          some(i) => { s += ~\" \"; s += cx.sess.str_of(i); }\n           _ => { }\n         }\n         s += ~\"(\";\n@@ -280,13 +281,13 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n             m.fty.output, m.fty.ret_style) + ~\";\";\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return *f.ident + ~\": \" + mt_to_str(cx, f.mt);\n+        return cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n     }\n \n     // if there is an id, print that instead of the structural type:\n     for ty::type_def_id(typ).each |def_id| {\n         // note that this typedef cannot have type parameters\n-        return ast_map::path_to_str(ty::item_path(cx, def_id));\n+        return ast_map::path_to_str(ty::item_path(cx, def_id),cx.sess.intr());\n     }\n \n     // pretty print the structural type representation:\n@@ -336,12 +337,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_self => ~\"self\",\n       ty_enum(did, substs) | ty_class(did, substs) => {\n         let path = ty::item_path(cx, did);\n-        let base = ast_map::path_to_str(path);\n+        let base = ast_map::path_to_str(path, cx.sess.intr());\n         parameterized(cx, base, substs.self_r, substs.tps)\n       }\n       ty_trait(did, substs, vs) => {\n         let path = ty::item_path(cx, did);\n-        let base = ast_map::path_to_str(path);\n+        let base = ast_map::path_to_str(path, cx.sess.intr());\n         let result = parameterized(cx, base, substs.self_r, substs.tps);\n         vstore_ty_to_str(cx, result, vs)\n       }"}, {"sha": "bb37697ff39d6cf37657eb1297c78c14f9a0a5d7", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -63,8 +63,7 @@ fn parse_crate(attrs: ~[ast::attribute]) -> crate_attrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n \n     {\n-        name: attr::last_meta_item_value_str_by_name(\n-            link_metas, ~\"name\").map(|x| *x )\n+        name: attr::last_meta_item_value_str_by_name(link_metas, ~\"name\")\n     }\n }\n \n@@ -95,7 +94,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n fn parse_desc(attrs: ~[ast::attribute]) -> option<~str> {\n     match doc_meta(attrs) {\n       some(meta) => {\n-        attr::get_meta_item_value_str(meta).map(|x| *x )\n+        attr::get_meta_item_value_str(meta)\n       }\n       none => none\n     }"}, {"sha": "2439ad9801b7161638c3e03409e98f279edf8bc5", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -7,6 +7,7 @@\n )];\n \n import doc::item_utils;\n+import extract::to_str;\n import syntax::ast;\n import syntax::ast_map;\n import std::map::hashmap;\n@@ -150,7 +151,7 @@ fn fold_enum(\n                   }, _) => {\n                     let ast_variant = option::get(\n                         vec::find(enum_definition.variants, |v| {\n-                            *v.node.name == variant.name\n+                            to_str(v.node.name) == variant.name\n                         }));\n \n                     attr_parser::parse_desc(ast_variant.node.attrs)\n@@ -208,10 +209,10 @@ fn merge_method_attrs(\n             vec::map(methods, |method| {\n                 match method {\n                   ast::required(ty_m) => {\n-                    (*ty_m.ident, attr_parser::parse_desc(ty_m.attrs))\n+                    (to_str(ty_m.ident), attr_parser::parse_desc(ty_m.attrs))\n                   }\n                   ast::provided(m) => {\n-                    (*m.ident, attr_parser::parse_desc(m.attrs))\n+                    (to_str(m.ident), attr_parser::parse_desc(m.attrs))\n                   }\n                 }\n             })\n@@ -220,7 +221,7 @@ fn merge_method_attrs(\n             node: ast::item_impl(_, _, _, methods), _\n           }, _) => {\n             vec::map(methods, |method| {\n-                (*method.ident, attr_parser::parse_desc(method.attrs))\n+                (to_str(method.ident), attr_parser::parse_desc(method.attrs))\n             })\n           }\n           _ => fail ~\"unexpected item\""}, {"sha": "b3e5785c06e50b86f74c09be96307f78ee0a6cd0", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -3,7 +3,21 @@\n import syntax::ast;\n import doc::item_utils;\n \n-export from_srv, extract;\n+export from_srv, extract, to_str, interner;\n+\n+// Hack; rather than thread an interner through everywhere, rely on\n+// thread-local data\n+fn to_str(id: ast::ident) -> ~str {\n+    let intr = unsafe{ task::local_data_get(\n+        syntax::parse::token::interner_key) };\n+\n+    return *(*intr.get()).get(id);\n+}\n+\n+fn interner() -> syntax::parse::token::ident_interner {\n+    return *(unsafe{ task::local_data_get(\n+        syntax::parse::token::interner_key) }).get();\n+}\n \n fn from_srv(\n     srv: astsrv::srv,\n@@ -34,14 +48,14 @@ fn top_moddoc_from_crate(\n     crate: @ast::crate,\n     default_name: ~str\n ) -> doc::moddoc {\n-    moddoc_from_mod(mk_itemdoc(ast::crate_node_id, @default_name),\n+    moddoc_from_mod(mk_itemdoc(ast::crate_node_id, default_name),\n                     crate.node.module)\n }\n \n-fn mk_itemdoc(id: ast::node_id, name: ast::ident) -> doc::itemdoc {\n+fn mk_itemdoc(id: ast::node_id, name: ~str) -> doc::itemdoc {\n     {\n         id: id,\n-        name: *name,\n+        name: name,\n         path: ~[],\n         brief: none,\n         desc: none,\n@@ -57,7 +71,7 @@ fn moddoc_from_mod(\n     doc::moddoc_({\n         item: itemdoc,\n         items: do vec::filter_map(module_.items) |item| {\n-            let itemdoc = mk_itemdoc(item.id, item.ident);\n+            let itemdoc = mk_itemdoc(item.id, to_str(item.ident));\n             match item.node {\n               ast::item_mod(m) => {\n                 some(doc::modtag(\n@@ -113,7 +127,7 @@ fn nmoddoc_from_mod(\n     {\n         item: itemdoc,\n         fns: do vec::map(module_.items) |item| {\n-            let itemdoc = mk_itemdoc(item.id, item.ident);\n+            let itemdoc = mk_itemdoc(item.id, to_str(item.ident));\n             match item.node {\n               ast::foreign_item_fn(_, _) => {\n                 fndoc_from_fn(itemdoc)\n@@ -162,8 +176,9 @@ fn variantdocs_from_variants(\n }\n \n fn variantdoc_from_variant(variant: ast::variant) -> doc::variantdoc {\n+\n     {\n-        name: *variant.node.name,\n+        name: to_str(variant.node.name),\n         desc: none,\n         sig: none\n     }\n@@ -192,7 +207,7 @@ fn traitdoc_from_trait(\n             match method {\n               ast::required(ty_m) => {\n                 {\n-                    name: *ty_m.ident,\n+                    name: to_str(ty_m.ident),\n                     brief: none,\n                     desc: none,\n                     sections: ~[],\n@@ -202,7 +217,7 @@ fn traitdoc_from_trait(\n               }\n               ast::provided(m) => {\n                 {\n-                    name: *m.ident,\n+                    name: to_str(m.ident),\n                     brief: none,\n                     desc: none,\n                     sections: ~[],\n@@ -237,7 +252,7 @@ fn impldoc_from_impl(\n         self_ty: none,\n         methods: do vec::map(methods) |method| {\n             {\n-                name: *method.ident,\n+                name: to_str(method.ident),\n                 brief: none,\n                 desc: none,\n                 sections: ~[],"}, {"sha": "e545870e8cb24f74272ab4d00cd60954fdb65e0a", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -5,6 +5,7 @@ import syntax::ast;\n import syntax::print::pprust;\n import syntax::ast_map;\n import std::map::hashmap;\n+import extract::to_str;\n \n export mk_pass;\n \n@@ -55,7 +56,7 @@ fn get_fn_sig(srv: astsrv::srv, fn_id: doc::ast_id) -> option<~str> {\n             ident: ident,\n             node: ast::foreign_item_fn(decl, tys), _\n           }, _, _) => {\n-            some(pprust::fun_to_str(decl, ident, tys))\n+            some(pprust::fun_to_str(decl, ident, tys, extract::interner()))\n           }\n         }\n     }\n@@ -85,7 +86,7 @@ fn fold_const(\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n               }, _) => {\n-                pprust::ty_to_str(ty)\n+                pprust::ty_to_str(ty, extract::interner())\n               }\n             }\n         })\n@@ -115,10 +116,10 @@ fn fold_enum(\n                   }, _) => {\n                     let ast_variant = option::get(\n                         do vec::find(enum_definition.variants) |v| {\n-                            *v.node.name == variant.name\n+                            to_str(v.node.name) == variant.name\n                         });\n \n-                    pprust::variant_to_str(ast_variant)\n+                    pprust::variant_to_str(ast_variant, extract::interner())\n                   }\n                 }\n             };\n@@ -173,8 +174,8 @@ fn get_method_sig(\n           }, _) => {\n             match check vec::find(methods, |method| {\n                 match method {\n-                  ast::required(ty_m) => *ty_m.ident == method_name,\n-                  ast::provided(m) => *m.ident == method_name,\n+                  ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n+                  ast::provided(m) => to_str(m.ident) == method_name,\n                 }\n             }) {\n                 some(method) => {\n@@ -183,14 +184,16 @@ fn get_method_sig(\n                       some(pprust::fun_to_str(\n                           ty_m.decl,\n                           ty_m.ident,\n-                          ty_m.tps\n+                          ty_m.tps,\n+                          extract::interner()\n                       ))\n                     }\n                     ast::provided(m) => {\n                       some(pprust::fun_to_str(\n                           m.decl,\n                           m.ident,\n-                          m.tps\n+                          m.tps,\n+                          extract::interner()\n                       ))\n                     }\n                   }\n@@ -201,13 +204,14 @@ fn get_method_sig(\n             node: ast::item_impl(_, _, _, methods), _\n           }, _) => {\n             match check vec::find(methods, |method| {\n-                *method.ident == method_name\n+                to_str(method.ident) == method_name\n             }) {\n                 some(method) => {\n                     some(pprust::fun_to_str(\n                         method.decl,\n                         method.ident,\n-                        method.tps\n+                        method.tps,\n+                        extract::interner()\n                     ))\n                 }\n             }\n@@ -236,9 +240,10 @@ fn fold_impl(\n             node: ast::item_impl(_, trait_types, self_ty, _), _\n           }, _) => {\n             let trait_types = vec::map(trait_types, |p| {\n-                pprust::path_to_str(p.path)\n+                pprust::path_to_str(p.path, extract::interner())\n             });\n-            (trait_types, some(pprust::ty_to_str(self_ty)))\n+            (trait_types, some(pprust::ty_to_str(self_ty,\n+                                                 extract::interner())))\n           }\n           _ => fail ~\"expected impl\"\n         }\n@@ -293,9 +298,9 @@ fn fold_type(\n               }, _) => {\n                 some(fmt!{\n                     \"type %s%s = %s\",\n-                    *ident,\n-                    pprust::typarams_to_str(params),\n-                    pprust::ty_to_str(ty)\n+                    to_str(ident),\n+                    pprust::typarams_to_str(params, extract::interner()),\n+                    pprust::ty_to_str(ty, extract::interner())\n                 })\n               }\n               _ => fail ~\"expected type\""}, {"sha": "87bf362fe97ee2ea62c1521bbcb8396298d1dd50", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1153b5dcc86c3567b0a86e441938f05d4f2e295b/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=1153b5dcc86c3567b0a86e441938f05d4f2e295b", "patch": "@@ -16,76 +16,77 @@ trait fake_ext_ctxt {\n     fn parse_sess() -> parse::parse_sess;\n }\n \n-type fake_session = ();\n+type fake_session = parse::parse_sess;\n \n impl fake_session: fake_ext_ctxt {\n     fn cfg() -> ast::crate_cfg { ~[] }\n-    fn parse_sess() -> parse::parse_sess { parse::new_parse_sess(none) }\n+    fn parse_sess() -> parse::parse_sess { self }\n }\n \n fn mk_ctxt() -> fake_ext_ctxt {\n-    () as fake_ext_ctxt\n+    parse::new_parse_sess(none) as fake_ext_ctxt\n }\n \n \n fn main() {\n     let ext_cx = mk_ctxt();\n \n     let abc = #ast{23};\n-    check_pp(abc,  pprust::print_expr, ~\"23\");\n+    check_pp(ext_cx, abc,  pprust::print_expr, ~\"23\");\n \n     let expr3 = #ast{2 - $(abc) + 7};\n-    check_pp(expr3,  pprust::print_expr, ~\"2 - 23 + 7\");\n+    check_pp(ext_cx, expr3,  pprust::print_expr, ~\"2 - 23 + 7\");\n \n     let expr4 = #ast{2 - $(#ast{3}) + 9};\n-    check_pp(expr4,  pprust::print_expr, ~\"2 - 3 + 9\");\n+    check_pp(ext_cx, expr4,  pprust::print_expr, ~\"2 - 3 + 9\");\n \n     let ty = #ast[ty]{int};\n-    check_pp(ty, pprust::print_type, ~\"int\");\n+    check_pp(ext_cx, ty, pprust::print_type, ~\"int\");\n \n     let ty2 = #ast[ty]{option<$(ty)>};\n-    check_pp(ty2, pprust::print_type, ~\"option<int>\");\n+    check_pp(ext_cx, ty2, pprust::print_type, ~\"option<int>\");\n \n     let item = #ast[item]{const x : int = 10;};\n-    check_pp(item, pprust::print_item, ~\"const x: int = 10;\");\n+    check_pp(ext_cx, item, pprust::print_item, ~\"const x: int = 10;\");\n \n     let item2: @ast::item = #ast[item]{const x : int = $(abc);};\n-    check_pp(item2, pprust::print_item, ~\"const x: int = 23;\");\n+    check_pp(ext_cx, item2, pprust::print_item, ~\"const x: int = 23;\");\n \n     let stmt = #ast[stmt]{let x = 20;};\n-    check_pp(*stmt, pprust::print_stmt, ~\"let x = 20;\");\n+    check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n     let stmt2 = #ast[stmt]{let x : $(ty) = $(abc);};\n-    check_pp(*stmt2, pprust::print_stmt, ~\"let x: int = 23;\");\n+    check_pp(ext_cx, *stmt2, pprust::print_stmt, ~\"let x: int = 23;\");\n \n     let pat = #ast[pat]{some(_)};\n-    check_pp(pat, pprust::print_pat, ~\"some(_)\");\n+    check_pp(ext_cx, pat, pprust::print_pat, ~\"some(_)\");\n \n     // issue #1785\n     let x = #ast{1};\n     let test1 = #ast{1+$(x)};\n-    check_pp(test1, pprust::print_expr, ~\"1 + 1\");\n+    check_pp(ext_cx, test1, pprust::print_expr, ~\"1 + 1\");\n \n     let test2 = #ast{$(x)+1};\n-    check_pp(test2, pprust::print_expr, ~\"1 + 1\");\n+    check_pp(ext_cx, test2, pprust::print_expr, ~\"1 + 1\");\n \n     let y = #ast{2};\n     let test3 = #ast{$(x) + $(y)};\n-    check_pp(test3, pprust::print_expr, ~\"1 + 2\");\n+    check_pp(ext_cx, test3, pprust::print_expr, ~\"1 + 2\");\n \n     let crate = #ast[crate] { fn a() { } };\n-    check_pp(crate, pprust::print_crate_, ~\"fn a() { }\\n\");\n+    check_pp(ext_cx, crate, pprust::print_crate_, ~\"fn a() { }\\n\");\n \n     // issue #1926\n     let s = #ast[expr]{__s};\n     let e = #ast[expr]{__e};\n     let call = #ast[expr]{$(s).foo(|__e| $(e) )};\n-    check_pp(call, pprust::print_expr, ~\"__s.foo(|__e| __e)\")\n+    check_pp(ext_cx, call, pprust::print_expr, ~\"__s.foo(|__e| __e)\")\n }\n \n-fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: ~str) {\n+fn check_pp<T>(cx: fake_ext_ctxt,\n+               expr: T, f: fn(pprust::ps, T), expect: ~str) {\n     let buf = mem_buffer();\n-    let pp = pprust::rust_printer(buf as io::Writer);\n+    let pp = pprust::rust_printer(buf as io::Writer,cx.parse_sess().interner);\n     f(pp, expr);\n     pp::eof(pp.s);\n     let str = mem_buffer_str(buf);"}]}