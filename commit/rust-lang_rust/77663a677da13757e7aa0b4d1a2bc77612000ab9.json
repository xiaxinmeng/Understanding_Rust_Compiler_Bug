{"sha": "77663a677da13757e7aa0b4d1a2bc77612000ab9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NjYzYTY3N2RhMTM3NTdlN2FhMGI0ZDFhMmJjNzc2MTIwMDBhYjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-01T16:07:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-13T17:20:27Z"}, "message": "refactor region value bitmatrix", "tree": {"sha": "435ac7c1c0b3d8e04e514caec918264a2d661bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/435ac7c1c0b3d8e04e514caec918264a2d661bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77663a677da13757e7aa0b4d1a2bc77612000ab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77663a677da13757e7aa0b4d1a2bc77612000ab9", "html_url": "https://github.com/rust-lang/rust/commit/77663a677da13757e7aa0b4d1a2bc77612000ab9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77663a677da13757e7aa0b4d1a2bc77612000ab9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a30e2259daacb0075cb5d0ecdca63afd8016b607", "url": "https://api.github.com/repos/rust-lang/rust/commits/a30e2259daacb0075cb5d0ecdca63afd8016b607", "html_url": "https://github.com/rust-lang/rust/commit/a30e2259daacb0075cb5d0ecdca63afd8016b607"}], "stats": {"total": 380, "additions": 270, "deletions": 110}, "files": [{"sha": "69ecafa66aee7719f93050d4b38f2172968b721c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=77663a677da13757e7aa0b4d1a2bc77612000ab9", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         with_msg: &mut FnMut(&str) -> io::Result<()>,\n     ) -> io::Result<()> {\n         for region in self.definitions.indices() {\n-            let value = self.region_value_str_from_matrix(&self.liveness_constraints, region);\n+            let value = self.liveness_constraints.region_value_str(region);\n             if value != \"{}\" {\n                 with_msg(&format!(\"{:?} live at {}\", region, value))?;\n             }"}, {"sha": "047b78dd55c49c89a9fe274a4a8c4d75e3fd7b2d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 38, "deletions": 105, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=77663a677da13757e7aa0b4d1a2bc77612000ab9", "patch": "@@ -19,15 +19,15 @@ use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::bitvec::BitMatrix;\n-use rustc_data_structures::indexed_vec::Idx;\n-use std::collections::BTreeMap;\n use std::fmt;\n+use std::rc::Rc;\n use syntax_pos::Span;\n \n mod annotation;\n mod dump_mir;\n mod graphviz;\n+mod values;\n+use self::values::{RegionValueElements, RegionValues};\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n@@ -36,27 +36,22 @@ pub struct RegionInferenceContext<'tcx> {\n     /// from as well as its final inferred value.\n     definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n+    /// Maps from points/universal-regions to a `RegionElementIndex`.\n+    elements: Rc<RegionValueElements>,\n+\n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    ///\n-    /// In this `BitMatrix` representation, the rows are the region\n-    /// variables and the columns are the free regions and MIR locations.\n-    liveness_constraints: BitMatrix,\n+    liveness_constraints: RegionValues,\n \n     /// The final inferred values of the inference variables; `None`\n     /// until `solve` is invoked.\n-    inferred_values: Option<BitMatrix>,\n+    inferred_values: Option<RegionValues>,\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n \n-    /// A map from each MIR Location to its column index in\n-    /// `liveness_constraints`/`inferred_values`. (The first N columns are\n-    /// the free regions.)\n-    point_indices: BTreeMap<Location, usize>,\n-\n     /// Information about the universally quantified regions in scope\n     /// on this function and their (known) relations to one another.\n     universal_regions: UniversalRegions<'tcx>,\n@@ -112,19 +107,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let num_region_variables = var_origins.len();\n         let num_universal_regions = universal_regions.len();\n \n-        let mut num_points = 0;\n-        let mut point_indices = BTreeMap::new();\n-\n+        let mut points = Vec::new();\n         for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n             for statement_index in 0..block_data.statements.len() + 1 {\n-                let location = Location {\n+                points.push(Location {\n                     block,\n                     statement_index,\n-                };\n-                point_indices.insert(location, num_universal_regions + num_points);\n-                num_points += 1;\n+                });\n             }\n         }\n+        let elements = &Rc::new(RegionValueElements::new(points, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n         let definitions = var_origins\n@@ -134,13 +126,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut result = Self {\n             definitions,\n-            liveness_constraints: BitMatrix::new(\n-                num_region_variables,\n-                num_universal_regions + num_points,\n-            ),\n+            elements: elements.clone(),\n+            liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             constraints: Vec::new(),\n-            point_indices,\n             universal_regions,\n         };\n \n@@ -186,14 +175,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n-            for (_location, point_index) in &self.point_indices {\n-                self.liveness_constraints\n-                    .add(variable.index(), *point_index);\n+            for point_index in self.elements.all_point_indices() {\n+                self.liveness_constraints.add(variable, point_index);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints\n-                .add(variable.index(), variable.index());\n+            self.liveness_constraints.add(variable, variable);\n         }\n     }\n \n@@ -217,32 +204,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n-        self.region_contains_point_in_matrix(inferred_values, r, p)\n-    }\n-\n-    /// True if given region `r` contains the point `p`, when\n-    /// evaluated in the set of region values `matrix`.\n-    fn region_contains_point_in_matrix(\n-        &self,\n-        matrix: &BitMatrix,\n-        r: RegionVid,\n-        p: Location,\n-    ) -> bool {\n-        let point_index = self.point_indices\n-            .get(&p)\n-            .expect(\"point index should be known\");\n-        matrix.contains(r.index(), *point_index)\n-    }\n-\n-    /// True if given region `r` contains the `end(s)`, when\n-    /// evaluated in the set of region values `matrix`.\n-    fn region_contains_region_in_matrix(\n-        &self,\n-        matrix: &BitMatrix,\n-        r: RegionVid,\n-        s: RegionVid,\n-    ) -> bool {\n-        matrix.contains(r.index(), s.index())\n+        inferred_values.contains(r, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n@@ -251,43 +213,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n-        self.region_value_str_from_matrix(inferred_values, r)\n-    }\n-\n-    fn region_value_str_from_matrix(&self,\n-                                    matrix: &BitMatrix,\n-                                    r: RegionVid) -> String {\n-        let mut result = String::new();\n-        result.push_str(\"{\");\n-        let mut sep = \"\";\n-\n-        for &point in self.point_indices.keys() {\n-            if self.region_contains_point_in_matrix(matrix, r, point) {\n-                result.push_str(&format!(\"{}{:?}\", sep, point));\n-                sep = \", \";\n-            }\n-        }\n-\n-        for fr in (0..self.universal_regions.len()).map(RegionVid::new) {\n-            if self.region_contains_region_in_matrix(matrix, r, fr) {\n-                result.push_str(&format!(\"{}{:?}\", sep, fr));\n-                sep = \", \";\n-            }\n-        }\n-\n-        result.push_str(\"}\");\n-\n-        result\n+        inferred_values.region_value_str(r)\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n     pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        let point_index = self.point_indices\n-            .get(&point)\n-            .expect(\"point index should be known\");\n-        self.liveness_constraints.add(v.index(), *point_index)\n+        debug!(\"add_live_point: @{:?}\", point);\n+\n+        let element = self.elements.index(point);\n+        if self.liveness_constraints.add(v, element) {\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n@@ -386,16 +326,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n-        let longer_value = inferred_values.iter(longer_fr.index());\n \n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n-        let shorter_frs = longer_value\n-            .take_while(|&i| i < self.universal_regions.len())\n-            .map(RegionVid::new);\n-        for shorter_fr in shorter_frs {\n+        for shorter_fr in inferred_values.universal_regions_outlived_by(longer_fr) {\n             // If it is known that `fr: o`, carry on.\n             if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;\n@@ -512,20 +448,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn copy(\n         &self,\n-        inferred_values: &mut BitMatrix,\n+        inferred_values: &mut RegionValues,\n         mir: &Mir<'tcx>,\n         from_region: RegionVid,\n         to_region: RegionVid,\n-        start_point: Location,\n+        constraint_point: Location,\n     ) -> bool {\n         let mut changed = false;\n \n         let mut stack = vec![];\n         let mut visited = FxHashSet();\n \n-        stack.push(start_point);\n+        stack.push(constraint_point);\n         while let Some(p) = stack.pop() {\n-            if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n+            let point_index = self.elements.index(p);\n+\n+            if !inferred_values.contains(from_region, point_index) {\n                 debug!(\"            not in from-region\");\n                 continue;\n             }\n@@ -535,8 +473,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 continue;\n             }\n \n-            let point_index = self.point_indices.get(&p).unwrap();\n-            changed |= inferred_values.add(to_region.index(), *point_index);\n+            let new = inferred_values.add(to_region, point_index);\n+            changed |= new;\n \n             let block_data = &mir[p.block];\n             let successor_points = if p.statement_index < block_data.statements.len() {\n@@ -564,13 +502,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n-                let universal_region_indices = inferred_values\n-                    .iter(from_region.index())\n-                    .take_while(|&i| i < self.universal_regions.len())\n-                    .collect::<Vec<_>>();\n-                for fr in &universal_region_indices {\n-                    changed |= inferred_values.add(to_region.index(), *fr);\n-                }\n+                changed |=\n+                    inferred_values.add_universal_regions_outlived_by(from_region, to_region);\n             } else {\n                 stack.extend(successor_points);\n             }"}, {"sha": "cda199859e40d4244e11dd21d203795b906e74d1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=77663a677da13757e7aa0b4d1a2bc77612000ab9", "patch": "@@ -0,0 +1,227 @@\n+use std::rc::Rc;\n+use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::Location;\n+use rustc::ty::RegionVid;\n+\n+/// Maps between the various kinds of elements of a region value to\n+/// the internal indices that w use.\n+pub(super) struct RegionValueElements {\n+    points: Vec<Location>,\n+    num_universal_regions: usize,\n+}\n+\n+impl RegionValueElements {\n+    pub(super) fn new(points: Vec<Location>, num_universal_regions: usize) -> Self {\n+        Self {\n+            points,\n+            num_universal_regions,\n+        }\n+    }\n+\n+    /// Converts an element of a region value into a `RegionElementIndex`.\n+    pub(super) fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n+        elem.to_element_index(self)\n+    }\n+\n+    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n+    pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n+        (0..self.points.len()).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n+    }\n+\n+    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n+    pub(super) fn all_universal_region_indices(&self) -> impl Iterator<Item = RegionElementIndex> {\n+        (0..self.num_universal_regions).map(move |i| RegionElementIndex::new(i))\n+    }\n+\n+    /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n+    pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n+        if let Some(r) = self.to_universal_region(i) {\n+            RegionElement::UniversalRegion(r)\n+        } else {\n+            RegionElement::Location(self.points[i.index() - self.num_universal_regions])\n+        }\n+    }\n+\n+    /// Converts a particular `RegionElementIndex` to a universal\n+    /// region, if that is what it represents. Returns `None`\n+    /// otherwise.\n+    pub(super) fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n+        if i.index() < self.num_universal_regions {\n+            Some(RegionVid::new(i.index()))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// A newtype for the integers that represent one of the possible\n+/// elements in a region. These are the rows in the `BitMatrix` that\n+/// is used to store the values of all regions. They have the following\n+/// convention:\n+///\n+/// - The first N indices represent free regions (where N = universal_regions.len()).\n+/// - The remainder represent the points in the CFG (see `point_indices` map).\n+///\n+/// You can convert a `RegionElementIndex` into a `RegionElement`\n+/// using the `to_region_elem` method.\n+newtype_index!(RegionElementIndex { DEBUG_FORMAT = \"RegionElementIndex({})\" });\n+\n+/// An individual element in a region value -- the value of a\n+/// particular region variable consists of a set of these elements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub(super) enum RegionElement {\n+    /// A point in the control-flow graph.\n+    Location(Location),\n+\n+    /// An in-scope, universally quantified region (e.g., a liftime parameter).\n+    UniversalRegion(RegionVid),\n+}\n+\n+\n+pub(super) trait ToElementIndex {\n+    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n+}\n+\n+impl ToElementIndex for Location {\n+    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n+        let index = elements.points.binary_search(&self).unwrap();\n+        RegionElementIndex::new(index + elements.num_universal_regions)\n+    }\n+}\n+\n+impl ToElementIndex for RegionVid {\n+    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n+        assert!(self.index() < elements.num_universal_regions);\n+        RegionElementIndex::new(self.index())\n+    }\n+}\n+\n+impl ToElementIndex for RegionElementIndex {\n+    fn to_element_index(self, _elements: &RegionValueElements) -> RegionElementIndex {\n+        self\n+    }\n+}\n+\n+/// Stores the values for a set of regions. These are stored in a\n+/// compact `BitMatrix` representation, with one row per region\n+/// variable. The columns consist of either universal regions or\n+/// points in the CFG.\n+#[derive(Clone)]\n+pub(super) struct RegionValues {\n+    elements: Rc<RegionValueElements>,\n+    matrix: BitMatrix,\n+}\n+\n+impl RegionValues {\n+    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n+        assert!(\n+            elements.num_universal_regions <= num_region_variables,\n+            \"universal regions are a subset of the region variables\"\n+        );\n+\n+        let num_columns = elements.points.len() + elements.num_universal_regions;\n+\n+        Self {\n+            elements: elements.clone(),\n+            matrix: BitMatrix::new(num_region_variables, num_columns),\n+        }\n+    }\n+\n+    /// Adds the given element to the value for the given region. Returns true if\n+    /// the element is newly added (i.e., was not already present).\n+    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E) -> bool {\n+        let i = self.elements.index(elem);\n+        if self.matrix.add(r.index(), i.index()) {\n+            debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Adds all the universal regions outlived by `from_region` to\n+    /// `to_region`.\n+    pub(super) fn add_universal_regions_outlived_by(\n+        &mut self,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n+    ) -> bool {\n+        // FIXME. We could optimize this by improving\n+        // `BitMatrix::merge` so it does not always merge an entire\n+        // row.\n+        debug!(\"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n+               from_region, to_region);\n+        let mut changed = false;\n+        for elem in self.elements.all_universal_region_indices() {\n+            if self.contains(from_region, elem) {\n+                changed |= self.add(to_region, elem);\n+            }\n+        }\n+        changed\n+    }\n+\n+    /// True if the region `r` contains the given element.\n+    pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n+        let i = self.elements.index(elem);\n+        self.matrix.contains(r.index(), i.index())\n+    }\n+\n+    /// Iterate over the value of the region `r`, yielding up element\n+    /// indices. You may prefer `universal_regions_outlived_by` or\n+    /// `elements_contained_in`.\n+    pub(super) fn element_indices_contained_in<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n+        self.matrix\n+            .iter(r.index())\n+            .map(move |i| RegionElementIndex::new(i))\n+    }\n+\n+    /// Returns just the universal regions that are contained in a given region's value.\n+    pub(super) fn universal_regions_outlived_by<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        self.element_indices_contained_in(r)\n+            .map(move |i| self.elements.to_universal_region(i))\n+            .take_while(move |v| v.is_some()) // universal regions are a prefix\n+            .map(move |v| v.unwrap())\n+    }\n+\n+    /// Returns all the elements contained in a given region's value.\n+    pub(super) fn elements_contained_in<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = RegionElement> + 'a {\n+        self.element_indices_contained_in(r)\n+            .map(move |r| self.elements.to_element(r))\n+    }\n+\n+    /// Returns a \"pretty\" string value of the region. Meant for debugging.\n+    pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n+        let mut result = String::new();\n+        result.push_str(\"{\");\n+\n+        for (index, element) in self.elements_contained_in(r).enumerate() {\n+            if index > 0 {\n+                result.push_str(\", \");\n+            }\n+\n+            match element {\n+                RegionElement::Location(l) => {\n+                    result.push_str(&format!(\"{:?}\", l));\n+                }\n+\n+                RegionElement::UniversalRegion(fr) => {\n+                    result.push_str(&format!(\"{:?}\", fr));\n+                }\n+            }\n+        }\n+\n+        result.push_str(\"}\");\n+\n+        result\n+    }\n+}"}, {"sha": "f3a57c088409ac05fb8e35894620739b6d53ee83", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77663a677da13757e7aa0b4d1a2bc77612000ab9/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=77663a677da13757e7aa0b4d1a2bc77612000ab9", "patch": "@@ -33,10 +33,10 @@ fn main() {\n // | '_#3r    | Local    | ['_#3r]\n // |\n // | Inferred Region Values\n-// | '_#0r    | {bb0[0], bb0[1], '_#0r}\n-// | '_#1r    | {bb0[0], bb0[1], '_#1r}\n-// | '_#2r    | {bb0[0], bb0[1], '_#2r}\n-// | '_#3r    | {bb0[0], bb0[1], '_#3r}\n+// | '_#0r    | {'_#0r, bb0[0], bb0[1]}\n+// | '_#1r    | {'_#1r, bb0[0], bb0[1]}\n+// | '_#2r    | {'_#2r, bb0[0], bb0[1]}\n+// | '_#3r    | {'_#3r, bb0[0], bb0[1]}\n // |\n // ...\n // fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {"}]}