{"sha": "a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2Zjc3NmQyZGMyMmE5OThjNmRiZWI0MjE2ODE2NDg5YjdjNGZkYmU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-10-31T01:28:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-10-31T17:30:57Z"}, "message": "libstd: Remove mocks.", "tree": {"sha": "d5d8b2442a5b81bf22f20db7eb536ecbf0dba368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5d8b2442a5b81bf22f20db7eb536ecbf0dba368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "html_url": "https://github.com/rust-lang/rust/commit/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f27272d60f193c6d27cc283f48c5be0e41562814", "url": "https://api.github.com/repos/rust-lang/rust/commits/f27272d60f193c6d27cc283f48c5be0e41562814", "html_url": "https://github.com/rust-lang/rust/commit/f27272d60f193c6d27cc283f48c5be0e41562814"}], "stats": {"total": 312, "additions": 131, "deletions": 181}, "files": [{"sha": "261792977b3a9da2118661824026e1005a5ae7bd", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 131, "deletions": 131, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "patch": "@@ -138,11 +138,118 @@ pub fn u64_from_be_bytes(data: &[u8],\n \n #[cfg(test)]\n mod test {\n-    use option::{Some, None};\n-    use cell::Cell;\n+    use option::{None, Option, Some};\n     use rt::io::mem::{MemReader, MemWriter};\n-    use rt::io::mock::MockReader;\n-    use rt::io::{io_error, placeholder_error};\n+    use rt::io::{Reader, io_error, placeholder_error};\n+\n+    struct InitialZeroByteReader {\n+        count: int,\n+    }\n+\n+    impl Reader for InitialZeroByteReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                Some(0)\n+            } else {\n+                buf[0] = 10;\n+                Some(1)\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct EofReader;\n+\n+    impl Reader for EofReader {\n+        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n+            None\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct ErroringReader;\n+\n+    impl Reader for ErroringReader {\n+        fn read(&mut self, _: &mut [u8]) -> Option<uint> {\n+            io_error::cond.raise(placeholder_error());\n+            None\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct PartialReader {\n+        count: int,\n+    }\n+\n+    impl Reader for PartialReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                buf[0] = 10;\n+                buf[1] = 11;\n+                Some(2)\n+            } else {\n+                buf[0] = 12;\n+                buf[1] = 13;\n+                Some(2)\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct ErroringLaterReader {\n+        count: int,\n+    }\n+\n+    impl Reader for ErroringLaterReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                buf[0] = 10;\n+                Some(1)\n+            } else {\n+                io_error::cond.raise(placeholder_error());\n+                None\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n+\n+    struct ThreeChunkReader {\n+        count: int,\n+    }\n+\n+    impl Reader for ThreeChunkReader {\n+        fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+            if self.count == 0 {\n+                self.count = 1;\n+                buf[0] = 10;\n+                buf[1] = 11;\n+                Some(2)\n+            } else if self.count == 1 {\n+                self.count = 2;\n+                buf[0] = 12;\n+                buf[1] = 13;\n+                Some(2)\n+            } else {\n+                None\n+            }\n+        }\n+        fn eof(&mut self) -> bool {\n+            false\n+        }\n+    }\n \n     #[test]\n     fn read_byte() {\n@@ -153,38 +260,23 @@ mod test {\n \n     #[test]\n     fn read_byte_0_bytes() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    Some(0)\n-                } else {\n-                    buf[0] = 10;\n-                    Some(1)\n-                }\n-            }\n+        let mut reader = InitialZeroByteReader {\n+            count: 0,\n         };\n         let byte = reader.read_byte();\n         assert!(byte == Some(10));\n     }\n \n     #[test]\n     fn read_byte_eof() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| None;\n+        let mut reader = EofReader;\n         let byte = reader.read_byte();\n         assert!(byte == None);\n     }\n \n     #[test]\n     fn read_byte_error() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| {\n-            io_error::cond.raise(placeholder_error());\n-            None\n-        };\n+        let mut reader = ErroringReader;\n         do io_error::cond.trap(|_| {\n         }).inside {\n             let byte = reader.read_byte();\n@@ -194,46 +286,30 @@ mod test {\n \n     #[test]\n     fn bytes_0_bytes() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    Some(0)\n-                } else {\n-                    buf[0] = 10;\n-                    Some(1)\n-                }\n-            }\n+        let reader = InitialZeroByteReader {\n+            count: 0,\n         };\n         let byte = reader.bytes().next();\n         assert!(byte == Some(10));\n     }\n \n     #[test]\n     fn bytes_eof() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| None;\n+        let reader = EofReader;\n         let byte = reader.bytes().next();\n         assert!(byte == None);\n     }\n \n     #[test]\n     fn bytes_error() {\n-        let mut reader = MockReader::new();\n-        reader.read = |_| {\n-            io_error::cond.raise(placeholder_error());\n-            None\n-        };\n+        let reader = ErroringReader;\n         let mut it = reader.bytes();\n         do io_error::cond.trap(|_| ()).inside {\n             let byte = it.next();\n             assert!(byte == None);\n         }\n     }\n \n-\n     #[test]\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n@@ -243,21 +319,8 @@ mod test {\n \n     #[test]\n     fn read_bytes_partial() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else {\n-                    buf[0] = 12;\n-                    buf[1] = 13;\n-                    Some(2)\n-                }\n-            }\n+        let mut reader = PartialReader {\n+            count: 0,\n         };\n         let bytes = reader.read_bytes(4);\n         assert!(bytes == ~[10, 11, 12, 13]);\n@@ -282,21 +345,8 @@ mod test {\n \n     #[test]\n     fn push_bytes_partial() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else {\n-                    buf[0] = 12;\n-                    buf[1] = 13;\n-                    Some(2)\n-                }\n-            }\n+        let mut reader = PartialReader {\n+            count: 0,\n         };\n         let mut buf = ~[8, 9];\n         reader.push_bytes(&mut buf, 4);\n@@ -316,19 +366,8 @@ mod test {\n \n     #[test]\n     fn push_bytes_error() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    Some(1)\n-                } else {\n-                    io_error::cond.raise(placeholder_error());\n-                    None\n-                }\n-            }\n+        let mut reader = ErroringLaterReader {\n+            count: 0,\n         };\n         let mut buf = ~[8, 9];\n         do io_error::cond.trap(|_| { } ).inside {\n@@ -342,19 +381,8 @@ mod test {\n     fn push_bytes_fail_reset_len() {\n         // push_bytes unsafely sets the vector length. This is testing that\n         // upon failure the length is reset correctly.\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    Some(1)\n-                } else {\n-                    io_error::cond.raise(placeholder_error());\n-                    None\n-                }\n-            }\n+        let mut reader = ErroringLaterReader {\n+            count: 0,\n         };\n         let buf = @mut ~[8, 9];\n         do (|| {\n@@ -368,24 +396,8 @@ mod test {\n \n     #[test]\n     fn read_to_end() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else if *count == 1 {\n-                    *count = 2;\n-                    buf[0] = 12;\n-                    buf[1] = 13;\n-                    Some(2)\n-                } else {\n-                    None\n-                }\n-            }\n+        let mut reader = ThreeChunkReader {\n+            count: 0,\n         };\n         let buf = reader.read_to_end();\n         assert!(buf == ~[10, 11, 12, 13]);\n@@ -394,20 +406,8 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn read_to_end_error() {\n-        let mut reader = MockReader::new();\n-        let count = Cell::new(0);\n-        reader.read = |buf| {\n-            do count.with_mut_ref |count| {\n-                if *count == 0 {\n-                    *count = 1;\n-                    buf[0] = 10;\n-                    buf[1] = 11;\n-                    Some(2)\n-                } else {\n-                    io_error::cond.raise(placeholder_error());\n-                    None\n-                }\n-            }\n+        let mut reader = ThreeChunkReader {\n+            count: 0,\n         };\n         let buf = reader.read_to_end();\n         assert!(buf == ~[10, 11]);"}, {"sha": "a0fd6846ce9b4ed830c5313441e5514d362cfdf4", "filename": "src/libstd/rt/io/mock.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27272d60f193c6d27cc283f48c5be0e41562814/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmock.rs?ref=f27272d60f193c6d27cc283f48c5be0e41562814", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use option::{Option, None};\n-use rt::io::{Reader, Writer};\n-\n-pub struct MockReader {\n-    read: ~fn(buf: &mut [u8]) -> Option<uint>,\n-    priv eof: ~fn() -> bool\n-}\n-\n-impl MockReader {\n-    pub fn new() -> MockReader {\n-        MockReader {\n-            read: |_| None,\n-            eof: || false\n-        }\n-    }\n-}\n-\n-impl Reader for MockReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { (self.read)(buf) }\n-    fn eof(&mut self) -> bool { (self.eof)() }\n-}\n-\n-pub struct MockWriter {\n-    priv write: ~fn(buf: &[u8]),\n-}\n-\n-impl MockWriter {\n-    pub fn new() -> MockWriter {\n-        MockWriter {\n-            write: |_| (),\n-        }\n-    }\n-}\n-\n-impl Writer for MockWriter {\n-    fn write(&mut self, buf: &[u8]) { (self.write)(buf) }\n-}"}, {"sha": "be205749186fb42ad33ec1b7318f22a1596aac40", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6f776d2dc22a998c6dbeb4216816489b7c4fdbe/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=a6f776d2dc22a998c6dbeb4216816489b7c4fdbe", "patch": "@@ -323,9 +323,6 @@ pub mod native {\n     }\n }\n \n-/// Mock implementations for testing\n-mod mock;\n-\n /// Signal handling\n pub mod signal;\n "}]}