{"sha": "528646e1275a90900179b473b204ca3ce19984b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyODY0NmUxMjc1YTkwOTAwMTc5YjQ3M2IyMDRjYTNjZTE5OTg0YjU=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-14T00:48:44Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:24:32Z"}, "message": "Utilize interning to allow Copy/Clone steps", "tree": {"sha": "5d86faa531fd3931f07cd2ab4fe69f282e274d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d86faa531fd3931f07cd2ab4fe69f282e274d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/528646e1275a90900179b473b204ca3ce19984b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/528646e1275a90900179b473b204ca3ce19984b5", "html_url": "https://github.com/rust-lang/rust/commit/528646e1275a90900179b473b204ca3ce19984b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/528646e1275a90900179b473b204ca3ce19984b5/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7b1a60ad7ff6ed1051c7f0945d79c96aa8068fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7b1a60ad7ff6ed1051c7f0945d79c96aa8068fd", "html_url": "https://github.com/rust-lang/rust/commit/e7b1a60ad7ff6ed1051c7f0945d79c96aa8068fd"}], "stats": {"total": 1718, "additions": 1012, "deletions": 706}, "files": [{"sha": "3f216b0c2f633d981705561a1bc5c18d32be579e", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -134,10 +134,11 @@ dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -155,8 +156,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"serde 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "daa2a3d0a0ff485c1927fe3626be3ece37e70410", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -40,3 +40,4 @@ serde = \"1.0.8\"\n serde_derive = \"1.0.8\"\n serde_json = \"1.0.2\"\n toml = \"0.4\"\n+lazy_static = \"0.2\""}, {"sha": "f217cd1dd37b2a1c39db670bff1dafce6cae494e", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -8,20 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use serde::{Serialize, Deserialize};\n-\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use std::cell::RefCell;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::fs;\n use std::ops::Deref;\n+use std::any::{TypeId, Any};\n \n use compile;\n use install;\n use dist;\n use util::{exe, libdir, add_lib_path};\n use {Build, Mode};\n-use cache::{Cache, Key};\n+use cache::{INTERNER, Interned, Cache};\n use check;\n use flags::Subcommand;\n use doc;\n@@ -34,7 +35,7 @@ pub struct Builder<'a> {\n     pub top_stage: u32,\n     pub kind: Kind,\n     cache: Cache,\n-    stack: RefCell<Vec<Key>>,\n+    stack: RefCell<Vec<(TypeId, Box<Any>)>>,\n }\n \n impl<'a> Deref for Builder<'a> {\n@@ -45,19 +46,10 @@ impl<'a> Deref for Builder<'a> {\n     }\n }\n \n-pub trait Step<'a>: Serialize + Sized {\n-    /// The output type of this step. This is used in a few places to return a\n+pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// `PathBuf` when directories are created or to return a `Compiler` once\n     /// it's been assembled.\n-    ///\n-    /// When possible, this should be used instead of implicitly creating files\n-    /// in a prearranged directory that will later be used by the build system.\n-    /// It's not always practical, however, since it makes avoiding rebuilds\n-    /// somewhat harder.\n-    type Output: Serialize + Deserialize<'a> + 'a;\n-\n-    /// This type, but with a 'static bound. Used for caching the step.\n-    type Id: 'static;\n+    type Output: Clone;\n \n     const DEFAULT: bool = false;\n \n@@ -72,13 +64,13 @@ pub trait Step<'a>: Serialize + Sized {\n \n     /// Primary function to execute this rule. Can call `builder.ensure(...)`\n     /// with other steps to run those.\n-    fn run(self, builder: &'a Builder) -> Self::Output;\n+    fn run(self, builder: &Builder) -> Self::Output;\n \n     /// When bootstrap is passed a set of paths, this controls whether this rule\n     /// will execute. However, it does not get called in a \"default\" context\n     /// when we are not passed any paths; in that case, make_run is called\n     /// directly.\n-    fn should_run(_builder: &'a Builder, _path: &Path) -> bool { false }\n+    fn should_run(_builder: &Builder, _path: &Path) -> bool { false }\n \n     /// Build up a \"root\" rule, either as a default rule or from a path passed\n     /// to us.\n@@ -87,10 +79,10 @@ pub trait Step<'a>: Serialize + Sized {\n     /// passed. When `./x.py build` is run, for example, this rule could get\n     /// called if it is in the correct list below with a path of `None`.\n     fn make_run(\n-        _builder: &'a Builder,\n+        _builder: &Builder,\n         _path: Option<&Path>,\n-        _host: &'a str,\n-        _target: &'a str,\n+        _host: Interned<String>,\n+        _target: Interned<String>,\n     ) { unimplemented!() }\n }\n \n@@ -176,26 +168,27 @@ impl<'a> Builder<'a> {\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n-    pub fn compiler(&'a self, stage: u32, host: &'a str) -> Compiler<'a> {\n+    pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n         self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n     }\n \n-    pub fn sysroot(&self, compiler: Compiler<'a>) -> PathBuf {\n+    pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n         self.ensure(compile::Sysroot { compiler })\n     }\n \n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n-    pub fn sysroot_libdir(&self, compiler: Compiler<'a>, target: &'a str) -> PathBuf {\n-        #[derive(Serialize)]\n-        struct Libdir<'a> {\n-            compiler: Compiler<'a>,\n-            target: &'a str,\n+    pub fn sysroot_libdir(\n+        &self, compiler: Compiler, target: Interned<String>\n+    ) -> Interned<PathBuf> {\n+        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        struct Libdir {\n+            compiler: Compiler,\n+            target: Interned<String>,\n         }\n-        impl<'a> Step<'a> for Libdir<'a> {\n-            type Id = Libdir<'static>;\n-            type Output = PathBuf;\n-            fn run(self, builder: &Builder) -> PathBuf {\n+        impl Step for Libdir {\n+            type Output = Interned<PathBuf>;\n+            fn run(self, builder: &Builder) -> Interned<PathBuf> {\n                 let compiler = self.compiler;\n                 let lib = if compiler.stage >= 2 && builder.build.config.libdir_relative.is_some() {\n                     builder.build.config.libdir_relative.clone().unwrap()\n@@ -206,7 +199,7 @@ impl<'a> Builder<'a> {\n                     .join(\"rustlib\").join(self.target).join(\"lib\");\n                 let _ = fs::remove_dir_all(&sysroot);\n                 t!(fs::create_dir_all(&sysroot));\n-                sysroot\n+                INTERNER.intern_path(sysroot)\n             }\n         }\n         self.ensure(Libdir { compiler, target })\n@@ -221,7 +214,7 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.build.rustc_snapshot_libdir()\n         } else {\n-            self.sysroot(compiler).join(libdir(compiler.host))\n+            self.sysroot(compiler).join(libdir(&compiler.host))\n         }\n     }\n \n@@ -243,15 +236,15 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", compiler.host))\n+            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n         }\n     }\n \n     /// Get the `rustdoc` executable next to the specified compiler\n     pub fn rustdoc(&self, compiler: Compiler) -> PathBuf {\n         let mut rustdoc = self.rustc(compiler);\n         rustdoc.pop();\n-        rustdoc.push(exe(\"rustdoc\", compiler.host));\n+        rustdoc.push(exe(\"rustdoc\", &compiler.host));\n         rustdoc\n     }\n \n@@ -265,7 +258,7 @@ impl<'a> Builder<'a> {\n     pub fn cargo(&self,\n              compiler: Compiler,\n              mode: Mode,\n-             target: &str,\n+             target: Interned<String>,\n              cmd: &str) -> Command {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n@@ -427,7 +420,7 @@ impl<'a> Builder<'a> {\n         cargo\n     }\n \n-    fn maybe_run<S: Step<'a>>(&'a self, path: Option<&Path>) {\n+    fn maybe_run<S: Step>(&self, path: Option<&Path>) {\n         let build = self.build;\n         let hosts = if S::ONLY_BUILD_TARGETS || S::ONLY_BUILD {\n             &build.config.host[..1]\n@@ -459,41 +452,45 @@ impl<'a> Builder<'a> {\n \n         for host in hosts {\n             for target in targets {\n-                S::make_run(self, path, host, target);\n+                S::make_run(self, path, *host, *target);\n             }\n         }\n     }\n \n     /// Ensure that a given step is built, returning it's output. This will\n     /// cache the step, so it is safe (and good!) to call this as often as\n     /// needed to ensure that all dependencies are built.\n-    pub fn ensure<S: Step<'a>>(&'a self, step: S) -> S::Output {\n-        let key = Cache::to_key(&step);\n+    pub fn ensure<S: Step>(&'a self, step: S) -> S::Output {\n+        let type_id = TypeId::of::<S>();\n         {\n             let mut stack = self.stack.borrow_mut();\n-            if stack.contains(&key) {\n+            for &(stack_type_id, ref stack_step) in stack.iter() {\n+                if !(type_id == stack_type_id && step == *stack_step.downcast_ref().unwrap()) {\n+                    continue\n+                }\n                 let mut out = String::new();\n-                out += &format!(\"\\n\\nCycle in build detected when adding {:?}\\n\", key);\n+                out += &format!(\"\\n\\nCycle in build detected when adding {:?}\\n\", step);\n                 for el in stack.iter().rev() {\n                     out += &format!(\"\\t{:?}\\n\", el);\n                 }\n                 panic!(out);\n             }\n-            if let Some(out) = self.cache.get::<S::Output>(&key) {\n-                self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), key));\n+            if let Some(out) = self.cache.get(&step) {\n+                self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n \n                 return out;\n             }\n-            self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), key));\n-            stack.push(key.clone());\n+            self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n+            stack.push((type_id, Box::new(step.clone())));\n         }\n-        let out = step.run(self);\n+        let out = step.clone().run(self);\n         {\n             let mut stack = self.stack.borrow_mut();\n-            assert_eq!(stack.pop().as_ref(), Some(&key));\n+            let (cur_type_id, cur_step) = stack.pop().expect(\"step stack empty\");\n+            assert_eq!((cur_type_id, cur_step.downcast_ref()), (type_id, Some(&step)));\n         }\n-        self.build.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), key));\n-        self.cache.put(key.clone(), &out);\n-        self.cache.get::<S::Output>(&key).unwrap()\n+        self.build.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n+        self.cache.put(step, out.clone());\n+        out\n     }\n }"}, {"sha": "e2576673338b81b213bc1451706e434650b340f6", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 262, "deletions": 58, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -8,85 +8,289 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use serde_json;\n-use serde::{Serialize, Deserialize};\n-use std::any::TypeId;\n-use builder::Step;\n+use serde::Deserialize;\n+use serde::de::{self, Deserializer, Visitor};\n \n+use std::any::{Any, TypeId};\n+use std::borrow::Borrow;\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::convert::AsRef;\n+use std::ffi::OsStr;\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::marker::PhantomData;\n use std::mem;\n-use std::collections::HashMap;\n-use std::cell::RefCell;\n+use std::ops::Deref;\n+use std::path::{Path, PathBuf};\n+use std::sync::Mutex;\n \n-/// This is essentially a HashMap which allows storing any type in its input and\n-/// any type in its output. It is a write-once cache; values are never evicted,\n-/// which means that references to the value can safely be returned from the\n-/// get() method.\n-//\n-// FIXME: This type does not permit retrieving &Path from a PathBuf, primarily\n-// due to a lack of any obvious way to ensure that this is safe, but also not\n-// penalize other cases (e.g., deserializing u32 -> &u32, which is non-optimal).\n-#[derive(Debug)]\n-pub struct Cache(RefCell<HashMap<Key, Box<str>>>);\n+use builder::Step;\n \n-fn to_json<T: Serialize>(element: &T) -> String {\n-    t!(serde_json::to_string(element))\n+pub struct Interned<T>(usize, PhantomData<*const T>);\n+\n+impl<'de> Deserialize<'de> for Interned<String> {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+        where D: Deserializer<'de>\n+    {\n+        struct StrVisitor;\n+\n+        impl<'de> Visitor<'de> for StrVisitor {\n+            type Value = &'de str;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"a str\")\n+            }\n+\n+            fn visit_borrowed_str<E>(self, value: &'de str) -> Result<&'de str, E>\n+                where E: de::Error\n+            {\n+                Ok(value)\n+            }\n+        }\n+\n+        Ok(INTERNER.intern_str(deserializer.deserialize_str(StrVisitor)?))\n+    }\n+}\n+impl Default for Interned<String> {\n+    fn default() -> Self {\n+        INTERNER.intern_string(String::default())\n+    }\n }\n \n-fn from_json<'a, O: Deserialize<'a>>(data: &'a str) -> O {\n-    t!(serde_json::from_str(data))\n+impl Default for Interned<PathBuf> {\n+    fn default() -> Self {\n+        INTERNER.intern_path(PathBuf::default())\n+    }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct Key(TypeId, String);\n+impl<T> Copy for Interned<T> {}\n+impl<T> Clone for Interned<T> {\n+    fn clone(&self) -> Interned<T> {\n+        *self\n+    }\n+}\n \n-impl fmt::Debug for Key {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.write_str(&format!(\"{:?}; \", self.0))?;\n-        fmt.write_str(&self.1)\n+impl<T> PartialEq for Interned<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0\n     }\n }\n+impl<T> Eq for Interned<T> {}\n \n-impl Cache {\n-    pub fn new() -> Cache {\n-        Cache(RefCell::new(HashMap::new()))\n+impl PartialEq<str> for Interned<String> {\n+    fn eq(&self, other: &str) -> bool {\n+       *self == other\n+    }\n+}\n+impl<'a> PartialEq<&'a str> for Interned<String> {\n+    fn eq(&self, other: &&str) -> bool {\n+        **self == **other\n+    }\n+}\n+impl<'a, T> PartialEq<&'a Interned<T>> for Interned<T> {\n+    fn eq(&self, other: &&Self) -> bool {\n+        self.0 == other.0\n+    }\n+}\n+impl<'a, T> PartialEq<Interned<T>> for &'a Interned<T> {\n+    fn eq(&self, other: &Interned<T>) -> bool {\n+        self.0 == other.0\n+    }\n+}\n+\n+unsafe impl<T> Send for Interned<T> {}\n+unsafe impl<T> Sync for Interned<T> {}\n+\n+impl fmt::Display for Interned<String> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let s: &str = &*self;\n+        f.write_str(s)\n+    }\n+}\n+\n+impl fmt::Debug for Interned<String> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let s: &str = &*self;\n+        f.write_fmt(format_args!(\"{:?}\", s))\n+    }\n+}\n+impl fmt::Debug for Interned<PathBuf> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let s: &Path = &*self;\n+        f.write_fmt(format_args!(\"{:?}\", s))\n+    }\n+}\n+\n+impl Hash for Interned<String> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).hash(state)\n+    }\n+}\n+\n+impl Hash for Interned<PathBuf> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let l = INTERNER.paths.lock().unwrap();\n+        l.get(*self).hash(state)\n+    }\n+}\n+\n+impl Deref for Interned<String> {\n+    type Target = str;\n+    fn deref(&self) -> &'static str {\n+        let l = INTERNER.strs.lock().unwrap();\n+        unsafe { mem::transmute::<&str, &'static str>(l.get(*self)) }\n+    }\n+}\n+\n+impl Deref for Interned<PathBuf> {\n+    type Target = Path;\n+    fn deref(&self) -> &'static Path {\n+        let l = INTERNER.paths.lock().unwrap();\n+        unsafe { mem::transmute::<&Path, &'static Path>(l.get(*self)) }\n+    }\n+}\n+\n+impl AsRef<Path> for Interned<PathBuf> {\n+    fn as_ref(&self) -> &'static Path {\n+        let l = INTERNER.paths.lock().unwrap();\n+        unsafe { mem::transmute::<&Path, &'static Path>(l.get(*self)) }\n+    }\n+}\n+\n+impl AsRef<Path> for Interned<String> {\n+    fn as_ref(&self) -> &'static Path {\n+        let l = INTERNER.strs.lock().unwrap();\n+        unsafe { mem::transmute::<&Path, &'static Path>(l.get(*self).as_ref()) }\n     }\n+}\n \n-    pub fn to_key<'a, K: Step<'a>>(key: &K) -> Key {\n-        Key(TypeId::of::<K::Id>(), to_json(key))\n+impl AsRef<OsStr> for Interned<PathBuf> {\n+    fn as_ref(&self) -> &'static OsStr {\n+        let l = INTERNER.paths.lock().unwrap();\n+        unsafe { mem::transmute::<&OsStr, &'static OsStr>(l.get(*self).as_ref()) }\n     }\n+}\n+\n+impl AsRef<OsStr> for Interned<String> {\n+    fn as_ref(&self) -> &'static OsStr {\n+        let l = INTERNER.strs.lock().unwrap();\n+        unsafe { mem::transmute::<&OsStr, &'static OsStr>(l.get(*self).as_ref()) }\n+    }\n+}\n+\n \n-    /// Puts a value into the cache. Will panic if called more than once with\n-    /// the same key.\n-    ///\n-    /// Returns the internal key utilized, as an opaque structure, useful only\n-    /// for debugging.\n-    pub fn put<V>(&self, key: Key, value: &V)\n+struct TyIntern<T> {\n+    items: Vec<T>,\n+    set: HashMap<T, Interned<T>>,\n+}\n+\n+impl<T: Hash + Clone + Eq> TyIntern<T> {\n+    fn new() -> TyIntern<T> {\n+        TyIntern {\n+            items: Vec::new(),\n+            set: HashMap::new(),\n+        }\n+    }\n+\n+    fn intern_borrow<B>(&mut self, item: &B) -> Interned<T>\n     where\n-        V: Serialize,\n+        B: Eq + Hash + ToOwned<Owned=T> + ?Sized,\n+        T: Borrow<B>,\n     {\n+        if let Some(i) = self.set.get(&item) {\n+            return *i;\n+        }\n+        let item = item.to_owned();\n+        let interned =  Interned(self.items.len(), PhantomData::<*const T>);\n+        self.set.insert(item.clone(), interned);\n+        self.items.push(item);\n+        interned\n+    }\n+\n+    fn intern(&mut self, item: T) -> Interned<T> {\n+        if let Some(i) = self.set.get(&item) {\n+            return *i;\n+        }\n+        let interned =  Interned(self.items.len(), PhantomData::<*const T>);\n+        self.set.insert(item.clone(), interned);\n+        self.items.push(item);\n+        interned\n+    }\n+\n+    fn get(&self, i: Interned<T>) -> &T {\n+        &self.items[i.0]\n+    }\n+}\n+\n+pub struct Interner {\n+    strs: Mutex<TyIntern<String>>,\n+    paths: Mutex<TyIntern<PathBuf>>,\n+}\n+\n+impl Interner {\n+    fn new() -> Interner {\n+        Interner {\n+            strs: Mutex::new(TyIntern::new()),\n+            paths: Mutex::new(TyIntern::new()),\n+        }\n+    }\n+\n+    pub fn intern_str(&self, s: &str) -> Interned<String> {\n+        self.strs.lock().unwrap().intern_borrow(s)\n+    }\n+    pub fn intern_string(&self, s: String) -> Interned<String> {\n+        self.strs.lock().unwrap().intern(s)\n+    }\n+\n+    pub fn intern_path(&self, s: PathBuf) -> Interned<PathBuf> {\n+        self.paths.lock().unwrap().intern(s)\n+    }\n+}\n+\n+lazy_static! {\n+    pub static ref INTERNER: Interner = Interner::new();\n+}\n+\n+/// This is essentially a HashMap which allows storing any type in its input and\n+/// any type in its output. It is a write-once cache; values are never evicted,\n+/// which means that references to the value can safely be returned from the\n+/// get() method.\n+//\n+// FIXME: This type does not permit retrieving &Path from a PathBuf, primarily\n+// due to a lack of any obvious way to ensure that this is safe, but also not\n+#[derive(Debug)]\n+pub struct Cache(\n+    RefCell<HashMap<\n+        TypeId,\n+        Box<Any>, // actually a HashMap<Step, Interned<Step::Output>>\n+    >>\n+);\n+\n+impl Cache {\n+    pub fn new() -> Cache {\n+        Cache(RefCell::new(HashMap::new()))\n+    }\n+\n+    pub fn put<S: Step>(&self, step: S, value: S::Output) {\n         let mut cache = self.0.borrow_mut();\n-        let value = to_json(value);\n-        assert!(!cache.contains_key(&key), \"processing {:?} a second time\", key);\n-        // Store a boxed str so that it's location in memory never changes and\n-        // it's safe for us to return references to it (so long as they live as\n-        // long as us).\n-        cache.insert(key, value.into_boxed_str());\n+        let type_id = TypeId::of::<S>();\n+        let stepcache = cache.entry(type_id)\n+                        .or_insert_with(|| Box::new(HashMap::<S, S::Output>::new()))\n+                        .downcast_mut::<HashMap<S, S::Output>>()\n+                        .expect(\"invalid type mapped\");\n+        assert!(!stepcache.contains_key(&step), \"processing {:?} a second time\", step);\n+        stepcache.insert(step, value);\n     }\n \n-    pub fn get<'a, V>(&'a self, key: &Key) -> Option<V>\n-    where\n-        V: Deserialize<'a> + 'a,\n-    {\n-        let cache = self.0.borrow();\n-        cache.get(key).map(|v| {\n-            // Change the lifetime. This borrow is valid for as long as self lives;\n-            // the data we're accessing will live as long as us and will be in a\n-            // stable location, since we use Box<str>.\n-            let v = unsafe {\n-                mem::transmute::<&str, &'a str>(v)\n-            };\n-            from_json(v)\n-        })\n+    pub fn get<S: Step>(&self, step: &S) -> Option<S::Output> {\n+        let mut cache = self.0.borrow_mut();\n+        let type_id = TypeId::of::<S>();\n+        let stepcache = cache.entry(type_id)\n+                        .or_insert_with(|| Box::new(HashMap::<S, S::Output>::new()))\n+                        .downcast_mut::<HashMap<S, S::Output>>()\n+                        .expect(\"invalid type mapped\");\n+        stepcache.get(step).cloned()\n     }\n }"}, {"sha": "739904e4f7c58edabc56553b8bf0b037f8f53bec", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -38,6 +38,7 @@ use gcc;\n \n use Build;\n use config::Target;\n+use cache::Interned;\n \n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n@@ -50,11 +51,11 @@ pub fn find(build: &mut Build) {\n         cfg.cargo_metadata(false).opt_level(0).debug(false)\n            .target(target).host(&build.build);\n \n-        let config = build.config.target_config.get(target);\n+        let config = build.config.target_config.get(&target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n             cfg.compiler(cc);\n         } else {\n-            set_compiler(&mut cfg, \"gcc\", target, config, build);\n+            set_compiler(&mut cfg, \"gcc\", *target, config, build);\n         }\n \n         let compiler = cfg.get_compiler();\n@@ -63,7 +64,7 @@ pub fn find(build: &mut Build) {\n         if let Some(ref ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n         }\n-        build.cc.insert(target.to_string(), (compiler, ar));\n+        build.cc.insert(*target, (compiler, ar));\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n@@ -78,20 +79,20 @@ pub fn find(build: &mut Build) {\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n         } else {\n-            set_compiler(&mut cfg, \"g++\", host, config, build);\n+            set_compiler(&mut cfg, \"g++\", *host, config, build);\n         }\n         let compiler = cfg.get_compiler();\n         build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n-        build.cxx.insert(host.to_string(), compiler);\n+        build.cxx.insert(*host, compiler);\n     }\n }\n \n fn set_compiler(cfg: &mut gcc::Config,\n                 gnu_compiler: &str,\n-                target: &str,\n+                target: Interned<String>,\n                 config: Option<&Target>,\n                 build: &Build) {\n-    match target {\n+    match &*target {\n         // When compiling for android we may have the NDK configured in the\n         // config.toml in which case we look there. Otherwise the default\n         // compiler already takes into account the triple in question."}, {"sha": "d983e54ac0851235fc14be75fd59258f7ad94005", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 137, "deletions": 97, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -33,11 +33,12 @@ use compile;\n use native;\n use builder::{Kind, Builder, Compiler, Step};\n use tool::{self, Tool};\n+use cache::{INTERNER, Interned};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n /// The two modes of the test runner; tests or benchmarks.\n-#[derive(Serialize, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n pub enum TestKind {\n     /// Run `cargo test`\n     Test,\n@@ -93,13 +94,12 @@ fn try_run_quiet(build: &Build, cmd: &mut Command) {\n //      .host(true)\n //      .run(move |s| check::linkcheck(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct Linkcheck<'a> {\n-    host: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Linkcheck {\n+    host: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Linkcheck<'a> {\n-    type Id = Linkcheck<'static>;\n+impl Step for Linkcheck {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n@@ -125,7 +125,12 @@ impl<'a> Step<'a> for Linkcheck<'a> {\n         path.ends_with(\"src/tools/linkchecker\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        path: Option<&Path>,\n+        host: Interned<String>,\n+        _target: Interned<String>,\n+    ) {\n         if path.is_some() {\n             builder.ensure(Linkcheck { host });\n         } else {\n@@ -142,22 +147,26 @@ impl<'a> Step<'a> for Linkcheck<'a> {\n //      .host(true)\n //      .run(move |s| check::cargotest(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Cargotest<'a> {\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargotest {\n     stage: u32,\n-    host: &'a str,\n+    host: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Cargotest<'a> {\n-    type Id = Cargotest<'static>;\n+impl Step for Cargotest {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/tools/cargotest\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        _target: Interned<String>,\n+    ) {\n         builder.ensure(Cargotest {\n             stage: builder.top_stage,\n             host: host,\n@@ -193,22 +202,26 @@ impl<'a> Step<'a> for Cargotest<'a> {\n //     .host(true)\n //     .run(move |s| check::cargo(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Cargo<'a> {\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargo {\n     stage: u32,\n-    host: &'a str,\n+    host: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Cargo<'a> {\n-    type Id = Cargo<'static>;\n+impl Step for Cargo {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/tools/cargo\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        _host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         builder.ensure(Cargotest {\n             stage: builder.top_stage,\n             host: target,\n@@ -304,13 +317,12 @@ fn path_for_cargo(build: &Build, compiler: &Compiler) -> OsString {\n //     .only_build(true)\n //     .run(move |s| check::tidy(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct Tidy<'a> {\n-    host: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Tidy {\n+    host: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Tidy<'a> {\n-    type Id = Tidy<'static>;\n+impl Step for Tidy {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -342,14 +354,19 @@ impl<'a> Step<'a> for Tidy<'a> {\n         path.ends_with(\"src/tools/tidy\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        _host: Interned<String>,\n+        _target: Interned<String>,\n+    ) {\n         builder.ensure(Tidy {\n-            host: &builder.build.build,\n+            host: builder.build.build,\n         });\n     }\n }\n \n-fn testdir(build: &Build, host: &str) -> PathBuf {\n+fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n     build.out.join(host).join(\"test\")\n }\n \n@@ -451,15 +468,15 @@ fn testdir(build: &Build, host: &str) -> PathBuf {\n //              \"pretty\", \"run-fail-fulldeps\");\n //    }\n \n-#[derive(Serialize)]\n-pub struct Compiletest<'a> {\n-    compiler: Compiler<'a>,\n-    target: &'a str,\n-    mode: &'a str,\n-    suite: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Compiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Test {\n     path: &'static str,\n     mode: &'static str,\n@@ -512,8 +529,7 @@ static COMPILETESTS: &[Test] = &[\n     Test { path: \"src/test/debuginfo-gdb\", mode: \"debuginfo-gdb\", suite: \"debuginfo\" },\n ];\n \n-impl<'a> Step<'a> for Compiletest<'a> {\n-    type Id = Compiletest<'static>;\n+impl Step for Compiletest {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n@@ -526,7 +542,12 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         let compiler = builder.compiler(builder.top_stage, host);\n \n         let test = path.map(|path| {\n@@ -591,12 +612,12 @@ impl<'a> Step<'a> for Compiletest<'a> {\n                     builder.ensure(Compiletest {\n                         mode: \"debuginfo-lldb\",\n                         ..self\n-                    })\n+                    });\n                 } else {\n                     builder.ensure(Compiletest {\n                         mode: \"debuginfo-gdb\",\n                         ..self\n-                    })\n+                    });\n                 };\n             }\n \n@@ -606,7 +627,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n             }\n \n             builder.ensure(dist::DebuggerScripts {\n-                sysroot: &builder.sysroot(compiler),\n+                sysroot: builder.sysroot(compiler),\n                 target: target\n             });\n \n@@ -630,7 +651,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n \n         let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n         println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, compiler.host, target);\n+                 suite, mode, &compiler.host, target);\n         let mut cmd = builder.tool_cmd(Tool::Compiletest);\n \n         // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -645,8 +666,8 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n         cmd.arg(\"--target\").arg(target);\n-        cmd.arg(\"--host\").arg(compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.build));\n+        cmd.arg(\"--host\").arg(&*compiler.host);\n+        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n \n         if let Some(ref nodejs) = build.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n@@ -664,7 +685,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         hostflags.extend(flags.clone());\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n-        let mut targetflags = build.rustc_flags(&target);\n+        let mut targetflags = build.rustc_flags(target);\n         targetflags.extend(flags);\n         targetflags.push(format!(\"-Lnative={}\",\n                                  build.test_helpers_out(target).display()));\n@@ -735,7 +756,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n         // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n         // rather than stomp over it.\n         if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[target].0.env() {\n+            for &(ref k, ref v) in build.cc[&target].0.env() {\n                 if k != \"PATH\" {\n                     cmd.env(k, v);\n                 }\n@@ -769,18 +790,17 @@ impl<'a> Step<'a> for Compiletest<'a> {\n     }\n }\n \n-#[derive(Serialize)]\n-pub struct Docs<'a> {\n-    compiler: Compiler<'a>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Docs {\n+    compiler: Compiler,\n }\n \n // rules.test(\"check-docs\", \"src/doc\")\n //     .dep(|s| s.name(\"libtest\"))\n //     .default(true)\n //     .host(true)\n //     .run(move |s| check::docs(build, &s.compiler()));\n-impl<'a> Step<'a> for Docs<'a> {\n-    type Id = Docs<'static>;\n+impl Step for Docs {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -789,7 +809,12 @@ impl<'a> Step<'a> for Docs<'a> {\n         path.ends_with(\"src/doc\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        _target: Interned<String>,\n+    ) {\n         builder.ensure(Docs {\n             compiler: builder.compiler(builder.top_stage, host),\n         });\n@@ -840,13 +865,12 @@ impl<'a> Step<'a> for Docs<'a> {\n //     .host(true)\n //     .run(move |s| check::error_index(build, &s.compiler()));\n \n-#[derive(Serialize)]\n-pub struct ErrorIndex<'a> {\n-    compiler: Compiler<'a>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ErrorIndex {\n+    compiler: Compiler,\n }\n \n-impl<'a> Step<'a> for ErrorIndex<'a> {\n-    type Id = ErrorIndex<'static>;\n+impl Step for ErrorIndex {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -855,7 +879,12 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         path.ends_with(\"src/tools/error_index_generator\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        _target: Interned<String>,\n+    ) {\n         builder.ensure(ErrorIndex {\n             compiler: builder.compiler(builder.top_stage, host),\n         });\n@@ -933,16 +962,15 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n //         .host(true)\n //         .run(move |s| check::krate(build, &s.compiler(), s.target,\n //                                    Mode::Librustc, TestKind::Test, None));\n-#[derive(Serialize)]\n-pub struct KrateLibrustc<'a> {\n-    compiler: Compiler<'a>,\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct KrateLibrustc {\n+    compiler: Compiler,\n+    target: Interned<String>,\n     test_kind: TestKind,\n-    krate: Option<&'a str>,\n+    krate: Option<Interned<String>>,\n }\n \n-impl<'a> Step<'a> for KrateLibrustc<'a> {\n-    type Id = KrateLibrustc<'static>;\n+impl Step for KrateLibrustc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -953,10 +981,15 @@ impl<'a> Step<'a> for KrateLibrustc<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         let compiler = builder.compiler(builder.top_stage, host);\n \n-        let run = |name: Option<&str>| {\n+        let run = |name: Option<Interned<String>>| {\n             let test_kind = if builder.kind == Kind::Test {\n                 TestKind::Test\n             } else if builder.kind == Kind::Bench {\n@@ -1043,17 +1076,16 @@ impl<'a> Step<'a> for KrateLibrustc<'a> {\n //         .run(move |s| check::krate(build, &s.compiler(), s.target,\n //                                    Mode::Libtest, TestKind::Test, None));\n \n-#[derive(Serialize)]\n-pub struct Krate<'a> {\n-    compiler: Compiler<'a>,\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Krate {\n+    compiler: Compiler,\n+    target: Interned<String>,\n     mode: Mode,\n     test_kind: TestKind,\n-    krate: Option<&'a str>,\n+    krate: Option<Interned<String>>,\n }\n \n-impl<'a> Step<'a> for Krate<'a> {\n-    type Id = Krate<'static>;\n+impl Step for Krate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n@@ -1066,10 +1098,15 @@ impl<'a> Step<'a> for Krate<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         let compiler = builder.compiler(builder.top_stage, host);\n \n-        let run = |mode: Mode, name: Option<&str>| {\n+        let run = |mode: Mode, name: Option<Interned<String>>| {\n             let test_kind = if builder.kind == Kind::Test {\n                 TestKind::Test\n             } else if builder.kind == Kind::Bench {\n@@ -1134,11 +1171,12 @@ impl<'a> Step<'a> for Krate<'a> {\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n+        let root = INTERNER.intern_string(String::from(root));\n         let _folder = build.fold_output(|| {\n             format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n         });\n         println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n-                compiler.host, target);\n+                &compiler.host, target);\n \n         // If we're not doing a full bootstrap but we're testing a stage2 version of\n         // libstd, then what we're actually testing is the libstd produced in\n@@ -1180,12 +1218,12 @@ impl<'a> Step<'a> for Krate<'a> {\n                     // target during the bootstrap and it's just meant to be a\n                     // helper crate, not tested. If it leaks through then it ends up\n                     // messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") && name != \"build_helper\" {\n+                    if !name.contains(\"jemalloc\") && *name != *\"build_helper\" {\n                         cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n                     }\n-                    for dep in build.crates[name].deps.iter() {\n+                    for dep in build.crates[&name].deps.iter() {\n                         if visited.insert(dep) {\n-                            next.push(dep);\n+                            next.push(*dep);\n                         }\n                     }\n                 }\n@@ -1198,7 +1236,7 @@ impl<'a> Step<'a> for Krate<'a> {\n         // Note that to run the compiler we need to run with the *host* libraries,\n         // but our wrapper scripts arrange for that to be the case anyway.\n         let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, builder.sysroot_libdir(compiler, target));\n+        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n         if target.contains(\"emscripten\") || build.remote_tested(target) {\n@@ -1228,7 +1266,7 @@ impl<'a> Step<'a> for Krate<'a> {\n \n fn krate_emscripten(build: &Build,\n                     compiler: Compiler,\n-                    target: &str,\n+                    target: Interned<String>,\n                     mode: Mode) {\n     let out_dir = build.cargo_out(compiler, mode, target);\n     let tests = find_tests(&out_dir.join(\"deps\"), target);\n@@ -1247,7 +1285,7 @@ fn krate_emscripten(build: &Build,\n \n fn krate_remote(builder: &Builder,\n                 compiler: Compiler,\n-                target: &str,\n+                target: Interned<String>,\n                 mode: Mode) {\n     let build = builder.build;\n     let out_dir = build.cargo_out(compiler, mode, target);\n@@ -1266,7 +1304,7 @@ fn krate_remote(builder: &Builder,\n     }\n }\n \n-fn find_tests(dir: &Path, target: &str) -> Vec<PathBuf> {\n+fn find_tests(dir: &Path, target: Interned<String>) -> Vec<PathBuf> {\n     let mut dst = Vec::new();\n     for e in t!(dir.read_dir()).map(|e| t!(e)) {\n         let file_type = t!(e.file_type());\n@@ -1313,14 +1351,13 @@ fn find_tests(dir: &Path, target: &str) -> Vec<PathBuf> {\n /// QEMU we have to build our own tools so we've got conditional dependencies\n /// on those programs as well. Note that the remote test client is built for\n /// the build target (us) and the server is built for the target.\n-#[derive(Serialize)]\n-pub struct RemoteCopyLibs<'a> {\n-    compiler: Compiler<'a>,\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RemoteCopyLibs {\n+    compiler: Compiler,\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for RemoteCopyLibs<'a> {\n-    type Id = RemoteCopyLibs<'static>;\n+impl Step for RemoteCopyLibs {\n     type Output = ();\n \n     fn run(self, builder: &Builder) {\n@@ -1368,18 +1405,17 @@ impl<'a> Step<'a> for RemoteCopyLibs<'a> {\n //     .dep(|s| s.name(\"dist-src\"))\n //     .run(move |_| check::distcheck(build));\n \n-#[derive(Serialize)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Distcheck;\n \n-impl<'a> Step<'a> for Distcheck {\n-    type Id = Distcheck;\n+impl Step for Distcheck {\n     type Output = ();\n \n     /// Run \"distcheck\", a 'make check' from a tarball\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        if build.build != \"x86_64-unknown-linux-gnu\" {\n+        if *build.build != *\"x86_64-unknown-linux-gnu\" {\n             return\n         }\n         if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n@@ -1436,11 +1472,10 @@ impl<'a> Step<'a> for Distcheck {\n //     .only_build(true)\n //     .run(move |_| check::bootstrap(build));\n \n-#[derive(Serialize)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Bootstrap;\n \n-impl<'a> Step<'a> for Bootstrap {\n-    type Id = Bootstrap;\n+impl Step for Bootstrap {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -1466,7 +1501,12 @@ impl<'a> Step<'a> for Bootstrap {\n         path.ends_with(\"src/bootstrap\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        _host: Interned<String>,\n+        _target: Interned<String>,\n+    ) {\n         builder.ensure(Bootstrap);\n     }\n }"}, {"sha": "558ced12cfea6080ace31b17d017a8b0bd56aed1", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 112, "deletions": 107, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -32,6 +32,7 @@ use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n use native;\n \n+use cache::{INTERNER, Interned};\n use builder::{Step, Builder};\n \n //\n@@ -140,14 +141,13 @@ use builder::{Step, Builder};\n //             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n //             .run(move |s| compile::std(build, s.target, &s.compiler()));\n //    }\n-#[derive(Serialize)]\n-pub struct Std<'a> {\n-    pub target: &'a str,\n-    pub compiler: Compiler<'a>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Std {\n+    pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n-impl<'a> Step<'a> for Std<'a> {\n-    type Id = Std<'static>;\n+impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n@@ -158,11 +158,16 @@ impl<'a> Step<'a> for Std<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         builder.ensure(Std {\n             compiler: builder.compiler(builder.top_stage, host),\n             target,\n-        })\n+        });\n     }\n \n     /// Build the standard library.\n@@ -178,7 +183,7 @@ impl<'a> Step<'a> for Std<'a> {\n         builder.ensure(StartupObjects { compiler, target });\n \n         if build.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, &build.build);\n+            let from = builder.compiler(1, build.build);\n             builder.ensure(Std {\n                 compiler: from,\n                 target: target,\n@@ -194,7 +199,7 @@ impl<'a> Step<'a> for Std<'a> {\n \n         let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                compiler.host, target);\n+                &compiler.host, target);\n \n         let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n@@ -229,7 +234,7 @@ impl<'a> Step<'a> for Std<'a> {\n             .arg(\"--manifest-path\")\n             .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n \n-        if let Some(target) = build.config.target_config.get(target) {\n+        if let Some(target) = build.config.target_config.get(&target) {\n             if let Some(ref jemalloc) = target.jemalloc {\n                 cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n             }\n@@ -245,7 +250,7 @@ impl<'a> Step<'a> for Std<'a> {\n                 &libstd_stamp(build, compiler, target));\n \n         builder.ensure(StdLink {\n-            compiler: builder.compiler(compiler.stage, &build.build),\n+            compiler: builder.compiler(compiler.stage, build.build),\n             target_compiler: compiler,\n             target: target,\n         });\n@@ -261,15 +266,14 @@ impl<'a> Step<'a> for Std<'a> {\n //     .dep(|s| s.name(\"startup-objects\"))\n //     .dep(|s| s.name(\"create-sysroot\").target(s.host));\n \n-#[derive(Serialize)]\n-struct StdLink<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target_compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct StdLink {\n+    pub compiler: Compiler,\n+    pub target_compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for StdLink<'a> {\n-    type Id = StdLink<'static>;\n+impl Step for StdLink {\n     type Output = ();\n \n     /// Link all libstd rlibs/dylibs into the sysroot location.\n@@ -288,7 +292,7 @@ impl<'a> Step<'a> for StdLink<'a> {\n         println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n-                compiler.host,\n+                &compiler.host,\n                 target_compiler.host,\n                 target);\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n@@ -310,7 +314,7 @@ impl<'a> Step<'a> for StdLink<'a> {\n /// Copies the crt(1,i,n).o startup objects\n ///\n /// Only required for musl targets that statically link to libc\n-fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {\n+fn copy_musl_third_party_objects(build: &Build, target: Interned<String>, into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n         copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n@@ -332,25 +336,29 @@ fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n //      .dep(|s| s.name(\"create-sysroot\").target(s.host))\n //      .run(move |s| compile::build_startup_objects(build, &s.compiler(), s.target));\n \n-#[derive(Serialize)]\n-pub struct StartupObjects<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct StartupObjects {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for StartupObjects<'a> {\n-    type Id = StartupObjects<'static>;\n+impl Step for StartupObjects {\n     type Output = ();\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/rtstartup\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         builder.ensure(StartupObjects {\n             compiler: builder.compiler(builder.top_stage, host),\n             target,\n-        })\n+        });\n     }\n \n     /// Build and prepare startup objects like rsbegin.o and rsend.o\n@@ -399,14 +407,13 @@ impl<'a> Step<'a> for StartupObjects<'a> {\n //             .dep(|s| s.name(\"libstd-link\"))\n //             .run(move |s| compile::test(build, s.target, &s.compiler()));\n //    }\n-#[derive(Serialize)]\n-pub struct Test<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Test {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Test<'a> {\n-    type Id = Test<'static>;\n+impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n@@ -417,11 +424,16 @@ impl<'a> Step<'a> for Test<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         builder.ensure(Test {\n             compiler: builder.compiler(builder.top_stage, host),\n             target,\n-        })\n+        });\n     }\n \n     /// Build libtest.\n@@ -438,12 +450,12 @@ impl<'a> Step<'a> for Test<'a> {\n \n         if build.force_use_stage1(compiler, target) {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, &build.build),\n+                compiler: builder.compiler(1, build.build),\n                 target: target,\n             });\n             println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, &build.build),\n+                compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n                 target: target,\n             });\n@@ -452,7 +464,7 @@ impl<'a> Step<'a> for Test<'a> {\n \n         let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                compiler.host, target);\n+                &compiler.host, target);\n         let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n@@ -466,7 +478,7 @@ impl<'a> Step<'a> for Test<'a> {\n                 &libtest_stamp(build, compiler, target));\n \n         builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, &build.build),\n+            compiler: builder.compiler(compiler.stage, build.build),\n             target_compiler: compiler,\n             target: target,\n         });\n@@ -481,15 +493,14 @@ impl<'a> Step<'a> for Test<'a> {\n //            compile::test_link)\n //     .dep(|s| s.name(\"libstd-link\"));\n \n-#[derive(Serialize)]\n-pub struct TestLink<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target_compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct TestLink {\n+    pub compiler: Compiler,\n+    pub target_compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for TestLink<'a> {\n-    type Id = TestLink<'static>;\n+impl Step for TestLink {\n     type Output = ();\n \n     /// Same as `std_link`, only for libtest\n@@ -501,7 +512,7 @@ impl<'a> Step<'a> for TestLink<'a> {\n         println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n-                compiler.host,\n+                &compiler.host,\n                 target_compiler.host,\n                 target);\n         add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n@@ -517,14 +528,13 @@ impl<'a> Step<'a> for TestLink<'a> {\n //             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n //    }\n \n-#[derive(Serialize)]\n-pub struct Rustc<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustc {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Rustc<'a> {\n-    type Id = Rustc<'static>;\n+impl Step for Rustc {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n@@ -536,11 +546,16 @@ impl<'a> Step<'a> for Rustc<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         builder.ensure(Rustc {\n             compiler: builder.compiler(builder.top_stage, host),\n             target,\n-        })\n+        });\n     }\n \n     /// Build the compiler.\n@@ -561,12 +576,12 @@ impl<'a> Step<'a> for Rustc<'a> {\n \n         if build.force_use_stage1(compiler, target) {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, &build.build),\n+                compiler: builder.compiler(1, build.build),\n                 target: target,\n             });\n             println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, &build.build),\n+                compiler: builder.compiler(1, build.build),\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -575,13 +590,13 @@ impl<'a> Step<'a> for Rustc<'a> {\n \n         // Ensure that build scripts have a std to link against.\n         builder.ensure(Std {\n-            compiler: builder.compiler(self.compiler.stage, &build.build),\n-            target: &build.build,\n+            compiler: builder.compiler(self.compiler.stage, build.build),\n+            target: build.build,\n         });\n \n         let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, compiler.host, target);\n+                 compiler.stage, &compiler.host, target);\n \n         let out_dir = build.cargo_out(compiler, Mode::Librustc, target);\n         build.clear_if_dirty(&out_dir, &libtest_stamp(build, compiler, target));\n@@ -627,7 +642,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n             cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n         }\n         cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n-        let target_config = build.config.target_config.get(target);\n+        let target_config = build.config.target_config.get(&target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             cargo.env(\"CFG_LLVM_ROOT\", s);\n         }\n@@ -653,7 +668,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n                   &librustc_stamp(build, compiler, target));\n \n         builder.ensure(RustcLink {\n-            compiler: builder.compiler(compiler.stage, &build.build),\n+            compiler: builder.compiler(compiler.stage, build.build),\n             target_compiler: compiler,\n             target,\n         });\n@@ -666,15 +681,14 @@ impl<'a> Step<'a> for Rustc<'a> {\n //            \"build-crate-rustc-main\",\n //            compile::rustc_link)\n //     .dep(|s| s.name(\"libtest-link\"));\n-#[derive(Serialize)]\n-struct RustcLink<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target_compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct RustcLink {\n+    pub compiler: Compiler,\n+    pub target_compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for RustcLink<'a> {\n-    type Id = RustcLink<'static>;\n+impl Step for RustcLink {\n     type Output = ();\n \n     /// Same as `std_link`, only for librustc\n@@ -686,7 +700,7 @@ impl<'a> Step<'a> for RustcLink<'a> {\n         println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n                  target_compiler.stage,\n                  compiler.stage,\n-                 compiler.host,\n+                 &compiler.host,\n                  target_compiler.host,\n                  target);\n         add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n@@ -696,19 +710,19 @@ impl<'a> Step<'a> for RustcLink<'a> {\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(build: &Build, compiler: Compiler, target: &str) -> PathBuf {\n+pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(build: &Build, compiler: Compiler, target: &str) -> PathBuf {\n+pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(build: &Build, compiler: Compiler, target: &str) -> PathBuf {\n+pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n }\n \n@@ -721,32 +735,31 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n // rules.build(\"create-sysroot\", \"path/to/nowhere\")\n //      .run(move |s| compile::create_sysroot(build, &s.compiler()));\n \n-#[derive(Serialize)]\n-pub struct Sysroot<'a> {\n-    pub compiler: Compiler<'a>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Sysroot {\n+    pub compiler: Compiler,\n }\n \n-impl<'a> Step<'a> for Sysroot<'a> {\n-    type Id = Sysroot<'static>;\n-    type Output = PathBuf;\n+impl Step for Sysroot {\n+    type Output = Interned<PathBuf>;\n \n     /// Returns the sysroot for the `compiler` specified that *this build system\n     /// generates*.\n     ///\n     /// That is, the sysroot for the stage0 compiler is not what the compiler\n     /// thinks it is by default, but it's the same as the default for stages\n     /// 1-3.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder) -> Interned<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n-            build.out.join(compiler.host).join(\"stage0-sysroot\")\n+            build.out.join(&compiler.host).join(\"stage0-sysroot\")\n         } else {\n-            build.out.join(compiler.host).join(format!(\"stage{}\", compiler.stage))\n+            build.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n-        sysroot\n+        INTERNER.intern_path(sysroot)\n     }\n }\n \n@@ -764,25 +777,24 @@ impl<'a> Step<'a> for Sysroot<'a> {\n //      })\n //      .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Assemble<'a> {\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Assemble {\n     /// The compiler which we will produce in this step. Assemble itself will\n     /// take care of ensuring that the necessary prerequisites to do so exist,\n     /// that is, this target can be a stage2 compiler and Assemble will build\n     /// previous stages for you.\n-    pub target_compiler: Compiler<'a>,\n+    pub target_compiler: Compiler,\n }\n \n-impl<'a> Step<'a> for Assemble<'a> {\n-    type Id = Assemble<'static>;\n-    type Output = Compiler<'a>;\n+impl Step for Assemble {\n+    type Output = Compiler;\n \n     /// Prepare a new compiler from the artifacts in `stage`\n     ///\n     /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n     /// must have been previously produced by the `stage - 1` build.build\n     /// compiler.\n-    fn run(self, builder: &Builder) -> Compiler<'a> {\n+    fn run(self, builder: &Builder) -> Compiler {\n         let build = builder.build;\n         let target_compiler = self.target_compiler;\n \n@@ -799,21 +811,14 @@ impl<'a> Step<'a> for Assemble<'a> {\n             // compiler for the host platform for this because it doesn't have\n             // the libraries we need.  FIXME: Perhaps we should download those\n             // libraries? It would make builds faster...\n-            builder.ensure(Assemble {\n-                target_compiler: Compiler {\n-                    // FIXME: It may be faster if we build just a stage 1\n-                    // compiler and then use that to bootstrap this compiler\n-                    // forward.\n-                    stage: target_compiler.stage - 1,\n-                    host: &build.build\n-                },\n-            })\n+            // FIXME: It may be faster if we build just a stage 1\n+            // compiler and then use that to bootstrap this compiler\n+            // forward.\n+            builder.compiler(target_compiler.stage - 1, build.build)\n         } else {\n             // Build the compiler we'll use to build the stage requested. This\n             // may build more than one compiler (going down to stage 0).\n-            builder.ensure(Assemble {\n-                target_compiler: target_compiler.with_stage(target_compiler.stage - 1),\n-            })\n+            builder.compiler(target_compiler.stage - 1, target_compiler.host)\n         };\n \n         // Build the libraries for this compiler to link to (i.e., the libraries\n@@ -829,7 +834,7 @@ impl<'a> Step<'a> for Assemble<'a> {\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n-        let sysroot_libdir = sysroot.join(libdir(host));\n+        let sysroot_libdir = sysroot.join(libdir(&*host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n         for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n@@ -842,15 +847,15 @@ impl<'a> Step<'a> for Assemble<'a> {\n         let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n \n         // Link the compiler binary itself into place\n-        let rustc = out_dir.join(exe(\"rustc\", host));\n+        let rustc = out_dir.join(exe(\"rustc\", &*host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n         let _ = fs::remove_file(&compiler);\n         copy(&rustc, &compiler);\n \n         // See if rustdoc exists to link it into place\n-        let rustdoc = exe(\"rustdoc\", host);\n+        let rustdoc = exe(\"rustdoc\", &*host);\n         let rustdoc_src = out_dir.join(&rustdoc);\n         let rustdoc_dst = bindir.join(&rustdoc);\n         if fs::metadata(&rustdoc_src).is_ok() {"}, {"sha": "abb0408c4d24780e9ebf6f18090c2acc7708ccef", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -23,6 +23,7 @@ use std::process;\n use num_cpus;\n use toml;\n use util::{exe, push_exe_path};\n+use cache::{INTERNER, Interned};\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -45,7 +46,7 @@ pub struct Config {\n     pub docs: bool,\n     pub locked_deps: bool,\n     pub vendor: bool,\n-    pub target_config: HashMap<String, Target>,\n+    pub target_config: HashMap<Interned<String>, Target>,\n     pub full_bootstrap: bool,\n     pub extended: bool,\n     pub sanitizers: bool,\n@@ -77,9 +78,9 @@ pub struct Config {\n     pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n \n-    pub build: String,\n-    pub host: Vec<String>,\n-    pub target: Vec<String>,\n+    pub build: Interned<String>,\n+    pub host: Vec<Interned<String>>,\n+    pub target: Vec<Interned<String>>,\n     pub local_rebuild: bool,\n \n     // dist misc\n@@ -282,7 +283,7 @@ impl Config {\n         config.docs = true;\n         config.rust_rpath = true;\n         config.rust_codegen_units = 1;\n-        config.build = build.to_string();\n+        config.build = INTERNER.intern_str(build);\n         config.channel = \"dev\".to_string();\n         config.codegen_tests = true;\n         config.rust_dist_src = true;\n@@ -302,16 +303,19 @@ impl Config {\n         }).unwrap_or_else(|| TomlConfig::default());\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n-        set(&mut config.build, build.build.clone());\n+        set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n         config.host.push(config.build.clone());\n         for host in build.host.iter() {\n-            if !config.host.contains(host) {\n-                config.host.push(host.clone());\n+            let host = INTERNER.intern_str(host);\n+            if !config.host.contains(&host) {\n+                config.host.push(host);\n             }\n         }\n-        for target in config.host.iter().chain(&build.target) {\n-            if !config.target.contains(target) {\n-                config.target.push(target.clone());\n+        for target in config.host.iter().cloned()\n+            .chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n+        {\n+            if !config.target.contains(&target) {\n+                config.target.push(target);\n             }\n         }\n         config.nodejs = build.nodejs.map(PathBuf::from);\n@@ -404,7 +408,7 @@ impl Config {\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n \n-                config.target_config.insert(triple.clone(), target);\n+                config.target_config.insert(INTERNER.intern_string(triple.clone()), target);\n             }\n         }\n \n@@ -506,13 +510,13 @@ impl Config {\n             }\n \n             match key {\n-                \"CFG_BUILD\" if value.len() > 0 => self.build = value.to_string(),\n+                \"CFG_BUILD\" if value.len() > 0 => self.build = INTERNER.intern_str(value),\n                 \"CFG_HOST\" if value.len() > 0 => {\n-                    self.host.extend(value.split(\" \").map(|s| s.to_string()));\n+                    self.host.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n \n                 }\n                 \"CFG_TARGET\" if value.len() > 0 => {\n-                    self.target.extend(value.split(\" \").map(|s| s.to_string()));\n+                    self.target.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n                 }\n                 \"CFG_EXPERIMENTAL_TARGETS\" if value.len() > 0 => {\n                     self.llvm_experimental_targets = Some(value.to_string());\n@@ -521,33 +525,28 @@ impl Config {\n                     self.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_X86_64\" if value.len() > 0 => {\n-                    let target = \"x86_64-unknown-linux-musl\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"x86_64-unknown-linux-musl\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_I686\" if value.len() > 0 => {\n-                    let target = \"i686-unknown-linux-musl\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"i686-unknown-linux-musl\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARM\" if value.len() > 0 => {\n-                    let target = \"arm-unknown-linux-musleabi\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"arm-unknown-linux-musleabi\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARMHF\" if value.len() > 0 => {\n-                    let target = \"arm-unknown-linux-musleabihf\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"arm-unknown-linux-musleabihf\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_MUSL_ROOT_ARMV7\" if value.len() > 0 => {\n-                    let target = \"armv7-unknown-linux-musleabihf\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"armv7-unknown-linux-musleabihf\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.musl_root = Some(parse_configure_path(value));\n                 }\n                 \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n@@ -595,33 +594,28 @@ impl Config {\n                     target.jemalloc = Some(parse_configure_path(value).join(\"libjemalloc_pic.a\"));\n                 }\n                 \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n-                    let target = \"arm-linux-androideabi\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"arm-linux-androideabi\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_ARMV7_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n-                    let target = \"armv7-linux-androideabi\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"armv7-linux-androideabi\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"i686-linux-android\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"i686-linux-android\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"aarch64-linux-android\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"aarch64-linux-android\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_X86_64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n-                    let target = \"x86_64-linux-android\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"x86_64-linux-android\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.ndk = Some(parse_configure_path(value));\n                 }\n                 \"CFG_LOCAL_RUST_ROOT\" if value.len() > 0 => {\n@@ -645,9 +639,8 @@ impl Config {\n                                                .collect();\n                 }\n                 \"CFG_QEMU_ARMHF_ROOTFS\" if value.len() > 0 => {\n-                    let target = \"arm-unknown-linux-gnueabihf\".to_string();\n-                    let target = self.target_config.entry(target)\n-                                     .or_insert(Target::default());\n+                    let target = INTERNER.intern_str(\"arm-unknown-linux-gnueabihf\");\n+                    let target = self.target_config.entry(target).or_insert(Target::default());\n                     target.qemu_rootfs = Some(parse_configure_path(value));\n                 }\n                 _ => {}"}, {"sha": "e9a2fc7fc1a92f352218e3abf9481bc2700771a0", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 104, "deletions": 84, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -40,6 +40,7 @@ use util::{cp_r, libdir, is_dylib, cp_filtered, copy, exe};\n use builder::{Builder, Step};\n use compile;\n use tool::{self, Tool};\n+use cache::{INTERNER, Interned};\n \n pub fn pkgname(build: &Build, component: &str) -> String {\n     if component == \"cargo\" {\n@@ -71,14 +72,13 @@ fn rust_installer(builder: &Builder) -> Command {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::docs(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Docs<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Docs {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Docs<'a> {\n-    type Id = Docs<'static>;\n+impl Step for Docs {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -87,7 +87,9 @@ impl<'a> Step<'a> for Docs<'a> {\n         path.ends_with(\"src/doc\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, target: Interned<String>,\n+    ) {\n         builder.ensure(Docs {\n             stage: builder.top_stage,\n             target: target,\n@@ -165,7 +167,9 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n     found\n }\n \n-fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build: &Build) {\n+fn make_win_dist(\n+    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, build: &Build\n+) {\n     //Ask gcc where it keeps its stuff\n     let mut cmd = Command::new(build.cc(target_triple));\n     cmd.arg(\"-print-search-dirs\");\n@@ -282,13 +286,12 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n //          }\n //      });\n \n-#[derive(Serialize)]\n-pub struct Mingw<'a> {\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Mingw {\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Mingw<'a> {\n-    type Id = Mingw<'static>;\n+impl Step for Mingw {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -297,7 +300,9 @@ impl<'a> Step<'a> for Mingw<'a> {\n         false\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         builder.ensure(Mingw { target });\n     }\n \n@@ -350,14 +355,13 @@ impl<'a> Step<'a> for Mingw<'a> {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::rustc(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Rustc<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustc {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Rustc<'a> {\n-    type Id = Rustc<'static>;\n+impl Step for Rustc {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -367,7 +371,9 @@ impl<'a> Step<'a> for Rustc<'a> {\n         path.ends_with(\"src/librustc\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         builder.ensure(Rustc {\n             stage: builder.top_stage,\n             target: target,\n@@ -381,7 +387,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n         let target = self.target;\n \n         let compiler = builder.ensure(compile::Assemble {\n-            target_compiler: builder.compiler(stage, &build.build),\n+            target_compiler: builder.compiler(stage, build.build),\n         });\n \n         println!(\"Dist rustc stage{} ({})\", stage, target);\n@@ -444,10 +450,12 @@ impl<'a> Step<'a> for Rustc<'a> {\n \n         return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n \n-        fn prepare_image(builder: &Builder, compiler: Compiler, target: &str, image: &Path) {\n+        fn prepare_image(\n+            builder: &Builder, compiler: Compiler, target: Interned<String>, image: &Path\n+        ) {\n             let build = builder.build;\n             let src = builder.sysroot(compiler);\n-            let libdir = libdir(target);\n+            let libdir = libdir(&target);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n@@ -471,7 +479,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n \n             // Debugger scripts\n             builder.ensure(DebuggerScripts {\n-                sysroot: &image,\n+                sysroot: INTERNER.intern_path(image.to_owned()),\n                 target: target,\n             });\n \n@@ -491,23 +499,24 @@ impl<'a> Step<'a> for Rustc<'a> {\n //     .run(move |s| dist::debugger_scripts(build, &builder.sysroot(&s.compiler()),\n //                                     s.target));\n \n-#[derive(Serialize)]\n-pub struct DebuggerScripts<'a> {\n-    pub sysroot: &'a Path,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct DebuggerScripts {\n+    pub sysroot: Interned<PathBuf>,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for DebuggerScripts<'a> {\n-    type Id = DebuggerScripts<'static>;\n+impl Step for DebuggerScripts {\n     type Output = ();\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/etc/lldb_batchmode.py\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, host: Interned<String>, target: Interned<String>\n+    ) {\n         builder.ensure(DebuggerScripts {\n-            sysroot: &builder.sysroot(builder.compiler(builder.top_stage, host)),\n+            sysroot: builder.sysroot(builder.compiler(builder.top_stage, host)),\n             target: target,\n         });\n     }\n@@ -564,14 +573,13 @@ impl<'a> Step<'a> for DebuggerScripts<'a> {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::std(build, &s.compiler(), s.target));\n \n-#[derive(Serialize)]\n-pub struct Std<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Std {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Std<'a> {\n-    type Id = Std<'static>;\n+impl Step for Std {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -580,7 +588,9 @@ impl<'a> Step<'a> for Std<'a> {\n         path.ends_with(\"src/libstd\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, host: Interned<String>, target: Interned<String>\n+    ) {\n         builder.ensure(Std {\n             compiler: builder.compiler(builder.top_stage, host),\n             target: target,\n@@ -592,7 +602,7 @@ impl<'a> Step<'a> for Std<'a> {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, compiler.host,\n+        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host,\n                  target);\n \n         // The only true set of target libraries came from the build triple, so\n@@ -617,7 +627,7 @@ impl<'a> Step<'a> for Std<'a> {\n \n         let dst = image.join(\"lib/rustlib\").join(target);\n         t!(fs::create_dir_all(&dst));\n-        let mut src = builder.sysroot_libdir(compiler, target);\n+        let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n         cp_r(&src, &dst);\n \n@@ -645,14 +655,13 @@ impl<'a> Step<'a> for Std<'a> {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n \n-#[derive(Serialize)]\n-pub struct Analysis<'a> {\n-    pub compiler: Compiler<'a>,\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Analysis {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Analysis<'a> {\n-    type Id = Analysis<'static>;\n+impl Step for Analysis {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -661,7 +670,12 @@ impl<'a> Step<'a> for Analysis<'a> {\n         path.ends_with(\"analysis\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        path: Option<&Path>,\n+        host: Interned<String>,\n+        target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.extended {\n             return;\n         }\n@@ -679,7 +693,7 @@ impl<'a> Step<'a> for Analysis<'a> {\n         assert!(build.config.extended);\n         println!(\"Dist analysis\");\n \n-        if compiler.host != build.build {\n+        if &compiler.host != build.build {\n             println!(\"\\tskipping, not a build host\");\n             return None;\n         }\n@@ -769,11 +783,10 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |_| dist::rust_src(build));\n \n-#[derive(Serialize)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Src;\n \n-impl<'a> Step<'a> for Src {\n-    type Id = Src;\n+impl Step for Src {\n     /// The output path of the src installer tarball\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n@@ -785,7 +798,9 @@ impl<'a> Step<'a> for Src {\n         path.ends_with(\"src\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, _target: Interned<String>\n+    ) {\n         builder.ensure(Src);\n     }\n \n@@ -867,11 +882,10 @@ const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |_| dist::plain_source_tarball(build));\n \n-#[derive(Serialize)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n-impl<'a> Step<'a> for PlainSourceTarball {\n-    type Id = PlainSourceTarball;\n+impl Step for PlainSourceTarball {\n     /// Produces the location of the tarball generated\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n@@ -883,7 +897,9 @@ impl<'a> Step<'a> for PlainSourceTarball {\n         path.ends_with(\"src\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, _target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.rust_dist_src {\n             return;\n         }\n@@ -1019,14 +1035,13 @@ fn write_file(path: &Path, data: &[u8]) {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::cargo(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Cargo<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Cargo {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Cargo<'a> {\n-    type Id = Cargo<'static>;\n+impl Step for Cargo {\n     type Output = PathBuf;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -1035,7 +1050,9 @@ impl<'a> Step<'a> for Cargo<'a> {\n         path.ends_with(\"cargo\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         builder.ensure(Cargo {\n             stage: builder.top_stage,\n             target: target,\n@@ -1050,7 +1067,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n         builder.ensure(tool::Cargo { stage, target });\n \n         println!(\"Dist cargo stage{} ({})\", stage, target);\n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n \n         let src = build.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n@@ -1067,7 +1084,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n         t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n         t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n         let cargo = build.cargo_out(compiler, Mode::Tool, target)\n-                         .join(exe(\"cargo\", target));\n+                         .join(exe(\"cargo\", &target));\n         install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n@@ -1116,14 +1133,13 @@ impl<'a> Step<'a> for Cargo<'a> {\n //      .dep(|s| s.name(\"tool-rls\"))\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::rls(build, s.stage, s.target));\n-#[derive(Serialize)]\n-pub struct Rls<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rls {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Rls<'a> {\n-    type Id = Rls<'static>;\n+impl Step for Rls {\n     type Output = PathBuf;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -1132,7 +1148,9 @@ impl<'a> Step<'a> for Rls<'a> {\n         path.ends_with(\"rls\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         builder.ensure(Rls {\n             stage: builder.top_stage,\n             target: target,\n@@ -1148,7 +1166,7 @@ impl<'a> Step<'a> for Rls<'a> {\n         builder.ensure(tool::Rls { stage, target });\n \n         println!(\"Dist RLS stage{} ({})\", stage, target);\n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n \n         let src = build.src.join(\"src/tools/rls\");\n         let release_num = build.release_num(\"rls\");\n@@ -1162,7 +1180,7 @@ impl<'a> Step<'a> for Rls<'a> {\n \n         // Prepare the image directory\n         let rls = build.cargo_out(compiler, Mode::Tool, target)\n-                         .join(exe(\"rls\", target));\n+                         .join(exe(\"rls\", &target));\n         install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n         install(&src.join(\"README.md\"), &doc, 0o644);\n@@ -1210,14 +1228,13 @@ impl<'a> Step<'a> for Rls<'a> {\n //      .dep(move |s| tool_rust_installer(build, s))\n //      .run(move |s| dist::extended(build, s.stage, s.target));\n \n-#[derive(Serialize)]\n-pub struct Extended<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Extended {\n     stage: u32,\n-    target: &'a str,\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Extended<'a> {\n-    type Id = Extended<'static>;\n+impl Step for Extended {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -1227,7 +1244,9 @@ impl<'a> Step<'a> for Extended<'a> {\n         path.ends_with(\"cargo\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.extended {\n             return;\n         }\n@@ -1242,7 +1261,7 @@ impl<'a> Step<'a> for Extended<'a> {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n \n         println!(\"Dist extended stage{} ({})\", stage, target);\n \n@@ -1583,7 +1602,7 @@ impl<'a> Step<'a> for Extended<'a> {\n     }\n }\n \n-fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n+fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n     cmd.env(\"CFG_RELEASE_INFO\", build.rust_version())\n        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n@@ -1620,11 +1639,10 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n //      .dep(move |s| s.name(\"tool-build-manifest\").target(&build.build).stage(0))\n //      .run(move |_| dist::hash_and_sign(build));\n \n-#[derive(Serialize)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct HashSign;\n \n-impl<'a> Step<'a> for HashSign {\n-    type Id = HashSign;\n+impl Step for HashSign {\n     type Output = ();\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -1634,7 +1652,9 @@ impl<'a> Step<'a> for HashSign {\n         path.ends_with(\"hash-and-sign\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, _target: &str) {\n+    fn make_run(\n+        builder: &Builder, _path: Option<&Path>, _host: Interned<String>, _target: Interned<String>\n+    ) {\n         builder.ensure(HashSign);\n     }\n "}, {"sha": "3c3f4bf2be73fa1bcfd1cb7c68754707d539dd15", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 95, "deletions": 84, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -20,35 +20,40 @@\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n-use std::path::Path;\n+use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use Mode;\n-use util::{cp_r, symlink_dir};\n use build_helper::up_to_date;\n \n+use util::{cp_r, symlink_dir};\n use builder::{Builder, Step};\n use tool::Tool;\n use compile;\n+use cache::{INTERNER, Interned};\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n         $(\n-        #[derive(Serialize)]\n-        pub struct $name<'a> {\n-            target: &'a str,\n+            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $name {\n+            target: Interned<String>,\n         }\n \n-        impl<'a> Step<'a> for $name<'a> {\n-            type Id = $name<'static>;\n+        impl Step for $name {\n             type Output = ();\n             const DEFAULT: bool = true;\n \n             fn should_run(_builder: &Builder, path: &Path) -> bool {\n                 path.ends_with($path)\n             }\n \n-            fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+            fn make_run(\n+                builder: &Builder,\n+                path: Option<&Path>,\n+                _host: Interned<String>,\n+                target: Interned<String>\n+            ) {\n                 if path.is_none() && !builder.build.config.docs {\n                     // Not a default rule if docs are disabled.\n                     return;\n@@ -62,7 +67,7 @@ macro_rules! book {\n             fn run(self, builder: &Builder) {\n                 builder.ensure(Rustbook {\n                     target: self.target,\n-                    name: $book_name,\n+                    name: INTERNER.intern_str($book_name),\n                 })\n             }\n         }\n@@ -93,14 +98,13 @@ book!(\n     Reference, \"src/doc/reference\", \"reference\";\n );\n \n-#[derive(Serialize)]\n-pub struct Rustbook<'a> {\n-    target: &'a str,\n-    name: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustbook {\n+    target: Interned<String>,\n+    name: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Rustbook<'a> {\n-    type Id = Rustbook<'static>;\n+impl Step for Rustbook {\n     type Output = ();\n \n     /// Invoke `rustbook` for `target` for the doc book `name`.\n@@ -112,7 +116,7 @@ impl<'a> Step<'a> for Rustbook<'a> {\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: self.name,\n-            src: &src,\n+            src: INTERNER.intern_path(src),\n         });\n     }\n }\n@@ -130,21 +134,22 @@ impl<'a> Step<'a> for Rustbook<'a> {\n //                                     s.target,\n //                                     \"unstable-book\",\n //                                     &build.md_doc_out(s.target)));\n-#[derive(Serialize)]\n-pub struct UnstableBook<'a> {\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct UnstableBook {\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for UnstableBook<'a> {\n-    type Id = UnstableBook<'static>;\n+impl Step for UnstableBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/doc/unstable-book\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.docs {\n             // Not a default rule if docs are disabled.\n             return;\n@@ -161,21 +166,20 @@ impl<'a> Step<'a> for UnstableBook<'a> {\n         });\n         builder.ensure(RustbookSrc {\n             target: self.target,\n-            name: \"unstable-book\",\n-            src: &builder.build.md_doc_out(self.target),\n+            name: INTERNER.intern_str(\"unstable-book\"),\n+            src: builder.build.md_doc_out(self.target),\n         })\n     }\n }\n \n-#[derive(Serialize)]\n-pub struct RustbookSrc<'a> {\n-    target: &'a str,\n-    name: &'a str,\n-    src: &'a Path,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustbookSrc {\n+    target: Interned<String>,\n+    name: Interned<String>,\n+    src: Interned<PathBuf>,\n }\n \n-impl<'a> Step<'a> for RustbookSrc<'a> {\n-    type Id = UnstableBook<'static>;\n+impl Step for RustbookSrc {\n     type Output = ();\n \n     /// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n@@ -217,21 +221,22 @@ impl<'a> Step<'a> for RustbookSrc<'a> {\n //      .default(build.config.docs)\n //      .run(move |s| doc::book(build, s.target, \"book\"));\n \n-#[derive(Serialize)]\n-pub struct TheBook<'a> {\n-    target: &'a str,\n-    name: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct TheBook {\n+    target: Interned<String>,\n+    name: &'static str,\n }\n \n-impl<'a> Step<'a> for TheBook<'a> {\n-    type Id = TheBook<'static>;\n+impl Step for TheBook {\n     type Output = ();\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/doc/book\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.docs {\n             // Not a default rule if docs are disabled.\n             return;\n@@ -258,13 +263,13 @@ impl<'a> Step<'a> for TheBook<'a> {\n         // build book first edition\n         builder.ensure(Rustbook {\n             target: target,\n-            name: &format!(\"{}/first-edition\", name),\n+            name: INTERNER.intern_string(format!(\"{}/first-edition\", name)),\n         });\n \n         // build book second edition\n         builder.ensure(Rustbook {\n             target: target,\n-            name: &format!(\"{}/second-edition\", name),\n+            name: INTERNER.intern_string(format!(\"{}/second-edition\", name)),\n         });\n \n         // build the index page\n@@ -284,11 +289,11 @@ impl<'a> Step<'a> for TheBook<'a> {\n     }\n }\n \n-fn invoke_rustdoc(builder: &Builder, target: &str, markdown: &str) {\n+fn invoke_rustdoc(builder: &Builder, target: Interned<String>, markdown: &str) {\n     let build = builder.build;\n     let out = build.doc_out(target);\n \n-    let compiler = builder.compiler(0, &build.build);\n+    let compiler = builder.compiler(0, build.build);\n \n     let path = build.src.join(\"src/doc\").join(markdown);\n \n@@ -340,21 +345,22 @@ fn invoke_rustdoc(builder: &Builder, target: &str, markdown: &str) {\n //      .default(build.config.docs)\n //      .run(move |s| doc::standalone(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct Standalone<'a> {\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Standalone {\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Standalone<'a> {\n-    type Id = Standalone<'static>;\n+impl Step for Standalone {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/doc\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.docs {\n             // Not a default rule if docs are disabled.\n             return;\n@@ -380,7 +386,7 @@ impl<'a> Step<'a> for Standalone<'a> {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        let compiler = builder.compiler(0, &build.build);\n+        let compiler = builder.compiler(0, build.build);\n \n         let favicon = build.src.join(\"src/doc/favicon.inc\");\n         let footer = build.src.join(\"src/doc/footer.inc\");\n@@ -447,14 +453,13 @@ impl<'a> Step<'a> for Standalone<'a> {\n //          .run(move |s| doc::std(build, s.stage, s.target));\n // }\n \n-#[derive(Serialize)]\n-pub struct Std<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Std {\n     stage: u32,\n-    target: &'a str,\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Std<'a> {\n-    type Id = Std<'static>;\n+impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n@@ -464,7 +469,9 @@ impl<'a> Step<'a> for Std<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         let run = || {\n             builder.ensure(Std {\n                 stage: builder.top_stage,\n@@ -496,7 +503,7 @@ impl<'a> Step<'a> for Std<'a> {\n         println!(\"Documenting stage{} std ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -559,14 +566,13 @@ impl<'a> Step<'a> for Std<'a> {\n //          .run(move |s| doc::test(build, s.stage, s.target));\n // }\n \n-#[derive(Serialize)]\n-pub struct Test<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Test {\n     stage: u32,\n-    target: &'a str,\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Test<'a> {\n-    type Id = Test<'static>;\n+impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n@@ -576,7 +582,9 @@ impl<'a> Step<'a> for Test<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         let run = || {\n             builder.ensure(Test {\n                 stage: builder.top_stage,\n@@ -608,7 +616,7 @@ impl<'a> Step<'a> for Test<'a> {\n         println!(\"Documenting stage{} test ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -647,14 +655,13 @@ impl<'a> Step<'a> for Test<'a> {\n // }\n //\n \n-#[derive(Serialize)]\n-pub struct Rustc<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustc {\n     stage: u32,\n-    target: &'a str,\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Rustc<'a> {\n-    type Id = Rustc<'static>;\n+impl Step for Rustc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -665,7 +672,9 @@ impl<'a> Step<'a> for Rustc<'a> {\n         })\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         let run = || {\n             builder.ensure(Rustc {\n                 stage: builder.top_stage,\n@@ -697,7 +706,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n         println!(\"Documenting stage{} compiler ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -749,13 +758,12 @@ impl<'a> Step<'a> for Rustc<'a> {\n //      .host(true)\n //      .run(move |s| doc::error_index(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct ErrorIndex<'a> {\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct ErrorIndex {\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for ErrorIndex<'a> {\n-    type Id = ErrorIndex<'static>;\n+impl Step for ErrorIndex {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -764,7 +772,9 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         path.ends_with(\"src/tools/error_index_generator\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.docs {\n             // Not a default rule if docs are disabled.\n             return;\n@@ -782,7 +792,7 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n         let target = self.target;\n \n         builder.ensure(compile::Rustc {\n-            compiler: builder.compiler(0, &build.build),\n+            compiler: builder.compiler(0, build.build),\n             target,\n         });\n \n@@ -812,13 +822,12 @@ impl<'a> Step<'a> for ErrorIndex<'a> {\n //      .host(true)\n //      .run(move |s| doc::unstable_book_gen(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct UnstableBookGen<'a> {\n-    target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct UnstableBookGen {\n+    target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for UnstableBookGen<'a> {\n-    type Id = UnstableBookGen<'static>;\n+impl Step for UnstableBookGen {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -827,7 +836,9 @@ impl<'a> Step<'a> for UnstableBookGen<'a> {\n         path.ends_with(\"src/doc/unstable-book\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>,\n+    ) {\n         if path.is_none() && !builder.build.config.docs {\n             // Not a default rule if docs are disabled.\n             return;\n@@ -843,7 +854,7 @@ impl<'a> Step<'a> for UnstableBookGen<'a> {\n         let target = self.target;\n \n         builder.ensure(compile::Std {\n-            compiler: builder.compiler(builder.top_stage, &build.build),\n+            compiler: builder.compiler(builder.top_stage, build.build),\n             target,\n         });\n "}, {"sha": "b1ea441795e77d8718cf5f6175dee0e8f9ce4a95", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -24,15 +24,17 @@ use Build;\n use config::Config;\n use metadata;\n \n+use cache::{Interned, INTERNER};\n+\n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n     pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n-    pub build: String,\n-    pub host: Vec<String>,\n-    pub target: Vec<String>,\n+    pub build: Interned<String>,\n+    pub host: Vec<Interned<String>>,\n+    pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n     pub src: PathBuf,\n     pub jobs: Option<u32>,\n@@ -320,11 +322,13 @@ Arguments:\n             stage: stage,\n             on_fail: matches.opt_str(\"on-fail\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: matches.opt_str(\"build\").unwrap_or_else(|| {\n+            build: INTERNER.intern_string(matches.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()\n-            }),\n-            host: split(matches.opt_strs(\"host\")),\n-            target: split(matches.opt_strs(\"target\")),\n+            })),\n+            host: split(matches.opt_strs(\"host\"))\n+                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+            target: split(matches.opt_strs(\"target\"))\n+                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             config: cfg_file,\n             src: src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),"}, {"sha": "6b6160f43caf3a1e15eab188e6e121ab299cc12c", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -21,37 +21,44 @@ use std::process::Command;\n use dist::{self, pkgname, sanitize_sh, tmpdir};\n \n use builder::{Builder, Step};\n+use cache::Interned;\n \n-pub fn install_docs(builder: &Builder, stage: u32, host: &str) {\n+pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n }\n \n pub fn install_std(builder: &Builder, stage: u32) {\n     for target in builder.build.config.target.iter() {\n-        install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n+        install_sh(builder, \"std\", \"rust-std\", stage, Some(*target));\n     }\n }\n \n-pub fn install_cargo(builder: &Builder, stage: u32, host: &str) {\n+pub fn install_cargo(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n }\n \n-pub fn install_rls(builder: &Builder, stage: u32, host: &str) {\n+pub fn install_rls(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n \n-pub fn install_analysis(builder: &Builder, stage: u32, host: &str) {\n+pub fn install_analysis(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n }\n \n pub fn install_src(builder: &Builder, stage: u32) {\n     install_sh(builder, \"src\", \"rust-src\", stage, None);\n }\n-pub fn install_rustc(builder: &Builder, stage: u32, host: &str) {\n+pub fn install_rustc(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n }\n \n-fn install_sh(builder: &Builder, package: &str, name: &str, stage: u32, host: Option<&str>) {\n+fn install_sh(\n+    builder: &Builder,\n+    package: &str,\n+    name: &str,\n+    stage: u32,\n+    host: Option<Interned<String>>\n+) {\n     let build = builder.build;\n     println!(\"Install {} stage{} ({:?})\", package, stage, host);\n \n@@ -127,15 +134,15 @@ macro_rules! install {\n        $default_cond:expr,\n        only_hosts: $only_hosts:expr,\n        $run_item:block $(, $c:ident)*;)+) => {\n-        $(#[derive(Serialize)]\n-        pub struct $name<'a> {\n+        $(\n+            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $name {\n             pub stage: u32,\n-            pub target: &'a str,\n-            pub host: &'a str,\n+            pub target: Interned<String>,\n+            pub host: Interned<String>,\n         }\n \n-        impl<'a> Step<'a> for $name<'a> {\n-            type Id = $name<'static>;\n+        impl Step for $name {\n             type Output = ();\n             const DEFAULT: bool = true;\n             const ONLY_BUILD_TARGETS: bool = true;\n@@ -146,7 +153,12 @@ macro_rules! install {\n                 path.ends_with($path)\n             }\n \n-            fn make_run($builder: &Builder, path: Option<&Path>, host: &str, target: &str) {\n+            fn make_run(\n+                $builder: &Builder,\n+                path: Option<&Path>,\n+                host: Interned<String>,\n+                target: Interned<String>,\n+            ) {\n                 if path.is_none() && !($default_cond) {\n                     return;\n                 }"}, {"sha": "472aea783f2d1821e678397a7de481ca7742e938", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -121,6 +121,8 @@\n extern crate build_helper;\n #[macro_use]\n extern crate serde_derive;\n+#[macro_use]\n+extern crate lazy_static;\n extern crate serde;\n extern crate serde_json;\n extern crate cmake;\n@@ -186,16 +188,17 @@ mod job {\n \n pub use config::Config;\n pub use flags::{Flags, Subcommand};\n+use cache::{Interned, INTERNER};\n \n /// A structure representing a Rust compiler.\n ///\n /// Each compiler has a `stage` that it is associated with and a `host` that\n /// corresponds to the platform the compiler runs on. This structure is used as\n /// a parameter to many methods below.\n-#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Copy, Hash, Debug)]\n-pub struct Compiler<'a> {\n+#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+pub struct Compiler {\n     stage: u32,\n-    host: &'a str,\n+    host: Interned<String>,\n }\n \n /// Global configuration for the build system.\n@@ -226,9 +229,9 @@ pub struct Build {\n     verbosity: usize,\n \n     // Targets for which to build.\n-    build: String,\n-    hosts: Vec<String>,\n-    targets: Vec<String>,\n+    build: Interned<String>,\n+    hosts: Vec<Interned<String>>,\n+    targets: Vec<Interned<String>>,\n \n     // Stage 0 (downloaded) compiler and cargo or their local rust equivalents.\n     initial_rustc: PathBuf,\n@@ -240,20 +243,20 @@ pub struct Build {\n \n     // Runtime state filled in later on\n     // target -> (cc, ar)\n-    cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n+    cc: HashMap<Interned<String>, (gcc::Tool, Option<PathBuf>)>,\n     // host -> (cc, ar)\n-    cxx: HashMap<String, gcc::Tool>,\n-    crates: HashMap<String, Crate>,\n+    cxx: HashMap<Interned<String>, gcc::Tool>,\n+    crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n     delayed_failures: Cell<usize>,\n }\n \n #[derive(Debug)]\n struct Crate {\n-    name: String,\n+    name: Interned<String>,\n     version: String,\n-    deps: Vec<String>,\n+    deps: Vec<Interned<String>>,\n     path: PathBuf,\n     doc_step: String,\n     build_step: String,\n@@ -265,7 +268,7 @@ struct Crate {\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n-#[derive(Serialize, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Hash, Clone, Copy, PartialEq, Eq)]\n pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Libstd,\n@@ -438,7 +441,7 @@ impl Build {\n     /// Get the directory for incremental by-products when using the\n     /// given compiler.\n     fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n-        self.out.join(compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n+        self.out.join(&*compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n     }\n \n     /// Returns the root directory for all output generated in a particular\n@@ -452,7 +455,7 @@ impl Build {\n             Mode::Tool => \"-tools\",\n             Mode::Librustc => \"-rustc\",\n         };\n-        self.out.join(compiler.host)\n+        self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))\n     }\n \n@@ -462,40 +465,40 @@ impl Build {\n     fn cargo_out(&self,\n                  compiler: Compiler,\n                  mode: Mode,\n-                 target: &str) -> PathBuf {\n-        self.stage_out(compiler, mode).join(target).join(self.cargo_dir())\n+                 target: Interned<String>) -> PathBuf {\n+        self.stage_out(compiler, mode).join(&*target).join(self.cargo_dir())\n     }\n \n     /// Root output directory for LLVM compiled for `target`\n     ///\n     /// Note that if LLVM is configured externally then the directory returned\n     /// will likely be empty.\n-    fn llvm_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"llvm\")\n+    fn llvm_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"llvm\")\n     }\n \n     /// Output directory for all documentation for a target\n-    fn doc_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"doc\")\n+    fn doc_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"doc\")\n     }\n \n     /// Output directory for some generated md crate documentation for a target (temporary)\n-    fn md_doc_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"md-doc\")\n+    fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n+        INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))\n     }\n \n     /// Output directory for all crate documentation for a target (temporary)\n     ///\n     /// The artifacts here are then copied into `doc_out` above.\n-    fn crate_doc_out(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"crate-docs\")\n+    fn crate_doc_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"crate-docs\")\n     }\n \n     /// Returns true if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n-    fn is_rust_llvm(&self, target: &str) -> bool {\n-        match self.config.target_config.get(target) {\n+    fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n+        match self.config.target_config.get(&target) {\n             Some(ref c) => c.llvm_config.is_none(),\n             None => true\n         }\n@@ -505,25 +508,25 @@ impl Build {\n     ///\n     /// If a custom `llvm-config` was specified for target then that's returned\n     /// instead.\n-    fn llvm_config(&self, target: &str) -> PathBuf {\n-        let target_config = self.config.target_config.get(target);\n+    fn llvm_config(&self, target: Interned<String>) -> PathBuf {\n+        let target_config = self.config.target_config.get(&target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             s.clone()\n         } else {\n-            self.llvm_out(&self.config.build).join(\"bin\")\n-                .join(exe(\"llvm-config\", target))\n+            self.llvm_out(self.config.build).join(\"bin\")\n+                .join(exe(\"llvm-config\", &*target))\n         }\n     }\n \n     /// Returns the path to `FileCheck` binary for the specified target\n-    fn llvm_filecheck(&self, target: &str) -> PathBuf {\n-        let target_config = self.config.target_config.get(target);\n+    fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {\n+        let target_config = self.config.target_config.get(&target);\n         if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             let llvm_bindir = output(Command::new(s).arg(\"--bindir\"));\n-            Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", target))\n+            Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target))\n         } else {\n-            let base = self.llvm_out(&self.config.build).join(\"build\");\n-            let exe = exe(\"FileCheck\", target);\n+            let base = self.llvm_out(self.config.build).join(\"build\");\n+            let exe = exe(\"FileCheck\", &*target);\n             if !self.config.ninja && self.config.build.contains(\"msvc\") {\n                 base.join(\"Release/bin\").join(exe)\n             } else {\n@@ -533,13 +536,13 @@ impl Build {\n     }\n \n     /// Directory for libraries built from C/C++ code and shared between stages.\n-    fn native_dir(&self, target: &str) -> PathBuf {\n-        self.out.join(target).join(\"native\")\n+    fn native_dir(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"native\")\n     }\n \n     /// Root output directory for rust_test_helpers library compiled for\n     /// `target`\n-    fn test_helpers_out(&self, target: &str) -> PathBuf {\n+    fn test_helpers_out(&self, target: Interned<String>) -> PathBuf {\n         self.native_dir(target).join(\"rust-test-helpers\")\n     }\n \n@@ -606,16 +609,16 @@ impl Build {\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n-    fn cc(&self, target: &str) -> &Path {\n-        self.cc[target].0.path()\n+    fn cc(&self, target: Interned<String>) -> &Path {\n+        self.cc[&target].0.path()\n     }\n \n     /// Returns a list of flags to pass to the C compiler for the target\n     /// specified.\n-    fn cflags(&self, target: &str) -> Vec<String> {\n+    fn cflags(&self, target: Interned<String>) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n         // gcc-rs because the build scripts will determine that for themselves.\n-        let mut base = self.cc[target].0.args().iter()\n+        let mut base = self.cc[&target].0.args().iter()\n                            .map(|s| s.to_string_lossy().into_owned())\n                            .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))\n                            .collect::<Vec<_>>();\n@@ -631,20 +634,20 @@ impl Build {\n         // Work around an apparently bad MinGW / GCC optimization,\n         // See: http://lists.llvm.org/pipermail/cfe-dev/2016-December/051980.html\n         // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78936\n-        if target == \"i686-pc-windows-gnu\" {\n+        if &*target == \"i686-pc-windows-gnu\" {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n         base\n     }\n \n     /// Returns the path to the `ar` archive utility for the target specified.\n-    fn ar(&self, target: &str) -> Option<&Path> {\n-        self.cc[target].1.as_ref().map(|p| &**p)\n+    fn ar(&self, target: Interned<String>) -> Option<&Path> {\n+        self.cc[&target].1.as_ref().map(|p| &**p)\n     }\n \n     /// Returns the path to the C++ compiler for the target specified.\n-    fn cxx(&self, target: &str) -> Result<&Path, String> {\n-        match self.cxx.get(target) {\n+    fn cxx(&self, target: Interned<String>) -> Result<&Path, String> {\n+        match self.cxx.get(&target) {\n             Some(p) => Ok(p.path()),\n             None => Err(format!(\n                     \"target `{}` is not configured as a host, only as a target\",\n@@ -653,7 +656,7 @@ impl Build {\n     }\n \n     /// Returns flags to pass to the compiler to generate code for `target`.\n-    fn rustc_flags(&self, target: &str) -> Vec<String> {\n+    fn rustc_flags(&self, target: Interned<String>) -> Vec<String> {\n         // New flags should be added here with great caution!\n         //\n         // It's quite unfortunate to **require** flags to generate code for a\n@@ -670,16 +673,16 @@ impl Build {\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n-    fn musl_root(&self, target: &str) -> Option<&Path> {\n-        self.config.target_config.get(target)\n+    fn musl_root(&self, target: Interned<String>) -> Option<&Path> {\n+        self.config.target_config.get(&target)\n             .and_then(|t| t.musl_root.as_ref())\n             .or(self.config.musl_root.as_ref())\n             .map(|p| &**p)\n     }\n \n     /// Returns whether the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n-    fn remote_tested(&self, target: &str) -> bool {\n+    fn remote_tested(&self, target: Interned<String>) -> bool {\n         self.qemu_rootfs(target).is_some() || target.contains(\"android\") ||\n         env::var_os(\"TEST_DEVICE_ADDR\").is_some()\n     }\n@@ -689,8 +692,8 @@ impl Build {\n     ///\n     /// If `Some` is returned then that means that tests for this target are\n     /// emulated with QEMU and binaries will need to be shipped to the emulator.\n-    fn qemu_rootfs(&self, target: &str) -> Option<&Path> {\n-        self.config.target_config.get(target)\n+    fn qemu_rootfs(&self, target: Interned<String>) -> Option<&Path> {\n+        self.config.target_config.get(&target)\n             .and_then(|t| t.qemu_rootfs.as_ref())\n             .map(|p| &**p)\n     }\n@@ -718,28 +721,28 @@ impl Build {\n     ///\n     /// When all of these conditions are met the build will lift artifacts from\n     /// the previous stage forward.\n-    fn force_use_stage1(&self, compiler: Compiler, target: &str) -> bool {\n+    fn force_use_stage1(&self, compiler: Compiler, target: Interned<String>) -> bool {\n         !self.config.full_bootstrap &&\n             compiler.stage >= 2 &&\n-            self.config.host.iter().any(|h| h == target)\n+            self.config.host.iter().any(|h| *h == target)\n     }\n \n     /// Returns the directory that OpenSSL artifacts are compiled into if\n     /// configured to do so.\n-    fn openssl_dir(&self, target: &str) -> Option<PathBuf> {\n+    fn openssl_dir(&self, target: Interned<String>) -> Option<PathBuf> {\n         // OpenSSL not used on Windows\n         if target.contains(\"windows\") {\n             None\n         } else if self.config.openssl_static {\n-            Some(self.out.join(target).join(\"openssl\"))\n+            Some(self.out.join(&*target).join(\"openssl\"))\n         } else {\n             None\n         }\n     }\n \n     /// Returns the directory that OpenSSL artifacts are installed into if\n     /// configured as such.\n-    fn openssl_install_dir(&self, target: &str) -> Option<PathBuf> {\n+    fn openssl_install_dir(&self, target: Interned<String>) -> Option<PathBuf> {\n         self.openssl_dir(target).map(|p| p.join(\"install\"))\n     }\n \n@@ -842,27 +845,28 @@ impl Build {\n     /// Get a list of crates from a root crate.\n     ///\n     /// Returns Vec<(crate, path to crate, is_root_crate)>\n-    fn crates(&self, root: &str) -> Vec<(&str, &Path)> {\n+    fn crates(&self, root: &str) -> Vec<(Interned<String>, &Path)> {\n+        let interned = INTERNER.intern_string(root.to_owned());\n         let mut ret = Vec::new();\n-        let mut list = vec![root];\n+        let mut list = vec![interned];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n-            let krate = &self.crates[krate];\n+            let krate = &self.crates[&krate];\n             // If we can't strip prefix, then out-of-tree path\n             let path = krate.path.strip_prefix(&self.src).unwrap_or(&krate.path);\n-            ret.push((&*krate.name, path));\n+            ret.push((krate.name, path));\n             for dep in &krate.deps {\n                 if visited.insert(dep) && dep != \"build_helper\" {\n-                    list.push(dep);\n+                    list.push(*dep);\n                 }\n             }\n         }\n         ret\n     }\n }\n \n-impl<'a> Compiler<'a> {\n-    pub fn with_stage(mut self, stage: u32) -> Compiler<'a> {\n+impl<'a> Compiler {\n+    pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;\n         self\n     }"}, {"sha": "2b641cd8484bbd115c5802a45bd9a3cf1485cf65", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -16,6 +16,7 @@ use build_helper::output;\n use serde_json;\n \n use {Build, Crate};\n+use cache::Interned;\n \n #[derive(Deserialize)]\n struct Output {\n@@ -26,7 +27,7 @@ struct Output {\n #[derive(Deserialize)]\n struct Package {\n     id: String,\n-    name: String,\n+    name: Interned<String>,\n     version: String,\n     source: Option<String>,\n     manifest_path: String,\n@@ -65,10 +66,10 @@ fn build_krate(build: &mut Build, krate: &str) {\n     let mut id2name = HashMap::new();\n     for package in output.packages {\n         if package.source.is_none() {\n-            id2name.insert(package.id, package.name.clone());\n+            id2name.insert(package.id, package.name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n-            build.crates.insert(package.name.clone(), Crate {\n+            build.crates.insert(package.name, Crate {\n                 build_step: format!(\"build-crate-{}\", package.name),\n                 doc_step: format!(\"doc-crate-{}\", package.name),\n                 test_step: format!(\"test-crate-{}\", package.name),\n@@ -93,7 +94,7 @@ fn build_krate(build: &mut Build, krate: &str) {\n                 Some(dep) => dep,\n                 None => continue,\n             };\n-            krate.deps.push(dep.clone());\n+            krate.deps.push(*dep);\n         }\n     }\n }"}, {"sha": "c0ec693a17e6e5a0e3ed799bba93b860195e2502", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -33,6 +33,7 @@ use Build;\n use util;\n use build_helper::up_to_date;\n use builder::{Builder, Step};\n+use cache::Interned;\n \n // rules.build(\"llvm\", \"src/llvm\")\n //      .host(true)\n@@ -45,13 +46,12 @@ use builder::{Builder, Step};\n //      })\n //      .run(move |s| native::llvm(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct Llvm<'a> {\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Llvm {\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Llvm<'a> {\n-    type Id = Llvm<'static>;\n+impl Step for Llvm {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n@@ -61,7 +61,7 @@ impl<'a> Step<'a> for Llvm<'a> {\n         let target = self.target;\n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n-        if let Some(config) = build.config.target_config.get(target) {\n+        if let Some(config) = build.config.target_config.get(&target) {\n             if let Some(ref s) = config.llvm_config {\n                 return check_llvm_version(build, s);\n             }\n@@ -117,7 +117,7 @@ impl<'a> Step<'a> for Llvm<'a> {\n \n         let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n-        cfg.target(target)\n+        cfg.target(&target)\n            .host(&build.build)\n            .out_dir(&out_dir)\n            .profile(profile)\n@@ -154,11 +154,11 @@ impl<'a> Step<'a> for Llvm<'a> {\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n         if target != build.build {\n-            builder.ensure(Llvm { target: &build.build });\n+            builder.ensure(Llvm { target: build.build });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n             //        actually exists most of the time in normal installs of LLVM.\n-            let host = build.llvm_out(&build.build).join(\"bin/llvm-tblgen\");\n+            let host = build.llvm_out(build.build).join(\"bin/llvm-tblgen\");\n             cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n                .define(\"LLVM_TABLEGEN\", &host);\n         }\n@@ -245,20 +245,24 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n //rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n //     .run(move |s| native::test_helpers(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct TestHelpers<'a> {\n-    pub target: &'a str,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct TestHelpers {\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for TestHelpers<'a> {\n-    type Id = TestHelpers<'static>;\n+impl Step for TestHelpers {\n     type Output = ();\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/rt/rust_test_helpers.c\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        _host: Interned<String>,\n+        target: Interned<String>,\n+    ) {\n         builder.ensure(TestHelpers { target })\n     }\n \n@@ -290,7 +294,7 @@ impl<'a> Step<'a> for TestHelpers<'a> {\n \n         cfg.cargo_metadata(false)\n            .out_dir(&dst)\n-           .target(target)\n+           .target(&target)\n            .host(&build.build)\n            .opt_level(0)\n            .debug(false)\n@@ -306,13 +310,12 @@ const OPENSSL_SHA256: &'static str =\n //rules.build(\"openssl\", \"path/to/nowhere\")\n //     .run(move |s| native::openssl(build, s.target));\n \n-#[derive(Serialize)]\n-pub struct Openssl<'a> {\n-    pub target: &'a str,\n+    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Openssl {\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Openssl<'a> {\n-    type Id = Openssl<'static>;\n+impl Step for Openssl {\n     type Output = ();\n \n     fn should_run(_builder: &Builder, _path: &Path) -> bool {\n@@ -385,7 +388,7 @@ impl<'a> Step<'a> for Openssl<'a> {\n         configure.arg(\"no-ssl2\");\n         configure.arg(\"no-ssl3\");\n \n-        let os = match target {\n+        let os = match &*target {\n             \"aarch64-linux-android\" => \"linux-aarch64\",\n             \"aarch64-unknown-linux-gnu\" => \"linux-aarch64\",\n             \"arm-linux-androideabi\" => \"android\","}, {"sha": "7063b28f19d012343e32813d7f4d208aab0c90a1", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -122,14 +122,14 @@ pub fn check(build: &mut Build) {\n             continue;\n         }\n \n-        cmd_finder.must_have(build.cc(target));\n-        if let Some(ar) = build.ar(target) {\n+        cmd_finder.must_have(build.cc(*target));\n+        if let Some(ar) = build.ar(*target) {\n             cmd_finder.must_have(ar);\n         }\n     }\n \n     for host in build.config.host.iter() {\n-        cmd_finder.must_have(build.cxx(host).unwrap());\n+        cmd_finder.must_have(build.cxx(*host).unwrap());\n \n         // The msvc hosts don't use jemalloc, turn it off globally to\n         // avoid packaging the dummy liballoc_jemalloc on that platform.\n@@ -139,7 +139,7 @@ pub fn check(build: &mut Build) {\n     }\n \n     // Externally configured LLVM requires FileCheck to exist\n-    let filecheck = build.llvm_filecheck(&build.build);\n+    let filecheck = build.llvm_filecheck(build.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n         panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n@@ -153,7 +153,7 @@ pub fn check(build: &mut Build) {\n \n         // Make sure musl-root is valid if specified\n         if target.contains(\"musl\") && !target.contains(\"mips\") {\n-            match build.musl_root(target) {\n+            match build.musl_root(*target) {\n                 Some(root) => {\n                     if fs::metadata(root.join(\"lib/libc.a\")).is_err() {\n                         panic!(\"couldn't find libc.a in musl dir: {}\","}, {"sha": "00616caf1206ed7fe2a6bc582a9f5d27b405eb84", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 58, "deletions": 49, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/528646e1275a90900179b473b204ca3ce19984b5/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=528646e1275a90900179b473b204ca3ce19984b5", "patch": "@@ -19,6 +19,7 @@ use util::{exe, add_lib_path};\n use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp, Rustc};\n use native;\n use channel::GitInfo;\n+use cache::Interned;\n \n //// ========================================================================\n //// Build tools\n@@ -44,15 +45,14 @@ use channel::GitInfo;\n //     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libstd));\n //\n \n-#[derive(Serialize)]\n-pub struct CleanTools<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CleanTools {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n     pub mode: Mode,\n }\n \n-impl<'a> Step<'a> for CleanTools<'a> {\n-    type Id = CleanTools<'static>;\n+impl Step for CleanTools {\n     type Output = ();\n \n     /// Build a tool in `src/tools`\n@@ -65,7 +65,7 @@ impl<'a> Step<'a> for CleanTools<'a> {\n         let target = self.target;\n         let mode = self.mode;\n \n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n \n         let stamp = match mode {\n             Mode::Libstd => libstd_stamp(build, compiler, target),\n@@ -78,16 +78,15 @@ impl<'a> Step<'a> for CleanTools<'a> {\n     }\n }\n \n-#[derive(Serialize)]\n-pub struct ToolBuild<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct ToolBuild {\n     pub stage: u32,\n-    pub target: &'a str,\n-    pub tool: &'a str,\n+    pub target: Interned<String>,\n+    pub tool: &'static str,\n     pub mode: Mode,\n }\n \n-impl<'a> Step<'a> for ToolBuild<'a> {\n-    type Id = ToolBuild<'static>;\n+impl Step for ToolBuild {\n     type Output = PathBuf;\n \n     /// Build a tool in `src/tools`\n@@ -100,7 +99,7 @@ impl<'a> Step<'a> for ToolBuild<'a> {\n         let target = self.target;\n         let tool = self.tool;\n \n-        let compiler = builder.compiler(stage, &build.build);\n+        let compiler = builder.compiler(stage, build.build);\n         builder.ensure(CleanTools { stage, target, mode: self.mode });\n         match self.mode {\n             Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n@@ -140,7 +139,7 @@ impl<'a> Step<'a> for ToolBuild<'a> {\n         }\n \n         build.run(&mut cargo);\n-        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, compiler.host))\n+        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n     }\n }\n \n@@ -159,29 +158,33 @@ macro_rules! tool {\n                     $(Tool::$name =>\n                         self.ensure($name {\n                             stage: 0,\n-                            target: &self.build.build,\n+                            target: self.build.build,\n                         }),\n                     )+\n                 }\n             }\n         }\n \n         $(\n-        #[derive(Serialize)]\n-        pub struct $name<'a> {\n+            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+        pub struct $name {\n             pub stage: u32,\n-            pub target: &'a str,\n+            pub target: Interned<String>,\n         }\n \n-        impl<'a> Step<'a> for $name<'a> {\n-            type Id = $name<'static>;\n+        impl Step for $name {\n             type Output = PathBuf;\n \n             fn should_run(_builder: &Builder, path: &Path) -> bool {\n                 path.ends_with($path)\n             }\n \n-            fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+            fn make_run(\n+                builder: &Builder,\n+                _path: Option<&Path>,\n+                _host: Interned<String>,\n+                target: Interned<String>\n+            ) {\n                 builder.ensure($name {\n                     stage: builder.top_stage,\n                     target,\n@@ -254,21 +257,25 @@ tool!(\n     RustInstaller, \"src/tools/rust-installer\", \"rust-installer\", Mode::Libstd;\n );\n \n-#[derive(Serialize)]\n-pub struct RemoteTestServer<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RemoteTestServer {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for RemoteTestServer<'a> {\n-    type Id = RemoteTestServer<'static>;\n+impl Step for RemoteTestServer {\n     type Output = PathBuf;\n \n     fn should_run(_builder: &Builder, path: &Path) -> bool {\n         path.ends_with(\"src/tools/remote-test-server\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder,\n+        _path: Option<&Path>,\n+        _host: Interned<String>,\n+        target: Interned<String>\n+    ) {\n         builder.ensure(RemoteTestServer {\n             stage: builder.top_stage,\n             target,\n@@ -299,14 +306,13 @@ impl<'a> Step<'a> for RemoteTestServer<'a> {\n //           .host(&build.build)\n //      })\n //      .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n-#[derive(Serialize)]\n-pub struct Cargo<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Cargo {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Cargo<'a> {\n-    type Id = Cargo<'static>;\n+impl Step for Cargo {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -315,7 +321,9 @@ impl<'a> Step<'a> for Cargo<'a> {\n         path.ends_with(\"src/tools/cargo\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.extended {\n             return;\n         }\n@@ -332,8 +340,8 @@ impl<'a> Step<'a> for Cargo<'a> {\n         // Cargo depends on procedural macros, which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(Rustc {\n-            compiler: builder.compiler(builder.top_stage, &builder.build.build),\n-            target: &builder.build.build,\n+            compiler: builder.compiler(builder.top_stage, builder.build.build),\n+            target: builder.build.build,\n         });\n         builder.ensure(ToolBuild {\n             stage: self.stage,\n@@ -357,14 +365,13 @@ impl<'a> Step<'a> for Cargo<'a> {\n //      })\n //      .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n //\n-#[derive(Serialize)]\n-pub struct Rls<'a> {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rls {\n     pub stage: u32,\n-    pub target: &'a str,\n+    pub target: Interned<String>,\n }\n \n-impl<'a> Step<'a> for Rls<'a> {\n-    type Id = Rls<'static>;\n+impl Step for Rls {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -373,7 +380,9 @@ impl<'a> Step<'a> for Rls<'a> {\n         path.ends_with(\"src/tools/rls\")\n     }\n \n-    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+    fn make_run(\n+        builder: &Builder, path: Option<&Path>, _host: Interned<String>, target: Interned<String>\n+    ) {\n         if path.is_none() && !builder.build.config.extended {\n             return;\n         }\n@@ -390,8 +399,8 @@ impl<'a> Step<'a> for Rls<'a> {\n         // RLS depends on procedural macros, which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(Rustc {\n-            compiler: builder.compiler(builder.top_stage, &builder.build.build),\n-            target: &builder.build.build,\n+            compiler: builder.compiler(builder.top_stage, builder.build.build),\n+            target: builder.build.build,\n         });\n         builder.ensure(ToolBuild {\n             stage: self.stage,\n@@ -407,7 +416,7 @@ impl<'a> Builder<'a> {\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));\n-        let compiler = self.compiler(0, &self.build.build);\n+        let compiler = self.compiler(0, self.build.build);\n         self.prepare_tool_cmd(compiler, &mut cmd);\n         cmd\n     }\n@@ -417,10 +426,10 @@ impl<'a> Builder<'a> {\n     /// Notably this munges the dynamic library lookup path to point to the\n     /// right location to run `compiler`.\n     fn prepare_tool_cmd(&self, compiler: Compiler, cmd: &mut Command) {\n-        let host = compiler.host;\n-        let mut paths = vec![\n-            self.sysroot_libdir(compiler, compiler.host),\n-            self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n+        let host = &compiler.host;\n+        let mut paths: Vec<PathBuf> = vec![\n+            PathBuf::from(&self.sysroot_libdir(compiler, compiler.host)),\n+            self.cargo_out(compiler, Mode::Tool, *host).join(\"deps\"),\n         ];\n \n         // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n@@ -429,7 +438,7 @@ impl<'a> Builder<'a> {\n         if compiler.host.contains(\"msvc\") {\n             let curpaths = env::var_os(\"PATH\").unwrap_or_default();\n             let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n-            for &(ref k, ref v) in self.cc[compiler.host].0.env() {\n+            for &(ref k, ref v) in self.cc[&compiler.host].0.env() {\n                 if k != \"PATH\" {\n                     continue\n                 }"}]}