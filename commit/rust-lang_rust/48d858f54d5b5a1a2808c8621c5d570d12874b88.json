{"sha": "48d858f54d5b5a1a2808c8621c5d570d12874b88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZDg1OGY1NGQ1YjVhMWEyODA4Yzg2MjFjNWQ1NzBkMTI4NzRiODg=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T07:52:25Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-06-30T08:10:24Z"}, "message": "Don't strip affixes from path links", "tree": {"sha": "cec3075c4e7bcb4aaefc1add087e37ea7402c4e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cec3075c4e7bcb4aaefc1add087e37ea7402c4e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d858f54d5b5a1a2808c8621c5d570d12874b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d858f54d5b5a1a2808c8621c5d570d12874b88", "html_url": "https://github.com/rust-lang/rust/commit/48d858f54d5b5a1a2808c8621c5d570d12874b88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d858f54d5b5a1a2808c8621c5d570d12874b88/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1833036daf6d2278df99f7b66aca24b2a66d8d2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1833036daf6d2278df99f7b66aca24b2a66d8d2a", "html_url": "https://github.com/rust-lang/rust/commit/1833036daf6d2278df99f7b66aca24b2a66d8d2a"}], "stats": {"total": 88, "additions": 53, "deletions": 35}, "files": [{"sha": "f7a0af0374e2512b8c7825fee6bb59c0b393cf2c", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/48d858f54d5b5a1a2808c8621c5d570d12874b88/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d858f54d5b5a1a2808c8621c5d570d12874b88/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=48d858f54d5b5a1a2808c8621c5d570d12874b88", "patch": "@@ -17,7 +17,7 @@ use ra_ide_db::{\n     RootDatabase,\n };\n use ra_syntax::{\n-    ast, ast::Path, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, TokenAtOffset,\n+    ast, ast::{Path, MacroCall}, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, TokenAtOffset,\n };\n use ra_tt::{Ident, Leaf, Literal, TokenTree};\n use url::Url;\n@@ -394,35 +394,36 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n // Rewrites a markdown document, resolving links using `callback` and additionally striping prefixes/suffixes on link titles.\n fn map_links<'e>(\n     events: impl Iterator<Item = Event<'e>>,\n-    callback: impl Fn(&str, &str) -> String,\n+    callback: impl Fn(&str, &str) -> (String, String),\n ) -> impl Iterator<Item = Event<'e>> {\n     let mut in_link = false;\n-    let mut link_text = CowStr::Borrowed(\"\");\n+    let mut link_target: Option<CowStr> = None;\n+\n     events.map(move |evt| match evt {\n-        Event::Start(Tag::Link(..)) => {\n+        Event::Start(Tag::Link(_link_type, ref target, _)) => {\n             in_link = true;\n+            link_target = Some(target.clone());\n             evt\n         }\n-        Event::End(Tag::Link(link_type, target, _)) => {\n+        Event::End(Tag::Link(link_type, _target, _)) => {\n             in_link = false;\n-            let target = callback(&target, &link_text);\n-            Event::End(Tag::Link(link_type, CowStr::Boxed(target.into()), CowStr::Borrowed(\"\")))\n+            Event::End(Tag::Link(link_type, link_target.take().unwrap(), CowStr::Borrowed(\"\")))\n         }\n         Event::Text(s) if in_link => {\n-            link_text = s.clone();\n-            // TODO: This can unintentionally strip words from path-based links.\n-            // See std::box::Box -> std::box link as an example.\n-            Event::Text(CowStr::Boxed(strip_prefixes_suffixes(&s).into()))\n+            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n+            link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            Event::Text(CowStr::Boxed(link_name.into()))\n         }\n         Event::Code(s) if in_link => {\n-            link_text = s.clone();\n-            Event::Code(CowStr::Boxed(strip_prefixes_suffixes(&s).into()))\n+            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n+            link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            Event::Code(CowStr::Boxed(link_name.into()))\n         }\n         _ => evt,\n     })\n }\n \n-/// Rewrite documentation links in markdown to point to local documentation/docs.rs\n+/// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> Option<String> {\n     let doc = Parser::new_with_broken_link_callback(\n         markdown,\n@@ -431,21 +432,22 @@ fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) ->\n     );\n \n     let doc = map_links(doc, |target, title: &str| {\n-        match Url::parse(target) {\n-            // If this is a valid absolute URL don't touch it\n-            Ok(_) => target.to_string(),\n-            // Otherwise there are two main possibilities\n-            // path-based links: `../../module/struct.MyStruct.html`\n-            // module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            Err(_) => {\n-                let resolved = try_resolve_intra(db, definition, title, &target)\n-                    .or_else(|| try_resolve_path(db, definition, &target));\n-\n-                if let Some(resolved) = resolved {\n-                    resolved\n-                } else {\n-                    target.to_string()\n-                }\n+        // This check is imperfect, there's some overlap between valid intra-doc links\n+        // and valid URLs so we choose to be too eager to try to resolve what might be\n+        // a URL.\n+        if target.contains(\"://\") {\n+            (target.to_string(), title.to_string())\n+        } else {\n+            // Two posibilities:\n+            // * path-based links: `../../module/struct.MyStruct.html`\n+            // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n+            let resolved = try_resolve_intra(db, definition, title, &target)\n+                .or_else(|| try_resolve_path(db, definition, &target).map(|target| (target, title.to_string())));\n+\n+            if let Some((target, title)) = resolved {\n+                (target, title)\n+            } else {\n+                (target.to_string(), title.to_string())\n             }\n         }\n     });\n@@ -520,7 +522,7 @@ fn try_resolve_intra(\n     definition: &Definition,\n     link_text: &str,\n     link_target: &str,\n-) -> Option<String> {\n+) -> Option<(String, String)> {\n     // Set link_target for implied shortlinks\n     let link_target =\n         if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n@@ -534,6 +536,7 @@ fn try_resolve_intra(\n     // Parse link as a module path\n     // This expects a full document, which a single path isn't, but we can just ignore the errors.\n     let parsed = SyntaxNode::new_root(ra_syntax::parse_text(link_target).0);\n+    // TODO: Proper parsing\n     let path = parsed.descendants().filter_map(Path::cast).next()?;\n     let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n \n@@ -566,7 +569,7 @@ fn try_resolve_intra(\n     let import_map = db.import_map(krate.into());\n     let path = import_map.path_of(ns)?;\n \n-    Some(\n+    Some((\n         get_doc_url(db, &krate)?\n             .join(&format!(\"{}/\", krate.display_name(db)?))\n             .ok()?\n@@ -575,7 +578,7 @@ fn try_resolve_intra(\n             .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?)\n             .ok()?\n             .into_string(),\n-    )\n+    strip_prefixes_suffixes(link_text).to_string()))\n }\n \n /// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n@@ -1485,15 +1488,30 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     }\n \n     #[test]\n-    fn test_hover_intra_link() {\n+    fn test_hover_path_link_no_strip() {\n         check_hover_result(\n             r\"\n             //- /lib.rs\n             pub struct Foo;\n-            /// [Foo](Foo)\n+            /// [struct Foo](struct.Foo.html)\n             pub struct B<|>ar\n             \",\n-            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[struct Foo](https://docs.rs/test/*/test/struct.Foo.html)\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_intra_link() {\n+        check_hover_result(\n+            r\"\n+            //- /lib.rs\n+            pub mod foo {\n+                pub struct Foo;\n+            }\n+            /// [Foo](foo::Foo)\n+            pub struct B<|>ar\n+            \",\n+            &[\"pub struct Bar\\n```\\n___\\n\\n[Foo](https://docs.rs/test/*/test/foo/struct.Foo.html)\"],\n         );\n     }\n "}]}