{"sha": "14e23a5835a385d9aa392abb0ddda5a80208f780", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZTIzYTU4MzVhMzg1ZDlhYTM5MmFiYjBkZGRhNWE4MDIwOGY3ODA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-05-30T14:36:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:19Z"}, "message": "introduce an \"in\" constraint instead of error", "tree": {"sha": "5fde895025c1359ed8594eee44903284edbe3477", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fde895025c1359ed8594eee44903284edbe3477"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e23a5835a385d9aa392abb0ddda5a80208f780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e23a5835a385d9aa392abb0ddda5a80208f780", "html_url": "https://github.com/rust-lang/rust/commit/14e23a5835a385d9aa392abb0ddda5a80208f780", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e23a5835a385d9aa392abb0ddda5a80208f780/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eb3fcc10d4cda8b5ae2e525b128f79d930520ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb3fcc10d4cda8b5ae2e525b128f79d930520ca", "html_url": "https://github.com/rust-lang/rust/commit/2eb3fcc10d4cda8b5ae2e525b128f79d930520ca"}], "stats": {"total": 182, "additions": 133, "deletions": 49}, "files": [{"sha": "f0ea61cf9b493542df28a2f414df92edbc510ee1", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=14e23a5835a385d9aa392abb0ddda5a80208f780", "patch": "@@ -654,11 +654,15 @@ pub fn make_query_outlives<'tcx>(\n         constraints,\n         verifys,\n         givens,\n+        in_constraints,\n     } = region_constraints;\n \n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n+    // FIXME(ndm) -- we have to think about what to do here, perhaps\n+    assert!(in_constraints.is_empty());\n+\n     let outlives: Vec<_> = constraints\n         .into_iter()\n         .map(|(k, _)| match *k {"}, {"sha": "d4386b321e32a77f0a8d82f4c3b1829b924a1faf", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=14e23a5835a385d9aa392abb0ddda5a80208f780", "patch": "@@ -30,6 +30,7 @@ use rustc_data_structures::unify as ut;\n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::symbol::InternedString;\n use syntax_pos::Span;\n@@ -904,6 +905,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .make_subregion(origin, a, b);\n     }\n \n+    /// Require that the region `r` be equal to one of the regions in\n+    /// the set `regions`.\n+    pub fn in_constraint(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        in_regions: &Rc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"sub_regions({:?} <: {:?})\", region, in_regions);\n+        self.borrow_region_constraints()\n+            .in_constraint(origin, region, in_regions);\n+    }\n+\n     pub fn subtype_predicate(\n         &self,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "3072c398df3562650eeace734b9e1a3d50f985a4", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 81, "deletions": 48, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=14e23a5835a385d9aa392abb0ddda5a80208f780", "patch": "@@ -9,6 +9,8 @@ use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n+use std::rc::Rc;\n+use syntax::source_map::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -212,22 +214,46 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///\n     /// # The Solution\n     ///\n-    /// We make use of the constraint that we *do* have in the `<=`\n-    /// relation. To do that, we find the \"minimum\" of all the\n-    /// arguments that appear in the substs: that is, some region\n-    /// which is less than all the others. In the case of `Foo1<'a>`,\n-    /// that would be `'a` (it's the only choice, after all). Then we\n-    /// apply that as a least bound to the variables (e.g., `'a <=\n-    /// '0`).\n+    /// We generally prefer to make us our `<=` constraints, since\n+    /// they integrate best into the region solve. To do that, we find\n+    /// the \"minimum\" of all the arguments that appear in the substs:\n+    /// that is, some region which is less than all the others. In the\n+    /// case of `Foo1<'a>`, that would be `'a` (it's the only choice,\n+    /// after all). Then we apply that as a least bound to the\n+    /// variables (e.g., `'a <= '0`).\n     ///\n     /// In some cases, there is no minimum. Consider this example:\n     ///\n     /// ```text\n     /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n     /// ```\n     ///\n-    /// Here we would report an error, because `'a` and `'b` have no\n-    /// relation to one another.\n+    /// Here we would report a more complex \"in constraint\", like `'r\n+    /// in ['a, 'b, 'static]` (where `'r` is some regon appearing in\n+    /// the hidden type).\n+    ///\n+    /// # Constrain regions, not the hidden concrete type\n+    ///\n+    /// Note that generating constraints on each region `Rc` is *not*\n+    /// the same as generating an outlives constraint on `Tc` iself.\n+    /// For example, if we had a function like this:\n+    ///\n+    /// ```rust\n+    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n+    ///   (x, y)\n+    /// }\n+    ///\n+    /// // Equivalent to:\n+    /// existential type FooReturn<'a, T>: Foo<'a>;\n+    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n+    /// ```\n+    ///\n+    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n+    /// is an inference variable). If we generated a constraint that\n+    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n+    /// but this is not necessary, because the existential type we\n+    /// create will be allowed to reference `T`. So instead we just\n+    /// generate a constraint that `'0: 'a`.\n     ///\n     /// # The `free_region_relations` parameter\n     ///\n@@ -270,6 +296,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// See `constrain_opaque_types` for docs\n     pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n@@ -323,6 +350,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 GenericParamDefKind::Lifetime => {}\n                 _ => continue,\n             }\n+\n             // Get the value supplied for this region from the substs.\n             let subst_arg = opaque_defn.substs.region_at(param.index as usize);\n \n@@ -339,45 +367,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         least_region = Some(subst_arg);\n                     } else {\n                         // There are two regions (`lr` and\n-                        // `subst_arg`) which are not relatable. We can't\n-                        // find a best choice.\n-                        let context_name = match opaque_defn.origin {\n-                            hir::ExistTyOrigin::ExistentialType => \"existential type\",\n-                            hir::ExistTyOrigin::ReturnImplTrait => \"impl Trait\",\n-                            hir::ExistTyOrigin::AsyncFn => \"async fn\",\n-                        };\n-                        let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n-                        let mut err = self.tcx.sess.struct_span_err(span, &msg);\n-\n-                        let lr_name = lr.to_string();\n-                        let subst_arg_name = subst_arg.to_string();\n-                        let label_owned;\n-                        let label = match (&*lr_name, &*subst_arg_name) {\n-                            (\"'_\", \"'_\") => \"the elided lifetimes here do not outlive one another\",\n-                            _ => {\n-                                label_owned = format!(\n-                                    \"neither `{}` nor `{}` outlives the other\",\n-                                    lr_name, subst_arg_name,\n-                                );\n-                                &label_owned\n-                            }\n-                        };\n-                        err.span_label(span, label);\n-\n-                        if let hir::ExistTyOrigin::AsyncFn = opaque_defn.origin {\n-                            err.note(\n-                                \"multiple unrelated lifetimes are not allowed in \\\n-                                 `async fn`.\",\n-                            );\n-                            err.note(\n-                                \"if you're using argument-position elided lifetimes, consider \\\n-                                 switching to a single named lifetime.\",\n-                            );\n-                        }\n-                        err.emit();\n-\n-                        least_region = Some(self.tcx.mk_region(ty::ReEmpty));\n-                        break;\n+                        // `subst_arg`) which are not relatable. We\n+                        // can't find a best choice. Therefore,\n+                        // instead of creating a single bound like\n+                        // `'r: 'a` (which is our preferred choice),\n+                        // we will create a \"in bound\" like `'r in\n+                        // ['a, 'b, 'c]`, where `'a..'c` are the\n+                        // regions that appear in the impl trait.\n+                        return self.generate_in_constraint(\n+                            span,\n+                            concrete_ty,\n+                            abstract_type_generics,\n+                            opaque_defn,\n+                        );\n                     }\n                 }\n             }\n@@ -392,6 +394,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         });\n     }\n \n+    /// As a fallback, we sometimes generate an \"in constraint\". For\n+    /// case like `impl Foo<'a, 'b>`, where `'a` and `'b` cannot be\n+    /// related, we would generate a constraint `'r in ['a, 'b,\n+    /// 'static]` for each region `'r` that appears in the hidden type\n+    /// (i.e., it must be equal to `'a`, `'b`, or `'static`).\n+    fn generate_in_constraint(\n+        &self,\n+        span: Span,\n+        concrete_ty: Ty<'tcx>,\n+        abstract_type_generics: &ty::Generics,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+    ) {\n+        let in_regions: Rc<Vec<ty::Region<'tcx>>> = Rc::new(\n+            abstract_type_generics\n+                .params\n+                .iter()\n+                .filter(|param| match param.kind {\n+                    GenericParamDefKind::Lifetime => true,\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => false,\n+                })\n+                .map(|param| opaque_defn.substs.region_at(param.index as usize))\n+                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n+                .collect(),\n+        );\n+\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| self.in_constraint(infer::CallReturn(span), r, &in_regions),\n+        });\n+    }\n+\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an abstract type"}, {"sha": "14572c050b00996ec226cfccecf563b964871089", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e23a5835a385d9aa392abb0ddda5a80208f780/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=14e23a5835a385d9aa392abb0ddda5a80208f780", "patch": "@@ -17,6 +17,7 @@ use crate::ty::{Region, RegionVid};\n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem};\n use std::ops::Range;\n+use std::rc::Rc;\n \n mod leak_check;\n \n@@ -78,6 +79,11 @@ pub struct RegionConstraintData<'tcx> {\n     /// be a region variable (or neither, as it happens).\n     pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n \n+    /// Constraints of the form `R0 in [R1, ..., Rn]`, meaning that\n+    /// `R0` must be equal to one of the regions `R1..Rn`. These occur\n+    /// with `impl Trait` quite frequently.\n+    pub in_constraints: Vec<InConstraint<'tcx>>,\n+\n     /// A \"verify\" is something that we need to verify after inference\n     /// is done, but which does not directly affect inference in any\n     /// way.\n@@ -137,6 +143,14 @@ impl Constraint<'_> {\n     }\n }\n \n+/// Requires that `region` must be equal to one of the regions in `in_regions`.\n+#[derive(Debug, Clone)]\n+pub struct InConstraint<'tcx> {\n+    pub origin: SubregionOrigin<'tcx>,\n+    pub region: Region<'tcx>,\n+    pub in_regions: Rc<Vec<Region<'tcx>>>,\n+}\n+\n /// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n /// outlive `RS`. Therefore, verify that `R <= RS[i]` for some\n@@ -643,6 +657,24 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n+    pub fn in_constraint(\n+        &mut self,\n+        origin: SubregionOrigin<'tcx>,\n+        region: ty::Region<'tcx>,\n+        in_regions: &Rc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"in_constraint({:?} in {:#?})\", region, in_regions);\n+\n+        if in_regions.iter().any(|&r| r == region) {\n+            return;\n+        }\n+\n+        self.data.in_constraints.push(InConstraint {\n+            origin, region, in_regions: in_regions.clone()\n+        });\n+\n+    }\n+\n     pub fn make_subregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -906,9 +938,10 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,\n+            in_constraints,\n             verifys,\n             givens,\n         } = self;\n-        constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n+        constraints.is_empty() && in_constraints.is_empty() && verifys.is_empty() && givens.is_empty()\n     }\n }"}]}