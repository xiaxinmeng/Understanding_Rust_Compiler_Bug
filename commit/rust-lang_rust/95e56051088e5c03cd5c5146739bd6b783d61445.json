{"sha": "95e56051088e5c03cd5c5146739bd6b783d61445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZTU2MDUxMDg4ZTVjMDNjZDVjNTE0NjczOWJkNmI3ODNkNjE0NDU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-12T00:41:16Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-16T02:46:27Z"}, "message": "Suggest `?Sized` when applicable for ADTs\n\nFix #71790.", "tree": {"sha": "7d047e15b917d668c30f388cad33154f17d52f05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d047e15b917d668c30f388cad33154f17d52f05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95e56051088e5c03cd5c5146739bd6b783d61445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95e56051088e5c03cd5c5146739bd6b783d61445", "html_url": "https://github.com/rust-lang/rust/commit/95e56051088e5c03cd5c5146739bd6b783d61445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95e56051088e5c03cd5c5146739bd6b783d61445/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4a2533a0720f9cdd86e02eafa3725f07aa7752", "html_url": "https://github.com/rust-lang/rust/commit/ff4a2533a0720f9cdd86e02eafa3725f07aa7752"}], "stats": {"total": 200, "additions": 166, "deletions": 34}, "files": [{"sha": "2cf9907fc7b96f81f4a8cfe8199b94432f4b6cb2", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=95e56051088e5c03cd5c5146739bd6b783d61445", "patch": "@@ -2729,14 +2729,8 @@ impl Node<'_> {\n     pub fn generics(&self) -> Option<&Generics<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { generics, .. })\n-            | Node::ImplItem(ImplItem { generics, .. })\n-            | Node::Item(Item {\n-                kind:\n-                    ItemKind::Trait(_, _, generics, ..)\n-                    | ItemKind::Impl { generics, .. }\n-                    | ItemKind::Fn(_, generics, _),\n-                ..\n-            }) => Some(generics),\n+            | Node::ImplItem(ImplItem { generics, .. }) => Some(generics),\n+            Node::Item(item) => item.kind.generics(),\n             _ => None,\n         }\n     }"}, {"sha": "3afdd709f3b6e71e9c369231fb31e1d192ec59ee", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 88, "deletions": 26, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=95e56051088e5c03cd5c5146739bd6b783d61445", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -1695,36 +1696,69 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        if let (\n-            ty::PredicateKind::Trait(pred, _),\n-            ObligationCauseCode::BindingObligation(item_def_id, span),\n-        ) = (obligation.predicate.kind(), &obligation.cause.code)\n+        let (pred, item_def_id, span) = match (obligation.predicate.kind(), &obligation.cause.code)\n         {\n-            if let (Some(generics), true) = (\n-                self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),\n-                Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n-            ) {\n-                for param in generics.params {\n-                    if param.span == *span\n-                        && !param.bounds.iter().any(|bound| {\n-                            bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n-                                == self.tcx.lang_items().sized_trait()\n-                        })\n-                    {\n-                        let (span, separator) = match param.bounds {\n-                            [] => (span.shrink_to_hi(), \":\"),\n-                            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n-                        };\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"consider relaxing the implicit `Sized` restriction\",\n-                            format!(\"{} ?Sized\", separator),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        return;\n+            (\n+                ty::PredicateKind::Trait(pred, _),\n+                ObligationCauseCode::BindingObligation(item_def_id, span),\n+            ) => (pred, item_def_id, span),\n+            _ => return,\n+        };\n+\n+        let node = match (\n+            self.tcx.hir().get_if_local(*item_def_id),\n+            Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n+        ) {\n+            (Some(node), true) => node,\n+            _ => return,\n+        };\n+        let generics = match node.generics() {\n+            Some(generics) => generics,\n+            None => return,\n+        };\n+        for param in generics.params {\n+            if param.span != *span\n+                || param.bounds.iter().any(|bound| {\n+                    bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n+                        == self.tcx.lang_items().sized_trait()\n+                })\n+            {\n+                continue;\n+            }\n+            match node {\n+                hir::Node::Item(\n+                    item\n+                    @\n+                    hir::Item {\n+                        kind:\n+                            hir::ItemKind::Enum(..)\n+                            | hir::ItemKind::Struct(..)\n+                            | hir::ItemKind::Union(..),\n+                        ..\n+                    },\n+                ) => {\n+                    // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n+                    // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n+                    // is not.\n+                    let mut visitor = FindTypeParam { param: param.name.ident().name, valid: true };\n+                    visitor.visit_item(item);\n+                    if !visitor.valid {\n+                        continue;\n                     }\n                 }\n+                _ => {}\n             }\n+            let (span, separator) = match param.bounds {\n+                [] => (span.shrink_to_hi(), \":\"),\n+                [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+            };\n+            err.span_suggestion_verbose(\n+                span,\n+                \"consider relaxing the implicit `Sized` restriction\",\n+                format!(\"{} ?Sized\", separator),\n+                Applicability::MachineApplicable,\n+            );\n+            return;\n         }\n     }\n \n@@ -1744,6 +1778,34 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n+/// Look for type `param` in an ADT being used only through a reference to confirm that suggesting\n+/// `param: ?Sized` would be a valid constraint.\n+struct FindTypeParam {\n+    param: rustc_span::Symbol,\n+    valid: bool,\n+}\n+\n+impl<'v> Visitor<'v> for FindTypeParam {\n+    type Map = rustc_hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+        match ty.kind {\n+            hir::TyKind::Ptr(_) | hir::TyKind::Rptr(..) | hir::TyKind::TraitObject(..) => return,\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path))\n+                if path.segments.len() == 1 && path.segments[0].ident.name == self.param =>\n+            {\n+                self.valid = false;\n+            }\n+            _ => {}\n+        }\n+        hir::intravisit::walk_ty(self, ty);\n+    }\n+}\n+\n pub fn recursive_type_with_infinite_size_error(\n     tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,"}, {"sha": "a5aae8cc4d8efb91d51cb9c7961c8b92df883b0c", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.rs?ref=95e56051088e5c03cd5c5146739bd6b783d61445", "patch": "@@ -0,0 +1,17 @@\n+trait Trait {\n+    fn func1() -> Struct1<Self>; //~ ERROR E0277\n+    fn func2<'a>() -> Struct2<'a, Self>; //~ ERROR E0277\n+    fn func3() -> Struct3<Self>; //~ ERROR E0277\n+}\n+\n+struct Struct1<T>{\n+    _t: std::marker::PhantomData<*const T>,\n+}\n+struct Struct2<'a, T>{\n+    _t: &'a T,\n+}\n+struct Struct3<T>{\n+    _t: T,\n+}\n+\n+fn main() {}"}, {"sha": "a8a3386c66ff0460321037d93ffa46856ff932b5", "filename": "src/test/ui/suggestions/adt-param-with-implicit-sized-bound.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95e56051088e5c03cd5c5146739bd6b783d61445/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fadt-param-with-implicit-sized-bound.stderr?ref=95e56051088e5c03cd5c5146739bd6b783d61445", "patch": "@@ -0,0 +1,59 @@\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:2:19\n+   |\n+LL |     fn func1() -> Struct1<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct1<T>{\n+   |                - required by this bound in `Struct1`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func1() -> Struct1<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct1<T: ?Sized>{\n+   |                 ^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:3:23\n+   |\n+LL |     fn func2<'a>() -> Struct2<'a, Self>;\n+   |                       ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct2<'a, T>{\n+   |                    - required by this bound in `Struct2`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func2<'a>() -> Struct2<'a, Self> where Self: std::marker::Sized;\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider relaxing the implicit `Sized` restriction\n+   |\n+LL | struct Struct2<'a, T: ?Sized>{\n+   |                     ^^^^^^^^\n+\n+error[E0277]: the size for values of type `Self` cannot be known at compilation time\n+  --> $DIR/adt-param-with-implicit-sized-bound.rs:4:19\n+   |\n+LL |     fn func3() -> Struct3<Self>;\n+   |                   ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+...\n+LL | struct Struct3<T>{\n+   |                - required by this bound in `Struct3`\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `Self`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+help: consider further restricting `Self`\n+   |\n+LL |     fn func3() -> Struct3<Self> where Self: std::marker::Sized;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}