{"sha": "179658e20fa299b4f7405ea72affd1c8d175d95b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OTY1OGUyMGZhMjk5YjRmNzQwNWVhNzJhZmZkMWM4ZDE3NWQ5NWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-22T18:23:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-22T18:23:46Z"}, "message": "Move trans_ivec into the ivec module", "tree": {"sha": "8d33b51f21d69d35cdb4523238c48840b8926ae0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d33b51f21d69d35cdb4523238c48840b8926ae0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/179658e20fa299b4f7405ea72affd1c8d175d95b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/179658e20fa299b4f7405ea72affd1c8d175d95b", "html_url": "https://github.com/rust-lang/rust/commit/179658e20fa299b4f7405ea72affd1c8d175d95b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/179658e20fa299b4f7405ea72affd1c8d175d95b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5bfae9d99186391f4269c37a34cf284d84bf68", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5bfae9d99186391f4269c37a34cf284d84bf68", "html_url": "https://github.com/rust-lang/rust/commit/3a5bfae9d99186391f4269c37a34cf284d84bf68"}], "stats": {"total": 188, "additions": 93, "deletions": 95}, "files": [{"sha": "65c0475defb42b82c30981af6e3c21ea9312f401", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 93, "deletions": 95, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/179658e20fa299b4f7405ea72affd1c8d175d95b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179658e20fa299b4f7405ea72affd1c8d175d95b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=179658e20fa299b4f7405ea72affd1c8d175d95b", "patch": "@@ -2643,6 +2643,98 @@ fn trans_evec_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n }\n \n mod ivec {\n+    fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n+        result {\n+        let typ = node_id_type(bcx_ccx(bcx), id);\n+        let unit_ty;\n+        alt ty::struct(bcx_tcx(bcx), typ) {\n+          ty::ty_vec(mt) { unit_ty = mt.ty; }\n+          _ { bcx_ccx(bcx).sess.bug(\"non-ivec type in trans_ivec\"); }\n+        }\n+        let llunitty = type_of_or_i8(bcx, unit_ty);\n+\n+        let ares = ivec::alloc(bcx, unit_ty);\n+        bcx = ares.bcx;\n+        let llvecptr = ares.llptr;\n+        let unit_sz = ares.llunitsz;\n+        let llalen = ares.llalen;\n+\n+        add_clean_temp(bcx, llvecptr, typ);\n+\n+        let lllen = bcx.build.Mul(C_uint(std::vec::len(args)), unit_sz);\n+        // Allocate the vector pieces and store length and allocated length.\n+\n+        let llfirsteltptr;\n+        if std::vec::len(args) > 0u &&\n+            std::vec::len(args) <= abi::ivec_default_length {\n+            // Interior case.\n+\n+            bcx.build.Store(lllen,\n+                            bcx.build.InBoundsGEP(llvecptr,\n+                                                  [C_int(0),\n+                                                   C_uint(abi::ivec_elt_len)]));\n+            bcx.build.Store(llalen,\n+                            bcx.build.InBoundsGEP(llvecptr,\n+                                                  [C_int(0),\n+                                                   C_uint(abi::ivec_elt_alen)]));\n+            llfirsteltptr =\n+                bcx.build.InBoundsGEP(llvecptr,\n+                                      [C_int(0), C_uint(abi::ivec_elt_elems),\n+                                       C_int(0)]);\n+        } else {\n+            // Heap case.\n+\n+            let stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n+            let stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n+            let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+            let llstubty = T_ivec_heap(llunitty);\n+            let llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n+            bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr, stub_z));\n+            let llheapty = T_ivec_heap_part(llunitty);\n+            if std::vec::len(args) == 0u {\n+                // Null heap pointer indicates a zero-length vector.\n+\n+                bcx.build.Store(llalen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n+                bcx.build.Store(C_null(T_ptr(llheapty)),\n+                                bcx.build.InBoundsGEP(llstubptr, stub_p));\n+                llfirsteltptr = C_null(T_ptr(llunitty));\n+            } else {\n+                bcx.build.Store(lllen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n+\n+                let llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n+                let rslt = trans_shared_malloc(bcx, T_ptr(llheapty), llheapsz);\n+                bcx = rslt.bcx;\n+                let llheapptr = rslt.val;\n+                bcx.build.Store(llheapptr,\n+                                bcx.build.InBoundsGEP(llstubptr, stub_p));\n+                let heap_l = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n+                bcx.build.Store(lllen, bcx.build.InBoundsGEP(llheapptr, heap_l));\n+                llfirsteltptr =\n+                    bcx.build.InBoundsGEP(llheapptr,\n+                                          [C_int(0),\n+                                           C_uint(abi::ivec_heap_elt_elems),\n+                                           C_int(0)]);\n+            }\n+        }\n+        // Store the individual elements.\n+\n+        let i = 0u;\n+        for e: @ast::expr in args {\n+            let lv = trans_lval(bcx, e);\n+            bcx = lv.res.bcx;\n+            let lleltptr;\n+            if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+                lleltptr =\n+                    bcx.build.InBoundsGEP(llfirsteltptr,\n+                                          [bcx.build.Mul(C_uint(i), unit_sz)]);\n+            } else {\n+                lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n+            }\n+            bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n+            i += 1u;\n+        }\n+        ret rslt(bcx, llvecptr);\n+    }\n \n     // Returns the length of an interior vector and a pointer to its first\n     // element, in that order.\n@@ -4821,100 +4913,6 @@ fn trans_tup(cx: &@block_ctxt, elts: &[@ast::expr], id: ast::node_id) ->\n     ret rslt(bcx, tup_val);\n }\n \n-// TODO: Move me to ivec::\n-fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n-   result {\n-    let typ = node_id_type(bcx_ccx(bcx), id);\n-    let unit_ty;\n-    alt ty::struct(bcx_tcx(bcx), typ) {\n-      ty::ty_vec(mt) { unit_ty = mt.ty; }\n-      _ { bcx_ccx(bcx).sess.bug(\"non-ivec type in trans_ivec\"); }\n-    }\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n-\n-    let ares = ivec::alloc(bcx, unit_ty);\n-    bcx = ares.bcx;\n-    let llvecptr = ares.llptr;\n-    let unit_sz = ares.llunitsz;\n-    let llalen = ares.llalen;\n-\n-    add_clean_temp(bcx, llvecptr, typ);\n-\n-    let lllen = bcx.build.Mul(C_uint(std::vec::len(args)), unit_sz);\n-    // Allocate the vector pieces and store length and allocated length.\n-\n-    let llfirsteltptr;\n-    if std::vec::len(args) > 0u &&\n-           std::vec::len(args) <= abi::ivec_default_length {\n-        // Interior case.\n-\n-        bcx.build.Store(lllen,\n-                        bcx.build.InBoundsGEP(llvecptr,\n-                                              [C_int(0),\n-                                               C_uint(abi::ivec_elt_len)]));\n-        bcx.build.Store(llalen,\n-                        bcx.build.InBoundsGEP(llvecptr,\n-                                              [C_int(0),\n-                                               C_uint(abi::ivec_elt_alen)]));\n-        llfirsteltptr =\n-            bcx.build.InBoundsGEP(llvecptr,\n-                                  [C_int(0), C_uint(abi::ivec_elt_elems),\n-                                   C_int(0)]);\n-    } else {\n-        // Heap case.\n-\n-        let stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n-        let stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n-        let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-        let llstubty = T_ivec_heap(llunitty);\n-        let llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n-        bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr, stub_z));\n-        let llheapty = T_ivec_heap_part(llunitty);\n-        if std::vec::len(args) == 0u {\n-            // Null heap pointer indicates a zero-length vector.\n-\n-            bcx.build.Store(llalen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n-            bcx.build.Store(C_null(T_ptr(llheapty)),\n-                            bcx.build.InBoundsGEP(llstubptr, stub_p));\n-            llfirsteltptr = C_null(T_ptr(llunitty));\n-        } else {\n-            bcx.build.Store(lllen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n-\n-            let llheapsz = bcx.build.Add(llsize_of(llheapty), lllen);\n-            let rslt = trans_shared_malloc(bcx, T_ptr(llheapty), llheapsz);\n-            bcx = rslt.bcx;\n-            let llheapptr = rslt.val;\n-            bcx.build.Store(llheapptr,\n-                            bcx.build.InBoundsGEP(llstubptr, stub_p));\n-            let heap_l = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-            bcx.build.Store(lllen, bcx.build.InBoundsGEP(llheapptr, heap_l));\n-            llfirsteltptr =\n-                bcx.build.InBoundsGEP(llheapptr,\n-                                      [C_int(0),\n-                                       C_uint(abi::ivec_heap_elt_elems),\n-                                       C_int(0)]);\n-        }\n-    }\n-    // Store the individual elements.\n-\n-    let i = 0u;\n-    for e: @ast::expr in args {\n-        let lv = trans_lval(bcx, e);\n-        bcx = lv.res.bcx;\n-        let lleltptr;\n-        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-            lleltptr =\n-                bcx.build.InBoundsGEP(llfirsteltptr,\n-                                      [bcx.build.Mul(C_uint(i), unit_sz)]);\n-        } else {\n-            lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n-        }\n-        bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n-        i += 1u;\n-    }\n-    ret rslt(bcx, llvecptr);\n-}\n-\n fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n              base: &option::t<@ast::expr>, id: ast::node_id) -> result {\n     let bcx = cx;\n@@ -5103,7 +5101,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         ret trans_call(cx, f, none::<ValueRef>, args, e.id);\n       }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n-      ast::expr_vec(args, _) { ret trans_ivec(cx, args, e.id); }\n+      ast::expr_vec(args, _) { ret ivec::trans_ivec(cx, args, e.id); }\n       ast::expr_rec(args, base) { ret trans_rec(cx, args, base, e.id); }\n       ast::expr_tup(args) { ret trans_tup(cx, args, e.id); }\n       ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(\"unexpanded macro\"); }"}]}