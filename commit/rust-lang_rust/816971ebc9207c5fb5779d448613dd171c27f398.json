{"sha": "816971ebc9207c5fb5779d448613dd171c27f398", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjk3MWViYzkyMDdjNWZiNTc3OWQ0NDg2MTNkZDE3MWMyN2YzOTg=", "commit": {"author": {"name": "Ville Penttinen", "email": "villem.penttinen@gmail.com", "date": "2019-02-21T10:04:14Z"}, "committer": {"name": "Ville Penttinen", "email": "villem.penttinen@gmail.com", "date": "2019-02-21T10:25:55Z"}, "message": "Implement basic support for Associated Methods and Constants\n\nThis is done in `infer_path_expr`. When `Resolver::resolve_path` returns\n`PartiallyResolved`, we use the returned `Resolution` together with the given\n`segment_index` to check if we can find something matching the segment at\nsegment_index in the impls for that particular type.", "tree": {"sha": "fe49d209a852bb1b4a51eea9d40449dcf2845209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe49d209a852bb1b4a51eea9d40449dcf2845209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/816971ebc9207c5fb5779d448613dd171c27f398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/816971ebc9207c5fb5779d448613dd171c27f398", "html_url": "https://github.com/rust-lang/rust/commit/816971ebc9207c5fb5779d448613dd171c27f398", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/816971ebc9207c5fb5779d448613dd171c27f398/comments", "author": {"login": "vipentti", "id": 4726680, "node_id": "MDQ6VXNlcjQ3MjY2ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/4726680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vipentti", "html_url": "https://github.com/vipentti", "followers_url": "https://api.github.com/users/vipentti/followers", "following_url": "https://api.github.com/users/vipentti/following{/other_user}", "gists_url": "https://api.github.com/users/vipentti/gists{/gist_id}", "starred_url": "https://api.github.com/users/vipentti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vipentti/subscriptions", "organizations_url": "https://api.github.com/users/vipentti/orgs", "repos_url": "https://api.github.com/users/vipentti/repos", "events_url": "https://api.github.com/users/vipentti/events{/privacy}", "received_events_url": "https://api.github.com/users/vipentti/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vipentti", "id": 4726680, "node_id": "MDQ6VXNlcjQ3MjY2ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/4726680?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vipentti", "html_url": "https://github.com/vipentti", "followers_url": "https://api.github.com/users/vipentti/followers", "following_url": "https://api.github.com/users/vipentti/following{/other_user}", "gists_url": "https://api.github.com/users/vipentti/gists{/gist_id}", "starred_url": "https://api.github.com/users/vipentti/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vipentti/subscriptions", "organizations_url": "https://api.github.com/users/vipentti/orgs", "repos_url": "https://api.github.com/users/vipentti/repos", "events_url": "https://api.github.com/users/vipentti/events{/privacy}", "received_events_url": "https://api.github.com/users/vipentti/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84561bb624280b84eb2fe6c6b2a6b9fe3f1dbf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84561bb624280b84eb2fe6c6b2a6b9fe3f1dbf7", "html_url": "https://github.com/rust-lang/rust/commit/c84561bb624280b84eb2fe6c6b2a6b9fe3f1dbf7"}], "stats": {"total": 480, "additions": 430, "deletions": 50}, "files": [{"sha": "f4dccf165fcbc1bd38411a43102c1671e315c120", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -88,7 +88,7 @@ impl ImplBlock {\n         if let Some(TypeRef::Path(path)) = self.target_trait_ref(db) {\n             let resolver = self.resolver(db);\n             if let Some(Resolution::Def(ModuleDef::Trait(tr))) =\n-                resolver.resolve_path(db, &path).take_types()\n+                resolver.resolve_path(db, &path).into_per_ns().take_types()\n             {\n                 return Some(tr);\n             }"}, {"sha": "b78a178c1ae1e7f84ae5a426ee9d716cc0771329", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -119,6 +119,10 @@ impl<T> PerNs<T> {\n         self.types.is_some() && self.values.is_some()\n     }\n \n+    pub fn is_values(&self) -> bool {\n+        self.values.is_some() && self.types.is_none()\n+    }\n+\n     pub fn take(self, namespace: Namespace) -> Option<T> {\n         match namespace {\n             Namespace::Types => self.types,\n@@ -297,7 +301,14 @@ where\n             );\n             (res, if res.is_none() { ReachedFixedPoint::No } else { ReachedFixedPoint::Yes })\n         } else {\n-            self.result.resolve_path_fp(self.db, ResolveMode::Import, original_module, &import.path)\n+            let res = self.result.resolve_path_fp(\n+                self.db,\n+                ResolveMode::Import,\n+                original_module,\n+                &import.path,\n+            );\n+\n+            (res.module, res.reached_fixedpoint)\n         };\n \n         if reached_fixedpoint != ReachedFixedPoint::Yes {\n@@ -435,6 +446,27 @@ where\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub struct ResolvePathResult {\n+    pub(crate) module: PerNs<ModuleDef>,\n+    pub(crate) segment_index: Option<usize>,\n+    reached_fixedpoint: ReachedFixedPoint,\n+}\n+\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n+\n+    fn with(\n+        module: PerNs<ModuleDef>,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { module, reached_fixedpoint, segment_index }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ResolveMode {\n     Import,\n@@ -468,8 +500,9 @@ impl ItemMap {\n         db: &impl PersistentHirDatabase,\n         original_module: Module,\n         path: &Path,\n-    ) -> PerNs<ModuleDef> {\n-        self.resolve_path_fp(db, ResolveMode::Other, original_module, path).0\n+    ) -> (PerNs<ModuleDef>, Option<usize>) {\n+        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n+        (res.module, res.segment_index)\n     }\n \n     fn resolve_in_prelude(\n@@ -534,7 +567,7 @@ impl ItemMap {\n         mode: ResolveMode,\n         original_module: Module,\n         path: &Path,\n-    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+    ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n             PathKind::Crate => PerNs::types(original_module.crate_root(db).into()),\n@@ -549,7 +582,7 @@ impl ItemMap {\n             {\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n-                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n                 self.resolve_name_in_crate_root_or_extern_prelude(\n@@ -561,7 +594,7 @@ impl ItemMap {\n             PathKind::Plain => {\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n-                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n                 self.resolve_name_in_module(db, original_module, &segment.name)\n@@ -571,20 +604,20 @@ impl ItemMap {\n                     PerNs::types(p.into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n-                    return (PerNs::none(), ReachedFixedPoint::Yes);\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n                 }\n             }\n             PathKind::Abs => {\n                 // 2018-style absolute path -- only extern prelude\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n-                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment.name) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n                     PerNs::types(*def)\n                 } else {\n-                    return (PerNs::none(), ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n@@ -598,7 +631,7 @@ impl ItemMap {\n                     // (don't break here because `curr_per_ns` might contain\n                     // something in the value namespace, and it would be wrong\n                     // to return that)\n-                    return (PerNs::none(), ReachedFixedPoint::No);\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n                 }\n             };\n             // resolve segment in curr\n@@ -612,15 +645,15 @@ impl ItemMap {\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let item_map = db.item_map(module.krate);\n-                        let def = item_map.resolve_path(db, *module, &path);\n-                        return (def, ReachedFixedPoint::Yes);\n+                        let (def, s) = item_map.resolve_path(db, *module, &path);\n+                        return ResolvePathResult::with(def, ReachedFixedPoint::Yes, s);\n                     }\n \n                     match self[module.module_id].items.get(&segment.name) {\n                         Some(res) if !res.def.is_none() => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return (PerNs::none(), ReachedFixedPoint::No);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n                         }\n                     }\n                 }\n@@ -629,9 +662,22 @@ impl ItemMap {\n                     tested_by!(item_map_enum_importing);\n                     match e.variant(db, &segment.name) {\n                         Some(variant) => PerNs::both(variant.into(), variant.into()),\n-                        None => PerNs::none(),\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types((*e).into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n                     }\n                 }\n+                ModuleDef::Struct(s) => {\n+                    return ResolvePathResult::with(\n+                        PerNs::types((*s).into()),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n+                }\n                 _ => {\n                     // could be an inherent method call in UFCS form\n                     // (`Struct::method`), or some other kind of associated\n@@ -641,11 +687,11 @@ impl ItemMap {\n                         segment.name,\n                         curr,\n                     );\n-                    return (PerNs::none(), ReachedFixedPoint::Yes);\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n                 }\n             };\n         }\n-        (curr_per_ns, ReachedFixedPoint::Yes)\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n }\n "}, {"sha": "00b55eae95689591c1cdbcfff205cb509342d925", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -32,6 +32,32 @@ pub(crate) struct ExprScope {\n     scope_id: ScopeId,\n }\n \n+#[derive(Debug, Clone)]\n+pub enum PathResult {\n+    /// Path was fully resolved\n+    FullyResolved(PerNs<Resolution>),\n+    /// Path was partially resolved, first element contains the resolution\n+    /// second contains the index in the Path.segments which we were unable to resolve\n+    PartiallyResolved(PerNs<Resolution>, usize),\n+}\n+\n+impl PathResult {\n+    pub fn segment_index(&self) -> Option<usize> {\n+        match self {\n+            PathResult::FullyResolved(_) => None,\n+            PathResult::PartiallyResolved(_, ref i) => Some(*i),\n+        }\n+    }\n+\n+    /// Consumes `PathResult` and returns the contained `PerNs<Resolution>`\n+    pub fn into_per_ns(self) -> PerNs<Resolution> {\n+        match self {\n+            PathResult::FullyResolved(def) => def,\n+            PathResult::PartiallyResolved(def, _) => def,\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n pub(crate) enum Scope {\n     /// All the items and imported names of a module\n@@ -67,18 +93,26 @@ impl Resolver {\n         resolution\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PathResult {\n+        use self::PathResult::*;\n         if let Some(name) = path.as_ident() {\n-            self.resolve_name(db, name)\n+            FullyResolved(self.resolve_name(db, name))\n         } else if path.is_self() {\n-            self.resolve_name(db, &Name::self_param())\n+            FullyResolved(self.resolve_name(db, &Name::self_param()))\n         } else {\n             let (item_map, module) = match self.module() {\n                 Some(m) => m,\n-                _ => return PerNs::none(),\n+                _ => return FullyResolved(PerNs::none()),\n             };\n-            let module_res = item_map.resolve_path(db, module, path);\n-            module_res.map(Resolution::Def)\n+            let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n+\n+            let def = module_res.map(Resolution::Def);\n+\n+            if let Some(index) = segment_index {\n+                PartiallyResolved(def, index)\n+            } else {\n+                FullyResolved(def)\n+            }\n         }\n     }\n "}, {"sha": "2751ab3ab20a1e586247997b92aeefa2986e1271", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 83, "deletions": 25, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -32,17 +32,20 @@ use rustc_hash::FxHashMap;\n \n use test_utils::tested_by;\n \n+use ra_syntax::ast::NameOwner;\n+\n use crate::{\n     Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n+    Const,\n     FnSignature, ModuleDef, AdtDef,\n     HirDatabase,\n     type_ref::{TypeRef, Mutability},\n-    name::KnownName,\n+    name::{KnownName, AsName},\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n     path::GenericArg,\n     adt::VariantDef,\n-    resolve::{Resolver, Resolution}, nameres::Namespace\n+    resolve::{Resolver, Resolution, PathResult}, nameres::Namespace\n };\n \n /// The ID of a type variable.\n@@ -370,7 +373,7 @@ impl Ty {\n         }\n \n         // Resolve the path (in type namespace)\n-        let resolution = resolver.resolve_path(db, path).take_types();\n+        let resolution = resolver.resolve_path(db, path).into_per_ns().take_types();\n \n         let def = match resolution {\n             Some(Resolution::Def(def)) => def,\n@@ -678,6 +681,19 @@ fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     Ty::FnDef { def: def.into(), sig, name, substs }\n }\n \n+fn type_for_const(db: &impl HirDatabase, resolver: &Resolver, def: Const) -> Ty {\n+    let node = def.source(db).1;\n+\n+    let tr = node\n+        .type_ref()\n+        .map(TypeRef::from_ast)\n+        .as_ref()\n+        .map(|tr| Ty::from_hir(db, resolver, tr))\n+        .unwrap_or_else(|| Ty::Unknown);\n+\n+    tr\n+}\n+\n /// Compute the type of a tuple struct constructor.\n fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n     let var_data = def.variant_data(db);\n@@ -1172,15 +1188,56 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n-        let resolved = resolver.resolve_path(self.db, &path).take_values()?;\n+        let resolved = resolver.resolve_path(self.db, &path);\n+\n+        let (resolved, segment_index) = match resolved {\n+            PathResult::FullyResolved(def) => (def.take_values()?, None),\n+            PathResult::PartiallyResolved(def, index) => (def.take_types()?, Some(index)),\n+        };\n+\n         match resolved {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n-                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n-                let ty = self.insert_type_vars(ty);\n-                Some(ty)\n+\n+                if let Some(segment_index) = segment_index {\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n+                    // TODO: What to do if segment_index is not the last segment\n+                    // in the path\n+                    let segment = &path.segments[segment_index];\n+\n+                    // Attempt to find an impl_item for the type which has a name matching\n+                    // the current segment\n+                    let ty = ty.iterate_impl_items(self.db, |item| match item {\n+                        crate::ImplItem::Method(func) => {\n+                            let sig = func.signature(self.db);\n+                            if segment.name == *sig.name() {\n+                                return Some(type_for_fn(self.db, func));\n+                            }\n+                            None\n+                        }\n+                        crate::ImplItem::Const(c) => {\n+                            let node = c.source(self.db).1;\n+\n+                            if let Some(name) = node.name().map(|n| n.as_name()) {\n+                                if segment.name == name {\n+                                    return Some(type_for_const(self.db, resolver, c));\n+                                }\n+                            }\n+\n+                            None\n+                        }\n+\n+                        // TODO: Resolve associated types\n+                        crate::ImplItem::Type(_) => None,\n+                    });\n+                    ty\n+                } else {\n+                    let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                    let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n+                    let ty = self.insert_type_vars(ty);\n+                    Some(ty)\n+                }\n             }\n             Resolution::LocalBinding(pat) => {\n                 let ty = self.type_of_pat.get(pat)?;\n@@ -1204,23 +1261,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n-        let typable: Option<TypableDef> = match resolver.resolve_path(self.db, &path).take_types() {\n-            Some(Resolution::Def(def)) => def.into(),\n-            Some(Resolution::LocalBinding(..)) => {\n-                // this cannot happen\n-                log::error!(\"path resolved to local binding in type ns\");\n-                return (Ty::Unknown, None);\n-            }\n-            Some(Resolution::GenericParam(..)) => {\n-                // generic params can't be used in struct literals\n-                return (Ty::Unknown, None);\n-            }\n-            Some(Resolution::SelfType(..)) => {\n-                // TODO this is allowed in an impl for a struct, handle this\n-                return (Ty::Unknown, None);\n-            }\n-            None => return (Ty::Unknown, None),\n-        };\n+        let typable: Option<TypableDef> =\n+            match resolver.resolve_path(self.db, &path).into_per_ns().take_types() {\n+                Some(Resolution::Def(def)) => def.into(),\n+                Some(Resolution::LocalBinding(..)) => {\n+                    // this cannot happen\n+                    log::error!(\"path resolved to local binding in type ns\");\n+                    return (Ty::Unknown, None);\n+                }\n+                Some(Resolution::GenericParam(..)) => {\n+                    // generic params can't be used in struct literals\n+                    return (Ty::Unknown, None);\n+                }\n+                Some(Resolution::SelfType(..)) => {\n+                    // TODO this is allowed in an impl for a struct, handle this\n+                    return (Ty::Unknown, None);\n+                }\n+                None => return (Ty::Unknown, None),\n+            };\n         let def = match typable {\n             None => return (Ty::Unknown, None),\n             Some(it) => it,"}, {"sha": "14ab8ba96be10cca2653d5f41dbe5ee5053c5d96", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_const.snap", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -0,0 +1,14 @@\n+---\n+created: \"2019-02-20T11:04:56.553382800Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[227; 305) '{     ...:ID; }': ()\n+[237; 238) 'x': u32\n+[241; 252) 'Struct::FOO': u32\n+[262; 263) 'y': u32\n+[266; 275) 'Enum::BAR': u32\n+[285; 286) 'z': u32\n+[289; 302) 'TraitTest::ID': u32\n+"}, {"sha": "8f27af88c9f29d4e8ec6a28a4f5102e6b7ddcb43", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_enum.snap", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_enum.snap", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_enum.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_enum.snap?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -0,0 +1,20 @@\n+---\n+created: \"2019-02-20T11:04:56.553382800Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[48; 68) '{     ...     }': A\n+[58; 62) 'A::B': A\n+[89; 109) '{     ...     }': A\n+[99; 103) 'A::C': A\n+[122; 179) '{     ...  c; }': ()\n+[132; 133) 'a': A\n+[136; 140) 'A::b': fn b() -> A\n+[136; 142) 'A::b()': A\n+[148; 149) 'a': A\n+[159; 160) 'c': A\n+[163; 167) 'A::c': fn c() -> A\n+[163; 169) 'A::c()': A\n+[175; 176) 'c': A\n+"}, {"sha": "fe5d6590e66d0e134f968391b97b36ddfa12ab53", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_generics.snap", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -0,0 +1,16 @@\n+---\n+created: \"2019-02-21T10:25:18.568887300Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[64; 67) 'val': T\n+[82; 109) '{     ...     }': Gen<T>\n+[92; 103) 'Gen { val }': Gen<T>\n+[98; 101) 'val': T\n+[123; 155) '{     ...32); }': ()\n+[133; 134) 'a': Gen<[unknown]>\n+[137; 146) 'Gen::make': fn make<[unknown]>(T) -> Gen<T>\n+[137; 152) 'Gen::make(0u32)': Gen<[unknown]>\n+[147; 151) '0u32': u32\n+"}, {"sha": "29ca9b0ea9e56f609a6fa3f55bf2ea89701bbddd", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_struct.snap", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_struct.snap", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_struct.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_struct.snap?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -0,0 +1,16 @@\n+---\n+created: \"2019-02-20T11:04:56.553382800Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[50; 76) '{     ...     }': A\n+[60; 70) 'A { x: 0 }': A\n+[67; 68) '0': u32\n+[89; 123) '{     ...a.x; }': ()\n+[99; 100) 'a': A\n+[103; 109) 'A::new': fn new() -> A\n+[103; 111) 'A::new()': A\n+[117; 118) 'a': A\n+[117; 120) 'a.x': u32\n+"}, {"sha": "6584bef39229cc8e6b893848735c9b9431037748", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_with_modules.snap", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_with_modules.snap", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_with_modules.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_with_modules.snap?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -0,0 +1,23 @@\n+---\n+created: \"2019-02-21T08:55:53.926725400Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[56; 64) '{ A {} }': A\n+[58; 62) 'A {}': A\n+[126; 132) '{ 99 }': u32\n+[128; 130) '99': u32\n+[202; 210) '{ C {} }': C\n+[204; 208) 'C {}': C\n+[241; 325) '{     ...g(); }': ()\n+[251; 252) 'x': A\n+[255; 266) 'a::A::thing': fn thing() -> A\n+[255; 268) 'a::A::thing()': A\n+[278; 279) 'y': u32\n+[282; 293) 'b::B::thing': fn thing() -> u32\n+[282; 295) 'b::B::thing()': u32\n+[305; 306) 'z': C\n+[309; 320) 'c::C::thing': fn thing() -> C\n+[309; 322) 'c::C::thing()': C\n+"}, {"sha": "c4b452ba4f297c585ffb604aa2c17265c110c8be", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -586,6 +586,139 @@ fn test() -> i128 {\n     );\n }\n \n+#[test]\n+fn infer_associated_const() {\n+    check_inference(\n+        \"infer_associated_const\",\n+        r#\"\n+struct Struct;\n+\n+impl Struct {\n+    const FOO: u32 = 1;\n+}\n+\n+enum Enum;\n+\n+impl Enum {\n+    const BAR: u32 = 2;\n+}\n+\n+trait Trait {\n+    const ID: u32;\n+}\n+\n+struct TraitTest;\n+\n+impl Trait for TraitTest {\n+    const ID: u32 = 5;\n+}\n+\n+fn test() {\n+    let x = Struct::FOO;\n+    let y = Enum::BAR;\n+    let z = TraitTest::ID;\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_struct() {\n+    check_inference(\n+        \"infer_associated_method_struct\",\n+        r#\"\n+struct A { x: u32 };\n+\n+impl A {\n+    fn new() -> A {\n+        A { x: 0 }\n+    }\n+}\n+fn test() {\n+    let a = A::new();\n+    a.x;\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_enum() {\n+    check_inference(\n+        \"infer_associated_method_enum\",\n+        r#\"\n+enum A { B, C };\n+\n+impl A {\n+    pub fn b() -> A {\n+        A::B\n+    }\n+    pub fn c() -> A {\n+        A::C\n+    }\n+}\n+fn test() {\n+    let a = A::b();\n+    a;\n+    let c = A::c();\n+    c;\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_with_modules() {\n+    check_inference(\n+        \"infer_associated_method_with_modules\",\n+        r#\"\n+mod a {\n+    struct A;\n+    impl A { pub fn thing() -> A { A {} }}\n+}\n+\n+mod b {\n+    struct B;\n+    impl B { pub fn thing() -> u32 { 99 }}\n+\n+    mod c {\n+        struct C;\n+        impl C { pub fn thing() -> C { C {} }}\n+    }\n+}\n+use b::c;\n+\n+fn test() {\n+    let x = a::A::thing();\n+    let y = b::B::thing();\n+    let z = c::C::thing();\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_generics() {\n+    check_inference(\n+        \"infer_associated_method_generics\",\n+        r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make(val: T) -> Gen<T> {\n+        Gen { val }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make(0u32);\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn no_panic_on_field_of_enum() {\n     check_inference("}, {"sha": "a0c5572d566b30ce44f3ef0108a8c0e4f59cfc34", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -10,7 +10,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(path) => path.clone(),\n         _ => return,\n     };\n-    let def = match ctx.resolver.resolve_path(ctx.db, &path).take_types() {\n+    let def = match ctx.resolver.resolve_path(ctx.db, &path).into_per_ns().take_types() {\n         Some(Resolution::Def(def)) => def,\n         _ => return,\n     };"}, {"sha": "76aaebd527b050c4fea7b9dd59e81d86e80f9a55", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -79,7 +79,7 @@ pub(crate) fn reference_definition(\n     if let Some(path) =\n         name_ref.syntax().ancestors().find_map(ast::Path::cast).and_then(hir::Path::from_ast)\n     {\n-        let resolved = resolver.resolve_path(db, &path);\n+        let resolved = resolver.resolve_path(db, &path).into_per_ns();\n         match resolved.clone().take_types().or_else(|| resolved.take_values()) {\n             Some(Resolution::Def(def)) => return Exact(NavigationTarget::from_def(db, def)),\n             Some(Resolution::LocalBinding(pat)) => {"}, {"sha": "38671b3940e3f3dd04fdba1900f46fa63d0adbb3", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816971ebc9207c5fb5779d448613dd171c27f398/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=816971ebc9207c5fb5779d448613dd171c27f398", "patch": "@@ -223,4 +223,24 @@ mod tests {\n         assert_eq!(\"usize\", &type_name);\n     }\n \n+    #[test]\n+    fn test_hover_infer_associated_method_result() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            struct Thing { x: u32 };\n+\n+            impl Thing {\n+                fn new() -> Thing {\n+                    Thing { x: 0 }\n+                }\n+            }\n+\n+            fn main() {\n+                let foo_<|>test = Thing::new();\n+            }\n+            \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        assert_eq!(hover.info, \"Thing\");\n+    }\n }"}]}