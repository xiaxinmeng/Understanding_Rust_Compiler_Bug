{"sha": "661a5ad38e79f336976b529aa717871d177ab7ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MWE1YWQzOGU3OWYzMzY5NzZiNTI5YWE3MTc4NzFkMTc3YWI3ZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-28T15:15:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-28T15:15:00Z"}, "message": "Auto merge of #26173 - pnkfelix:fsk-trans-nzmove-take3, r=nikomatsakis\n\nAdd dropflag hints (stack-local booleans) for unfragmented paths in trans.  Part of #5016.\r\n\r\nAdded code to maintain these hints at runtime, and to conditionalize drop-filling and calls to destructors.\r\n\r\nIn this early stage of my incremental implementation strategy, we are using hints, so we are always free to leave out a flag for a path -- then we just pass `None` as the dropflag hint in the corresponding schedule cleanup call. But, once a path has a hint, we must at least maintain it: i.e. if the hint exists, we must ensure it is never set to \"moved\" if the data in question might actually have been initialized. It remains sound to conservatively set the hint to \"initialized\" as long as the true drop-flag embedded in the value itself is up-to-date.\r\n\r\nI hope the commit series has been broken up to be readable; most of the commits in the series should build (though I did not always check this).\r\n\r\n----\r\n\r\nOh, I think this technically qualifies as a:\r\n[breaking-change]\r\nbecause it removes drop-filling in some cases where one could previously observe it. That should only affect `unsafe` code; no safe code should be able to inspect whether the drop-fill was present or not. For an example of code that needed to change to account for this, see commit a81c24ae0216ab47df59acd724f8a33124fb6d97 (a unit test of the `move_val_init` intrinsic).  I have not encountered actual code that needed to be updated to account for the change, since this should only be skipping the drop-filling on *moved* values, not on dropped one, and so even types that use `unsafe_no_drop_flag` should be unchanged by this particular PR. (Their time will come later.)", "tree": {"sha": "01670f974a6a52261f06edc9cbf8a78892edcba4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01670f974a6a52261f06edc9cbf8a78892edcba4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/661a5ad38e79f336976b529aa717871d177ab7ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/661a5ad38e79f336976b529aa717871d177ab7ed", "html_url": "https://github.com/rust-lang/rust/commit/661a5ad38e79f336976b529aa717871d177ab7ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/661a5ad38e79f336976b529aa717871d177ab7ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec49d01c88b2098fd6fa550dbd23667fa6d98f50", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec49d01c88b2098fd6fa550dbd23667fa6d98f50", "html_url": "https://github.com/rust-lang/rust/commit/ec49d01c88b2098fd6fa550dbd23667fa6d98f50"}, {"sha": "b4dd765e6884820bb9b5c46d18215657abb7ef22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4dd765e6884820bb9b5c46d18215657abb7ef22", "html_url": "https://github.com/rust-lang/rust/commit/b4dd765e6884820bb9b5c46d18215657abb7ef22"}], "stats": {"total": 996, "additions": 832, "deletions": 164}, "files": [{"sha": "ad4d015979ace2fecdb0b79bc3eb68db2c775ed2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -957,6 +957,44 @@ pub struct ctxt<'tcx> {\n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n     pub cast_kinds: RefCell<NodeMap<cast::CastKind>>,\n+\n+    /// Maps Fn items to a collection of fragment infos.\n+    ///\n+    /// The main goal is to identify data (each of which may be moved\n+    /// or assigned) whose subparts are not moved nor assigned\n+    /// (i.e. their state is *unfragmented*) and corresponding ast\n+    /// nodes where the path to that data is moved or assigned.\n+    ///\n+    /// In the long term, unfragmented values will have their\n+    /// destructor entirely driven by a single stack-local drop-flag,\n+    /// and their parents, the collections of the unfragmented values\n+    /// (or more simply, \"fragmented values\"), are mapped to the\n+    /// corresponding collections of stack-local drop-flags.\n+    ///\n+    /// (However, in the short term that is not the case; e.g. some\n+    /// unfragmented paths still need to be zeroed, namely when they\n+    /// reference parent data from an outer scope that was not\n+    /// entirely moved, and therefore that needs to be zeroed so that\n+    /// we do not get double-drop when we hit the end of the parent\n+    /// scope.)\n+    ///\n+    /// Also: currently the table solely holds keys for node-ids of\n+    /// unfragmented values (see `FragmentInfo` enum definition), but\n+    /// longer-term we will need to also store mappings from\n+    /// fragmented data to the set of unfragmented pieces that\n+    /// constitute it.\n+    pub fragment_infos: RefCell<DefIdMap<Vec<FragmentInfo>>>,\n+}\n+\n+/// Describes the fragment-state associated with a NodeId.\n+///\n+/// Currently only unfragmented paths have entries in the table,\n+/// but longer-term this enum is expected to expand to also\n+/// include data for fragmented paths.\n+#[derive(Copy, Clone, Debug)]\n+pub enum FragmentInfo {\n+    Moved { var: NodeId, move_expr: NodeId },\n+    Assigned { var: NodeId, assign_expr: NodeId, assignee_id: NodeId },\n }\n \n impl<'tcx> ctxt<'tcx> {\n@@ -3498,6 +3536,7 @@ impl<'tcx> ctxt<'tcx> {\n             const_qualif_map: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n+            fragment_infos: RefCell::new(DefIdMap()),\n        }, f)\n     }\n "}, {"sha": "fba8fad203ba2df24564908b7cc7664aaab30051", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -594,6 +594,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"Force drop flag checks on or off\"),\n     trace_macros: bool = (false, parse_bool,\n           \"For every macro invocation, print its name and arguments\"),\n+    disable_nonzeroing_move_hints: bool = (false, parse_bool,\n+          \"Force nonzeroing move optimization off\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "efd46d35f56b7adb9573383cb4f1533821d6d73d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -272,6 +272,9 @@ impl Session {\n     pub fn print_enum_sizes(&self) -> bool {\n         self.opts.debugging_opts.print_enum_sizes\n     }\n+    pub fn nonzeroing_move_hints(&self) -> bool {\n+        !self.opts.debugging_opts.disable_nonzeroing_move_hints\n+    }\n     pub fn sysroot<'a>(&'a self) -> &'a Path {\n         match self.opts.maybe_sysroot {\n             Some (ref sysroot) => sysroot,"}, {"sha": "8d7c964c7b21e4db6d40baabaf97b602f27f85b1", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -86,7 +86,7 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n-    move_data: move_data::FlowedMoveData<'a, 'tcx>,\n+    move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n     param_env: &'a ty::ParameterEnvironment<'a, 'tcx>,\n }\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n \n pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n-                                     move_data: move_data::FlowedMoveData<'c, 'tcx>,\n+                                     move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      fn_id: ast::NodeId,\n                                      decl: &ast::FnDecl,"}, {"sha": "864bd7190a36127e056af4232a51cfaf80ccfd56", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -15,7 +15,7 @@\n use self::Fragment::*;\n \n use borrowck::InteriorKind::{InteriorField, InteriorElement};\n-use borrowck::LoanPath;\n+use borrowck::{self, LoanPath};\n use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n@@ -59,6 +59,84 @@ impl Fragment {\n     }\n }\n \n+pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n+                              move_data: &MoveData,\n+                              id: ast::NodeId) {\n+    let fr = &move_data.fragments.borrow();\n+\n+    // For now, don't care about other kinds of fragments; the precise\n+    // classfication of all paths for non-zeroing *drop* needs them,\n+    // but the loose approximation used by non-zeroing moves does not.\n+    let moved_leaf_paths = fr.moved_leaf_paths();\n+    let assigned_leaf_paths = fr.assigned_leaf_paths();\n+\n+    let mut fragment_infos = Vec::with_capacity(moved_leaf_paths.len());\n+\n+    let find_var_id = |move_path_index: MovePathIndex| -> Option<ast::NodeId> {\n+        let lp = move_data.path_loan_path(move_path_index);\n+        match lp.kind {\n+            LpVar(var_id) => Some(var_id),\n+            LpUpvar(ty::UpvarId { var_id, closure_expr_id }) => {\n+                // The `var_id` is unique *relative to* the current function.\n+                // (Check that we are indeed talking about the same function.)\n+                assert_eq!(id, closure_expr_id);\n+                Some(var_id)\n+            }\n+            LpDowncast(..) | LpExtend(..) => {\n+                // This simple implementation of non-zeroing move does\n+                // not attempt to deal with tracking substructure\n+                // accurately in the general case.\n+                None\n+            }\n+        }\n+    };\n+\n+    let moves = move_data.moves.borrow();\n+    for &move_path_index in moved_leaf_paths {\n+        let var_id = match find_var_id(move_path_index) {\n+            None => continue,\n+            Some(var_id) => var_id,\n+        };\n+\n+        move_data.each_applicable_move(move_path_index, |move_index| {\n+            let info = ty::FragmentInfo::Moved {\n+                var: var_id,\n+                move_expr: moves[move_index.get()].id,\n+            };\n+            debug!(\"fragment_infos push({:?} \\\n+                    due to move_path_index: {} move_index: {}\",\n+                   info, move_path_index.get(), move_index.get());\n+            fragment_infos.push(info);\n+            true\n+        });\n+    }\n+\n+    for &move_path_index in assigned_leaf_paths {\n+        let var_id = match find_var_id(move_path_index) {\n+            None => continue,\n+            Some(var_id) => var_id,\n+        };\n+\n+        let var_assigns = move_data.var_assignments.borrow();\n+        for var_assign in var_assigns.iter()\n+            .filter(|&assign| assign.path == move_path_index)\n+        {\n+            let info = ty::FragmentInfo::Assigned {\n+                var: var_id,\n+                assign_expr: var_assign.id,\n+                assignee_id: var_assign.assignee_id,\n+            };\n+            debug!(\"fragment_infos push({:?} due to var_assignment\", info);\n+            fragment_infos.push(info);\n+        }\n+    }\n+\n+    let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n+    let fn_did = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n+    let prev = fraginfo_map.insert(fn_did, fragment_infos);\n+    assert!(prev.is_none());\n+}\n+\n pub struct FragmentSets {\n     /// During move_data construction, `moved_leaf_paths` tracks paths\n     /// that have been used directly by being moved out of.  When\n@@ -103,6 +181,14 @@ impl FragmentSets {\n         }\n     }\n \n+    pub fn moved_leaf_paths(&self) -> &[MovePathIndex] {\n+        &self.moved_leaf_paths\n+    }\n+\n+    pub fn assigned_leaf_paths(&self) -> &[MovePathIndex] {\n+        &self.assigned_leaf_paths\n+    }\n+\n     pub fn add_move(&mut self, path_index: MovePathIndex) {\n         self.moved_leaf_paths.push(path_index);\n     }"}, {"sha": "78e4945d4b5571a1bd55c2a8cfa2106be7c788fd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -166,10 +166,13 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                     this.tcx,\n                                                     sp,\n                                                     id);\n+    move_data::fragments::build_unfragmented_map(this,\n+                                                 &flowed_moves.move_data,\n+                                                 id);\n \n     check_loans::check_loans(this,\n                              &loan_dfcx,\n-                             flowed_moves,\n+                             &flowed_moves,\n                              &all_loans[..],\n                              id,\n                              decl,"}, {"sha": "ec25dcc7e837691915a229bfc571828b3069ee45", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -159,6 +159,9 @@ pub struct Assignment {\n \n     /// span of node where assignment occurs\n     pub span: Span,\n+\n+    /// id for l-value expression on lhs of assignment\n+    pub assignee_id: ast::NodeId,\n }\n \n #[derive(Copy, Clone)]\n@@ -412,6 +415,7 @@ impl<'tcx> MoveData<'tcx> {\n             path: path_index,\n             id: assign_id,\n             span: span,\n+            assignee_id: assignee_id,\n         };\n \n         if self.is_var_path(path_index) {"}, {"sha": "7d7fd111fe94c9dba05ec0e6c5dfcfe7bbfeb91a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 244, "deletions": 86, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -205,7 +205,7 @@ use trans::build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCas\n use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n use trans::callee;\n-use trans::cleanup::{self, CleanupMethods};\n+use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n@@ -330,11 +330,35 @@ pub enum OptResult<'blk, 'tcx: 'blk> {\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum TransBindingMode {\n+    /// By-value binding for a copy type: copies from matched data\n+    /// into a fresh LLVM alloca.\n     TrByCopy(/* llbinding */ ValueRef),\n-    TrByMove,\n+\n+    /// By-value binding for a non-copy type where we copy into a\n+    /// fresh LLVM alloca; this most accurately reflects the language\n+    /// semantics (e.g. it properly handles overwrites of the matched\n+    /// input), but potentially injects an unwanted copy.\n+    TrByMoveIntoCopy(/* llbinding */ ValueRef),\n+\n+    /// Binding a non-copy type by reference under the hood; this is\n+    /// a codegen optimization to avoid unnecessary memory traffic.\n+    TrByMoveRef,\n+\n+    /// By-ref binding exposed in the original source input.\n     TrByRef,\n }\n \n+impl TransBindingMode {\n+    /// if binding by making a fresh copy; returns the alloca that it\n+    /// will copy into; otherwise None.\n+    fn alloca_if_copy(&self) -> Option<ValueRef> {\n+        match *self {\n+            TrByCopy(llbinding) | TrByMoveIntoCopy(llbinding) => Some(llbinding),\n+            TrByMoveRef | TrByRef => None,\n+        }\n+    }\n+}\n+\n /// Information about a pattern binding:\n /// - `llmatch` is a pointer to a stack slot.  The stack slot contains a\n ///   pointer into the value being matched.  Hence, llmatch has type `T**`\n@@ -393,16 +417,45 @@ fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     return false;\n }\n \n+// As noted in `fn match_datum`, we should eventually pass around a\n+// `Datum<Lvalue>` for the `val`; but until we get to that point, this\n+// `MatchInput` struct will serve -- it has everything `Datum<Lvalue>`\n+// does except for the type field.\n+#[derive(Copy, Clone)]\n+pub struct MatchInput { val: ValueRef, lval: Lvalue }\n+\n+impl<'tcx> Datum<'tcx, Lvalue> {\n+    pub fn match_input(&self) -> MatchInput {\n+        MatchInput {\n+            val: self.val,\n+            lval: self.kind,\n+        }\n+    }\n+}\n+\n+impl MatchInput {\n+    fn from_val(val: ValueRef) -> MatchInput {\n+        MatchInput {\n+            val: val,\n+            lval: Lvalue::new(\"MatchInput::from_val\"),\n+        }\n+    }\n+\n+    fn to_datum<'tcx>(self, ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n+        Datum::new(self.val, ty, self.lval)\n+    }\n+}\n+\n fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                               col: usize,\n-                                              val: ValueRef)\n+                                              val: MatchInput)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     m.iter().map(|br| {\n@@ -411,7 +464,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         loop {\n             pat = match pat.node {\n                 ast::PatIdent(_, ref path, Some(ref inner)) => {\n-                    bound_ptrs.push((path.node, val));\n+                    bound_ptrs.push((path.node, val.val));\n                     &**inner\n                 },\n                 _ => break\n@@ -433,7 +486,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           dm: &DefMap,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                           col: usize,\n-                                          val: ValueRef,\n+                                          val: MatchInput,\n                                           mut e: F)\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n     F: FnMut(&[&'p ast::Pat]) -> Option<Vec<&'p ast::Pat>>,\n@@ -442,7 +495,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n            bcx.to_str(),\n            m,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n@@ -452,7 +505,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             match this.node {\n                 ast::PatIdent(_, ref path, None) => {\n                     if pat_is_binding(dm, &*this) {\n-                        bound_ptrs.push((path.node, val));\n+                        bound_ptrs.push((path.node, val.val));\n                     }\n                 }\n                 ast::PatVec(ref before, Some(ref slice), ref after) => {\n@@ -479,13 +532,13 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      dm: &DefMap,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      col: usize,\n-                                     val: ValueRef)\n+                                     val: MatchInput)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n@@ -536,14 +589,14 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              opt: &Opt,\n              col: usize,\n              variant_size: usize,\n-             val: ValueRef)\n+             val: MatchInput)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={:?}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m,\n            *opt,\n            col,\n-           bcx.val_to_string(val));\n+           bcx.val_to_string(val.val));\n     let _indenter = indenter();\n \n     let ctor = match opt {\n@@ -639,25 +692,25 @@ struct ExtractedBlock<'blk, 'tcx: 'blk> {\n fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     repr: &adt::Repr<'tcx>,\n                                     disr_val: ty::Disr,\n-                                    val: ValueRef)\n+                                    val: MatchInput)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n     let args = (0..adt::num_args(repr, disr_val)).map(|i| {\n-        adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n+        adt::trans_field_ptr(bcx, repr, val.val, disr_val, i)\n     }).collect();\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n /// Helper for converting from the ValueRef that we pass around in the match code, which is always\n /// an lvalue, into a Datum. Eventually we should just pass around a Datum and be done with it.\n-fn match_datum<'tcx>(val: ValueRef, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n-    Datum::new(val, left_ty, Lvalue)\n+fn match_datum<'tcx>(val: MatchInput, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n+    val.to_datum(left_ty)\n }\n \n fn bind_subslice_pat(bcx: Block,\n                      pat_id: ast::NodeId,\n-                     val: ValueRef,\n+                     val: MatchInput,\n                      offset_left: usize,\n                      offset_right: usize) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n@@ -687,7 +740,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  left_ty: Ty<'tcx>,\n                                  before: usize,\n                                  after: usize,\n-                                 val: ValueRef)\n+                                 val: MatchInput)\n                                  -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(val, left_ty);\n@@ -888,32 +941,79 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n     for (&ident, &binding_info) in bindings_map {\n-        let llval = match binding_info.trmode {\n+        let (llval, aliases_other_state) = match binding_info.trmode {\n             // By value mut binding for a copy type: load from the ptr\n             // into the matched value and copy to our alloca\n-            TrByCopy(llbinding) => {\n+            TrByCopy(llbinding) |\n+            TrByMoveIntoCopy(llbinding) => {\n                 let llval = Load(bcx, binding_info.llmatch);\n-                let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+                let lvalue = match binding_info.trmode {\n+                    TrByCopy(..) =>\n+                        Lvalue::new(\"_match::insert_lllocals\"),\n+                    TrByMoveIntoCopy(..) => {\n+                        // match_input moves from the input into a\n+                        // separate stack slot.\n+                        //\n+                        // E.g. consider moving the value `D(A)` out\n+                        // of the tuple `(D(A), D(B))` and into the\n+                        // local variable `x` via the pattern `(x,_)`,\n+                        // leaving the remainder of the tuple `(_,\n+                        // D(B))` still to be dropped in the future.\n+                        //\n+                        // Thus, here we must must zero the place that\n+                        // we are moving *from*, because we do not yet\n+                        // track drop flags for a fragmented parent\n+                        // match input expression.\n+                        //\n+                        // Longer term we will be able to map the move\n+                        // into `(x, _)` up to the parent path that\n+                        // owns the whole tuple, and mark the\n+                        // corresponding stack-local drop-flag\n+                        // tracking the first component of the tuple.\n+                        let hint_kind = HintKind::ZeroAndMaintain;\n+                        Lvalue::new_with_hint(\"_match::insert_lllocals (match_input)\",\n+                                              bcx, binding_info.id, hint_kind)\n+                    }\n+                    _ => unreachable!(),\n+                };\n+                let datum = Datum::new(llval, binding_info.ty, lvalue);\n                 call_lifetime_start(bcx, llbinding);\n                 bcx = datum.store_to(bcx, llbinding);\n                 if let Some(cs) = cs {\n                     bcx.fcx.schedule_lifetime_end(cs, llbinding);\n                 }\n \n-                llbinding\n+                (llbinding, false)\n             },\n \n             // By value move bindings: load from the ptr into the matched value\n-            TrByMove => Load(bcx, binding_info.llmatch),\n+            TrByMoveRef => (Load(bcx, binding_info.llmatch), true),\n \n             // By ref binding: use the ptr into the matched value\n-            TrByRef => binding_info.llmatch\n+            TrByRef => (binding_info.llmatch, true),\n         };\n \n-        let datum = Datum::new(llval, binding_info.ty, Lvalue);\n+\n+        // A local that aliases some other state must be zeroed, since\n+        // the other state (e.g. some parent data that we matched\n+        // into) will still have its subcomponents (such as this\n+        // local) destructed at the end of the parent's scope. Longer\n+        // term, we will properly map such parents to the set of\n+        // unique drop flags for its fragments.\n+        let hint_kind = if aliases_other_state {\n+            HintKind::ZeroAndMaintain\n+        } else {\n+            HintKind::DontZeroJustUse\n+        };\n+        let lvalue = Lvalue::new_with_hint(\"_match::insert_lllocals (local)\",\n+                                           bcx,\n+                                           binding_info.id,\n+                                           hint_kind);\n+        let datum = Datum::new(llval, binding_info.ty, lvalue);\n         if let Some(cs) = cs {\n+            let opt_datum = lvalue.dropflag_hint(bcx);\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n-            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty);\n+            bcx.fcx.schedule_drop_and_fill_mem(cs, llval, binding_info.ty, opt_datum);\n         }\n \n         debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n@@ -927,15 +1027,15 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      guard_expr: &ast::Expr,\n                                      data: &ArmData<'p, 'blk, 'tcx>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                     vals: &[ValueRef],\n+                                     vals: &[MatchInput],\n                                      chk: &FailureHandler,\n                                      has_genuine_default: bool)\n                                      -> Block<'blk, 'tcx> {\n     debug!(\"compile_guard(bcx={}, guard_expr={:?}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n            guard_expr,\n            m,\n-           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().join(\", \"));\n+           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n     let _indenter = indenter();\n \n     let mut bcx = insert_lllocals(bcx, &data.bindings_map, None);\n@@ -944,8 +1044,8 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let val = val.to_llbool(bcx);\n \n     for (_, &binding_info) in &data.bindings_map {\n-        if let TrByCopy(llbinding) = binding_info.trmode {\n-            call_lifetime_end(bcx, llbinding);\n+        if let Some(llbinding) = binding_info.trmode.alloca_if_copy() {\n+            call_lifetime_end(bcx, llbinding)\n         }\n     }\n \n@@ -974,13 +1074,13 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                        vals: &[ValueRef],\n+                                        vals: &[MatchInput],\n                                         chk: &FailureHandler,\n                                         has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={:?}, vals=[{}])\",\n            bcx.to_str(),\n            m,\n-           vals.iter().map(|v| bcx.val_to_string(*v)).collect::<Vec<_>>().join(\", \"));\n+           vals.iter().map(|v| bcx.val_to_string(v.val)).collect::<Vec<_>>().join(\", \"));\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n@@ -1040,10 +1140,10 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                                 vals: &[ValueRef],\n+                                                 vals: &[MatchInput],\n                                                  chk: &FailureHandler,\n                                                  col: usize,\n-                                                 val: ValueRef,\n+                                                 val: MatchInput,\n                                                  has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n@@ -1073,13 +1173,13 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n         let arg_count = adt::num_args(&*repr, 0);\n         let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n-            (arg_count, val)\n+            (arg_count, val.val)\n         } else {\n             // For an unsized ADT (i.e. DST struct), we need to treat\n             // the last field specially: instead of simply passing a\n             // ValueRef pointing to that field, as with all the others,\n             // we skip it and instead construct a 'fat ptr' below.\n-            (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val)))\n+            (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val.val)))\n         };\n         let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n             adt::trans_field_ptr(bcx, &*repr, struct_val, 0, ix)\n@@ -1098,7 +1198,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n                 let scratch = alloca_no_lifetime(bcx, llty, \"__struct_field_fat_ptr\");\n                 let data = adt::trans_field_ptr(bcx, &*repr, struct_val, 0, arg_count);\n-                let len = Load(bcx, expr::get_len(bcx, val));\n+                let len = Load(bcx, expr::get_len(bcx, val.val));\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n                 Store(bcx, len, expr::get_len(bcx, scratch));\n                 field_vals.push(scratch);\n@@ -1107,7 +1207,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         Some(field_vals)\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n-        Some(vec!(Load(bcx, val)))\n+        Some(vec!(Load(bcx, val.val)))\n     } else {\n         match left_ty.sty {\n             ty::TyArray(_, n) => {\n@@ -1124,7 +1224,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         &check_match::Single, col,\n                                         field_vals.len())\n             );\n-            let mut vals = field_vals;\n+            let mut vals: Vec<_> = field_vals.into_iter()\n+                .map(|v|MatchInput::from_val(v))\n+                .collect();\n             vals.push_all(&vals_left);\n             compile_submatch(bcx, &pats, &vals, chk, has_genuine_default);\n             return;\n@@ -1136,25 +1238,25 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let opts = get_branches(bcx, m, col);\n     debug!(\"options={:?}\", opts);\n     let mut kind = NoBranch;\n-    let mut test_val = val;\n+    let mut test_val = val.val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if !opts.is_empty() {\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n-                test_val = load_if_immediate(bcx, val, left_ty);\n+                test_val = load_if_immediate(bcx, val.val, left_ty);\n                 kind = if left_ty.is_integral() {\n                     Switch\n                 } else {\n                     Compare\n                 };\n             }\n             Variant(_, ref repr, _, _) => {\n-                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val);\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, &**repr, val.val);\n                 kind = the_kind;\n                 if let Some(tval) = val_opt { test_val = tval; }\n             }\n             SliceLengthEqual(..) | SliceLengthGreaterOrEqual(..) => {\n-                let (_, len) = tvec::get_base_and_len(bcx, val, left_ty);\n+                let (_, len) = tvec::get_base_and_len(bcx, val.val, left_ty);\n                 test_val = len;\n                 kind = Switch;\n             }\n@@ -1278,7 +1380,9 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ConstantValue(..) | ConstantRange(..) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n-        let mut opt_vals = unpacked;\n+        let mut opt_vals: Vec<_> = unpacked.into_iter()\n+            .map(|v|MatchInput::from_val(v))\n+            .collect();\n         opt_vals.push_all(&vals_left[..]);\n         compile_submatch(opt_cx,\n                          &opt_ms[..],\n@@ -1415,25 +1519,30 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n \n         let llmatch;\n         let trmode;\n+        let moves_by_default = variable_ty.moves_by_default(&param_env, span);\n         match bm {\n-            ast::BindByValue(_)\n-                if !variable_ty.moves_by_default(&param_env, span) || reassigned =>\n+            ast::BindByValue(_) if !moves_by_default || reassigned =>\n             {\n                 llmatch = alloca_no_lifetime(bcx,\n-                                 llvariable_ty.ptr_to(),\n-                                 \"__llmatch\");\n-                trmode = TrByCopy(alloca_no_lifetime(bcx,\n-                                         llvariable_ty,\n-                                         &bcx.name(name)));\n+                                             llvariable_ty.ptr_to(),\n+                                             \"__llmatch\");\n+                let llcopy = alloca_no_lifetime(bcx,\n+                                                llvariable_ty,\n+                                                &bcx.name(name));\n+                trmode = if moves_by_default {\n+                    TrByMoveIntoCopy(llcopy)\n+                } else {\n+                    TrByCopy(llcopy)\n+                };\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n-                                 llvariable_ty.ptr_to(),\n-                                 &bcx.name(name));\n-                trmode = TrByMove;\n+                                             llvariable_ty.ptr_to(),\n+                                             &bcx.name(name));\n+                trmode = TrByMoveRef;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n@@ -1517,7 +1626,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, &matches[..], &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, &matches[..], &[discr_datum.match_input()], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in &arm_datas {\n@@ -1556,7 +1665,26 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path1.node.name, scope, (),\n-                |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n+                \"_match::store_local::create_dummy_locals\",\n+                |(), bcx, Datum { val: llval, ty, kind }| {\n+                    // Dummy-locals start out uninitialized, so set their\n+                    // drop-flag hints (if any) to \"moved.\"\n+                    if let Some(hint) = kind.dropflag_hint(bcx) {\n+                        let moved_hint = adt::DTOR_MOVED_HINT as usize;\n+                        debug!(\"store moved_hint={} for hint={:?}, uninitialized dummy\",\n+                               moved_hint, hint);\n+                        Store(bcx, C_u8(bcx.fcx.ccx, moved_hint), hint.to_value().value());\n+                    }\n+\n+                    if kind.drop_flag_info.must_zero() {\n+                        // if no drop-flag hint, or the hint requires\n+                        // we maintain the embedded drop-flag, then\n+                        // mark embedded drop-flag(s) as moved\n+                        // (i.e. \"already dropped\").\n+                        drop_done_fill_mem(bcx, llval, ty);\n+                    }\n+                    bcx\n+                });\n         });\n         bcx\n     }\n@@ -1578,8 +1706,9 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n                         bcx, pat.id, ident.name, var_scope, (),\n-                        |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n-                                                         expr::SaveIn(v)));\n+                        \"_match::store_local\",\n+                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &**init_expr,\n+                                                                         expr::SaveIn(v)));\n                 }\n \n                 None => {}\n@@ -1592,7 +1721,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 add_comment(bcx, \"creating zeroable ref llval\");\n             }\n             let var_scope = cleanup::var_scope(tcx, local.id);\n-            bind_irrefutable_pat(bcx, pat, init_datum.val, var_scope)\n+            bind_irrefutable_pat(bcx, pat, init_datum.match_input(), var_scope)\n         }\n         None => {\n             create_dummy_locals(bcx, pat)\n@@ -1605,24 +1734,26 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        name: ast::Name,\n                                        cleanup_scope: cleanup::ScopeId,\n                                        arg: A,\n+                                       caller_name: &'static str,\n                                        populate: F)\n                                        -> Block<'blk, 'tcx> where\n-    F: FnOnce(A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n+    F: FnOnce(A, Block<'blk, 'tcx>, Datum<'tcx, Lvalue>) -> Block<'blk, 'tcx>,\n {\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n     let llval = alloc_ty(bcx, var_ty, &bcx.name(name));\n+    let lvalue = Lvalue::new_with_hint(caller_name, bcx, p_id, HintKind::DontZeroJustUse);\n+    let datum = Datum::new(llval, var_ty, lvalue);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n-    let bcx = populate(arg, bcx, llval, var_ty);\n+    let bcx = populate(arg, bcx, datum);\n     bcx.fcx.schedule_lifetime_end(cleanup_scope, llval);\n-    bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty);\n+    bcx.fcx.schedule_drop_mem(cleanup_scope, llval, var_ty, lvalue.dropflag_hint(bcx));\n \n     // Now that memory is initialized and has cleanup scheduled,\n-    // create the datum and insert into the local variable map.\n-    let datum = Datum::new(llval, var_ty, Lvalue);\n+    // insert datum into the local variable map.\n     bcx.fcx.lllocals.borrow_mut().insert(p_id, datum);\n     bcx\n }\n@@ -1641,7 +1772,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n /// - val: the value being matched -- must be an lvalue (by ref, with cleanup)\n pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     pat: &ast::Pat,\n-                                    val: ValueRef,\n+                                    val: MatchInput,\n                                     cleanup_scope: cleanup::ScopeId)\n                                     -> Block<'blk, 'tcx> {\n     debug!(\"bind_irrefutable_pat(bcx={}, pat={:?})\",\n@@ -1667,23 +1798,24 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // map.\n                 bcx = mk_binding_alloca(\n                     bcx, pat.id, path1.node.name, cleanup_scope, (),\n-                    |(), bcx, llval, ty| {\n+                    \"_match::bind_irrefutable_pat\",\n+                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n-                                let d = Datum::new(val, ty, Lvalue);\n+                                let d = val.to_datum(ty);\n                                 d.store_to(bcx, llval)\n                             }\n \n                             ast::BindByRef(_) => {\n                                 // By ref binding: the value of the variable\n                                 // is the pointer `val` itself or fat pointer referenced by `val`\n                                 if type_is_fat_ptr(bcx.tcx(), ty) {\n-                                    expr::copy_fat_ptr(bcx, val, llval);\n+                                    expr::copy_fat_ptr(bcx, val.val, llval);\n                                 }\n                                 else {\n-                                    Store(bcx, val, llval);\n+                                    Store(bcx, val.val, llval);\n                                 }\n \n                                 bcx\n@@ -1708,8 +1840,11 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     val);\n                     if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, &*sub_pat[i],\n-                                                       argval, cleanup_scope);\n+                            bcx = bind_irrefutable_pat(\n+                                bcx,\n+                                &*sub_pat[i],\n+                                MatchInput::from_val(argval),\n+                                cleanup_scope);\n                         }\n                     }\n                 }\n@@ -1723,9 +1858,12 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n-                                                                  val, 0, i);\n-                                bcx = bind_irrefutable_pat(bcx, &**elem,\n-                                                           fldptr, cleanup_scope);\n+                                                                  val.val, 0, i);\n+                                bcx = bind_irrefutable_pat(\n+                                    bcx,\n+                                    &**elem,\n+                                    MatchInput::from_val(fldptr),\n+                                    cleanup_scope);\n                             }\n                         }\n                     }\n@@ -1742,26 +1880,42 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n                 for f in fields {\n                     let ix = tcx.field_idx_strict(f.node.ident.name, field_tys);\n-                    let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n-                                                      discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, &*f.node.pat, fldptr, cleanup_scope);\n+                    let fldptr = adt::trans_field_ptr(\n+                        bcx,\n+                        &*pat_repr,\n+                        val.val,\n+                        discr,\n+                        ix);\n+                    bcx = bind_irrefutable_pat(bcx,\n+                                               &*f.node.pat,\n+                                               MatchInput::from_val(fldptr),\n+                                               cleanup_scope);\n                 }\n             })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr, cleanup_scope);\n+                let fldptr = adt::trans_field_ptr(bcx, &*repr, val.val, 0, i);\n+                bcx = bind_irrefutable_pat(\n+                    bcx,\n+                    &**elem,\n+                    MatchInput::from_val(fldptr),\n+                    cleanup_scope);\n             }\n         }\n         ast::PatBox(ref inner) => {\n-            let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, cleanup_scope);\n+            let llbox = Load(bcx, val.val);\n+            bcx = bind_irrefutable_pat(\n+                bcx, &**inner, MatchInput::from_val(llbox), cleanup_scope);\n         }\n         ast::PatRegion(ref inner, _) => {\n-            let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, cleanup_scope);\n+            let loaded_val = Load(bcx, val.val);\n+            bcx = bind_irrefutable_pat(\n+                bcx,\n+                &**inner,\n+                MatchInput::from_val(loaded_val),\n+                cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n@@ -1780,9 +1934,13 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(slice.iter())\n                 .chain(after.iter())\n                 .zip(extracted.vals)\n-                .fold(bcx, |bcx, (inner, elem)|\n-                    bind_irrefutable_pat(bcx, &**inner, elem, cleanup_scope)\n-                );\n+                .fold(bcx, |bcx, (inner, elem)| {\n+                    bind_irrefutable_pat(\n+                        bcx,\n+                        &**inner,\n+                        MatchInput::from_val(elem),\n+                        cleanup_scope)\n+                });\n         }\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");"}, {"sha": "b47d2dd4112ca719fae9a73a202cbe762ec8d827", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -163,6 +163,20 @@ macro_rules! repeat_u8_as_u64 {\n                        (repeat_u8_as_u32!($name) as u64)) }\n }\n \n+/// `DTOR_NEEDED_HINT` is a stack-local hint that just means\n+/// \"we do not know whether the destructor has run or not; check the\n+/// drop-flag embedded in the value itself.\"\n+pub const DTOR_NEEDED_HINT: u8 = 0x3d;\n+\n+/// `DTOR_MOVED_HINT` is a stack-local hint that means \"this value has\n+/// definitely been moved; you do not need to run its destructor.\"\n+///\n+/// (However, for now, such values may still end up being explicitly\n+/// zeroed by the generated code; this is the distinction between\n+/// `datum::DropFlagInfo::ZeroAndMaintain` versus\n+/// `datum::DropFlagInfo::DontZeroJustUse`.)\n+pub const DTOR_MOVED_HINT: u8 = 0x2d;\n+\n pub const DTOR_NEEDED: u8 = 0xd4;\n pub const DTOR_NEEDED_U32: u32 = repeat_u8_as_u32!(DTOR_NEEDED);\n pub const DTOR_NEEDED_U64: u64 = repeat_u8_as_u64!(DTOR_NEEDED);\n@@ -1083,7 +1097,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {\n                 let ptr = struct_field_ptr(variant_cx, st, value, (st.fields.len() - 1), false);\n-                datum::Datum::new(ptr, ptr_ty, datum::Lvalue)\n+                datum::Datum::new(ptr, ptr_ty, datum::Lvalue::new(\"adt::trans_drop_flag_ptr\"))\n                     .store_to(variant_cx, scratch.val)\n             });\n             let expr_datum = scratch.to_expr_datum();"}, {"sha": "61e81d75607cf702caae9432d3e1b245a5271b45", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -51,12 +51,11 @@ use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n use trans::callee;\n-use trans::cleanup::CleanupMethods;\n-use trans::cleanup;\n+use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use trans::common::{CrateContext, FunctionContext};\n+use trans::common::{CrateContext, DropFlagHintsMap, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n@@ -88,7 +87,7 @@ use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::collections::HashSet;\n+use std::collections::{HashMap, HashSet};\n use std::mem;\n use std::str;\n use std::{i8, i16, i32, i64};\n@@ -1235,6 +1234,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           caller_expects_out_pointer: uses_outptr,\n           lllocals: RefCell::new(NodeMap()),\n           llupvars: RefCell::new(NodeMap()),\n+          lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n           id: id,\n           param_substs: param_substs,\n           span: sp,\n@@ -1283,6 +1283,54 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n         }\n     }\n \n+    // Create the drop-flag hints for every unfragmented path in the function.\n+    let tcx = fcx.ccx.tcx();\n+    let fn_did = ast::DefId { krate: ast::LOCAL_CRATE, node: fcx.id };\n+    let mut hints = fcx.lldropflag_hints.borrow_mut();\n+    let fragment_infos = tcx.fragment_infos.borrow();\n+\n+    // Intern table for drop-flag hint datums.\n+    let mut seen = HashMap::new();\n+\n+    if let Some(fragment_infos) = fragment_infos.get(&fn_did) {\n+        for &info in fragment_infos {\n+\n+            let make_datum = |id| {\n+                let init_val = C_u8(fcx.ccx, adt::DTOR_NEEDED_HINT as usize);\n+                let llname = &format!(\"dropflag_hint_{}\", id);\n+                debug!(\"adding hint {}\", llname);\n+                let ptr = alloc_ty(entry_bcx, tcx.types.u8, llname);\n+                Store(entry_bcx, init_val, ptr);\n+                let ty = tcx.mk_ptr(ty::TypeAndMut { ty: tcx.types.u8, mutbl: ast::MutMutable });\n+                let flag = datum::Lvalue::new_dropflag_hint(\"base::init_function\");\n+                let datum = datum::Datum::new(ptr, ty, flag);\n+                datum\n+            };\n+\n+            let (var, datum) = match info {\n+                ty::FragmentInfo::Moved { var, .. } |\n+                ty::FragmentInfo::Assigned { var, .. } => {\n+                    let datum = seen.get(&var).cloned().unwrap_or_else(|| {\n+                        let datum = make_datum(var);\n+                        seen.insert(var, datum.clone());\n+                        datum\n+                    });\n+                    (var, datum)\n+                }\n+            };\n+            match info {\n+                ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n+                    debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n+                    hints.insert(expr_id, DropHint::new(var, datum));\n+                }\n+                ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n+                    debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n+                    hints.insert(expr_id, DropHint::new(var, datum));\n+                }\n+            }\n+        }\n+    }\n+\n     entry_bcx\n }\n \n@@ -1335,9 +1383,9 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n                 let llarg = get_param(fcx.llfn, idx);\n                 idx += 1;\n                 bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n-                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty);\n+                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n \n-                datum::Datum::new(llarg, arg_ty, datum::Lvalue)\n+                datum::Datum::new(llarg, arg_ty, datum::Lvalue::new(\"create_datum_for_fn_args\"))\n             } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 let data = get_param(fcx.llfn, idx);\n                 let extra = get_param(fcx.llfn, idx + 1);\n@@ -1408,7 +1456,7 @@ pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n         } else {\n             // General path. Copy out the values that are used in the\n             // pattern.\n-            _match::bind_irrefutable_pat(bcx, pat, arg_datum.val, arg_scope_id)\n+            _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n         };\n         debuginfo::create_argument_metadata(bcx, &args[i]);\n     }"}, {"sha": "b4b0472512e61a5eb165db96295f0c150630a0f5", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -124,6 +124,7 @@ use trans::base;\n use trans::build;\n use trans::common;\n use trans::common::{Block, FunctionContext, NodeIdAndSpan};\n+use trans::datum::{Datum, Lvalue};\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n@@ -212,6 +213,29 @@ pub enum ScopeId {\n     CustomScope(CustomScopeIndex)\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct DropHint<K>(pub ast::NodeId, pub K);\n+\n+pub type DropHintDatum<'tcx> = DropHint<Datum<'tcx, Lvalue>>;\n+pub type DropHintValue = DropHint<ValueRef>;\n+\n+impl<K> DropHint<K> {\n+    pub fn new(id: ast::NodeId, k: K) -> DropHint<K> { DropHint(id, k) }\n+}\n+\n+impl DropHint<ValueRef> {\n+    pub fn value(&self) -> ValueRef { self.1 }\n+}\n+\n+pub trait DropHintMethods {\n+    type ValueKind;\n+    fn to_value(&self) -> Self::ValueKind;\n+}\n+impl<'tcx> DropHintMethods for DropHintDatum<'tcx> {\n+    type ValueKind = DropHintValue;\n+    fn to_value(&self) -> DropHintValue { DropHint(self.0, self.1.val) }\n+}\n+\n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Invoked when we start to trans the code contained within a new cleanup scope.\n     fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {\n@@ -382,14 +406,17 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: Ty<'tcx>) {\n+                         ty: Ty<'tcx>,\n+                         drop_hint: Option<DropHintDatum<'tcx>>) {\n         if !self.type_needs_drop(ty) { return; }\n+        let drop_hint = drop_hint.map(|hint|hint.to_value());\n         let drop = box DropValue {\n             is_immediate: false,\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n             skip_dtor: false,\n+            drop_hint: drop_hint,\n         };\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n@@ -406,23 +433,28 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: Ty<'tcx>) {\n+                                  ty: Ty<'tcx>,\n+                                  drop_hint: Option<DropHintDatum<'tcx>>) {\n         if !self.type_needs_drop(ty) { return; }\n \n+        let drop_hint = drop_hint.map(|datum|datum.to_value());\n         let drop = box DropValue {\n             is_immediate: false,\n             val: val,\n             ty: ty,\n             fill_on_drop: true,\n             skip_dtor: false,\n+            drop_hint: drop_hint,\n         };\n \n-        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?}, fill_on_drop={}, skip_dtor={})\",\n+        debug!(\"schedule_drop_and_fill_mem({:?}, val={}, ty={:?},\n+                fill_on_drop={}, skip_dtor={}, has_drop_hint={})\",\n                cleanup_scope,\n                self.ccx.tn().val_to_string(val),\n                ty,\n                drop.fill_on_drop,\n-               drop.skip_dtor);\n+               drop.skip_dtor,\n+               drop_hint.is_some());\n \n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n@@ -446,6 +478,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n             ty: ty,\n             fill_on_drop: false,\n             skip_dtor: true,\n+            drop_hint: None,\n         };\n \n         debug!(\"schedule_drop_adt_contents({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n@@ -465,13 +498,14 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                                ty: Ty<'tcx>) {\n \n         if !self.type_needs_drop(ty) { return; }\n-        let drop = box DropValue {\n+        let drop = Box::new(DropValue {\n             is_immediate: true,\n             val: val,\n             ty: ty,\n             fill_on_drop: false,\n             skip_dtor: false,\n-        };\n+            drop_hint: None,\n+        });\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={:?}) fill_on_drop={} skip_dtor={}\",\n                cleanup_scope,\n@@ -976,6 +1010,7 @@ pub struct DropValue<'tcx> {\n     ty: Ty<'tcx>,\n     fill_on_drop: bool,\n     skip_dtor: bool,\n+    drop_hint: Option<DropHintValue>,\n }\n \n impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n@@ -1000,7 +1035,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n         } else {\n-            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor)\n+            glue::drop_ty_core(bcx, self.val, self.ty, debug_loc, self.skip_dtor, self.drop_hint)\n         };\n         if self.fill_on_drop {\n             base::drop_done_fill_mem(bcx, self.val, self.ty);\n@@ -1128,11 +1163,13 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: Ty<'tcx>);\n+                         ty: Ty<'tcx>,\n+                         drop_hint: Option<DropHintDatum<'tcx>>);\n     fn schedule_drop_and_fill_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: Ty<'tcx>);\n+                                  ty: Ty<'tcx>,\n+                                  drop_hint: Option<DropHintDatum<'tcx>>);\n     fn schedule_drop_adt_contents(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,"}, {"sha": "d97872310966beed76b4f87a6a4c448cc4917868", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -82,9 +82,11 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n \n         if kind == ty::FnOnceClosureKind && !captured_by_ref {\n+            let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n-                                      node_id_type(bcx, def_id.node))\n+                                      node_id_type(bcx, def_id.node),\n+                                      hint)\n         }\n \n         if let Some(env_pointer_alloca) = env_pointer_alloca {"}, {"sha": "9478c197a44d0b70e5187d4a687d849d8d01c5c6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -299,6 +299,33 @@ pub fn validate_substs(substs: &Substs) {\n type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n+#[derive(Clone, Debug)]\n+struct HintEntry<'tcx> {\n+    // The datum for the dropflag-hint itself; note that many\n+    // source-level Lvalues will be associated with the same\n+    // dropflag-hint datum.\n+    datum: cleanup::DropHintDatum<'tcx>,\n+}\n+\n+pub struct DropFlagHintsMap<'tcx> {\n+    // Maps NodeId for expressions that read/write unfragmented state\n+    // to that state's drop-flag \"hint.\"  (A stack-local hint\n+    // indicates either that (1.) it is certain that no-drop is\n+    // needed, or (2.)  inline drop-flag must be consulted.)\n+    node_map: NodeMap<HintEntry<'tcx>>,\n+}\n+\n+impl<'tcx> DropFlagHintsMap<'tcx> {\n+    pub fn new() -> DropFlagHintsMap<'tcx> { DropFlagHintsMap { node_map: NodeMap() } }\n+    pub fn has_hint(&self, id: ast::NodeId) -> bool { self.node_map.contains_key(&id) }\n+    pub fn insert(&mut self, id: ast::NodeId, datum: cleanup::DropHintDatum<'tcx>) {\n+        self.node_map.insert(id, HintEntry { datum: datum });\n+    }\n+    pub fn hint_datum(&self, id: ast::NodeId) -> Option<cleanup::DropHintDatum<'tcx>> {\n+        self.node_map.get(&id).map(|t|t.datum)\n+    }\n+}\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n pub struct FunctionContext<'a, 'tcx: 'a> {\n@@ -349,6 +376,10 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // Same as above, but for closure upvars\n     pub llupvars: RefCell<NodeMap<ValueRef>>,\n \n+    // Carries info about drop-flags for local bindings (longer term,\n+    // paths) for the code being compiled.\n+    pub lldropflag_hints: RefCell<DropFlagHintsMap<'tcx>>,\n+\n     // The NodeId of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n     pub id: ast::NodeId,"}, {"sha": "77ac43ac172bbd9bc75c89bb77a60eda7040bbc6", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 151, "deletions": 17, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -93,11 +93,12 @@ pub use self::Expr::*;\n pub use self::RvalueMode::*;\n \n use llvm::ValueRef;\n+use trans::adt;\n use trans::base::*;\n-use trans::build::Load;\n+use trans::build::{Load, Store};\n use trans::common::*;\n use trans::cleanup;\n-use trans::cleanup::CleanupMethods;\n+use trans::cleanup::{CleanupMethods, DropHintDatum, DropHintMethods};\n use trans::expr;\n use trans::tvec;\n use trans::type_of;\n@@ -111,7 +112,7 @@ use syntax::codemap::DUMMY_SP;\n /// describes where the value is stored, what Rust type the value has,\n /// whether it is addressed by reference, and so forth. Please refer\n /// the section on datums in `README.md` for more details.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `kind` below.\n@@ -138,17 +139,125 @@ pub enum Expr {\n     /// `val` is a pointer into memory for which a cleanup is scheduled\n     /// (and thus has type *T). If you move out of an Lvalue, you must\n     /// zero out the memory (FIXME #5016).\n-    LvalueExpr,\n+    LvalueExpr(Lvalue),\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct Lvalue;\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum DropFlagInfo {\n+    DontZeroJustUse(ast::NodeId),\n+    ZeroAndMaintain(ast::NodeId),\n+    None,\n+}\n+\n+impl DropFlagInfo {\n+    pub fn must_zero(&self) -> bool {\n+        match *self {\n+            DropFlagInfo::DontZeroJustUse(..) => false,\n+            DropFlagInfo::ZeroAndMaintain(..) => true,\n+            DropFlagInfo::None => true,\n+        }\n+    }\n+\n+    pub fn hint_datum<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>)\n+                              -> Option<DropHintDatum<'tcx>> {\n+        let id = match *self {\n+            DropFlagInfo::None => return None,\n+            DropFlagInfo::DontZeroJustUse(id) |\n+            DropFlagInfo::ZeroAndMaintain(id) => id,\n+        };\n+\n+        let hints = bcx.fcx.lldropflag_hints.borrow();\n+        let retval = hints.hint_datum(id);\n+        assert!(retval.is_some(), \"An id (={}) means must have a hint\", id);\n+        retval\n+    }\n+}\n+\n+// FIXME: having Lvalue be `Copy` is a bit of a footgun, since clients\n+// may not realize that subparts of an Lvalue can have a subset of\n+// drop-flags associated with them, while this as written will just\n+// memcpy the drop_flag_info. But, it is an easier way to get `_match`\n+// off the ground to just let this be `Copy` for now.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Lvalue {\n+    pub source: &'static str,\n+    pub drop_flag_info: DropFlagInfo\n+}\n \n #[derive(Debug)]\n pub struct Rvalue {\n     pub mode: RvalueMode\n }\n \n+/// Classifies what action we should take when a value is moved away\n+/// with respect to its drop-flag.\n+///\n+/// Long term there will be no need for this classification: all flags\n+/// (which will be stored on the stack frame) will have the same\n+/// interpretation and maintenance code associated with them.\n+#[derive(Copy, Clone, Debug)]\n+pub enum HintKind {\n+    /// When the value is moved, set the drop-flag to \"dropped\"\n+    /// (i.e. \"zero the flag\", even when the specific representation\n+    /// is not literally 0) and when it is reinitialized, set the\n+    /// drop-flag back to \"initialized\".\n+    ZeroAndMaintain,\n+\n+    /// When the value is moved, do not set the drop-flag to \"dropped\"\n+    /// However, continue to read the drop-flag in deciding whether to\n+    /// drop. (In essence, the path/fragment in question will never\n+    /// need to be dropped at the points where it is moved away by\n+    /// this code, but we are defending against the scenario where\n+    /// some *other* code could move away (or drop) the value and thus\n+    /// zero-the-flag, which is why we will still read from it.\n+    DontZeroJustUse,\n+}\n+\n+impl Lvalue { // Constructors for various Lvalues.\n+    pub fn new<'blk, 'tcx>(source: &'static str) -> Lvalue {\n+        debug!(\"Lvalue at {} no drop flag info\", source);\n+        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n+    }\n+\n+    pub fn new_dropflag_hint(source: &'static str) -> Lvalue {\n+        debug!(\"Lvalue at {} is drop flag hint\", source);\n+        Lvalue { source: source, drop_flag_info: DropFlagInfo::None }\n+    }\n+\n+    pub fn new_with_hint<'blk, 'tcx>(source: &'static str,\n+                                     bcx: Block<'blk, 'tcx>,\n+                                     id: ast::NodeId,\n+                                     k: HintKind) -> Lvalue {\n+        let (opt_id, info) = {\n+            let hint_available = Lvalue::has_dropflag_hint(bcx, id) &&\n+                bcx.tcx().sess.nonzeroing_move_hints();\n+            let info = match k {\n+                HintKind::ZeroAndMaintain if hint_available =>\n+                    DropFlagInfo::ZeroAndMaintain(id),\n+                HintKind::DontZeroJustUse if hint_available =>\n+                    DropFlagInfo::DontZeroJustUse(id),\n+                _ =>\n+                    DropFlagInfo::None,\n+            };\n+            (Some(id), info)\n+        };\n+        debug!(\"Lvalue at {}, id: {:?} info: {:?}\", source, opt_id, info);\n+        Lvalue { source: source, drop_flag_info: info }\n+    }\n+} // end Lvalue constructor methods.\n+\n+impl Lvalue {\n+    fn has_dropflag_hint<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     id: ast::NodeId) -> bool {\n+        let hints = bcx.fcx.lldropflag_hints.borrow();\n+        hints.has_hint(id)\n+    }\n+    pub fn dropflag_hint<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>)\n+                                 -> Option<DropHintDatum<'tcx>> {\n+        self.drop_flag_info.hint_datum(bcx)\n+    }\n+}\n+\n impl Rvalue {\n     pub fn new(m: RvalueMode) -> Rvalue {\n         Rvalue { mode: m }\n@@ -199,9 +308,9 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     // Subtle. Populate the scratch memory *before* scheduling cleanup.\n     let bcx = populate(arg, bcx, scratch);\n     bcx.fcx.schedule_lifetime_end(scope, scratch);\n-    bcx.fcx.schedule_drop_mem(scope, scratch, ty);\n+    bcx.fcx.schedule_drop_mem(scope, scratch, ty, None);\n \n-    DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue))\n+    DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue::new(\"datum::lvalue_scratch_datum\")))\n }\n \n /// Allocates temporary space on the stack using alloca() and returns a by-ref Datum pointing to\n@@ -238,7 +347,7 @@ fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n             fcx.schedule_lifetime_end(scope, val);\n-            fcx.schedule_drop_mem(scope, val, ty);\n+            fcx.schedule_drop_mem(scope, val, ty, None);\n         }\n     }\n }\n@@ -295,10 +404,32 @@ impl KindOps for Lvalue {\n                               -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"<Lvalue as KindOps>::post_store\");\n         if bcx.fcx.type_needs_drop(ty) {\n-            // cancel cleanup of affine values by drop-filling the memory\n-            let () = drop_done_fill_mem(bcx, val, ty);\n+            // cancel cleanup of affine values:\n+            // 1. if it has drop-hint, mark as moved; then code\n+            //    aware of drop-hint won't bother calling the\n+            //    drop-glue itself.\n+            if let Some(hint_datum) = self.drop_flag_info.hint_datum(bcx) {\n+                let moved_hint_byte = adt::DTOR_MOVED_HINT as usize;\n+                let hint_llval = hint_datum.to_value().value();\n+                Store(bcx, C_u8(bcx.fcx.ccx, moved_hint_byte), hint_llval);\n+            }\n+            // 2. if the drop info says its necessary, drop-fill the memory.\n+            if self.drop_flag_info.must_zero() {\n+                let () = drop_done_fill_mem(bcx, val, ty);\n+            }\n             bcx\n         } else {\n+            // FIXME (#5016) would be nice to assert this, but we have\n+            // to allow for e.g. DontZeroJustUse flags, for now.\n+            //\n+            // (The dropflag hint construction should be taking\n+            // !type_needs_drop into account; earlier analysis phases\n+            // may not have all the info they need to include such\n+            // information properly, I think; in particular the\n+            // fragments analysis works on a non-monomorphized view of\n+            // the code.)\n+            //\n+            // assert_eq!(self.drop_flag_info, DropFlagInfo::None);\n             bcx\n         }\n     }\n@@ -308,7 +439,7 @@ impl KindOps for Lvalue {\n     }\n \n     fn to_expr_kind(self) -> Expr {\n-        LvalueExpr\n+        LvalueExpr(self)\n     }\n }\n \n@@ -319,14 +450,14 @@ impl KindOps for Expr {\n                               ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n         match *self {\n-            LvalueExpr => Lvalue.post_store(bcx, val, ty),\n+            LvalueExpr(ref l) => l.post_store(bcx, val, ty),\n             RvalueExpr(ref r) => r.post_store(bcx, val, ty),\n         }\n     }\n \n     fn is_by_ref(&self) -> bool {\n         match *self {\n-            LvalueExpr => Lvalue.is_by_ref(),\n+            LvalueExpr(ref l) => l.is_by_ref(),\n             RvalueExpr(ref r) => r.is_by_ref()\n         }\n     }\n@@ -360,7 +491,10 @@ impl<'tcx> Datum<'tcx, Rvalue> {\n         match self.kind.mode {\n             ByRef => {\n                 add_rvalue_clean(ByRef, fcx, scope, self.val, self.ty);\n-                DatumBlock::new(bcx, Datum::new(self.val, self.ty, Lvalue))\n+                DatumBlock::new(bcx, Datum::new(\n+                    self.val,\n+                    self.ty,\n+                    Lvalue::new(\"datum::to_lvalue_datum_in_scope\")))\n             }\n \n             ByValue => {\n@@ -417,7 +551,7 @@ impl<'tcx> Datum<'tcx, Expr> {\n     {\n         let Datum { val, ty, kind } = self;\n         match kind {\n-            LvalueExpr => if_lvalue(Datum::new(val, ty, Lvalue)),\n+            LvalueExpr(l) => if_lvalue(Datum::new(val, ty, l)),\n             RvalueExpr(r) => if_rvalue(Datum::new(val, ty, r)),\n         }\n     }\n@@ -528,7 +662,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n         };\n         Datum {\n             val: val,\n-            kind: Lvalue,\n+            kind: Lvalue::new(\"Datum::get_element\"),\n             ty: ty,\n         }\n     }"}, {"sha": "77822397e89ec4e5f211740498edc24b6867cd57", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -30,7 +30,7 @@ use middle::infer;\n use rustc::ast_map;\n use trans::{type_of, adt, machine, monomorphize};\n use trans::common::{self, CrateContext, FunctionContext, Block};\n-use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n+use trans::_match::{BindingInfo, TransBindingMode};\n use trans::type_::Type;\n use middle::ty::{self, Ty};\n use session::config::{self, FullDebugInfo};\n@@ -2082,14 +2082,15 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // dereference once more. For ByCopy we just use the stack slot we created\n     // for the binding.\n     let var_access = match binding.trmode {\n-        TrByCopy(llbinding) => VariableAccess::DirectVariable {\n+        TransBindingMode::TrByCopy(llbinding) |\n+        TransBindingMode::TrByMoveIntoCopy(llbinding) => VariableAccess::DirectVariable {\n             alloca: llbinding\n         },\n-        TrByMove => VariableAccess::IndirectVariable {\n+        TransBindingMode::TrByMoveRef => VariableAccess::IndirectVariable {\n             alloca: binding.llmatch,\n             address_operations: &aops\n         },\n-        TrByRef => VariableAccess::DirectVariable {\n+        TransBindingMode::TrByRef => VariableAccess::DirectVariable {\n             alloca: binding.llmatch\n         }\n     };"}, {"sha": "35e3c96d09c8013cd9e4360bccec1ce2c99810df", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -61,7 +61,7 @@ use middle::traits;\n use trans::{_match, adt, asm, base, callee, closure, consts, controlflow};\n use trans::base::*;\n use trans::build::*;\n-use trans::cleanup::{self, CleanupMethods};\n+use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::datum::*;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n@@ -227,7 +227,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty_adjusted(bcx, expr);\n             let llty = type_of::type_of(bcx.ccx(), const_ty);\n             let global = PointerCast(bcx, global, llty.ptr_to());\n-            let datum = Datum::new(global, const_ty, Lvalue);\n+            let datum = Datum::new(global, const_ty, Lvalue::new(\"expr::trans\"));\n             return DatumBlock::new(bcx, datum.to_expr_datum());\n         }\n \n@@ -733,7 +733,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             // Always generate an lvalue datum, because this pointer doesn't own\n             // the data and cleanup is scheduled elsewhere.\n-            DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr))\n+            DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n         }\n     })\n \n@@ -810,10 +810,11 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                Some(SaveIn(scratch.val)),\n                                                false));\n             let datum = scratch.to_expr_datum();\n+            let lval = Lvalue::new(\"expr::trans_index overload\");\n             if type_is_sized(bcx.tcx(), elt_ty) {\n-                Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n+                Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr(lval))\n             } else {\n-                Datum::new(datum.val, elt_ty, LvalueExpr)\n+                Datum::new(datum.val, elt_ty, LvalueExpr(lval))\n             }\n         }\n         None => {\n@@ -867,7 +868,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             });\n             let elt = InBoundsGEP(bcx, base, &[ix_val]);\n             let elt = PointerCast(bcx, elt, type_of::type_of(ccx, unit_ty).ptr_to());\n-            Datum::new(elt, unit_ty, LvalueExpr)\n+            let lval = Lvalue::new(\"expr::trans_index fallback\");\n+            Datum::new(elt, unit_ty, LvalueExpr(lval))\n         }\n     };\n \n@@ -912,7 +914,8 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Case 2.\n                 base::get_extern_const(bcx.ccx(), did, const_ty)\n             };\n-            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n+            let lval = Lvalue::new(\"expr::trans_def\");\n+            DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n         }\n         def::DefConst(_) => {\n             bcx.sess().span_bug(ref_expr.span,\n@@ -1001,10 +1004,26 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n                 let src_datum = unpack_datum!(\n                     bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n-                bcx = glue::drop_ty(bcx,\n-                                    dst_datum.val,\n-                                    dst_datum.ty,\n-                                    expr.debug_loc());\n+                let opt_hint_datum = dst_datum.kind.drop_flag_info.hint_datum(bcx);\n+                let opt_hint_val = opt_hint_datum.map(|d|d.to_value());\n+\n+                // 1. Drop the data at the destination, passing the\n+                //    drop-hint in case the lvalue has already been\n+                //    dropped or moved.\n+                bcx = glue::drop_ty_core(bcx,\n+                                         dst_datum.val,\n+                                         dst_datum.ty,\n+                                         expr.debug_loc(),\n+                                         false,\n+                                         opt_hint_val);\n+\n+                // 2. We are overwriting the destination; ensure that\n+                //    its drop-hint (if any) says \"initialized.\"\n+                if let Some(hint_val) = opt_hint_val {\n+                    let hint_llval = hint_val.value();\n+                    let drop_needed = C_u8(bcx.fcx.ccx, adt::DTOR_NEEDED_HINT as usize);\n+                    Store(bcx, drop_needed, hint_llval);\n+                }\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n                 src_datum.store_to(bcx, dst_datum.val)\n@@ -1302,8 +1321,10 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefUpvar(nid, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n+            let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\",\n+                                             bcx, nid, HintKind::ZeroAndMaintain);\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n-                Some(&val) => Datum::new(val, local_ty, Lvalue),\n+                Some(&val) => Datum::new(val, local_ty, lval),\n                 None => {\n                     bcx.sess().bug(&format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n@@ -1574,7 +1595,8 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx = trans_into(bcx, &**e, SaveIn(dest));\n             let scope = cleanup::CustomScope(custom_cleanup_scope);\n             fcx.schedule_lifetime_end(scope, dest);\n-            fcx.schedule_drop_mem(scope, dest, e_ty);\n+            // FIXME: nonzeroing move should generalize to fields\n+            fcx.schedule_drop_mem(scope, dest, e_ty, None);\n         }\n     }\n \n@@ -2267,21 +2289,23 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = load_ty(bcx, datum.val, datum.ty);\n-                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr(datum.kind)))\n             } else {\n                 // A fat pointer and a DST lvalue have the same representation\n                 // just different types. Since there is no temporary for `*e`\n                 // here (because it is unsized), we cannot emulate the sized\n                 // object code path for running drop glue and free. Instead,\n                 // we schedule cleanup for `e`, turning it into an lvalue.\n \n-                let datum = Datum::new(datum.val, content_ty, LvalueExpr);\n+                let lval = Lvalue::new(\"expr::deref_once ty_uniq\");\n+                let datum = Datum::new(datum.val, content_ty, LvalueExpr(lval));\n                 DatumBlock::new(bcx, datum)\n             }\n         }\n \n         ty::TyRawPtr(ty::TypeAndMut { ty: content_ty, .. }) |\n         ty::TyRef(_, ty::TypeAndMut { ty: content_ty, .. }) => {\n+            let lval = Lvalue::new(\"expr::deref_once ptr\");\n             if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = datum.to_llscalarish(bcx);\n \n@@ -2290,11 +2314,11 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // rvalue for non-owning pointers like &T or *T, in which\n                 // case cleanup *is* scheduled elsewhere, by the true\n                 // owner (or, in the case of *T, by the user).\n-                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr(lval)))\n             } else {\n                 // A fat pointer and a DST lvalue have the same representation\n                 // just different types.\n-                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr))\n+                DatumBlock::new(bcx, Datum::new(datum.val, content_ty, LvalueExpr(lval)))\n             }\n         }\n "}, {"sha": "6019099c058254024afdd009b800b41f81da7984", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -130,17 +130,20 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n                            debug_loc: DebugLoc) -> Block<'blk, 'tcx> {\n-    drop_ty_core(bcx, v, t, debug_loc, false)\n+    drop_ty_core(bcx, v, t, debug_loc, false, None)\n }\n \n pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 v: ValueRef,\n                                 t: Ty<'tcx>,\n                                 debug_loc: DebugLoc,\n-                                skip_dtor: bool) -> Block<'blk, 'tcx> {\n+                                skip_dtor: bool,\n+                                drop_hint: Option<cleanup::DropHintValue>)\n+                                -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    debug!(\"drop_ty_core(t={:?}, skip_dtor={})\", t, skip_dtor);\n+    debug!(\"drop_ty_core(t={:?}, skip_dtor={} drop_hint={:?})\", t, skip_dtor, drop_hint);\n     let _icx = push_ctxt(\"drop_ty\");\n+    let mut bcx = bcx;\n     if bcx.fcx.type_needs_drop(t) {\n         let ccx = bcx.ccx();\n         let g = if skip_dtor {\n@@ -156,7 +159,23 @@ pub fn drop_ty_core<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             v\n         };\n \n-        Call(bcx, glue, &[ptr], None, debug_loc);\n+        match drop_hint {\n+            Some(drop_hint) => {\n+                let hint_val = load_ty(bcx, drop_hint.value(), bcx.tcx().types.u8);\n+                let moved_val =\n+                    C_integral(Type::i8(bcx.ccx()), adt::DTOR_MOVED_HINT as u64, false);\n+                let may_need_drop =\n+                    ICmp(bcx, llvm::IntNE, hint_val, moved_val, DebugLoc::None);\n+                bcx = with_cond(bcx, may_need_drop, |cx| {\n+                    Call(cx, glue, &[ptr], None, debug_loc);\n+                    cx\n+                })\n+            }\n+            None => {\n+                // No drop-hint ==> call standard drop glue\n+                Call(bcx, glue, &[ptr], None, debug_loc);\n+            }\n+        }\n     }\n     bcx\n }\n@@ -170,7 +189,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor)\n+    drop_ty_core(bcx, vp, t, debug_loc, skip_dtor, None)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {"}, {"sha": "a9abc61c274d16a85475c530da8e815ecada7f86", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -117,7 +117,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Arrange for the backing array to be cleaned up.\n         let cleanup_scope = cleanup::temporary_scope(bcx.tcx(), content_expr.id);\n         fcx.schedule_lifetime_end(cleanup_scope, llfixed);\n-        fcx.schedule_drop_mem(cleanup_scope, llfixed, fixed_ty);\n+        fcx.schedule_drop_mem(cleanup_scope, llfixed, fixed_ty, None);\n \n         // Generate the content into the backing array.\n         // llfixed has type *[T x N], but we want the type *T,\n@@ -212,7 +212,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);\n                         fcx.schedule_lifetime_end(scope, lleltptr);\n-                        fcx.schedule_drop_mem(scope, lleltptr, vt.unit_ty);\n+                        fcx.schedule_drop_mem(scope, lleltptr, vt.unit_ty, None);\n                     }\n                     fcx.pop_custom_cleanup_scope(temp_scope);\n                 }"}, {"sha": "eb482b3230a439ec38f580c7dc0f10903cf0c602", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/661a5ad38e79f336976b529aa717871d177ab7ed/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=661a5ad38e79f336976b529aa717871d177ab7ed", "patch": "@@ -9,13 +9,8 @@\n // except according to those terms.\n \n \n-#![allow(unknown_features)]\n #![feature(box_syntax)]\n #![feature(intrinsics)]\n-// needed to check for drop fill word.\n-#![feature(filling_drop)]\n-\n-use std::mem::{self, transmute};\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -26,12 +21,80 @@ mod rusti {\n \n pub fn main() {\n     unsafe {\n-        let x: Box<_> = box 1;\n-        let mut y = rusti::init();\n-        let mut z: *const usize = transmute(&x);\n+        // sanity check\n+        check_drops_state(0, None);\n+\n+        let mut x: Box<D> = box D(1);\n+        assert_eq!(x.0, 1);\n+\n+        // A normal overwrite, to demonstrate `check_drops_state`.\n+        x = box D(2);\n+\n+        // At this point, one destructor has run, because the\n+        // overwrite of `x` drops its initial value.\n+        check_drops_state(1, Some(1));\n+\n+        let mut y: Box<D> = rusti::init();\n+\n+        // An initial binding does not overwrite anything.\n+        check_drops_state(1, Some(1));\n+\n+        // Since `y` has been initialized via the `init` intrinsic, it\n+        // would be unsound to directly overwrite its value via normal\n+        // assignment.\n+        //\n+        // The code currently generated by the compiler is overly\n+        // accepting, however, in that it will check if `y` is itself\n+        // null and thus avoid the unsound action of attempting to\n+        // free null. In other words, if we were to do a normal\n+        // assignment like `y = box D(4);` here, it probably would not\n+        // crash today. But the plan is that it may well crash in the\n+        // future, (I believe).\n+\n+        // `x` is moved here; the manner in which this is tracked by the\n+        // compiler is hidden.\n         rusti::move_val_init(&mut y, x);\n-        assert_eq!(*y, 1);\n-        // `x` is nulled out, not directly visible\n-        assert_eq!(*z, mem::POST_DROP_USIZE);\n+\n+        // In particular, it may be tracked via a drop-flag embedded\n+        // in the value, or via a null pointer, or via\n+        // mem::POST_DROP_USIZE, or (most preferably) via a\n+        // stack-local drop flag.\n+        //\n+        // (This test used to build-in knowledge of how it was\n+        // tracked, and check that the underlying stack slot had been\n+        // set to `mem::POST_DROP_USIZE`.)\n+\n+        // But what we *can* observe is how many times the destructor\n+        // for `D` is invoked, and what the last value we saw was\n+        // during such a destructor call. We do so after the end of\n+        // this scope.\n+\n+        assert_eq!(y.0, 2);\n+        y.0 = 3;\n+        assert_eq!(y.0, 3);\n+\n+        check_drops_state(1, Some(1));\n+    }\n+\n+    check_drops_state(2, Some(3));\n+}\n+\n+static mut NUM_DROPS: i32 = 0;\n+static mut LAST_DROPPED: Option<i32> = None;\n+\n+fn check_drops_state(num_drops: i32, last_dropped: Option<i32>) {\n+    unsafe {\n+        assert_eq!(NUM_DROPS, num_drops);\n+        assert_eq!(LAST_DROPPED, last_dropped);\n+    }\n+}\n+\n+struct D(i32);\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        unsafe {\n+            NUM_DROPS += 1;\n+            LAST_DROPPED = Some(self.0);\n+        }\n     }\n }"}]}