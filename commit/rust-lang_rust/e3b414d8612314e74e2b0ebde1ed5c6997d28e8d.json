{"sha": "e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzYjQxNGQ4NjEyMzE0ZTc0ZTJiMGViZGUxZWQ1YzY5OTdkMjhlOGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-07T06:54:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-14T19:50:40Z"}, "message": "std: Stop prefixing jemalloc symbols\n\nNow that we properly only link in jemalloc when building executables, we have\nfar less to worry about in terms of polluting the global namespace with the\n`free` and `malloc` symbols on Linux. This commit will primarily allow LLVM to\nuse jemalloc so the compiler will only be using one allocator overall.\n\nLocally this took compile time for libsyntax from 95 seconds to 89 (a 6%\nimprovement).", "tree": {"sha": "80f053d30c5f9d8451ad60738784d719a7d22074", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80f053d30c5f9d8451ad60738784d719a7d22074"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "html_url": "https://github.com/rust-lang/rust/commit/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc719d2d7d1967b92e38b1dec6d19f10c5b42891", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc719d2d7d1967b92e38b1dec6d19f10c5b42891", "html_url": "https://github.com/rust-lang/rust/commit/cc719d2d7d1967b92e38b1dec6d19f10c5b42891"}], "stats": {"total": 62, "additions": 47, "deletions": 15}, "files": [{"sha": "bd17490955d1e5bbabf97d257097da1af3b12a6b", "filename": "mk/rt.mk", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "patch": "@@ -148,7 +148,15 @@ ifeq ($$(CFG_WINDOWSY_$(1)),1)\n else ifeq ($(OSTYPE_$(1)), apple-ios)\n   JEMALLOC_ARGS_$(1) := --disable-tls\n else ifeq ($(findstring android, $(OSTYPE_$(1))), android)\n-  JEMALLOC_ARGS_$(1) := --disable-tls\n+  # We force android to have prefixed symbols because apparently replacement of\n+  # the libc allocator doesn't quite work. When this was tested (unprefixed\n+  # symbols), it was found that the `realpath` function in libc would allocate\n+  # with libc malloc (not jemalloc malloc), and then the standard library would\n+  # free with jemalloc free, causing a segfault.\n+  #\n+  # If the test suite passes, however, without symbol prefixes then we should be\n+  # good to go!\n+  JEMALLOC_ARGS_$(1) := --disable-tls --with-jemalloc-prefix=je_\n endif\n \n ifdef CFG_ENABLE_DEBUG_JEMALLOC\n@@ -186,7 +194,7 @@ JEMALLOC_LOCAL_$(1) := $$(JEMALLOC_BUILD_DIR_$(1))/lib/$$(JEMALLOC_REAL_NAME_$(1\n $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: jemalloc)\n \tcd \"$$(JEMALLOC_BUILD_DIR_$(1))\"; \"$(S)src/jemalloc/configure\" \\\n-\t\t$$(JEMALLOC_ARGS_$(1)) --with-jemalloc-prefix=je_ $(CFG_JEMALLOC_FLAGS) \\\n+\t\t$$(JEMALLOC_ARGS_$(1)) $(CFG_JEMALLOC_FLAGS) \\\n \t\t--build=$$(CFG_GNU_TRIPLE_$(CFG_BUILD)) --host=$$(CFG_GNU_TRIPLE_$(1)) \\\n \t\tCC=\"$$(CC_$(1)) $$(CFG_JEMALLOC_CFLAGS_$(1))\" \\\n \t\tAR=\"$$(AR_$(1))\" \\"}, {"sha": "c9508322a31a7d7292d14b25426b562b31d08519", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "patch": "@@ -50,7 +50,7 @@ fn main() {\n        .env(\"AR\", &ar)\n        .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n \n-    if target.contains(\"windows-gnu\") {\n+    if target.contains(\"windows\") {\n         // A bit of history here, this used to be --enable-lazy-lock added in\n         // #14006 which was filed with jemalloc in jemalloc/jemalloc#83 which\n         // was also reported to MinGW:\n@@ -72,7 +72,19 @@ fn main() {\n         //        locking, but requires passing an option due to a historical\n         //        default with jemalloc.\n         cmd.arg(\"--disable-lazy-lock\");\n-    } else if target.contains(\"ios\") || target.contains(\"android\") {\n+    } else if target.contains(\"ios\") {\n+        cmd.arg(\"--disable-tls\");\n+    } else if target.contains(\"android\") {\n+        // We force android to have prefixed symbols because apparently\n+        // replacement of the libc allocator doesn't quite work. When this was\n+        // tested (unprefixed symbols), it was found that the `realpath`\n+        // function in libc would allocate with libc malloc (not jemalloc\n+        // malloc), and then the standard library would free with jemalloc free,\n+        // causing a segfault.\n+        //\n+        // If the test suite passes, however, without symbol prefixes then we\n+        // should be good to go!\n+        cmd.arg(\"--with-jemalloc-prefix=je_\");\n         cmd.arg(\"--disable-tls\");\n     }\n \n@@ -82,7 +94,6 @@ fn main() {\n \n     // Turn off broken quarantine (see jemalloc/jemalloc#161)\n     cmd.arg(\"--disable-fill\");\n-    cmd.arg(\"--with-jemalloc-prefix=je_\");\n     cmd.arg(format!(\"--host={}\", build_helper::gnu_target(&target)));\n     cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n "}, {"sha": "bda001eb4f426fbac09f0de84a7eeeb01ec62542", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3b414d8612314e74e2b0ebde1ed5c6997d28e8d/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=e3b414d8612314e74e2b0ebde1ed5c6997d28e8d", "patch": "@@ -41,12 +41,25 @@ use libc::{c_int, c_void, size_t};\n #[cfg(not(cargobuild))]\n extern {}\n \n+// Note that the symbols here are prefixed by default on OSX (we don't\n+// explicitly request it), and on Android we explicitly request it as\n+// unprefixing cause segfaults (mismatches in allocators).\n extern {\n-    fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-    fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-    fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\"),\n+               link_name = \"je_mallocx\")]\n+    fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\"),\n+               link_name = \"je_rallocx\")]\n+    fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\"),\n+               link_name = \"je_xallocx\")]\n+    fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\"),\n+               link_name = \"je_sdallocx\")]\n+    fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n+    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\"),\n+               link_name = \"je_nallocx\")]\n+    fn nallocx(size: size_t, flags: c_int) -> size_t;\n }\n \n // The minimum alignment guaranteed by the architecture. This value is used to\n@@ -78,7 +91,7 @@ fn align_to_flags(align: usize) -> c_int {\n #[no_mangle]\n pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     let flags = align_to_flags(align);\n-    unsafe { je_mallocx(size as size_t, flags) as *mut u8 }\n+    unsafe { mallocx(size as size_t, flags) as *mut u8 }\n }\n \n #[no_mangle]\n@@ -88,7 +101,7 @@ pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n                                     align: usize)\n                                     -> *mut u8 {\n     let flags = align_to_flags(align);\n-    unsafe { je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n+    unsafe { rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n }\n \n #[no_mangle]\n@@ -98,19 +111,19 @@ pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n                                             align: usize)\n                                             -> usize {\n     let flags = align_to_flags(align);\n-    unsafe { je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n+    unsafe { xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n }\n \n #[no_mangle]\n pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     let flags = align_to_flags(align);\n-    unsafe { je_sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n+    unsafe { sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n }\n \n #[no_mangle]\n pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     let flags = align_to_flags(align);\n-    unsafe { je_nallocx(size as size_t, flags) as usize }\n+    unsafe { nallocx(size as size_t, flags) as usize }\n }\n \n // These symbols are used by jemalloc on android but the really old android"}]}