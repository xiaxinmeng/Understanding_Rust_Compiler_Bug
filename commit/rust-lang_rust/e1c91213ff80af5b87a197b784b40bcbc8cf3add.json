{"sha": "e1c91213ff80af5b87a197b784b40bcbc8cf3add", "node_id": "C_kwDOAAsO6NoAKGUxYzkxMjEzZmY4MGFmNWI4N2ExOTdiNzg0YjQwYmNiYzhjZjNhZGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-11T02:26:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-11T02:26:50Z"}, "message": "Auto merge of #105543 - matthiaskrgr:rollup-s9zj0pq, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103146 (Cleanup timeouts in pthread condvar)\n - #105459 (Build rust-analyzer proc-macro server by default)\n - #105460 (Bump compiler-builtins to 0.1.85)\n - #105511 (Update rustix to 0.36.5)\n - #105530 (Clean up lifetimes in rustdoc syntax highlighting)\n - #105534 (Add Nilstrieb to compiler reviewers)\n - #105542 (Some method confirmation code nits)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8b4bbdf495edb95cf31f31cb55a67d64d85ed198", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b4bbdf495edb95cf31f31cb55a67d64d85ed198"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1c91213ff80af5b87a197b784b40bcbc8cf3add", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c91213ff80af5b87a197b784b40bcbc8cf3add", "html_url": "https://github.com/rust-lang/rust/commit/e1c91213ff80af5b87a197b784b40bcbc8cf3add", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1c91213ff80af5b87a197b784b40bcbc8cf3add/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6fcdb690609769a240fc8ab0de0ce68d5ea7dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fcdb690609769a240fc8ab0de0ce68d5ea7dba", "html_url": "https://github.com/rust-lang/rust/commit/c6fcdb690609769a240fc8ab0de0ce68d5ea7dba"}, {"sha": "30db3a7d2535d773356c90eea4af201e5d68ddfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/30db3a7d2535d773356c90eea4af201e5d68ddfd", "html_url": "https://github.com/rust-lang/rust/commit/30db3a7d2535d773356c90eea4af201e5d68ddfd"}], "stats": {"total": 289, "additions": 125, "deletions": 164}, "files": [{"sha": "5d05a09f038938cf4e26241a3883989ee8e4dc22", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -809,9 +809,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.84\"\n+version = \"0.1.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"989b2c1ca6e90ad06fdc69d1d1862fa28d27a977be6d92ae2fa762cf61fe0b10\"\n+checksum = \"13e81c6cd7ab79f51a0c927d22858d61ad12bd0b3865f0b13ece02a4486aeabb\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -4627,9 +4627,9 @@ dependencies = [\n \n [[package]]\n name = \"rustix\"\n-version = \"0.36.3\"\n+version = \"0.36.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b1fbb4dfc4eb1d390c02df47760bb19a84bb80b301ecc947ab5406394d8223e\"\n+checksum = \"a3807b5d10909833d3e9acd1eb5fb988f79376ff10fce42937de71a449c4c588\"\n dependencies = [\n  \"bitflags\",\n  \"errno\","}, {"sha": "7a5191b77f1d45759a88ce6f7c6740f1b257df6d", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 callee_expr,\n                 call_expr,\n                 callee_ty,\n-                pick,\n+                &pick,\n                 segment,\n             );\n             if pick.illegal_sized_bound.is_some() {"}, {"sha": "218c54688aa3e959a187f7b69aded369e9ab8a99", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_expr: &'tcx hir::Expr<'tcx>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         unadjusted_self_ty: Ty<'tcx>,\n-        pick: probe::Pick<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n         segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         debug!(\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     fn confirm(\n         &mut self,\n         unadjusted_self_ty: Ty<'tcx>,\n-        pick: probe::Pick<'tcx>,\n+        pick: &probe::Pick<'tcx>,\n         segment: &hir::PathSegment<'_>,\n     ) -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type."}, {"sha": "b15c086ffad5781f2b921dd61d5c97b31d8bb470", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -192,8 +192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span, None);\n \n-        let result =\n-            self.confirm_method(span, self_expr, call_expr, self_ty, pick.clone(), segment);\n+        let result = self.confirm_method(span, self_expr, call_expr, self_ty, &pick, segment);\n         debug!(\"result = {:?}\", result);\n \n         if let Some(span) = result.illegal_sized_bound {"}, {"sha": "070359e71becc13381d15e12fb510b336a58c28e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -38,9 +38,9 @@ use rustc_trait_selection::traits::query::method_autoderef::{\n use rustc_trait_selection::traits::query::CanonicalTyGoal;\n use rustc_trait_selection::traits::NormalizeExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n+use std::cell::RefCell;\n use std::cmp::max;\n use std::iter;\n-use std::mem;\n use std::ops::Deref;\n \n use smallvec::{smallvec, SmallVec};\n@@ -62,28 +62,29 @@ struct ProbeContext<'a, 'tcx> {\n \n     /// This is the OriginalQueryValues for the steps queries\n     /// that are answered in steps.\n-    orig_steps_var_values: OriginalQueryValues<'tcx>,\n+    orig_steps_var_values: &'a OriginalQueryValues<'tcx>,\n     steps: &'tcx [CandidateStep<'tcx>],\n \n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n \n-    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n-    /// used for error reporting\n-    static_candidates: Vec<CandidateSource>,\n-\n     /// When probing for names, include names that are close to the\n-    /// requested name (by Levensthein distance)\n+    /// requested name (by Levenshtein distance)\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n     private_candidate: Option<(DefKind, DefId)>,\n \n+    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n+    /// used for error reporting\n+    static_candidates: RefCell<Vec<CandidateSource>>,\n+\n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n-    unsatisfied_predicates:\n+    unsatisfied_predicates: RefCell<\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n+    >,\n \n     scope_expr_id: hir::HirId,\n }\n@@ -334,7 +335,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: OP,\n     ) -> Result<R, MethodError<'tcx>>\n     where\n-        OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>,\n+        OP: FnOnce(ProbeContext<'_, 'tcx>) -> Result<R, MethodError<'tcx>>,\n     {\n         let mut orig_values = OriginalQueryValues::default();\n         let param_env_and_self_ty = self.canonicalize_query(\n@@ -445,7 +446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 mode,\n                 method_name,\n                 return_type,\n-                orig_values,\n+                &orig_values,\n                 steps.steps,\n                 scope_expr_id,\n             );\n@@ -539,7 +540,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         mode: Mode,\n         method_name: Option<Ident>,\n         return_type: Option<Ty<'tcx>>,\n-        orig_steps_var_values: OriginalQueryValues<'tcx>,\n+        orig_steps_var_values: &'a OriginalQueryValues<'tcx>,\n         steps: &'tcx [CandidateStep<'tcx>],\n         scope_expr_id: hir::HirId,\n     ) -> ProbeContext<'a, 'tcx> {\n@@ -554,10 +555,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             impl_dups: FxHashSet::default(),\n             orig_steps_var_values,\n             steps,\n-            static_candidates: Vec::new(),\n             allow_similar_names: false,\n             private_candidate: None,\n-            unsatisfied_predicates: Vec::new(),\n+            static_candidates: RefCell::new(Vec::new()),\n+            unsatisfied_predicates: RefCell::new(Vec::new()),\n             scope_expr_id,\n         }\n     }\n@@ -566,8 +567,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.inherent_candidates.clear();\n         self.extension_candidates.clear();\n         self.impl_dups.clear();\n-        self.static_candidates.clear();\n         self.private_candidate = None;\n+        self.static_candidates.borrow_mut().clear();\n+        self.unsatisfied_predicates.borrow_mut().clear();\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1003,9 +1005,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         debug!(\"pick: actual search failed, assemble diagnostics\");\n \n-        let static_candidates = mem::take(&mut self.static_candidates);\n+        let static_candidates = std::mem::take(self.static_candidates.get_mut());\n         let private_candidate = self.private_candidate.take();\n-        let unsatisfied_predicates = mem::take(&mut self.unsatisfied_predicates);\n+        let unsatisfied_predicates = std::mem::take(self.unsatisfied_predicates.get_mut());\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n         self.reset();\n@@ -1050,7 +1052,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }))\n     }\n \n-    fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n+    fn pick_core(&self) -> Option<PickResult<'tcx>> {\n         let pick = self.pick_all_method(Some(&mut vec![]));\n \n         // In this case unstable picking is done by `pick_method`.\n@@ -1065,11 +1067,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_all_method(\n-        &mut self,\n+        &self,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n-        let steps = self.steps.clone();\n-        steps\n+        self.steps\n             .iter()\n             .filter(|step| {\n                 debug!(\"pick_all_method: step={:?}\", step);\n@@ -1123,7 +1124,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// to transparently pass `&mut` pointers, in particular, without consuming\n     /// them for their entire lifetime.\n     fn pick_by_value_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n@@ -1151,7 +1152,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn pick_autorefd_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         mutbl: hir::Mutability,\n@@ -1177,7 +1178,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// special case for this is because going from `*mut T` to `*const T` with autoderefs and\n     /// autorefs would require dereferencing the pointer, which is not safe.\n     fn pick_const_ptr_method(\n-        &mut self,\n+        &self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n         unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n@@ -1202,7 +1203,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn pick_method_with_unstable(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n+    fn pick_method_with_unstable(&self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_method_with_unstable(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n@@ -1213,7 +1214,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"searching {} candidates\", kind);\n             let res = self.consider_candidates(\n                 self_ty,\n-                candidates.iter(),\n+                candidates,\n                 &mut possibly_unsatisfied_predicates,\n                 Some(&mut vec![]),\n             );\n@@ -1222,21 +1223,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             }\n         }\n \n-        debug!(\"searching unstable candidates\");\n-        let res = self.consider_candidates(\n-            self_ty,\n-            self.inherent_candidates.iter().chain(&self.extension_candidates),\n-            &mut possibly_unsatisfied_predicates,\n-            None,\n-        );\n-        if res.is_none() {\n-            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+        for (kind, candidates) in\n+            &[(\"inherent\", &self.inherent_candidates), (\"extension\", &self.extension_candidates)]\n+        {\n+            debug!(\"searching unstable {kind} candidates\");\n+            let res = self.consider_candidates(\n+                self_ty,\n+                candidates,\n+                &mut possibly_unsatisfied_predicates,\n+                None,\n+            );\n+            if res.is_some() {\n+                return res;\n+            }\n         }\n-        res\n+\n+        self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n+        None\n     }\n \n     fn pick_method(\n-        &mut self,\n+        &self,\n         self_ty: Ty<'tcx>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n     ) -> Option<PickResult<'tcx>> {\n@@ -1254,7 +1261,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"searching {} candidates\", kind);\n             let res = self.consider_candidates(\n                 self_ty,\n-                candidates.iter(),\n+                candidates,\n                 &mut possibly_unsatisfied_predicates,\n                 unstable_candidates.as_deref_mut(),\n             );\n@@ -1266,28 +1273,24 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // `pick_method` may be called twice for the same self_ty if no stable methods\n         // match. Only extend once.\n         if unstable_candidates.is_some() {\n-            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+            self.unsatisfied_predicates.borrow_mut().extend(possibly_unsatisfied_predicates);\n         }\n         None\n     }\n \n-    fn consider_candidates<'b, ProbesIter>(\n+    fn consider_candidates(\n         &self,\n         self_ty: Ty<'tcx>,\n-        probes: ProbesIter,\n+        candidates: &[Candidate<'tcx>],\n         possibly_unsatisfied_predicates: &mut Vec<(\n             ty::Predicate<'tcx>,\n             Option<ty::Predicate<'tcx>>,\n             Option<ObligationCause<'tcx>>,\n         )>,\n         mut unstable_candidates: Option<&mut Vec<(Candidate<'tcx>, Symbol)>>,\n-    ) -> Option<PickResult<'tcx>>\n-    where\n-        ProbesIter: Iterator<Item = &'b Candidate<'tcx>> + Clone,\n-        'tcx: 'b,\n-    {\n-        let mut applicable_candidates: Vec<_> = probes\n-            .clone()\n+    ) -> Option<PickResult<'tcx>> {\n+        let mut applicable_candidates: Vec<_> = candidates\n+            .iter()\n             .map(|probe| {\n                 (probe, self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n             })\n@@ -1305,19 +1308,19 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n \n         if let Some(uc) = &mut unstable_candidates {\n-            applicable_candidates.retain(|&(p, _)| {\n+            applicable_candidates.retain(|&(candidate, _)| {\n                 if let stability::EvalResult::Deny { feature, .. } =\n-                    self.tcx.eval_stability(p.item.def_id, None, self.span, None)\n+                    self.tcx.eval_stability(candidate.item.def_id, None, self.span, None)\n                 {\n-                    uc.push((p.clone(), feature));\n+                    uc.push((candidate.clone(), feature));\n                     return false;\n                 }\n                 true\n             });\n         }\n \n         if applicable_candidates.len() > 1 {\n-            let sources = probes.map(|p| self.candidate_source(p, self_ty)).collect();\n+            let sources = candidates.iter().map(|p| self.candidate_source(p, self_ty)).collect();\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n@@ -1701,7 +1704,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.mode,\n                 self.method_name,\n                 self.return_type,\n-                self.orig_steps_var_values.clone(),\n+                &self.orig_steps_var_values,\n                 steps,\n                 self.scope_expr_id,\n             );\n@@ -1763,8 +1766,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // -- but this could be overcome.\n     }\n \n-    fn record_static_candidate(&mut self, source: CandidateSource) {\n-        self.static_candidates.push(source);\n+    fn record_static_candidate(&self, source: CandidateSource) {\n+        self.static_candidates.borrow_mut().push(source);\n     }\n \n     #[instrument(level = \"debug\", skip(self))]"}, {"sha": "29b5a468bf4c502d582e0d369067b8c50af5eaea", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -16,7 +16,7 @@ panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n libc = { version = \"0.2.138\", default-features = false, features = ['rustc-dep-of-std'] }\n-compiler_builtins = { version = \"0.1.82\" }\n+compiler_builtins = { version = \"0.1.85\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n hashbrown = { version = \"0.12\", default-features = false, features = ['rustc-dep-of-std'] }"}, {"sha": "6be1abc2b080a0164d772b5f6eed32b7f2bc9b9d", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 30, "deletions": 63, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -2,6 +2,7 @@ use crate::cell::UnsafeCell;\n use crate::ptr;\n use crate::sync::atomic::{AtomicPtr, Ordering::Relaxed};\n use crate::sys::locks::{pthread_mutex, Mutex};\n+use crate::sys::time::TIMESPEC_MAX;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n@@ -12,13 +13,6 @@ pub struct Condvar {\n     mutex: AtomicPtr<libc::pthread_mutex_t>,\n }\n \n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n-fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n-}\n-\n #[inline]\n fn raw(c: &Condvar) -> *mut libc::pthread_cond_t {\n     c.inner.0.get()\n@@ -133,26 +127,15 @@ impl Condvar {\n         target_os = \"horizon\"\n     )))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        use crate::mem;\n+        use crate::sys::time::Timespec;\n \n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n-        let mut now: libc::timespec = mem::zeroed();\n-        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n-        assert_eq!(r, 0);\n-\n-        // Nanosecond calculations can't overflow because both values are below 1e9.\n-        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n-\n-        let sec = saturating_cast_to_time_t(dur.as_secs())\n-            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n-            .and_then(|s| s.checked_add(now.tv_sec));\n-        let nsec = nsec % 1_000_000_000;\n-\n-        let timeout =\n-            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n-\n+        let timeout = Timespec::now(libc::CLOCK_MONOTONIC)\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec())\n+            .unwrap_or(TIMESPEC_MAX);\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n@@ -169,57 +152,41 @@ impl Condvar {\n         target_os = \"espidf\",\n         target_os = \"horizon\"\n     ))]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        use crate::sys::time::SystemTime;\n         use crate::time::Instant;\n \n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n-        // 1000 years\n-        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n-\n-        if dur > max_dur {\n-            // OSX implementation of `pthread_cond_timedwait` is buggy\n-            // with super long durations. When duration is greater than\n-            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n-            // in macOS Sierra return error 316.\n-            //\n-            // This program demonstrates the issue:\n-            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n-            //\n-            // To work around this issue, and possible bugs of other OSes, timeout\n-            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n-            // because of spurious wakeups.\n-\n-            dur = max_dur;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and\n-        // stable time.  pthread_cond_timedwait uses system time, but we want to\n-        // report timeout based on stable time.\n-        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let stable_now = Instant::now();\n-        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n-        assert_eq!(r, 0, \"unexpected error: {:?}\", crate::io::Error::last_os_error());\n-\n-        let nsec = dur.subsec_nanos() as libc::c_long + (sys_now.tv_usec * 1000) as libc::c_long;\n-        let extra = (nsec / 1_000_000_000) as libc::time_t;\n-        let nsec = nsec % 1_000_000_000;\n-        let seconds = saturating_cast_to_time_t(dur.as_secs());\n-\n-        let timeout = sys_now\n-            .tv_sec\n-            .checked_add(extra)\n-            .and_then(|s| s.checked_add(seconds))\n-            .map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec })\n+        // OSX implementation of `pthread_cond_timedwait` is buggy\n+        // with super long durations. When duration is greater than\n+        // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+        // in macOS Sierra returns error 316.\n+        //\n+        // This program demonstrates the issue:\n+        // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+        //\n+        // To work around this issue, and possible bugs of other OSes, timeout\n+        // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n+        // because of spurious wakeups.\n+        let dur = Duration::min(dur, Duration::from_secs(1000 * 365 * 86400));\n+\n+        // pthread_cond_timedwait uses system time, but we want to report timeout\n+        // based on stable time.\n+        let now = Instant::now();\n+\n+        let timeout = SystemTime::now()\n+            .t\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec())\n             .unwrap_or(TIMESPEC_MAX);\n \n-        // And wait!\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n         // ETIMEDOUT is not a totally reliable method of determining timeout due\n         // to clock shifts, so do the check ourselves\n-        stable_now.elapsed() < dur\n+        now.elapsed() < dur\n     }\n }"}, {"sha": "c400c7715676f7856d47e3be8ed83e0c839cd340", "filename": "library/std/src/sys/unix/thread_parker/pthread.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -6,6 +6,7 @@ use crate::pin::Pin;\n use crate::ptr::addr_of_mut;\n use crate::sync::atomic::AtomicUsize;\n use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sys::time::TIMESPEC_MAX;\n use crate::time::Duration;\n \n const EMPTY: usize = 0;\n@@ -32,9 +33,6 @@ unsafe fn wait(cond: *mut libc::pthread_cond_t, lock: *mut libc::pthread_mutex_t\n     debug_assert_eq!(r, 0);\n }\n \n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n unsafe fn wait_timeout(\n     cond: *mut libc::pthread_cond_t,\n     lock: *mut libc::pthread_mutex_t,"}, {"sha": "2daad981b73e9a94af6e3b3f779b029d4026076e", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -5,6 +5,9 @@ pub use self::inner::Instant;\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n+#[allow(dead_code)] // Used for pthread condvar timeouts\n+pub const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[repr(transparent)]"}, {"sha": "24b033cc0dc5eb4f6e63104efc065a507d35a114", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -747,19 +747,9 @@ impl Step for RustAnalyzerProcMacroSrv {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-\n         // Allow building `rust-analyzer-proc-macro-srv` both as part of the `rust-analyzer` and as a stand-alone tool.\n         run.path(\"src/tools/rust-analyzer\")\n             .path(\"src/tools/rust-analyzer/crates/proc-macro-srv-cli\")\n-            .default_condition(\n-                builder.config.extended\n-                    && builder.config.tools.as_ref().map_or(true, |tools| {\n-                        tools.iter().any(|tool| {\n-                            tool == \"rust-analyzer\" || tool == \"rust-analyzer-proc-macro-srv\"\n-                        })\n-                    }),\n-            )\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "8a9e6caf611bad111308874cd8bd3d7685cb130d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -21,15 +21,15 @@ use rustc_span::{BytePos, Span, DUMMY_SP};\n use super::format::{self, Buffer};\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-pub(crate) struct HrefContext<'a, 'b, 'c> {\n-    pub(crate) context: &'a Context<'b>,\n+pub(crate) struct HrefContext<'a, 'tcx> {\n+    pub(crate) context: &'a Context<'tcx>,\n     /// This span contains the current file we're going through.\n     pub(crate) file_span: Span,\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n-    pub(crate) root_path: &'c str,\n+    pub(crate) root_path: &'a str,\n     /// This field is used to calculate precise local URLs.\n-    pub(crate) current_href: &'c str,\n+    pub(crate) current_href: String,\n }\n \n /// Decorations are represented as a map from CSS class to vector of character ranges.\n@@ -70,7 +70,7 @@ pub(crate) fn render_source_with_highlighting(\n     src: &str,\n     out: &mut Buffer,\n     line_numbers: Buffer,\n-    href_context: HrefContext<'_, '_, '_>,\n+    href_context: HrefContext<'_, '_>,\n     decoration_info: DecorationInfo,\n     extra: Option<&str>,\n ) {\n@@ -137,7 +137,7 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n \n /// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n /// the various functions (which became its methods).\n-struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+struct TokenHandler<'a, 'tcx> {\n     out: &'a mut Buffer,\n     /// It contains the closing tag and the associated `Class`.\n     closing_tags: Vec<(&'static str, Class)>,\n@@ -149,11 +149,11 @@ struct TokenHandler<'a, 'b, 'c, 'd, 'e> {\n     current_class: Option<Class>,\n     /// We need to keep the `Class` for each element because it could contain a `Span` which is\n     /// used to generate links.\n-    pending_elems: Vec<(&'b str, Option<Class>)>,\n-    href_context: Option<HrefContext<'c, 'd, 'e>>,\n+    pending_elems: Vec<(&'a str, Option<Class>)>,\n+    href_context: Option<HrefContext<'a, 'tcx>>,\n }\n \n-impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n     fn handle_exit_span(&mut self) {\n         // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n         // being used in `write_pending_elems`.\n@@ -205,7 +205,7 @@ impl<'a, 'b, 'c, 'd, 'e> TokenHandler<'a, 'b, 'c, 'd, 'e> {\n     }\n }\n \n-impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n+impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n     /// When leaving, we need to flush all pending data to not have missing content.\n     fn drop(&mut self) {\n         if self.pending_exit_span.is_some() {\n@@ -230,7 +230,7 @@ impl<'a, 'b, 'c, 'd, 'e> Drop for TokenHandler<'a, 'b, 'c, 'd, 'e> {\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n-    href_context: Option<HrefContext<'_, '_, '_>>,\n+    href_context: Option<HrefContext<'_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n@@ -514,18 +514,18 @@ impl Decorations {\n \n /// Processes program tokens, classifying strings of text by highlighting\n /// category (`Class`).\n-struct Classifier<'a> {\n-    tokens: PeekIter<'a>,\n+struct Classifier<'src> {\n+    tokens: PeekIter<'src>,\n     in_attribute: bool,\n     in_macro: bool,\n     in_macro_nonterminal: bool,\n     byte_pos: u32,\n     file_span: Span,\n-    src: &'a str,\n+    src: &'src str,\n     decorations: Option<Decorations>,\n }\n \n-impl<'a> Classifier<'a> {\n+impl<'src> Classifier<'src> {\n     /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n     /// file span which will be used later on by the `span_correspondance_map`.\n     fn new(src: &str, file_span: Span, decoration_info: Option<DecorationInfo>) -> Classifier<'_> {\n@@ -603,7 +603,7 @@ impl<'a> Classifier<'a> {\n     ///\n     /// It returns the token's kind, the token as a string and its byte position in the source\n     /// string.\n-    fn next(&mut self) -> Option<(TokenKind, &'a str, u32)> {\n+    fn next(&mut self) -> Option<(TokenKind, &'src str, u32)> {\n         if let Some((kind, text)) = self.tokens.next() {\n             let before = self.byte_pos;\n             self.byte_pos += text.len() as u32;\n@@ -618,7 +618,7 @@ impl<'a> Classifier<'a> {\n     /// The general structure for this method is to iterate over each token,\n     /// possibly giving it an HTML span with a class specifying what flavor of\n     /// token is used.\n-    fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'a>)) {\n+    fn highlight(mut self, sink: &mut dyn FnMut(Highlight<'src>)) {\n         loop {\n             if let Some(decs) = self.decorations.as_mut() {\n                 let byte_pos = self.byte_pos;\n@@ -666,8 +666,8 @@ impl<'a> Classifier<'a> {\n     fn advance(\n         &mut self,\n         token: TokenKind,\n-        text: &'a str,\n-        sink: &mut dyn FnMut(Highlight<'a>),\n+        text: &'src str,\n+        sink: &mut dyn FnMut(Highlight<'src>),\n         before: u32,\n     ) {\n         let lookahead = self.peek();\n@@ -881,7 +881,7 @@ impl<'a> Classifier<'a> {\n fn enter_span(\n     out: &mut Buffer,\n     klass: Class,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n ) -> &'static str {\n     string_without_closing_tag(out, \"\", Some(klass), href_context, true).expect(\n         \"internal error: enter_span was called with Some(klass) but did not return a \\\n@@ -914,7 +914,7 @@ fn string<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) {\n     if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n@@ -936,7 +936,7 @@ fn string_without_closing_tag<T: Display>(\n     out: &mut Buffer,\n     text: T,\n     klass: Option<Class>,\n-    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n@@ -985,7 +985,7 @@ fn string_without_closing_tag<T: Display>(\n                 // https://github.com/rust-lang/rust/blob/60f1a2fc4b535ead9c85ce085fdce49b1b097531/src/librustdoc/html/render/context.rs#L315-L338\n                 match href {\n                     LinkFromSrc::Local(span) => {\n-                        context.href_from_span_relative(*span, href_context.current_href)\n+                        context.href_from_span_relative(*span, &href_context.current_href)\n                     }\n                     LinkFromSrc::External(def_id) => {\n                         format::href_with_root_path(*def_id, context, Some(href_context.root_path))"}, {"sha": "e639fadeb96733ddb5848e6ef9c677614eaaa5b0", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -276,7 +276,7 @@ pub(crate) fn print_src(\n     let mut line_numbers = Buffer::empty_from(buf);\n     let extra;\n     line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n-    let current_href = &context\n+    let current_href = context\n         .href_from_span(clean::Span::new(file_span), false)\n         .expect(\"only local crates should have sources emitted\");\n     match source_context {"}, {"sha": "19e8334fc1aa30bf5d753edb1e5b8a94016824e2", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1c91213ff80af5b87a197b784b40bcbc8cf3add/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1c91213ff80af5b87a197b784b40bcbc8cf3add/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=e1c91213ff80af5b87a197b784b40bcbc8cf3add", "patch": "@@ -469,6 +469,7 @@ compiler-team-contributors = [\n     \"@jackh726\",\n     \"@fee1-dead\",\n     \"@TaKO8Ki\",\n+    \"@Nilstrieb\",\n ]\n compiler = [\n     \"compiler-team\","}]}