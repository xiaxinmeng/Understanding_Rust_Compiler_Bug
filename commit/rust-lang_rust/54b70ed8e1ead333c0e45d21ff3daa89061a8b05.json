{"sha": "54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YjcwZWQ4ZTFlYWQzMzNjMGU0NWQyMWZmM2RhYTg5MDYxYThiMDU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-03T14:49:25Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-03T16:04:08Z"}, "message": "Move eq_op::is_exp_equal to utils", "tree": {"sha": "6fff8d0312190e3df0ef32facb1d12f617c78f5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fff8d0312190e3df0ef32facb1d12f617c78f5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "html_url": "https://github.com/rust-lang/rust/commit/54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c6e385493407815068b9ca618a0baa09ad20d08", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6e385493407815068b9ca618a0baa09ad20d08", "html_url": "https://github.com/rust-lang/rust/commit/0c6e385493407815068b9ca618a0baa09ad20d08"}], "stats": {"total": 143, "additions": 71, "deletions": 72}, "files": [{"sha": "3d2f32e6c7fbbcee3a38d7dc71a214af03b8cd6c", "filename": "src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 70, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "patch": "@@ -1,10 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use rustc_front::util as ast_util;\n-use syntax::ptr::P;\n \n-use consts::constant;\n-use utils::span_lint;\n+use utils::{is_exp_equal, span_lint};\n \n /// **What it does:** This lint checks for equal operands to comparisons and bitwise binary operators (`&`, `|` and `^`). It is `Warn` by default.\n ///\n@@ -40,57 +38,6 @@ impl LateLintPass for EqOp {\n     }\n }\n \n-pub fn is_exp_equal(cx: &LateContext, left : &Expr, right : &Expr) -> bool {\n-    if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n-        if l == r {\n-            return true;\n-        }\n-    }\n-    match (&left.node, &right.node) {\n-        (&ExprField(ref lfexp, ref lfident),\n-                &ExprField(ref rfexp, ref rfident)) =>\n-            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n-        (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprPath(ref lqself, ref lsubpath),\n-                &ExprPath(ref rqself, ref rsubpath)) =>\n-            both(lqself, rqself, is_qself_equal) &&\n-                is_path_equal(lsubpath, rsubpath),\n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n-            is_exps_equal(cx, ltup, rtup),\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n-        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) =>\n-            is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n-        _ => false\n-    }\n-}\n-\n-fn is_exps_equal(cx: &LateContext, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n-    over(left, right, |l, r| is_exp_equal(cx, l, r))\n-}\n-\n-fn is_path_equal(left : &Path, right : &Path) -> bool {\n-    // The == of idents doesn't work with different contexts,\n-    // we have to be explicit about hygiene\n-    left.global == right.global && over(&left.segments, &right.segments,\n-        |l, r| l.identifier.name == r.identifier.name\n-               && l.parameters == r.parameters)\n-}\n-\n-fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n-    left.ty.node == right.ty.node && left.position == right.position\n-}\n-\n-fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-        where F: FnMut(&X, &X) -> bool {\n-    left.len() == right.len() && left.iter().zip(right).all(|(x, y)|\n-        eq_fn(x, y))\n-}\n-\n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool\n-        where F: FnMut(&X, &X) -> bool {\n-    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n-        |y| eq_fn(x, y)))\n-}\n \n fn is_cmp_or_bit(op : &BinOp) -> bool {\n     match op.node {\n@@ -99,19 +46,3 @@ fn is_cmp_or_bit(op : &BinOp) -> bool {\n         _ => false\n     }\n }\n-\n-fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n-    match (&left.node, &right.node) {\n-        (&TyVec(ref lvec), &TyVec(ref rvec)) => is_cast_ty_equal(lvec, rvec),\n-        (&TyPtr(ref lmut), &TyPtr(ref rmut)) =>\n-            lmut.mutbl == rmut.mutbl &&\n-            is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n-        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) =>\n-            lrmut.mutbl == rrmut.mutbl &&\n-            is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty),\n-        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n-            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n-        (&TyInfer, &TyInfer) => true,\n-        _ => false\n-    }\n-}"}, {"sha": "2baf26095b7975170ed1c70de0abf3b2a2ae3483", "filename": "src/strings.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "patch": "@@ -7,8 +7,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n \n-use eq_op::is_exp_equal;\n-use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{is_exp_equal, match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n use utils::STRING_PATH;\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!). It is `Allow` by default."}, {"sha": "1b6c75a3b78aedea21af9d8dfcd50d398e8b7135", "filename": "src/utils.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b70ed8e1ead333c0e45d21ff3daa89061a8b05/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=54b70ed8e1ead333c0e45d21ff3daa89061a8b05", "patch": "@@ -10,6 +10,7 @@ use syntax::ast::Lit_::*;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n+use consts::constant;\n \n use rustc::session::Session;\n use std::str::FromStr;\n@@ -493,3 +494,71 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         }\n     }\n }\n+\n+pub fn is_exp_equal(cx: &LateContext, left : &Expr, right : &Expr) -> bool {\n+    if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n+        if l == r {\n+            return true;\n+        }\n+    }\n+    match (&left.node, &right.node) {\n+        (&ExprField(ref lfexp, ref lfident),\n+                &ExprField(ref rfexp, ref rfident)) =>\n+            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp),\n+        (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n+        (&ExprPath(ref lqself, ref lsubpath),\n+                &ExprPath(ref rqself, ref rsubpath)) =>\n+            both(lqself, rqself, is_qself_equal) &&\n+                is_path_equal(lsubpath, rsubpath),\n+        (&ExprTup(ref ltup), &ExprTup(ref rtup)) =>\n+            is_exps_equal(cx, ltup, rtup),\n+        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n+        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) =>\n+            is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n+        _ => false\n+    }\n+}\n+\n+fn is_exps_equal(cx: &LateContext, left : &[P<Expr>], right : &[P<Expr>]) -> bool {\n+    over(left, right, |l, r| is_exp_equal(cx, l, r))\n+}\n+\n+fn is_path_equal(left : &Path, right : &Path) -> bool {\n+    // The == of idents doesn't work with different contexts,\n+    // we have to be explicit about hygiene\n+    left.global == right.global && over(&left.segments, &right.segments,\n+        |l, r| l.identifier.name == r.identifier.name\n+               && l.parameters == r.parameters)\n+}\n+\n+fn is_qself_equal(left : &QSelf, right : &QSelf) -> bool {\n+    left.ty.node == right.ty.node && left.position == right.position\n+}\n+\n+fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n+        where F: FnMut(&X, &X) -> bool {\n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)|\n+        eq_fn(x, y))\n+}\n+\n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn : F) -> bool\n+        where F: FnMut(&X, &X) -> bool {\n+    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false,\n+        |y| eq_fn(x, y)))\n+}\n+\n+fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n+    match (&left.node, &right.node) {\n+        (&TyVec(ref lvec), &TyVec(ref rvec)) => is_cast_ty_equal(lvec, rvec),\n+        (&TyPtr(ref lmut), &TyPtr(ref rmut)) =>\n+            lmut.mutbl == rmut.mutbl &&\n+            is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n+        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) =>\n+            lrmut.mutbl == rrmut.mutbl &&\n+            is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty),\n+        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) =>\n+            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath),\n+        (&TyInfer, &TyInfer) => true,\n+        _ => false\n+    }\n+}"}]}