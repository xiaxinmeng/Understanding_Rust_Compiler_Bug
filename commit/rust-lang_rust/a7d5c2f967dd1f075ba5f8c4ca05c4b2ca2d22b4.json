{"sha": "a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZDVjMmY5NjdkZDFmMDc1YmE1ZjhjNGNhMDVjNGIyY2EyZDIyYjQ=", "commit": {"author": {"name": "jrqc", "email": "jrqc01@hotmail.com", "date": "2020-08-13T16:24:34Z"}, "committer": {"name": "jrqc", "email": "jrqc01@hotmail.com", "date": "2020-08-15T21:24:27Z"}, "message": "Modifications according to the code review", "tree": {"sha": "9f7854bc4a03b9e1c6e602c29df46e2cdda72767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f7854bc4a03b9e1c6e602c29df46e2cdda72767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "html_url": "https://github.com/rust-lang/rust/commit/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/comments", "author": {"login": "jrqc", "id": 14986914, "node_id": "MDQ6VXNlcjE0OTg2OTE0", "avatar_url": "https://avatars.githubusercontent.com/u/14986914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrqc", "html_url": "https://github.com/jrqc", "followers_url": "https://api.github.com/users/jrqc/followers", "following_url": "https://api.github.com/users/jrqc/following{/other_user}", "gists_url": "https://api.github.com/users/jrqc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrqc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrqc/subscriptions", "organizations_url": "https://api.github.com/users/jrqc/orgs", "repos_url": "https://api.github.com/users/jrqc/repos", "events_url": "https://api.github.com/users/jrqc/events{/privacy}", "received_events_url": "https://api.github.com/users/jrqc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jrqc", "id": 14986914, "node_id": "MDQ6VXNlcjE0OTg2OTE0", "avatar_url": "https://avatars.githubusercontent.com/u/14986914?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrqc", "html_url": "https://github.com/jrqc", "followers_url": "https://api.github.com/users/jrqc/followers", "following_url": "https://api.github.com/users/jrqc/following{/other_user}", "gists_url": "https://api.github.com/users/jrqc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrqc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrqc/subscriptions", "organizations_url": "https://api.github.com/users/jrqc/orgs", "repos_url": "https://api.github.com/users/jrqc/repos", "events_url": "https://api.github.com/users/jrqc/events{/privacy}", "received_events_url": "https://api.github.com/users/jrqc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6ca72e0e4040a5c3a6623c2e8533db91db6042", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6ca72e0e4040a5c3a6623c2e8533db91db6042", "html_url": "https://github.com/rust-lang/rust/commit/cd6ca72e0e4040a5c3a6623c2e8533db91db6042"}], "stats": {"total": 887, "additions": 425, "deletions": 462}, "files": [{"sha": "fa560ffb980c82407d748018b6b12717c7572267", "filename": "clippy_lints/src/let_and_return.rs", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cd6ca72e0e4040a5c3a6623c2e8533db91db6042/clippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6ca72e0e4040a5c3a6623c2e8533db91db6042/clippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_and_return.rs?ref=cd6ca72e0e4040a5c3a6623c2e8533db91db6042", "patch": "@@ -1,124 +0,0 @@\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_then};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `let`-bindings, which are subsequently\n-    /// returned.\n-    ///\n-    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo() -> String {\n-    ///     let x = String::new();\n-    ///     x\n-    /// }\n-    /// ```\n-    /// instead, use\n-    /// ```\n-    /// fn foo() -> String {\n-    ///     String::new()\n-    /// }\n-    /// ```\n-    pub LET_AND_RETURN,\n-    style,\n-    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n-}\n-\n-declare_lint_pass!(LetReturn => [LET_AND_RETURN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LetReturn {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        // we need both a let-binding stmt and an expr\n-        if_chain! {\n-            if let Some(retexpr) = block.expr;\n-            if let Some(stmt) = block.stmts.iter().last();\n-            if let StmtKind::Local(local) = &stmt.kind;\n-            if local.ty.is_none();\n-            if local.attrs.is_empty();\n-            if let Some(initexpr) = &local.init;\n-            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n-            if let ExprKind::Path(qpath) = &retexpr.kind;\n-            if match_qpath(qpath, &[&*ident.name.as_str()]);\n-            if !last_statement_borrows(cx, initexpr);\n-            if !in_external_macro(cx.sess(), initexpr.span);\n-            if !in_external_macro(cx.sess(), retexpr.span);\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    LET_AND_RETURN,\n-                    retexpr.span,\n-                    \"returning the result of a `let` binding from a block\",\n-                    |err| {\n-                        err.span_label(local.span, \"unnecessary `let` binding\");\n-\n-                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n-                            err.multipart_suggestion(\n-                                \"return the expression directly\",\n-                                vec![\n-                                    (local.span, String::new()),\n-                                    (retexpr.span, snippet),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n-                .tcx\n-                .fn_sig(def_id)\n-                .output()\n-                .skip_binder()\n-                .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "63de0f8a0c222b912454b25340571fd38cf75773", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "patch": "@@ -218,7 +218,6 @@ mod large_const_arrays;\n mod large_enum_variant;\n mod large_stack_arrays;\n mod len_zero;\n-mod let_and_return;\n mod let_if_seq;\n mod let_underscore;\n mod lifetimes;\n@@ -256,7 +255,6 @@ mod needless_borrow;\n mod needless_borrowed_ref;\n mod needless_continue;\n mod needless_pass_by_value;\n-mod needless_return;\n mod needless_update;\n mod neg_cmp_op_on_partial_ord;\n mod neg_multiply;\n@@ -311,6 +309,7 @@ mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n+mod unused_unit;\n mod unwrap;\n mod use_self;\n mod useless_conversion;\n@@ -587,7 +586,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &large_stack_arrays::LARGE_STACK_ARRAYS,\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n-        &let_and_return::LET_AND_RETURN,\n+        &returns::LET_AND_RETURN,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n         &let_underscore::LET_UNDERSCORE_LOCK,\n         &let_underscore::LET_UNDERSCORE_MUST_USE,\n@@ -727,7 +726,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE,\n         &needless_continue::NEEDLESS_CONTINUE,\n         &needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n-        &needless_return::NEEDLESS_RETURN,\n+        &returns::NEEDLESS_RETURN,\n         &needless_update::NEEDLESS_UPDATE,\n         &neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD,\n         &neg_multiply::NEG_MULTIPLY,\n@@ -771,7 +770,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &regex::INVALID_REGEX,\n         &regex::TRIVIAL_REGEX,\n         &repeat_once::REPEAT_ONCE,\n-        &returns::UNUSED_UNIT,\n+        &unused_unit::UNUSED_UNIT,\n         &serde_api::SERDE_API_MISUSE,\n         &shadow::SHADOW_REUSE,\n         &shadow::SHADOW_SAME,\n@@ -1026,9 +1025,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box misc_early::MiscEarlyLints);\n     store.register_early_pass(|| box redundant_closure_call::RedundantClosureCall);\n     store.register_late_pass(|| box redundant_closure_call::RedundantClosureCall);\n-    store.register_early_pass(|| box returns::Return);\n-    store.register_late_pass(|| box let_and_return::LetReturn);\n-    store.register_late_pass(|| box needless_return::NeedlessReturn);\n+    store.register_early_pass(|| box unused_unit::UnusedUnit);\n+    store.register_late_pass(|| box returns::Return);\n     store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n@@ -1286,7 +1284,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n@@ -1383,7 +1381,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n-        LintId::of(&needless_return::NEEDLESS_RETURN),\n+        LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&needless_update::NEEDLESS_UPDATE),\n         LintId::of(&neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n@@ -1416,7 +1414,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&repeat_once::REPEAT_ONCE),\n-        LintId::of(&returns::UNUSED_UNIT),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n@@ -1502,7 +1500,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n-        LintId::of(&let_and_return::LET_AND_RETURN),\n+        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1545,7 +1543,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc_early::MIXED_CASE_HEX_LITERALS),\n         LintId::of(&misc_early::REDUNDANT_PATTERN),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n-        LintId::of(&needless_return::NEEDLESS_RETURN),\n+        LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&neg_multiply::NEG_MULTIPLY),\n         LintId::of(&new_without_default::NEW_WITHOUT_DEFAULT),\n         LintId::of(&non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n@@ -1557,7 +1555,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n-        LintId::of(&returns::UNUSED_UNIT),\n+        LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),"}, {"sha": "eb0bf12c0ab58478c33fe9330f4378bd206e818b", "filename": "clippy_lints/src/needless_return.rs", "status": "removed", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/cd6ca72e0e4040a5c3a6623c2e8533db91db6042/clippy_lints%2Fsrc%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6ca72e0e4040a5c3a6623c2e8533db91db6042/clippy_lints%2Fsrc%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_return.rs?ref=cd6ca72e0e4040a5c3a6623c2e8533db91db6042", "patch": "@@ -1,223 +0,0 @@\n-use rustc_ast::ast::Attribute;\n-use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-use crate::utils::{fn_def_id, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for return statements at the end of a block.\n-    ///\n-    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     return x;\n-    /// }\n-    /// ```\n-    /// simplify to\n-    /// ```rust\n-    /// fn foo(x: usize) -> usize {\n-    ///     x\n-    /// }\n-    /// ```\n-    pub NEEDLESS_RETURN,\n-    style,\n-    \"using a return statement like `return expr;` where an expression would suffice\"\n-}\n-\n-#[derive(PartialEq, Eq, Copy, Clone)]\n-enum RetReplacement {\n-    Empty,\n-    Block,\n-}\n-\n-declare_lint_pass!(NeedlessReturn => [NEEDLESS_RETURN]);\n-\n-impl<'tcx> LateLintPass<'tcx> for NeedlessReturn {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        _: &'tcx FnDecl<'tcx>,\n-        body: &'tcx Body<'tcx>,\n-        _: Span,\n-        _: HirId,\n-    ) {\n-        match kind {\n-            FnKind::Closure(_) => {\n-                if !last_statement_borrows(cx, &body.value) {\n-                    check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty)\n-                }\n-            },\n-            FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                if let ExprKind::Block(ref block, _) = body.value.kind {\n-                    if let Some(expr) = block.expr {\n-                        if !last_statement_borrows(cx, expr) {\n-                            check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n-                        }\n-                    } else if let Some(stmt) = block.stmts.iter().last() {\n-                        match stmt.kind {\n-                            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n-                                if !last_statement_borrows(cx, expr) {\n-                                    check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-                                }\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-fn attr_is_cfg(attr: &Attribute) -> bool {\n-    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n-}\n-\n-fn check_block_return(cx: &LateContext<'_>, block: &Block<'_>) {\n-    if let Some(expr) = block.expr {\n-        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n-    } else if let Some(stmt) = block.stmts.iter().last() {\n-        match stmt.kind {\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n-                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_final_expr(cx: &LateContext<'_>, expr: &Expr<'_>, span: Option<Span>, replacement: RetReplacement) {\n-    match expr.kind {\n-        // simple return is always \"bad\"\n-        ExprKind::Ret(ref inner) => {\n-            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n-            if !expr.attrs.iter().any(attr_is_cfg) {\n-                emit_return_lint(\n-                    cx,\n-                    span.expect(\"`else return` is not possible\"),\n-                    inner.as_ref().map(|i| i.span),\n-                    replacement,\n-                );\n-            }\n-        },\n-        // a whole block? check it!\n-        ExprKind::Block(ref block, _) => {\n-            check_block_return(cx, block);\n-        },\n-        // a match expr, check all arms\n-        // an if/if let expr, check both exprs\n-        // note, if without else is going to be a type checking error anyways\n-        // (except for unit type functions) so we don't match it\n-        ExprKind::Match(_, ref arms, source) => match source {\n-            MatchSource::Normal => {\n-                for arm in arms.iter() {\n-                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n-                }\n-            },\n-            MatchSource::IfDesugar {\n-                contains_else_clause: true,\n-            }\n-            | MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            } => {\n-                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n-                    check_block_return(cx, ifblock);\n-                }\n-                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n-            },\n-            _ => (),\n-        },\n-        _ => (),\n-    }\n-}\n-\n-fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n-    match inner_span {\n-        Some(inner_span) => {\n-            if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {\n-                return;\n-            }\n-\n-            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n-                if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n-                }\n-            })\n-        },\n-        None => match replacement {\n-            RetReplacement::Empty => {\n-                span_lint_and_sugg(\n-                    cx,\n-                    NEEDLESS_RETURN,\n-                    ret_span,\n-                    \"unneeded `return` statement\",\n-                    \"remove `return`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                );\n-            },\n-            RetReplacement::Block => {\n-                span_lint_and_sugg(\n-                    cx,\n-                    NEEDLESS_RETURN,\n-                    ret_span,\n-                    \"unneeded `return` statement\",\n-                    \"replace `return` with an empty block\",\n-                    \"{}\".to_string(),\n-                    Applicability::MachineApplicable,\n-                );\n-            },\n-        },\n-    }\n-}\n-\n-fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    let mut visitor = BorrowVisitor { cx, borrows: false };\n-    walk_expr(&mut visitor, expr);\n-    visitor.borrows\n-}\n-\n-struct BorrowVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    borrows: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.borrows {\n-            return;\n-        }\n-\n-        if let Some(def_id) = fn_def_id(self.cx, expr) {\n-            self.borrows = self\n-                .cx\n-                .tcx\n-                .fn_sig(def_id)\n-                .output()\n-                .skip_binder()\n-                .walk()\n-                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}"}, {"sha": "4d91f9be999648dd8ae508dac57a6835b2e95e02", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 246, "deletions": 101, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "patch": "@@ -1,145 +1,290 @@\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_ast::visit::FnKind;\n+use rustc_ast::ast::Attribute;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::intravisit::{walk_expr, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, PatKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n \n-use crate::utils::span_lint_and_sugg;\n+use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n     ///\n-    /// **Why is this bad?** Such expressions add no value, but can make the code\n-    /// less readable. Depending on formatting they can make a `break` or `return`\n-    /// statement look like a function call.\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n+    /// more rusty.\n     ///\n-    /// **Known problems:** The lint currently misses unit return types in types,\n-    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn return_unit() -> () {\n-    ///     ()\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n     /// }\n     /// ```\n-    pub UNUSED_UNIT,\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n+    /// }\n+    /// ```\n+    pub LET_AND_RETURN,\n     style,\n-    \"needless unit expression\"\n+    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n }\n \n-declare_lint_pass!(Return => [UNUSED_UNIT]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for return statements at the end of a block.\n+    ///\n+    /// **Why is this bad?** Removing the `return` and semicolon will make the code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     return x;\n+    /// }\n+    /// ```\n+    /// simplify to\n+    /// ```rust\n+    /// fn foo(x: usize) -> usize {\n+    ///     x\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RETURN,\n+    style,\n+    \"using a return statement like `return expr;` where an expression would suffice\"\n+}\n \n-impl EarlyLintPass for Return {\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n-        if_chain! {\n-            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n-            if let ast::TyKind::Tup(ref vals) = ty.kind;\n-            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n-            then {\n-                lint_unneeded_unit_return(cx, ty, span);\n-            }\n-        }\n-    }\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+enum RetReplacement {\n+    Empty,\n+    Block,\n+}\n+\n+declare_lint_pass!(Return => [LET_AND_RETURN, NEEDLESS_RETURN]);\n \n-    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+impl<'tcx> LateLintPass<'tcx> for Return {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        // we need both a let-binding stmt and an expr\n         if_chain! {\n-            if let Some(ref stmt) = block.stmts.last();\n-            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n-            if is_unit_expr(expr) && !stmt.span.from_expansion();\n+            if let Some(retexpr) = block.expr;\n+            if let Some(stmt) = block.stmts.iter().last();\n+            if let StmtKind::Local(local) = &stmt.kind;\n+            if local.ty.is_none();\n+            if local.attrs.is_empty();\n+            if let Some(initexpr) = &local.init;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            if let ExprKind::Path(qpath) = &retexpr.kind;\n+            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if !last_statement_borrows(cx, initexpr);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n+            if !in_external_macro(cx.sess(), retexpr.span);\n+            if !in_external_macro(cx.sess(), local.span);\n+            if !in_macro(local.span);\n             then {\n-                let sp = expr.span;\n-                span_lint_and_sugg(\n+                span_lint_and_then(\n                     cx,\n-                    UNUSED_UNIT,\n-                    sp,\n-                    \"unneeded unit expression\",\n-                    \"remove the final `()`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n+                    LET_AND_RETURN,\n+                    retexpr.span,\n+                    \"returning the result of a `let` binding from a block\",\n+                    |err| {\n+                        err.span_label(local.span, \"unnecessary `let` binding\");\n+\n+                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n+                            err.multipart_suggestion(\n+                                \"return the expression directly\",\n+                                vec![\n+                                    (local.span, String::new()),\n+                                    (retexpr.span, snippet),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n+                        }\n+                    },\n                 );\n             }\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        match e.kind {\n-            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n-                if is_unit_expr(expr) && !expr.span.from_expansion() {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        UNUSED_UNIT,\n-                        expr.span,\n-                        \"unneeded `()`\",\n-                        \"remove the `()`\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        _: &'tcx FnDecl<'tcx>,\n+        body: &'tcx Body<'tcx>,\n+        _: Span,\n+        _: HirId,\n+    ) {\n+        match kind {\n+            FnKind::Closure(_) => check_final_expr(cx, &body.value, Some(body.value.span), RetReplacement::Empty),\n+            FnKind::ItemFn(..) | FnKind::Method(..) => {\n+                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                    check_block_return(cx, block);\n                 }\n             },\n-            _ => (),\n         }\n     }\n+}\n \n-    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n-        let segments = &poly.trait_ref.path.segments;\n+fn attr_is_cfg(attr: &Attribute) -> bool {\n+    attr.meta_item_list().is_some() && attr.has_name(sym!(cfg))\n+}\n \n-        if_chain! {\n-            if segments.len() == 1;\n-            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n-            if let Some(args) = &segments[0].args;\n-            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n-            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n-            if ty.kind.is_unit();\n-            then {\n-                lint_unneeded_unit_return(cx, ty, generic_args.span);\n-            }\n+fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+    if let Some(expr) = block.expr {\n+        check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n+    } else if let Some(stmt) = block.stmts.iter().last() {\n+        match stmt.kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n+            },\n+            _ => (),\n         }\n     }\n }\n \n-// get the def site\n-#[must_use]\n-fn get_def(span: Span) -> Option<Span> {\n-    if span.from_expansion() {\n-        Some(span.ctxt().outer_expn_data().def_site)\n-    } else {\n-        None\n+fn check_final_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    span: Option<Span>,\n+    replacement: RetReplacement,\n+) {\n+    if last_statement_borrows(cx, expr) {\n+        return;\n     }\n-}\n \n-// is this expr a `()` unit?\n-fn is_unit_expr(expr: &ast::Expr) -> bool {\n-    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n-        vals.is_empty()\n-    } else {\n-        false\n+    match expr.kind {\n+        // simple return is always \"bad\"\n+        ExprKind::Ret(ref inner) => {\n+            // allow `#[cfg(a)] return a; #[cfg(b)] return b;`\n+            if !expr.attrs.iter().any(attr_is_cfg) {\n+                let borrows = inner.map_or(false, |inner| last_statement_borrows(cx, inner));\n+                if !borrows {\n+                    emit_return_lint(\n+                        cx,\n+                        span.expect(\"`else return` is not possible\"),\n+                        inner.as_ref().map(|i| i.span),\n+                        replacement,\n+                    );\n+                }\n+            }\n+        },\n+        // a whole block? check it!\n+        ExprKind::Block(ref block, _) => {\n+            check_block_return(cx, block);\n+        },\n+        // a match expr, check all arms\n+        // an if/if let expr, check both exprs\n+        // note, if without else is going to be a type checking error anyways\n+        // (except for unit type functions) so we don't match it\n+        ExprKind::Match(_, ref arms, source) => match source {\n+            MatchSource::Normal => {\n+                for arm in arms.iter() {\n+                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                }\n+            },\n+            MatchSource::IfDesugar {\n+                contains_else_clause: true,\n+            }\n+            | MatchSource::IfLetDesugar {\n+                contains_else_clause: true,\n+            } => {\n+                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                    check_block_return(cx, ifblock);\n+                }\n+                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n+            },\n+            _ => (),\n+        },\n+        _ => (),\n     }\n }\n \n-fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n-    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        fn_source\n-            .rfind(\"->\")\n-            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n-                (\n-                    #[allow(clippy::cast_possible_truncation)]\n-                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                    Applicability::MachineApplicable,\n-                )\n+fn emit_return_lint(cx: &LateContext<'_>, ret_span: Span, inner_span: Option<Span>, replacement: RetReplacement) {\n+    match inner_span {\n+        Some(inner_span) => {\n+            if in_external_macro(cx.tcx.sess, inner_span) || inner_span.from_expansion() {\n+                return;\n+            }\n+\n+            span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded `return` statement\", |diag| {\n+                if let Some(snippet) = snippet_opt(cx, inner_span) {\n+                    diag.span_suggestion(ret_span, \"remove `return`\", snippet, Applicability::MachineApplicable);\n+                }\n             })\n-    } else {\n-        (ty.span, Applicability::MaybeIncorrect)\n-    };\n-    span_lint_and_sugg(\n-        cx,\n-        UNUSED_UNIT,\n-        ret_span,\n-        \"unneeded unit return type\",\n-        \"remove the `-> ()`\",\n-        String::new(),\n-        appl,\n-    );\n+        },\n+        None => match replacement {\n+            RetReplacement::Empty => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"remove `return`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+            RetReplacement::Block => {\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_RETURN,\n+                    ret_span,\n+                    \"unneeded `return` statement\",\n+                    \"replace `return` with an empty block\",\n+                    \"{}\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        },\n+    }\n+}\n+\n+fn last_statement_borrows<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    let mut visitor = BorrowVisitor { cx, borrows: false };\n+    walk_expr(&mut visitor, expr);\n+    visitor.borrows\n+}\n+\n+struct BorrowVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    borrows: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.borrows {\n+            return;\n+        }\n+\n+        if let Some(def_id) = fn_def_id(self.cx, expr) {\n+            self.borrows = self\n+                .cx\n+                .tcx\n+                .fn_sig(def_id)\n+                .output()\n+                .skip_binder()\n+                .walk()\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n }"}, {"sha": "e322e4025353df9afd79fa6368aba181cbc3037d", "filename": "clippy_lints/src/unused_unit.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "patch": "@@ -0,0 +1,145 @@\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_ast::visit::FnKind;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::BytePos;\n+\n+use crate::utils::span_lint_and_sugg;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n+    ///\n+    /// **Why is this bad?** Such expressions add no value, but can make the code\n+    /// less readable. Depending on formatting they can make a `break` or `return`\n+    /// statement look like a function call.\n+    ///\n+    /// **Known problems:** The lint currently misses unit return types in types,\n+    /// e.g., the `F` in `fn generic_unit<F: Fn() -> ()>(f: F) { .. }`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn return_unit() -> () {\n+    ///     ()\n+    /// }\n+    /// ```\n+    pub UNUSED_UNIT,\n+    style,\n+    \"needless unit expression\"\n+}\n+\n+declare_lint_pass!(UnusedUnit => [UNUSED_UNIT]);\n+\n+impl EarlyLintPass for UnusedUnit {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, span: Span, _: ast::NodeId) {\n+        if_chain! {\n+            if let ast::FnRetTy::Ty(ref ty) = kind.decl().output;\n+            if let ast::TyKind::Tup(ref vals) = ty.kind;\n+            if vals.is_empty() && !ty.span.from_expansion() && get_def(span) == get_def(ty.span);\n+            then {\n+                lint_unneeded_unit_return(cx, ty, span);\n+            }\n+        }\n+    }\n+\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n+        if_chain! {\n+            if let Some(ref stmt) = block.stmts.last();\n+            if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n+            if is_unit_expr(expr) && !stmt.span.from_expansion();\n+            then {\n+                let sp = expr.span;\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNUSED_UNIT,\n+                    sp,\n+                    \"unneeded unit expression\",\n+                    \"remove the final `()`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        match e.kind {\n+            ast::ExprKind::Ret(Some(ref expr)) | ast::ExprKind::Break(_, Some(ref expr)) => {\n+                if is_unit_expr(expr) && !expr.span.from_expansion() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNUSED_UNIT,\n+                        expr.span,\n+                        \"unneeded `()`\",\n+                        \"remove the `()`\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &EarlyContext<'_>, poly: &ast::PolyTraitRef, _: &ast::TraitBoundModifier) {\n+        let segments = &poly.trait_ref.path.segments;\n+\n+        if_chain! {\n+            if segments.len() == 1;\n+            if [\"Fn\", \"FnMut\", \"FnOnce\"].contains(&&*segments[0].ident.name.as_str());\n+            if let Some(args) = &segments[0].args;\n+            if let ast::GenericArgs::Parenthesized(generic_args) = &**args;\n+            if let ast::FnRetTy::Ty(ty) = &generic_args.output;\n+            if ty.kind.is_unit();\n+            then {\n+                lint_unneeded_unit_return(cx, ty, generic_args.span);\n+            }\n+        }\n+    }\n+}\n+\n+// get the def site\n+#[must_use]\n+fn get_def(span: Span) -> Option<Span> {\n+    if span.from_expansion() {\n+        Some(span.ctxt().outer_expn_data().def_site)\n+    } else {\n+        None\n+    }\n+}\n+\n+// is this expr a `()` unit?\n+fn is_unit_expr(expr: &ast::Expr) -> bool {\n+    if let ast::ExprKind::Tup(ref vals) = expr.kind {\n+        vals.is_empty()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n+    let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n+    } else {\n+        (ty.span, Applicability::MaybeIncorrect)\n+    };\n+    span_lint_and_sugg(\n+        cx,\n+        UNUSED_UNIT,\n+        ret_span,\n+        \"unneeded unit return type\",\n+        \"remove the `-> ()`\",\n+        String::new(),\n+        appl,\n+    );\n+}"}, {"sha": "b795516f999c32c34726d16fcbe0f7738f775951", "filename": "tests/ui/needless_return.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/tests%2Fui%2Fneedless_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/tests%2Fui%2Fneedless_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.fixed?ref=a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "patch": "@@ -76,6 +76,17 @@ mod no_lint_if_stmt_borrows {\n             let stdin = ::std::io::stdin();\n             return stdin.lock().lines().next().unwrap().unwrap();\n         }\n+\n+        fn read_line2(value: bool) -> String {\n+            if value {\n+                use std::io::BufRead;\n+                let stdin = ::std::io::stdin();\n+                let _a = stdin.lock().lines().next().unwrap().unwrap();\n+                return String::from(\"test\");\n+            } else {\n+                return String::new();\n+            }\n+        }\n     }\n }\n "}, {"sha": "3547991935deda118ea7822bd458b812f4f2000f", "filename": "tests/ui/needless_return.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/tests%2Fui%2Fneedless_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4/tests%2Fui%2Fneedless_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_return.rs?ref=a7d5c2f967dd1f075ba5f8c4ca05c4b2ca2d22b4", "patch": "@@ -76,6 +76,17 @@ mod no_lint_if_stmt_borrows {\n             let stdin = ::std::io::stdin();\n             return stdin.lock().lines().next().unwrap().unwrap();\n         }\n+\n+        fn read_line2(value: bool) -> String {\n+            if value {\n+                use std::io::BufRead;\n+                let stdin = ::std::io::stdin();\n+                let _a = stdin.lock().lines().next().unwrap().unwrap();\n+                return String::from(\"test\");\n+            } else {\n+                return String::new();\n+            }\n+        }\n     }\n }\n "}]}