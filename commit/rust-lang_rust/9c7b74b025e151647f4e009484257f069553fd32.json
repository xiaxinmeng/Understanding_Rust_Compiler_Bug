{"sha": "9c7b74b025e151647f4e009484257f069553fd32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljN2I3NGIwMjVlMTUxNjQ3ZjRlMDA5NDg0MjU3ZjA2OTU1M2ZkMzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T04:19:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T04:20:37Z"}, "message": "check if the type of a local variable contains illegal region\n\nalso, try to suppress some of the duplicate errors---in general\nmore work is needed to make these error messages comprehensible\nto ordinary humans", "tree": {"sha": "437b6529ea7881f1bf527434da3fa177a59b1227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/437b6529ea7881f1bf527434da3fa177a59b1227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c7b74b025e151647f4e009484257f069553fd32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c7b74b025e151647f4e009484257f069553fd32", "html_url": "https://github.com/rust-lang/rust/commit/9c7b74b025e151647f4e009484257f069553fd32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c7b74b025e151647f4e009484257f069553fd32/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7df7a9d8ac29f2e9498e109c16ba4c9241b4c1ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/7df7a9d8ac29f2e9498e109c16ba4c9241b4c1ae", "html_url": "https://github.com/rust-lang/rust/commit/7df7a9d8ac29f2e9498e109c16ba4c9241b4c1ae"}], "stats": {"total": 186, "additions": 115, "deletions": 71}, "files": [{"sha": "0908bafb2e25cea1bb50885abf08b9bf034056d0", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -465,7 +465,7 @@ impl methods for check_loan_ctxt {\n     fn walk_loans(scope_id: ast::node_id,\n                   f: fn(loan) -> bool) {\n         let mut scope_id = scope_id;\n-        let parents = self.tcx().region_map.parents;\n+        let region_map = self.tcx().region_map;\n         let req_loan_map = self.req_loan_map;\n \n         loop {\n@@ -477,7 +477,7 @@ impl methods for check_loan_ctxt {\n                 }\n             }\n \n-            alt parents.find(scope_id) {\n+            alt region_map.find(scope_id) {\n               none { ret; }\n               some(next_scope_id) { scope_id = next_scope_id; }\n             }\n@@ -570,7 +570,7 @@ impl methods for check_loan_ctxt {\n             some(loanss) { loanss }\n         };\n \n-        let par_scope_id = self.tcx().region_map.parents.get(scope_id);\n+        let par_scope_id = self.tcx().region_map.get(scope_id);\n         for self.walk_loans(par_scope_id) { |old_loan|\n             for (*new_loanss).each { |new_loans|\n                 for (*new_loans).each { |new_loan|"}, {"sha": "b12836e612582b1e0e7166bb10bc09017c2a6dbf", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -151,20 +151,16 @@ type binding = {node_id: ast::node_id,\n                 name: str,\n                 br: ty::bound_region};\n \n-type region_map = {\n-    // Mapping from a block/function expression to its parent.\n-    parents: hashmap<ast::node_id,ast::node_id>,\n-\n-    // Mapping from arguments and local variables to the block in\n-    // which they are declared. Arguments are considered to be declared\n-    // within the body of the function.\n-    local_blocks: hashmap<ast::node_id,ast::node_id>\n-};\n+// Mapping from a block/expr/binding to the innermost scope that\n+// bounds its lifetime.  For a block/expression, this is the lifetime\n+// in which it will be evaluated.  For a binding, this is the lifetime\n+// in which is in scope.\n+type region_map = hashmap<ast::node_id, ast::node_id>;\n \n type ctxt = {\n     sess: session,\n     def_map: resolve::def_map,\n-    region_map: @region_map,\n+    region_map: region_map,\n \n     // These two fields (parent and closure_parent) specify the parent\n     // scope of the current expression.  The parent scope is the\n@@ -207,27 +203,27 @@ type ctxt = {\n \n // Returns true if `subscope` is equal to or is lexically nested inside\n // `superscope` and false otherwise.\n-fn scope_contains(region_map: @region_map, superscope: ast::node_id,\n+fn scope_contains(region_map: region_map, superscope: ast::node_id,\n                   subscope: ast::node_id) -> bool {\n     let mut subscope = subscope;\n     while superscope != subscope {\n-        alt region_map.parents.find(subscope) {\n+        alt region_map.find(subscope) {\n             none { ret false; }\n             some(scope) { subscope = scope; }\n         }\n     }\n     ret true;\n }\n \n-fn nearest_common_ancestor(region_map: @region_map, scope_a: ast::node_id,\n+fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n                            scope_b: ast::node_id) -> option<ast::node_id> {\n \n-    fn ancestors_of(region_map: @region_map, scope: ast::node_id)\n+    fn ancestors_of(region_map: region_map, scope: ast::node_id)\n                     -> [ast::node_id] {\n         let mut result = [scope];\n         let mut scope = scope;\n         loop {\n-            alt region_map.parents.find(scope) {\n+            alt region_map.find(scope) {\n                 none { ret result; }\n                 some(superscope) {\n                     result += [superscope];\n@@ -285,7 +281,7 @@ fn record_parent(cx: ctxt, child_id: ast::node_id) {\n       none { /* no-op */ }\n       some(parent_id) {\n         #debug[\"parent of node %d is node %d\", child_id, parent_id];\n-        cx.region_map.parents.insert(child_id, parent_id);\n+        cx.region_map.insert(child_id, parent_id);\n       }\n     }\n }\n@@ -314,8 +310,7 @@ fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n           }\n           _ {\n             /* This names a local. Bind it to the containing scope. */\n-            let local_blocks = cx.region_map.local_blocks;\n-            local_blocks.insert(pat.id, parent_id(cx, pat.span));\n+            record_parent(cx, pat.id);\n           }\n         }\n       }\n@@ -357,8 +352,7 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n }\n \n fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    cx.region_map.local_blocks.insert(\n-        local.node.id, parent_id(cx, local.span));\n+    record_parent(cx, local.node.id);\n     visit::visit_local(local, cx, visitor);\n }\n \n@@ -391,19 +385,17 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n            cx.closure_parent, fn_cx.parent];\n \n     for decl.inputs.each { |input|\n-        cx.region_map.local_blocks.insert(\n-            input.id, body.node.id);\n+        cx.region_map.insert(input.id, body.node.id);\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, fn_cx, visitor);\n }\n \n fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n-        -> @region_map {\n+        -> region_map {\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n-                    region_map: @{parents: map::int_hash(),\n-                                  local_blocks: map::int_hash()},\n+                    region_map: map::int_hash(),\n                     parent: none,\n                     closure_parent: none};\n     let visitor = visit::mk_vt(@{"}, {"sha": "3b5093017dc7ba8cab56394880cbd379b3b0aae3", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -206,7 +206,7 @@ type ctxt =\n       mut next_id: uint,\n       sess: session::session,\n       def_map: resolve::def_map,\n-      region_map: @middle::region::region_map,\n+      region_map: middle::region::region_map,\n \n       // Stores the types for various nodes in the AST.  Note that this table\n       // is not guaranteed to be populated until after typeck.  See\n@@ -459,7 +459,7 @@ fn new_ty_hash<V: copy>() -> map::hashmap<t, V> {\n \n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map,\n-           region_map: @middle::region::region_map) -> ctxt {\n+           region_map: middle::region::region_map) -> ctxt {\n     let interner = map::hashmap({|&&k: intern_key|\n         hash_type_structure(k.struct) +\n             option::map_default(k.o_def_id, 0u, ast_util::hash_def_id)\n@@ -688,7 +688,7 @@ fn default_arg_mode_for_ty(ty: ty::t) -> ast::rmode {\n // Returns the narrowest lifetime enclosing the evaluation of the expression\n // with id `id`.\n fn encl_region(cx: ctxt, id: ast::node_id) -> ty::region {\n-    alt cx.region_map.parents.find(id) {\n+    alt cx.region_map.find(id) {\n       some(encl_scope) {ty::re_scope(encl_scope)}\n       none {ty::re_static}\n     }"}, {"sha": "7009488272dfc183b4ef9550d4aca505141ced3f", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -1577,9 +1577,8 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n         alt defn {\n           ast::def_local(local_id, _) |\n           ast::def_upvar(local_id, _, _) {\n-            let local_blocks = fcx.ccx.tcx.region_map.local_blocks;\n-            let local_block_id = local_blocks.get(local_id);\n-            ty::re_scope(local_block_id)\n+            let local_scope = fcx.ccx.tcx.region_map.get(local_id);\n+            ty::re_scope(local_scope)\n           }\n           _ {\n             ty::re_static\n@@ -2629,8 +2628,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     }\n \n     let region =\n-        ty::re_scope(\n-            fcx.ccx.tcx.region_map.local_blocks.get(local.node.id));\n+        ty::re_scope(fcx.ccx.tcx.region_map.get(local.node.id));\n     let pcx = {\n         fcx: fcx,\n         map: pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),"}, {"sha": "27194934dbefaddbc9397982deefad19102e3800", "filename": "src/rustc/middle/typeck/regionck.rs", "status": "modified", "additions": 75, "deletions": 32, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -16,21 +16,24 @@ the region scope `r`.\n import util::ppaux;\n import syntax::print::pprust;\n \n+type rcx = @{fcx: @fn_ctxt, mut errors_reported: uint};\n+type rvt = visit::vt<rcx>;\n+\n fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n-    let v = regionck_visitor(fcx);\n-    v.visit_expr(e, fcx, v);\n+    let rcx = @{fcx:fcx, mut errors_reported: 0u};\n+    let v = regionck_visitor();\n+    v.visit_expr(e, rcx, v);\n }\n \n fn regionck_fn(fcx: @fn_ctxt,\n                _decl: ast::fn_decl,\n                blk: ast::blk) {\n-    let v = regionck_visitor(fcx);\n-    v.visit_block(blk, fcx, v);\n+    let rcx = @{fcx:fcx, mut errors_reported: 0u};\n+    let v = regionck_visitor();\n+    v.visit_block(blk, rcx, v);\n }\n \n-type rvt = visit::vt<@fn_ctxt>;\n-\n-fn regionck_visitor(_fcx: @fn_ctxt) -> rvt {\n+fn regionck_visitor() -> rvt {\n     visit::mk_vt(@{visit_item: visit_item,\n                    visit_stmt: visit_stmt,\n                    visit_expr: visit_expr,\n@@ -40,67 +43,106 @@ fn regionck_visitor(_fcx: @fn_ctxt) -> rvt {\n                    with *visit::default_visitor()})\n }\n \n-fn visit_item(_item: @ast::item, &&_fcx: @fn_ctxt, _v: rvt) {\n+fn visit_item(_item: @ast::item, &&_rcx: rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, &&fcx: @fn_ctxt, v: rvt) {\n-    visit::visit_local(l, fcx, v);\n+fn visit_local(l: @ast::local, &&rcx: rcx, v: rvt) {\n+    let e = rcx.errors_reported;\n+    v.visit_pat(l.node.pat, rcx, v);\n+    if e != rcx.errors_reported {\n+        ret; // if decl has errors, skip initializer expr\n+    }\n+\n+    v.visit_ty(l.node.ty, rcx, v);\n+    for l.node.init.each { |i|\n+        v.visit_expr(i.expr, rcx, v);\n+    }\n }\n \n-fn visit_pat(p: @ast::pat, &&fcx: @fn_ctxt, v: rvt) {\n-    visit::visit_pat(p, fcx, v);\n+fn visit_pat(p: @ast::pat, &&rcx: rcx, v: rvt) {\n+    let fcx = rcx.fcx;\n+    alt p.node {\n+      ast::pat_ident(path, _)\n+      if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n+        #debug[\"visit_pat binding=%s\", path.idents[0]];\n+        visit_node(p.id, p.span, rcx);\n+      }\n+      _ {}\n+    }\n+\n+    visit::visit_pat(p, rcx, v);\n }\n \n-fn visit_block(b: ast::blk, &&fcx: @fn_ctxt, v: rvt) {\n-    visit::visit_block(b, fcx, v);\n+fn visit_block(b: ast::blk, &&rcx: rcx, v: rvt) {\n+    visit::visit_block(b, rcx, v);\n }\n \n-fn visit_expr(e: @ast::expr, &&fcx: @fn_ctxt, v: rvt) {\n+fn visit_expr(e: @ast::expr, &&rcx: rcx, v: rvt) {\n     #debug[\"visit_expr(e=%s)\", pprust::expr_to_str(e)];\n \n-    visit_ty(fcx.expr_ty(e), e.id, e.span, fcx);\n-    visit::visit_expr(e, fcx, v);\n+    alt e.node {\n+      ast::expr_path(*) {\n+        // Avoid checking the use of local variables, as we already\n+        // check their definitions.  The def'n always encloses the\n+        // use.  So if the def'n is enclosed by the region, then the\n+        // uses will also be enclosed (and otherwise, an error will\n+        // have been reported at the def'n site).\n+        alt lookup_def(rcx.fcx, e.span, e.id) {\n+          ast::def_local(*) | ast::def_arg(*) | ast::def_upvar(*) { ret; }\n+          _ { }\n+        }\n+      }\n+      _ { }\n+    }\n+\n+    if !visit_node(e.id, e.span, rcx) { ret; }\n+    visit::visit_expr(e, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, &&fcx: @fn_ctxt, v: rvt) {\n-    visit::visit_stmt(s, fcx, v);\n+fn visit_stmt(s: @ast::stmt, &&rcx: rcx, v: rvt) {\n+    visit::visit_stmt(s, rcx, v);\n }\n \n-fn visit_ty(ty: ty::t,\n-            id: ast::node_id,\n-            span: span,\n-            fcx: @fn_ctxt) {\n+// checks the type of the node `id` and reports an error if it\n+// references a region that is not in scope for that node.  Returns\n+// false if an error is reported; this is used to cause us to cut off\n+// region checking for that subtree to avoid reporting tons of errors.\n+fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n+    let fcx = rcx.fcx;\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    let ty = alt infer::resolve_deep(fcx.infcx, ty, false) {\n-      result::err(_) { ret; }\n+    let ty0 = fcx.node_ty(id);\n+    let ty = alt infer::resolve_deep(fcx.infcx, ty0, false) {\n+      result::err(_) { ret true; }\n       result::ok(ty) { ty }\n     };\n \n     // find the region where this expr evaluation is taking place\n     let tcx = fcx.ccx.tcx;\n     let encl_region = ty::encl_region(tcx, id);\n \n-    #debug[\"visit_ty(ty=%s, id=%d, encl_region=%s)\",\n+    #debug[\"visit_node(ty=%s, id=%d, encl_region=%s, ty0=%s)\",\n            ppaux::ty_to_str(tcx, ty),\n            id,\n-           ppaux::region_to_str(tcx, encl_region)];\n+           ppaux::region_to_str(tcx, encl_region),\n+           ppaux::ty_to_str(tcx, ty0)];\n \n     // Otherwise, look at the type and see if it is a region pointer.\n-    if !ty::type_has_regions(ty) { ret; }\n+    let e = rcx.errors_reported;\n     ty::walk_regions_and_ty(\n         tcx, ty,\n-        { |r| constrain_region(fcx, encl_region, span, r); },\n+        { |r| constrain_region(rcx, encl_region, span, r); },\n         { |t| ty::type_has_regions(t) });\n+    ret (e == rcx.errors_reported);\n \n-    fn constrain_region(fcx: @fn_ctxt,\n+    fn constrain_region(rcx: rcx,\n                         encl_region: ty::region,\n                         span: span,\n                         region: ty::region) {\n-        let tcx = fcx.ccx.tcx;\n+        let tcx = rcx.fcx.ccx.tcx;\n \n         #debug[\"constrain_region(encl_region=%s, region=%s)\",\n                ppaux::region_to_str(tcx, encl_region),\n@@ -117,13 +159,14 @@ fn visit_ty(ty: ty::t,\n           _ {}\n         }\n \n-        alt fcx.mk_subr(encl_region, region) {\n+        alt rcx.fcx.mk_subr(encl_region, region) {\n           result::err(_) {\n             tcx.sess.span_err(\n                 span,\n                 #fmt[\"reference is not valid outside \\\n                       of its lifetime, %s\",\n                      ppaux::region_to_str(tcx, region)]);\n+            rcx.errors_reported += 1u;\n           }\n           result::ok(()) {\n           }"}, {"sha": "5bcfc9841622ff31accbe00ee05eebc13cae358f", "filename": "src/test/compile-fail/regions-borrow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -5,5 +5,4 @@ fn main() {\n     let r = foo(p);\n     //!^ ERROR reference is not valid\n     assert *p == *r;\n-    //!^ ERROR reference is not valid\n }"}, {"sha": "bf0c625abab32c0f9b5ab88b38d30825db92d3b2", "filename": "src/test/compile-fail/regions-escape-loop-via-variable.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -0,0 +1,14 @@\n+fn main() {\n+    let x = 3;\n+\n+    // Here, the variable `p` gets inferred to a type with a lifetime\n+    // of the loop body.  The regionck then determines that this type\n+    // is invalid.\n+    let mut p = //! ERROR reference is not valid\n+        &x;\n+\n+    loop {\n+        let x = 1 + *p;\n+        p = &x;\n+    }\n+}"}, {"sha": "b44c38e68f81f38890f0530f9738f5a93748b52a", "filename": "src/test/compile-fail/regions-leaking-ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c7b74b025e151647f4e009484257f069553fd32/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c7b74b025e151647f4e009484257f069553fd32/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-leaking-ptr.rs?ref=9c7b74b025e151647f4e009484257f069553fd32", "patch": "@@ -12,8 +12,6 @@ fn broken() -> int {\n     //!^ ERROR reference is not valid\n     //!^^ ERROR reference is not valid\n     //!^^^ ERROR reference is not valid\n-    //!^^^^ ERROR reference is not valid\n-    //!^^^^^ ERROR reference is not valid\n }\n \n fn main() { }\n\\ No newline at end of file"}]}