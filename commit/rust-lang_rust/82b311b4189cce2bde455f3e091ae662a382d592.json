{"sha": "82b311b4189cce2bde455f3e091ae662a382d592", "node_id": "C_kwDOAAsO6NoAKDgyYjMxMWI0MTg5Y2NlMmJkZTQ1NWYzZTA5MWFlNjYyYTM4MmQ1OTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T12:29:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T12:29:07Z"}, "message": "Auto merge of #112016 - GuillaumeGomez:rollup-fhqn4i6, r=GuillaumeGomez\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #111936 (Include test suite metadata in the build metrics)\n - #111952 (Remove DesugaringKind::Replace.)\n - #111966 (Add #[inline] to array TryFrom impls)\n - #111983 (Perform MIR type ops locally in new solver)\n - #111997 (Fix re-export of doc hidden macro not showing up)\n - #112014 (rustdoc: get unnormalized link destination for suggestions)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d81029e60279047279e497ef619c3a1b199a7abb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d81029e60279047279e497ef619c3a1b199a7abb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82b311b4189cce2bde455f3e091ae662a382d592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82b311b4189cce2bde455f3e091ae662a382d592", "html_url": "https://github.com/rust-lang/rust/commit/82b311b4189cce2bde455f3e091ae662a382d592", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82b311b4189cce2bde455f3e091ae662a382d592/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786178b2ab79ae471c5efc4e1faa0c83b9151703", "url": "https://api.github.com/repos/rust-lang/rust/commits/786178b2ab79ae471c5efc4e1faa0c83b9151703", "html_url": "https://github.com/rust-lang/rust/commit/786178b2ab79ae471c5efc4e1faa0c83b9151703"}, {"sha": "30896536f3901c9bf78a437f8d58a8a137758529", "url": "https://api.github.com/repos/rust-lang/rust/commits/30896536f3901c9bf78a437f8d58a8a137758529", "html_url": "https://github.com/rust-lang/rust/commit/30896536f3901c9bf78a437f8d58a8a137758529"}], "stats": {"total": 2359, "additions": 1610, "deletions": 749}, "files": [{"sha": "15d73ed732f502b7db33c80d4c3f024c858c59ac", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1635,34 +1635,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             })\n     }\n \n-    /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n-    ///\n-    /// Depending on the origin of the StorageDeadOrDrop, this may be\n-    /// reported as either a drop or an illegal mutation of a borrowed value.\n-    /// The latter is preferred when the this is a drop triggered by a\n-    /// reassignment, as it's more user friendly to report a problem with the\n-    /// explicit assignment than the implicit drop.\n-    #[instrument(level = \"debug\", skip(self))]\n-    pub(crate) fn report_storage_dead_or_drop_of_borrowed(\n-        &mut self,\n-        location: Location,\n-        place_span: (Place<'tcx>, Span),\n-        borrow: &BorrowData<'tcx>,\n-    ) {\n-        // It's sufficient to check the last desugaring as Replace is the last\n-        // one to be applied.\n-        if let Some(DesugaringKind::Replace) = place_span.1.desugaring_kind() {\n-            self.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n-        } else {\n-            self.report_borrowed_value_does_not_live_long_enough(\n-                location,\n-                borrow,\n-                place_span,\n-                Some(WriteKind::StorageDeadOrDrop),\n-            )\n-        }\n-    }\n-\n     /// This means that some data referenced by `borrow` needs to live\n     /// past the point where the StorageDeadOrDrop of `place` occurs.\n     /// This is usually interpreted as meaning that `place` has too"}, {"sha": "d0e17bf5a08489267b701fddb384161ad94c06a6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -641,13 +641,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let Some(hir::Node::Item(item)) = node else { return; };\n             let hir::ItemKind::Fn(.., body_id) = item.kind else { return; };\n             let body = self.infcx.tcx.hir().body(body_id);\n-            let mut assign_span = span;\n-            // Drop desugaring is done at MIR build so it's not in the HIR\n-            if let Some(DesugaringKind::Replace) = span.desugaring_kind() {\n-                assign_span.remove_mark();\n-            }\n \n-            let mut v = V { assign_span, err, ty, suggested: false };\n+            let mut v = V { assign_span: span, err, ty, suggested: false };\n             v.visit_body(body);\n             if !v.suggested {\n                 err.help(format!("}, {"sha": "b2ff25ecb96f4e47e1efeccaa0610a21d8d6320f", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -112,11 +112,13 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             TerminatorKind::SwitchInt { discr, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n-            TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place: drop_place, target: _, unwind: _, replace } => {\n+                let write_kind =\n+                    if *replace { WriteKind::Replace } else { WriteKind::StorageDeadOrDrop };\n                 self.access_place(\n                     location,\n                     *drop_place,\n-                    (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n+                    (AccessDepth::Drop, Write(write_kind)),\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }"}, {"sha": "a53ea100c224219c8de6b4ac8bcd8ce7edc0da25", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -685,17 +685,19 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             TerminatorKind::SwitchInt { discr, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n-            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { place, target: _, unwind: _, replace } => {\n                 debug!(\n                     \"visit_terminator_drop \\\n                      loc: {:?} term: {:?} place: {:?} span: {:?}\",\n                     loc, term, place, span\n                 );\n \n+                let write_kind =\n+                    if *replace { WriteKind::Replace } else { WriteKind::StorageDeadOrDrop };\n                 self.access_place(\n                     loc,\n                     (*place, span),\n-                    (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n+                    (AccessDepth::Drop, Write(write_kind)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n@@ -885,6 +887,7 @@ enum ReadKind {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum WriteKind {\n     StorageDeadOrDrop,\n+    Replace,\n     MutableBorrow(BorrowKind),\n     Mutate,\n     Move,\n@@ -1132,13 +1135,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             this.buffer_error(err);\n                         }\n                         WriteKind::StorageDeadOrDrop => this\n-                            .report_storage_dead_or_drop_of_borrowed(location, place_span, borrow),\n+                            .report_borrowed_value_does_not_live_long_enough(\n+                                location,\n+                                borrow,\n+                                place_span,\n+                                Some(WriteKind::StorageDeadOrDrop),\n+                            ),\n                         WriteKind::Mutate => {\n                             this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n                         }\n                         WriteKind::Move => {\n                             this.report_move_out_while_borrowed(location, place_span, borrow)\n                         }\n+                        WriteKind::Replace => {\n+                            this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n+                        }\n                     }\n                     Control::Break\n                 }\n@@ -1982,12 +1993,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Reservation(\n                 WriteKind::Move\n+                | WriteKind::Replace\n                 | WriteKind::StorageDeadOrDrop\n                 | WriteKind::MutableBorrow(BorrowKind::Shared)\n                 | WriteKind::MutableBorrow(BorrowKind::Shallow),\n             )\n             | Write(\n                 WriteKind::Move\n+                | WriteKind::Replace\n                 | WriteKind::StorageDeadOrDrop\n                 | WriteKind::MutableBorrow(BorrowKind::Shared)\n                 | WriteKind::MutableBorrow(BorrowKind::Shallow),"}, {"sha": "eb02604b9d925e4b4a076da6eac89ad8a3c623ff", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -3,9 +3,9 @@ use rustc_index::bit_set::HybridBitSet;\n use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n+use rustc_middle::traits::query::DropckOutlivesResult;\n use rustc_middle::ty::{Ty, TyCtxt, TypeVisitable, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n-use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n use std::rc::Rc;"}, {"sha": "fcfa0b862d4b5a8755a13374945a7e57766af4af", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -473,7 +473,7 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop { place, target, unwind: _ } => {\n+            TerminatorKind::Drop { place, target, unwind: _, replace: _ } => {\n                 let drop_place = codegen_place(fx, *place);\n                 crate::abi::codegen_drop(fx, source_info, drop_place);\n "}, {"sha": "3f0b64b1103d6a58c2903f146f0c66ca98112853", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1256,7 +1256,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 MergingSucc::False\n             }\n \n-            mir::TerminatorKind::Drop { place, target, unwind } => {\n+            mir::TerminatorKind::Drop { place, target, unwind, replace: _ } => {\n                 self.codegen_drop_terminator(helper, bx, place, target, unwind, mergeable_succ())\n             }\n "}, {"sha": "586e8f063eeefa588f58d75981f177904be37049", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -114,7 +114,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Drop { place, target, unwind } => {\n+            Drop { place, target, unwind, replace: _ } => {\n                 let frame = self.frame();\n                 let ty = place.ty(&frame.body.local_decls, *self.tcx).ty;\n                 let ty = self.subst_from_frame_and_normalize_erasing_regions(frame, ty)?;"}, {"sha": "6d6d71bc87b1438a1108cf79f7ec1ee81fa87ca9", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -603,7 +603,11 @@ pub enum TerminatorKind<'tcx> {\n     /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n     /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n     /// > consider indirect assignments.\n-    Drop { place: Place<'tcx>, target: BasicBlock, unwind: UnwindAction },\n+    ///\n+    /// The `replace` flag indicates whether this terminator was created as part of an assignment.\n+    /// This should only be used for diagnostic purposes, and does not have any operational\n+    /// meaning.\n+    Drop { place: Place<'tcx>, target: BasicBlock, unwind: UnwindAction, replace: bool },\n \n     /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n     /// the referred to function. The operand types must match the argument types of the function."}, {"sha": "942654b30749c3c1ea7792140713c6b07291141b", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -504,6 +504,7 @@ macro_rules! make_mir_visitor {\n                         place,\n                         target: _,\n                         unwind: _,\n+                        replace: _,\n                     } => {\n                         self.visit_place(\n                             place,"}, {"sha": "ebf830cb9c1f6a2da2120a1266adb3b82cf1ba50", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -57,6 +57,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n                     place: self.parse_place(args[0])?,\n                     target: self.parse_block(args[1])?,\n                     unwind: UnwindAction::Continue,\n+                    replace: false,\n                 })\n             },\n             @call(\"mir_call\", args) => {"}, {"sha": "3742d640e3b58927caa09c5af385c5661cddfad2", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -725,6 +725,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         place: to_drop,\n                         target: success,\n                         unwind: UnwindAction::Continue,\n+                        replace: false,\n                     },\n                 );\n                 this.diverge_from(block);"}, {"sha": "7c0fbc6f81c94721d0a7ad2d1df4f35260921728", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -91,7 +91,7 @@ use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::thir::{Expr, LintLevel};\n \n-use rustc_span::{DesugaringKind, Span, DUMMY_SP};\n+use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Debug)]\n pub struct Scopes<'tcx> {\n@@ -371,6 +371,7 @@ impl DropTree {\n                         // The caller will handle this if needed.\n                         unwind: UnwindAction::Terminate,\n                         place: drop_data.0.local.into(),\n+                        replace: false,\n                     };\n                     cfg.terminate(block, drop_data.0.source_info, terminator);\n                 }\n@@ -1128,9 +1129,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: Place<'tcx>,\n         value: Rvalue<'tcx>,\n     ) -> BlockAnd<()> {\n-        let span = self.tcx.with_stable_hashing_context(|hcx| {\n-            span.mark_with_reason(None, DesugaringKind::Replace, self.tcx.sess.edition(), hcx)\n-        });\n         let source_info = self.source_info(span);\n \n         // create the new block for the assignment\n@@ -1148,6 +1146,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 place,\n                 target: assign,\n                 unwind: UnwindAction::Cleanup(assign_unwind),\n+                replace: true,\n             },\n         );\n         self.diverge_from(block);\n@@ -1261,6 +1260,7 @@ fn build_scope_drops<'tcx>(\n                         place: local.into(),\n                         target: next,\n                         unwind: UnwindAction::Continue,\n+                        replace: false,\n                     },\n                 );\n                 block = next;"}, {"sha": "d615c83d621915e6bf05235b840d3f55394d1ac1", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -237,6 +237,7 @@ where\n                         place: self.place,\n                         target: self.succ,\n                         unwind: self.unwind.into_action(),\n+                        replace: false,\n                     },\n                 );\n             }\n@@ -719,6 +720,7 @@ where\n                 place: tcx.mk_place_deref(ptr),\n                 target: loop_block,\n                 unwind: unwind.into_action(),\n+                replace: false,\n             },\n         );\n \n@@ -963,8 +965,12 @@ where\n     }\n \n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n-        let block =\n-            TerminatorKind::Drop { place: self.place, target, unwind: unwind.into_action() };\n+        let block = TerminatorKind::Drop {\n+            place: self.place,\n+            target,\n+            unwind: unwind.into_action(),\n+            replace: false,\n+        };\n         self.new_block(unwind, block)\n     }\n "}, {"sha": "ba328e78040a51e06b9e29d987607ae779215ceb", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -479,7 +479,7 @@ impl Direction for Forward {\n             Goto { target } => propagate(target, exit_state),\n \n             Assert { target, unwind, expected: _, msg: _, cond: _ }\n-            | Drop { target, unwind, place: _ }\n+            | Drop { target, unwind, place: _, replace: _ }\n             | FalseUnwind { real_target: target, unwind } => {\n                 if let UnwindAction::Cleanup(unwind) = unwind {\n                     propagate(unwind, exit_state);"}, {"sha": "ef2a0c790e9459eab462aee9a09ed8b9c5b2c73f", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -80,7 +80,7 @@ fn add_move_for_packed_drop<'tcx>(\n     is_cleanup: bool,\n ) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n-    let TerminatorKind::Drop { ref place, target, unwind } = terminator.kind else {\n+    let TerminatorKind::Drop { ref place, target, unwind, replace } = terminator.kind else {\n         unreachable!();\n     };\n \n@@ -98,6 +98,11 @@ fn add_move_for_packed_drop<'tcx>(\n     patch.add_assign(loc, Place::from(temp), Rvalue::Use(Operand::Move(*place)));\n     patch.patch_terminator(\n         loc.block,\n-        TerminatorKind::Drop { place: Place::from(temp), target: storage_dead_block, unwind },\n+        TerminatorKind::Drop {\n+            place: Place::from(temp),\n+            target: storage_dead_block,\n+            unwind,\n+            replace,\n+        },\n     );\n }"}, {"sha": "fda0e1023f7c58fc9696a44af29ec3a1648de52e", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -14,7 +14,7 @@ use rustc_mir_dataflow::un_derefer::UnDerefer;\n use rustc_mir_dataflow::MoveDataParamEnv;\n use rustc_mir_dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n-use rustc_span::{DesugaringKind, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{FieldIdx, VariantIdx};\n use std::fmt;\n \n@@ -401,7 +401,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             let terminator = data.terminator();\n \n             match terminator.kind {\n-                TerminatorKind::Drop { mut place, target, unwind } => {\n+                TerminatorKind::Drop { mut place, target, unwind, replace } => {\n                     if let Some(new_place) = self.un_derefer.derefer(place.as_ref(), self.body) {\n                         place = new_place;\n                     }\n@@ -434,10 +434,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             )\n                         }\n                         LookupResult::Parent(..) => {\n-                            if !matches!(\n-                                terminator.source_info.span.desugaring_kind(),\n-                                Some(DesugaringKind::Replace),\n-                            ) {\n+                            if !replace {\n                                 self.tcx.sess.delay_span_bug(\n                                     terminator.source_info.span,\n                                     format!(\"drop of untracked value {:?}\", bb),"}, {"sha": "89567ed0ab88278c8cc51ccbf608a32fc7bcb9ed", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1045,7 +1045,10 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n \n     for (block, block_data) in body.basic_blocks.iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            Terminator { source_info, kind: TerminatorKind::Drop { place, target, unwind } } => {\n+            Terminator {\n+                source_info,\n+                kind: TerminatorKind::Drop { place, target, unwind, replace: _ },\n+            } => {\n                 if let Some(local) = place.as_local() {\n                     if local == SELF_ARG {\n                         (target, unwind, source_info)\n@@ -1304,6 +1307,7 @@ fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n         place: Place::from(SELF_ARG),\n         target: return_block,\n         unwind: UnwindAction::Continue,\n+        replace: false,\n     };\n     let source_info = SourceInfo::outermost(body.span);\n "}, {"sha": "ca1e209d504b0b6cd0d7e8a787490a3025b7342e", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -449,16 +449,16 @@ impl<'tcx> Inliner<'tcx> {\n             checker.visit_basic_block_data(bb, blk);\n \n             let term = blk.terminator();\n-            if let TerminatorKind::Drop { ref place, target, unwind } = term.kind {\n+            if let TerminatorKind::Drop { ref place, target, unwind, replace: _ } = term.kind {\n                 work_list.push(target);\n \n                 // If the place doesn't actually need dropping, treat it like a regular goto.\n                 let ty = callsite\n                     .callee\n                     .subst_mir(self.tcx, ty::EarlyBinder(&place.ty(callee_body, tcx).ty));\n                 if ty.needs_drop(tcx, self.param_env) && let UnwindAction::Cleanup(unwind) = unwind {\n-                        work_list.push(unwind);\n-                    }\n+                    work_list.push(unwind);\n+                }\n             } else if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set\n                 && matches!(term.kind, TerminatorKind::InlineAsm { .. })\n             {"}, {"sha": "0eb27c23105f5ba24c106dfbb1c07dffd49854ac", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -544,6 +544,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n                     place: dest_field,\n                     target: unwind,\n                     unwind: UnwindAction::Terminate,\n+                    replace: false,\n                 },\n                 true,\n             );\n@@ -800,6 +801,7 @@ fn build_call_shim<'tcx>(\n                 place: rcvr_place(),\n                 target: BasicBlock::new(2),\n                 unwind: UnwindAction::Continue,\n+                replace: false,\n             },\n             false,\n         );\n@@ -815,6 +817,7 @@ fn build_call_shim<'tcx>(\n                 place: rcvr_place(),\n                 target: BasicBlock::new(4),\n                 unwind: UnwindAction::Terminate,\n+                replace: false,\n             },\n             true,\n         );"}, {"sha": "5572108f49567ea5b84f5f40a3dd2e288da4da69", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -309,7 +309,7 @@ fn rustc_terminator_to_terminator(\n         Terminate => Terminator::Abort,\n         Return => Terminator::Return,\n         Unreachable => Terminator::Unreachable,\n-        Drop { place, target, unwind } => Terminator::Drop {\n+        Drop { place, target, unwind, replace: _ } => Terminator::Drop {\n             place: rustc_place_to_place(place),\n             target: target.as_usize(),\n             unwind: rustc_unwind_to_unwind(unwind),"}, {"sha": "b219fde4da9a17c0aacfa6bf53c29f0de52c12af", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1147,7 +1147,6 @@ pub enum DesugaringKind {\n     Await,\n     ForLoop,\n     WhileLoop,\n-    Replace,\n }\n \n impl DesugaringKind {\n@@ -1163,7 +1162,6 @@ impl DesugaringKind {\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop => \"`for` loop\",\n             DesugaringKind::WhileLoop => \"`while` loop\",\n-            DesugaringKind::Replace => \"drop and replace\",\n         }\n     }\n }"}, {"sha": "f8d056e321e656e28bf0fdf622fc2ee4ea57303c", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::InferCtxt;\n-use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::infer::InferOk;\n+use rustc_middle::infer::canonical::{OriginalQueryValues, QueryRegionConstraints};\n use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n \n@@ -68,20 +68,29 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n             return vec![];\n         }\n \n-        let span = self.tcx.def_span(body_id);\n-        let result: Result<_, ErrorGuaranteed> = param_env\n-            .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n-            .fully_perform(self, span);\n-        let result = match result {\n-            Ok(r) => r,\n-            Err(_) => {\n-                return vec![];\n-            }\n+        let mut canonical_var_values = OriginalQueryValues::default();\n+        let canonical_ty =\n+            self.canonicalize_query_keep_static(param_env.and(ty), &mut canonical_var_values);\n+        let Ok(canonical_result) = self.tcx.implied_outlives_bounds(canonical_ty) else {\n+            return vec![];\n+        };\n+\n+        let mut constraints = QueryRegionConstraints::default();\n+        let Ok(InferOk { value, obligations }) = self\n+            .instantiate_nll_query_response_and_region_obligations(\n+                &ObligationCause::dummy(),\n+                param_env,\n+                &canonical_var_values,\n+                canonical_result,\n+                &mut constraints,\n+            ) else {\n+            return vec![];\n         };\n+        assert_eq!(&obligations, &[]);\n \n-        let TypeOpOutput { output, constraints, .. } = result;\n+        if !constraints.is_empty() {\n+            let span = self.tcx.def_span(body_id);\n \n-        if let Some(constraints) = constraints {\n             debug!(?constraints);\n             if !constraints.member_constraints.is_empty() {\n                 span_bug!(span, \"{:#?}\", constraints.member_constraints);\n@@ -108,7 +117,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n             }\n         };\n \n-        output\n+        value\n     }\n \n     fn implied_bounds_tys("}, {"sha": "4e4172e7f41ec62bf4a4b55b2b92467cf9219f35", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 267, "deletions": 2, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,6 +1,11 @@\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use crate::traits::query::normalize::QueryNormalizeExt;\n+use crate::traits::query::NoSolution;\n+use crate::traits::{Normalized, ObligationCause, ObligationCtxt};\n \n-pub use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n+use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_span::source_map::{Span, DUMMY_SP};\n \n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n@@ -71,3 +76,263 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Generator(..) => false,\n     }\n }\n+\n+pub fn compute_dropck_outlives_inner<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Result<DropckOutlivesResult<'tcx>, NoSolution> {\n+    let tcx = ocx.infcx.tcx;\n+    let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+    // A stack of types left to process. Each round, we pop\n+    // something from the stack and invoke\n+    // `dtorck_constraint_for_ty_inner`. This may produce new types that\n+    // have to be pushed on the stack. This continues until we have explored\n+    // all the reachable types from the type `for_ty`.\n+    //\n+    // Example: Imagine that we have the following code:\n+    //\n+    // ```rust\n+    // struct A {\n+    //     value: B,\n+    //     children: Vec<A>,\n+    // }\n+    //\n+    // struct B {\n+    //     value: u32\n+    // }\n+    //\n+    // fn f() {\n+    //   let a: A = ...;\n+    //   ..\n+    // } // here, `a` is dropped\n+    // ```\n+    //\n+    // at the point where `a` is dropped, we need to figure out\n+    // which types inside of `a` contain region data that may be\n+    // accessed by any destructors in `a`. We begin by pushing `A`\n+    // onto the stack, as that is the type of `a`. We will then\n+    // invoke `dtorck_constraint_for_ty_inner` which will expand `A`\n+    // into the types of its fields `(B, Vec<A>)`. These will get\n+    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+    // lead to us trying to push `A` a second time -- to prevent\n+    // infinite recursion, we notice that `A` was already pushed\n+    // once and stop.\n+    let mut ty_stack = vec![(for_ty, 0)];\n+\n+    // Set used to detect infinite recursion.\n+    let mut ty_set = FxHashSet::default();\n+\n+    let cause = ObligationCause::dummy();\n+    let mut constraints = DropckConstraint::empty();\n+    while let Some((ty, depth)) = ty_stack.pop() {\n+        debug!(\n+            \"{} kinds, {} overflows, {} ty_stack\",\n+            result.kinds.len(),\n+            result.overflows.len(),\n+            ty_stack.len()\n+        );\n+        dtorck_constraint_for_ty_inner(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+        // \"outlives\" represent types/regions that may be touched\n+        // by a destructor.\n+        result.kinds.append(&mut constraints.outlives);\n+        result.overflows.append(&mut constraints.overflows);\n+\n+        // If we have even one overflow, we should stop trying to evaluate further --\n+        // chances are, the subsequent overflows for this evaluation won't provide useful\n+        // information and will just decrease the speed at which we can emit these errors\n+        // (since we'll be printing for just that much longer for the often enormous types\n+        // that result here).\n+        if !result.overflows.is_empty() {\n+            break;\n+        }\n+\n+        // dtorck types are \"types that will get dropped but which\n+        // do not themselves define a destructor\", more or less. We have\n+        // to push them onto the stack to be expanded.\n+        for ty in constraints.dtorck_types.drain(..) {\n+            let Normalized { value: ty, obligations } =\n+                ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n+            ocx.register_obligations(obligations);\n+\n+            debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+            match ty.kind() {\n+                // All parameters live for the duration of the\n+                // function.\n+                ty::Param(..) => {}\n+\n+                // A projection that we couldn't resolve - it\n+                // might have a destructor.\n+                ty::Alias(..) => {\n+                    result.kinds.push(ty.into());\n+                }\n+\n+                _ => {\n+                    if ty_set.insert(ty) {\n+                        ty_stack.push((ty, depth + 1));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"dropck_outlives: result = {:#?}\", result);\n+    Ok(result)\n+}\n+\n+/// Returns a set of constraints that needs to be satisfied in\n+/// order for `ty` to be valid for destruction.\n+pub fn dtorck_constraint_for_ty_inner<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    for_ty: Ty<'tcx>,\n+    depth: usize,\n+    ty: Ty<'tcx>,\n+    constraints: &mut DropckConstraint<'tcx>,\n+) -> Result<(), NoSolution> {\n+    debug!(\"dtorck_constraint_for_ty_inner({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        constraints.overflows.push(ty);\n+        return Ok(());\n+    }\n+\n+    if trivial_dropck_outlives(tcx, ty) {\n+        return Ok(());\n+    }\n+\n+    match ty.kind() {\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Str\n+        | ty::Never\n+        | ty::Foreign(..)\n+        | ty::RawPtr(..)\n+        | ty::Ref(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::GeneratorWitness(..)\n+        | ty::GeneratorWitnessMIR(..) => {\n+            // these types never have a destructor\n+        }\n+\n+        ty::Array(ety, _) | ty::Slice(ety) => {\n+            // single-element containers, behave like their element\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, *ety, constraints)\n+            })?;\n+        }\n+\n+        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+            for ty in tys.iter() {\n+                dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+            }\n+            Ok::<_, NoSolution>(())\n+        })?,\n+\n+        ty::Closure(_, substs) => {\n+            if !substs.as_closure().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                for ty in substs.as_closure().upvar_tys() {\n+                    dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+                }\n+                Ok::<_, NoSolution>(())\n+            })?\n+        }\n+\n+        ty::Generator(_, substs, _movability) => {\n+            // rust-lang/rust#49918: types can be constructed, stored\n+            // in the interior, and sit idle when generator yields\n+            // (and is subsequently dropped).\n+            //\n+            // It would be nice to descend into interior of a\n+            // generator to determine what effects dropping it might\n+            // have (by looking at any drop effects associated with\n+            // its interior).\n+            //\n+            // However, the interior's representation uses things like\n+            // GeneratorWitness that explicitly assume they are not\n+            // traversed in such a manner. So instead, we will\n+            // simplify things for now by treating all generators as\n+            // if they were like trait objects, where its upvars must\n+            // all be alive for the generator's (potential)\n+            // destructor.\n+            //\n+            // In particular, skipping over `_interior` is safe\n+            // because any side-effects from dropping `_interior` can\n+            // only take place through references with lifetimes\n+            // derived from lifetimes attached to the upvars and resume\n+            // argument, and we *do* incorporate those here.\n+\n+            if !substs.as_generator().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n+            constraints.outlives.extend(\n+                substs\n+                    .as_generator()\n+                    .upvar_tys()\n+                    .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n+            );\n+            constraints.outlives.push(substs.as_generator().resume_ty().into());\n+        }\n+\n+        ty::Adt(def, substs) => {\n+            let DropckConstraint { dtorck_types, outlives, overflows } =\n+                tcx.at(span).adt_dtorck_constraint(def.did())?;\n+            // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+            // there, but that needs some way to handle cycles.\n+            constraints\n+                .dtorck_types\n+                .extend(dtorck_types.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n+            constraints\n+                .outlives\n+                .extend(outlives.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n+            constraints\n+                .overflows\n+                .extend(overflows.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n+        }\n+\n+        // Objects must be alive in order for their destructor\n+        // to be called.\n+        ty::Dynamic(..) => {\n+            constraints.outlives.push(ty.into());\n+        }\n+\n+        // Types that can't be resolved. Pass them forward.\n+        ty::Alias(..) | ty::Param(..) => {\n+            constraints.dtorck_types.push(ty);\n+        }\n+\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n+            // By the time this code runs, all type variables ought to\n+            // be fully resolved.\n+            return Err(NoSolution);\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "01d7a1e7913b554850666bf0dcffc249d6d0e752", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,8 +1,13 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n+use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, UserSelfTy, UserSubsts, UserType};\n \n pub use rustc_middle::traits::query::type_op::AscribeUserType;\n+use rustc_span::{Span, DUMMY_SP};\n \n impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     type QueryResponse = ();\n@@ -20,4 +25,116 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        type_op_ascribe_user_type_with_span(ocx, key, None)\n+    }\n+}\n+\n+/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n+/// this query can be re-run to better track the span of the obligation cause, and improve the error\n+/// message. Do not call directly unless you're in that very specific context.\n+pub fn type_op_ascribe_user_type_with_span<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n+    span: Option<Span>,\n+) -> Result<(), NoSolution> {\n+    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n+    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n+    let span = span.unwrap_or(DUMMY_SP);\n+    match user_ty {\n+        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n+        UserType::TypeOf(def_id, user_substs) => {\n+            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n+        }\n+    };\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_ty<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    user_ty: Ty<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let cause = ObligationCause::dummy_with_span(span);\n+    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n+\n+    // FIXME(#104764): We should check well-formedness before normalization.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n+    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_substs<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    def_id: DefId,\n+    user_substs: UserSubsts<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let param_env = param_env.without_const();\n+    let UserSubsts { user_self_ty, substs } = user_substs;\n+    let tcx = ocx.infcx.tcx;\n+    let cause = ObligationCause::dummy_with_span(span);\n+\n+    let ty = tcx.type_of(def_id).subst(tcx, substs);\n+    let ty = ocx.normalize(&cause, param_env, ty);\n+    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n+\n+    ocx.eq(&cause, param_env, mir_ty, ty)?;\n+\n+    // Prove the predicates coming along with `def_id`.\n+    //\n+    // Also, normalize the `instantiated_predicates`\n+    // because otherwise we wind up with duplicate \"type\n+    // outlives\" error messages.\n+    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n+\n+    debug!(?instantiated_predicates);\n+    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n+        let span = if span == DUMMY_SP { predicate_span } else { span };\n+        let cause = ObligationCause::new(\n+            span,\n+            CRATE_DEF_ID,\n+            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+        );\n+        let instantiated_predicate =\n+            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n+\n+        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n+    }\n+\n+    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n+        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n+\n+        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n+        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n+    }\n+\n+    // In addition to proving the predicates, we have to\n+    // prove that `ty` is well-formed -- this is because\n+    // the WF of `ty` is predicated on the substs being\n+    // well-formed, and we haven't proven *that*. We don't\n+    // want to prove the WF of types from  `substs` directly because they\n+    // haven't been normalized.\n+    //\n+    // FIXME(nmatsakis): Well, perhaps we should normalize\n+    // them?  This would only be relevant if some input\n+    // type were ill-formed but did not appear in `ty`,\n+    // which...could happen with normalization...\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n+    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n+    Ok(())\n }"}, {"sha": "f65893088066ef057bb11f7cc5585540a69c0089", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/eq.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::Eq;\n@@ -20,4 +22,12 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_eq(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        ocx.eq(&ObligationCause::dummy(), key.param_env, key.value.a, key.value.b)?;\n+        Ok(())\n+    }\n }"}, {"sha": "9989fc9c479a38da498f29d3192b86a004d712aa", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 176, "deletions": 3, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,7 +1,15 @@\n-use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::query::NoSolution;\n+use crate::traits::wf;\n+use crate::traits::ObligationCtxt;\n+\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::traits::query::OutlivesBound;\n-use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_middle::infer::canonical::CanonicalQueryResponse;\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::def_id::CRATE_DEF_ID;\n+use rustc_span::source_map::DUMMY_SP;\n+use smallvec::{smallvec, SmallVec};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n@@ -39,4 +47,169 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n \n         tcx.implied_outlives_bounds(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        compute_implied_outlives_bounds_inner(ocx, key.param_env, key.value.ty)\n+    }\n+}\n+\n+pub fn compute_implied_outlives_bounds_inner<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n+    let tcx = ocx.infcx.tcx;\n+\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Because the resulting predicates aren't always\n+    // guaranteed to be a subset of the original type, so we need to store the\n+    // WF args we've computed in a set.\n+    let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n+    let mut wf_args = vec![ty.into()];\n+\n+    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n+        vec![];\n+\n+    while let Some(arg) = wf_args.pop() {\n+        if !checked_wf_args.insert(arg) {\n+            continue;\n+        }\n+\n+        // Compute the obligations for `arg` to be well-formed. If `arg` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        //\n+        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n+        // bounds can be backward incompatible, e.g. #101951 was caused by\n+        // us not dealing with inference vars in `TypeOutlives` predicates.\n+        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n+            .unwrap_or_default();\n+\n+        for obligation in obligations {\n+            debug!(?obligation);\n+            assert!(!obligation.has_escaping_bound_vars());\n+\n+            // While these predicates should all be implied by other parts of\n+            // the program, they are still relevant as they may constrain\n+            // inference variables, which is necessary to add the correct\n+            // implied bounds in some cases, mostly when dealing with projections.\n+            //\n+            // Another important point here: we only register `Projection`\n+            // predicates, since otherwise we might register outlives\n+            // predicates containing inference variables, and we don't\n+            // learn anything new from those.\n+            if obligation.predicate.has_non_region_infer() {\n+                match obligation.predicate.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                    | ty::PredicateKind::AliasRelate(..) => {\n+                        ocx.register_obligation(obligation.clone());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            let pred = match obligation.predicate.kind().no_bound_vars() {\n+                None => continue,\n+                Some(pred) => pred,\n+            };\n+            match pred {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n+                // if we ever support that\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::AliasRelate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+\n+                // We need to search through *all* WellFormed predicates\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    wf_args.push(arg);\n+                }\n+\n+                // We need to register region relationships\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    r_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n+\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    ty_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n+            }\n+        }\n+    }\n+\n+    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n+    // use further down when computing the implied bounds.\n+    match ocx.select_all_or_error().as_slice() {\n+        [] => (),\n+        _ => return Err(NoSolution),\n+    }\n+\n+    // We lazily compute the outlives components as\n+    // `select_all_or_error` constrains inference variables.\n+    let implied_bounds = outlives_bounds\n+        .into_iter()\n+        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n+            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n+            ty::GenericArgKind::Type(ty_a) => {\n+                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n+                let mut components = smallvec![];\n+                push_outlives_components(tcx, ty_a, &mut components);\n+                implied_bounds_from_components(r_b, components)\n+            }\n+            ty::GenericArgKind::Const(_) => unreachable!(),\n+        })\n+        .collect();\n+\n+    Ok(implied_bounds)\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components<'tcx>(\n+    sub_region: ty::Region<'tcx>,\n+    sup_components: SmallVec<[Component<'tcx>; 4]>,\n+) -> Vec<OutlivesBound<'tcx>> {\n+    sup_components\n+        .into_iter()\n+        .filter_map(|component| {\n+            match component {\n+                Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n+                Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n+                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n+                Component::EscapingAlias(_) =>\n+                // If the projection has escaping regions, don't\n+                // try to infer any implied bounds even for its\n+                // free components. This is conservative, because\n+                // the caller will still have to prove that those\n+                // free components outlive `sub_region`. But the\n+                // idea is that the WAY that the caller proves\n+                // that may change in the future and we want to\n+                // give ourselves room to get smarter here.\n+                {\n+                    None\n+                }\n+                Component::UnresolvedInferenceVariable(..) => None,\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "642fdec2d9ae33278c92f8f15a7b0a4409dca5d4", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -2,7 +2,7 @@ use crate::infer::canonical::{\n     Canonical, CanonicalQueryResponse, OriginalQueryValues, QueryRegionConstraints,\n };\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::canonical::Certainty;\n use rustc_infer::traits::PredicateObligations;\n@@ -23,6 +23,8 @@ pub mod subtype;\n \n pub use rustc_middle::traits::query::type_op::*;\n \n+use self::custom::scrape_region_constraints;\n+\n /// \"Type ops\" are used in NLL to perform some particular action and\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed).\n@@ -81,6 +83,17 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<TyCtxt<'tcx>> + 't\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution>;\n \n+    /// In the new trait solver, we already do caching in the solver itself,\n+    /// so there's no need to canonicalize and cache via the query system.\n+    /// Additionally, even if we were to canonicalize, we'd still need to\n+    /// make sure to feed it predefined opaque types and the defining anchor\n+    /// and that would require duplicating all of the tcx queries. Instead,\n+    /// just perform these ops locally.\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution>;\n+\n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'tcx>,\n@@ -133,6 +146,16 @@ where\n         infcx: &InferCtxt<'tcx>,\n         span: Span,\n     ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n+        if infcx.tcx.trait_solver_next() {\n+            return Ok(scrape_region_constraints(\n+                infcx,\n+                |ocx| QueryTypeOp::perform_locally_in_new_solver(ocx, self),\n+                \"query type op\",\n+                span,\n+            )?\n+            .0);\n+        }\n+\n         let mut region_constraints = QueryRegionConstraints::default();\n         let (output, error_info, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints).map_err(|_| {"}, {"sha": "57ca14aa492ffb036f5b4a5daf08ac8662bfbf78", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/normalize.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt, TypeVisitableExt};\n use std::fmt;\n@@ -22,6 +24,14 @@ where\n     ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution> {\n         T::type_op_method(tcx, canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        // FIXME(-Ztrait-solver=next): shouldn't be using old normalizer\n+        Ok(ocx.normalize(&ObligationCause::dummy(), key.param_env, key.value.value))\n+    }\n }\n \n pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<TyCtxt<'tcx>> + Lift<'tcx> + Copy {"}, {"sha": "9889426337476ff87ae2d15ef67c586abe6bf9c9", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/outlives.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,6 +1,9 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::dropck_outlives::{trivial_dropck_outlives, DropckOutlivesResult};\n-use rustc_middle::traits::query::NoSolution;\n+use crate::traits::query::dropck_outlives::{\n+    compute_dropck_outlives_inner, trivial_dropck_outlives,\n+};\n+use crate::traits::ObligationCtxt;\n+use rustc_middle::traits::query::{DropckOutlivesResult, NoSolution};\n use rustc_middle::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n@@ -48,4 +51,11 @@ impl<'tcx> super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n \n         tcx.dropck_outlives(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        compute_dropck_outlives_inner(ocx, key.param_env.and(key.value.dropped_ty))\n+    }\n }"}, {"sha": "47850bc330dab295c977225059c403728264dfe3", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,5 +1,8 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n+use rustc_infer::traits::Obligation;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::ProvePredicate;\n@@ -36,4 +39,17 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        ocx.register_obligation(Obligation::new(\n+            ocx.infcx.tcx,\n+            ObligationCause::dummy(),\n+            key.param_env,\n+            key.value.predicate,\n+        ));\n+        Ok(())\n+    }\n }"}, {"sha": "10976d5cd71625a7433eb195b3f3684886426ce1", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/subtype.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::ObligationCtxt;\n use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::Subtype;\n@@ -17,4 +19,12 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_subtype(canonicalized)\n     }\n+\n+    fn perform_locally_in_new_solver(\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n+    ) -> Result<Self::QueryResponse, NoSolution> {\n+        ocx.sub(&ObligationCause::dummy(), key.param_env, key.value.sub, key.value.sup)?;\n+        Ok(())\n+    }\n }"}, {"sha": "f35c14eeac80139ecb2c29c56094a30de8648972", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 261, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -3,17 +3,14 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n use rustc_middle::ty::InternalSubsts;\n-use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_middle::ty::TyCtxt;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n-    DropckConstraint, DropckOutlivesResult,\n+    compute_dropck_outlives_inner, dtorck_constraint_for_ty_inner,\n };\n-use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -26,263 +23,10 @@ fn dropck_outlives<'tcx>(\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n     tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n-        let tcx = ocx.infcx.tcx;\n-        let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-        // A stack of types left to process. Each round, we pop\n-        // something from the stack and invoke\n-        // `dtorck_constraint_for_ty`. This may produce new types that\n-        // have to be pushed on the stack. This continues until we have explored\n-        // all the reachable types from the type `for_ty`.\n-        //\n-        // Example: Imagine that we have the following code:\n-        //\n-        // ```rust\n-        // struct A {\n-        //     value: B,\n-        //     children: Vec<A>,\n-        // }\n-        //\n-        // struct B {\n-        //     value: u32\n-        // }\n-        //\n-        // fn f() {\n-        //   let a: A = ...;\n-        //   ..\n-        // } // here, `a` is dropped\n-        // ```\n-        //\n-        // at the point where `a` is dropped, we need to figure out\n-        // which types inside of `a` contain region data that may be\n-        // accessed by any destructors in `a`. We begin by pushing `A`\n-        // onto the stack, as that is the type of `a`. We will then\n-        // invoke `dtorck_constraint_for_ty` which will expand `A`\n-        // into the types of its fields `(B, Vec<A>)`. These will get\n-        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-        // lead to us trying to push `A` a second time -- to prevent\n-        // infinite recursion, we notice that `A` was already pushed\n-        // once and stop.\n-        let mut ty_stack = vec![(for_ty, 0)];\n-\n-        // Set used to detect infinite recursion.\n-        let mut ty_set = FxHashSet::default();\n-\n-        let cause = ObligationCause::dummy();\n-        let mut constraints = DropckConstraint::empty();\n-        while let Some((ty, depth)) = ty_stack.pop() {\n-            debug!(\n-                \"{} kinds, {} overflows, {} ty_stack\",\n-                result.kinds.len(),\n-                result.overflows.len(),\n-                ty_stack.len()\n-            );\n-            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-            // \"outlives\" represent types/regions that may be touched\n-            // by a destructor.\n-            result.kinds.append(&mut constraints.outlives);\n-            result.overflows.append(&mut constraints.overflows);\n-\n-            // If we have even one overflow, we should stop trying to evaluate further --\n-            // chances are, the subsequent overflows for this evaluation won't provide useful\n-            // information and will just decrease the speed at which we can emit these errors\n-            // (since we'll be printing for just that much longer for the often enormous types\n-            // that result here).\n-            if !result.overflows.is_empty() {\n-                break;\n-            }\n-\n-            // dtorck types are \"types that will get dropped but which\n-            // do not themselves define a destructor\", more or less. We have\n-            // to push them onto the stack to be expanded.\n-            for ty in constraints.dtorck_types.drain(..) {\n-                let Normalized { value: ty, obligations } =\n-                    ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n-                ocx.register_obligations(obligations);\n-\n-                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                match ty.kind() {\n-                    // All parameters live for the duration of the\n-                    // function.\n-                    ty::Param(..) => {}\n-\n-                    // A projection that we couldn't resolve - it\n-                    // might have a destructor.\n-                    ty::Alias(..) => {\n-                        result.kinds.push(ty.into());\n-                    }\n-\n-                    _ => {\n-                        if ty_set.insert(ty) {\n-                            ty_stack.push((ty, depth + 1));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        debug!(\"dropck_outlives: result = {:#?}\", result);\n-        Ok(result)\n+        compute_dropck_outlives_inner(ocx, goal)\n     })\n }\n \n-/// Returns a set of constraints that needs to be satisfied in\n-/// order for `ty` to be valid for destruction.\n-fn dtorck_constraint_for_ty<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    for_ty: Ty<'tcx>,\n-    depth: usize,\n-    ty: Ty<'tcx>,\n-    constraints: &mut DropckConstraint<'tcx>,\n-) -> Result<(), NoSolution> {\n-    debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n-\n-    if !tcx.recursion_limit().value_within_limit(depth) {\n-        constraints.overflows.push(ty);\n-        return Ok(());\n-    }\n-\n-    if trivial_dropck_outlives(tcx, ty) {\n-        return Ok(());\n-    }\n-\n-    match ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Str\n-        | ty::Never\n-        | ty::Foreign(..)\n-        | ty::RawPtr(..)\n-        | ty::Ref(..)\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::GeneratorWitness(..)\n-        | ty::GeneratorWitnessMIR(..) => {\n-            // these types never have a destructor\n-        }\n-\n-        ty::Array(ety, _) | ty::Slice(ety) => {\n-            // single-element containers, behave like their element\n-            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, *ety, constraints)\n-            })?;\n-        }\n-\n-        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-            for ty in tys.iter() {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n-            }\n-            Ok::<_, NoSolution>(())\n-        })?,\n-\n-        ty::Closure(_, substs) => {\n-            if !substs.as_closure().is_valid() {\n-                // By the time this code runs, all type variables ought to\n-                // be fully resolved.\n-\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n-                );\n-                return Err(NoSolution);\n-            }\n-\n-            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                for ty in substs.as_closure().upvar_tys() {\n-                    dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n-                }\n-                Ok::<_, NoSolution>(())\n-            })?\n-        }\n-\n-        ty::Generator(_, substs, _movability) => {\n-            // rust-lang/rust#49918: types can be constructed, stored\n-            // in the interior, and sit idle when generator yields\n-            // (and is subsequently dropped).\n-            //\n-            // It would be nice to descend into interior of a\n-            // generator to determine what effects dropping it might\n-            // have (by looking at any drop effects associated with\n-            // its interior).\n-            //\n-            // However, the interior's representation uses things like\n-            // GeneratorWitness that explicitly assume they are not\n-            // traversed in such a manner. So instead, we will\n-            // simplify things for now by treating all generators as\n-            // if they were like trait objects, where its upvars must\n-            // all be alive for the generator's (potential)\n-            // destructor.\n-            //\n-            // In particular, skipping over `_interior` is safe\n-            // because any side-effects from dropping `_interior` can\n-            // only take place through references with lifetimes\n-            // derived from lifetimes attached to the upvars and resume\n-            // argument, and we *do* incorporate those here.\n-\n-            if !substs.as_generator().is_valid() {\n-                // By the time this code runs, all type variables ought to\n-                // be fully resolved.\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n-                );\n-                return Err(NoSolution);\n-            }\n-\n-            constraints.outlives.extend(\n-                substs\n-                    .as_generator()\n-                    .upvar_tys()\n-                    .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n-            );\n-            constraints.outlives.push(substs.as_generator().resume_ty().into());\n-        }\n-\n-        ty::Adt(def, substs) => {\n-            let DropckConstraint { dtorck_types, outlives, overflows } =\n-                tcx.at(span).adt_dtorck_constraint(def.did())?;\n-            // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n-            // there, but that needs some way to handle cycles.\n-            constraints\n-                .dtorck_types\n-                .extend(dtorck_types.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-            constraints\n-                .outlives\n-                .extend(outlives.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-            constraints\n-                .overflows\n-                .extend(overflows.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-        }\n-\n-        // Objects must be alive in order for their destructor\n-        // to be called.\n-        ty::Dynamic(..) => {\n-            constraints.outlives.push(ty.into());\n-        }\n-\n-        // Types that can't be resolved. Pass them forward.\n-        ty::Alias(..) | ty::Param(..) => {\n-            constraints.dtorck_types.push(ty);\n-        }\n-\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n-            // By the time this code runs, all type variables ought to\n-            // be fully resolved.\n-            return Err(NoSolution);\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n /// Calculates the dtorck constraint for a type.\n pub(crate) fn adt_dtorck_constraint(\n     tcx: TyCtxt<'_>,\n@@ -311,7 +55,7 @@ pub(crate) fn adt_dtorck_constraint(\n     let mut result = DropckConstraint::empty();\n     for field in def.all_fields() {\n         let fty = tcx.type_of(field.did).subst_identity();\n-        dtorck_constraint_for_ty(tcx, span, fty, 0, fty, &mut result)?;\n+        dtorck_constraint_for_ty_inner(tcx, span, fty, 0, fty, &mut result)?;\n     }\n     result.outlives.extend(tcx.destructor_constraints(def));\n     dedup_dtorck_constraint(&mut result);"}, {"sha": "959838ab348fd0026585d3bda06f1569dd847327", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 166, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -3,18 +3,13 @@\n //! [`rustc_trait_selection::traits::query::type_op::implied_outlives_bounds`].\n \n use rustc_infer::infer::canonical::{self, Canonical};\n-use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::query::OutlivesBound;\n use rustc_middle::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::source_map::DUMMY_SP;\n+use rustc_middle::ty::TyCtxt;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n+use rustc_trait_selection::traits::query::type_op::implied_outlives_bounds::compute_implied_outlives_bounds_inner;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::wf;\n-use rustc_trait_selection::traits::ObligationCtxt;\n-use smallvec::{smallvec, SmallVec};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { implied_outlives_bounds, ..*p };\n@@ -29,164 +24,6 @@ fn implied_outlives_bounds<'tcx>(\n > {\n     tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(ocx, param_env, ty)\n+        compute_implied_outlives_bounds_inner(ocx, param_env, ty)\n     })\n }\n-\n-fn compute_implied_outlives_bounds<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n-    let tcx = ocx.infcx.tcx;\n-\n-    // Sometimes when we ask what it takes for T: WF, we get back that\n-    // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Because the resulting predicates aren't always\n-    // guaranteed to be a subset of the original type, so we need to store the\n-    // WF args we've computed in a set.\n-    let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n-    let mut wf_args = vec![ty.into()];\n-\n-    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n-        vec![];\n-\n-    while let Some(arg) = wf_args.pop() {\n-        if !checked_wf_args.insert(arg) {\n-            continue;\n-        }\n-\n-        // Compute the obligations for `arg` to be well-formed. If `arg` is\n-        // an unresolved inference variable, just substituted an empty set\n-        // -- because the return type here is going to be things we *add*\n-        // to the environment, it's always ok for this set to be smaller\n-        // than the ultimate set. (Note: normally there won't be\n-        // unresolved inference variables here anyway, but there might be\n-        // during typeck under some circumstances.)\n-        //\n-        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n-        // bounds can be backward incompatible, e.g. #101951 was caused by\n-        // us not dealing with inference vars in `TypeOutlives` predicates.\n-        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n-            .unwrap_or_default();\n-\n-        for obligation in obligations {\n-            debug!(?obligation);\n-            assert!(!obligation.has_escaping_bound_vars());\n-\n-            // While these predicates should all be implied by other parts of\n-            // the program, they are still relevant as they may constrain\n-            // inference variables, which is necessary to add the correct\n-            // implied bounds in some cases, mostly when dealing with projections.\n-            //\n-            // Another important point here: we only register `Projection`\n-            // predicates, since otherwise we might register outlives\n-            // predicates containing inference variables, and we don't\n-            // learn anything new from those.\n-            if obligation.predicate.has_non_region_infer() {\n-                match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                    | ty::PredicateKind::AliasRelate(..) => {\n-                        ocx.register_obligation(obligation.clone());\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            let pred = match obligation.predicate.kind().no_bound_vars() {\n-                None => continue,\n-                Some(pred) => pred,\n-            };\n-            match pred {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n-                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n-                // if we ever support that\n-                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasRelate(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n-\n-                // We need to search through *all* WellFormed predicates\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    wf_args.push(arg);\n-                }\n-\n-                // We need to register region relationships\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                    r_a,\n-                    r_b,\n-                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n-\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                    ty_a,\n-                    r_b,\n-                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n-            }\n-        }\n-    }\n-\n-    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n-    // use further down when computing the implied bounds.\n-    match ocx.select_all_or_error().as_slice() {\n-        [] => (),\n-        _ => return Err(NoSolution),\n-    }\n-\n-    // We lazily compute the outlives components as\n-    // `select_all_or_error` constrains inference variables.\n-    let implied_bounds = outlives_bounds\n-        .into_iter()\n-        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n-            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n-            ty::GenericArgKind::Type(ty_a) => {\n-                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n-                let mut components = smallvec![];\n-                push_outlives_components(tcx, ty_a, &mut components);\n-                implied_bounds_from_components(r_b, components)\n-            }\n-            ty::GenericArgKind::Const(_) => unreachable!(),\n-        })\n-        .collect();\n-\n-    Ok(implied_bounds)\n-}\n-\n-/// When we have an implied bound that `T: 'a`, we can further break\n-/// this down to determine what relationships would have to hold for\n-/// `T: 'a` to hold. We get to assume that the caller has validated\n-/// those relationships.\n-fn implied_bounds_from_components<'tcx>(\n-    sub_region: ty::Region<'tcx>,\n-    sup_components: SmallVec<[Component<'tcx>; 4]>,\n-) -> Vec<OutlivesBound<'tcx>> {\n-    sup_components\n-        .into_iter()\n-        .filter_map(|component| {\n-            match component {\n-                Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n-                Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n-                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n-                Component::EscapingAlias(_) =>\n-                // If the projection has escaping regions, don't\n-                // try to infer any implied bounds even for its\n-                // free components. This is conservative, because\n-                // the caller will still have to prove that those\n-                // free components outlive `sub_region`. But the\n-                // idea is that the WAY that the caller proves\n-                // that may change in the future and we want to\n-                // give ourselves room to get smarter here.\n-                {\n-                    None\n-                }\n-                Component::UnresolvedInferenceVariable(..) => None,\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "907e2d39c518f057f3c33ddd503eaa16d95c68ed", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -21,7 +21,8 @@ mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n \n-pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n+pub use rustc_trait_selection::traits::query::type_op::ascribe_user_type::type_op_ascribe_user_type_with_span;\n+pub use type_op::type_op_prove_predicate_with_cause;\n \n use rustc_middle::query::Providers;\n "}, {"sha": "9904acb1c0d516ab2b56364ccb9ad3ea6bb565e9", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 5, "deletions": 112, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1,17 +1,15 @@\n-use rustc_hir as hir;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::{DefiningAnchor, ObligationCauseCode};\n-use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::traits::DefiningAnchor;\n+use rustc_middle::ty::{FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ParamEnvAnd, Predicate};\n-use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n-use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n+use rustc_trait_selection::traits::query::type_op::ascribe_user_type::{\n+    type_op_ascribe_user_type_with_span, AscribeUserType,\n+};\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n@@ -42,111 +40,6 @@ fn type_op_ascribe_user_type<'tcx>(\n     })\n }\n \n-/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n-/// this query can be re-run to better track the span of the obligation cause, and improve the error\n-/// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_ascribe_user_type_with_span<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n-    span: Option<Span>,\n-) -> Result<(), NoSolution> {\n-    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n-    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n-    let span = span.unwrap_or(DUMMY_SP);\n-    match user_ty {\n-        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n-        UserType::TypeOf(def_id, user_substs) => {\n-            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n-        }\n-    };\n-    Ok(())\n-}\n-\n-#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n-fn relate_mir_and_user_ty<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-    mir_ty: Ty<'tcx>,\n-    user_ty: Ty<'tcx>,\n-) -> Result<(), NoSolution> {\n-    let cause = ObligationCause::dummy_with_span(span);\n-    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n-    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n-\n-    // FIXME(#104764): We should check well-formedness before normalization.\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n-    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n-    Ok(())\n-}\n-\n-#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n-fn relate_mir_and_user_substs<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-    mir_ty: Ty<'tcx>,\n-    def_id: hir::def_id::DefId,\n-    user_substs: UserSubsts<'tcx>,\n-) -> Result<(), NoSolution> {\n-    let param_env = param_env.without_const();\n-    let UserSubsts { user_self_ty, substs } = user_substs;\n-    let tcx = ocx.infcx.tcx;\n-    let cause = ObligationCause::dummy_with_span(span);\n-\n-    let ty = tcx.type_of(def_id).subst(tcx, substs);\n-    let ty = ocx.normalize(&cause, param_env, ty);\n-    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-\n-    ocx.eq(&cause, param_env, mir_ty, ty)?;\n-\n-    // Prove the predicates coming along with `def_id`.\n-    //\n-    // Also, normalize the `instantiated_predicates`\n-    // because otherwise we wind up with duplicate \"type\n-    // outlives\" error messages.\n-    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-    debug!(?instantiated_predicates);\n-    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n-        let span = if span == DUMMY_SP { predicate_span } else { span };\n-        let cause = ObligationCause::new(\n-            span,\n-            CRATE_DEF_ID,\n-            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-        );\n-        let instantiated_predicate =\n-            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n-\n-        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n-    }\n-\n-    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n-        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n-        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n-\n-        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n-        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n-        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n-    }\n-\n-    // In addition to proving the predicates, we have to\n-    // prove that `ty` is well-formed -- this is because\n-    // the WF of `ty` is predicated on the substs being\n-    // well-formed, and we haven't proven *that*. We don't\n-    // want to prove the WF of types from  `substs` directly because they\n-    // haven't been normalized.\n-    //\n-    // FIXME(nmatsakis): Well, perhaps we should normalize\n-    // them?  This would only be relevant if some input\n-    // type were ill-formed but did not appear in `ty`,\n-    // which...could happen with normalization...\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n-    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n-    Ok(())\n-}\n-\n fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,"}, {"sha": "fec92320a4b5e6de863ea062e486c3f1e0d62668", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -204,6 +204,7 @@ where\n {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n         <&Self>::try_from(slice).map(|r| *r)\n     }\n@@ -228,6 +229,7 @@ where\n {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &mut [T]) -> Result<[T; N], TryFromSliceError> {\n         <Self>::try_from(&*slice)\n     }\n@@ -249,6 +251,7 @@ where\n impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &'a [T]) -> Result<&'a [T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_ptr() as *const [T; N];\n@@ -276,6 +279,7 @@ impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N] {\n     type Error = TryFromSliceError;\n \n+    #[inline]\n     fn try_from(slice: &'a mut [T]) -> Result<&'a mut [T; N], TryFromSliceError> {\n         if slice.len() == N {\n             let ptr = slice.as_mut_ptr() as *mut [T; N];"}, {"sha": "5990f33b9bc6c87d18359c9288e0b0342653fe3a", "filename": "src/bootstrap/metrics.rs", "status": "modified", "additions": 95, "deletions": 24, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/src%2Fbootstrap%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/src%2Fbootstrap%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetrics.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -14,6 +14,25 @@ use std::io::BufWriter;\n use std::time::{Duration, Instant, SystemTime};\n use sysinfo::{CpuExt, System, SystemExt};\n \n+// Update this number whenever a breaking change is made to the build metrics.\n+//\n+// The output format is versioned for two reasons:\n+//\n+// - The metadata is intended to be consumed by external tooling, and exposing a format version\n+//   helps the tools determine whether they're compatible with a metrics file.\n+//\n+// - If a developer enables build metrics in their local checkout, making a breaking change to the\n+//   metrics format would result in a hard-to-diagnose error message when an existing metrics file\n+//   is not compatible with the new changes. With a format version number, bootstrap can discard\n+//   incompatible metrics files instead of appending metrics to them.\n+//\n+// Version changelog:\n+//\n+// - v0: initial version\n+// - v1: replaced JsonNode::Test with JsonNode::TestSuite\n+//\n+const CURRENT_FORMAT_VERSION: usize = 1;\n+\n pub(crate) struct BuildMetrics {\n     state: RefCell<MetricsState>,\n }\n@@ -57,7 +76,7 @@ impl BuildMetrics {\n             duration_excluding_children_sec: Duration::ZERO,\n \n             children: Vec::new(),\n-            tests: Vec::new(),\n+            test_suites: Vec::new(),\n         });\n     }\n \n@@ -84,19 +103,31 @@ impl BuildMetrics {\n         }\n     }\n \n+    pub(crate) fn begin_test_suite(&self, metadata: TestSuiteMetadata, builder: &Builder<'_>) {\n+        // Do not record dry runs, as they'd be duplicates of the actual steps.\n+        if builder.config.dry_run() {\n+            return;\n+        }\n+\n+        let mut state = self.state.borrow_mut();\n+        let step = state.running_steps.last_mut().unwrap();\n+        step.test_suites.push(TestSuite { metadata, tests: Vec::new() });\n+    }\n+\n     pub(crate) fn record_test(&self, name: &str, outcome: TestOutcome, builder: &Builder<'_>) {\n         // Do not record dry runs, as they'd be duplicates of the actual steps.\n         if builder.config.dry_run() {\n             return;\n         }\n \n         let mut state = self.state.borrow_mut();\n-        state\n-            .running_steps\n-            .last_mut()\n-            .unwrap()\n-            .tests\n-            .push(Test { name: name.to_string(), outcome });\n+        let step = state.running_steps.last_mut().unwrap();\n+\n+        if let Some(test_suite) = step.test_suites.last_mut() {\n+            test_suite.tests.push(Test { name: name.to_string(), outcome });\n+        } else {\n+            panic!(\"metrics.record_test() called without calling metrics.begin_test_suite() first\");\n+        }\n     }\n \n     fn collect_stats(&self, state: &mut MetricsState) {\n@@ -131,7 +162,20 @@ impl BuildMetrics {\n         // Some of our CI builds consist of multiple independent CI invocations. Ensure all the\n         // previous invocations are still present in the resulting file.\n         let mut invocations = match std::fs::read(&dest) {\n-            Ok(contents) => t!(serde_json::from_slice::<JsonRoot>(&contents)).invocations,\n+            Ok(contents) => {\n+                // We first parse just the format_version field to have the check succeed even if\n+                // the rest of the contents are not valid anymore.\n+                let version: OnlyFormatVersion = t!(serde_json::from_slice(&contents));\n+                if version.format_version == CURRENT_FORMAT_VERSION {\n+                    t!(serde_json::from_slice::<JsonRoot>(&contents)).invocations\n+                } else {\n+                    println!(\n+                        \"warning: overriding existing build/metrics.json, as it's not \\\n+                         compatible with build metrics format version {CURRENT_FORMAT_VERSION}.\"\n+                    );\n+                    Vec::new()\n+                }\n+            }\n             Err(err) => {\n                 if err.kind() != std::io::ErrorKind::NotFound {\n                     panic!(\"failed to open existing metrics file at {}: {err}\", dest.display());\n@@ -149,7 +193,7 @@ impl BuildMetrics {\n             children: steps.into_iter().map(|step| self.prepare_json_step(step)).collect(),\n         });\n \n-        let json = JsonRoot { system_stats, invocations };\n+        let json = JsonRoot { format_version: CURRENT_FORMAT_VERSION, system_stats, invocations };\n \n         t!(std::fs::create_dir_all(dest.parent().unwrap()));\n         let mut file = BufWriter::new(t!(File::create(&dest)));\n@@ -159,11 +203,7 @@ impl BuildMetrics {\n     fn prepare_json_step(&self, step: StepMetrics) -> JsonNode {\n         let mut children = Vec::new();\n         children.extend(step.children.into_iter().map(|child| self.prepare_json_step(child)));\n-        children.extend(\n-            step.tests\n-                .into_iter()\n-                .map(|test| JsonNode::Test { name: test.name, outcome: test.outcome }),\n-        );\n+        children.extend(step.test_suites.into_iter().map(JsonNode::TestSuite));\n \n         JsonNode::RustbuildStep {\n             type_: step.type_,\n@@ -198,17 +238,14 @@ struct StepMetrics {\n     duration_excluding_children_sec: Duration,\n \n     children: Vec<StepMetrics>,\n-    tests: Vec<Test>,\n-}\n-\n-struct Test {\n-    name: String,\n-    outcome: TestOutcome,\n+    test_suites: Vec<TestSuite>,\n }\n \n #[derive(Serialize, Deserialize)]\n #[serde(rename_all = \"snake_case\")]\n struct JsonRoot {\n+    #[serde(default)] // For version 0 the field was not present.\n+    format_version: usize,\n     system_stats: JsonInvocationSystemStats,\n     invocations: Vec<JsonInvocation>,\n }\n@@ -237,13 +274,41 @@ enum JsonNode {\n \n         children: Vec<JsonNode>,\n     },\n-    Test {\n-        name: String,\n-        #[serde(flatten)]\n-        outcome: TestOutcome,\n+    TestSuite(TestSuite),\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct TestSuite {\n+    metadata: TestSuiteMetadata,\n+    tests: Vec<Test>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(tag = \"kind\", rename_all = \"snake_case\")]\n+pub(crate) enum TestSuiteMetadata {\n+    CargoPackage {\n+        crates: Vec<String>,\n+        target: String,\n+        host: String,\n+        stage: u32,\n+    },\n+    Compiletest {\n+        suite: String,\n+        mode: String,\n+        compare_mode: Option<String>,\n+        target: String,\n+        host: String,\n+        stage: u32,\n     },\n }\n \n+#[derive(Serialize, Deserialize)]\n+pub(crate) struct Test {\n+    name: String,\n+    #[serde(flatten)]\n+    outcome: TestOutcome,\n+}\n+\n #[derive(Serialize, Deserialize)]\n #[serde(tag = \"outcome\", rename_all = \"snake_case\")]\n pub(crate) enum TestOutcome {\n@@ -266,3 +331,9 @@ struct JsonInvocationSystemStats {\n struct JsonStepSystemStats {\n     cpu_utilization_percent: f64,\n }\n+\n+#[derive(Deserialize)]\n+struct OnlyFormatVersion {\n+    #[serde(default)] // For version 0 the field was not present.\n+    format_version: usize,\n+}"}, {"sha": "44cd84be705ab1ed19fbc810ec184f86e079153e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -317,6 +317,17 @@ impl Step for Cargo {\n         cargo.env(\"CARGO_TEST_DISABLE_NIGHTLY\", \"1\");\n         cargo.env(\"PATH\", &path_for_cargo(builder, compiler));\n \n+        #[cfg(feature = \"build-metrics\")]\n+        builder.metrics.begin_test_suite(\n+            crate::metrics::TestSuiteMetadata::CargoPackage {\n+                crates: vec![\"cargo\".into()],\n+                target: self.host.triple.to_string(),\n+                host: self.host.triple.to_string(),\n+                stage: self.stage,\n+            },\n+            builder,\n+        );\n+\n         let _time = util::timeit(&builder);\n         add_flags_and_try_run_tests(builder, &mut cargo);\n     }\n@@ -1699,6 +1710,19 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n \n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n+        #[cfg(feature = \"build-metrics\")]\n+        builder.metrics.begin_test_suite(\n+            crate::metrics::TestSuiteMetadata::Compiletest {\n+                suite: suite.into(),\n+                mode: mode.into(),\n+                compare_mode: None,\n+                target: self.target.triple.to_string(),\n+                host: self.compiler.host.triple.to_string(),\n+                stage: self.compiler.stage,\n+            },\n+            builder,\n+        );\n+\n         builder.info(&format!(\n             \"Check compiletest suite={} mode={} ({} -> {})\",\n             suite, mode, &compiler.host, target\n@@ -1708,6 +1732,20 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n+\n+            #[cfg(feature = \"build-metrics\")]\n+            builder.metrics.begin_test_suite(\n+                crate::metrics::TestSuiteMetadata::Compiletest {\n+                    suite: suite.into(),\n+                    mode: mode.into(),\n+                    compare_mode: Some(compare_mode.into()),\n+                    target: self.target.triple.to_string(),\n+                    host: self.compiler.host.triple.to_string(),\n+                    stage: self.compiler.stage,\n+                },\n+                builder,\n+            );\n+\n             builder.info(&format!(\n                 \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n                 suite, mode, compare_mode, &compiler.host, target\n@@ -2034,6 +2072,17 @@ fn run_cargo_test(\n     let mut cargo =\n         prepare_cargo_test(cargo, libtest_args, crates, primary_crate, compiler, target, builder);\n     let _time = util::timeit(&builder);\n+\n+    #[cfg(feature = \"build-metrics\")]\n+    builder.metrics.begin_test_suite(\n+        crate::metrics::TestSuiteMetadata::CargoPackage {\n+            crates: crates.iter().map(|c| c.to_string()).collect(),\n+            target: target.triple.to_string(),\n+            host: compiler.host.triple.to_string(),\n+            stage: compiler.stage,\n+        },\n+        builder,\n+    );\n     add_flags_and_try_run_tests(builder, &mut cargo)\n }\n "}, {"sha": "03adc19e359c193279616a7c6b34e6643e15c82b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -2592,7 +2592,8 @@ fn clean_use_statement_inner<'tcx>(\n     } else {\n         if inline_attr.is_none()\n             && let Res::Def(DefKind::Mod, did) = path.res\n-            && !did.is_local() && did.is_crate_root()\n+            && !did.is_local()\n+            && did.is_crate_root()\n         {\n             // if we're `pub use`ing an extern crate root, don't inline it unless we\n             // were specifically asked for it"}, {"sha": "9bb20022cfd4c612acaa92e90c5b7dab3691a95a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 111, "deletions": 9, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -1237,7 +1237,27 @@ pub(crate) fn plain_text_summary(md: &str, link_names: &[RenderedLink]) -> Strin\n pub(crate) struct MarkdownLink {\n     pub kind: LinkType,\n     pub link: String,\n-    pub range: Range<usize>,\n+    pub range: MarkdownLinkRange,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) enum MarkdownLinkRange {\n+    /// Normally, markdown link warnings point only at the destination.\n+    Destination(Range<usize>),\n+    /// In some cases, it's not possible to point at the destination.\n+    /// Usually, this happens because backslashes `\\\\` are used.\n+    /// When that happens, point at the whole link, and don't provide structured suggestions.\n+    WholeLink(Range<usize>),\n+}\n+\n+impl MarkdownLinkRange {\n+    /// Extracts the inner range.\n+    pub fn inner_range(&self) -> &Range<usize> {\n+        match self {\n+            MarkdownLinkRange::Destination(range) => range,\n+            MarkdownLinkRange::WholeLink(range) => range,\n+        }\n+    }\n }\n \n pub(crate) fn markdown_links<R>(\n@@ -1257,16 +1277,17 @@ pub(crate) fn markdown_links<R>(\n         if md_start <= s_start && s_end <= md_end {\n             let start = s_start.offset_from(md_start) as usize;\n             let end = s_end.offset_from(md_start) as usize;\n-            start..end\n+            MarkdownLinkRange::Destination(start..end)\n         } else {\n-            fallback\n+            MarkdownLinkRange::WholeLink(fallback)\n         }\n     };\n \n     let span_for_link = |link: &CowStr<'_>, span: Range<usize>| {\n         // For diagnostics, we want to underline the link's definition but `span` will point at\n         // where the link is used. This is a problem for reference-style links, where the definition\n         // is separate from the usage.\n+\n         match link {\n             // `Borrowed` variant means the string (the link's destination) may come directly from\n             // the markdown text and we can locate the original link destination.\n@@ -1275,8 +1296,80 @@ pub(crate) fn markdown_links<R>(\n             CowStr::Borrowed(s) => locate(s, span),\n \n             // For anything else, we can only use the provided range.\n-            CowStr::Boxed(_) | CowStr::Inlined(_) => span,\n+            CowStr::Boxed(_) | CowStr::Inlined(_) => MarkdownLinkRange::WholeLink(span),\n+        }\n+    };\n+\n+    let span_for_offset_backward = |span: Range<usize>, open: u8, close: u8| {\n+        let mut open_brace = !0;\n+        let mut close_brace = !0;\n+        for (i, b) in md.as_bytes()[span.clone()].iter().copied().enumerate().rev() {\n+            let i = i + span.start;\n+            if b == close {\n+                close_brace = i;\n+                break;\n+            }\n+        }\n+        if close_brace < span.start || close_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        let mut nesting = 1;\n+        for (i, b) in md.as_bytes()[span.start..close_brace].iter().copied().enumerate().rev() {\n+            let i = i + span.start;\n+            if b == close {\n+                nesting += 1;\n+            }\n+            if b == open {\n+                nesting -= 1;\n+            }\n+            if nesting == 0 {\n+                open_brace = i;\n+                break;\n+            }\n+        }\n+        assert!(open_brace != close_brace);\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        // do not actually include braces in the span\n+        let range = (open_brace + 1)..close_brace;\n+        MarkdownLinkRange::Destination(range.clone())\n+    };\n+\n+    let span_for_offset_forward = |span: Range<usize>, open: u8, close: u8| {\n+        let mut open_brace = !0;\n+        let mut close_brace = !0;\n+        for (i, b) in md.as_bytes()[span.clone()].iter().copied().enumerate() {\n+            let i = i + span.start;\n+            if b == open {\n+                open_brace = i;\n+                break;\n+            }\n+        }\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n         }\n+        let mut nesting = 0;\n+        for (i, b) in md.as_bytes()[open_brace..span.end].iter().copied().enumerate() {\n+            let i = i + open_brace;\n+            if b == close {\n+                nesting -= 1;\n+            }\n+            if b == open {\n+                nesting += 1;\n+            }\n+            if nesting == 0 {\n+                close_brace = i;\n+                break;\n+            }\n+        }\n+        assert!(open_brace != close_brace);\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        // do not actually include braces in the span\n+        let range = (open_brace + 1)..close_brace;\n+        MarkdownLinkRange::Destination(range.clone())\n     };\n \n     Parser::new_with_broken_link_callback(\n@@ -1287,11 +1380,20 @@ pub(crate) fn markdown_links<R>(\n     .into_offset_iter()\n     .filter_map(|(event, span)| match event {\n         Event::Start(Tag::Link(link_type, dest, _)) if may_be_doc_link(link_type) => {\n-            preprocess_link(MarkdownLink {\n-                kind: link_type,\n-                range: span_for_link(&dest, span),\n-                link: dest.into_string(),\n-            })\n+            let range = match link_type {\n+                // Link is pulled from the link itself.\n+                LinkType::ReferenceUnknown | LinkType::ShortcutUnknown => {\n+                    span_for_offset_backward(span, b'[', b']')\n+                }\n+                LinkType::CollapsedUnknown => span_for_offset_forward(span, b'[', b']'),\n+                LinkType::Inline => span_for_offset_backward(span, b'(', b')'),\n+                // Link is pulled from elsewhere in the document.\n+                LinkType::Reference | LinkType::Collapsed | LinkType::Shortcut => {\n+                    span_for_link(&dest, span)\n+                }\n+                LinkType::Autolink | LinkType::Email => unreachable!(),\n+            };\n+            preprocess_link(MarkdownLink { kind: link_type, range, link: dest.into_string() })\n         }\n         _ => None,\n     })"}, {"sha": "417bdd58ad45ac1336558f3116e8588ed57ffb14", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 112, "deletions": 62, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -31,7 +31,7 @@ use std::ops::Range;\n use crate::clean::{self, utils::find_nearest_parent_module};\n use crate::clean::{Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n-use crate::html::markdown::{markdown_links, MarkdownLink};\n+use crate::html::markdown::{markdown_links, MarkdownLink, MarkdownLinkRange};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n use crate::passes::Pass;\n use crate::visit::DocVisitor;\n@@ -248,7 +248,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Range<usize>,\n+    link_range: MarkdownLinkRange,\n }\n \n struct LinkCollector<'a, 'tcx> {\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n enum PreprocessingError {\n     /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n-    Disambiguator(Range<usize>, String),\n+    Disambiguator(MarkdownLinkRange, String),\n     MalformedGenerics(MalformedGenerics, String),\n }\n \n@@ -873,6 +873,7 @@ pub(crate) struct PreprocessedMarkdownLink(\n /// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n fn preprocess_link(\n     ori_link: &MarkdownLink,\n+    dox: &str,\n ) -> Option<Result<PreprocessingInfo, PreprocessingError>> {\n     // [] is mostly likely not supposed to be a link\n     if ori_link.link.is_empty() {\n@@ -906,9 +907,15 @@ fn preprocess_link(\n         Err((err_msg, relative_range)) => {\n             // Only report error if we would not have ignored this link. See issue #83859.\n             if !should_ignore_link_with_disambiguators(link) {\n-                let no_backticks_range = range_between_backticks(ori_link);\n-                let disambiguator_range = (no_backticks_range.start + relative_range.start)\n-                    ..(no_backticks_range.start + relative_range.end);\n+                let disambiguator_range = match range_between_backticks(&ori_link.range, dox) {\n+                    MarkdownLinkRange::Destination(no_backticks_range) => {\n+                        MarkdownLinkRange::Destination(\n+                            (no_backticks_range.start + relative_range.start)\n+                                ..(no_backticks_range.start + relative_range.end),\n+                        )\n+                    }\n+                    mdlr @ MarkdownLinkRange::WholeLink(_) => mdlr,\n+                };\n                 return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n             } else {\n                 return None;\n@@ -947,7 +954,7 @@ fn preprocess_link(\n \n fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n     markdown_links(s, |link| {\n-        preprocess_link(&link).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n+        preprocess_link(&link, s).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n     })\n }\n \n@@ -1060,22 +1067,12 @@ impl LinkCollector<'_, '_> {\n                     // valid omission. See https://github.com/rust-lang/rust/pull/80660#discussion_r551585677\n                     // for discussion on the matter.\n                     let kind = self.cx.tcx.def_kind(id);\n-                    self.verify_disambiguator(\n-                        path_str,\n-                        ori_link,\n-                        kind,\n-                        id,\n-                        disambiguator,\n-                        item,\n-                        &diag_info,\n-                    )?;\n+                    self.verify_disambiguator(path_str, kind, id, disambiguator, item, &diag_info)?;\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n                         Some(other) => {\n-                            self.report_disambiguator_mismatch(\n-                                path_str, ori_link, other, res, &diag_info,\n-                            );\n+                            self.report_disambiguator_mismatch(path_str, other, res, &diag_info);\n                             return None;\n                         }\n                     }\n@@ -1096,7 +1093,6 @@ impl LinkCollector<'_, '_> {\n                 };\n                 self.verify_disambiguator(\n                     path_str,\n-                    ori_link,\n                     kind_for_dis,\n                     id_for_dis,\n                     disambiguator,\n@@ -1118,7 +1114,6 @@ impl LinkCollector<'_, '_> {\n     fn verify_disambiguator(\n         &self,\n         path_str: &str,\n-        ori_link: &MarkdownLink,\n         kind: DefKind,\n         id: DefId,\n         disambiguator: Option<Disambiguator>,\n@@ -1142,7 +1137,7 @@ impl LinkCollector<'_, '_> {\n                 => {}\n                 (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n                 (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                    self.report_disambiguator_mismatch(path_str,ori_link,specified, Res::Def(kind, id),diag_info);\n+                    self.report_disambiguator_mismatch(path_str, specified, Res::Def(kind, id), diag_info);\n                     return None;\n                 }\n             }\n@@ -1164,14 +1159,13 @@ impl LinkCollector<'_, '_> {\n     fn report_disambiguator_mismatch(\n         &self,\n         path_str: &str,\n-        ori_link: &MarkdownLink,\n         specified: Disambiguator,\n         resolved: Res,\n         diag_info: &DiagnosticInfo<'_>,\n     ) {\n         // The resolved item did not match the disambiguator; give a better error than 'not found'\n         let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>| {\n+        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>, link_range| {\n             let note = format!(\n                 \"this link resolved to {} {}, which is not {} {}\",\n                 resolved.article(),\n@@ -1184,14 +1178,24 @@ impl LinkCollector<'_, '_> {\n             } else {\n                 diag.note(note);\n             }\n-            suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n+            suggest_disambiguator(resolved, diag, path_str, link_range, sp, diag_info);\n         };\n         report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, callback);\n     }\n \n-    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n-        let span = super::source_span_for_markdown_range(self.cx.tcx, dox, ori_link, &item.attrs)\n-            .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+    fn report_rawptr_assoc_feature_gate(\n+        &self,\n+        dox: &str,\n+        ori_link: &MarkdownLinkRange,\n+        item: &Item,\n+    ) {\n+        let span = super::source_span_for_markdown_range(\n+            self.cx.tcx,\n+            dox,\n+            ori_link.inner_range(),\n+            &item.attrs,\n+        )\n+        .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n         rustc_session::parse::feature_err(\n             &self.cx.tcx.sess.parse_sess,\n             sym::intra_doc_pointers,\n@@ -1371,16 +1375,23 @@ impl LinkCollector<'_, '_> {\n /// [`Foo`]\n ///   ^^^\n /// ```\n-fn range_between_backticks(ori_link: &MarkdownLink) -> Range<usize> {\n-    let after_first_backtick_group = ori_link.link.bytes().position(|b| b != b'`').unwrap_or(0);\n-    let before_second_backtick_group = ori_link\n-        .link\n+///\n+/// This function does nothing if `ori_link.range` is a `MarkdownLinkRange::WholeLink`.\n+fn range_between_backticks(ori_link_range: &MarkdownLinkRange, dox: &str) -> MarkdownLinkRange {\n+    let range = match ori_link_range {\n+        mdlr @ MarkdownLinkRange::WholeLink(_) => return mdlr.clone(),\n+        MarkdownLinkRange::Destination(inner) => inner.clone(),\n+    };\n+    let ori_link_text = &dox[range.clone()];\n+    let after_first_backtick_group = ori_link_text.bytes().position(|b| b != b'`').unwrap_or(0);\n+    let before_second_backtick_group = ori_link_text\n         .bytes()\n         .skip(after_first_backtick_group)\n         .position(|b| b == b'`')\n-        .unwrap_or(ori_link.link.len());\n-    (ori_link.range.start + after_first_backtick_group)\n-        ..(ori_link.range.start + before_second_backtick_group)\n+        .unwrap_or(ori_link_text.len());\n+    MarkdownLinkRange::Destination(\n+        (range.start + after_first_backtick_group)..(range.start + before_second_backtick_group),\n+    )\n }\n \n /// Returns true if we should ignore `link` due to it being unlikely\n@@ -1530,14 +1541,23 @@ impl Suggestion {\n         sp: rustc_span::Span,\n     ) -> Vec<(rustc_span::Span, String)> {\n         let inner_sp = match ori_link.find('(') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => sp.with_hi(sp.lo() + BytePos(index as _)),\n             None => sp,\n         };\n         let inner_sp = match ori_link.find('!') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => inner_sp.with_hi(inner_sp.lo() + BytePos(index as _)),\n             None => inner_sp,\n         };\n         let inner_sp = match ori_link.find('@') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => inner_sp.with_lo(inner_sp.lo() + BytePos(index as u32 + 1)),\n             None => inner_sp,\n         };\n@@ -1584,7 +1604,7 @@ fn report_diagnostic(\n     lint: &'static Lint,\n     msg: impl Into<DiagnosticMessage> + Display,\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n-    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n+    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>, MarkdownLinkRange),\n ) {\n     let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n     else {\n@@ -1596,16 +1616,32 @@ fn report_diagnostic(\n     let sp = item.attr_span(tcx);\n \n     tcx.struct_span_lint_hir(lint, hir_id, sp, msg, |lint| {\n-        let span =\n-            super::source_span_for_markdown_range(tcx, dox, link_range, &item.attrs).map(|sp| {\n-                if dox.as_bytes().get(link_range.start) == Some(&b'`')\n-                    && dox.as_bytes().get(link_range.end - 1) == Some(&b'`')\n-                {\n-                    sp.with_lo(sp.lo() + BytePos(1)).with_hi(sp.hi() - BytePos(1))\n-                } else {\n-                    sp\n-                }\n-            });\n+        let (span, link_range) = match link_range {\n+            MarkdownLinkRange::Destination(md_range) => {\n+                let mut md_range = md_range.clone();\n+                let sp = super::source_span_for_markdown_range(tcx, dox, &md_range, &item.attrs)\n+                    .map(|mut sp| {\n+                        while dox.as_bytes().get(md_range.start) == Some(&b' ')\n+                            || dox.as_bytes().get(md_range.start) == Some(&b'`')\n+                        {\n+                            md_range.start += 1;\n+                            sp = sp.with_lo(sp.lo() + BytePos(1));\n+                        }\n+                        while dox.as_bytes().get(md_range.end - 1) == Some(&b' ')\n+                            || dox.as_bytes().get(md_range.end - 1) == Some(&b'`')\n+                        {\n+                            md_range.end -= 1;\n+                            sp = sp.with_hi(sp.hi() - BytePos(1));\n+                        }\n+                        sp\n+                    });\n+                (sp, MarkdownLinkRange::Destination(md_range))\n+            }\n+            MarkdownLinkRange::WholeLink(md_range) => (\n+                super::source_span_for_markdown_range(tcx, dox, &md_range, &item.attrs),\n+                link_range.clone(),\n+            ),\n+        };\n \n         if let Some(sp) = span {\n             lint.set_span(sp);\n@@ -1614,21 +1650,22 @@ fn report_diagnostic(\n             //                       ^     ~~~~\n             //                       |     link_range\n             //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let md_range = link_range.inner_range().clone();\n+            let last_new_line_offset = dox[..md_range.start].rfind('\\n').map_or(0, |n| n + 1);\n             let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            // Print the line containing the `md_range` and manually mark it with '^'s.\n             lint.note(format!(\n                 \"the link appears in this line:\\n\\n{line}\\n\\\n                      {indicator: <before$}{indicator:^<found$}\",\n                 line = line,\n                 indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n+                before = md_range.start - last_new_line_offset,\n+                found = md_range.len(),\n             ));\n         }\n \n-        decorate(lint, span);\n+        decorate(lint, span, link_range);\n \n         lint\n     });\n@@ -1652,7 +1689,7 @@ fn resolution_failure(\n         BROKEN_INTRA_DOC_LINKS,\n         format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n-        |diag, sp| {\n+        |diag, sp, link_range| {\n             let item = |res: Res| format!(\"the {} `{}`\", res.descr(), res.name(tcx),);\n             let assoc_item_not_allowed = |res: Res| {\n                 let name = res.name(tcx);\n@@ -1845,7 +1882,14 @@ fn resolution_failure(\n                 let note = match failure {\n                     ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n                     ResolutionFailure::WrongNamespace { res, expected_ns } => {\n-                        suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n+                        suggest_disambiguator(\n+                            res,\n+                            diag,\n+                            path_str,\n+                            link_range.clone(),\n+                            sp,\n+                            &diag_info,\n+                        );\n \n                         format!(\n                             \"this link resolves to {}, which is not in the {} namespace\",\n@@ -1882,7 +1926,7 @@ fn anchor_failure(\n     msg: String,\n     anchor_idx: usize,\n ) {\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp, _link_range| {\n         if let Some(mut sp) = sp {\n             if let Some((fragment_offset, _)) =\n                 diag_info.ori_link.char_indices().filter(|(_, x)| *x == '#').nth(anchor_idx)\n@@ -1898,11 +1942,11 @@ fn anchor_failure(\n fn disambiguator_error(\n     cx: &DocContext<'_>,\n     mut diag_info: DiagnosticInfo<'_>,\n-    disambiguator_range: Range<usize>,\n+    disambiguator_range: MarkdownLinkRange,\n     msg: impl Into<DiagnosticMessage> + Display,\n ) {\n     diag_info.link_range = disambiguator_range;\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp, _link_range| {\n         let msg = format!(\n             \"see {}/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\",\n             crate::DOC_RUST_LANG_ORG_CHANNEL\n@@ -1922,7 +1966,7 @@ fn report_malformed_generics(\n         BROKEN_INTRA_DOC_LINKS,\n         format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n-        |diag, sp| {\n+        |diag, sp, _link_range| {\n             let note = match err {\n                 MalformedGenerics::UnbalancedAngleBrackets => \"unbalanced angle brackets\",\n                 MalformedGenerics::MissingType => \"missing type for generic parameters\",\n@@ -1995,15 +2039,15 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp, link_range| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n             diag.note(\"ambiguous link\");\n         }\n \n         for res in kinds {\n-            suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n+            suggest_disambiguator(res, diag, path_str, link_range.clone(), sp, diag_info);\n         }\n     });\n     true\n@@ -2015,13 +2059,19 @@ fn suggest_disambiguator(\n     res: Res,\n     diag: &mut Diagnostic,\n     path_str: &str,\n-    ori_link: &str,\n+    link_range: MarkdownLinkRange,\n     sp: Option<rustc_span::Span>,\n+    diag_info: &DiagnosticInfo<'_>,\n ) {\n     let suggestion = res.disambiguator_suggestion();\n     let help = format!(\"to link to the {}, {}\", res.descr(), suggestion.descr());\n \n-    if let Some(sp) = sp {\n+    let ori_link = match link_range {\n+        MarkdownLinkRange::Destination(range) => Some(&diag_info.dox[range]),\n+        MarkdownLinkRange::WholeLink(_) => None,\n+    };\n+\n+    if let (Some(sp), Some(ori_link)) = (sp, ori_link) {\n         let mut spans = suggestion.as_help_span(path_str, ori_link, sp);\n         if spans.len() > 1 {\n             diag.multipart_suggestion(help, spans, Applicability::MaybeIncorrect);\n@@ -2047,7 +2097,7 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp, _link_range| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "eb813af779ef66f402ea1ce4b8c218b7320853c7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -305,11 +305,27 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        if !self.view_item_stack.insert(res_did) {\n+        let is_bang_macro = matches!(\n+            tcx.hir().get_by_def_id(res_did),\n+            Node::Item(&hir::Item { kind: hir::ItemKind::Macro(_, MacroKind::Bang), .. })\n+        );\n+\n+        if !self.view_item_stack.insert(res_did) && !is_bang_macro {\n             return false;\n         }\n \n         let ret = match tcx.hir().get_by_def_id(res_did) {\n+            // Bang macros are handled a bit on their because of how they are handled by the\n+            // compiler. If they have `#[doc(hidden)]` and the re-export doesn't have\n+            // `#[doc(inline)]`, then we don't inline it.\n+            Node::Item(_)\n+                if is_bang_macro\n+                    && !please_inline\n+                    && renamed.is_some()\n+                    && self.cx.tcx.is_doc_hidden(ori_res_did) =>\n+            {\n+                return false;\n+            }\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {"}, {"sha": "6c834fd0a1b617ba9c4a5f2a0640f992a2b5bc92", "filename": "tests/rustdoc-ui/intra-doc/issue-110495-suffix-with-space.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -36,7 +36,7 @@ LL | //! [`Clone ()`].\n help: to link to the trait, prefix with `trait@`\n    |\n LL - //! [`Clone ()`].\n-LL + //! [`trait@Clone (`].\n+LL + //! [`trait@Clone `].\n    |\n \n error: incompatible link kind for `Clone`\n@@ -47,8 +47,9 @@ LL | //! [`Clone !`].\n    |\n help: to link to the derive macro, prefix with `derive@`\n    |\n-LL | //! [`derive@Clone !`].\n-   |       +++++++\n+LL - //! [`Clone !`].\n+LL + //! [`derive@Clone `].\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ca18842fb21c5e8199205c80919f7b6f9fa8aaef", "filename": "tests/rustdoc-ui/intra-doc/weird-syntax.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -0,0 +1,140 @@\n+// Many examples are from\n+// https://github.com/rust-lang/rust/issues/110111#issuecomment-1517800781\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+//! This test case is closely linked to [raphlinus/pulldown-cmark#441], getting offsets of\n+//! link components. In particular, pulldown-cmark doesn't provide the offsets of the contents\n+//! of a link.\n+//!\n+//! To work around this, rustdoc parses parts of a link definition itself. This is basically a\n+//! test suite for that link syntax parser.\n+//!\n+//! [raphlinus/pulldown-cmark#441]: https://github.com/raphlinus/pulldown-cmark/issues/441\n+\n+use std::clone::Clone;\n+\n+// Basic version //\n+\n+/// [`struct@Clone`] //~ERROR link\n+pub struct LinkToCloneWithBackquotes;\n+\n+/// [```struct@Clone```] //~ERROR link\n+pub struct LinkToCloneWithMultipleBackquotes;\n+\n+/// [  `  struct@Clone  `  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesAndBackquotes;\n+\n+/// [  `Clone ()`  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesBackquotesAndParens;\n+\n+/// [`Clone ()`  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesEndBackquotesAndParens;\n+\n+/// [  `Clone ()`] //~ERROR link\n+pub struct LinkToCloneWithSpacesStartBackquotesAndParens;\n+\n+/// [```Clone ()```] //~ERROR link\n+pub struct LinkToCloneWithMultipleBackquotesAndParens;\n+\n+/// [```Clone \\(\\)```] // not URL-shaped enough\n+pub struct LinkToCloneWithMultipleBackquotesAndEscapedParens;\n+\n+/// [  ```  Clone ()  ```  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesMultipleBackquotesAndParens;\n+\n+/// [ x \\] ] // not URL-shaped enough\n+pub struct LinkWithEscapedCloseBrace;\n+\n+/// [ x \\[ ] // not URL-shaped enough\n+pub struct LinkWithEscapedOpenBrace;\n+\n+/// [ x \\( ] // not URL-shaped enough\n+pub struct LinkWithEscapedCloseParen;\n+\n+/// [ x \\) ] // not URL-shaped enough\n+pub struct LinkWithEscapedOpenParen;\n+\n+/// [ Clone \\(\\) ] // not URL-shaped enough\n+pub struct LinkWithEscapedParens;\n+\n+// [][] version //\n+\n+/// [x][ struct@Clone] //~ERROR link\n+pub struct XLinkToCloneWithStartSpace;\n+\n+/// [x][struct@Clone ] //~ERROR link\n+pub struct XLinkToCloneWithEndSpace;\n+\n+/// [x][Clone\\(\\)] not URL-shaped enough\n+pub struct XLinkToCloneWithEscapedParens;\n+\n+/// [x][`Clone`] not URL-shaped enough\n+pub struct XLinkToCloneWithBackquotes;\n+\n+/// [x][Clone()] //~ERROR link\n+pub struct XLinkToCloneWithUnescapedParens;\n+\n+/// [x][Clone  ()] //~ERROR link\n+pub struct XLinkToCloneWithUnescapedParensAndDoubleSpace;\n+\n+/// [x][Clone  [] //~ERROR unresolved link to `x`\n+pub struct XLinkToCloneWithUnmatchedOpenParenAndDoubleSpace;\n+\n+/// [x][Clone  \\[] // not URL-shaped enough\n+pub struct XLinkToCloneWithUnmatchedEscapedOpenParenAndDoubleSpace;\n+\n+/// [x][Clone  \\]] // not URL-shaped enough\n+pub struct XLinkToCloneWithUnmatchedEscapedCloseParenAndDoubleSpace;\n+\n+// []() version //\n+\n+/// [w]( struct@Clone) //~ERROR link\n+pub struct WLinkToCloneWithStartSpace;\n+\n+/// [w](struct@Clone ) //~ERROR link\n+pub struct WLinkToCloneWithEndSpace;\n+\n+/// [w](Clone\\(\\)) //~ERROR link\n+pub struct WLinkToCloneWithEscapedParens;\n+\n+/// [w](`Clone`) not URL-shaped enough\n+pub struct WLinkToCloneWithBackquotes;\n+\n+/// [w](Clone()) //~ERROR link\n+pub struct WLinkToCloneWithUnescapedParens;\n+\n+/// [w](Clone  ()) not URL-shaped enough\n+pub struct WLinkToCloneWithUnescapedParensAndDoubleSpace;\n+\n+/// [w](Clone  () //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedOpenParenAndDoubleSpace;\n+\n+/// [w](Clone  \\() //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedEscapedOpenParenAndDoubleSpace;\n+\n+/// [w](Clone  \\)) //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedEscapedCloseParenAndDoubleSpace;\n+\n+// References\n+\n+/// The [cln][] link here is going to be unresolved, because `Clone()` gets rejected //~ERROR link\n+/// in Markdown for not being URL-shaped enough.\n+///\n+/// [cln]: Clone() //~ERROR link\n+pub struct LinkToCloneWithParensInReference;\n+\n+/// The [cln][] link here is going to be unresolved, because `struct@Clone` gets //~ERROR link\n+/// rejected in Markdown for not being URL-shaped enough.\n+///\n+/// [cln]: struct@Clone //~ERROR link\n+pub struct LinkToCloneWithWrongPrefix;\n+\n+/// The [cln][] link here will produce a plain text suggestion //~ERROR link\n+///\n+/// [cln]: Clone\\(\\)\n+pub struct LinkToCloneWithEscapedParensInReference;\n+\n+/// The [cln][] link here will produce a plain text suggestion //~ERROR link\n+///\n+/// [cln]: struct\\@Clone\n+pub struct LinkToCloneWithEscapedAtsInReference;"}, {"sha": "f50feb57fccf2729d043a5e69ba13f3fe0958398", "filename": "tests/rustdoc-ui/intra-doc/weird-syntax.stderr", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -0,0 +1,272 @@\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:18:7\n+   |\n+LL | /// [`struct@Clone`]\n+   |       ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+note: the lint level is defined here\n+  --> $DIR/weird-syntax.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@Clone`]\n+   |       ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:21:9\n+   |\n+LL | /// [```struct@Clone```]\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [```trait@Clone```]\n+   |         ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:24:11\n+   |\n+LL | /// [  `  struct@Clone  `  ]\n+   |           ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [  `  trait@Clone  `  ]\n+   |           ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:27:9\n+   |\n+LL | /// [  `Clone ()`  ]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  `Clone ()`  ]\n+LL + /// [  `trait@Clone `  ]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:30:7\n+   |\n+LL | /// [`Clone ()`  ]\n+   |       ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [`Clone ()`  ]\n+LL + /// [`trait@Clone `  ]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:33:9\n+   |\n+LL | /// [  `Clone ()`]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  `Clone ()`]\n+LL + /// [  `trait@Clone `]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:36:9\n+   |\n+LL | /// [```Clone ()```]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [```Clone ()```]\n+LL + /// [```trait@Clone ```]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:42:13\n+   |\n+LL | /// [  ```  Clone ()  ```  ]\n+   |             ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  ```  Clone ()  ```  ]\n+LL + /// [  ```  trait@Clone   ```  ]\n+   |\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:62:10\n+   |\n+LL | /// [x][ struct@Clone]\n+   |          ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [x][ trait@Clone]\n+   |          ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:65:9\n+   |\n+LL | /// [x][struct@Clone ]\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [x][trait@Clone ]\n+   |         ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:74:9\n+   |\n+LL | /// [x][Clone()]\n+   |         ^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [x][Clone()]\n+LL + /// [x][trait@Clone]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:77:9\n+   |\n+LL | /// [x][Clone  ()]\n+   |         ^^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [x][Clone  ()]\n+LL + /// [x][trait@Clone  ]\n+   |\n+\n+error: unresolved link to `x`\n+  --> $DIR/weird-syntax.rs:80:6\n+   |\n+LL | /// [x][Clone  []\n+   |      ^ no item named `x` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:91:10\n+   |\n+LL | /// [w]( struct@Clone)\n+   |          ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [w]( trait@Clone)\n+   |          ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:94:9\n+   |\n+LL | /// [w](struct@Clone )\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [w](trait@Clone )\n+   |         ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:97:9\n+   |\n+LL | /// [w](Clone\\(\\))\n+   |         ^^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [w](Clone\\(\\))\n+LL + /// [w](trait@Clone)\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:103:9\n+   |\n+LL | /// [w](Clone())\n+   |         ^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [w](Clone())\n+LL + /// [w](trait@Clone)\n+   |\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:109:6\n+   |\n+LL | /// [w](Clone  ()\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:112:6\n+   |\n+LL | /// [w](Clone  \\()\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:115:6\n+   |\n+LL | /// [w](Clone  \\))\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:120:10\n+   |\n+LL | /// The [cln][] link here is going to be unresolved, because `Clone()` gets rejected\n+   |          ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:123:6\n+   |\n+LL | /// [cln]: Clone()\n+   |      ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:126:10\n+   |\n+LL | /// The [cln][] link here is going to be unresolved, because `struct@Clone` gets\n+   |          ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:129:6\n+   |\n+LL | /// [cln]: struct@Clone\n+   |      ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:132:9\n+   |\n+LL | /// The [cln][] link here will produce a plain text suggestion\n+   |         ^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+   = help: to link to the trait, prefix with `trait@`: trait@Clone\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:137:9\n+   |\n+LL | /// The [cln][] link here will produce a plain text suggestion\n+   |         ^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+   = help: to link to the trait, prefix with `trait@`: trait@Clone\n+\n+error: aborting due to 26 previous errors\n+"}, {"sha": "d9ed954868e50a9b4b1d895f6598a15ec68aa368", "filename": "tests/rustdoc/reexport-doc-hidden.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc%2Freexport-doc-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc%2Freexport-doc-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-doc-hidden.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -21,6 +21,5 @@ macro_rules! foo {\n     () => {};\n }\n \n-// This is a bug: https://github.com/rust-lang/rust/issues/59368\n-// @!has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n+// @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n pub use crate::foo as Macro;"}, {"sha": "47a21e39462251473ebb9fd6e72eb7166df16ece", "filename": "tests/rustdoc/reexport-hidden-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc%2Freexport-hidden-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc%2Freexport-hidden-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-hidden-macro.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -5,6 +5,7 @@\n \n // @has 'foo/index.html'\n // @has - '//*[@id=\"main-content\"]//a[@href=\"macro.Macro2.html\"]' 'Macro2'\n+// @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n \n // @has 'foo/macro.Macro2.html'\n // @has - '//*[@class=\"docblock\"]' 'Displayed'\n@@ -15,7 +16,6 @@ macro_rules! foo {\n     () => {};\n }\n \n-/// not displayed\n pub use crate::foo as Macro;\n /// Displayed\n #[doc(inline)]"}, {"sha": "b733716c22a3b65f62c8a7f21436b184ffbf11ea", "filename": "tests/rustdoc/reexport-of-doc-hidden.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc%2Freexport-of-doc-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Frustdoc%2Freexport-of-doc-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-of-doc-hidden.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -0,0 +1,42 @@\n+// This test ensures that all re-exports of doc hidden elements are displayed.\n+\n+#![crate_name = \"foo\"]\n+\n+#[doc(hidden)]\n+pub struct Bar;\n+\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! foo {\n+    () => {};\n+}\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n+pub use crate::foo as Macro;\n+// @has - '//*[@id=\"reexport.Macro2\"]/code' 'pub use crate::foo as Macro2;'\n+pub use crate::foo as Macro2;\n+// @has - '//*[@id=\"reexport.Boo\"]/code' 'pub use crate::Bar as Boo;'\n+pub use crate::Bar as Boo;\n+// @has - '//*[@id=\"reexport.Boo2\"]/code' 'pub use crate::Bar as Boo2;'\n+pub use crate::Bar as Boo2;\n+\n+pub fn fofo() {}\n+\n+// @has - '//*[@id=\"reexport.f1\"]/code' 'pub use crate::fofo as f1;'\n+pub use crate::fofo as f1;\n+// @has - '//*[@id=\"reexport.f2\"]/code' 'pub use crate::fofo as f2;'\n+pub use crate::fofo as f2;\n+\n+pub mod sub {\n+    // @has 'foo/sub/index.html'\n+    // @has - '//*[@id=\"reexport.Macro\"]/code' 'pub use crate::foo as Macro;'\n+    pub use crate::foo as Macro;\n+    // @has - '//*[@id=\"reexport.Macro2\"]/code' 'pub use crate::foo as Macro2;'\n+    pub use crate::foo as Macro2;\n+\n+    // @has - '//*[@id=\"reexport.f1\"]/code' 'pub use crate::fofo as f1;'\n+    pub use crate::fofo as f1;\n+    // @has - '//*[@id=\"reexport.f2\"]/code' 'pub use crate::fofo as f2;'\n+    pub use crate::fofo as f2;\n+}"}, {"sha": "1bda7a4971375491003540a23cfc68c4a02887f5", "filename": "tests/ui/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -8,7 +8,6 @@ fn a() {\n         //~^ NOTE `vec[_]` is borrowed here\n             vec[0] = Box::new(4); //~ ERROR cannot assign\n             //~^ NOTE `vec[_]` is assigned to here\n-            //~| NOTE in this expansion of desugaring of drop and replace\n             _a.use_ref();\n             //~^ NOTE borrow later used here\n         }\n@@ -23,7 +22,6 @@ fn b() {\n         //~^ `vec[_]` is borrowed here\n             vec[0] = Box::new(4); //~ ERROR cannot assign\n             //~^ NOTE `vec[_]` is assigned to here\n-            //~| NOTE in this expansion of desugaring of drop and replace\n             _b.use_ref();\n             //~^ NOTE borrow later used here\n         }"}, {"sha": "70b9e4f4433b34e8ae6926e2fd507c658bf92c15", "filename": "tests/ui/borrowck/borrowck-vec-pattern-nesting.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -6,24 +6,24 @@ LL |         [box ref _a, _, _] => {\n LL |\n LL |             vec[0] = Box::new(4);\n    |             ^^^^^^ `vec[_]` is assigned to here but it was already borrowed\n-...\n+LL |\n LL |             _a.use_ref();\n    |             ------------ borrow later used here\n \n error[E0506]: cannot assign to `vec[_]` because it is borrowed\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:24:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:23:13\n    |\n LL |         &mut [ref _b @ ..] => {\n    |               ------ `vec[_]` is borrowed here\n LL |\n LL |             vec[0] = Box::new(4);\n    |             ^^^^^^ `vec[_]` is assigned to here but it was already borrowed\n-...\n+LL |\n LL |             _b.use_ref();\n    |             ------------ borrow later used here\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:36:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:34:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -41,7 +41,7 @@ LL +         [_a,\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:48:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:46:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^\n@@ -55,7 +55,7 @@ LL |     let a = &vec[0];\n    |             +\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:57:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:55:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -73,7 +73,7 @@ LL +         [\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:67:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:65:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^\n@@ -87,7 +87,7 @@ LL |     let a = &vec[0];\n    |             +\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:76:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:74:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -106,7 +106,7 @@ LL +         [_a, _b, _c] => {}\n    |\n \n error[E0508]: cannot move out of type `[Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:87:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:85:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^"}, {"sha": "ded46e56e34514c8d9010dff9e0c203370091ab1", "filename": "tests/ui/borrowck/issue-45199.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fissue-45199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fissue-45199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-45199.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -5,7 +5,6 @@ fn test_drop_replace() {\n     b = Box::new(1);    //~ NOTE first assignment\n     b = Box::new(2);    //~ ERROR cannot assign twice to immutable variable `b`\n                         //~| NOTE cannot assign twice to immutable\n-                        //~| NOTE in this expansion of desugaring of drop and replace\n }\n \n fn test_call() {\n@@ -14,14 +13,12 @@ fn test_call() {\n                             //~| SUGGESTION mut b\n     b = Box::new(2);        //~ ERROR cannot assign twice to immutable variable `b`\n                             //~| NOTE cannot assign twice to immutable\n-                            //~| NOTE in this expansion of desugaring of drop and replace\n }\n \n fn test_args(b: Box<i32>) {  //~ HELP consider making this binding mutable\n                                 //~| SUGGESTION mut b\n     b = Box::new(2);            //~ ERROR cannot assign to immutable argument `b`\n                                 //~| NOTE cannot assign to immutable argument\n-                                //~| NOTE in this expansion of desugaring of drop and replace\n }\n \n fn main() {}"}, {"sha": "47aa30908270d91b7ac9107dcf7318ea259b5e6a", "filename": "tests/ui/borrowck/issue-45199.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fissue-45199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fborrowck%2Fissue-45199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-45199.stderr?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -10,7 +10,7 @@ LL |     b = Box::new(2);\n    |     ^ cannot assign twice to immutable variable\n \n error[E0384]: cannot assign twice to immutable variable `b`\n-  --> $DIR/issue-45199.rs:15:5\n+  --> $DIR/issue-45199.rs:14:5\n    |\n LL |     let b = Box::new(1);\n    |         -\n@@ -22,7 +22,7 @@ LL |     b = Box::new(2);\n    |     ^ cannot assign twice to immutable variable\n \n error[E0384]: cannot assign to immutable argument `b`\n-  --> $DIR/issue-45199.rs:22:5\n+  --> $DIR/issue-45199.rs:20:5\n    |\n LL | fn test_args(b: Box<i32>) {\n    |              - help: consider making this binding mutable: `mut b`"}, {"sha": "c9b16e43910e8e9f6215acc0ed4ed4b3ecca2c64", "filename": "tests/ui/liveness/liveness-assign/liveness-assign-imm-local-with-drop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fliveness%2Fliveness-assign%2Fliveness-assign-imm-local-with-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b311b4189cce2bde455f3e091ae662a382d592/tests%2Fui%2Fliveness%2Fliveness-assign%2Fliveness-assign-imm-local-with-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliveness%2Fliveness-assign%2Fliveness-assign-imm-local-with-drop.rs?ref=82b311b4189cce2bde455f3e091ae662a382d592", "patch": "@@ -5,7 +5,6 @@ fn test() {\n     drop(b);\n     b = Box::new(2); //~ ERROR cannot assign twice to immutable variable `b`\n                      //~| NOTE cannot assign twice to immutable\n-                     //~| NOTE in this expansion of desugaring of drop and replace\n     drop(b);\n }\n "}]}