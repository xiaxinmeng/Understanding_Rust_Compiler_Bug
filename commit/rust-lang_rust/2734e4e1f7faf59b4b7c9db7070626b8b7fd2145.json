{"sha": "2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MzRlNGUxZjdmYWY1OWI0YjdjOWRiNzA3MDYyNmI4YjdmZDIxNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-24T08:33:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-24T08:33:03Z"}, "message": "Auto merge of #4897 - krishna-veerareddy:issue-2040-accurate-float-functions, r=flip1995\n\nAdd lint to improve floating-point expressions\n\nLooks for floating-point expressions that can be expressed using built-in methods to improve accuracy, performance and/or succinctness.\n\nchangelog: Add lint `floating_point_improvements`.\n\nFixes #4726\nPartly addresses [#2040](https://github.com/rust-lang/rust-clippy/issues/2040)\n\nCurrently linted expressions:\n\n| Expression | Suggestion |\n|---------------------------------|------------|\n| x.log(2.0) | x.log2() |\n| x.log(10.0) | x.log10() |\n| x.log(std::f32::consts::E) | x.ln() |\n| (1 + x).ln() | x.ln_1p() |\n| (2.0).powf(x) | x.exp2() |\n| (std::f32::consts::E).powf(x) | x.exp() |\n| x.powf(1/2) | x.sqrt() |\n| x.powf(1/3) | x.cbrt() |\n| x.powf(y), where y is whole | x.powi(y) |\n| x.exp() - 1 | x.exp_m1() |\n|x * y + z|x.mul_add(y, z)|", "tree": {"sha": "08b93e137d6e77beb482e15b0340d27a6ed09be5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b93e137d6e77beb482e15b0340d27a6ed09be5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "html_url": "https://github.com/rust-lang/rust/commit/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "html_url": "https://github.com/rust-lang/rust/commit/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3"}, {"sha": "ff0d44e45a27e688b5ee5447dc9175d5e72b37c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0d44e45a27e688b5ee5447dc9175d5e72b37c9", "html_url": "https://github.com/rust-lang/rust/commit/ff0d44e45a27e688b5ee5447dc9175d5e72b37c9"}], "stats": {"total": 1355, "additions": 1092, "deletions": 263}, "files": [{"sha": "99e84ea51931d2a5b18a09f2fbc99eece52754d8", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -1169,6 +1169,7 @@ Released 2018-09-13\n [`ifs_same_cond`]: https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond\n [`implicit_hasher`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_hasher\n [`implicit_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return\n+[`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n [`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing\n [`ineffective_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#ineffective_bit_mask\n@@ -1210,7 +1211,6 @@ Released 2018-09-13\n [`lossy_float_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#lossy_float_literal\n [`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n-[`manual_mul_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_mul_add\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n@@ -1349,6 +1349,7 @@ Released 2018-09-13\n [`string_lit_as_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_lit_as_bytes\n [`string_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_to_string\n [`struct_excessive_bools`]: https://rust-lang.github.io/rust-clippy/master/index.html#struct_excessive_bools\n+[`suboptimal_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#suboptimal_flops\n [`suspicious_arithmetic_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_arithmetic_impl\n [`suspicious_assignment_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_assignment_formatting\n [`suspicious_else_formatting`]: https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_else_formatting"}, {"sha": "1300c5ad47bf0bd2ba654770ae66ecf3aa03b8ed", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 357 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 358 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "eed4f58cf902d82458c38bbe274df127b815cc71", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,380 @@\n+use crate::consts::{\n+    constant, Constant,\n+    Constant::{F32, F64},\n+};\n+use crate::utils::{span_lint_and_sugg, sugg};\n+use if_chain::if_chain;\n+use rustc::ty;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+use std::f32::consts as f32_consts;\n+use std::f64::consts as f64_consts;\n+use sugg::{format_numeric_literal, Sugg};\n+use syntax::ast;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Looks for floating-point expressions that\n+    /// can be expressed using built-in methods to improve accuracy\n+    /// at the cost of performance.\n+    ///\n+    /// **Why is this bad?** Negatively impacts accuracy.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = a.powf(1.0 / 3.0);\n+    /// let _ = (1.0 + a).ln();\n+    /// let _ = a.exp() - 1.0;\n+    /// ```\n+    ///\n+    /// is better expressed as\n+    ///\n+    /// ```rust\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = a.cbrt();\n+    /// let _ = a.ln_1p();\n+    /// let _ = a.exp_m1();\n+    /// ```\n+    pub IMPRECISE_FLOPS,\n+    nursery,\n+    \"usage of imprecise floating point operations\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Looks for floating-point expressions that\n+    /// can be expressed using built-in methods to improve both\n+    /// accuracy and performance.\n+    ///\n+    /// **Why is this bad?** Negatively impacts accuracy and performance.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::f32::consts::E;\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = (2f32).powf(a);\n+    /// let _ = E.powf(a);\n+    /// let _ = a.powf(1.0 / 2.0);\n+    /// let _ = a.log(2.0);\n+    /// let _ = a.log(10.0);\n+    /// let _ = a.log(E);\n+    /// let _ = a.powf(2.0);\n+    /// let _ = a * 2.0 + 4.0;\n+    /// ```\n+    ///\n+    /// is better expressed as\n+    ///\n+    /// ```rust\n+    /// use std::f32::consts::E;\n+    ///\n+    /// let a = 3f32;\n+    /// let _ = a.exp2();\n+    /// let _ = a.exp();\n+    /// let _ = a.sqrt();\n+    /// let _ = a.log2();\n+    /// let _ = a.log10();\n+    /// let _ = a.ln();\n+    /// let _ = a.powi(2);\n+    /// let _ = a.mul_add(2.0, 4.0);\n+    /// ```\n+    pub SUBOPTIMAL_FLOPS,\n+    nursery,\n+    \"usage of sub-optimal floating point operations\"\n+}\n+\n+declare_lint_pass!(FloatingPointArithmetic => [\n+    IMPRECISE_FLOPS,\n+    SUBOPTIMAL_FLOPS\n+]);\n+\n+// Returns the specialized log method for a given base if base is constant\n+// and is one of 2, 10 and e\n+fn get_specialized_log_method(cx: &LateContext<'_, '_>, base: &Expr<'_>) -> Option<&'static str> {\n+    if let Some((value, _)) = constant(cx, cx.tables, base) {\n+        if F32(2.0) == value || F64(2.0) == value {\n+            return Some(\"log2\");\n+        } else if F32(10.0) == value || F64(10.0) == value {\n+            return Some(\"log10\");\n+        } else if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            return Some(\"ln\");\n+        }\n+    }\n+\n+    None\n+}\n+\n+// Adds type suffixes and parenthesis to method receivers if necessary\n+fn prepare_receiver_sugg<'a>(cx: &LateContext<'_, '_>, mut expr: &'a Expr<'a>) -> Sugg<'a> {\n+    let mut suggestion = Sugg::hir(cx, expr, \"..\");\n+\n+    if let ExprKind::Unary(UnOp::UnNeg, inner_expr) = &expr.kind {\n+        expr = &inner_expr;\n+    }\n+\n+    if_chain! {\n+        // if the expression is a float literal and it is unsuffixed then\n+        // add a suffix so the suggestion is valid and unambiguous\n+        if let ty::Float(float_ty) = cx.tables.expr_ty(expr).kind;\n+        if let ExprKind::Lit(lit) = &expr.kind;\n+        if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n+        then {\n+            let op = format!(\n+                \"{}{}{}\",\n+                suggestion,\n+                // Check for float literals without numbers following the decimal\n+                // separator such as `2.` and adds a trailing zero\n+                if sym.as_str().ends_with('.') {\n+                    \"0\"\n+                } else {\n+                    \"\"\n+                },\n+                float_ty.name_str()\n+            ).into();\n+\n+            suggestion = match suggestion {\n+                Sugg::MaybeParen(_) => Sugg::MaybeParen(op),\n+                _ => Sugg::NonParen(op)\n+            };\n+        }\n+    }\n+\n+    suggestion.maybe_par()\n+}\n+\n+fn check_log_base(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(method) = get_specialized_log_method(cx, &args[1]) {\n+        span_lint_and_sugg(\n+            cx,\n+            SUBOPTIMAL_FLOPS,\n+            expr.span,\n+            \"logarithm for bases 2, 10 and e can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.{}()\", Sugg::hir(cx, &args[0], \"..\"), method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// TODO: Lint expressions of the form `(x + y).ln()` where y > 1 and\n+// suggest usage of `(x + (y - 1)).ln_1p()` instead\n+fn check_ln1p(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Add, ..\n+        },\n+        lhs,\n+        rhs,\n+    ) = &args[0].kind\n+    {\n+        let recv = match (constant(cx, cx.tables, lhs), constant(cx, cx.tables, rhs)) {\n+            (Some((value, _)), _) if F32(1.0) == value || F64(1.0) == value => rhs,\n+            (_, Some((value, _))) if F32(1.0) == value || F64(1.0) == value => lhs,\n+            _ => return,\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            IMPRECISE_FLOPS,\n+            expr.span,\n+            \"ln(1 + x) can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.ln_1p()\", prepare_receiver_sugg(cx, recv)),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// Returns an integer if the float constant is a whole number and it can be\n+// converted to an integer without loss of precision. For now we only check\n+// ranges [-16777215, 16777216) for type f32 as whole number floats outside\n+// this range are lossy and ambiguous.\n+#[allow(clippy::cast_possible_truncation)]\n+fn get_integer_from_float_constant(value: &Constant) -> Option<i32> {\n+    match value {\n+        F32(num) if num.fract() == 0.0 => {\n+            if (-16_777_215.0..16_777_216.0).contains(num) {\n+                Some(num.round() as i32)\n+            } else {\n+                None\n+            }\n+        },\n+        F64(num) if num.fract() == 0.0 => {\n+            if (-2_147_483_648.0..2_147_483_648.0).contains(num) {\n+                Some(num.round() as i32)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    // Check receiver\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[0]) {\n+        let method = if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            \"exp\"\n+        } else if F32(2.0) == value || F64(2.0) == value {\n+            \"exp2\"\n+        } else {\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            SUBOPTIMAL_FLOPS,\n+            expr.span,\n+            \"exponent for bases 2 and e can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.{}()\", prepare_receiver_sugg(cx, &args[1]), method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    // Check argument\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[1]) {\n+        let (lint, help, suggestion) = if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n+            (\n+                SUBOPTIMAL_FLOPS,\n+                \"square-root of a number can be computed more efficiently and accurately\",\n+                format!(\"{}.sqrt()\", Sugg::hir(cx, &args[0], \"..\")),\n+            )\n+        } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n+            (\n+                IMPRECISE_FLOPS,\n+                \"cube-root of a number can be computed more accurately\",\n+                format!(\"{}.cbrt()\", Sugg::hir(cx, &args[0], \"..\")),\n+            )\n+        } else if let Some(exponent) = get_integer_from_float_constant(&value) {\n+            (\n+                SUBOPTIMAL_FLOPS,\n+                \"exponentiation with integer powers can be computed more efficiently\",\n+                format!(\n+                    \"{}.powi({})\",\n+                    Sugg::hir(cx, &args[0], \"..\"),\n+                    format_numeric_literal(&exponent.to_string(), None, false)\n+                ),\n+            )\n+        } else {\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            lint,\n+            expr.span,\n+            help,\n+            \"consider using\",\n+            suggestion,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// TODO: Lint expressions of the form `x.exp() - y` where y > 1\n+// and suggest usage of `x.exp_m1() - (y - 1)` instead\n+fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n+        if cx.tables.expr_ty(lhs).is_floating_point();\n+        if let Some((value, _)) = constant(cx, cx.tables, rhs);\n+        if F32(1.0) == value || F64(1.0) == value;\n+        if let ExprKind::MethodCall(ref path, _, ref method_args) = lhs.kind;\n+        if cx.tables.expr_ty(&method_args[0]).is_floating_point();\n+        if path.ident.name.as_str() == \"exp\";\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                IMPRECISE_FLOPS,\n+                expr.span,\n+                \"(e.pow(x) - 1) can be computed more accurately\",\n+                \"consider using\",\n+                format!(\n+                    \"{}.exp_m1()\",\n+                    Sugg::hir(cx, &method_args[0], \"..\")\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn is_float_mul_expr<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n+    if_chain! {\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n+        if cx.tables.expr_ty(lhs).is_floating_point();\n+        if cx.tables.expr_ty(rhs).is_floating_point();\n+        then {\n+            return Some((lhs, rhs));\n+        }\n+    }\n+\n+    None\n+}\n+\n+// TODO: Fix rust-lang/rust-clippy#4735\n+fn check_mul_add(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Add, ..\n+        },\n+        lhs,\n+        rhs,\n+    ) = &expr.kind\n+    {\n+        let (recv, arg1, arg2) = if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, lhs) {\n+            (inner_lhs, inner_rhs, rhs)\n+        } else if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, rhs) {\n+            (inner_lhs, inner_rhs, lhs)\n+        } else {\n+            return;\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            SUBOPTIMAL_FLOPS,\n+            expr.span,\n+            \"multiply and add expressions can be calculated more efficiently and accurately\",\n+            \"consider using\",\n+            format!(\n+                \"{}.mul_add({}, {})\",\n+                prepare_receiver_sugg(cx, recv),\n+                Sugg::hir(cx, arg1, \"..\"),\n+                Sugg::hir(cx, arg2, \"..\"),\n+            ),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::MethodCall(ref path, _, args) = &expr.kind {\n+            let recv_ty = cx.tables.expr_ty(&args[0]);\n+\n+            if recv_ty.is_floating_point() {\n+                match &*path.ident.name.as_str() {\n+                    \"ln\" => check_ln1p(cx, expr, args),\n+                    \"log\" => check_log_base(cx, expr, args),\n+                    \"powf\" => check_powf(cx, expr, args),\n+                    _ => {},\n+                }\n+            }\n+        } else {\n+            check_expm1(cx, expr);\n+            check_mul_add(cx, expr);\n+        }\n+    }\n+}"}, {"sha": "c732657b2e57159c952c48487ec401f44ae7053a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -208,6 +208,7 @@ pub mod exit;\n pub mod explicit_write;\n pub mod fallible_impl_from;\n pub mod float_literal;\n+pub mod floating_point_arithmetic;\n pub mod format;\n pub mod formatting;\n pub mod functions;\n@@ -248,7 +249,6 @@ pub mod missing_const_for_fn;\n pub mod missing_doc;\n pub mod missing_inline;\n pub mod modulo_arithmetic;\n-pub mod mul_add;\n pub mod multiple_crate_versions;\n pub mod mut_key;\n pub mod mut_mut;\n@@ -538,6 +538,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &fallible_impl_from::FALLIBLE_IMPL_FROM,\n         &float_literal::EXCESSIVE_PRECISION,\n         &float_literal::LOSSY_FLOAT_LITERAL,\n+        &floating_point_arithmetic::IMPRECISE_FLOPS,\n+        &floating_point_arithmetic::SUBOPTIMAL_FLOPS,\n         &format::USELESS_FORMAT,\n         &formatting::POSSIBLE_MISSING_COMMA,\n         &formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n@@ -690,7 +692,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &missing_doc::MISSING_DOCS_IN_PRIVATE_ITEMS,\n         &missing_inline::MISSING_INLINE_IN_PUBLIC_ITEMS,\n         &modulo_arithmetic::MODULO_ARITHMETIC,\n-        &mul_add::MANUAL_MUL_ADD,\n         &multiple_crate_versions::MULTIPLE_CRATE_VERSIONS,\n         &mut_key::MUTABLE_KEY_TYPE,\n         &mut_mut::MUT_MUT,\n@@ -966,7 +967,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box inherent_to_string::InherentToString);\n     store.register_late_pass(|| box trait_bounds::TraitBounds);\n     store.register_late_pass(|| box comparison_chain::ComparisonChain);\n-    store.register_late_pass(|| box mul_add::MulAddCheck);\n     store.register_late_pass(|| box mut_key::MutableKeyType);\n     store.register_late_pass(|| box modulo_arithmetic::ModuloArithmetic);\n     store.register_early_pass(|| box reference::DerefAddrOf);\n@@ -1000,6 +1000,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box to_digit_is_some::ToDigitIsSome);\n     let array_size_threshold = conf.array_size_threshold;\n     store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n+    store.register_late_pass(move || box floating_point_arithmetic::FloatingPointArithmetic);\n     store.register_early_pass(|| box as_conversions::AsConversions);\n     store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n     store.register_late_pass(|| box let_underscore::LetUnderscore);\n@@ -1648,8 +1649,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n         LintId::of(&attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n         LintId::of(&fallible_impl_from::FALLIBLE_IMPL_FROM),\n+        LintId::of(&floating_point_arithmetic::IMPRECISE_FLOPS),\n+        LintId::of(&floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n         LintId::of(&missing_const_for_fn::MISSING_CONST_FOR_FN),\n-        LintId::of(&mul_add::MANUAL_MUL_ADD),\n         LintId::of(&mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n         LintId::of(&mutex_atomic::MUTEX_INTEGER),\n         LintId::of(&needless_borrow::NEEDLESS_BORROW),"}, {"sha": "57e56d8f959a3421c637459c4ce77bb6cbd71fe5", "filename": "clippy_lints/src/mul_add.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/clippy_lints%2Fsrc%2Fmul_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/clippy_lints%2Fsrc%2Fmul_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmul_add.rs?ref=c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "patch": "@@ -1,111 +0,0 @@\n-use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-use crate::utils::{snippet, span_lint_and_sugg};\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for expressions of the form `a * b + c`\n-    /// or `c + a * b` where `a`, `b`, `c` are floats and suggests using\n-    /// `a.mul_add(b, c)` instead.\n-    ///\n-    /// **Why is this bad?** Calculating `a * b + c` may lead to slight\n-    /// numerical inaccuracies as `a * b` is rounded before being added to\n-    /// `c`. Depending on the target architecture, `mul_add()` may be more\n-    /// performant.\n-    ///\n-    /// **Known problems:** This lint can emit semantic incorrect suggestions.\n-    /// For example, for `a * b * c + d` the suggestion `a * b.mul_add(c, d)`\n-    /// is emitted, which is equivalent to `a * (b * c + d)`. (#4735)\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// # let a = 0_f32;\n-    /// # let b = 0_f32;\n-    /// # let c = 0_f32;\n-    /// let foo = (a * b) + c;\n-    /// ```\n-    ///\n-    /// can be written as\n-    ///\n-    /// ```rust\n-    /// # let a = 0_f32;\n-    /// # let b = 0_f32;\n-    /// # let c = 0_f32;\n-    /// let foo = a.mul_add(b, c);\n-    /// ```\n-    pub MANUAL_MUL_ADD,\n-    nursery,\n-    \"Using `a.mul_add(b, c)` for floating points has higher numerical precision than `a * b + c`\"\n-}\n-\n-declare_lint_pass!(MulAddCheck => [MANUAL_MUL_ADD]);\n-\n-fn is_float<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n-    cx.tables.expr_ty(expr).is_floating_point()\n-}\n-\n-// Checks whether expression is multiplication of two floats\n-fn is_float_mult_expr<'a, 'tcx, 'b>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'b Expr<'b>,\n-) -> Option<(&'b Expr<'b>, &'b Expr<'b>)> {\n-    if let ExprKind::Binary(op, lhs, rhs) = &expr.kind {\n-        if let BinOpKind::Mul = op.node {\n-            if is_float(cx, &lhs) && is_float(cx, &rhs) {\n-                return Some((&lhs, &rhs));\n-            }\n-        }\n-    }\n-\n-    None\n-}\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MulAddCheck {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(op, lhs, rhs) = &expr.kind {\n-            if let BinOpKind::Add = op.node {\n-                //Converts mult_lhs * mult_rhs + rhs to mult_lhs.mult_add(mult_rhs, rhs)\n-                if let Some((mult_lhs, mult_rhs)) = is_float_mult_expr(cx, lhs) {\n-                    if is_float(cx, rhs) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            MANUAL_MUL_ADD,\n-                            expr.span,\n-                            \"consider using `mul_add()` for better numerical precision\",\n-                            \"try\",\n-                            format!(\n-                                \"{}.mul_add({}, {})\",\n-                                snippet(cx, mult_lhs.span, \"_\"),\n-                                snippet(cx, mult_rhs.span, \"_\"),\n-                                snippet(cx, rhs.span, \"_\"),\n-                            ),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                //Converts lhs + mult_lhs * mult_rhs to mult_lhs.mult_add(mult_rhs, lhs)\n-                if let Some((mult_lhs, mult_rhs)) = is_float_mult_expr(cx, rhs) {\n-                    if is_float(cx, lhs) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            MANUAL_MUL_ADD,\n-                            expr.span,\n-                            \"consider using `mul_add()` for better numerical precision\",\n-                            \"try\",\n-                            format!(\n-                                \"{}.mul_add({}, {})\",\n-                                snippet(cx, mult_lhs.span, \"_\"),\n-                                snippet(cx, mult_rhs.span, \"_\"),\n-                                snippet(cx, lhs.span, \"_\"),\n-                            ),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "15e6a4b6036a7606969fda62247ab539d52e9f25", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 357] = [\n+pub const ALL_LINTS: [Lint; 358] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -749,6 +749,13 @@ pub const ALL_LINTS: [Lint; 357] = [\n         deprecation: None,\n         module: \"implicit_return\",\n     },\n+    Lint {\n+        name: \"imprecise_flops\",\n+        group: \"nursery\",\n+        desc: \"usage of imprecise floating point operations\",\n+        deprecation: None,\n+        module: \"floating_point_arithmetic\",\n+    },\n     Lint {\n         name: \"inconsistent_digit_grouping\",\n         group: \"style\",\n@@ -1022,13 +1029,6 @@ pub const ALL_LINTS: [Lint; 357] = [\n         deprecation: None,\n         module: \"loops\",\n     },\n-    Lint {\n-        name: \"manual_mul_add\",\n-        group: \"nursery\",\n-        desc: \"Using `a.mul_add(b, c)` for floating points has higher numerical precision than `a * b + c`\",\n-        deprecation: None,\n-        module: \"mul_add\",\n-    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\",\n@@ -1960,6 +1960,13 @@ pub const ALL_LINTS: [Lint; 357] = [\n         deprecation: None,\n         module: \"excessive_bools\",\n     },\n+    Lint {\n+        name: \"suboptimal_flops\",\n+        group: \"nursery\",\n+        desc: \"usage of sub-optimal floating point operations\",\n+        deprecation: None,\n+        module: \"floating_point_arithmetic\",\n+    },\n     Lint {\n         name: \"suspicious_arithmetic_impl\",\n         group: \"correctness\","}, {"sha": "ae7805fdf018eea7228cecc02adcb4781173768e", "filename": "tests/ui/floating_point_exp.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_exp.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_exp.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_exp.fixed?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![warn(clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 2f32;\n+    let _ = x.exp_m1();\n+    let _ = x.exp_m1() + 2.0;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.exp() - 2.0;\n+    let _ = x.exp() - 1.0 * 2.0;\n+\n+    let x = 2f64;\n+    let _ = x.exp_m1();\n+    let _ = x.exp_m1() + 2.0;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.exp() - 2.0;\n+    let _ = x.exp() - 1.0 * 2.0;\n+}"}, {"sha": "27e0b9bcbc937a829e9e1d9ce7d7fb286c0c63d6", "filename": "tests/ui/floating_point_exp.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_exp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_exp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_exp.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![warn(clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 2f32;\n+    let _ = x.exp() - 1.0;\n+    let _ = x.exp() - 1.0 + 2.0;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.exp() - 2.0;\n+    let _ = x.exp() - 1.0 * 2.0;\n+\n+    let x = 2f64;\n+    let _ = x.exp() - 1.0;\n+    let _ = x.exp() - 1.0 + 2.0;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.exp() - 2.0;\n+    let _ = x.exp() - 1.0 * 2.0;\n+}"}, {"sha": "5cd999ad47cdd0d768138c901b1a9df01d891d8b", "filename": "tests/ui/floating_point_exp.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_exp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_exp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_exp.stderr?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,28 @@\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_exp.rs:6:13\n+   |\n+LL |     let _ = x.exp() - 1.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+   |\n+   = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_exp.rs:7:13\n+   |\n+LL |     let _ = x.exp() - 1.0 + 2.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_exp.rs:13:13\n+   |\n+LL |     let _ = x.exp() - 1.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_exp.rs:14:13\n+   |\n+LL |     let _ = x.exp() - 1.0 + 2.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "42c5e5d2bae2418c4330959aa559382a46f4940f", "filename": "tests/ui/floating_point_log.fixed", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_log.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_log.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.fixed?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+#![allow(dead_code, clippy::double_parens)]\n+#![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n+\n+const TWO: f32 = 2.0;\n+const E: f32 = std::f32::consts::E;\n+\n+fn check_log_base() {\n+    let x = 1f32;\n+    let _ = x.log2();\n+    let _ = x.log10();\n+    let _ = x.ln();\n+    let _ = x.log2();\n+    let _ = x.ln();\n+\n+    let x = 1f64;\n+    let _ = x.log2();\n+    let _ = x.log10();\n+    let _ = x.ln();\n+}\n+\n+fn check_ln1p() {\n+    let x = 1f32;\n+    let _ = 2.0f32.ln_1p();\n+    let _ = 2.0f32.ln_1p();\n+    let _ = x.ln_1p();\n+    let _ = (x / 2.0).ln_1p();\n+    let _ = x.powi(2).ln_1p();\n+    let _ = (x.powi(2) / 2.0).ln_1p();\n+    let _ = ((std::f32::consts::E - 1.0)).ln_1p();\n+    let _ = x.ln_1p();\n+    let _ = x.powi(2).ln_1p();\n+    let _ = (x + 2.0).ln_1p();\n+    let _ = (x / 2.0).ln_1p();\n+    // Cases where the lint shouldn't be applied\n+    let _ = (1.0 + x + 2.0).ln();\n+    let _ = (x + 1.0 + 2.0).ln();\n+    let _ = (x + 1.0 / 2.0).ln();\n+    let _ = (1.0 + x - 2.0).ln();\n+\n+    let x = 1f64;\n+    let _ = 2.0f64.ln_1p();\n+    let _ = 2.0f64.ln_1p();\n+    let _ = x.ln_1p();\n+    let _ = (x / 2.0).ln_1p();\n+    let _ = x.powi(2).ln_1p();\n+    let _ = x.ln_1p();\n+    let _ = x.powi(2).ln_1p();\n+    let _ = (x + 2.0).ln_1p();\n+    let _ = (x / 2.0).ln_1p();\n+    // Cases where the lint shouldn't be applied\n+    let _ = (1.0 + x + 2.0).ln();\n+    let _ = (x + 1.0 + 2.0).ln();\n+    let _ = (x + 1.0 / 2.0).ln();\n+    let _ = (1.0 + x - 2.0).ln();\n+}\n+\n+fn main() {}"}, {"sha": "8be0d9ad56fc34fa07f120eda343a6ab61257047", "filename": "tests/ui/floating_point_log.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,58 @@\n+// run-rustfix\n+#![allow(dead_code, clippy::double_parens)]\n+#![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n+\n+const TWO: f32 = 2.0;\n+const E: f32 = std::f32::consts::E;\n+\n+fn check_log_base() {\n+    let x = 1f32;\n+    let _ = x.log(2f32);\n+    let _ = x.log(10f32);\n+    let _ = x.log(std::f32::consts::E);\n+    let _ = x.log(TWO);\n+    let _ = x.log(E);\n+\n+    let x = 1f64;\n+    let _ = x.log(2f64);\n+    let _ = x.log(10f64);\n+    let _ = x.log(std::f64::consts::E);\n+}\n+\n+fn check_ln1p() {\n+    let x = 1f32;\n+    let _ = (1f32 + 2.).ln();\n+    let _ = (1f32 + 2.0).ln();\n+    let _ = (1.0 + x).ln();\n+    let _ = (1.0 + x / 2.0).ln();\n+    let _ = (1.0 + x.powi(2)).ln();\n+    let _ = (1.0 + x.powi(2) / 2.0).ln();\n+    let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n+    let _ = (x + 1.0).ln();\n+    let _ = (x.powi(2) + 1.0).ln();\n+    let _ = (x + 2.0 + 1.0).ln();\n+    let _ = (x / 2.0 + 1.0).ln();\n+    // Cases where the lint shouldn't be applied\n+    let _ = (1.0 + x + 2.0).ln();\n+    let _ = (x + 1.0 + 2.0).ln();\n+    let _ = (x + 1.0 / 2.0).ln();\n+    let _ = (1.0 + x - 2.0).ln();\n+\n+    let x = 1f64;\n+    let _ = (1f64 + 2.).ln();\n+    let _ = (1f64 + 2.0).ln();\n+    let _ = (1.0 + x).ln();\n+    let _ = (1.0 + x / 2.0).ln();\n+    let _ = (1.0 + x.powi(2)).ln();\n+    let _ = (x + 1.0).ln();\n+    let _ = (x.powi(2) + 1.0).ln();\n+    let _ = (x + 2.0 + 1.0).ln();\n+    let _ = (x / 2.0 + 1.0).ln();\n+    // Cases where the lint shouldn't be applied\n+    let _ = (1.0 + x + 2.0).ln();\n+    let _ = (x + 1.0 + 2.0).ln();\n+    let _ = (x + 1.0 / 2.0).ln();\n+    let _ = (1.0 + x - 2.0).ln();\n+}\n+\n+fn main() {}"}, {"sha": "943fbdb0b83232964312d49beedce567093ce20b", "filename": "tests/ui/floating_point_log.stderr", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_log.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_log.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.stderr?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,174 @@\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:10:13\n+   |\n+LL |     let _ = x.log(2f32);\n+   |             ^^^^^^^^^^^ help: consider using: `x.log2()`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:11:13\n+   |\n+LL |     let _ = x.log(10f32);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.log10()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:12:13\n+   |\n+LL |     let _ = x.log(std::f32::consts::E);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.ln()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:13:13\n+   |\n+LL |     let _ = x.log(TWO);\n+   |             ^^^^^^^^^^ help: consider using: `x.log2()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:14:13\n+   |\n+LL |     let _ = x.log(E);\n+   |             ^^^^^^^^ help: consider using: `x.ln()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:17:13\n+   |\n+LL |     let _ = x.log(2f64);\n+   |             ^^^^^^^^^^^ help: consider using: `x.log2()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:18:13\n+   |\n+LL |     let _ = x.log(10f64);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.log10()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_log.rs:19:13\n+   |\n+LL |     let _ = x.log(std::f64::consts::E);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.ln()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:24:13\n+   |\n+LL |     let _ = (1f32 + 2.).ln();\n+   |             ^^^^^^^^^^^^^^^^ help: consider using: `2.0f32.ln_1p()`\n+   |\n+   = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:25:13\n+   |\n+LL |     let _ = (1f32 + 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `2.0f32.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:26:13\n+   |\n+LL |     let _ = (1.0 + x).ln();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:27:13\n+   |\n+LL |     let _ = (1.0 + x / 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:28:13\n+   |\n+LL |     let _ = (1.0 + x.powi(2)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:29:13\n+   |\n+LL |     let _ = (1.0 + x.powi(2) / 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(2) / 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:30:13\n+   |\n+LL |     let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `((std::f32::consts::E - 1.0)).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:31:13\n+   |\n+LL |     let _ = (x + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:32:13\n+   |\n+LL |     let _ = (x.powi(2) + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:33:13\n+   |\n+LL |     let _ = (x + 2.0 + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x + 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:34:13\n+   |\n+LL |     let _ = (x / 2.0 + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:42:13\n+   |\n+LL |     let _ = (1f64 + 2.).ln();\n+   |             ^^^^^^^^^^^^^^^^ help: consider using: `2.0f64.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:43:13\n+   |\n+LL |     let _ = (1f64 + 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `2.0f64.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:44:13\n+   |\n+LL |     let _ = (1.0 + x).ln();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:45:13\n+   |\n+LL |     let _ = (1.0 + x / 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:46:13\n+   |\n+LL |     let _ = (1.0 + x.powi(2)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:47:13\n+   |\n+LL |     let _ = (x + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:48:13\n+   |\n+LL |     let _ = (x.powi(2) + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:49:13\n+   |\n+LL |     let _ = (x + 2.0 + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x + 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_log.rs:50:13\n+   |\n+LL |     let _ = (x / 2.0 + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x / 2.0).ln_1p()`\n+\n+error: aborting due to 28 previous errors\n+"}, {"sha": "e343c37740da5f8207c5999238b2f48655914e35", "filename": "tests/ui/floating_point_mul_add.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_mul_add.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_mul_add.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_mul_add.fixed?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let a: f64 = 1234.567;\n+    let b: f64 = 45.67834;\n+    let c: f64 = 0.0004;\n+    let d: f64 = 0.0001;\n+\n+    let _ = a.mul_add(b, c);\n+    let _ = a.mul_add(b, c);\n+    let _ = 2.0f64.mul_add(4.0, a);\n+    let _ = 2.0f64.mul_add(4., a);\n+\n+    let _ = a.mul_add(b, c);\n+    let _ = a.mul_add(b, c);\n+    let _ = (a * b).mul_add(c, d);\n+\n+    let _ = a.mul_add(b, c).mul_add(a.mul_add(b, c), a.mul_add(b, c)) + c;\n+    let _ = 1234.567_f64.mul_add(45.67834_f64, 0.0004_f64);\n+}"}, {"sha": "810f929c8568b9bc1573e6c0ad976ac55933a785", "filename": "tests/ui/floating_point_mul_add.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_mul_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_mul_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_mul_add.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let a: f64 = 1234.567;\n+    let b: f64 = 45.67834;\n+    let c: f64 = 0.0004;\n+    let d: f64 = 0.0001;\n+\n+    let _ = a * b + c;\n+    let _ = c + a * b;\n+    let _ = a + 2.0 * 4.0;\n+    let _ = a + 2. * 4.;\n+\n+    let _ = (a * b) + c;\n+    let _ = c + (a * b);\n+    let _ = a * b * c + d;\n+\n+    let _ = a.mul_add(b, c) * a.mul_add(b, c) + a.mul_add(b, c) + c;\n+    let _ = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n+}"}, {"sha": "2dfbf562d15fc0c6a16bc2960ae02488870fad3f", "filename": "tests/ui/floating_point_mul_add.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_mul_add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_mul_add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_mul_add.stderr?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,58 @@\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:10:13\n+   |\n+LL |     let _ = a * b + c;\n+   |             ^^^^^^^^^ help: consider using: `a.mul_add(b, c)`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:11:13\n+   |\n+LL |     let _ = c + a * b;\n+   |             ^^^^^^^^^ help: consider using: `a.mul_add(b, c)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:12:13\n+   |\n+LL |     let _ = a + 2.0 * 4.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `2.0f64.mul_add(4.0, a)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:13:13\n+   |\n+LL |     let _ = a + 2. * 4.;\n+   |             ^^^^^^^^^^^ help: consider using: `2.0f64.mul_add(4., a)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:15:13\n+   |\n+LL |     let _ = (a * b) + c;\n+   |             ^^^^^^^^^^^ help: consider using: `a.mul_add(b, c)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:16:13\n+   |\n+LL |     let _ = c + (a * b);\n+   |             ^^^^^^^^^^^ help: consider using: `a.mul_add(b, c)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:17:13\n+   |\n+LL |     let _ = a * b * c + d;\n+   |             ^^^^^^^^^^^^^ help: consider using: `(a * b).mul_add(c, d)`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:19:13\n+   |\n+LL |     let _ = a.mul_add(b, c) * a.mul_add(b, c) + a.mul_add(b, c) + c;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `a.mul_add(b, c).mul_add(a.mul_add(b, c), a.mul_add(b, c))`\n+\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:20:13\n+   |\n+LL |     let _ = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1234.567_f64.mul_add(45.67834_f64, 0.0004_f64)`\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "78a9d44829bb1ab708b1b39ed2fabffe2b3e24e4", "filename": "tests/ui/floating_point_powf.fixed", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_powf.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_powf.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powf.fixed?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let _ = x.exp2();\n+    let _ = 3.1f32.exp2();\n+    let _ = (-3.1f32).exp2();\n+    let _ = x.exp();\n+    let _ = 3.1f32.exp();\n+    let _ = (-3.1f32).exp();\n+    let _ = x.sqrt();\n+    let _ = x.cbrt();\n+    let _ = x.powi(2);\n+    let _ = x.powi(-2);\n+    let _ = x.powi(16_777_215);\n+    let _ = x.powi(-16_777_215);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powf(2.1);\n+    let _ = x.powf(-2.1);\n+    let _ = x.powf(16_777_216.0);\n+    let _ = x.powf(-16_777_216.0);\n+\n+    let x = 3f64;\n+    let _ = x.exp2();\n+    let _ = 3.1f64.exp2();\n+    let _ = (-3.1f64).exp2();\n+    let _ = x.exp();\n+    let _ = 3.1f64.exp();\n+    let _ = (-3.1f64).exp();\n+    let _ = x.sqrt();\n+    let _ = x.cbrt();\n+    let _ = x.powi(2);\n+    let _ = x.powi(-2);\n+    let _ = x.powi(-2_147_483_648);\n+    let _ = x.powi(2_147_483_647);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powf(2.1);\n+    let _ = x.powf(-2.1);\n+    let _ = x.powf(-2_147_483_649.0);\n+    let _ = x.powf(2_147_483_648.0);\n+}"}, {"sha": "dbc1cac5cb4315cb03ceb516542e15b4aa8e21a9", "filename": "tests/ui/floating_point_powf.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_powf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_powf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powf.rs?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops, clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let _ = 2f32.powf(x);\n+    let _ = 2f32.powf(3.1);\n+    let _ = 2f32.powf(-3.1);\n+    let _ = std::f32::consts::E.powf(x);\n+    let _ = std::f32::consts::E.powf(3.1);\n+    let _ = std::f32::consts::E.powf(-3.1);\n+    let _ = x.powf(1.0 / 2.0);\n+    let _ = x.powf(1.0 / 3.0);\n+    let _ = x.powf(2.0);\n+    let _ = x.powf(-2.0);\n+    let _ = x.powf(16_777_215.0);\n+    let _ = x.powf(-16_777_215.0);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powf(2.1);\n+    let _ = x.powf(-2.1);\n+    let _ = x.powf(16_777_216.0);\n+    let _ = x.powf(-16_777_216.0);\n+\n+    let x = 3f64;\n+    let _ = 2f64.powf(x);\n+    let _ = 2f64.powf(3.1);\n+    let _ = 2f64.powf(-3.1);\n+    let _ = std::f64::consts::E.powf(x);\n+    let _ = std::f64::consts::E.powf(3.1);\n+    let _ = std::f64::consts::E.powf(-3.1);\n+    let _ = x.powf(1.0 / 2.0);\n+    let _ = x.powf(1.0 / 3.0);\n+    let _ = x.powf(2.0);\n+    let _ = x.powf(-2.0);\n+    let _ = x.powf(-2_147_483_648.0);\n+    let _ = x.powf(2_147_483_647.0);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powf(2.1);\n+    let _ = x.powf(-2.1);\n+    let _ = x.powf(-2_147_483_649.0);\n+    let _ = x.powf(2_147_483_648.0);\n+}"}, {"sha": "ad5163f0079be937ae34e629eaa5a5148c17190a", "filename": "tests/ui/floating_point_powf.stderr", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_powf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2734e4e1f7faf59b4b7c9db7070626b8b7fd2145/tests%2Fui%2Ffloating_point_powf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_powf.stderr?ref=2734e4e1f7faf59b4b7c9db7070626b8b7fd2145", "patch": "@@ -0,0 +1,150 @@\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:6:13\n+   |\n+LL |     let _ = 2f32.powf(x);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:7:13\n+   |\n+LL |     let _ = 2f32.powf(3.1);\n+   |             ^^^^^^^^^^^^^^ help: consider using: `3.1f32.exp2()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:8:13\n+   |\n+LL |     let _ = 2f32.powf(-3.1);\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `(-3.1f32).exp2()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:9:13\n+   |\n+LL |     let _ = std::f32::consts::E.powf(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:10:13\n+   |\n+LL |     let _ = std::f32::consts::E.powf(3.1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `3.1f32.exp()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:11:13\n+   |\n+LL |     let _ = std::f32::consts::E.powf(-3.1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-3.1f32).exp()`\n+\n+error: square-root of a number can be computed more efficiently and accurately\n+  --> $DIR/floating_point_powf.rs:12:13\n+   |\n+LL |     let _ = x.powf(1.0 / 2.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n+\n+error: cube-root of a number can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:13:13\n+   |\n+LL |     let _ = x.powf(1.0 / 3.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n+   |\n+   = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:14:13\n+   |\n+LL |     let _ = x.powf(2.0);\n+   |             ^^^^^^^^^^^ help: consider using: `x.powi(2)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:15:13\n+   |\n+LL |     let _ = x.powf(-2.0);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.powi(-2)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:16:13\n+   |\n+LL |     let _ = x.powf(16_777_215.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(16_777_215)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:17:13\n+   |\n+LL |     let _ = x.powf(-16_777_215.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(-16_777_215)`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:25:13\n+   |\n+LL |     let _ = 2f64.powf(x);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:26:13\n+   |\n+LL |     let _ = 2f64.powf(3.1);\n+   |             ^^^^^^^^^^^^^^ help: consider using: `3.1f64.exp2()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:27:13\n+   |\n+LL |     let _ = 2f64.powf(-3.1);\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `(-3.1f64).exp2()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:28:13\n+   |\n+LL |     let _ = std::f64::consts::E.powf(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:29:13\n+   |\n+LL |     let _ = std::f64::consts::E.powf(3.1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `3.1f64.exp()`\n+\n+error: exponent for bases 2 and e can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:30:13\n+   |\n+LL |     let _ = std::f64::consts::E.powf(-3.1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(-3.1f64).exp()`\n+\n+error: square-root of a number can be computed more efficiently and accurately\n+  --> $DIR/floating_point_powf.rs:31:13\n+   |\n+LL |     let _ = x.powf(1.0 / 2.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n+\n+error: cube-root of a number can be computed more accurately\n+  --> $DIR/floating_point_powf.rs:32:13\n+   |\n+LL |     let _ = x.powf(1.0 / 3.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:33:13\n+   |\n+LL |     let _ = x.powf(2.0);\n+   |             ^^^^^^^^^^^ help: consider using: `x.powi(2)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:34:13\n+   |\n+LL |     let _ = x.powf(-2.0);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.powi(-2)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:35:13\n+   |\n+LL |     let _ = x.powf(-2_147_483_648.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(-2_147_483_648)`\n+\n+error: exponentiation with integer powers can be computed more efficiently\n+  --> $DIR/floating_point_powf.rs:36:13\n+   |\n+LL |     let _ = x.powf(2_147_483_647.0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2_147_483_647)`\n+\n+error: aborting due to 24 previous errors\n+"}, {"sha": "1322e002c64131f1530ea88ddce87a65c1018714", "filename": "tests/ui/mul_add.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmul_add.rs?ref=c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "patch": "@@ -1,16 +0,0 @@\n-#![warn(clippy::manual_mul_add)]\n-#![allow(unused_variables)]\n-\n-fn mul_add_test() {\n-    let a: f64 = 1234.567;\n-    let b: f64 = 45.67834;\n-    let c: f64 = 0.0004;\n-\n-    // Examples of not auto-fixable expressions\n-    let test1 = (a * b + c) * (c + a * b) + (c + (a * b) + c);\n-    let test2 = 1234.567 * 45.67834 + 0.0004;\n-}\n-\n-fn main() {\n-    mul_add_test();\n-}"}, {"sha": "3b21646f7c3012ed987d58de03b965285a0439c3", "filename": "tests/ui/mul_add.stderr", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmul_add.stderr?ref=c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "patch": "@@ -1,34 +0,0 @@\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add.rs:10:17\n-   |\n-LL |     let test1 = (a * b + c) * (c + a * b) + (c + (a * b) + c);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(a * b + c).mul_add((c + a * b), (c + (a * b) + c))`\n-   |\n-   = note: `-D clippy::manual-mul-add` implied by `-D warnings`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add.rs:10:17\n-   |\n-LL |     let test1 = (a * b + c) * (c + a * b) + (c + (a * b) + c);\n-   |                 ^^^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add.rs:10:31\n-   |\n-LL |     let test1 = (a * b + c) * (c + a * b) + (c + (a * b) + c);\n-   |                               ^^^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add.rs:10:46\n-   |\n-LL |     let test1 = (a * b + c) * (c + a * b) + (c + (a * b) + c);\n-   |                                              ^^^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add.rs:11:17\n-   |\n-LL |     let test2 = 1234.567 * 45.67834 + 0.0004;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `1234.567.mul_add(45.67834, 0.0004)`\n-\n-error: aborting due to 5 previous errors\n-"}, {"sha": "4af7c7e3e1a5d04f342e74bb252b314420a5fd8d", "filename": "tests/ui/mul_add_fixable.fixed", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmul_add_fixable.fixed?ref=c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "patch": "@@ -1,24 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::manual_mul_add)]\n-#![allow(unused_variables)]\n-\n-fn mul_add_test() {\n-    let a: f64 = 1234.567;\n-    let b: f64 = 45.67834;\n-    let c: f64 = 0.0004;\n-\n-    // Auto-fixable examples\n-    let test1 = a.mul_add(b, c);\n-    let test2 = a.mul_add(b, c);\n-\n-    let test3 = a.mul_add(b, c);\n-    let test4 = a.mul_add(b, c);\n-\n-    let test5 = a.mul_add(b, c).mul_add(a.mul_add(b, c), a.mul_add(b, c)) + c;\n-    let test6 = 1234.567_f64.mul_add(45.67834_f64, 0.0004_f64);\n-}\n-\n-fn main() {\n-    mul_add_test();\n-}"}, {"sha": "8b42f6f184a4c32b747d10852c5f724c1ea0018f", "filename": "tests/ui/mul_add_fixable.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmul_add_fixable.rs?ref=c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "patch": "@@ -1,24 +0,0 @@\n-// run-rustfix\n-\n-#![warn(clippy::manual_mul_add)]\n-#![allow(unused_variables)]\n-\n-fn mul_add_test() {\n-    let a: f64 = 1234.567;\n-    let b: f64 = 45.67834;\n-    let c: f64 = 0.0004;\n-\n-    // Auto-fixable examples\n-    let test1 = a * b + c;\n-    let test2 = c + a * b;\n-\n-    let test3 = (a * b) + c;\n-    let test4 = c + (a * b);\n-\n-    let test5 = a.mul_add(b, c) * a.mul_add(b, c) + a.mul_add(b, c) + c;\n-    let test6 = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n-}\n-\n-fn main() {\n-    mul_add_test();\n-}"}, {"sha": "235443f4b02b3ef9c19d41c9f13e89b321c10982", "filename": "tests/ui/mul_add_fixable.stderr", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3/tests%2Fui%2Fmul_add_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmul_add_fixable.stderr?ref=c6ad3db8b5cad17bdacf9fae09ddabc6dc8f67d3", "patch": "@@ -1,40 +0,0 @@\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add_fixable.rs:12:17\n-   |\n-LL |     let test1 = a * b + c;\n-   |                 ^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-   |\n-   = note: `-D clippy::manual-mul-add` implied by `-D warnings`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add_fixable.rs:13:17\n-   |\n-LL |     let test2 = c + a * b;\n-   |                 ^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add_fixable.rs:15:17\n-   |\n-LL |     let test3 = (a * b) + c;\n-   |                 ^^^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add_fixable.rs:16:17\n-   |\n-LL |     let test4 = c + (a * b);\n-   |                 ^^^^^^^^^^^ help: try: `a.mul_add(b, c)`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add_fixable.rs:18:17\n-   |\n-LL |     let test5 = a.mul_add(b, c) * a.mul_add(b, c) + a.mul_add(b, c) + c;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `a.mul_add(b, c).mul_add(a.mul_add(b, c), a.mul_add(b, c))`\n-\n-error: consider using `mul_add()` for better numerical precision\n-  --> $DIR/mul_add_fixable.rs:19:17\n-   |\n-LL |     let test6 = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `1234.567_f64.mul_add(45.67834_f64, 0.0004_f64)`\n-\n-error: aborting due to 6 previous errors\n-"}]}