{"sha": "13f6d771bb7f3617e247d9806e1b9472022cdaf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZjZkNzcxYmI3ZjM2MTdlMjQ3ZDk4MDZlMWI5NDcyMDIyY2RhZjQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-18T23:00:15Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-20T13:43:41Z"}, "message": "Simplify ensure_root_is_owned callers\n\nThis makes ensure_root_is_owned return a reference to the (now guaranteed to\nexist) root, allowing callers to operate on it without going through another\nunwrap.\n\nUnfortunately this is only rarely useful as it's frequently the case that both\nthe length and the root need to be accessed and field-level borrows in methods\ndon't yet exist.", "tree": {"sha": "1f7e5da4bfa4872999299118983646a71625716a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f7e5da4bfa4872999299118983646a71625716a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13f6d771bb7f3617e247d9806e1b9472022cdaf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13f6d771bb7f3617e247d9806e1b9472022cdaf4", "html_url": "https://github.com/rust-lang/rust/commit/13f6d771bb7f3617e247d9806e1b9472022cdaf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13f6d771bb7f3617e247d9806e1b9472022cdaf4/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54b7c38889ee7bb59f4d6449822fcfdfa3448ddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/54b7c38889ee7bb59f4d6449822fcfdfa3448ddb", "html_url": "https://github.com/rust-lang/rust/commit/54b7c38889ee7bb59f4d6449822fcfdfa3448ddb"}], "stats": {"total": 28, "additions": 13, "deletions": 15}, "files": [{"sha": "3ba7befc0460924215d4890e5df2fa494ac5f5f0", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/13f6d771bb7f3617e247d9806e1b9472022cdaf4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f6d771bb7f3617e247d9806e1b9472022cdaf4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=13f6d771bb7f3617e247d9806e1b9472022cdaf4", "patch": "@@ -170,13 +170,13 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                 }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n-\n-                    // Cannot call ensure_root_is_owned() because lacking K: Ord\n-                    if out_tree.root.is_none() {\n-                        out_tree.root = Some(node::Root::new_leaf());\n-                    }\n+                    out_tree.ensure_root_is_owned();\n \n                     {\n+                        // Ideally we'd use the return of ensure_root_is_owned\n+                        // instead of re-unwrapping here but unfortunately that\n+                        // borrows all of out_tree and we need access to the\n+                        // length below.\n                         let mut out_node = out_tree.root.as_mut().unwrap().push_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n@@ -1207,9 +1207,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n-        right.root = Some(node::Root::new_leaf());\n+        let right_root = right.ensure_root_is_owned();\n         for _ in 0..(self.root.as_ref().unwrap().as_ref().height()) {\n-            right.root.as_mut().unwrap().push_level();\n+            right_root.push_level();\n         }\n \n         {\n@@ -1348,14 +1348,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.fix_top();\n     }\n-\n-    /// If the root node is the empty (non-allocated) root node, allocate our\n-    /// own node.\n-    fn ensure_root_is_owned(&mut self) {\n-        if self.root.is_none() {\n-            self.root = Some(node::Root::new_leaf());\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2151,6 +2143,12 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// If the root node is the empty (non-allocated) root node, allocate our\n+    /// own node.\n+    fn ensure_root_is_owned(&mut self) -> &mut node::Root<K, V> {\n+        self.root.get_or_insert_with(|| node::Root::new_leaf())\n+    }\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {"}]}