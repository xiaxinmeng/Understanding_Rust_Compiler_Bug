{"sha": "1ea4efd0656599f824e2567a5b7a95454f701c03", "node_id": "C_kwDOAAsO6NoAKDFlYTRlZmQwNjU2NTk5ZjgyNGUyNTY3YTViN2E5NTQ1NGY3MDFjMDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T22:31:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T22:31:19Z"}, "message": "Auto merge of #100578 - Urgau:float-next-up-down, r=scottmcm\n\nAdd next_up and next_down for f32/f64 - take 2\n\nThis is a revival of https://github.com/rust-lang/rust/pull/88728 which staled due to inactivity of the original author. I've address the last review comment.\n\n---\n\nThis is a pull request implementing the features described at https://github.com/rust-lang/rfcs/pull/3173.\n\n`@rustbot` label +T-libs-api -T-libs\nr? `@scottmcm`\ncc `@orlp`", "tree": {"sha": "41a7588dfa4aafc000b5afdf157a46777fff9a8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41a7588dfa4aafc000b5afdf157a46777fff9a8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ea4efd0656599f824e2567a5b7a95454f701c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4efd0656599f824e2567a5b7a95454f701c03", "html_url": "https://github.com/rust-lang/rust/commit/1ea4efd0656599f824e2567a5b7a95454f701c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ea4efd0656599f824e2567a5b7a95454f701c03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce36e88256f09078519f8bc6b21e4dc88f88f523", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce36e88256f09078519f8bc6b21e4dc88f88f523", "html_url": "https://github.com/rust-lang/rust/commit/ce36e88256f09078519f8bc6b21e4dc88f88f523"}, {"sha": "3f10e6c86d9d602a821b3156266978c33a214965", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f10e6c86d9d602a821b3156266978c33a214965", "html_url": "https://github.com/rust-lang/rust/commit/3f10e6c86d9d602a821b3156266978c33a214965"}], "stats": {"total": 355, "additions": 355, "deletions": 0}, "files": [{"sha": "da41ea536357a2f39415e206ec2cafb04e34ce49", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=1ea4efd0656599f824e2567a5b7a95454f701c03", "patch": "@@ -678,6 +678,106 @@ impl f32 {\n         unsafe { mem::transmute::<f32, u32>(self) & 0x8000_0000 != 0 }\n     }\n \n+    /// Returns the least number greater than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f32`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`NEG_INFINITY`], this returns [`MIN`];\n+    ///  - if `self` is `-TINY`, this returns -0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `TINY`;\n+    ///  - if `self` is [`MAX`] or [`INFINITY`], this returns [`INFINITY`];\n+    ///  - otherwise the unique least value greater than `self` is returned.\n+    ///\n+    /// The identity `x.next_up() == -(-x).next_down()` holds for all non-NaN `x`. When `x`\n+    /// is finite `x == x.next_up().next_down()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// // f32::EPSILON is the difference between 1.0 and the next number up.\n+    /// assert_eq!(1.0f32.next_up(), 1.0 + f32::EPSILON);\n+    /// // But not for most numbers.\n+    /// assert!(0.1f32.next_up() < 0.1 + f32::EPSILON);\n+    /// assert_eq!(16777216f32.next_up(), 16777218.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    #[rustc_const_unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    pub const fn next_up(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const TINY_BITS: u32 = 0x1; // Smallest positive f32.\n+        const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            TINY_BITS\n+        } else if bits == abs {\n+            bits + 1\n+        } else {\n+            bits - 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n+    /// Returns the greatest number less than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f32`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`INFINITY`], this returns [`MAX`];\n+    ///  - if `self` is `TINY`, this returns 0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `-TINY`;\n+    ///  - if `self` is [`MIN`] or [`NEG_INFINITY`], this returns [`NEG_INFINITY`];\n+    ///  - otherwise the unique greatest value less than `self` is returned.\n+    ///\n+    /// The identity `x.next_down() == -(-x).next_up()` holds for all non-NaN `x`. When `x`\n+    /// is finite `x == x.next_down().next_up()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// let x = 1.0f32;\n+    /// // Clamp value into range [0, 1).\n+    /// let clamped = x.clamp(0.0, 1.0f32.next_down());\n+    /// assert!(clamped < 1.0);\n+    /// assert_eq!(clamped.next_up(), 1.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    #[rustc_const_unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    pub const fn next_down(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const NEG_TINY_BITS: u32 = 0x8000_0001; // Smallest (in magnitude) negative f32.\n+        const CLEAR_SIGN_MASK: u32 = 0x7fff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            NEG_TINY_BITS\n+        } else if bits == abs {\n+            bits - 1\n+        } else {\n+            bits + 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}, {"sha": "631d559df5f701be46c90957c9d7adca344f7f7e", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=1ea4efd0656599f824e2567a5b7a95454f701c03", "patch": "@@ -688,6 +688,106 @@ impl f64 {\n         self.is_sign_negative()\n     }\n \n+    /// Returns the least number greater than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f64`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`NEG_INFINITY`], this returns [`MIN`];\n+    ///  - if `self` is `-TINY`, this returns -0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `TINY`;\n+    ///  - if `self` is [`MAX`] or [`INFINITY`], this returns [`INFINITY`];\n+    ///  - otherwise the unique least value greater than `self` is returned.\n+    ///\n+    /// The identity `x.next_up() == -(-x).next_down()` holds for all non-NaN `x`. When `x`\n+    /// is finite `x == x.next_up().next_down()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// // f64::EPSILON is the difference between 1.0 and the next number up.\n+    /// assert_eq!(1.0f64.next_up(), 1.0 + f64::EPSILON);\n+    /// // But not for most numbers.\n+    /// assert!(0.1f64.next_up() < 0.1 + f64::EPSILON);\n+    /// assert_eq!(9007199254740992f64.next_up(), 9007199254740994.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    #[rustc_const_unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    pub const fn next_up(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const TINY_BITS: u64 = 0x1; // Smallest positive f64.\n+        const CLEAR_SIGN_MASK: u64 = 0x7fff_ffff_ffff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            TINY_BITS\n+        } else if bits == abs {\n+            bits + 1\n+        } else {\n+            bits - 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n+    /// Returns the greatest number less than `self`.\n+    ///\n+    /// Let `TINY` be the smallest representable positive `f64`. Then,\n+    ///  - if `self.is_nan()`, this returns `self`;\n+    ///  - if `self` is [`INFINITY`], this returns [`MAX`];\n+    ///  - if `self` is `TINY`, this returns 0.0;\n+    ///  - if `self` is -0.0 or +0.0, this returns `-TINY`;\n+    ///  - if `self` is [`MIN`] or [`NEG_INFINITY`], this returns [`NEG_INFINITY`];\n+    ///  - otherwise the unique greatest value less than `self` is returned.\n+    ///\n+    /// The identity `x.next_down() == -(-x).next_up()` holds for all non-NaN `x`. When `x`\n+    /// is finite `x == x.next_down().next_up()` also holds.\n+    ///\n+    /// ```rust\n+    /// #![feature(float_next_up_down)]\n+    /// let x = 1.0f64;\n+    /// // Clamp value into range [0, 1).\n+    /// let clamped = x.clamp(0.0, 1.0f64.next_down());\n+    /// assert!(clamped < 1.0);\n+    /// assert_eq!(clamped.next_up(), 1.0);\n+    /// ```\n+    ///\n+    /// [`NEG_INFINITY`]: Self::NEG_INFINITY\n+    /// [`INFINITY`]: Self::INFINITY\n+    /// [`MIN`]: Self::MIN\n+    /// [`MAX`]: Self::MAX\n+    #[unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    #[rustc_const_unstable(feature = \"float_next_up_down\", issue = \"91399\")]\n+    pub const fn next_down(self) -> Self {\n+        // We must use strictly integer arithmetic to prevent denormals from\n+        // flushing to zero after an arithmetic operation on some platforms.\n+        const NEG_TINY_BITS: u64 = 0x8000_0000_0000_0001; // Smallest (in magnitude) negative f64.\n+        const CLEAR_SIGN_MASK: u64 = 0x7fff_ffff_ffff_ffff;\n+\n+        let bits = self.to_bits();\n+        if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {\n+            return self;\n+        }\n+\n+        let abs = bits & CLEAR_SIGN_MASK;\n+        let next_bits = if abs == 0 {\n+            NEG_TINY_BITS\n+        } else if bits == abs {\n+            bits - 1\n+        } else {\n+            bits + 1\n+        };\n+        Self::from_bits(next_bits)\n+    }\n+\n     /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```"}, {"sha": "4ec16c84aa916607c51a6293d221a0e28f205815", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=1ea4efd0656599f824e2567a5b7a95454f701c03", "patch": "@@ -299,6 +299,84 @@ fn test_is_sign_negative() {\n     assert!((-f32::NAN).is_sign_negative());\n }\n \n+#[allow(unused_macros)]\n+macro_rules! assert_f32_biteq {\n+    ($left : expr, $right : expr) => {\n+        let l: &f32 = &$left;\n+        let r: &f32 = &$right;\n+        let lb = l.to_bits();\n+        let rb = r.to_bits();\n+        assert_eq!(lb, rb, \"float {} ({:#x}) is not equal to {} ({:#x})\", *l, lb, *r, rb);\n+    };\n+}\n+\n+// Ignore test on x87 floating point, these platforms do not guarantee NaN\n+// payloads are preserved and flush denormals to zero, failing the tests.\n+#[cfg(not(target_arch = \"x86\"))]\n+#[test]\n+fn test_next_up() {\n+    let tiny = f32::from_bits(1);\n+    let tiny_up = f32::from_bits(2);\n+    let max_down = f32::from_bits(0x7f7f_fffe);\n+    let largest_subnormal = f32::from_bits(0x007f_ffff);\n+    let smallest_normal = f32::from_bits(0x0080_0000);\n+    assert_f32_biteq!(f32::NEG_INFINITY.next_up(), f32::MIN);\n+    assert_f32_biteq!(f32::MIN.next_up(), -max_down);\n+    assert_f32_biteq!((-1.0 - f32::EPSILON).next_up(), -1.0);\n+    assert_f32_biteq!((-smallest_normal).next_up(), -largest_subnormal);\n+    assert_f32_biteq!((-tiny_up).next_up(), -tiny);\n+    assert_f32_biteq!((-tiny).next_up(), -0.0f32);\n+    assert_f32_biteq!((-0.0f32).next_up(), tiny);\n+    assert_f32_biteq!(0.0f32.next_up(), tiny);\n+    assert_f32_biteq!(tiny.next_up(), tiny_up);\n+    assert_f32_biteq!(largest_subnormal.next_up(), smallest_normal);\n+    assert_f32_biteq!(1.0f32.next_up(), 1.0 + f32::EPSILON);\n+    assert_f32_biteq!(f32::MAX.next_up(), f32::INFINITY);\n+    assert_f32_biteq!(f32::INFINITY.next_up(), f32::INFINITY);\n+\n+    // Check that NaNs roundtrip.\n+    let nan0 = f32::NAN;\n+    let nan1 = f32::from_bits(f32::NAN.to_bits() ^ 0x002a_aaaa);\n+    let nan2 = f32::from_bits(f32::NAN.to_bits() ^ 0x0055_5555);\n+    assert_f32_biteq!(nan0.next_up(), nan0);\n+    assert_f32_biteq!(nan1.next_up(), nan1);\n+    assert_f32_biteq!(nan2.next_up(), nan2);\n+}\n+\n+// Ignore test on x87 floating point, these platforms do not guarantee NaN\n+// payloads are preserved and flush denormals to zero, failing the tests.\n+#[cfg(not(target_arch = \"x86\"))]\n+#[test]\n+fn test_next_down() {\n+    let tiny = f32::from_bits(1);\n+    let tiny_up = f32::from_bits(2);\n+    let max_down = f32::from_bits(0x7f7f_fffe);\n+    let largest_subnormal = f32::from_bits(0x007f_ffff);\n+    let smallest_normal = f32::from_bits(0x0080_0000);\n+    assert_f32_biteq!(f32::NEG_INFINITY.next_down(), f32::NEG_INFINITY);\n+    assert_f32_biteq!(f32::MIN.next_down(), f32::NEG_INFINITY);\n+    assert_f32_biteq!((-max_down).next_down(), f32::MIN);\n+    assert_f32_biteq!((-1.0f32).next_down(), -1.0 - f32::EPSILON);\n+    assert_f32_biteq!((-largest_subnormal).next_down(), -smallest_normal);\n+    assert_f32_biteq!((-tiny).next_down(), -tiny_up);\n+    assert_f32_biteq!((-0.0f32).next_down(), -tiny);\n+    assert_f32_biteq!((0.0f32).next_down(), -tiny);\n+    assert_f32_biteq!(tiny.next_down(), 0.0f32);\n+    assert_f32_biteq!(tiny_up.next_down(), tiny);\n+    assert_f32_biteq!(smallest_normal.next_down(), largest_subnormal);\n+    assert_f32_biteq!((1.0 + f32::EPSILON).next_down(), 1.0f32);\n+    assert_f32_biteq!(f32::MAX.next_down(), max_down);\n+    assert_f32_biteq!(f32::INFINITY.next_down(), f32::MAX);\n+\n+    // Check that NaNs roundtrip.\n+    let nan0 = f32::NAN;\n+    let nan1 = f32::from_bits(f32::NAN.to_bits() ^ 0x002a_aaaa);\n+    let nan2 = f32::from_bits(f32::NAN.to_bits() ^ 0x0055_5555);\n+    assert_f32_biteq!(nan0.next_down(), nan0);\n+    assert_f32_biteq!(nan1.next_down(), nan1);\n+    assert_f32_biteq!(nan2.next_down(), nan2);\n+}\n+\n #[test]\n fn test_mul_add() {\n     let nan: f32 = f32::NAN;"}, {"sha": "12baa68f49b76abcff7f1fb0c778870a608b04bf", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=1ea4efd0656599f824e2567a5b7a95454f701c03", "patch": "@@ -289,6 +289,82 @@ fn test_is_sign_negative() {\n     assert!((-f64::NAN).is_sign_negative());\n }\n \n+#[allow(unused_macros)]\n+macro_rules! assert_f64_biteq {\n+    ($left : expr, $right : expr) => {\n+        let l: &f64 = &$left;\n+        let r: &f64 = &$right;\n+        let lb = l.to_bits();\n+        let rb = r.to_bits();\n+        assert_eq!(lb, rb, \"float {} ({:#x}) is not equal to {} ({:#x})\", *l, lb, *r, rb);\n+    };\n+}\n+\n+// Ignore test on x87 floating point, these platforms do not guarantee NaN\n+// payloads are preserved and flush denormals to zero, failing the tests.\n+#[cfg(not(target_arch = \"x86\"))]\n+#[test]\n+fn test_next_up() {\n+    let tiny = f64::from_bits(1);\n+    let tiny_up = f64::from_bits(2);\n+    let max_down = f64::from_bits(0x7fef_ffff_ffff_fffe);\n+    let largest_subnormal = f64::from_bits(0x000f_ffff_ffff_ffff);\n+    let smallest_normal = f64::from_bits(0x0010_0000_0000_0000);\n+    assert_f64_biteq!(f64::NEG_INFINITY.next_up(), f64::MIN);\n+    assert_f64_biteq!(f64::MIN.next_up(), -max_down);\n+    assert_f64_biteq!((-1.0 - f64::EPSILON).next_up(), -1.0);\n+    assert_f64_biteq!((-smallest_normal).next_up(), -largest_subnormal);\n+    assert_f64_biteq!((-tiny_up).next_up(), -tiny);\n+    assert_f64_biteq!((-tiny).next_up(), -0.0f64);\n+    assert_f64_biteq!((-0.0f64).next_up(), tiny);\n+    assert_f64_biteq!(0.0f64.next_up(), tiny);\n+    assert_f64_biteq!(tiny.next_up(), tiny_up);\n+    assert_f64_biteq!(largest_subnormal.next_up(), smallest_normal);\n+    assert_f64_biteq!(1.0f64.next_up(), 1.0 + f64::EPSILON);\n+    assert_f64_biteq!(f64::MAX.next_up(), f64::INFINITY);\n+    assert_f64_biteq!(f64::INFINITY.next_up(), f64::INFINITY);\n+\n+    let nan0 = f64::NAN;\n+    let nan1 = f64::from_bits(f64::NAN.to_bits() ^ 0x000a_aaaa_aaaa_aaaa);\n+    let nan2 = f64::from_bits(f64::NAN.to_bits() ^ 0x0005_5555_5555_5555);\n+    assert_f64_biteq!(nan0.next_up(), nan0);\n+    assert_f64_biteq!(nan1.next_up(), nan1);\n+    assert_f64_biteq!(nan2.next_up(), nan2);\n+}\n+\n+// Ignore test on x87 floating point, these platforms do not guarantee NaN\n+// payloads are preserved and flush denormals to zero, failing the tests.\n+#[cfg(not(target_arch = \"x86\"))]\n+#[test]\n+fn test_next_down() {\n+    let tiny = f64::from_bits(1);\n+    let tiny_up = f64::from_bits(2);\n+    let max_down = f64::from_bits(0x7fef_ffff_ffff_fffe);\n+    let largest_subnormal = f64::from_bits(0x000f_ffff_ffff_ffff);\n+    let smallest_normal = f64::from_bits(0x0010_0000_0000_0000);\n+    assert_f64_biteq!(f64::NEG_INFINITY.next_down(), f64::NEG_INFINITY);\n+    assert_f64_biteq!(f64::MIN.next_down(), f64::NEG_INFINITY);\n+    assert_f64_biteq!((-max_down).next_down(), f64::MIN);\n+    assert_f64_biteq!((-1.0f64).next_down(), -1.0 - f64::EPSILON);\n+    assert_f64_biteq!((-largest_subnormal).next_down(), -smallest_normal);\n+    assert_f64_biteq!((-tiny).next_down(), -tiny_up);\n+    assert_f64_biteq!((-0.0f64).next_down(), -tiny);\n+    assert_f64_biteq!((0.0f64).next_down(), -tiny);\n+    assert_f64_biteq!(tiny.next_down(), 0.0f64);\n+    assert_f64_biteq!(tiny_up.next_down(), tiny);\n+    assert_f64_biteq!(smallest_normal.next_down(), largest_subnormal);\n+    assert_f64_biteq!((1.0 + f64::EPSILON).next_down(), 1.0f64);\n+    assert_f64_biteq!(f64::MAX.next_down(), max_down);\n+    assert_f64_biteq!(f64::INFINITY.next_down(), f64::MAX);\n+\n+    let nan0 = f64::NAN;\n+    let nan1 = f64::from_bits(f64::NAN.to_bits() ^ 0x000a_aaaa_aaaa_aaaa);\n+    let nan2 = f64::from_bits(f64::NAN.to_bits() ^ 0x0005_5555_5555_5555);\n+    assert_f64_biteq!(nan0.next_down(), nan0);\n+    assert_f64_biteq!(nan1.next_down(), nan1);\n+    assert_f64_biteq!(nan2.next_down(), nan2);\n+}\n+\n #[test]\n fn test_mul_add() {\n     let nan: f64 = f64::NAN;"}, {"sha": "f5dcdab4cd570afbaf40ec3c61ac2361fc4b0895", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea4efd0656599f824e2567a5b7a95454f701c03/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=1ea4efd0656599f824e2567a5b7a95454f701c03", "patch": "@@ -288,6 +288,7 @@\n #![feature(exclusive_wrapper)]\n #![feature(extend_one)]\n #![feature(float_minimum_maximum)]\n+#![feature(float_next_up_down)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]"}]}