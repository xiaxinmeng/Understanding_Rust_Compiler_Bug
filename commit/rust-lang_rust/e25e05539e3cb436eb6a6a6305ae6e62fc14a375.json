{"sha": "e25e05539e3cb436eb6a6a6305ae6e62fc14a375", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNWUwNTUzOWUzY2I0MzZlYjZhNmE2MzA1YWU2ZTYyZmMxNGEzNzU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-10T14:38:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-10T14:44:33Z"}, "message": "Handle mutable references in alias analysis", "tree": {"sha": "a611db630f28035120a9696ab648e099de215ca9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a611db630f28035120a9696ab648e099de215ca9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e25e05539e3cb436eb6a6a6305ae6e62fc14a375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e25e05539e3cb436eb6a6a6305ae6e62fc14a375", "html_url": "https://github.com/rust-lang/rust/commit/e25e05539e3cb436eb6a6a6305ae6e62fc14a375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e25e05539e3cb436eb6a6a6305ae6e62fc14a375/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f28796ed99c57b574a16430dd0f7b1b1884740c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28796ed99c57b574a16430dd0f7b1b1884740c6", "html_url": "https://github.com/rust-lang/rust/commit/f28796ed99c57b574a16430dd0f7b1b1884740c6"}], "stats": {"total": 122, "additions": 90, "deletions": 32}, "files": [{"sha": "d7cf80c0464e07ae8e025559d07189b2043e3b93", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 78, "deletions": 32, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e25e05539e3cb436eb6a6a6305ae6e62fc14a375/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e05539e3cb436eb6a6a6305ae6e62fc14a375/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=e25e05539e3cb436eb6a6a6305ae6e62fc14a375", "patch": "@@ -113,13 +113,30 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n         case (ty::ty_native_fn(_, ?args, _)) { args }\n     };\n \n-    auto i = 0u;\n     let vec[def_num] roots = [];\n+    let vec[tup(uint, def_num)] mut_roots = [];\n     let vec[ty::t] unsafe_ts = [];\n     let vec[uint] unsafe_t_offsets = [];\n+\n+    auto i = 0u;\n     for (ty::arg arg_t in arg_ts) {\n         if (arg_t.mode != ty::mo_val) {\n-            auto root = expr_root(cx, args.(i), false);\n+            auto arg = args.(i);\n+            auto root = expr_root(cx, arg, false);\n+            if (arg_t.mode == ty::mo_alias(true)) {\n+                alt (path_def_id(cx, arg)) {\n+                    case (some(?did)) {\n+                        vec::push(mut_roots, tup(i, did._1));\n+                    }\n+                    case (_) {\n+                        if (!root.mut_field) {\n+                            cx.tcx.sess.span_err\n+                                (arg.span, \"passing a temporary value or \\\n+                                 immutable field by mutable alias\");\n+                        }\n+                    }\n+                }\n+            }\n             alt (path_def_id(cx, root.ex)) {\n                 case (some(?did)) { vec::push(roots, did._1); }\n                 case (_) {}\n@@ -154,19 +171,31 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc)\n         j += 1u;\n         auto i = 0u;\n         for (ty::arg arg_t in arg_ts) {\n+            auto mut_alias = arg_t.mode == ty::mo_alias(true);\n             if (i != offset &&\n-                // FIXME false should be replace with mutability of alias\n-                ty_can_unsafely_include(cx, unsafe, arg_t.ty, false)) {\n+                ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias)) {\n                 cx.tcx.sess.span_err\n                     (args.(i).span, #fmt(\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\", i, offset));\n             }\n             i += 1u;\n         }\n     }\n-    // FIXME when mutable aliases can be distinguished, go over the args again\n-    // and ensure that we're not passing a root variable by mutable alias\n-    // (using roots and the scope root vars).\n+\n+    // Ensure we're not passing a root by mutable alias.\n+    for (tup(uint, def_num) root in mut_roots) {\n+        auto mut_alias_to_root = vec::count(root._1, roots) > 1u;\n+        for (restrict r in sc.rs) {\n+            if (vec::member(root._1, r.root_vars)) {\n+                mut_alias_to_root = true;\n+            }\n+        }\n+        if (mut_alias_to_root) {\n+            cx.tcx.sess.span_err\n+                (args.(root._0).span, \"passing a mutable alias to a \\\n+                 variable that roots another alias\");\n+        }\n+    }\n \n     ret rec(root_vars = roots, unsafe_ts = unsafe_ts);\n }\n@@ -300,25 +329,16 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n     alt (dest.node) {\n         case (ast::expr_path(?p, ?ann)) {\n             auto dnum = ast::def_id_of_def(cx.dm.get(ann.id))._1;\n-\n-            for (tup(def_num, ast::mode) arg in sc.args) {\n-                if (arg._0 == dnum && arg._1 == ast::alias(false)) {\n-                    cx.tcx.sess.span_err\n-                        (dest.span, \"assigning to immutable alias\");\n-                }\n+            if (is_immutable_alias(sc, dnum)) {\n+                cx.tcx.sess.span_err\n+                    (dest.span, \"assigning to immutable alias\");\n             }\n \n             auto var_t = ty::expr_ty(*cx.tcx, dest);\n             for (restrict r in sc.rs) {\n                 if (vec::member(dnum, r.root_vars)) {\n                     r.ok = overwritten(dest.span, p);\n                 }\n-                for (def_num bnd in r.bindings) {\n-                    if (dnum == bnd) {\n-                        cx.tcx.sess.span_err\n-                            (dest.span, \"assigning to immutable alias\");\n-                    }\n-                }\n             }\n             check_var(*cx, dest, p, ann, true, sc);\n         }\n@@ -328,6 +348,16 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src,\n     }\n }\n \n+fn is_immutable_alias(&scope sc, def_num dnum) -> bool {\n+    for (tup(def_num, ast::mode) arg in sc.args) {\n+        if (arg._0 == dnum && arg._1 == ast::alias(false)) { ret true; }\n+    }\n+    for (restrict r in sc.rs) {\n+        if (vec::member(dnum, r.bindings)) { ret true; }\n+    }\n+    ret false;\n+}\n+\n fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n     auto prob = r.ok;\n     for (uint dep in r.depends_on) {\n@@ -364,13 +394,18 @@ fn deps(&scope sc, vec[def_num] roots) -> vec[uint] {\n }\n \n fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n-    -> rec(@ast::expr ex, option::t[ty::t] inner_mut, bool mut_in_box) {\n+    -> rec(@ast::expr ex,\n+           option::t[ty::t] inner_mut,\n+           bool mut_in_box,\n+           bool mut_field) {\n     let option::t[ty::t] mut = none;\n     // This is not currently used but would make it possible to be more\n     // liberal -- only stuff in a mutable box needs full type-inclusion\n     // checking, things that aren't in a box need only be checked against\n     // locally live aliases and their root.\n     auto mut_in_box = false;\n+    auto mut_fld = false;\n+    auto depth = 0;\n     while (true) {\n         alt ({ex.node}) {\n             case (ast::expr_field(?base, ?ident, _)) {\n@@ -379,15 +414,19 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_tup(?fields)) {\n                         auto fnm = ty::field_num(cx.tcx.sess, ex.span, ident);\n-                        if (fields.(fnm).mut != ast::imm && is_none(mut)) {\n-                            mut = some(auto_unbox.t);\n+                        if (fields.(fnm).mut != ast::imm) {\n+                            if (is_none(mut)) { mut = some(auto_unbox.t); }\n+                            if (depth == 0) { mut_fld = true; }\n                         }\n                     }\n                     case (ty::ty_rec(?fields)) {\n                         for (ty::field fld in fields) {\n                             if (str::eq(ident, fld.ident)) {\n-                                if (fld.mt.mut != ast::imm && is_none(mut)) {\n-                                    mut = some(auto_unbox.t);\n+                                if (fld.mt.mut != ast::imm) {\n+                                    if (is_none(mut)) {\n+                                        mut = some(auto_unbox.t);\n+                                    }\n+                                    if (depth == 0) { mut_fld = true; }\n                                 }\n                                 break;\n                             }\n@@ -406,26 +445,26 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n                 auto auto_unbox = maybe_auto_unbox(cx, base_t);\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n-                        if (mt.mut != ast::imm && is_none(mut)) {\n-                            mut = some(auto_unbox.t);\n+                        if (mt.mut != ast::imm) {\n+                            if (is_none(mut)) { mut = some(auto_unbox.t); }\n+                            if (depth == 0) { mut_fld = true; }\n                         }\n                     }\n                 }\n                 if (auto_unbox.done) {\n                     if (!is_none(mut)) { mut_in_box = true; }\n                     else if (auto_unbox.mut) { mut = some(base_t); }\n                 }\n-                if (auto_unbox.done && !is_none(mut)) {\n-                }\n                 ex = base;\n             }\n             case (ast::expr_unary(?op, ?base, _)) {\n                 if (op == ast::deref) {\n                     auto base_t = ty::expr_ty(*cx.tcx, base);\n                     alt (ty::struct(*cx.tcx, base_t)) {\n                         case (ty::ty_box(?mt)) {\n-                            if (mt.mut != ast::imm && is_none(mut)) {\n-                                mut = some(base_t);\n+                            if (mt.mut != ast::imm) {\n+                                if (is_none(mut)) { mut = some(base_t); }\n+                                if (depth == 0) { mut_fld = true; }\n                             }\n                             if (!is_none(mut)) {\n                                 mut_in_box = true;\n@@ -439,16 +478,23 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef)\n             }\n             case (_) { break; }\n         }\n+        depth += 1;\n     }\n     if (autoderef) {\n         auto ex_t = ty::expr_ty(*cx.tcx, ex);\n         auto auto_unbox = maybe_auto_unbox(cx, ex_t);\n         if (auto_unbox.done) {\n             if (!is_none(mut)) { mut_in_box = true; }\n-            else if (auto_unbox.mut) { mut = some(ex_t); }\n+            else if (auto_unbox.mut) {\n+                mut = some(ex_t);\n+                if (depth == 0) { mut_fld = true; }\n+            }\n         }\n     }\n-    ret rec(ex = ex, inner_mut = mut, mut_in_box = mut_in_box);\n+    ret rec(ex = ex,\n+            inner_mut = mut,\n+            mut_in_box = mut_in_box,\n+            mut_field = mut_fld);\n }\n \n fn maybe_auto_unbox(&ctx cx, &ty::t t)"}, {"sha": "b6968056b12701f6aa3304ac3ab491f2abfd2871", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e25e05539e3cb436eb6a6a6305ae6e62fc14a375/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e25e05539e3cb436eb6a6a6305ae6e62fc14a375/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=e25e05539e3cb436eb6a6a6305ae6e62fc14a375", "patch": "@@ -0,0 +1,12 @@\n+// xfail-stage0\n+// error-pattern:mutable alias to a variable that roots another alias\n+\n+fn f(&int a, &mutable int b) -> int {\n+    b += 1;\n+    ret a + b;\n+}\n+\n+fn main() {\n+    auto i = 4;\n+    log f(i, i);\n+}"}]}