{"sha": "aaa1db63ce2b92240272a1db303fa292d58373ee", "node_id": "C_kwDOAAsO6NoAKGFhYTFkYjYzY2UyYjkyMjQwMjcyYTFkYjMwM2ZhMjkyZDU4MzczZWU", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-11-25T18:07:19Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-11-25T18:25:00Z"}, "message": "Remove AscribeUserTypeCx", "tree": {"sha": "6d6f8d8ddce11dfc4d987678ae05478bd0126448", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d6f8d8ddce11dfc4d987678ae05478bd0126448"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaa1db63ce2b92240272a1db303fa292d58373ee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmOBCHwACgkQgTGiTgx5\n769ElQ//ZOp/92JzTmDyn6eIOAoUU/frOPOPhsyYbzz9bmiLQaPuWp1TwE9MOo/M\n7lPUt5px1WlusjT7yVB6J5GmeyfyXgY8gxbBf667JeWfTcGrMjlqijKnji0DLjVp\nElYeX1A9K8NrHEKoUyV3Yhe/nl7/FvO7sD8F1MKRtvk9TV/4w/aXfTHg+qOewW7w\nVbmrrtxTHeMlZFB5Jpp8qA3PME40ifYzuhmsuwSOgfVkHUCAqF1FkUZ48dJgcNGl\n8NuDf9UozdFBhUWBCf3a6QKt1ezmHbBuQG3YfDAydgw2bDDXs1u/W/lN3RbVhBXZ\nacp/9kuYjDLInXlLAwdicJkKE+daM30+Qt2zUTsDBshHEhP9Ab5NsvhZ+IaFtgFZ\nI9lp7s4jJNBZnvHRMnd9/p08qWOjpjIdOw5ykIgX6hjb0hfEmnifcgRiDQiTE4A+\ngqwNWlCh0pBsxe+PArRMuEEv1kVu7dsFoenvqomHiQN/hZivZ15vXcU9irksBuzV\nIDfnhzj8ysGixKaJ69/iYTDpnup2993TrhtLRlhu5WrspsoLh2MVYY4Db2rlyjK6\nfQ9QStwx+yEcg5tYTmIYEvroKlZy8Q/d5s01/KR4QvJU2m1qTidjudgV9jjTWCvB\n0lCjE0V0M0djj5F44HIjCraCQfyYCttmaiVvKVHZ2d4k+fDX0Iw=\n=NL0N\n-----END PGP SIGNATURE-----", "payload": "tree 6d6f8d8ddce11dfc4d987678ae05478bd0126448\nparent e704e95250ff4e949214f390a88f21d08052bea1\nauthor Santiago Pastorino <spastorino@gmail.com> 1669399639 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1669400700 -0300\n\nRemove AscribeUserTypeCx\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa1db63ce2b92240272a1db303fa292d58373ee", "html_url": "https://github.com/rust-lang/rust/commit/aaa1db63ce2b92240272a1db303fa292d58373ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaa1db63ce2b92240272a1db303fa292d58373ee/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e704e95250ff4e949214f390a88f21d08052bea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e704e95250ff4e949214f390a88f21d08052bea1", "html_url": "https://github.com/rust-lang/rust/commit/e704e95250ff4e949214f390a88f21d08052bea1"}], "stats": {"total": 159, "additions": 52, "deletions": 107}, "files": [{"sha": "fffa666cd5834fb915c69ddcefdaadea8f7bbe08", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 52, "deletions": 107, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/aaa1db63ce2b92240272a1db303fa292d58373ee/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa1db63ce2b92240272a1db303fa292d58373ee/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=aaa1db63ce2b92240272a1db303fa292d58373ee", "patch": "@@ -1,6 +1,4 @@\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCauseCode;\n@@ -57,122 +55,69 @@ pub fn type_op_ascribe_user_type_with_span<'tcx>(\n         \"type_op_ascribe_user_type: mir_ty={:?} def_id={:?} user_substs={:?}\",\n         mir_ty, def_id, user_substs\n     );\n-    let cx = AscribeUserTypeCx { ocx, param_env, span: span.unwrap_or(DUMMY_SP) };\n-    cx.relate_mir_and_user_ty(mir_ty, def_id, user_substs)?;\n-    Ok(())\n-}\n-\n-struct AscribeUserTypeCx<'me, 'tcx> {\n-    ocx: &'me ObligationCtxt<'me, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-}\n+    let span = span.unwrap_or(DUMMY_SP);\n \n-impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n-    fn normalize<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.normalize_with_cause(value, ObligationCause::misc(self.span, hir::CRATE_HIR_ID))\n-    }\n+    let UserSubsts { user_self_ty, substs } = user_substs;\n+    let tcx = ocx.infcx.tcx;\n \n-    fn normalize_with_cause<T>(&self, value: T, cause: ObligationCause<'tcx>) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.ocx.normalize(cause, self.param_env, value)\n-    }\n+    let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n+    let ty = ocx.normalize(ObligationCause::misc(span, hir::CRATE_HIR_ID), param_env, ty);\n+    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n-    fn eq<T>(&self, a: T, b: T) -> Result<(), NoSolution>\n-    where\n-        T: ToTrace<'tcx>,\n-    {\n-        Ok(self.ocx.eq(&ObligationCause::dummy_with_span(self.span), self.param_env, a, b)?)\n-    }\n+    ocx.eq(&ObligationCause::dummy_with_span(span), param_env, mir_ty, ty)?;\n \n-    fn prove_predicate(&self, predicate: Predicate<'tcx>, cause: ObligationCause<'tcx>) {\n-        self.ocx.register_obligation(Obligation::new(\n-            self.ocx.infcx.tcx,\n-            cause,\n-            self.param_env,\n-            predicate,\n-        ));\n-    }\n+    // Prove the predicates coming along with `def_id`.\n+    //\n+    // Also, normalize the `instantiated_predicates`\n+    // because otherwise we wind up with duplicate \"type\n+    // outlives\" error messages.\n+    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n \n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.ocx.infcx.tcx\n-    }\n+    let cause = ObligationCause::dummy_with_span(span);\n \n-    #[instrument(level = \"debug\", skip(self))]\n-    fn relate_mir_and_user_ty(\n-        &self,\n-        mir_ty: Ty<'tcx>,\n-        def_id: DefId,\n-        user_substs: UserSubsts<'tcx>,\n-    ) -> Result<(), NoSolution> {\n-        let UserSubsts { user_self_ty, substs } = user_substs;\n-        let tcx = self.tcx();\n-\n-        let ty = tcx.bound_type_of(def_id).subst(tcx, substs);\n-        let ty = self.normalize(ty);\n-        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-\n-        self.eq(mir_ty, ty)?;\n-\n-        // Prove the predicates coming along with `def_id`.\n-        //\n-        // Also, normalize the `instantiated_predicates`\n-        // because otherwise we wind up with duplicate \"type\n-        // outlives\" error messages.\n-        let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-        let cause = ObligationCause::dummy_with_span(self.span);\n-\n-        debug!(?instantiated_predicates);\n-        for (instantiated_predicate, predicate_span) in\n-            zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n-        {\n-            let span = if self.span == DUMMY_SP { predicate_span } else { self.span };\n-            let cause = ObligationCause::new(\n-                span,\n-                hir::CRATE_HIR_ID,\n-                ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-            );\n-            let instantiated_predicate =\n-                self.normalize_with_cause(instantiated_predicate, cause.clone());\n-            self.prove_predicate(instantiated_predicate, cause);\n-        }\n+    debug!(?instantiated_predicates);\n+    for (instantiated_predicate, predicate_span) in\n+        zip(instantiated_predicates.predicates, instantiated_predicates.spans)\n+    {\n+        let span = if span == DUMMY_SP { predicate_span } else { span };\n+        let cause = ObligationCause::new(\n+            span,\n+            hir::CRATE_HIR_ID,\n+            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+        );\n+        let instantiated_predicate =\n+            ocx.normalize(cause.clone(), param_env, instantiated_predicate);\n \n-        if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-            let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n-            let impl_self_ty = self.normalize(impl_self_ty);\n+        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n+    }\n \n-            self.eq(self_ty, impl_self_ty)?;\n+    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let impl_self_ty = tcx.bound_type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty =\n+            ocx.normalize(ObligationCause::misc(span, hir::CRATE_HIR_ID), param_env, impl_self_ty);\n \n-            self.prove_predicate(\n-                ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()))\n-                    .to_predicate(tcx),\n-                cause.clone(),\n-            );\n-        }\n+        ocx.eq(&ObligationCause::dummy_with_span(span), param_env, self_ty, impl_self_ty)?;\n \n-        // In addition to proving the predicates, we have to\n-        // prove that `ty` is well-formed -- this is because\n-        // the WF of `ty` is predicated on the substs being\n-        // well-formed, and we haven't proven *that*. We don't\n-        // want to prove the WF of types from  `substs` directly because they\n-        // haven't been normalized.\n-        //\n-        // FIXME(nmatsakis): Well, perhaps we should normalize\n-        // them?  This would only be relevant if some input\n-        // type were ill-formed but did not appear in `ty`,\n-        // which...could happen with normalization...\n-        self.prove_predicate(\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx),\n-            cause,\n-        );\n-        Ok(())\n+        let predicate: Predicate<'tcx> =\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into())).to_predicate(tcx);\n+        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n     }\n+\n+    // In addition to proving the predicates, we have to\n+    // prove that `ty` is well-formed -- this is because\n+    // the WF of `ty` is predicated on the substs being\n+    // well-formed, and we haven't proven *that*. We don't\n+    // want to prove the WF of types from  `substs` directly because they\n+    // haven't been normalized.\n+    //\n+    // FIXME(nmatsakis): Well, perhaps we should normalize\n+    // them?  This would only be relevant if some input\n+    // type were ill-formed but did not appear in `ty`,\n+    // which...could happen with normalization...\n+    let predicate: Predicate<'tcx> =\n+        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into())).to_predicate(tcx);\n+    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n+    Ok(())\n }\n \n fn type_op_eq<'tcx>("}]}