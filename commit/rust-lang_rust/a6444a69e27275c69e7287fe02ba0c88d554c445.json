{"sha": "a6444a69e27275c69e7287fe02ba0c88d554c445", "node_id": "C_kwDOAAsO6NoAKGE2NDQ0YTY5ZTI3Mjc1YzY5ZTcyODdmZTAyYmEwYzg4ZDU1NGM0NDU", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-23T17:05:57Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-23T17:05:57Z"}, "message": "Remove if_chain from equatable_if_let", "tree": {"sha": "e265d1a1ef5434669f7b7738b6b4228acede9e56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e265d1a1ef5434669f7b7738b6b4228acede9e56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6444a69e27275c69e7287fe02ba0c88d554c445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6444a69e27275c69e7287fe02ba0c88d554c445", "html_url": "https://github.com/rust-lang/rust/commit/a6444a69e27275c69e7287fe02ba0c88d554c445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6444a69e27275c69e7287fe02ba0c88d554c445/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5735a3bef6db84156d78d05fdd43e6332687cf2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5735a3bef6db84156d78d05fdd43e6332687cf2c", "html_url": "https://github.com/rust-lang/rust/commit/5735a3bef6db84156d78d05fdd43e6332687cf2c"}], "stats": {"total": 59, "additions": 27, "deletions": 32}, "files": [{"sha": "ba615c8c1648401037c26b262d1e126464cebe07", "filename": "clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a6444a69e27275c69e7287fe02ba0c88d554c445/clippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6444a69e27275c69e7287fe02ba0c88d554c445/clippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=a6444a69e27275c69e7287fe02ba0c88d554c445", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::implements_trait;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -67,37 +66,33 @@ fn is_structural_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: T\n \n impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Let(let_expr) = expr.kind;\n-            if unary_pattern(let_expr.pat);\n-            let exp_ty = cx.typeck_results().expr_ty(let_expr.init);\n-            let pat_ty = cx.typeck_results().pat_ty(let_expr.pat);\n-            if is_structural_partial_eq(cx, exp_ty, pat_ty);\n-            then {\n-\n-                let mut applicability = Applicability::MachineApplicable;\n-                let pat_str = match let_expr.pat.kind {\n-                    PatKind::Struct(..) => format!(\n-                        \"({})\",\n-                        snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n-                    ),\n-                    _ => snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n-                };\n-                span_lint_and_sugg(\n-                    cx,\n-                    EQUATABLE_IF_LET,\n-                    expr.span,\n-                    \"this pattern matching can be expressed using equality\",\n-                    \"try\",\n-                    format!(\n-                        \"{} == {}\",\n-                        snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n-                        pat_str,\n-                    ),\n-                    applicability,\n-                );\n-            }\n+        if !in_external_macro(cx.sess(), expr.span)\n+            && let ExprKind::Let(let_expr) = expr.kind\n+            && unary_pattern(let_expr.pat)\n+            && let exp_ty = cx.typeck_results().expr_ty(let_expr.init)\n+            && let pat_ty = cx.typeck_results().pat_ty(let_expr.pat)\n+            && is_structural_partial_eq(cx, exp_ty, pat_ty) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let pat_str = match let_expr.pat.kind {\n+                PatKind::Struct(..) => format!(\n+                    \"({})\",\n+                    snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                ),\n+                _ => snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                EQUATABLE_IF_LET,\n+                expr.span,\n+                \"this pattern matching can be expressed using equality\",\n+                \"try\",\n+                format!(\n+                    \"{} == {}\",\n+                    snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                    pat_str,\n+                ),\n+                applicability,\n+            );\n         }\n     }\n }"}]}