{"sha": "2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNDJhYzQzOGVmNGJjMjc3M2Y1YWMwYTU1YWU0NWIwOGU1NzViMTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-12-02T18:31:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-12-22T06:12:48Z"}, "message": "std: Remove rust_builtin C support library\n\nAll these definitions can now be written in Rust, so do so!", "tree": {"sha": "f91aed3b3f838305d24f1d25441ec22dc6ab995d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f91aed3b3f838305d24f1d25441ec22dc6ab995d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "html_url": "https://github.com/rust-lang/rust/commit/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2343a92a908901958c8207d6d0430a2e59ab0a9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2343a92a908901958c8207d6d0430a2e59ab0a9c", "html_url": "https://github.com/rust-lang/rust/commit/2343a92a908901958c8207d6d0430a2e59ab0a9c"}], "stats": {"total": 822, "additions": 156, "deletions": 666}, "files": [{"sha": "2597c724da96fd7ad4aa096d7633bc6e3bc80635", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -71,7 +71,7 @@ DEPS_rustc_bitflags := core\n DEPS_rustc_unicode := core\n \n DEPS_std := core libc rand alloc collections rustc_unicode \\\n-\tnative:rust_builtin native:backtrace \\\n+\tnative:backtrace \\\n \talloc_system\n DEPS_arena := std\n DEPS_glob := std"}, {"sha": "92c7c506f187ac4435b93b38bfd1447f981e5859", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -35,7 +35,7 @@\n # that's per-target so you're allowed to conditionally add files based on the\n # target.\n ################################################################################\n-NATIVE_LIBS := rust_builtin hoedown miniz rust_test_helpers\n+NATIVE_LIBS := hoedown miniz rust_test_helpers\n \n # $(1) is the target triple\n define NATIVE_LIBRARIES\n@@ -50,8 +50,6 @@ NATIVE_DEPS_hoedown_$(1) := hoedown/src/autolink.c \\\n \t\t\thoedown/src/stack.c \\\n \t\t\thoedown/src/version.c\n NATIVE_DEPS_miniz_$(1) = miniz.c\n-NATIVE_DEPS_rust_builtin_$(1) := rust_builtin.c \\\n-\t\t\trust_android_dummy.c\n NATIVE_DEPS_rust_test_helpers_$(1) := rust_test_helpers.c\n \n ################################################################################"}, {"sha": "eaaa9391d3115e2667e6f6deab6c977257efcf64", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -108,3 +108,14 @@ pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     let flags = align_to_flags(align);\n     unsafe { je_nallocx(size as size_t, flags) as usize }\n }\n+\n+// These symbols are used by jemalloc on android but the really old android\n+// we're building on doesn't have them defined, so just make sure the symbols\n+// are available.\n+#[no_mangle]\n+#[cfg(target_os = \"android\")]\n+pub extern fn pthread_atfork(_prefork: *mut u8,\n+                             _postfork_parent: *mut u8,\n+                             _postfork_child: *mut u8) -> i32 {\n+    0\n+}"}, {"sha": "9b1046f39a7b34d8ee5de98c2dcb681248bfec38", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -12,11 +12,6 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-// A few small shims in C that haven't been translated to Rust yet\n-#[cfg(all(not(test), not(windows)))]\n-#[link(name = \"rust_builtin\", kind = \"static\")]\n-extern {}\n-\n // LLVM implements the `frem` instruction as a call to `fmod`, which lives in\n // libm. Hence, we must explicitly link to it.\n //"}, {"sha": "e8575a6c21cf13c0eb159766123a3c415df28c05", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 65, "deletions": 45, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -14,7 +14,8 @@ use os::unix::prelude::*;\n use ffi::{CString, CStr, OsString, OsStr};\n use fmt;\n use io::{self, Error, ErrorKind, SeekFrom};\n-use libc::{self, c_int, off_t, c_char, mode_t};\n+use libc::{dirent, readdir_r};\n+use libc::{self, c_int, off_t, mode_t};\n use mem;\n use path::{Path, PathBuf};\n use ptr;\n@@ -43,7 +44,7 @@ unsafe impl Send for Dir {}\n unsafe impl Sync for Dir {}\n \n pub struct DirEntry {\n-    buf: Vec<u8>, // actually *mut libc::dirent\n+    entry: dirent,\n     root: Arc<PathBuf>,\n }\n \n@@ -126,32 +127,22 @@ impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        extern {\n-            fn rust_dirent_t_size() -> libc::size_t;\n-        }\n-\n-        let mut buf: Vec<u8> = Vec::with_capacity(unsafe {\n-            rust_dirent_t_size()\n-        });\n-        let ptr = buf.as_mut_ptr() as *mut libc::dirent;\n-\n-        let mut entry_ptr = ptr::null_mut();\n-        loop {\n-            if unsafe { libc::readdir_r(self.dirp.0, ptr, &mut entry_ptr) != 0 } {\n-                return Some(Err(Error::last_os_error()))\n-            }\n-            if entry_ptr.is_null() {\n-                return None\n-            }\n-\n-            let entry = DirEntry {\n-                buf: buf,\n+        unsafe {\n+            let mut ret = DirEntry {\n+                entry: mem::zeroed(),\n                 root: self.root.clone()\n             };\n-            if entry.name_bytes() == b\".\" || entry.name_bytes() == b\"..\" {\n-                buf = entry.buf;\n-            } else {\n-                return Some(Ok(entry))\n+            let mut entry_ptr = ptr::null_mut();\n+            loop {\n+                if readdir_r(self.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n+                    return Some(Err(Error::last_os_error()))\n+                }\n+                if entry_ptr.is_null() {\n+                    return None\n+                }\n+                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n+                    return Some(Ok(ret))\n+                }\n             }\n         }\n     }\n@@ -166,7 +157,7 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        self.root.join(<OsStr as OsStrExt>::from_bytes(self.name_bytes()))\n+        self.root.join(OsStr::from_bytes(self.name_bytes()))\n     }\n \n     pub fn file_name(&self) -> OsString {\n@@ -178,35 +169,64 @@ impl DirEntry {\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n-        extern {\n-            fn rust_dir_get_mode(ptr: *mut libc::dirent) -> c_int;\n-        }\n-        unsafe {\n-            match rust_dir_get_mode(self.dirent()) {\n-                -1 => lstat(&self.path()).map(|m| m.file_type()),\n-                n => Ok(FileType { mode: n as mode_t }),\n-            }\n+        match self.entry.d_type {\n+            libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n+            libc::DT_FIFO => Ok(FileType { mode: libc::S_IFIFO }),\n+            libc::DT_LNK => Ok(FileType { mode: libc::S_IFLNK }),\n+            libc::DT_REG => Ok(FileType { mode: libc::S_IFREG }),\n+            libc::DT_SOCK => Ok(FileType { mode: libc::S_IFSOCK }),\n+            libc::DT_DIR => Ok(FileType { mode: libc::S_IFDIR }),\n+            libc::DT_BLK => Ok(FileType { mode: libc::S_IFBLK }),\n+            _ => lstat(&self.path()).map(|m| m.file_type()),\n         }\n     }\n \n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"linux\"))]\n     pub fn ino(&self) -> raw::ino_t {\n-        extern {\n-            fn rust_dir_get_ino(ptr: *mut libc::dirent) -> raw::ino_t;\n-        }\n-        unsafe { rust_dir_get_ino(self.dirent()) }\n+        self.entry.d_ino\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    pub fn ino(&self) -> raw::ino_t {\n+        self.entry.d_ino as raw::ino_t\n+    }\n+\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"openbsd\",\n+              target_os = \"bitrig\",\n+              target_os = \"netbsd\",\n+              target_os = \"dragonfly\"))]\n+    pub fn ino(&self) -> raw::ino_t {\n+        self.entry.d_fileno\n     }\n \n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"netbsd\"))]\n     fn name_bytes(&self) -> &[u8] {\n-        extern {\n-            fn rust_list_dir_val(ptr: *mut libc::dirent) -> *const c_char;\n+        unsafe {\n+            ::slice::from_raw_parts(self.entry.d_name.as_ptr() as *const u8,\n+                                    self.entry.d_namlen as usize)\n         }\n+    }\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"dragonfly\",\n+              target_os = \"bitrig\",\n+              target_os = \"openbsd\"))]\n+    fn name_bytes(&self) -> &[u8] {\n         unsafe {\n-            CStr::from_ptr(rust_list_dir_val(self.dirent())).to_bytes()\n+            ::slice::from_raw_parts(self.entry.d_name.as_ptr() as *const u8,\n+                                    self.entry.d_namelen as usize)\n         }\n     }\n-\n-    fn dirent(&self) -> *mut libc::dirent {\n-        self.buf.as_ptr() as *mut _\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"linux\"))]\n+    fn name_bytes(&self) -> &[u8] {\n+        unsafe {\n+            CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()\n+        }\n     }\n }\n "}, {"sha": "c62960d74cb1ca290c4b1e74621a1cc93901457f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -38,12 +38,17 @@ static ENV_LOCK: StaticMutex = StaticMutex::new();\n /// Returns the platform-specific value of errno\n pub fn errno() -> i32 {\n     extern {\n-        #[cfg_attr(any(target_os = \"linux\", target_os = \"android\"), link_name = \"__errno_location\")]\n-        #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\",\n+        #[cfg_attr(any(target_os = \"linux\"), link_name = \"__errno_location\")]\n+        #[cfg_attr(any(target_os = \"bitrig\",\n+                       target_os = \"netbsd\",\n+                       target_os = \"openbsd\",\n+                       target_os = \"android\",\n                        target_env = \"newlib\"),\n                    link_name = \"__errno\")]\n         #[cfg_attr(target_os = \"dragonfly\", link_name = \"__dfly_error\")]\n-        #[cfg_attr(any(target_os = \"macos\", target_os = \"ios\", target_os = \"freebsd\"),\n+        #[cfg_attr(any(target_os = \"macos\",\n+                       target_os = \"ios\",\n+                       target_os = \"freebsd\"),\n                    link_name = \"__error\")]\n         fn errno_location() -> *const c_int;\n     }\n@@ -173,17 +178,19 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                        libc::KERN_PROC_PATHNAME as c_int,\n                        -1 as c_int];\n         let mut sz: libc::size_t = 0;\n-        let err = libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                               ptr::null_mut(), &mut sz, ptr::null_mut(),\n-                               0 as libc::size_t);\n-        if err != 0 { return Err(io::Error::last_os_error()); }\n-        if sz == 0 { return Err(io::Error::last_os_error()); }\n+        try!(cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                              ptr::null_mut(), &mut sz, ptr::null_mut(),\n+                              0 as libc::size_t)));\n+        if sz == 0 {\n+            return Err(io::Error::last_os_error())\n+        }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n-        let err = libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n-                               v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n-                               ptr::null_mut(), 0 as libc::size_t);\n-        if err != 0 { return Err(io::Error::last_os_error()); }\n-        if sz == 0 { return Err(io::Error::last_os_error()); }\n+        try!(cvt(libc::sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                              v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n+                              ptr::null_mut(), 0 as libc::size_t)));\n+        if sz == 0 {\n+            return Err(io::Error::last_os_error());\n+        }\n         v.set_len(sz as usize - 1); // chop off trailing NUL\n         Ok(PathBuf::from(OsString::from_vec(v)))\n     }\n@@ -201,22 +208,28 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n-    use sync::StaticMutex;\n-    static LOCK: StaticMutex = StaticMutex::new();\n-\n-    extern {\n-        fn rust_current_exe() -> *const c_char;\n-    }\n-\n-    let _guard = LOCK.lock();\n-\n     unsafe {\n-        let v = rust_current_exe();\n-        if v.is_null() {\n-            Err(io::Error::last_os_error())\n+        let mut mib = [libc::CTL_KERN,\n+                       libc::KERN_PROC_ARGS,\n+                       libc::getpid(),\n+                       libc::KERN_PROC_ARGV];\n+        let mib = mib.as_mut_ptr();\n+        let mut argv_len = 0;\n+        try!(cvt(libc::sysctl(mib, 4, 0 as *mut _, &mut argv_len,\n+                              0 as *mut _, 0)));\n+        let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n+        try!(cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n+                              &mut argv_len, 0 as *mut _, 0)));\n+        argv.set_len(argv_len as usize);\n+        if argv[0].is_null() {\n+            return Err(io::Error::new(io::ErrorKind::Other,\n+                                      \"no current exe available\"))\n+        }\n+        let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n+        if argv0[0] == b'.' || argv0.iter().any(|b| *b == b'/') {\n+            ::fs::canonicalize(OsStr::from_bytes(argv0))\n         } else {\n-            let vec = CStr::from_ptr(v).to_bytes().to_vec();\n-            Ok(PathBuf::from(OsString::from_vec(vec)))\n+            Ok(PathBuf::from(OsStr::from_bytes(argv0)))\n         }\n     }\n }"}, {"sha": "a844bdf1351d9041892c38bd15777caf7becce72", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f42ac438ef4bc2773f5ac0a55ae45b08e575b17/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=2f42ac438ef4bc2773f5ac0a55ae45b08e575b17", "patch": "@@ -906,10 +906,45 @@ fn get_concurrency() -> usize {\n         }\n     }\n \n-    #[cfg(unix)]\n+    #[cfg(any(target_os = \"linux\",\n+              target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"android\"))]\n     fn num_cpus() -> usize {\n-        extern { fn rust_get_num_cpus() -> libc::uintptr_t; }\n-        unsafe { rust_get_num_cpus() as usize }\n+        unsafe {\n+            libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize\n+        }\n+    }\n+\n+    #[cfg(any(target_os = \"freebsd\",\n+              target_os = \"dragonfly\",\n+              target_os = \"bitrig\",\n+              target_os = \"openbsd\",\n+              target_os = \"netbsd\"))]\n+    fn num_cpus() -> usize {\n+        let mut cpus: libc::c_uint = 0;\n+        let mut CPUS_SIZE = std::mem::size_of_val(&cpus);\n+        let mut mib = [libc::CTL_HW, libc::HW_AVAILCPU, 0, 0];\n+\n+        unsafe {\n+            libc::sysctl(mib.as_mut_ptr(), 2,\n+                         &mut cpus as *mut _ as *mut _,\n+                         &mut CPUS_SIZE as *mut _ as *mut _,\n+                         0 as *mut _, 0);\n+        }\n+        if cpus < 1 {\n+            mib[1] = HW_NCPU;\n+            unsafe {\n+                libc::sysctl(mib.as_mut_ptr(), 2,\n+                             &mut cpus as *mut _ as *mut _,\n+                             &mut CPUS_SIZE as *mut _ as *mut _,\n+                             0 as *mut _, 0);\n+            }\n+            if cpus < 1 {\n+                cpus = 1;\n+            }\n+        }\n+        cpus as usize\n     }\n }\n "}, {"sha": "c322dc6706f7211c70094c63e29668b93326fa5c", "filename": "src/rt/rust_android_dummy.c", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/2343a92a908901958c8207d6d0430a2e59ab0a9c/src%2Frt%2Frust_android_dummy.c", "raw_url": "https://github.com/rust-lang/rust/raw/2343a92a908901958c8207d6d0430a2e59ab0a9c/src%2Frt%2Frust_android_dummy.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_android_dummy.c?ref=2343a92a908901958c8207d6d0430a2e59ab0a9c", "patch": "@@ -1,112 +0,0 @@\n-// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#ifdef __ANDROID__\n-\n-#include \"rust_android_dummy.h\"\n-#include <math.h>\n-#include <errno.h>\n-\n-int backtrace(void **array, int size) { return 0; }\n-\n-char **backtrace_symbols(void *const *array, int size) { return 0; }\n-\n-void backtrace_symbols_fd (void *const *array, int size, int fd) {}\n-\n-volatile int* __errno_location() {\n-    return &errno;\n-}\n-\n-float log2f(float f)\n-{\n-    return logf( f ) / logf( 2 );\n-}\n-\n-double log2( double n )\n-{\n-    return log( n ) / log( 2 );\n-}\n-\n-double exp10( double x )\n-{\n-    return pow( 10, x );\n-}\n-\n-void telldir()\n-{\n-}\n-\n-void seekdir()\n-{\n-}\n-\n-void mkfifo()\n-{\n-}\n-\n-void abs()\n-{\n-}\n-\n-void labs()\n-{\n-}\n-\n-void rand()\n-{\n-}\n-\n-void srand()\n-{\n-}\n-\n-void atof()\n-{\n-}\n-\n-int glob(const char *pattern,\n-                    int flags,\n-                    int (*errfunc) (const char *epath, int eerrno),\n-                    glob_t *pglob)\n-{\n-    return 0;\n-}\n-\n-void globfree(glob_t *pglob)\n-{\n-}\n-\n-int pthread_atfork(void (*prefork)(void),\n-                              void (*postfork_parent)(void),\n-                              void (*postfork_child)(void))\n-{\n-    return 0;\n-}\n-\n-int mlockall(int flags)\n-{\n-    return 0;\n-}\n-\n-int munlockall(void)\n-{\n-    return 0;\n-}\n-\n-int shm_open(const char *name, int oflag, mode_t mode)\n-{\n-    return 0;\n-}\n-\n-int shm_unlink(const char *name)\n-{\n-    return 0;\n-}\n-\n-int posix_madvise(void *addr, size_t len, int advice)\n-{\n-    return 0;\n-}\n-\n-#endif"}, {"sha": "c2168d785b995e0c0fe9284bc0b149367271895c", "filename": "src/rt/rust_builtin.c", "status": "removed", "additions": 0, "deletions": 470, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/2343a92a908901958c8207d6d0430a2e59ab0a9c/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/2343a92a908901958c8207d6d0430a2e59ab0a9c/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=2343a92a908901958c8207d6d0430a2e59ab0a9c", "patch": "@@ -1,470 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#if !defined(_WIN32)\n-\n-#include <stdint.h>\n-#include <time.h>\n-#include <string.h>\n-#include <assert.h>\n-#include <stdlib.h>\n-\n-\n-#include <dirent.h>\n-#include <pthread.h>\n-#include <signal.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <unistd.h>\n-\n-#ifdef __APPLE__\n-#include <TargetConditionals.h>\n-#include <mach/mach_time.h>\n-\n-#if !(TARGET_OS_IPHONE)\n-#include <crt_externs.h>\n-#endif\n-#endif\n-\n-char*\n-rust_list_dir_val(struct dirent* entry_ptr) {\n-    return entry_ptr->d_name;\n-}\n-\n-// Android's struct dirent does have d_type from the very beginning\n-// (android-3). _DIRENT_HAVE_D_TYPE is not defined all the way to android-21\n-// though...\n-#if defined(__ANDROID__)\n-# define _DIRENT_HAVE_D_TYPE\n-#endif\n-\n-int\n-rust_dir_get_mode(struct dirent* entry_ptr) {\n-#if defined(_DIRENT_HAVE_D_TYPE) || defined(__APPLE__)\n-    switch (entry_ptr->d_type) {\n-        case DT_BLK: return S_IFBLK;\n-        case DT_CHR: return S_IFCHR;\n-        case DT_FIFO: return S_IFIFO;\n-        case DT_LNK: return S_IFLNK;\n-        case DT_REG: return S_IFREG;\n-        case DT_SOCK: return S_IFSOCK;\n-        case DT_DIR: return S_IFDIR;\n-    }\n-#endif\n-    return -1;\n-}\n-\n-ino_t\n-rust_dir_get_ino(struct dirent* entry_ptr) {\n-    return entry_ptr->d_ino;\n-}\n-\n-DIR*\n-rust_opendir(char *dirname) {\n-    return opendir(dirname);\n-}\n-\n-int\n-rust_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result) {\n-    return readdir_r(dirp, entry, result);\n-}\n-\n-size_t\n-rust_dirent_t_size() {\n-    return sizeof(struct dirent);\n-}\n-\n-#if defined(__BSD__)\n-static int\n-get_num_cpus() {\n-    /* swiped from http://stackoverflow.com/questions/150355/\n-       programmatically-find-the-number-of-cores-on-a-machine */\n-\n-    unsigned int numCPU;\n-    int mib[4];\n-    size_t len = sizeof(numCPU);\n-\n-    /* set the mib for hw.ncpu */\n-    mib[0] = CTL_HW;\n-    mib[1] = HW_AVAILCPU;  // alternatively, try HW_NCPU;\n-\n-    /* get the number of CPUs from the system */\n-    sysctl(mib, 2, &numCPU, &len, NULL, 0);\n-\n-    if( numCPU < 1 ) {\n-        mib[1] = HW_NCPU;\n-        sysctl( mib, 2, &numCPU, &len, NULL, 0 );\n-\n-        if( numCPU < 1 ) {\n-            numCPU = 1;\n-        }\n-    }\n-    return numCPU;\n-}\n-#elif defined(__GNUC__)\n-static int\n-get_num_cpus() {\n-    return sysconf(_SC_NPROCESSORS_ONLN);\n-}\n-#endif\n-\n-uintptr_t\n-rust_get_num_cpus() {\n-    return get_num_cpus();\n-}\n-\n-#if defined(__DragonFly__)\n-#include <errno.h>\n-// In DragonFly __error() is an inline function and as such\n-// no symbol exists for it.\n-int *__dfly_error(void) { return __error(); }\n-#endif\n-\n-#if defined(__Bitrig__)\n-#include <stdio.h>\n-#include <sys/param.h>\n-#include <sys/sysctl.h>\n-#include <limits.h>\n-\n-int rust_get_path(void *p, size_t* sz)\n-{\n-  int mib[4];\n-  char *eq = NULL;\n-  char *key = NULL;\n-  char *val = NULL;\n-  char **menv = NULL;\n-  size_t maxlen, len;\n-  int nenv = 0;\n-  int i;\n-\n-  if ((p == NULL) && (sz == NULL))\n-    return -1;\n-\n-  /* get the argv array */\n-  mib[0] = CTL_KERN;\n-  mib[1] = KERN_PROC_ARGS;\n-  mib[2] = getpid();\n-  mib[3] = KERN_PROC_ENV;\n-\n-  /* get the number of bytes needed to get the env */\n-  maxlen = 0;\n-  if (sysctl(mib, 4, NULL, &maxlen, NULL, 0) == -1)\n-    return -1;\n-\n-  /* allocate the buffer */\n-  if ((menv = calloc(maxlen, sizeof(char))) == NULL)\n-    return -1;\n-\n-  /* get the env array */\n-  if (sysctl(mib, 4, menv, &maxlen, NULL, 0) == -1)\n-  {\n-    free(menv);\n-    return -1;\n-  }\n-\n-  mib[3] = KERN_PROC_NENV;\n-  len = sizeof(int);\n-  /* get the length of env array */\n-  if (sysctl(mib, 4, &nenv, &len, NULL, 0) == -1)\n-  {\n-    free(menv);\n-    return -1;\n-  }\n-\n-  /* find _ key and resolve the value */\n-  for (i = 0; i < nenv; i++)\n-  {\n-    if ((eq = strstr(menv[i], \"=\")) == NULL)\n-      continue;\n-\n-    key = menv[i];\n-    val = eq + 1;\n-    *eq = '\\0';\n-\n-    if (strncmp(key, \"PATH\", maxlen) != 0)\n-      continue;\n-\n-    if (p == NULL)\n-    {\n-      /* return the length of the value + NUL */\n-      *sz = strnlen(val, maxlen) + 1;\n-      free(menv);\n-      return 0;\n-    }\n-    else\n-    {\n-      /* copy *sz bytes to the output buffer */\n-      memcpy(p, val, *sz);\n-      free(menv);\n-      return 0;\n-    }\n-  }\n-\n-  free(menv);\n-  return -1;\n-}\n-\n-int rust_get_path_array(void * p, size_t * sz)\n-{\n-  char *path, *str;\n-  char **buf;\n-  int i, num;\n-  size_t len;\n-\n-  if ((p == NULL) && (sz == NULL))\n-    return -1;\n-\n-  /* get the length of the PATH value */\n-  if (rust_get_path(NULL, &len) == -1)\n-    return -1;\n-\n-  if (len == 0)\n-    return -1;\n-\n-  /* allocate the buffer */\n-  if ((path = calloc(len, sizeof(char))) == NULL)\n-    return -1;\n-\n-  /* get the PATH value */\n-  if (rust_get_path(path, &len) == -1)\n-  {\n-    free(path);\n-    return -1;\n-  }\n-\n-  /* count the number of parts in the PATH */\n-  num = 1;\n-  for(str = path; *str != '\\0'; str++)\n-  {\n-    if (*str == ':')\n-      num++;\n-  }\n-\n-  /* calculate the size of the buffer for the 2D array */\n-  len = (num * sizeof(char*) + 1) + strlen(path) + 1;\n-\n-  if (p == NULL)\n-  {\n-    free(path);\n-    *sz = len;\n-    return 0;\n-  }\n-\n-  /* make sure we have enough buffer space */\n-  if (*sz < len)\n-  {\n-    free(path);\n-    return -1;\n-  }\n-\n-  /* zero out the buffer */\n-  buf = (char**)p;\n-  memset(buf, 0, *sz);\n-\n-  /* copy the data into the right place */\n-  str = p + ((num+1) * sizeof(char*));\n-  memcpy(str, path, strlen(path));\n-\n-  /* parse the path into it's parts */\n-  for (i = 0; i < num && (buf[i] = strsep(&str, \":\")) != NULL; i++) {;}\n-  buf[num] = NULL;\n-\n-  free(path);\n-  return 0;\n-}\n-\n-int rust_get_argv_zero(void* p, size_t* sz)\n-{\n-  int mib[4];\n-  char **argv = NULL;\n-  size_t len;\n-\n-  if ((p == NULL) && (sz == NULL))\n-    return -1;\n-\n-  /* get the argv array */\n-  mib[0] = CTL_KERN;\n-  mib[1] = KERN_PROC_ARGS;\n-  mib[2] = getpid();\n-  mib[3] = KERN_PROC_ARGV;\n-\n-  /* request KERN_PROC_ARGV size */\n-  len = 0;\n-  if (sysctl(mib, 4, NULL, &len, NULL, 0) == -1)\n-    return -1;\n-\n-  /* allocate buffer to receive the values */\n-  if ((argv = malloc(len)) == NULL)\n-    return -1;\n-\n-  /* get the argv array */\n-  if (sysctl(mib, 4, argv, &len, NULL, 0) == -1)\n-  {\n-    free(argv);\n-    return -1;\n-  }\n-\n-  /* get length of argv[0] */\n-  len = strnlen(argv[0], len) + 1;\n-\n-  if (p == NULL)\n-  {\n-    *sz = len;\n-    free(argv);\n-    return 0;\n-  }\n-\n-  if (*sz < len)\n-  {\n-    free(argv);\n-    return -1;\n-  }\n-\n-  memcpy(p, argv[0], len);\n-  free(argv);\n-  return 0;\n-}\n-\n-const char * rust_current_exe()\n-{\n-  static char *self = NULL;\n-  char *argv0;\n-  char **paths;\n-  size_t sz;\n-  int i;\n-  /* If `PATH_MAX` is defined on the platform, `realpath` will truncate the\n-   * resolved path up to `PATH_MAX`. While this can make the resolution fail if\n-   * the executable is placed in a deep path, the usage of a buffer whose\n-   * length depends on `PATH_MAX` is still memory safe. */\n-  char buf[2*PATH_MAX], exe[PATH_MAX];\n-\n-  if (self != NULL)\n-    return self;\n-\n-  if (rust_get_argv_zero(NULL, &sz) == -1)\n-    return NULL;\n-  if ((argv0 = calloc(sz, sizeof(char))) == NULL)\n-    return NULL;\n-  if (rust_get_argv_zero(argv0, &sz) == -1)\n-  {\n-    free(argv0);\n-    return NULL;\n-  }\n-\n-  /* if argv0 is a relative or absolute path, resolve it with realpath */\n-  if ((*argv0 == '.') || (*argv0 == '/') || (strstr(argv0, \"/\") != NULL))\n-  {\n-    self = realpath(argv0, NULL);\n-    free(argv0);\n-    return self;\n-  }\n-\n-  /* get the path array */\n-  if (rust_get_path_array(NULL, &sz) == -1)\n-  {\n-    free(argv0);\n-    return NULL;\n-  }\n-  if ((paths = calloc(sz, sizeof(char))) == NULL)\n-  {\n-    free(argv0);\n-    return NULL;\n-  }\n-  if (rust_get_path_array(paths, &sz) == -1)\n-  {\n-    free(argv0);\n-    free(paths);\n-    return NULL;\n-  }\n-\n-  for(i = 0; paths[i] != NULL; i++)\n-  {\n-    snprintf(buf, 2*PATH_MAX, \"%s/%s\", paths[i], argv0);\n-    if (realpath(buf, exe) == NULL)\n-      continue;\n-\n-    if (access(exe, F_OK | X_OK) == -1)\n-      continue;\n-\n-    self = strdup(exe);\n-    free(argv0);\n-    free(paths);\n-    return self;\n-  }\n-\n-  free(argv0);\n-  free(paths);\n-  return NULL;\n-}\n-\n-#elif defined(__OpenBSD__)\n-\n-#include <sys/param.h>\n-#include <sys/sysctl.h>\n-#include <limits.h>\n-\n-const char * rust_current_exe() {\n-    static char *self = NULL;\n-\n-    if (self == NULL) {\n-        int mib[4];\n-        char **argv = NULL;\n-        size_t argv_len;\n-\n-        /* initialize mib */\n-        mib[0] = CTL_KERN;\n-        mib[1] = KERN_PROC_ARGS;\n-        mib[2] = getpid();\n-        mib[3] = KERN_PROC_ARGV;\n-\n-        /* request KERN_PROC_ARGV size */\n-        argv_len = 0;\n-        if (sysctl(mib, 4, NULL, &argv_len, NULL, 0) == -1)\n-            return (NULL);\n-\n-        /* allocate size */\n-        if ((argv = malloc(argv_len)) == NULL)\n-            return (NULL);\n-\n-        /* request KERN_PROC_ARGV */\n-        if (sysctl(mib, 4, argv, &argv_len, NULL, 0) == -1) {\n-            free(argv);\n-            return (NULL);\n-        }\n-\n-        /* get realpath if possible */\n-        if ((argv[0] != NULL) && ((*argv[0] == '.') || (*argv[0] == '/')\n-                                || (strstr(argv[0], \"/\") != NULL)))\n-\n-            self = realpath(argv[0], NULL);\n-        else\n-            self = NULL;\n-\n-        /* cleanup */\n-        free(argv);\n-    }\n-\n-    return (self);\n-}\n-\n-#endif\n-\n-#endif // !defined(_WIN32)\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}]}