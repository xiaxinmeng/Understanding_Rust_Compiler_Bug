{"sha": "ab9c900131d8224bc105fbeb0795a0f7001a0836", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiOWM5MDAxMzFkODIyNGJjMTA1ZmJlYjA3OTVhMGY3MDAxYTA4MzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-13T04:39:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-13T04:39:01Z"}, "message": "Merge pull request #2576 from mozilla/incoming\n\nIncoming", "tree": {"sha": "14736810303f5f51739215cc59beabdf11bfb8a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14736810303f5f51739215cc59beabdf11bfb8a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab9c900131d8224bc105fbeb0795a0f7001a0836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9c900131d8224bc105fbeb0795a0f7001a0836", "html_url": "https://github.com/rust-lang/rust/commit/ab9c900131d8224bc105fbeb0795a0f7001a0836", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab9c900131d8224bc105fbeb0795a0f7001a0836/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07bba397c5b46c96cfb8de23c34b9bae47e07947", "url": "https://api.github.com/repos/rust-lang/rust/commits/07bba397c5b46c96cfb8de23c34b9bae47e07947", "html_url": "https://github.com/rust-lang/rust/commit/07bba397c5b46c96cfb8de23c34b9bae47e07947"}, {"sha": "11e30b2a7367e9820c26eb3f9e12d985f74f3a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/11e30b2a7367e9820c26eb3f9e12d985f74f3a0f", "html_url": "https://github.com/rust-lang/rust/commit/11e30b2a7367e9820c26eb3f9e12d985f74f3a0f"}], "stats": {"total": 1569, "additions": 988, "deletions": 581}, "files": [{"sha": "0853e56e3cbeb1f57e7839119b0121c1937be571", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -78,3 +78,4 @@ x86_64-apple-darwin/\n doc/core/\n tmp.*.rs\n config.stamp\n+.DS_Store"}, {"sha": "2bfde838bce4387f4a330457d9eb30b7864a0181", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -9,11 +9,9 @@ import syntax::diagnostic;\n \n import result::{ok, err};\n import io::writer_util;\n-import result;\n import std::{map, json, tempfile, term, sort, getopts};\n import map::hashmap;\n-import str;\n-import vec;\n+import json::to_str;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n@@ -399,28 +397,28 @@ fn parse_source(name: str, j: json::json) -> source {\n     }\n \n     alt j {\n-        json::dict(_j) {\n-            let mut url = alt _j.find(\"url\") {\n+        json::dict(j) {\n+            let mut url = alt j.find(\"url\") {\n                 some(json::string(u)) {\n-                    u\n+                    *u\n                 }\n                 _ { fail \"needed 'url' field in source\"; }\n             };\n-            let method = alt _j.find(\"method\") {\n+            let method = alt j.find(\"method\") {\n                 some(json::string(u)) {\n-                    u\n+                    *u\n                 }\n                 _ { assume_source_method(url) }\n             };\n-            let key = alt _j.find(\"key\") {\n+            let key = alt j.find(\"key\") {\n                 some(json::string(u)) {\n-                    some(u)\n+                    some(*u)\n                 }\n                 _ { none }\n             };\n-            let keyfp = alt _j.find(\"keyfp\") {\n+            let keyfp = alt j.find(\"keyfp\") {\n                 some(json::string(u)) {\n-                    some(u)\n+                    some(*u)\n                 }\n                 _ { none }\n             };\n@@ -450,20 +448,20 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n             }\n         }\n         ok(_) { fail \"malformed sources.json\"; }\n-        err(e) { fail #fmt(\"%s:%u:%u: %s\", filename, e.line, e.col, e.msg); }\n+        err(e) { fail #fmt(\"%s:%s\", filename, e.to_str()); }\n     }\n }\n \n fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n-        some(json::string(_n)) {\n-            if !valid_pkg_name(_n) {\n-                warn(\"malformed source json: \" + src.name + \", '\" + _n + \"'\"+\n+        some(json::string(n)) {\n+            if !valid_pkg_name(*n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + *n + \"'\"+\n                      \" is an invalid name (alphanumeric, underscores and\" +\n                      \" dashes only)\");\n                 ret;\n             }\n-            _n\n+            *n\n         }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing name)\");\n@@ -472,13 +470,13 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     };\n \n     let uuid = alt p.find(\"uuid\") {\n-        some(json::string(_n)) {\n-            if !is_uuid(_n) {\n-                warn(\"malformed source json: \" + src.name + \", '\" + _n + \"'\"+\n+        some(json::string(n)) {\n+            if !is_uuid(*n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + *n + \"'\"+\n                      \" is an invalid uuid\");\n                 ret;\n             }\n-            _n\n+            *n\n         }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing uuid)\");\n@@ -487,32 +485,32 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     };\n \n     let url = alt p.find(\"url\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(n)) { *n }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing url)\");\n             ret;\n         }\n     };\n \n     let method = alt p.find(\"method\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(n)) { *n }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing method)\");\n             ret;\n         }\n     };\n \n     let ref = alt p.find(\"ref\") {\n-        some(json::string(_n)) { some(_n) }\n+        some(json::string(n)) { some(*n) }\n         _ { none }\n     };\n \n     let mut tags = [];\n     alt p.find(\"tags\") {\n         some(json::list(js)) {\n-            for js.each {|j|\n+            for (*js).each {|j|\n                 alt j {\n-                    json::string(_j) { vec::grow(tags, 1u, _j); }\n+                    json::string(j) { vec::grow(tags, 1u, *j); }\n                     _ { }\n                 }\n             }\n@@ -521,7 +519,7 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     }\n \n     let description = alt p.find(\"description\") {\n-        some(json::string(_n)) { _n }\n+        some(json::string(n)) { *n }\n         _ {\n             warn(\"malformed source json: \" + src.name\n                  + \" (missing description)\");\n@@ -570,7 +568,7 @@ fn load_source_info(c: cargo, src: source) {\n                  \"(source info is not a dict)\");\n         }\n         err(e) {\n-            warn(#fmt(\"%s:%u:%u: %s\", src.name, e.line, e.col, e.msg));\n+            warn(#fmt(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n@@ -582,10 +580,10 @@ fn load_source_packages(c: cargo, src: source) {\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) {\n-            for js.each {|_j|\n-                alt _j {\n-                    json::dict(_p) {\n-                        load_one_source_package(src, _p);\n+            for (*js).each {|j|\n+                alt j {\n+                    json::dict(p) {\n+                        load_one_source_package(src, p);\n                     }\n                     _ {\n                         warn(\"malformed source json: \" + src.name +\n@@ -599,7 +597,7 @@ fn load_source_packages(c: cargo, src: source) {\n                  \"(packages is not a list)\");\n         }\n         err(e) {\n-            warn(#fmt(\"%s:%u:%u: %s\", src.name, e.line, e.col, e.msg));\n+            warn(#fmt(\"%s:%s\", src.name, e.to_str()));\n         }\n     };\n }\n@@ -766,8 +764,8 @@ fn install_one_crate(c: cargo, path: str, cf: str) {\n \n fn rustc_sysroot() -> str {\n     alt os::self_exe_path() {\n-        some(_path) {\n-            let path = [_path, \"..\", \"bin\", \"rustc\"];\n+        some(path) {\n+            let path = [path, \"..\", \"bin\", \"rustc\"];\n             check vec::is_not_empty(path);\n             let rustc = path::normalize(path::connect_many(path));\n             #debug(\"  rustc: %s\", rustc);\n@@ -1578,18 +1576,18 @@ fn dump_sources(c: cargo) {\n                 let chash = map::str_hash();\n                 let child = json::dict(chash);\n \n-                chash.insert(\"url\", json::string(v.url));\n-                chash.insert(\"method\", json::string(v.method));\n+                chash.insert(\"url\", json::string(@v.url));\n+                chash.insert(\"method\", json::string(@v.method));\n \n                 alt copy v.key {\n                     some(key) {\n-                        chash.insert(\"key\", json::string(key));\n+                        chash.insert(\"key\", json::string(@key));\n                     }\n                     _ {}\n                 }\n                 alt copy v.keyfp {\n                     some(keyfp) {\n-                        chash.insert(\"keyfp\", json::string(keyfp));\n+                        chash.insert(\"keyfp\", json::string(@keyfp));\n                     }\n                     _ {}\n                 }"}, {"sha": "b1d1457654e22b6f35c26c839b2d9c99a0937c20", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -16,21 +16,21 @@ export ord, eq, num;\n const min_value: T = -1 as T << (inst::bits - 1 as T);\n const max_value: T = min_value - 1 as T;\n \n-pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n-pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n-\n-pure fn add(x: T, y: T) -> T { x + y }\n-pure fn sub(x: T, y: T) -> T { x - y }\n-pure fn mul(x: T, y: T) -> T { x * y }\n-pure fn div(x: T, y: T) -> T { x / y }\n-pure fn rem(x: T, y: T) -> T { x % y }\n-\n-pure fn lt(x: T, y: T) -> bool { x < y }\n-pure fn le(x: T, y: T) -> bool { x <= y }\n-pure fn eq(x: T, y: T) -> bool { x == y }\n-pure fn ne(x: T, y: T) -> bool { x != y }\n-pure fn ge(x: T, y: T) -> bool { x >= y }\n-pure fn gt(x: T, y: T) -> bool { x > y }\n+pure fn min(&&x: T, &&y: T) -> T { if x < y { x } else { y } }\n+pure fn max(&&x: T, &&y: T) -> T { if x > y { x } else { y } }\n+\n+pure fn add(&&x: T, &&y: T) -> T { x + y }\n+pure fn sub(&&x: T, &&y: T) -> T { x - y }\n+pure fn mul(&&x: T, &&y: T) -> T { x * y }\n+pure fn div(&&x: T, &&y: T) -> T { x / y }\n+pure fn rem(&&x: T, &&y: T) -> T { x % y }\n+\n+pure fn lt(&&x: T, &&y: T) -> bool { x < y }\n+pure fn le(&&x: T, &&y: T) -> bool { x <= y }\n+pure fn eq(&&x: T, &&y: T) -> bool { x == y }\n+pure fn ne(&&x: T, &&y: T) -> bool { x != y }\n+pure fn ge(&&x: T, &&y: T) -> bool { x >= y }\n+pure fn gt(&&x: T, &&y: T) -> bool { x > y }\n \n pure fn is_positive(x: T) -> bool { x > 0 as T }\n pure fn is_negative(x: T) -> bool { x < 0 as T }"}, {"sha": "d28333c79e63d62ce087362280364e6106ec4da6", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -7,7 +7,7 @@ const bits: T = 32 as T;\n const bits: T = 64 as T;\n \n #[doc = \"Produce a uint suitable for use in a hash table\"]\n-pure fn hash(x: int) -> uint { ret x as uint; }\n+pure fn hash(&&x: int) -> uint { ret x as uint; }\n \n #[doc = \"Returns `base` raised to the power of `exponent`\"]\n fn pow(base: int, exponent: uint) -> int {"}, {"sha": "cf81dcd7157fff9a3632f6baea58bd14874d7aaa", "filename": "src/libcore/str.rs", "status": "modified", "additions": 104, "deletions": 99, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -222,7 +222,7 @@ pure fn from_char(ch: char) -> str {\n }\n \n #[doc = \"Convert a vector of chars to a string\"]\n-pure fn from_chars(chs: [char]) -> str {\n+pure fn from_chars(chs: [const char]/&) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, chs.len());\n@@ -232,7 +232,7 @@ pure fn from_chars(chs: [char]) -> str {\n }\n \n #[doc = \"Concatenate a vector of strings\"]\n-pure fn concat(v: [str]) -> str {\n+pure fn concat(v: [const str]/&) -> str {\n     let mut s: str = \"\";\n     for vec::each(v) {|ss| s += ss; }\n     ret s;\n@@ -241,7 +241,7 @@ pure fn concat(v: [str]) -> str {\n #[doc = \"\n Concatenate a vector of strings, placing a given separator between each\n \"]\n-pure fn connect(v: [str], sep: str) -> str {\n+pure fn connect(v: [const str]/&a, sep: str) -> str {\n     let mut s = \"\", first = true;\n     for vec::each(v) {|ss|\n         if first { first = false; } else { s += sep; }\n@@ -338,7 +338,7 @@ pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n }\n \n #[doc = \"Convert a string to a vector of characters\"]\n-pure fn chars(s: str) -> [char] {\n+pure fn chars(s: str/&) -> [char] {\n     let mut buf = [], i = 0u;\n     let len = len(s);\n     while i < len {\n@@ -355,7 +355,7 @@ Take a substring of another.\n Returns a string containing `n` characters starting at byte offset\n `begin`.\n \"]\n-pure fn substr(s: str, begin: uint, n: uint) -> str {\n+pure fn substr(s: str/&, begin: uint, n: uint) -> str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -365,7 +365,7 @@ Returns a slice of the given string from the byte range [`begin`..`end`)\n Fails when `begin` and `end` do not point to valid characters or\n beyond the last character of the string\n \"]\n-pure fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n+pure fn slice(s: str/&, begin: uint, end: uint) -> str unsafe {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe::slice_bytes(s, begin, end)\n@@ -374,7 +374,7 @@ pure fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n #[doc = \"\n Splits a string into substrings at each occurrence of a given character\n \"]\n-pure fn split_char(s: str, sep: char) -> [str] {\n+pure fn split_char(s: str/&, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -384,18 +384,18 @@ character up to 'count' times\n \n The byte must be a valid UTF-8/ASCII byte\n \"]\n-pure fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n+pure fn splitn_char(s: str/&, sep: char, count: uint) -> [str] {\n     split_char_inner(s, sep, count, true)\n }\n \n #[doc = \"\n Like `split_char`, but omits empty strings from the returned vector\n \"]\n-pure fn split_char_nonempty(s: str, sep: char) -> [str] {\n+pure fn split_char_nonempty(s: str/&, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n-pure fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n+pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n     -> [str] unsafe {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n@@ -422,24 +422,24 @@ pure fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n \n \n #[doc = \"Splits a string into substrings using a character function\"]\n-pure fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n #[doc = \"\n Splits a string into substrings using a character function, cutting at\n most `count` times.\n \"]\n-pure fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n+pure fn splitn(s: str/&, sepfn: fn(char) -> bool, count: uint) -> [str] {\n     split_inner(s, sepfn, count, true)\n }\n \n #[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n-pure fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-pure fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n+pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> [str] unsafe {\n     let l = len(s);\n     let mut result = [], i = 0u, start = 0u, done = 0u;\n@@ -461,7 +461,7 @@ pure fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -488,7 +488,7 @@ pure fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n     iter_matches(s, sep) {|from, to|\n         f(last_end, from);\n@@ -506,15 +506,15 @@ Splits a string into a vector of the substrings separated by a given string\n assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n ~~~\n \"]\n-pure fn split_str(s: str, sep: str) -> [str] {\n+pure fn split_str(s: str/&a, sep: str/&b) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n     }\n     result\n }\n \n-pure fn split_str_nonempty(s: str, sep: str) -> [str] {\n+pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n@@ -527,13 +527,13 @@ pure fn split_str_nonempty(s: str, sep: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n \"]\n-pure fn lines(s: str) -> [str] { split_char(s, '\\n') }\n+pure fn lines(s: str/&) -> [str] { split_char(s, '\\n') }\n \n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n and/or CR LF ('\\\\r\\\\n')\n \"]\n-pure fn lines_any(s: str) -> [str] {\n+pure fn lines_any(s: str/&) -> [str] {\n     vec::map(lines(s), {|s|\n         let l = len(s);\n         let mut cp = s;\n@@ -547,19 +547,19 @@ pure fn lines_any(s: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by whitespace\n \"]\n-pure fn words(s: str) -> [str] {\n+pure fn words(s: str/&) -> [str] {\n     split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n #[doc = \"Convert a string to lowercase. ASCII only\"]\n-pure fn to_lower(s: str) -> str {\n+pure fn to_lower(s: str/&) -> str {\n     map(s, {|c|\n         unchecked{(libc::tolower(c as libc::c_char)) as char}\n     })\n }\n \n #[doc = \"Convert a string to uppercase. ASCII only\"]\n-pure fn to_upper(s: str) -> str {\n+pure fn to_upper(s: str/&) -> str {\n     map(s, {|c|\n         unchecked{(libc::toupper(c as libc::c_char)) as char}\n     })\n@@ -629,20 +629,20 @@ Section: Iterating through strings\n Return true if a predicate matches all characters or if the string\n contains no characters\n \"]\n-pure fn all(s: str, it: fn(char) -> bool) -> bool {\n+pure fn all(s: str/&, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n #[doc = \"\n Return true if a predicate matches any character (and false if it\n matches none or there are no characters)\n \"]\n-pure fn any(ss: str, pred: fn(char) -> bool) -> bool {\n+pure fn any(ss: str/&, pred: fn(char) -> bool) -> bool {\n     !all(ss, {|cc| !pred(cc)})\n }\n \n #[doc = \"Apply a function to each character\"]\n-pure fn map(ss: str, ff: fn(char) -> char) -> str {\n+pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n     unchecked {\n         reserve(result, len(ss));\n@@ -654,7 +654,7 @@ pure fn map(ss: str, ff: fn(char) -> char) -> str {\n }\n \n #[doc = \"Iterate over the bytes in a string\"]\n-pure fn bytes_iter(ss: str, it: fn(u8)) {\n+pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -666,7 +666,7 @@ pure fn bytes_iter(ss: str, it: fn(u8)) {\n \n #[doc = \"Iterate over the bytes in a string\"]\n #[inline(always)]\n-pure fn each(s: str, it: fn(u8) -> bool) {\n+pure fn each(s: str/&, it: fn(u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(s[i]) { break; }\n@@ -676,7 +676,7 @@ pure fn each(s: str, it: fn(u8) -> bool) {\n \n #[doc = \"Iterates over the chars in a string\"]\n #[inline(always)]\n-pure fn each_char(s: str, it: fn(char) -> bool) {\n+pure fn each_char(s: str/&, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -687,7 +687,7 @@ pure fn each_char(s: str, it: fn(char) -> bool) {\n }\n \n #[doc = \"Iterate over the characters in a string\"]\n-pure fn chars_iter(s: str, it: fn(char)) {\n+pure fn chars_iter(s: str/&, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -700,26 +700,26 @@ pure fn chars_iter(s: str, it: fn(char)) {\n #[doc = \"\n Apply a function to each substring after splitting by character\n \"]\n-pure fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n+pure fn split_char_iter(ss: str/&, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n #[doc = \"\n Apply a function to each substring after splitting by character, up to\n `count` times\n \"]\n-pure fn splitn_char_iter(ss: str, sep: char, count: uint,\n+pure fn splitn_char_iter(ss: str/&, sep: char, count: uint,\n                          ff: fn(&&str)) unsafe {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n #[doc = \"Apply a function to each word\"]\n-pure fn words_iter(ss: str, ff: fn(&&str)) {\n+pure fn words_iter(ss: str/&, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n #[doc = \"Apply a function to each line (by '\\\\n')\"]\n-pure fn lines_iter(ss: str, ff: fn(&&str)) {\n+pure fn lines_iter(ss: str/&, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n \n@@ -740,7 +740,7 @@ Returns the byte index of the first matching character\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-pure fn find_char(s: str, c: char) -> option<uint> {\n+pure fn find_char(s: str/&, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -764,7 +764,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn find_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -789,7 +789,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-pure fn find_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -819,7 +819,7 @@ Returns the byte index of the last matching character\n An `option` containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-pure fn rfind_char(s: str, c: char) -> option<uint> {\n+pure fn rfind_char(s: str/&, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -843,7 +843,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be\n the index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn rfind_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -868,7 +868,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-pure fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -899,7 +899,7 @@ the given predicate\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-pure fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn find(s: str/&, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -923,7 +923,8 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn find_from(s: str/&, start: uint, f: fn(char)\n+    -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n@@ -949,7 +950,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn find_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -977,7 +978,7 @@ the given predicate\n An option containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-pure fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind(s: str/&, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1001,7 +1002,8 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)', `start` must be the\n index of a character boundary, as defined by `is_char_boundary`\n \"]\n-pure fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind_from(s: str/&, start: uint, f: fn(char) -> bool)\n+    -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1027,7 +1029,7 @@ or `none` if there is no match\n than or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`\n \"]\n-pure fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn rfind_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1042,7 +1044,7 @@ pure fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n }\n \n // Utility used by various searching functions\n-pure fn match_at(haystack: str, needle: str, at: uint) -> bool {\n+pure fn match_at(haystack: str/&a, needle: str/&b, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) {|c| if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n@@ -1061,7 +1063,7 @@ Returns the byte index of the first matching substring\n An `option` containing the byte index of the first matching substring\n or `none` if there is no match\n \"]\n-pure fn find_str(haystack: str, needle: str) -> option<uint> {\n+pure fn find_str(haystack: str/&a, needle: str/&b) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1084,7 +1086,7 @@ or `none` if there is no match\n \n `start` must be less than or equal to `len(s)`\n \"]\n-pure fn find_str_from(haystack: str, needle: str, start: uint)\n+pure fn find_str_from(haystack: str/&a, needle: str/&b, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1109,7 +1111,8 @@ or `none` if there is no match\n `start` must be less than or equal to `end` and `end` must be less than\n or equal to `len(s)`.\n \"]\n-pure fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n+pure fn find_str_between(haystack: str/&a, needle: str/&b, start: uint,\n+                         end:uint)\n   -> option<uint> {\n     // See Issue #1932 for why this is a naive search\n     assert end <= len(haystack);\n@@ -1134,7 +1137,7 @@ Returns true if one string contains another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn contains(haystack: str, needle: str) -> bool {\n+pure fn contains(haystack: str/&a, needle: str/&b) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n@@ -1146,7 +1149,7 @@ Returns true if one string starts with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn starts_with(haystack: str, needle: str) -> bool unsafe {\n+pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool unsafe {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1161,7 +1164,7 @@ Returns true if one string ends with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn ends_with(haystack: str, needle: str) -> bool {\n+pure fn ends_with(haystack: str/&a, needle: str/&b) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1173,24 +1176,24 @@ Section: String properties\n */\n \n #[doc = \"Determines if a string contains only ASCII characters\"]\n-pure fn is_ascii(s: str) -> bool {\n+pure fn is_ascii(s: str/&) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n \n #[doc = \"Returns true if the string has length 0\"]\n-pure fn is_empty(s: str) -> bool { len(s) == 0u }\n+pure fn is_empty(s: str/&) -> bool { len(s) == 0u }\n \n #[doc = \"Returns true if the string has length greater than 0\"]\n-pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n+pure fn is_not_empty(s: str/&) -> bool { !is_empty(s) }\n \n #[doc = \"\n Returns true if the string contains only whitespace\n \n Whitespace characters are determined by `char::is_whitespace`\n \"]\n-pure fn is_whitespace(s: str) -> bool {\n+pure fn is_whitespace(s: str/&) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n@@ -1199,27 +1202,26 @@ Returns true if the string contains only alphanumerics\n \n Alphanumeric characters are determined by `char::is_alphanumeric`\n \"]\n-fn is_alphanumeric(s: str) -> bool {\n+fn is_alphanumeric(s: str/&) -> bool {\n     ret all(s, char::is_alphanumeric);\n }\n \n #[doc = \"\n Returns the string length/size in bytes not counting the null terminator\n \"]\n-pure fn len(s: str) -> uint unsafe {\n-    let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(s);\n-    (*repr).fill - 1u\n+pure fn len(s: str/&) -> uint {\n+    unpack_slice(s) { |_p, n| n - 1u }\n }\n \n #[doc = \"Returns the number of characters that a string holds\"]\n-pure fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n+pure fn char_len(s: str/&) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n #[doc = \"Determines if a vector of bytes contains valid UTF-8\"]\n-pure fn is_utf8(v: [const u8]) -> bool {\n+pure fn is_utf8(v: [const u8]/&) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1237,7 +1239,7 @@ pure fn is_utf8(v: [const u8]) -> bool {\n }\n \n #[doc = \"Determines if a vector of `u16` contains valid UTF-16\"]\n-pure fn is_utf16(v: [const u16]) -> bool {\n+pure fn is_utf16(v: [const u16]/&) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1258,7 +1260,7 @@ pure fn is_utf16(v: [const u16]) -> bool {\n }\n \n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n-pure fn to_utf16(s: str) -> [u16] {\n+pure fn to_utf16(s: str/&) -> [u16] {\n     let mut u = [];\n     chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1280,7 +1282,7 @@ pure fn to_utf16(s: str) -> [u16] {\n     ret u;\n }\n \n-pure fn utf16_chars(v: [const u16], f: fn(char)) {\n+pure fn utf16_chars(v: [const u16]/&, f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1305,7 +1307,7 @@ pure fn utf16_chars(v: [const u16], f: fn(char)) {\n }\n \n \n-pure fn from_utf16(v: [const u16]) -> str {\n+pure fn from_utf16(v: [const u16]/&) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, vec::len(v));\n@@ -1328,7 +1330,7 @@ As char_len but for a slice of a string\n \n The number of Unicode characters in `s` between the given indices.\n \"]\n-pure fn count_chars(s: str, start: uint, end: uint) -> uint {\n+pure fn count_chars(s: str/&, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1343,7 +1345,7 @@ pure fn count_chars(s: str, start: uint, end: uint) -> uint {\n #[doc = \"\n Counts the number of bytes taken by the `n` in `s` starting from `start`.\n \"]\n-pure fn count_bytes(s: str, start: uint, n: uint) -> uint {\n+pure fn count_bytes(s: str/&b, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1375,7 +1377,7 @@ pure fn utf8_char_width(b: u8) -> uint {\n Returns false if the index points into the middle of a multi-byte\n character sequence.\n \"]\n-pure fn is_char_boundary(s: str, index: uint) -> bool {\n+pure fn is_char_boundary(s: str/&, index: uint) -> bool {\n     if index == len(s) { ret true; }\n     let b = s[index];\n     ret b < 128u8 || b >= 192u8;\n@@ -1428,7 +1430,7 @@ index of the next unicode character.\n If `i` is greater than or equal to the length of the string.\n If `i` is not the index of the beginning of a valid UTF-8 character.\n \"]\n-pure fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n+pure fn char_range_at(s: str/&, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1451,14 +1453,14 @@ pure fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n }\n \n #[doc = \"Pluck a character out of a string\"]\n-pure fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+pure fn char_at(s: str/&, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n #[doc = \"\n Given a byte position and a str, return the previous char and its position\n \n This function can be used to iterate over a unicode string in reverse.\n \"]\n-pure fn char_range_at_reverse(ss: str, start: uint)\n+pure fn char_range_at_reverse(ss: str/&, start: uint)\n     -> {ch: char, prev: uint} {\n \n     let mut prev = start;\n@@ -1497,7 +1499,7 @@ Loop through a substring, char by char\n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n \"]\n-pure fn all_between(s: str, start: uint, end: uint,\n+pure fn all_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n@@ -1530,7 +1532,7 @@ Loop through a substring, char by char\n \n `true` if `it` returns `true` for any character\n \"]\n-pure fn any_between(s: str, start: uint, end: uint,\n+pure fn any_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, {|c| !it(c)})\n }\n@@ -1668,7 +1670,7 @@ pure fn capacity(&&s: str) -> uint unsafe {\n }\n \n #[doc = \"Escape each char in `s` with char::escape_default.\"]\n-pure fn escape_default(s: str) -> str {\n+pure fn escape_default(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n@@ -1678,7 +1680,7 @@ pure fn escape_default(s: str) -> str {\n }\n \n #[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n-pure fn escape_unicode(s: str) -> str {\n+pure fn escape_unicode(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n@@ -1762,22 +1764,21 @@ mod unsafe {\n    If begin is greater than end.\n    If end is greater than the length of the string.\n    \"]\n-   unsafe fn slice_bytes(s: str, begin: uint, end: uint) -> str unsafe {\n-       assert (begin <= end);\n-       assert (end <= len(s));\n+   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str unsafe {\n+       unpack_slice(s) { |sbuf, n|\n+           assert (begin <= end);\n+           assert (end <= n);\n \n-       let mut v = as_buf(s) { |sbuf|\n            let mut v = [];\n            vec::reserve(v, end - begin + 1u);\n            vec::as_buf(v) { |vbuf|\n                let src = ptr::offset(sbuf, begin);\n                ptr::memcpy(vbuf, src, end - begin);\n            }\n            vec::unsafe::set_len(v, end - begin);\n-           v\n-       };\n-       v += [0u8];\n-       ret ::unsafe::transmute(v);\n+           v += [0u8];\n+           ::unsafe::transmute(v)\n+       }\n    }\n \n    #[doc = \"Appends a byte to a string. (Not UTF-8 safe).\"]\n@@ -1834,6 +1835,19 @@ mod unsafe {\n \n #[doc = \"Extension methods for strings\"]\n impl extensions for str {\n+    #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n+    #[inline]\n+    fn trim() -> str { trim(self) }\n+    #[doc = \"Returns a string with leading whitespace removed\"]\n+    #[inline]\n+    fn trim_left() -> str { trim_left(self) }\n+    #[doc = \"Returns a string with trailing whitespace removed\"]\n+    #[inline]\n+    fn trim_right() -> str { trim_right(self) }\n+}\n+\n+#[doc = \"Extension methods for strings\"]\n+impl extensions/& for str/& {\n     #[doc = \"\n     Return true if a predicate matches all characters or if the string\n     contains no characters\n@@ -1848,7 +1862,7 @@ impl extensions for str {\n     fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n     #[doc = \"Returns true if one string contains another\"]\n     #[inline]\n-    fn contains(needle: str) -> bool { contains(self, needle) }\n+    fn contains(needle: str/&a) -> bool { contains(self, needle) }\n     #[doc = \"Iterate over the bytes in a string\"]\n     #[inline]\n     fn each(it: fn(u8) -> bool) { each(self, it) }\n@@ -1857,7 +1871,7 @@ impl extensions for str {\n     fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n     #[doc = \"Returns true if one string ends with another\"]\n     #[inline]\n-    fn ends_with(needle: str) -> bool { ends_with(self, needle) }\n+    fn ends_with(needle: str/&) -> bool { ends_with(self, needle) }\n     #[doc = \"Returns true if the string has length 0\"]\n     #[inline]\n     fn is_empty() -> bool { is_empty(self) }\n@@ -1902,10 +1916,10 @@ impl extensions for str {\n     string\n     \"]\n     #[inline]\n-    fn split_str(sep: str) -> [str] { split_str(self, sep) }\n+    fn split_str(sep: str/&a) -> [str] { split_str(self, sep) }\n     #[doc = \"Returns true if one string starts with another\"]\n     #[inline]\n-    fn starts_with(needle: str) -> bool { starts_with(self, needle) }\n+    fn starts_with(needle: str/&a) -> bool { starts_with(self, needle) }\n     #[doc = \"\n     Take a substring of another.\n \n@@ -1920,15 +1934,6 @@ impl extensions for str {\n     #[doc = \"Convert a string to uppercase\"]\n     #[inline]\n     fn to_upper() -> str { to_upper(self) }\n-    #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n-    #[inline]\n-    fn trim() -> str { trim(self) }\n-    #[doc = \"Returns a string with leading whitespace removed\"]\n-    #[inline]\n-    fn trim_left() -> str { trim_left(self) }\n-    #[doc = \"Returns a string with trailing whitespace removed\"]\n-    #[inline]\n-    fn trim_right() -> str { trim_right(self) }\n     #[doc = \"Escape each char in `s` with char::escape_default.\"]\n     #[inline]\n     fn escape_default() -> str { escape_default(self) }\n@@ -2091,7 +2096,7 @@ mod tests {\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: str, sep: str, i: int, k: str) {\n+        fn t(s: str, sep: str/&a, i: int, k: str) {\n             let v = split_str(s, sep);\n             assert eq(v[i], k);\n         }"}, {"sha": "fda4253a688d4b46849bd06d610cec5976a41ea3", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -16,21 +16,21 @@ export ord, eq, num;\n const min_value: T = 0 as T;\n const max_value: T = 0 as T - 1 as T;\n \n-pure fn min(x: T, y: T) -> T { if x < y { x } else { y } }\n-pure fn max(x: T, y: T) -> T { if x > y { x } else { y } }\n-\n-pure fn add(x: T, y: T) -> T { x + y }\n-pure fn sub(x: T, y: T) -> T { x - y }\n-pure fn mul(x: T, y: T) -> T { x * y }\n-pure fn div(x: T, y: T) -> T { x / y }\n-pure fn rem(x: T, y: T) -> T { x % y }\n-\n-pure fn lt(x: T, y: T) -> bool { x < y }\n-pure fn le(x: T, y: T) -> bool { x <= y }\n-pure fn eq(x: T, y: T) -> bool { x == y }\n-pure fn ne(x: T, y: T) -> bool { x != y }\n-pure fn ge(x: T, y: T) -> bool { x >= y }\n-pure fn gt(x: T, y: T) -> bool { x > y }\n+pure fn min(&&x: T, &&y: T) -> T { if x < y { x } else { y } }\n+pure fn max(&&x: T, &&y: T) -> T { if x > y { x } else { y } }\n+\n+pure fn add(&&x: T, &&y: T) -> T { x + y }\n+pure fn sub(&&x: T, &&y: T) -> T { x - y }\n+pure fn mul(&&x: T, &&y: T) -> T { x * y }\n+pure fn div(&&x: T, &&y: T) -> T { x / y }\n+pure fn rem(&&x: T, &&y: T) -> T { x % y }\n+\n+pure fn lt(&&x: T, &&y: T) -> bool { x < y }\n+pure fn le(&&x: T, &&y: T) -> bool { x <= y }\n+pure fn eq(&&x: T, &&y: T) -> bool { x == y }\n+pure fn ne(&&x: T, &&y: T) -> bool { x != y }\n+pure fn ge(&&x: T, &&y: T) -> bool { x >= y }\n+pure fn gt(&&x: T, &&y: T) -> bool { x > y }\n \n pure fn is_positive(x: T) -> bool { x > 0 as T }\n pure fn is_negative(x: T) -> bool { x < 0 as T }"}, {"sha": "e1bb89c27c4e7288b1cf3e4044c09e00955d5d5e", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -54,7 +54,7 @@ is either `x/y` or `x/y + 1`.\n pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n \n #[doc = \"Produce a uint suitable for use in a hash table\"]\n-pure fn hash(x: uint) -> uint { ret x; }\n+pure fn hash(&&x: uint) -> uint { ret x; }\n \n #[doc = \"\n Iterate over the range [`lo`..`hi`), or stop when requested"}, {"sha": "7058f2202b9f01846a2296080395edb5b1d3df7c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -266,7 +266,7 @@ pure fn view<T: copy>(v: [T]/&, start: uint, end: uint) -> [T]/&a {\n #[doc = \"\n Split the vector `v` by applying each element against the predicate `f`.\n \"]\n-fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+fn split<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -289,7 +289,7 @@ fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n Split the vector `v` by applying each element against the predicate `f` up\n to `n` times.\n \"]\n-fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn splitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -315,7 +315,7 @@ fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f`.\n \"]\n-fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+fn rsplit<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -338,7 +338,7 @@ fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f` up to `n times.\n \"]\n-fn rsplitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -776,7 +776,7 @@ Convert two vectors to a vector of pairs\n Returns a vector of tuples, where the i-th tuple contains contains the\n i-th elements from each of the input vectors.\n \"]\n-pure fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n+pure fn zip<T: copy, U: copy>(v: [const T]/&, u: [const U]/&) -> [(T, U)] {\n     let mut zipped = [];\n     let sz = len(v);\n     let mut i = 0u;\n@@ -859,7 +859,7 @@ Iterates over a vector, with option to break\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn each<T>(v: [T]/&, f: fn(T) -> bool) unsafe {\n+pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n@@ -877,7 +877,7 @@ Iterates over a vector's elements and indices\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn eachi<T>(v: [T]/&, f: fn(uint, T) -> bool) unsafe {\n+pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n@@ -996,7 +996,7 @@ fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T unsafe {\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n-pure fn unpack_slice<T,U>(s: [T]/&,\n+pure fn unpack_slice<T,U>(s: [const T]/&,\n                           f: fn(*T, uint) -> U) -> U unsafe {\n     let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n@@ -1316,7 +1316,7 @@ mod u8 {\n //\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n-impl extensions/&<A> of iter::base_iter<A> for [A]/& {\n+impl extensions/&<A> of iter::base_iter<A> for [const A]/& {\n     fn each(blk: fn(A) -> bool) { each(self, blk) }\n     fn size_hint() -> option<uint> { some(len(self)) }\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n@@ -1328,7 +1328,7 @@ impl extensions/&<A> of iter::base_iter<A> for [A]/& {\n     fn contains(x: A) -> bool { iter::contains(self, x) }\n     fn count(x: A) -> uint { iter::count(self, x) }\n }\n-impl extensions/&<A:copy> for [A]/& {\n+impl extensions/&<A:copy> for [const A]/& {\n     fn filter_to_vec(pred: fn(A) -> bool) -> [A] {\n         iter::filter_to_vec(self, pred)\n     }"}, {"sha": "1ac6a5476597803be7cf5c85213f6757646456e8", "filename": "src/libstd/json.rs", "status": "modified", "additions": 123, "deletions": 104, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -28,48 +28,33 @@ export null;\n #[doc = \"Represents a json value\"]\n enum json {\n     num(float),\n-    string(str),\n+    string(@str),\n     boolean(bool),\n-    list([json]),\n-    dict(map::hashmap<str,json>),\n+    list(@[json]),\n+    dict(map::hashmap<str, json>),\n     null,\n }\n \n type error = {\n     line: uint,\n     col: uint,\n-    msg: str,\n+    msg: @str,\n };\n \n #[doc = \"Serializes a json value into a io::writer\"]\n fn to_writer(wr: io::writer, j: json) {\n     alt j {\n       num(n) { wr.write_str(float::to_str(n, 6u)); }\n       string(s) {\n-        wr.write_char('\"');\n-        let mut escaped = \"\";\n-        str::chars_iter(s) { |c|\n-            alt c {\n-              '\"' { escaped += \"\\\\\\\"\"; }\n-              '\\\\' { escaped += \"\\\\\\\\\"; }\n-              '\\x08' { escaped += \"\\\\b\"; }\n-              '\\x0c' { escaped += \"\\\\f\"; }\n-              '\\n' { escaped += \"\\\\n\"; }\n-              '\\r' { escaped += \"\\\\r\"; }\n-              '\\t' { escaped += \"\\\\t\"; }\n-              _ { escaped += str::from_char(c); }\n-            }\n-        };\n-        wr.write_str(escaped);\n-        wr.write_char('\"');\n+        wr.write_str(escape_str(*s));\n       }\n       boolean(b) {\n         wr.write_str(if b { \"true\" } else { \"false\" });\n       }\n       list(v) {\n         wr.write_char('[');\n         let mut first = true;\n-        vec::iter(v) { |item|\n+        for (*v).each { |item|\n             if !first {\n                 wr.write_str(\", \");\n             }\n@@ -91,7 +76,7 @@ fn to_writer(wr: io::writer, j: json) {\n                 wr.write_str(\", \");\n             }\n             first = false;\n-            to_writer(wr, string(key));\n+            wr.write_str(escape_str(key));\n             wr.write_str(\": \");\n             to_writer(wr, value);\n         };\n@@ -103,6 +88,26 @@ fn to_writer(wr: io::writer, j: json) {\n     }\n }\n \n+fn escape_str(s: str) -> str {\n+    let mut escaped = \"\\\"\";\n+    str::chars_iter(s) { |c|\n+        alt c {\n+          '\"' { escaped += \"\\\\\\\"\"; }\n+          '\\\\' { escaped += \"\\\\\\\\\"; }\n+          '\\x08' { escaped += \"\\\\b\"; }\n+          '\\x0c' { escaped += \"\\\\f\"; }\n+          '\\n' { escaped += \"\\\\n\"; }\n+          '\\r' { escaped += \"\\\\r\"; }\n+          '\\t' { escaped += \"\\\\t\"; }\n+          _ { escaped += str::from_char(c); }\n+        }\n+    };\n+\n+    escaped += \"\\\"\";\n+\n+    escaped\n+}\n+\n #[doc = \"Serializes a json value into a string\"]\n fn to_str(j: json) -> str {\n     io::with_str_writer { |wr| to_writer(wr, j) }\n@@ -134,8 +139,8 @@ impl parser for parser {\n         self.ch\n     }\n \n-    fn error<T>(msg: str) -> result<T, error> {\n-        err({ line: self.line, col: self.col, msg: msg })\n+    fn error<T>(+msg: str) -> result<T, error> {\n+        err({ line: self.line, col: self.col, msg: @msg })\n     }\n \n     fn parse() -> result<json, error> {\n@@ -318,7 +323,7 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_str() -> result<str, error> {\n+    fn parse_str() -> result<@str, error> {\n         let mut escape = false;\n         let mut res = \"\";\n \n@@ -365,7 +370,7 @@ impl parser for parser {\n             } else {\n                 if self.ch == '\"' {\n                     self.bump();\n-                    ret ok(res);\n+                    ret ok(@res);\n                 }\n                 str::push_char(res, self.ch);\n             }\n@@ -382,7 +387,7 @@ impl parser for parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            ret ok(list(values));\n+            ret ok(list(@values));\n         }\n \n         loop {\n@@ -398,7 +403,7 @@ impl parser for parser {\n \n             alt self.ch {\n               ',' { self.bump(); }\n-              ']' { self.bump(); ret ok(list(values)); }\n+              ']' { self.bump(); ret ok(list(@values)); }\n               _ { ret self.error(\"expecting ',' or ']'\"); }\n             }\n         };\n@@ -436,7 +441,7 @@ impl parser for parser {\n             self.bump();\n \n             alt self.parse_value() {\n-              ok(value) { values.insert(key, value); }\n+              ok(value) { values.insert(copy *key, value); }\n               e { ret e; }\n             }\n             self.parse_whitespace();\n@@ -478,7 +483,7 @@ fn eq(value0: json, value1: json) -> bool {\n       (num(f0), num(f1)) { f0 == f1 }\n       (string(s0), string(s1)) { s0 == s1 }\n       (boolean(b0), boolean(b1)) { b0 == b1 }\n-      (list(l0), list(l1)) { vec::all2(l0, l1, eq) }\n+      (list(l0), list(l1)) { vec::all2(*l0, *l1, eq) }\n       (dict(d0), dict(d1)) {\n           if d0.size() == d1.size() {\n               let mut equal = true;\n@@ -558,33 +563,37 @@ impl of to_json for bool {\n }\n \n impl of to_json for str {\n+    fn to_json() -> json { string(@copy self) }\n+}\n+\n+impl of to_json for @str {\n     fn to_json() -> json { string(self) }\n }\n \n impl <A: to_json copy, B: to_json copy> of to_json for (A, B) {\n     fn to_json() -> json {\n         let (a, b) = self;\n-        list([a.to_json(), b.to_json()])\n+        list(@[a.to_json(), b.to_json()])\n     }\n }\n \n impl <A: to_json copy, B: to_json copy, C: to_json copy>\n   of to_json for (A, B, C) {\n     fn to_json() -> json {\n         let (a, b, c) = self;\n-        list([a.to_json(), b.to_json(), c.to_json()])\n+        list(@[a.to_json(), b.to_json(), c.to_json()])\n     }\n }\n \n impl <A: to_json> of to_json for [A] {\n-    fn to_json() -> json { list(self.map { |elt| elt.to_json() }) }\n+    fn to_json() -> json { list(@self.map { |elt| elt.to_json() }) }\n }\n \n impl <A: to_json copy> of to_json for hashmap<str, A> {\n     fn to_json() -> json {\n         let d = map::str_hash();\n         for self.each() { |key, value|\n-            d.insert(key, value.to_json());\n+            d.insert(copy key, value.to_json());\n         }\n         dict(d)\n     }\n@@ -603,13 +612,19 @@ impl of to_str::to_str for json {\n     fn to_str() -> str { to_str(self) }\n }\n \n+impl of to_str::to_str for error {\n+    fn to_str() -> str {\n+        #fmt(\"%u:%u: %s\", self.line, self.col, *self.msg)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     fn mk_dict(items: [(str, json)]) -> json {\n         let d = map::str_hash();\n \n         vec::iter(items) { |item|\n-            let (key, value) = item;\n+            let (key, value) = copy item;\n             d.insert(key, value);\n         };\n \n@@ -631,8 +646,8 @@ mod tests {\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(string(\"\")) == \"\\\"\\\"\";\n-        assert to_str(string(\"foo\")) == \"\\\"foo\\\"\";\n+        assert to_str(string(@\"\")) == \"\\\"\\\"\";\n+        assert to_str(string(@\"foo\")) == \"\\\"foo\\\"\";\n     }\n \n     #[test]\n@@ -643,12 +658,12 @@ mod tests {\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(list([])) == \"[]\";\n-        assert to_str(list([boolean(true)])) == \"[true]\";\n-        assert to_str(list([\n+        assert to_str(list(@[])) == \"[]\";\n+        assert to_str(list(@[boolean(true)])) == \"[true]\";\n+        assert to_str(list(@[\n             boolean(false),\n             null,\n-            list([string(\"foo\\nbar\"), num(3.5f)])\n+            list(@[string(@\"foo\\nbar\"), num(3.5f)])\n         ])) == \"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n     }\n \n@@ -658,9 +673,9 @@ mod tests {\n         assert to_str(mk_dict([(\"a\", boolean(true))])) == \"{ \\\"a\\\": true }\";\n         assert to_str(mk_dict([\n             (\"a\", boolean(true)),\n-            (\"b\", list([\n-                mk_dict([(\"c\", string(\"\\x0c\\r\"))]),\n-                mk_dict([(\"d\", string(\"\"))])\n+            (\"b\", list(@[\n+                mk_dict([(\"c\", string(@\"\\x0c\\r\"))]),\n+                mk_dict([(\"d\", string(@\"\"))])\n             ]))\n         ])) ==\n             \"{ \" +\n@@ -675,35 +690,35 @@ mod tests {\n     #[test]\n     fn test_trailing_characters() {\n         assert from_str(\"nulla\") ==\n-            err({line: 1u, col: 5u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 5u, msg: @\"trailing characters\"});\n         assert from_str(\"truea\") ==\n-            err({line: 1u, col: 5u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 5u, msg: @\"trailing characters\"});\n         assert from_str(\"falsea\") ==\n-            err({line: 1u, col: 6u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 6u, msg: @\"trailing characters\"});\n         assert from_str(\"1a\") ==\n-            err({line: 1u, col: 2u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 2u, msg: @\"trailing characters\"});\n         assert from_str(\"[]a\") ==\n-            err({line: 1u, col: 3u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n         assert from_str(\"{}a\") ==\n-            err({line: 1u, col: 3u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert from_str(\"n\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n         assert from_str(\"nul\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"t\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n         assert from_str(\"truz\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"f\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n         assert from_str(\"faz\") ==\n-            err({line: 1u, col: 3u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 3u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"null\") == ok(null);\n         assert from_str(\"true\") == ok(boolean(true));\n@@ -716,20 +731,20 @@ mod tests {\n     #[test]\n     fn test_read_num() {\n         assert from_str(\"+\") ==\n-            err({line: 1u, col: 1u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 1u, msg: @\"invalid syntax\"});\n         assert from_str(\".\") ==\n-            err({line: 1u, col: 1u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 1u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"-\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid number\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid number\"});\n         assert from_str(\"00\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid number\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid number\"});\n         assert from_str(\"1.\") ==\n-            err({line: 1u, col: 3u, msg: \"invalid number\"});\n+            err({line: 1u, col: 3u, msg: @\"invalid number\"});\n         assert from_str(\"1e\") ==\n-            err({line: 1u, col: 3u, msg: \"invalid number\"});\n+            err({line: 1u, col: 3u, msg: @\"invalid number\"});\n         assert from_str(\"1e+\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid number\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid number\"});\n \n         assert from_str(\"3\") == ok(num(3f));\n         assert from_str(\"3.1\") == ok(num(3.1f));\n@@ -744,82 +759,86 @@ mod tests {\n     #[test]\n     fn test_read_str() {\n         assert from_str(\"\\\"\") ==\n-            err({line: 1u, col: 2u, msg: \"EOF while parsing string\"});\n+            err({line: 1u, col: 2u, msg: @\"EOF while parsing string\"});\n         assert from_str(\"\\\"lol\") ==\n-            err({line: 1u, col: 5u, msg: \"EOF while parsing string\"});\n+            err({line: 1u, col: 5u, msg: @\"EOF while parsing string\"});\n \n-        assert from_str(\"\\\"\\\"\") == ok(string(\"\"));\n-        assert from_str(\"\\\"foo\\\"\") == ok(string(\"foo\"));\n-        assert from_str(\"\\\"\\\\\\\"\\\"\") == ok(string(\"\\\"\"));\n-        assert from_str(\"\\\"\\\\b\\\"\") == ok(string(\"\\x08\"));\n-        assert from_str(\"\\\"\\\\n\\\"\") == ok(string(\"\\n\"));\n-        assert from_str(\"\\\"\\\\r\\\"\") == ok(string(\"\\r\"));\n-        assert from_str(\"\\\"\\\\t\\\"\") == ok(string(\"\\t\"));\n-        assert from_str(\" \\\"foo\\\" \") == ok(string(\"foo\"));\n+        assert from_str(\"\\\"\\\"\") == ok(string(@\"\"));\n+        assert from_str(\"\\\"foo\\\"\") == ok(string(@\"foo\"));\n+        assert from_str(\"\\\"\\\\\\\"\\\"\") == ok(string(@\"\\\"\"));\n+        assert from_str(\"\\\"\\\\b\\\"\") == ok(string(@\"\\x08\"));\n+        assert from_str(\"\\\"\\\\n\\\"\") == ok(string(@\"\\n\"));\n+        assert from_str(\"\\\"\\\\r\\\"\") == ok(string(@\"\\r\"));\n+        assert from_str(\"\\\"\\\\t\\\"\") == ok(string(@\"\\t\"));\n+        assert from_str(\" \\\"foo\\\" \") == ok(string(@\"foo\"));\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert from_str(\"[\") ==\n-            err({line: 1u, col: 2u, msg: \"EOF while parsing value\"});\n+            err({line: 1u, col: 2u, msg: @\"EOF while parsing value\"});\n         assert from_str(\"[1\") ==\n-            err({line: 1u, col: 3u, msg: \"EOF while parsing list\"});\n+            err({line: 1u, col: 3u, msg: @\"EOF while parsing list\"});\n         assert from_str(\"[1,\") ==\n-            err({line: 1u, col: 4u, msg: \"EOF while parsing value\"});\n+            err({line: 1u, col: 4u, msg: @\"EOF while parsing value\"});\n         assert from_str(\"[1,]\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n         assert from_str(\"[6 7]\") ==\n-            err({line: 1u, col: 4u, msg: \"expecting ',' or ']'\"});\n-\n-        assert from_str(\"[]\") == ok(list([]));\n-        assert from_str(\"[ ]\") == ok(list([]));\n-        assert from_str(\"[true]\") == ok(list([boolean(true)]));\n-        assert from_str(\"[ false ]\") == ok(list([boolean(false)]));\n-        assert from_str(\"[null]\") == ok(list([null]));\n-        assert from_str(\"[3, 1]\") == ok(list([num(3f), num(1f)]));\n-        assert from_str(\"\\n[3, 2]\\n\") == ok(list([num(3f), num(2f)]));\n+            err({line: 1u, col: 4u, msg: @\"expecting ',' or ']'\"});\n+\n+        assert from_str(\"[]\") == ok(list(@[]));\n+        assert from_str(\"[ ]\") == ok(list(@[]));\n+        assert from_str(\"[true]\") == ok(list(@[boolean(true)]));\n+        assert from_str(\"[ false ]\") == ok(list(@[boolean(false)]));\n+        assert from_str(\"[null]\") == ok(list(@[null]));\n+        assert from_str(\"[3, 1]\") == ok(list(@[num(3f), num(1f)]));\n+        assert from_str(\"\\n[3, 2]\\n\") == ok(list(@[num(3f), num(2f)]));\n         assert from_str(\"[2, [4, 1]]\") ==\n-               ok(list([num(2f), list([num(4f), num(1f)])]));\n+               ok(list(@[num(2f), list(@[num(4f), num(1f)])]));\n     }\n \n     #[test]\n     fn test_read_dict() {\n         assert from_str(\"{\") ==\n-            err({line: 1u, col: 2u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 2u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{ \") ==\n-            err({line: 1u, col: 3u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 3u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{1\") ==\n-            err({line: 1u, col: 2u, msg: \"key must be a string\"});\n+            err({line: 1u, col: 2u, msg: @\"key must be a string\"});\n         assert from_str(\"{ \\\"a\\\"\") ==\n-            err({line: 1u, col: 6u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 6u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{\\\"a\\\"\") ==\n-            err({line: 1u, col: 5u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 5u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{\\\"a\\\" \") ==\n-            err({line: 1u, col: 6u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 6u, msg: @\"EOF while parsing object\"});\n \n         assert from_str(\"{\\\"a\\\" 1\") ==\n-            err({line: 1u, col: 6u, msg: \"expecting ':'\"});\n+            err({line: 1u, col: 6u, msg: @\"expecting ':'\"});\n         assert from_str(\"{\\\"a\\\":\") ==\n-            err({line: 1u, col: 6u, msg: \"EOF while parsing value\"});\n+            err({line: 1u, col: 6u, msg: @\"EOF while parsing value\"});\n         assert from_str(\"{\\\"a\\\":1\") ==\n-            err({line: 1u, col: 7u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 7u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{\\\"a\\\":1 1\") ==\n-            err({line: 1u, col: 8u, msg: \"expecting ',' or '}'\"});\n+            err({line: 1u, col: 8u, msg: @\"expecting ',' or '}'\"});\n         assert from_str(\"{\\\"a\\\":1,\") ==\n-            err({line: 1u, col: 8u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 8u, msg: @\"EOF while parsing object\"});\n \n         assert eq(result::get(from_str(\"{}\")), mk_dict([]));\n         assert eq(result::get(from_str(\"{\\\"a\\\": 3}\")),\n                   mk_dict([(\"a\", num(3.0f))]));\n \n         assert eq(result::get(from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n-                  mk_dict([(\"a\", null), (\"b\", boolean(true))]));\n+                  mk_dict([\n+                      (\"a\", null),\n+                      (\"b\", boolean(true))]));\n         assert eq(result::get(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n-                  mk_dict([(\"a\", null), (\"b\", boolean(true))]));\n+                  mk_dict([\n+                      (\"a\", null),\n+                      (\"b\", boolean(true))]));\n         assert eq(result::get(from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n                   mk_dict([\n                       (\"a\", num(1.0)),\n-                      (\"b\", list([boolean(true)]))\n+                      (\"b\", list(@[boolean(true)]))\n                   ]));\n         assert eq(result::get(from_str(\n                       \"{\" +\n@@ -832,9 +851,9 @@ mod tests {\n                       \"}\")),\n                   mk_dict([\n                       (\"a\", num(1.0f)),\n-                      (\"b\", list([\n+                      (\"b\", list(@[\n                           boolean(true),\n-                          string(\"foo\\nbar\"),\n+                          string(@\"foo\\nbar\"),\n                           mk_dict([\n                               (\"c\", mk_dict([(\"d\", null)]))\n                           ])\n@@ -845,6 +864,6 @@ mod tests {\n     #[test]\n     fn test_multiline_errors() {\n         assert from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            err({line: 3u, col: 8u, msg: \"EOF while parsing object\"});\n+            err({line: 3u, col: 8u, msg: @\"EOF while parsing object\"});\n     }\n }"}, {"sha": "140349089a81d7f9d4f9e5240651c27b7f8ba1eb", "filename": "src/libstd/map.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -262,7 +262,7 @@ mod chained {\n         ret vec::to_mut(vec::from_elem(nchains, absent));\n     }\n \n-    fn mk<K: copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {\n+    fn mk<K, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>) -> t<K,V> {\n         let initial_capacity: uint = 32u; // 2^5\n         let slf: t<K, V> = @{mut count: 0u,\n                              mut chains: chains(initial_capacity),\n@@ -282,7 +282,7 @@ Parameters:\n hasher - The hash function for key type K\n eqer - The equality function for key type K\n */\n-fn hashmap<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n+fn hashmap<K: const, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n         -> hashmap<K, V> {\n     chained::mk(hasher, eqer)\n }\n@@ -297,20 +297,14 @@ fn bytes_hash<V: copy>() -> hashmap<[u8], V> {\n     ret hashmap(vec::u8::hash, vec::u8::eq);\n }\n \n-fn hash_int(&&x: int) -> uint { int::hash(x) }\n-fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n-\n #[doc = \"Construct a hashmap for int keys\"]\n fn int_hash<V: copy>() -> hashmap<int, V> {\n-    ret hashmap(hash_int, eq_int);\n+    ret hashmap(int::hash, int::eq);\n }\n \n-fn hash_uint(&&x: uint) -> uint { uint::hash(x) }\n-fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n-\n #[doc = \"Construct a hashmap for uint keys\"]\n fn uint_hash<V: copy>() -> hashmap<uint, V> {\n-    ret hashmap(hash_uint, eq_uint);\n+    ret hashmap(uint::hash, uint::eq);\n }\n \n #[doc = \"\n@@ -334,7 +328,7 @@ fn vec_from_set<T: copy>(s: set<T>) -> [T] {\n \n #[doc = \"Construct a hashmap from a vector\"]\n fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                                   items: [(K, V)]) -> hashmap<K, V> {\n+                                         items: [(K, V)]) -> hashmap<K, V> {\n     let map = hashmap(hasher, eqer);\n     vec::iter(items) { |item|\n         let (key, value) = item;\n@@ -355,12 +349,12 @@ fn hash_from_bytes<V: copy>(items: [([u8], V)]) -> hashmap<[u8], V> {\n \n #[doc = \"Construct a hashmap from a vector with int keys\"]\n fn hash_from_ints<V: copy>(items: [(int, V)]) -> hashmap<int, V> {\n-    hash_from_vec(hash_int, eq_int, items)\n+    hash_from_vec(int::hash, int::eq, items)\n }\n \n #[doc = \"Construct a hashmap from a vector with uint keys\"]\n fn hash_from_uints<V: copy>(items: [(uint, V)]) -> hashmap<uint, V> {\n-    hash_from_vec(hash_uint, eq_uint, items)\n+    hash_from_vec(uint::hash, uint::eq, items)\n }\n \n #[cfg(test)]"}, {"sha": "ad1501dd8b0d1b7609c1cab36778d19de6514a07", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -730,7 +730,8 @@ enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_native(@native_item),\n-    ii_ctor(class_ctor, ident, [ty_param], def_id /* parent id */)\n+    ii_ctor(class_ctor, ident, [ty_param], def_id /* parent id */),\n+    ii_dtor(class_dtor, ident, [ty_param], def_id /* parent id */)\n }\n \n //"}, {"sha": "10397e795ab7b35a12efd68d59745acdcb0e6fd0", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -106,7 +106,7 @@ fn map_decoded_item(diag: span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     alt ii {\n-      ii_item(_) | ii_ctor(_,_,_,_) { /* fallthrough */ }\n+      ii_item(*) | ii_ctor(*) | ii_dtor(*) { /* fallthrough */ }\n       ii_native(i) {\n         cx.map.insert(i.id, node_native_item(i, native_abi_rust_intrinsic,\n                                              @path));"}, {"sha": "9eee9a33af8f9396d1daee1307e7423fb7d3341a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -320,6 +320,7 @@ impl inlined_item_methods for inlined_item {\n           ii_native(i) { /* FIXME: bad */ copy i.ident }\n           ii_method(_, m) { /* FIXME: bad */ copy m.ident }\n           ii_ctor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n+          ii_dtor(_, nm, _, _) { /* FIXME: bad */ copy nm }\n         }\n     }\n \n@@ -329,6 +330,7 @@ impl inlined_item_methods for inlined_item {\n           ii_native(i) { i.id }\n           ii_method(_, m) { m.id }\n           ii_ctor(ctor, _, _, _) { ctor.node.id }\n+          ii_dtor(dtor, _, _, _) { dtor.node.id }\n         }\n     }\n \n@@ -340,6 +342,9 @@ impl inlined_item_methods for inlined_item {\n           ii_ctor(ctor, nm, tps, parent_id) {\n               visit::visit_class_ctor_helper(ctor, nm, tps, parent_id, e, v);\n           }\n+          ii_dtor(dtor, nm, tps, parent_id) {\n+              visit::visit_class_dtor_helper(dtor, tps, parent_id, e, v);\n+          }\n         }\n     }\n }"}, {"sha": "cddf8de479bdb56052d482ff488f4f7290954430", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -1,6 +1,6 @@\n import either::{either, left, right};\n import ast_util::spanned;\n-import common::{parser_common, seq_sep};\n+import common::{parser_common, seq_sep_trailing_disallowed};\n \n export attr_or_ext;\n export parser_attr;\n@@ -111,7 +111,7 @@ impl parser_attr for parser {\n \n     fn parse_meta_seq() -> [@ast::meta_item] {\n         ret self.parse_seq(token::LPAREN, token::RPAREN,\n-                           seq_sep(token::COMMA),\n+                           seq_sep_trailing_disallowed(token::COMMA),\n                            {|p| p.parse_meta_item()}).node;\n     }\n "}, {"sha": "0520993de745bfdcb9f7713d9bc1c87d0ecedead", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -4,25 +4,23 @@ import parser::parser;\n \n type seq_sep = {\n     sep: option<token::token>,\n-    trailing_opt: bool   // is trailing separator optional?\n+    trailing_sep_allowed: bool\n };\n \n-fn seq_sep(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_opt: false};\n+fn seq_sep_trailing_disallowed(t: token::token) -> seq_sep {\n+    ret {sep: option::some(t), trailing_sep_allowed: false};\n }\n-fn seq_sep_opt(t: token::token) -> seq_sep {\n-    ret {sep: option::some(t), trailing_opt: true};\n+fn seq_sep_trailing_allowed(t: token::token) -> seq_sep {\n+    ret {sep: option::some(t), trailing_sep_allowed: true};\n }\n fn seq_sep_none() -> seq_sep {\n-    ret {sep: option::none, trailing_opt: false};\n+    ret {sep: option::none, trailing_sep_allowed: false};\n }\n \n-\n fn token_to_str(reader: reader, ++token: token::token) -> str {\n     token::to_str(*reader.interner, token)\n }\n \n-\n // This should be done with traits, once traits work\n impl parser_common for parser {\n \n@@ -203,7 +201,7 @@ impl parser_common for parser {\n                         else { self.expect(t); } }\n               _ { }\n             }\n-            if sep.trailing_opt && self.token == ket { break; }\n+            if sep.trailing_sep_allowed && self.token == ket { break; }\n             v += [f(self)];\n         }\n         ret v;"}, {"sha": "828cd5ce7d435be0276b4bc382839642643c8f9e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -9,7 +9,8 @@ import ast::*;\n import lexer::reader;\n import prec::{as_prec, token_to_binop};\n import attr::parser_attr;\n-import common::{seq_sep, seq_sep_opt, seq_sep_none, token_to_str};\n+import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n+                seq_sep_none, token_to_str};\n import common::*;//{parser_common};\n import dvec::{dvec, extensions};\n \n@@ -167,9 +168,9 @@ class parser {\n     }\n \n     fn parse_ty_fn_decl(purity: ast::purity) -> fn_decl {\n-        let inputs =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA)) { |p|\n+        let inputs = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA)) { |p|\n             let mode = p.parse_arg_mode();\n             let name = if is_plain_ident(p.token)\n                 && p.look_ahead(1u) == token::COLON {\n@@ -260,21 +261,21 @@ class parser {\n     fn parse_ty_constr(fn_args: [arg]) -> @constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA),\n-                                     {|p| p.parse_constr_arg(fn_args)});\n+        let args = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            {|p| p.parse_constr_arg(fn_args)});\n         ret @spanned(lo, self.span.hi,\n                      {path: path, args: args, id: self.get_id()});\n     }\n \n     fn parse_constr_in_type() -> @ty_constr {\n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n-        let args: [@ty_constr_arg] =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA),\n-                                     {|p| p.parse_type_constr_arg()});\n+        let args: [@ty_constr_arg] = self.parse_unspanned_seq(\n+            token::LPAREN, token::RPAREN,\n+            seq_sep_trailing_disallowed(token::COMMA),\n+            {|p| p.parse_type_constr_arg()});\n         let hi = self.span.lo;\n         let tc: ty_constr_ = {path: path, args: args, id: self.get_id()};\n         ret @spanned(lo, hi, tc);\n@@ -389,9 +390,10 @@ class parser {\n             self.bump();\n             ty_ptr(self.parse_mt())\n         } else if self.token == token::LBRACE {\n-            let elems = self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n-                                                 seq_sep_opt(token::COMMA),\n-                                                 {|p| p.parse_ty_field()});\n+            let elems = self.parse_unspanned_seq(\n+                token::LBRACE, token::RBRACE,\n+                seq_sep_trailing_allowed(token::COMMA),\n+                {|p| p.parse_ty_field()});\n             if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n@@ -802,9 +804,9 @@ class parser {\n         } else if self.token == token::LBRACKET {\n             self.bump();\n             let mutbl = self.parse_mutability();\n-            let es =\n-                self.parse_seq_to_end(token::RBRACKET, seq_sep(token::COMMA),\n-                                      {|p| p.parse_expr()});\n+            let es = self.parse_seq_to_end(\n+                token::RBRACKET, seq_sep_trailing_allowed(token::COMMA),\n+                {|p| p.parse_expr()});\n             hi = self.span.hi;\n             ex = expr_vec(es, mutbl);\n         } else if self.token == token::POUND\n@@ -833,9 +835,10 @@ class parser {\n             ex = ex_ext.node;\n         } else if self.eat_keyword(\"bind\") {\n             let e = self.parse_expr_res(RESTRICT_NO_CALL_EXPRS);\n-            let es = self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                              seq_sep(token::COMMA),\n-                                              {|p| p.parse_expr_or_hole()});\n+            let es = self.parse_unspanned_seq(\n+                token::LPAREN, token::RPAREN,\n+                seq_sep_trailing_disallowed(token::COMMA),\n+                {|p| p.parse_expr_or_hole()});\n             hi = self.span.hi;\n             ex = expr_bind(e, es);\n         } else if self.eat_keyword(\"fail\") {\n@@ -937,7 +940,7 @@ class parser {\n         }\n         let pth = self.parse_path_without_tps();\n         //temporary for a backwards-compatible cycle:\n-        let sep = seq_sep(token::COMMA);\n+        let sep = seq_sep_trailing_disallowed(token::COMMA);\n         let mut e = none;\n         if (self.token == token::LPAREN || self.token == token::LBRACKET) {\n             let lo = self.span.lo;\n@@ -1009,10 +1012,10 @@ class parser {\n             alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n-                let es_opt =\n-                    self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                             seq_sep(token::COMMA),\n-                                             {|p| p.parse_expr_or_hole()});\n+                let es_opt = self.parse_unspanned_seq(\n+                    token::LPAREN, token::RPAREN,\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    {|p| p.parse_expr_or_hole()});\n                 hi = self.span.hi;\n \n                 let nd =\n@@ -1479,11 +1482,10 @@ class parser {\n                         self.expect(token::RPAREN);\n                       }\n                       _ {\n-                        args =\n-                            self.parse_unspanned_seq(token::LPAREN,\n-                                                     token::RPAREN,\n-                                                     seq_sep(token::COMMA),\n-                                                     {|p| p.parse_pat()});\n+                        args = self.parse_unspanned_seq(\n+                            token::LPAREN, token::RPAREN,\n+                            seq_sep_trailing_disallowed(token::COMMA),\n+                            {|p| p.parse_pat()});\n                         hi = self.span.hi;\n                       }\n                     }\n@@ -1783,8 +1785,9 @@ class parser {\n         -> (fn_decl, capture_clause) {\n \n         let args_or_capture_items: [arg_or_capture_item] =\n-            self.parse_unspanned_seq(token::LPAREN, token::RPAREN,\n-                                     seq_sep(token::COMMA), parse_arg_fn);\n+            self.parse_unspanned_seq(\n+                token::LPAREN, token::RPAREN,\n+                seq_sep_trailing_disallowed(token::COMMA), parse_arg_fn);\n \n         let inputs = either::lefts(args_or_capture_items);\n         let capture_clause = @either::rights(args_or_capture_items);\n@@ -1810,10 +1813,10 @@ class parser {\n             if self.eat(token::OROR) {\n                 []\n             } else {\n-                self.parse_unspanned_seq(token::BINOP(token::OR),\n-                                         token::BINOP(token::OR),\n-                                         seq_sep(token::COMMA),\n-                                         {|p| p.parse_fn_block_arg()})\n+                self.parse_unspanned_seq(\n+                    token::BINOP(token::OR), token::BINOP(token::OR),\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    {|p| p.parse_fn_block_arg()})\n             }\n         };\n         let output = if self.eat(token::RARROW) {\n@@ -1984,8 +1987,9 @@ class parser {\n     }\n \n     fn parse_iface_ref_list() -> [@iface_ref] {\n-        self.parse_seq_to_before_end(token::LBRACE, seq_sep(token::COMMA),\n-                                     {|p| p.parse_iface_ref()})\n+        self.parse_seq_to_before_end(\n+            token::LBRACE, seq_sep_trailing_disallowed(token::COMMA),\n+            {|p| p.parse_iface_ref()})\n     }\n \n     fn parse_item_class() -> item_info {\n@@ -2265,11 +2269,10 @@ class parser {\n             let mut args = [], disr_expr = none;\n             if self.token == token::LPAREN {\n                 all_nullary = false;\n-                let arg_tys =\n-                    self.parse_unspanned_seq(token::LPAREN,\n-                                             token::RPAREN,\n-                                             seq_sep(token::COMMA),\n-                                             {|p| p.parse_ty(false)});\n+                let arg_tys = self.parse_unspanned_seq(\n+                    token::LPAREN, token::RPAREN,\n+                    seq_sep_trailing_disallowed(token::COMMA),\n+                    {|p| p.parse_ty(false)});\n                 for arg_tys.each {|ty|\n                     args += [{ty: ty, id: self.get_id()}];\n                 }\n@@ -2409,11 +2412,10 @@ class parser {\n \n                   // foo::bar::{a,b,c}\n                   token::LBRACE {\n-                    let idents =\n-                        self.parse_unspanned_seq(token::LBRACE, token::RBRACE,\n-                                                 seq_sep(token::COMMA),\n-                                                 {|p|\n-                                                  p.parse_path_list_ident()});\n+                    let idents = self.parse_unspanned_seq(\n+                        token::LBRACE, token::RBRACE,\n+                        seq_sep_trailing_disallowed(token::COMMA),\n+                        {|p| p.parse_path_list_ident()});\n                     let path = @{span: mk_sp(lo, self.span.hi),\n                                  global: false, idents: path,\n                                  rp: none, types: []};"}, {"sha": "20058a8a9db8d0df543c0e3b6a097221abe002bf", "filename": "src/rt/rust_box_annihilator.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_box_annihilator.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_box_annihilator.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_box_annihilator.cpp?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -45,6 +45,10 @@ class annihilator : public shape::data<annihilator,shape::ptr> {\n         task->kernel->free(vec);\n     }\n \n+    void walk_unboxed_vec2(bool is_pod) {\n+        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n+    }\n+\n     void walk_fixedvec2(uint16_t n_elts, size_t elt_sz, bool is_pod) {\n         walk_vec2(is_pod, get_fixedvec_data_range(n_elts, elt_sz, dp));\n     }"}, {"sha": "e75ec46522fffa842d590143ffa729f872ce6a08", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -91,6 +91,10 @@ class irc : public shape::data<irc,shape::ptr> {\n         walk_vec2(is_pod, get_vec_data_range(dp));\n     }\n \n+    void walk_unboxed_vec2(bool is_pod) {\n+        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n+    }\n+\n     void walk_slice2(bool is_pod, bool is_str) {\n         walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n     }\n@@ -341,6 +345,10 @@ class mark : public shape::data<mark,shape::ptr> {\n         walk_vec2(is_pod, get_vec_data_range(dp));\n     }\n \n+    void walk_unboxed_vec2(bool is_pod) {\n+        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n+    }\n+\n     void walk_slice2(bool is_pod, bool is_str) {\n         walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n     }"}, {"sha": "444bcc9e0887f86d020e65c9a35941cbb3bde3aa", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -263,6 +263,11 @@ class cmp : public data<cmp,ptr_pair> {\n         walk_vec2(is_pod, get_vec_data_range(dp));\n     }\n \n+    void walk_unboxed_vec2(bool is_pod) {\n+        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n+    }\n+\n+\n     void walk_slice2(bool is_pod, bool is_str) {\n         // Slices compare just like vecs.\n         walk_vec2(is_pod, get_slice_data_range(is_str, dp));"}, {"sha": "8766759cc41ddfafbe86d9c69df8362ebeff171c", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 74, "deletions": 2, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -58,6 +58,7 @@ const uint8_t SHAPE_SEND_TYDESC = 29u;\n const uint8_t SHAPE_RPTR = 31u;\n const uint8_t SHAPE_FIXEDVEC = 32u;\n const uint8_t SHAPE_SLICE = 33u;\n+const uint8_t SHAPE_UNBOXED_VEC = 34u;\n \n #ifdef _LP64\n const uint8_t SHAPE_PTR = SHAPE_U64;\n@@ -263,9 +264,9 @@ class ctxt {\n \n private:\n     void walk_vec0();\n+    void walk_unboxed_vec0();\n     void walk_tag0();\n     void walk_box0();\n-    void walk_box_old0();\n     void walk_uniq0();\n     void walk_struct0();\n     void walk_res0();\n@@ -318,6 +319,7 @@ ctxt<T>::walk() {\n     case SHAPE_RPTR:     walk_rptr0();            break;\n     case SHAPE_FIXEDVEC: walk_fixedvec0();        break;\n     case SHAPE_SLICE:    walk_slice0();           break;\n+    case SHAPE_UNBOXED_VEC: walk_unboxed_vec0();  break;\n     default:             abort();\n     }\n }\n@@ -375,6 +377,19 @@ ctxt<T>::walk_vec0() {\n     sp = end_sp;\n }\n \n+template<typename T>\n+void\n+ctxt<T>::walk_unboxed_vec0() {\n+    bool is_pod = *sp++;\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_unboxed_vec1(is_pod);\n+\n+    sp = end_sp;\n+}\n+\n template<typename T>\n void\n ctxt<T>::walk_tag0() {\n@@ -516,6 +531,9 @@ class print : public ctxt<print> {\n     void walk_vec1(bool is_pod) {\n         DPRINT(\"vec<\"); walk(); DPRINT(\">\");\n     }\n+    void walk_unboxed_vec1(bool is_pod) {\n+        DPRINT(\"unboxed_vec<\"); walk(); DPRINT(\">\");\n+    }\n     void walk_uniq1() {\n         DPRINT(\"~<\"); walk(); DPRINT(\">\");\n     }\n@@ -603,6 +621,11 @@ class size_of : public ctxt<size_of> {\n         sa.set(sizeof(void *), sizeof(void *));\n     }\n \n+    void walk_unboxed_vec1(bool is_pod) {\n+        assert(false &&\n+               \"trying to compute size of dynamically sized unboxed vector\");\n+    }\n+\n     void walk_res1(const rust_fn *dtor, const uint8_t *end_sp) {\n         abort();    // TODO\n     }\n@@ -849,6 +872,12 @@ class data : public ctxt< data<T,U> > {\n     static std::pair<uint8_t *,uint8_t *> get_vec_data_range(ptr dp);\n     static std::pair<ptr_pair,ptr_pair> get_vec_data_range(ptr_pair &dp);\n \n+    static std::pair<uint8_t *,uint8_t *> get_unboxed_vec_data_range(ptr dp);\n+    static std::pair<ptr_pair,ptr_pair>\n+        get_unboxed_vec_data_range(ptr_pair &dp);\n+    static ptr get_unboxed_vec_end(ptr dp);\n+    static ptr_pair get_unboxed_vec_end(ptr_pair &dp);\n+\n     static std::pair<uint8_t *,uint8_t *> get_slice_data_range(bool is_str,\n                                                                ptr dp);\n     static std::pair<ptr_pair,ptr_pair> get_slice_data_range(bool is_str,\n@@ -880,6 +909,13 @@ class data : public ctxt< data<T,U> > {\n         DATA_SIMPLE(void *, walk_vec2(is_pod));\n     }\n \n+    void walk_unboxed_vec1(bool is_pod) {\n+        // align?\n+        U next_dp = get_unboxed_vec_end(dp);\n+        static_cast<T *>(this)->walk_unboxed_vec2(is_pod);\n+        dp = next_dp;\n+    }\n+\n     void walk_slice1(bool is_pod, bool is_str) {\n         DATA_SIMPLE(void *, walk_slice2(is_pod, is_str));\n     }\n@@ -955,7 +991,7 @@ data<T,U>::walk_uniq_contents1() {\n     if (body_td) {\n         U body_dp(dp.box_body());\n         arena arena;\n-        T sub(*static_cast<T *>(this), body_td->shape,\n+        T sub(*static_cast<T *>(this), /*body_td->shape,*/ this->sp,\n               body_td->shape_tables, body_dp);\n         sub.align = true;\n         static_cast<T *>(this)->walk_uniq_contents2(sub);\n@@ -1000,6 +1036,38 @@ data<T,U>::get_vec_data_range(ptr_pair &dp) {\n     return std::make_pair(start, end);\n }\n \n+template<typename T,typename U>\n+std::pair<uint8_t *,uint8_t *>\n+data<T,U>::get_unboxed_vec_data_range(ptr dp) {\n+    rust_vec* ptr = (rust_vec*)dp;\n+    uint8_t* data = &ptr->data[0];\n+    return std::make_pair(data, data + ptr->fill);\n+}\n+\n+template<typename T,typename U>\n+std::pair<ptr_pair,ptr_pair>\n+data<T,U>::get_unboxed_vec_data_range(ptr_pair &dp) {\n+    std::pair<uint8_t *,uint8_t *> fst =\n+        get_unboxed_vec_data_range(shape::ptr(dp.fst));\n+    std::pair<uint8_t *,uint8_t *> snd =\n+        get_unboxed_vec_data_range(shape::ptr(dp.snd));\n+    ptr_pair start(fst.first, snd.first);\n+    ptr_pair end(fst.second, snd.second);\n+    return std::make_pair(start, end);\n+}\n+\n+template<typename T,typename U>\n+ptr data<T,U>::get_unboxed_vec_end(ptr dp) {\n+    rust_vec* ptr = (rust_vec*)dp;\n+    return dp + sizeof(rust_vec) + ptr->fill;\n+}\n+\n+template<typename T,typename U>\n+ptr_pair data<T,U>::get_unboxed_vec_end(ptr_pair &dp) {\n+    return ptr_pair(get_unboxed_vec_end(ptr(dp.fst)),\n+                    get_unboxed_vec_end(ptr(dp.snd)));\n+}\n+\n template<typename T,typename U>\n std::pair<uint8_t *,uint8_t *>\n data<T,U>::get_slice_data_range(bool is_str, ptr dp) {\n@@ -1135,6 +1203,10 @@ class log : public data<log,ptr> {\n             walk_vec2(is_pod, get_vec_data_range(dp));\n     }\n \n+    void walk_unboxed_vec2(bool is_pod) {\n+        walk_vec2(is_pod, get_unboxed_vec_data_range(dp));\n+    }\n+\n     void walk_slice2(bool is_pod, bool is_str) {\n         walk_vec2(is_pod, get_slice_data_range(is_str, dp));\n         out << \"/&\";"}, {"sha": "dcb71c6718ae28bea86d83686f51ed546536c573", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -335,15 +335,18 @@ fn get_class_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    let mut found = none;\n     let cls_items = alt maybe_find_item(id, items) {\n             some(it) { it }\n-            none     { ret none; }};\n-    let mut rslt = none;\n-    ebml::tagged_docs(cls_items, tag_item_dtor) {|f|\n-        let did = parse_def_id(ebml::doc_data(f));\n-        rslt = some(translate_def_id(cdata, did));\n-    }\n-    rslt\n+            none     { fail (#fmt(\"class_dtor: class id not found \\\n+              when looking up dtor for %d\", id)); }\n+    };\n+    ebml::tagged_docs(cls_items, tag_item_dtor) {|doc|\n+         let doc1 = ebml::get_doc(doc, tag_def_id);\n+         let did = parse_def_id(ebml::doc_data(doc1));\n+         found = some(translate_def_id(cdata, did));\n+    };\n+    found\n }\n \n fn get_symbol(data: @[u8], id: ast::node_id) -> str {"}, {"sha": "215f73a6d4f4686aa53b90ceedf40eddea80e225", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -9,7 +9,7 @@ import ebml::writer;\n import syntax::ast::*;\n import syntax::print::pprust;\n import syntax::{ast_util, visit};\n-import syntax::ast_util::local_def;\n+import syntax::ast_util::*;\n import common::*;\n import middle::ty;\n import middle::ty::node_id_to_type;\n@@ -206,12 +206,6 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                 add_to_index(ebml_w, path, index, it.ident);\n                 encode_named_def_id(ebml_w, it.ident,\n                                     local_def(ctor.node.id));\n-                /* Encode id for dtor */\n-                option::iter(m_dtor) {|dtor|\n-                        ebml_w.wr_tag(tag_item_dtor) {||\n-                           encode_def_id(ebml_w, local_def(dtor.node.id));\n-                    }\n-                };\n                 encode_class_item_paths(ebml_w, items, path + [it.ident],\n                                         index);\n             }\n@@ -485,8 +479,8 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n-        #debug(\"fn name = %s ty = %s\", ident,\n-               util::ppaux::ty_to_str(ecx.tcx, its_ty));\n+        #debug(\"fn name = %s ty = %s its node id = %d\", ident,\n+               util::ppaux::ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n         alt item {\n@@ -623,13 +617,23 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants,\n                                  path, index, tps);\n       }\n-      item_class(tps, ifaces, items, ctor, _dtor, rp) {\n+      item_class(tps, ifaces, items, ctor, m_dtor, rp) {\n         /* First, encode the fields and methods\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n         let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n                                           items, index);\n+        /* Encode the dtor */\n+        option::iter(m_dtor) {|dtor|\n+          *index += [{val: dtor.node.id, pos: ebml_w.writer.tell()}];\n+          encode_info_for_fn(ecx, ebml_w, dtor.node.id, item.ident\n+                             + \"_dtor\", path, if tps.len() > 0u {\n+                               some(ii_dtor(dtor, item.ident, tps,\n+                                            local_def(item.id))) }\n+                             else { none }, tps, ast_util::dtor_dec());\n+        }\n+\n         /* Index the class*/\n         add_to_index();\n         /* Now, make an item for the class itself */\n@@ -644,6 +648,14 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         for ifaces.each {|t|\n            encode_iface_ref(ebml_w, ecx, t);\n         }\n+        /* Encode the dtor */\n+        /* Encode id for dtor */\n+        option::iter(m_dtor) {|dtor|\n+            ebml_w.wr_tag(tag_item_dtor) {||\n+                encode_def_id(ebml_w, local_def(dtor.node.id));\n+            }\n+        };\n+\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_iface_method\n         needs to know*/\n@@ -803,17 +815,15 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n                 /* encode ctor, then encode items */\n                 alt i.node {\n-                   item_class(tps, _, _, ctor, _, _) {\n-                   /* this is assuming that ctors aren't inlined...\n-                      probably shouldn't assume that */\n+                   item_class(tps, _, _, ctor, m_dtor, _) {\n                    #debug(\"encoding info for ctor %s %d\", i.ident,\n                           ctor.node.id);\n                    *index += [{val: ctor.node.id, pos: ebml_w.writer.tell()}];\n                    encode_info_for_fn(ecx, ebml_w, ctor.node.id, i.ident,\n                       *pt, if tps.len() > 0u {\n                              some(ii_ctor(ctor, i.ident, tps,\n                                           local_def(i.id))) }\n-                           else { none }, tps, ctor.node.dec)\n+                      else { none }, tps, ctor.node.dec);\n                   }\n                   _ {}\n                 }"}, {"sha": "02ba2597d7673b18d36aad7a5acc3f668b6c318f", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -308,6 +308,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         ret ty::mk_rptr(st.tcx, r, mt);\n       }\n       'I' { ret ty::mk_vec(st.tcx, parse_mt(st, conv)); }\n+      'U' { ret ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)); }\n       'V' {\n         let mt = parse_mt(st, conv);\n         let v = parse_vstore(st);"}, {"sha": "051ea9e444ecd86feb3f6a1498678fca4c1ee134", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -252,6 +252,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_vstore(w, cx, v);\n       }\n       ty::ty_vec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n+      ty::ty_unboxed_vec(mt) { w.write_char('U'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\"/&);\n         for fields.each {|field|"}, {"sha": "0d6b158a9ae5f44f618bfe1f72282cc1b9905c36", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -427,6 +427,12 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n                               with ctor.node}\n             with ctor}, nm, tps, parent_id)\n       }\n+      ast::ii_dtor(dtor, nm, tps, parent_id) {\n+        let dtor_body = fld.fold_block(dtor.node.body);\n+        ast::ii_dtor({node: {body: dtor_body\n+                              with dtor.node}\n+            with dtor}, nm, tps, parent_id)\n+      }\n     }\n }\n \n@@ -464,6 +470,16 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n                               with ctor.node}\n             with ctor}, nm, new_params, new_parent)\n       }\n+      ast::ii_dtor(dtor, nm, tps, parent_id) {\n+        let dtor_body = fld.fold_block(dtor.node.body);\n+        let new_params = fold::fold_ty_params(tps, fld);\n+        let dtor_id = fld.new_id(dtor.node.id);\n+        let new_parent = xcx.tr_def_id(parent_id);\n+        let new_self = fld.new_id(dtor.node.self_id);\n+        ast::ii_dtor({node: {id: dtor_id, self_id: new_self, body: dtor_body}\n+                        with dtor},\n+          nm, new_params, new_parent)\n+      }\n      }\n }\n "}, {"sha": "66118dbc38c3abc087650996ed36af96d8f11489", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -238,11 +238,13 @@ enum ptr_kind {uniq_ptr, gc_ptr, region_ptr, unsafe_ptr}\n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n enum comp_kind {\n-    comp_tuple, comp_res, comp_variant,\n-    comp_field(str, // name of field\n+    comp_tuple,                  // elt in a tuple\n+    comp_res,                    // data for a resource\n+    comp_variant(ast::def_id),   // internals to a variant of given enum\n+    comp_field(str,              // name of field\n                ast::mutability), // declared mutability of field\n-    comp_index(ty::t, // type of vec/str/etc being deref'd\n-               ast::mutability) // mutability of vec content\n+    comp_index(ty::t,            // type of vec/str/etc being deref'd\n+               ast::mutability)  // mutability of vec content\n }\n \n // We pun on *T to mean both actual deref of a ptr as well\n@@ -411,7 +413,7 @@ impl to_str_methods for borrowck_ctxt {\n           comp_index(*) { \"[]\" }\n           comp_tuple { \"()\" }\n           comp_res { \"<res>\" }\n-          comp_variant { \"<enum>\" }\n+          comp_variant(_) { \"<enum>\" }\n         }\n     }\n \n@@ -468,7 +470,7 @@ impl to_str_methods for borrowck_ctxt {\n           cat_comp(_, comp_field(*)) { mut_str + \" field\" }\n           cat_comp(_, comp_tuple) { \"tuple content\" }\n           cat_comp(_, comp_res) { \"resource content\" }\n-          cat_comp(_, comp_variant) { \"enum content\" }\n+          cat_comp(_, comp_variant(_)) { \"enum content\" }\n           cat_comp(_, comp_index(t, _)) {\n             alt ty::get(t).struct {\n               ty::ty_vec(*) | ty::ty_evec(*) {\n@@ -514,7 +516,7 @@ impl to_str_methods for borrowck_ctxt {\n // mutable structure.\n fn inherent_mutability(ck: comp_kind) -> mutability {\n     alt ck {\n-      comp_tuple | comp_res | comp_variant {m_imm}\n+      comp_tuple | comp_res | comp_variant(_) {m_imm}\n       comp_field(_, m) | comp_index(_, m) {m}\n     }\n }\n\\ No newline at end of file"}, {"sha": "db22f880941b6b2709eefc9977430148c299d82a", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -67,8 +67,8 @@ fn opt_deref_kind(t: ty::t) -> option<deref_kind> {\n         some(deref_ptr(unsafe_ptr))\n       }\n \n-      ty::ty_enum(*) {\n-        some(deref_comp(comp_variant))\n+      ty::ty_enum(did, _) {\n+        some(deref_comp(comp_variant(did)))\n       }\n \n       ty::ty_res(*) {\n@@ -275,10 +275,12 @@ impl public_methods for borrowck_ctxt {\n         }\n     }\n \n-    fn cat_variant<N: ast_node>(arg: N, cmt: cmt) -> cmt {\n+    fn cat_variant<N: ast_node>(arg: N,\n+                                enum_did: ast::def_id,\n+                                cmt: cmt) -> cmt {\n         @{id: arg.id(), span: arg.span(),\n-          cat: cat_comp(cmt, comp_variant),\n-          lp: cmt.lp.map { |l| @lp_comp(l, comp_variant) },\n+          cat: cat_comp(cmt, comp_variant(enum_did)),\n+          lp: cmt.lp.map { |l| @lp_comp(l, comp_variant(enum_did)) },\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(arg)}\n     }"}, {"sha": "87980bf7248171a7da5a6f154023027b3eef4054", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -338,8 +338,16 @@ impl methods for gather_loan_ctxt {\n           }\n           ast::pat_enum(_, some(subpats)) {\n             // variant(x, y, z)\n+            let enum_did = alt self.bccx.tcx.def_map\n+.find(pat.id) {\n+              some(ast::def_variant(enum_did, _)) {enum_did}\n+              e {tcx.sess.span_bug(pat.span,\n+                                   #fmt[\"resolved to %?, \\\n+                                         not variant\", e])}\n+            };\n+\n             for subpats.each { |subpat|\n-                let subcmt = self.bccx.cat_variant(subpat, cmt);\n+                let subcmt = self.bccx.cat_variant(subpat, enum_did, cmt);\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n           }"}, {"sha": "ee61dd9f0cf6866f750131214d5934942a3c5516", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -65,24 +65,23 @@ impl loan_methods for loan_ctxt {\n             // that case, it must also be embedded in an immutable\n             // location, or else the whole structure could be\n             // overwritten and the component along with it.\n-            let base_mutbl = alt req_mutbl {\n-              m_imm { m_imm }\n-              m_const | m_mutbl { m_const }\n-            };\n-\n-            self.loan(cmt_base, base_mutbl);\n-            self.ok_with_loan_of(cmt, req_mutbl)\n+            self.loan_stable_comp(cmt, cmt_base, req_mutbl)\n           }\n-          cat_comp(cmt1, comp_variant) |\n-          cat_deref(cmt1, _, uniq_ptr) {\n-            // Variant components: the base must be immutable, because\n-            // if it is overwritten, the types of the embedded data\n-            // could change.\n-            //\n-            // Unique pointers: the base must be immutable, because if\n-            // it is overwritten, the unique content will be freed.\n-            self.loan(cmt1, m_imm);\n-            self.ok_with_loan_of(cmt, req_mutbl)\n+          cat_comp(cmt_base, comp_variant(enum_did)) {\n+            // For enums, the memory is unstable if there are multiple\n+            // variants, because if the enum value is overwritten then\n+            // the memory changes type.\n+            if ty::enum_is_univariant(self.bccx.tcx, enum_did) {\n+                self.loan_stable_comp(cmt, cmt_base, req_mutbl)\n+            } else {\n+                self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n+            }\n+          }\n+          cat_deref(cmt_base, _, uniq_ptr) {\n+            // For unique pointers, the memory being pointed out is\n+            // unstable because if the unique pointer is overwritten\n+            // then the memory is freed.\n+            self.loan_unstable_deref(cmt, cmt_base, req_mutbl)\n           }\n           cat_deref(cmt1, _, unsafe_ptr) |\n           cat_deref(cmt1, _, gc_ptr) |\n@@ -94,4 +93,32 @@ impl loan_methods for loan_ctxt {\n           }\n         }\n     }\n+\n+    // A \"stable component\" is one where assigning the base of the\n+    // component cannot cause the component itself to change types.\n+    // Example: record fields.\n+    fn loan_stable_comp(cmt: cmt,\n+                        cmt_base: cmt,\n+                        req_mutbl: ast::mutability) {\n+        let base_mutbl = alt req_mutbl {\n+          m_imm { m_imm }\n+          m_const | m_mutbl { m_const }\n+        };\n+\n+        self.loan(cmt_base, base_mutbl);\n+        self.ok_with_loan_of(cmt, req_mutbl)\n+    }\n+\n+    // An \"unstable deref\" means a deref of a ptr/comp where, if the\n+    // base of the deref is assigned to, pointers into the result of the\n+    // deref would be invalidated. Examples: interior of variants, uniques.\n+    fn loan_unstable_deref(cmt: cmt,\n+                           cmt_base: cmt,\n+                           req_mutbl: ast::mutability) {\n+        // Variant components: the base must be immutable, because\n+        // if it is overwritten, the types of the embedded data\n+        // could change.\n+        self.loan(cmt_base, m_imm);\n+        self.ok_with_loan_of(cmt, req_mutbl)\n+    }\n }"}, {"sha": "98c9109fe8edf032d53662a109ba02396fb9408d", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -17,7 +17,7 @@ impl public_methods for borrowck_ctxt {\n           }\n           cat_local(_) {\n             // Normally, local variables are lendable, and so this\n-            // case should never trigged.  However, if we are\n+            // case should never trigger.  However, if we are\n             // preserving an expression like a.b where the field `b`\n             // has @ type, then it will recurse to ensure that the `a`\n             // is stable to try and avoid rooting the value `a.b`.  In\n@@ -43,10 +43,19 @@ impl public_methods for borrowck_ctxt {\n             // type never changes.\n             self.preserve(cmt_base, opt_scope_id)\n           }\n-          cat_comp(cmt_base, comp_variant) {\n-            self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_variant)\n+          cat_comp(cmt_base, comp_variant(enum_did)) {\n+            if ty::enum_is_univariant(self.tcx, enum_did) {\n+                self.preserve(cmt_base, opt_scope_id)\n+            } else {\n+                // If there are multiple variants: overwriting the\n+                // base could cause the type of this memory to change,\n+                // so require imm.\n+                self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_variant)\n+            }\n           }\n           cat_deref(cmt_base, _, uniq_ptr) {\n+            // Overwriting the base could cause this memory to be\n+            // freed, so require imm.\n             self.require_imm(cmt, cmt_base, opt_scope_id, err_mut_uniq)\n           }\n           cat_deref(_, _, region_ptr) {"}, {"sha": "2fd4374dc093b156557366ccee153bf662aff0dc", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -462,8 +462,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n-        let box_ty = node_id_type(bcx, pat_id);\n-        let box_no_addrspace = non_gc_box_cast(bcx, box, box_ty);\n+        let box_no_addrspace = non_gc_box_cast(bcx, box);\n         let unboxed = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]\n                          + vals_left, chk, exits);\n@@ -472,8 +471,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n \n     if any_uniq_pat(m, col) {\n         let box = Load(bcx, val);\n-        let box_ty = node_id_type(bcx, pat_id);\n-        let box_no_addrspace = non_gc_box_cast(bcx, box, box_ty);\n+        let box_no_addrspace = non_gc_box_cast(bcx, box);\n         let unboxed = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(dm, m, col, val),\n                          [unboxed] + vals_left, chk, exits);"}, {"sha": "2423f04d11fedb14380f17bf192ae94f5d673c6b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -50,6 +50,7 @@ import type_of::type_of; // Issue #1873\n import syntax::ast_map::{path, path_mod, path_name};\n \n import std::smallintmap;\n+import option::is_none;\n \n // Destinations\n \n@@ -380,10 +381,8 @@ fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n     {box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n-    let mk_ty = alt heap { heap_shared { ty::mk_imm_box }\n-                           heap_exchange { ty::mk_imm_uniq } };\n     let box = malloc_raw(bcx, t, heap);\n-    let non_gc_box = non_gc_box_cast(bcx, box, mk_ty(bcx.tcx(), t));\n+    let non_gc_box = non_gc_box_cast(bcx, box);\n     let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n@@ -750,6 +749,12 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n+      ty::ty_class(did,substs) {\n+        // Call the dtor if there is one\n+        option::map_default(ty::ty_dtor(bcx.tcx(), did), bcx) {|dt_id|\n+          trans_class_drop(bcx, v, dt_id, did, substs)\n+        }\n+      }\n       _ { bcx }\n     };\n     build_return(bcx);\n@@ -1207,7 +1212,8 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n     }\n }\n \n-fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n+// See [Note-arg-mode]\n+fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue_full\");\n     lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n@@ -1245,8 +1251,9 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n                     C_null(T_ptr(T_ptr(cx.ccx().tydesc_type))), llrawptr]);\n }\n \n-fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint) ->\n-   block {\n+// See [Note-arg-mode]\n+fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n+    -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let mut ti = none;\n     let td = get_tydesc(cx.ccx(), t, ti);\n@@ -2286,7 +2293,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n       }\n       some(none) { fn_id } // Not inlinable\n       none { // Not seen yet\n-        alt check csearch::maybe_get_item_ast(\n+        alt csearch::maybe_get_item_ast(\n             ccx.tcx, fn_id,\n             bind astencode::decode_inlined_item(_, _, ccx.maps, _, _)) {\n \n@@ -2326,6 +2333,10 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             trans_item(ccx, *item);\n             local_def(my_id)\n           }\n+          csearch::found_parent(_, _) {\n+              ccx.sess.bug(\"maybe_get_item_ast returned a found_parent \\\n+               with a non-item parent\");\n+          }\n           csearch::found(ast::ii_method(impl_did, mth)) {\n             ccx.external.insert(fn_id, some(mth.id));\n             let {bounds: impl_bnds, rp: _, ty: impl_ty} =\n@@ -2339,6 +2350,10 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             }\n             local_def(mth.id)\n           }\n+          csearch::found(ast::ii_dtor(dtor, nm, tps, parent_id)) {\n+              ccx.external.insert(fn_id, some(dtor.node.id));\n+              local_def(dtor.node.id)\n+          }\n         }\n       }\n     }\n@@ -2679,11 +2694,11 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n             let t = expr_ty(cx, base);\n             let val = alt check ty::get(t).struct {\n               ty::ty_box(_) {\n-                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n+                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n               ty::ty_uniq(_) {\n-                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n+                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n               ty::ty_res(_, _, _) {\n@@ -2711,10 +2726,11 @@ Before taking a pointer to the inside of a box it should be cast into address\n space 0. Otherwise the resulting (non-box) pointer will be in the wrong\n address space and thus be the wrong type.\n \"]\n-fn non_gc_box_cast(cx: block, val: ValueRef, t: ty::t) -> ValueRef {\n+fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n     #debug(\"non_gc_box_cast\");\n     add_comment(cx, \"non_gc_box_cast\");\n-    let non_gc_t = type_of_non_gc_box(cx.ccx(), t);\n+    assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) as uint == 1u);\n+    let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n     PointerCast(cx, val, non_gc_t)\n }\n \n@@ -3111,8 +3127,9 @@ fn body_contains_ret(body: ast::blk) -> bool {\n     cx.found\n }\n \n+// See [Note-arg-mode]\n fn trans_call_inner(\n-    in_cx: block,\n+    ++in_cx: block,\n     call_info: option<node_info>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n@@ -3240,8 +3257,8 @@ fn need_invoke(bcx: block) -> bool {\n           _ { }\n         }\n         cur = alt cur.parent {\n-          parent_some(next) { next }\n-          parent_none { ret false; }\n+          some(next) { next }\n+          none { ret false; }\n         }\n     }\n }\n@@ -3262,7 +3279,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     loop {\n         alt bcx.kind {\n           block_scope(inf) {\n-            if inf.cleanups.len() > 0u || bcx.parent == parent_none {\n+            if inf.cleanups.len() > 0u || is_none(bcx.parent) {\n                 f(inf); ret;\n             }\n           }\n@@ -3471,11 +3488,11 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n               some({id, _}) if id == scope_id { ret bcx_sid; }\n               _ {\n                 alt bcx_sid.parent {\n-                  parent_none {\n+                  none {\n                     bcx.tcx().sess.bug(\n                         #fmt[\"no enclosing scope with id %d\", scope_id]);\n                   }\n-                  parent_some(bcx_par) { bcx_par }\n+                  some(bcx_par) { bcx_par }\n                 }\n               }\n             }\n@@ -3785,7 +3802,10 @@ fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n+// [Note-arg-mode]\n+// ++ mode is temporary, due to how borrowck treats enums. With hope,\n+// will go away anyway when we get rid of modes.\n+fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     ret llptr;\n@@ -3878,11 +3898,8 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(e_ty) {\n-            let unit_ty = ty::mk_mach_uint(tcx, ast::ty_u8);\n-            let vec_ty = ty::mk_vec(tcx, {ty: unit_ty, mutbl: ast::m_imm});\n-            let unit_llty = type_of(ccx, unit_ty);\n-            let body = tvec::get_bodyptr(bcx, expr_res.val, vec_ty);\n-            let data = tvec::get_dataptr(bcx, body, unit_llty);\n+            let body = tvec::get_bodyptr(bcx, expr_res.val);\n+            let data = tvec::get_dataptr(bcx, body);\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n             ret bcx;\n@@ -3970,9 +3987,9 @@ fn trans_break_cont(bcx: block, to_end: bool)\n           _ {}\n         }\n         unwind = alt unwind.parent {\n-          parent_some(cx) { cx }\n+          some(cx) { cx }\n           // This is a return from a loop body block\n-          parent_none {\n+          none {\n             Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n             cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n             Unreachable(bcx);\n@@ -4090,7 +4107,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block(cx: fn_ctxt, parent: block_parent, +kind: block_kind,\n+fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n              name: str, opt_node_info: option<node_info>) -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -4099,19 +4116,10 @@ fn new_block(cx: fn_ctxt, parent: block_parent, +kind: block_kind,\n     let llbb: BasicBlockRef = str::as_c_str(s, {|buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n-    let bcx = @{llbb: llbb,\n-                mut terminated: false,\n-                mut unreachable: false,\n-                parent: parent,\n-                kind: kind,\n-                node_info: opt_node_info,\n-                fcx: cx};\n-    alt parent {\n-      parent_some(cx) {\n+    let bcx = mk_block(llbb, parent, kind, opt_node_info, cx);\n+    option::iter(parent) {|cx|\n         if cx.unreachable { Unreachable(bcx); }\n-      }\n-      _ {}\n-    }\n+    };\n     ret bcx;\n }\n \n@@ -4122,20 +4130,20 @@ fn simple_block_scope() -> block_kind {\n \n // Use this when you're at the top block of a function or the like.\n fn top_scope_block(fcx: fn_ctxt, opt_node_info: option<node_info>) -> block {\n-    ret new_block(fcx, parent_none, simple_block_scope(),\n+    ret new_block(fcx, none, simple_block_scope(),\n                   \"function top level\", opt_node_info);\n }\n \n fn scope_block(bcx: block,\n                opt_node_info: option<node_info>,\n                n: str) -> block {\n-    ret new_block(bcx.fcx, parent_some(bcx), simple_block_scope(),\n+    ret new_block(bcx.fcx, some(bcx), simple_block_scope(),\n                   n, opt_node_info);\n }\n \n fn loop_scope_block(bcx: block, loop_break: block, n: str,\n                     opt_node_info: option<node_info>) -> block {\n-    ret new_block(bcx.fcx, parent_some(bcx), block_scope({\n+    ret new_block(bcx.fcx, some(bcx), block_scope({\n         loop_break: some(loop_break),\n         mut cleanups: [],\n         mut cleanup_paths: [],\n@@ -4146,17 +4154,11 @@ fn loop_scope_block(bcx: block, loop_break: block, n: str,\n \n // Use this when you're making a general CFG BB within a scope.\n fn sub_block(bcx: block, n: str) -> block {\n-    ret new_block(bcx.fcx, parent_some(bcx), block_non_scope, n, none);\n+    new_block(bcx.fcx, some(bcx), block_non_scope, n, none)\n }\n \n fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n-    ret @{llbb: llbb,\n-          mut terminated: false,\n-          mut unreachable: false,\n-          parent: parent_none,\n-          kind: block_non_scope,\n-          node_info: none,\n-          fcx: fcx};\n+    mk_block(llbb, none, block_non_scope, none, fcx)\n }\n \n \n@@ -4231,8 +4233,8 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n           _ {}\n         }\n         cur = alt cur.parent {\n-          parent_some(next) { next }\n-          parent_none { assert option::is_none(upto); break; }\n+          some(next) { next }\n+          none { assert is_none(upto); break; }\n         };\n     }\n     alt leave {"}, {"sha": "3bac52a949a0b6ab7292fb86f79e3ce966611be4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -350,32 +350,44 @@ type node_info = {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-type block = @{\n+class block_ {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n-    llbb: BasicBlockRef,\n-    mut terminated: bool,\n-    mut unreachable: bool,\n-    parent: block_parent,\n+    let llbb: BasicBlockRef;\n+    let mut terminated: bool;\n+    let mut unreachable: bool;\n+    let parent: option<block>;\n     // The 'kind' of basic block this is.\n-    kind: block_kind,\n+    let kind: block_kind;\n     // info about the AST node this block originated from, if any\n-    node_info: option<node_info>,\n+    let node_info: option<node_info>;\n     // The function context for the function to which this block is\n     // attached.\n-    fcx: fn_ctxt\n-};\n+    let fcx: fn_ctxt;\n+    new(llbb: BasicBlockRef, parent: option<block>, -kind: block_kind,\n+        node_info: option<node_info>, fcx: fn_ctxt) {\n+        // sigh\n+        self.llbb = llbb; self.terminated = false; self.unreachable = false;\n+        self.parent = parent; self.kind = kind; self.node_info = node_info;\n+        self.fcx = fcx;\n+    }\n+}\n+\n+/* This must be enum and not type, or trans goes into an infinite loop (#2572)\n+ */\n+enum block = @block_;\n+\n+fn mk_block(llbb: BasicBlockRef, parent: option<block>, -kind: block_kind,\n+         node_info: option<node_info>, fcx: fn_ctxt) -> block {\n+   block(@block_(llbb, parent, kind, node_info, fcx))\n+}\n \n // First two args are retptr, env\n const first_real_arg: uint = 2u;\n \n-// FIXME move blocks to a class once those are finished, and simply use\n-// option<block> for this. (#2532)\n-enum block_parent { parent_none, parent_some(block), }\n-\n type result = {bcx: block, val: ValueRef};\n type result_t = {bcx: block, val: ValueRef, ty: ty::t};\n \n@@ -412,7 +424,11 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n }\n \n fn block_parent(cx: block) -> block {\n-    alt check cx.parent { parent_some(b) { b } }\n+    alt cx.parent {\n+      some(b) { b }\n+      none    { cx.sess().bug(#fmt(\"block_parent called on root block %?\",\n+                                   cx)); }\n+    }\n }\n \n // Accessors"}, {"sha": "f45bb4d5011eafeb8fcd91b14393453cafa6fafc", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -236,8 +236,8 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let mut cx = cx;\n     while option::is_none(cx.node_info) {\n         alt cx.parent {\n-          parent_some(b) { cx = b; }\n-          parent_none { fail; }\n+          some(b) { cx = b; }\n+          none { fail; }\n         }\n     }\n     let sp = option::get(cx.node_info).span;\n@@ -254,8 +254,8 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     }*/\n \n     let parent = alt cx.parent {\n-        parent_none { create_function(cx.fcx).node }\n-        parent_some(bcx) { create_block(bcx).node }\n+        none { create_function(cx.fcx).node }\n+        some(bcx) { create_block(bcx).node }\n     };\n     let file_node = create_file(cx.ccx(), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n@@ -658,8 +658,8 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.file.name);\n     let context = alt bcx.parent {\n-        parent_none { create_function(bcx.fcx).node }\n-        parent_some(_) { create_block(bcx).node }\n+        none { create_function(bcx.fcx).node }\n+        some(_) { create_block(bcx).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n                             loc.line as int, tymd.node);\n@@ -761,9 +761,10 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n             (nm, decl.output, ctor_id)\n           }\n           ast_map::class_ctor(ctor,_) {\n-            fcx.ccx.sess.span_bug(ctor.span, \"create_function: \\\n-                  expected a resource ctor here\"); }\n+            // FIXME: output type may be wrong (#2194)\n+            (nm, ctor.node.dec.output, ctor.node.id)\n           }\n+        }\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {"}, {"sha": "2b708467874203672ca6de04b2f64e27a308c0e5", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -9,7 +9,9 @@ import syntax::ast::*;\n import syntax::{visit, ast_util, ast_map};\n import syntax::ast_util::def_id_of_def;\n import syntax::attr;\n+import syntax::print::pprust::expr_to_str;\n import std::map::hashmap;\n+import driver::session::*;\n \n export map, find_reachable;\n \n@@ -58,7 +60,11 @@ fn traverse_export(cx: ctx, exp_id: node_id) {\n \n fn traverse_def_id(cx: ctx, did: def_id) {\n     if did.crate != local_crate { ret; }\n-    alt cx.tcx.items.get(did.node) {\n+    let n = alt cx.tcx.items.find(did.node) {\n+        none { ret; } // This can happen for self, for example\n+        some(n) { n }\n+    };\n+    alt n {\n       ast_map::node_item(item, _) { traverse_public_item(cx, item); }\n       ast_map::node_method(_, impl_id, _) { traverse_def_id(cx, impl_id); }\n       ast_map::node_native_item(item, _, _) { cx.rmap.insert(item.id, ()); }\n@@ -111,6 +117,10 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         cx.rmap.insert(ctor.node.id, ());\n         option::iter(m_dtor) {|dtor|\n             cx.rmap.insert(dtor.node.id, ());\n+            // dtors don't have attrs\n+            if tps.len() > 0u {\n+                traverse_inline_body(cx, dtor.node.body);\n+            }\n         }\n         for vec::each(items) {|item|\n             alt item.node {\n@@ -134,7 +144,13 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         alt e.node {\n           expr_path(_) {\n-            traverse_def_id(cx, def_id_of_def(cx.tcx.def_map.get(e.id)));\n+            alt cx.tcx.def_map.find(e.id) {\n+                some(d) {\n+                  traverse_def_id(cx, def_id_of_def(d));\n+                }\n+                none      { cx.tcx.sess.span_bug(e.span, #fmt(\"Unbound node \\\n+                  id %? while traversing %s\", e.id, expr_to_str(e))); }\n+            }\n           }\n           expr_field(_, _, _) {\n             alt cx.method_map.find(e.id) {"}, {"sha": "4b6e92aa5adaf202b3e8714d9d7bea3a4a362b28", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -257,6 +257,7 @@ impl methods for reflector {\n             };\n             self.visit(\"closure_ptr\", [self.c_uint(ckval)])\n           }\n+          ty::ty_unboxed_vec(mt) { self.bracketed_mt(\"vec\", mt, []) }\n         }\n     }\n }"}, {"sha": "2b21e3e954eafc3d0f84e54f0f72d28fbbcb12d6", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -93,6 +93,7 @@ const shape_send_tydesc: u8 = 29u8;\n const shape_rptr: u8 = 31u8;\n const shape_fixedvec: u8 = 32u8;\n const shape_slice: u8 = 33u8;\n+const shape_unboxed_vec: u8 = 34u8;\n \n fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n    ValueRef {\n@@ -225,6 +226,9 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n       ty::ty_float(ast::ty_f64) { [shape_f64] }\n       ty::ty_estr(ty::vstore_uniq) |\n       ty::ty_str {\n+        // FIXME: we want to emit this as a unique pointer to an unboxed vec,\n+        // but it doesn't work at the moment, since trans doesn't put\n+        // tydescs in string boxes...\n         let mut s = [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n@@ -265,13 +269,17 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> [u8] {\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n-      ty::ty_evec(mt, ty::vstore_uniq) |\n-      ty::ty_vec(mt) {\n-        let mut s = [shape_vec];\n+      ty::ty_unboxed_vec(mt) {\n+        let mut s = [shape_unboxed_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_substr(s, shape_of(ccx, mt.ty));\n         s\n       }\n+      ty::ty_evec(mt, ty::vstore_uniq) |\n+      ty::ty_vec(mt) {\n+        shape_of(ccx,\n+                 ty::mk_imm_uniq(ccx.tcx, ty::mk_unboxed_vec(ccx.tcx, mt)))\n+      }\n \n       ty::ty_estr(ty::vstore_fixed(n)) {\n         let mut s = [shape_fixedvec];"}, {"sha": "b220ec7cd42fe00407bfa5cb7f220354ba2223ae", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 31, "deletions": 66, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -5,11 +5,12 @@ import back::abi;\n import base::{call_memmove,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n-               dest, bcx_icx};\n+               dest, bcx_icx, non_gc_box_cast};\n import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;\n import common::*;\n+import util::ppaux::ty_to_str;\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n@@ -22,28 +23,14 @@ fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-fn get_bodyptr(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> ValueRef {\n-    let ccx = bcx.ccx();\n-    alt ty::get(vec_ty).struct {\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq)\n-      | ty::ty_vec(_) | ty::ty_str {\n-        let boxptr = PointerCast(bcx, vptr, T_ptr(T_box_header(ccx)));\n-        let bodyptr = GEPi(bcx, boxptr, [1u]);\n-        let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-        let llunit_ty = type_of::type_of(ccx, unit_ty);\n-        PointerCast(bcx, bodyptr, T_ptr(T_vec(ccx, llunit_ty)))\n-      }\n-      _ {\n-        vptr\n-      }\n-    }\n+fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n+    non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n }\n \n-fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n+fn get_dataptr(bcx: block, vptr: ValueRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n-    let ptr = GEPi(bcx, vptr, [0u, abi::vec_elt_elems]);\n-    PointerCast(bcx, ptr, T_ptr(unit_ty))\n+    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n@@ -57,17 +44,14 @@ fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n                   fill: ValueRef, alloc: ValueRef) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq_raw\");\n     let ccx = bcx.ccx();\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let llvecty = T_vec(ccx, llunitty);\n-    let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n-    let vecbodyty = unit_ty; // FIXME: This is not the correct type (#2536)\n+\n+    let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n+    let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n+\n     let {box, body} = base::malloc_unique_dyn(bcx, vecbodyty, vecsize);\n-    let boxptr = PointerCast(bcx, box,\n-                             T_unique_ptr(T_unique(bcx.ccx(), llvecty)));\n-    let bodyptr = PointerCast(bcx, body, T_ptr(llvecty));\n-    Store(bcx, fill, GEPi(bcx, bodyptr, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, bodyptr, [0u, abi::vec_elt_alloc]));\n-    ret {bcx: bcx, val: boxptr};\n+    Store(bcx, fill, GEPi(bcx, body, [0u, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, body, [0u, abi::vec_elt_alloc]));\n+    ret {bcx: bcx, val: box};\n }\n \n fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n@@ -86,19 +70,14 @@ fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n     let ccx = bcx.ccx();\n-    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let body_ptr = get_bodyptr(bcx, vptr);\n     let fill = get_fill(bcx, body_ptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let llvecty = T_vec(ccx, llunitty);\n-    let vecbodyty = unit_ty; // FIXME: This is not the correct type (#2536)\n+    let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n     let {box: newptr, body: new_body_ptr} =\n         base::malloc_unique_dyn(bcx, vecbodyty, size);\n-    let newptr = PointerCast(bcx, newptr,\n-                             T_unique_ptr(T_unique(bcx.ccx(), llvecty)));\n-    let new_body_ptr = PointerCast(bcx, new_body_ptr, T_ptr(llvecty));\n     call_memmove(bcx, new_body_ptr, body_ptr, size);\n \n     Store(bcx, fill, GEPi(bcx, new_body_ptr, [0u, abi::vec_elt_alloc]));\n@@ -167,8 +146,7 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n           ast::vstore_uniq {\n             let {bcx, val} = alloc_uniq(bcx, unit_ty, args.len());\n             add_clean_free(bcx, val, true);\n-            let body = get_bodyptr(bcx, val, vec_ty);\n-            let dataptr = get_dataptr(bcx, body, llunitty);\n+            let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n@@ -249,10 +227,8 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq {\n-        let body = tvec::get_bodyptr(cx, v, vec_ty);\n-        let base = tvec::get_dataptr(cx, body, llunitty);\n-        let len = tvec::get_fill(cx, body);\n-        (base, len)\n+        let body = tvec::get_bodyptr(cx, v);\n+        (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n       }\n       ty::vstore_box {\n         cx.ccx().sess.unimpl(\"unhandled tvec::get_base_and_len\");\n@@ -305,14 +281,11 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(ccx.tcx, vec_ty);\n     let strings = ty::type_is_str(vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n-    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n-    let rbody = get_bodyptr(bcx, rhs, vec_ty);\n-    let lfill = get_fill(bcx, lbody);\n-    let rfill = get_fill(bcx, rbody);\n+    let lfill = get_fill(bcx, get_bodyptr(bcx, lhs));\n+    let rfill = get_fill(bcx, get_bodyptr(bcx, rhs));\n     let mut new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n@@ -323,9 +296,9 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let lhs = Load(bcx, lhsptr);\n     let rhs = Select(bcx, self_append, lhs, rhs);\n \n-    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n+    let lbody = get_bodyptr(bcx, lhs);\n \n-    let lhs_data = get_dataptr(bcx, lbody, llunitty);\n+    let lhs_data = get_dataptr(bcx, lbody);\n     let mut lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n@@ -350,7 +323,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let scratch = base::alloca(bcx, elt_llty);\n     for vec::each(vals) {|val|\n         bcx = base::trans_expr_save_in(bcx, val, scratch);\n-        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr));\n         let old_fill = get_fill(bcx, vptr);\n         let new_fill = Add(bcx, old_fill, elt_sz);\n         let do_grow = ICmp(bcx, lib::llvm::IntUGT, new_fill,\n@@ -361,9 +334,9 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n             Call(bcx, ccx.upcalls.vec_grow, [pt, new_fill]);\n             bcx\n         };\n-        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr));\n         set_fill(bcx, vptr, new_fill);\n-        let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr, elt_llty),\n+        let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr),\n                                     old_fill);\n         call_memmove(bcx, targetptr, scratch, elt_sz);\n     }\n@@ -387,18 +360,15 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n         ret base::store_in_dest(bcx, n, dest);\n     }\n \n-    let lhs_body = get_bodyptr(bcx, lhs, vec_ty);\n-    let rhs_body = get_bodyptr(bcx, rhs, vec_ty);\n-\n-    let lhs_fill = get_fill(bcx, lhs_body);\n-    let rhs_fill = get_fill(bcx, rhs_body);\n+    let lhs_fill = get_fill(bcx, get_bodyptr(bcx, lhs));\n+    let rhs_fill = get_fill(bcx, get_bodyptr(bcx, rhs));\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let mut {bcx: bcx, val: new_vec_ptr} =\n         alloc_uniq_raw(bcx, unit_ty, new_fill, new_fill);\n \n-    let new_vec_body_ptr = get_bodyptr(bcx, new_vec_ptr, vec_ty);\n+    let new_vec_body_ptr = get_bodyptr(bcx, new_vec_ptr);\n     let write_ptr_ptr = do_spill_noroot\n-        (bcx, get_dataptr(bcx, new_vec_body_ptr, llunitty));\n+        (bcx, get_dataptr(bcx, new_vec_body_ptr));\n     let copy_fn = fn@(bcx: block, addr: ValueRef,\n                       _ty: ty::t) -> block {\n         let ccx = bcx.ccx();\n@@ -451,19 +421,14 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                  fill: ValueRef, f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n-    let ccx = bcx.ccx();\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n-    let data_ptr = get_dataptr(bcx, body_ptr, llunitty);\n+    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n-    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n-    let fill = get_fill(bcx, body_ptr);\n+    let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     ret iter_vec_uniq(bcx, vptr, vec_ty, fill, f);\n }\n "}, {"sha": "fb9112fc751ff88c0209d5d585f5db8e60444b4d", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -99,6 +99,9 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_vec(mt) {\n             T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n           }\n+          ty::ty_unboxed_vec(mt) {\n+            T_vec(cx, type_of(cx, mt.ty))\n+          }\n           ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n           ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n "}, {"sha": "8ffc0f36d2039a1a413ae27037ee5c22f38a9a4b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -68,7 +68,7 @@ export sty;\n export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n export t;\n export new_ty_hash;\n-export enum_variants, substd_enum_variants;\n+export enum_variants, substd_enum_variants, enum_is_univariant;\n export iface_methods, store_iface_methods, impl_iface;\n export enum_variant_with_id;\n export ty_dtor;\n@@ -88,6 +88,7 @@ export ty_str, mk_str, type_is_str;\n export ty_vec, mk_vec, type_is_vec;\n export ty_estr, mk_estr;\n export ty_evec, mk_evec;\n+export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n export ty_nil, mk_nil, type_is_nil;\n export ty_iface, mk_iface;\n@@ -378,6 +379,7 @@ enum sty {\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n     ty_opaque_closure_ptr(closure_kind), // ptr to env for fn, fn@, fn~\n+    ty_unboxed_vec(mt),\n }\n \n // In the middle end, constraints have a def_id attached, referring\n@@ -576,7 +578,8 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_enum(_, substs) | ty_class(_, substs) | ty_iface(_, substs) {\n         flags |= sflags(substs);\n       }\n-      ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) | ty_ptr(m) {\n+      ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) |\n+      ty_ptr(m) | ty_unboxed_vec(m) {\n         flags |= get(m.ty).flags;\n       }\n       ty_rptr(r, m) {\n@@ -671,6 +674,14 @@ fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_evec(tm, t))\n }\n \n+fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n+    mk_t(cx, ty_unboxed_vec(tm))\n+}\n+fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n+    mk_t(cx, ty_unboxed_vec({ty: ty, mutbl: ast::m_imm}))\n+}\n+\n+\n fn mk_rec(cx: ctxt, fs: [field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n fn mk_constr(cx: ctxt, t: t, cs: [@type_constr]) -> t {\n@@ -752,7 +763,7 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_var_integral(_) |\n       ty_param(_, _) {\n       }\n-      ty_box(tm) | ty_vec(tm) | ty_evec(tm, _) |\n+      ty_box(tm) | ty_vec(tm) | ty_evec(tm, _) | ty_unboxed_vec(tm) |\n       ty_ptr(tm) | ty_rptr(_, tm) {\n         maybe_walk_ty(tm.ty, f);\n       }\n@@ -801,6 +812,9 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_vec(tm) {\n         ty_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n+      ty_unboxed_vec(tm) {\n+        ty_unboxed_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+      }\n       ty_evec(tm, vst) {\n         ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n       }\n@@ -1155,7 +1169,7 @@ pure fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pure fn type_is_vec(ty: t) -> bool {\n     ret alt get(ty).struct {\n-          ty_vec(_) | ty_evec(_, _) { true }\n+          ty_vec(_) | ty_evec(_, _) | ty_unboxed_vec(_) { true }\n           ty_str | ty_estr(_) { true }\n           _ { false }\n         };\n@@ -1593,7 +1607,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_var(_) | ty_var_integral(_) {\n         cx.sess.bug(\"Asked to compute kind of a type variable\");\n       }\n-      ty_type | ty_opaque_closure_ptr(_) | ty_opaque_box {\n+      ty_type | ty_opaque_closure_ptr(_) | ty_opaque_box | ty_unboxed_vec(_) {\n         cx.sess.bug(\"Asked to compute kind of fictitious type\");\n       }\n     };\n@@ -1647,6 +1661,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_opaque_box |\n           ty_opaque_closure_ptr(_) |\n           ty_evec(_, _) |\n+          ty_unboxed_vec(_) |\n           ty_vec(_) {\n             false\n           }\n@@ -2052,38 +2067,35 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_box(mt) { hash_subty(19u, mt.ty) }\n       ty_evec(mt, _) { hash_subty(20u, mt.ty) }\n       ty_vec(mt) { hash_subty(21u, mt.ty) }\n+      ty_unboxed_vec(mt) { hash_subty(22u, mt.ty) }\n+      ty_tup(ts) { hash_subtys(25u, ts) }\n       ty_rec(fields) {\n         let mut h = 26u;\n         for fields.each {|f| h = hash_subty(h, f.mt.ty); }\n         h\n       }\n-      ty_tup(ts) { hash_subtys(25u, ts) }\n       ty_fn(f) {\n         let mut h = 27u;\n         for f.inputs.each {|a| h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n+      ty_self { 28u }\n       ty_var(v) { hash_uint(29u, v.to_uint()) }\n       ty_var_integral(v) { hash_uint(30u, v.to_uint()) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n-      ty_self { 28u }\n       ty_type { 32u }\n       ty_bot { 34u }\n       ty_ptr(mt) { hash_subty(35u, mt.ty) }\n-      ty_rptr(region, mt) {\n-        let mut h = (46u << 2u) + hash_region(region);\n-        hash_subty(h, mt.ty)\n-      }\n-      ty_res(did, sub, substs) {\n-        let mut h = hash_subty(hash_def(18u, did), sub);\n-        hash_substs(h, substs)\n-      }\n       ty_constr(t, cs) {\n         let mut h = hash_subty(36u, t);\n         for cs.each {|c| h = (h << 2u) + hash_type_constr(h, c); }\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n+      ty_res(did, sub, substs) {\n+        let mut h = hash_subty(hash_def(38u, did), sub);\n+        hash_substs(h, substs)\n+      }\n       ty_iface(did, substs) {\n         let mut h = hash_def(40u, did);\n         hash_substs(h, substs)\n@@ -2096,6 +2108,10 @@ fn hash_type_structure(st: sty) -> uint {\n         let mut h = hash_def(45u, did);\n         hash_substs(h, substs)\n       }\n+      ty_rptr(region, mt) {\n+        let mut h = (46u << 2u) + hash_region(region);\n+        hash_subty(h, mt.ty)\n+      }\n     }\n }\n \n@@ -2411,6 +2427,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> str {\n       ty_box(_) { \"@-ptr\" }\n       ty_uniq(_) { \"~-ptr\" }\n       ty_evec(_, _) | ty_vec(_) { \"vector\" }\n+      ty_unboxed_vec(_) { \"unboxed vector\" }\n       ty_ptr(_) { \"*-ptr\" }\n       ty_rptr(_, _) { \"&-ptr\" }\n       ty_rec(_) { \"record\" }\n@@ -2663,6 +2680,10 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     }\n }\n \n+fn enum_is_univariant(cx: ctxt, id: ast::def_id) -> bool {\n+    vec::len(*enum_variants(cx, id)) == 1u\n+}\n+\n fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n     alt cx.enum_var_cache.find(id) {\n       some(variants) { ret variants; }"}, {"sha": "3c60cb911fe4ad89f94d53e63981ee76fac50d30", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -8,7 +8,7 @@ import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_iface, ty_int};\n import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n import middle::ty::{ty_ptr, ty_rec, ty_res, ty_rptr, ty_self, ty_str, ty_tup};\n import middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n-import middle::ty::{ty_vec, vid};\n+import middle::ty::{ty_vec, ty_unboxed_vec, vid};\n import metadata::encoder;\n import syntax::codemap;\n import syntax::print::pprust;\n@@ -186,6 +186,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         }\n       }\n       ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n+      ty_unboxed_vec(tm) { \"unboxed_vec<\" + mt_to_str(cx, tm) + \">\" }\n       ty_type { \"type\" }\n       ty_rec(elems) {\n         let mut strs: [str] = [];"}, {"sha": "48083fdf3f4fdda920c65328bcc06950b6a4d5cc", "filename": "src/test/auxiliary/test_comm.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,108 @@\n+/*\n+  Minimized version of core::comm (with still-local modifications\n+  to turn a resource into a class) for testing. \n+\n+  Could probably be more minimal.\n+ */\n+\n+import libc::size_t;\n+\n+export port::{};\n+export port;\n+export recv;\n+\n+\n+#[doc = \"\n+A communication endpoint that can receive messages\n+\n+Each port has a unique per-task identity and may not be replicated or\n+transmitted. If a port value is copied, both copies refer to the same\n+port.  Ports may be associated with multiple `chan`s.\n+\"]\n+enum port<T: send> {\n+    port_t(@port_ptr<T>)\n+}\n+\n+#[doc = \"Constructs a port\"]\n+fn port<T: send>() -> port<T> {\n+    port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n+}\n+\n+class port_ptr<T:send> {\n+   let po: *rust_port;\n+   new(po: *rust_port) {\n+    #debug(\"in the port_ptr constructor\");\n+    self.po = po; }\n+   drop unsafe {\n+    #debug(\"in the port_ptr destructor\");\n+    task::unkillable {||\n+        let yield = 0u;\n+        let yieldp = ptr::addr_of(yield);\n+        rustrt::rust_port_begin_detach(self.po, yieldp);\n+        if yield != 0u {\n+            task::yield();\n+        }\n+        rustrt::rust_port_end_detach(self.po);\n+\n+        while rustrt::rust_port_size(self.po) > 0u as size_t {\n+            recv_::<T>(self.po);\n+        }\n+        rustrt::del_port(self.po);\n+    }\n+  }\n+}\n+\n+\n+#[doc = \"\n+Receive from a port.  If no data is available on the port then the\n+task will block until data becomes available.\n+\"]\n+fn recv<T: send>(p: port<T>) -> T { recv_((**p).po) }\n+\n+\n+#[doc = \"Receive on a raw port pointer\"]\n+fn recv_<T: send>(p: *rust_port) -> T {\n+    let yield = 0u;\n+    let yieldp = ptr::addr_of(yield);\n+    let mut res;\n+    res = rusti::init::<T>();\n+    rustrt::port_recv(ptr::addr_of(res) as *uint, p, yieldp);\n+\n+    if yield != 0u {\n+        // Data isn't available yet, so res has not been initialized.\n+        task::yield();\n+    } else {\n+        // In the absense of compiler-generated preemption points\n+        // this is a good place to yield\n+        task::yield();\n+    }\n+    ret res;\n+}\n+\n+\n+/* Implementation details */\n+\n+\n+enum rust_port {}\n+\n+type port_id = int;\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+\n+    fn new_port(unit_sz: libc::size_t) -> *rust_port;\n+    fn del_port(po: *rust_port);\n+    fn rust_port_begin_detach(po: *rust_port,\n+                              yield: *libc::uintptr_t);\n+    fn rust_port_end_detach(po: *rust_port);\n+    fn rust_port_size(po: *rust_port) -> libc::size_t;\n+    fn port_recv(dptr: *uint, po: *rust_port,\n+                 yield: *libc::uintptr_t);\n+}\n+\n+#[abi = \"rust-intrinsic\"]\n+native mod rusti {\n+    fn init<T>() -> T;\n+}\n+\n+"}, {"sha": "e7bb6b704a1948593f56017ea7a1b93272517f3b", "filename": "src/test/compile-fail/empty-vec-trailing-comma.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-vec-trailing-comma.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let v = [,]; //! ERROR unexpected token: ','\n+}"}, {"sha": "5ca39da8cb3c20a72dff67559667cc0ba3ebdc18", "filename": "src/test/run-pass/borrowck-newtype-issue-2573.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,16 @@\n+enum foo = {mut bar: baz};\n+\n+enum baz = @{mut baz: int};\n+\n+impl quuux for foo {\n+    fn frob() {\n+        really_impure(self.bar);\n+    }\n+}\n+\n+// Override default mode so that we are passing by value\n+fn really_impure(++bar: baz) {\n+    bar.baz = 3;\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "3b01c4aa076bc8cad6bb26f96f6ac68551b81497", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,19 @@\n+enum newtype {\n+    newtype(int)\n+}\n+\n+fn main() {\n+\n+    // Test that borrowck treats enums with a single variant\n+    // specially.\n+\n+    let x = @mut 5;\n+    let y = @mut newtype(3);\n+    let z = alt *y {\n+      newtype(b) {\n+        *x += 1;\n+        *x * b\n+      }\n+    };\n+    assert z == 18;\n+}\n\\ No newline at end of file"}, {"sha": "71b7c84410203ef46142ecbb744884af5e469119", "filename": "src/test/run-pass/explicit-i-suffix.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fexplicit-i-suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fexplicit-i-suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-i-suffix.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let x: int = 8i;\n+    let y = 9i;\n+    x + y;\n+\n+    let q: int = -8i;\n+    let r = -9i;\n+    q + r;\n+}"}, {"sha": "fe4f44caf08ec7015167979eb1b2cca28871bc02", "filename": "src/test/run-pass/leaky_comm.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fleaky_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fleaky_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleaky_comm.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,19 @@\n+// xfail-fast\n+// aux-build:test_comm.rs\n+\n+use test_comm;\n+\n+fn main() {\n+  let p = test_comm::port();\n+  \n+  alt none::<int> {\n+      none {}\n+      some(_) {\n+  if test_comm::recv(p) == 0 {\n+      #error(\"floop\");\n+  }\n+  else {\n+      #error(\"bloop\");\n+  }\n+      }}\n+}\n\\ No newline at end of file"}, {"sha": "80157c0e9388c817d055d69ab6da8fb2145539ff", "filename": "src/test/run-pass/log-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Flog-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Flog-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-str.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    assert \"[1, 2, 3]\" == sys::log_str([1, 2, 3]);\n-    assert #fmt[\"%?/%5?\", [1, 2, 3], \"hi\"] == \"[1, 2, 3]/ \\\"hi\\\"\";\n+    assert \"~[1, 2, 3]\" == sys::log_str([1, 2, 3]);\n+    assert #fmt[\"%?/%5?\", [1, 2, 3], \"hi\"] == \"~[1, 2, 3]/ \\\"hi\\\"\";\n }"}, {"sha": "473ffe9f11d696921f8c7a61398d81fbfae44824", "filename": "src/test/run-pass/vec-trailing-comma.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fvec-trailing-comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab9c900131d8224bc105fbeb0795a0f7001a0836/src%2Ftest%2Frun-pass%2Fvec-trailing-comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-trailing-comma.rs?ref=ab9c900131d8224bc105fbeb0795a0f7001a0836", "patch": "@@ -0,0 +1,10 @@\n+// Issue #2482.\n+\n+fn main() {\n+    let v1: [int] = [10, 20, 30,];\n+    let v2: [int] = [10, 20, 30];\n+    assert (v1[2] == v2[2]);\n+    let v3: [int] = [10,];\n+    let v4: [int] = [10];\n+    assert (v3[0] == v4[0]);\n+}"}]}