{"sha": "0f6e06b7c0262a6940b5161f3ac507084e7daea6", "node_id": "C_kwDOAAsO6NoAKDBmNmUwNmI3YzAyNjJhNjk0MGI1MTYxZjNhYzUwNzA4NGU3ZGFlYTY", "commit": {"author": {"name": "Oli Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2021-08-20T14:47:12Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-02T15:40:11Z"}, "message": "Lazily resolve type-alias-impl-trait defining uses\n\nby using an opaque type obligation to bubble up comparisons between opaque types and other types\n\nAlso uses proper obligation causes so that the body id works, because out of some reason nll uses body ids for logic instead of just diagnostics.", "tree": {"sha": "15591857240d68342f017dd1c238b92117286bec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15591857240d68342f017dd1c238b92117286bec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f6e06b7c0262a6940b5161f3ac507084e7daea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6e06b7c0262a6940b5161f3ac507084e7daea6", "html_url": "https://github.com/rust-lang/rust/commit/0f6e06b7c0262a6940b5161f3ac507084e7daea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f6e06b7c0262a6940b5161f3ac507084e7daea6/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d2b5984597202489c5e42461db530fa48e45a8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2b5984597202489c5e42461db530fa48e45a8e", "html_url": "https://github.com/rust-lang/rust/commit/8d2b5984597202489c5e42461db530fa48e45a8e"}], "stats": {"total": 4741, "additions": 2645, "deletions": 2096}, "files": [{"sha": "09b3bc5f73739be2945638d9507b95fbb047e334", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -124,8 +124,9 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+    let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(hir_owner).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         do_mir_borrowck(&infcx, input_body, promoted, false).0\n@@ -140,7 +141,7 @@ fn mir_borrowck<'tcx>(\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n-#[instrument(skip(infcx, input_body, input_promoted), level = \"debug\")]\n+#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,"}, {"sha": "205578c638acd5ea95a32ed9de794daf2b08dc06", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n@@ -54,27 +53,40 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (Ty<'tcx>, Span, OpaqueTyOrigin)>,\n         span: Span,\n     ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .filter_map(|(opaque_type_key, decl)| {\n+            .filter_map(|(opaque_type_key, (concrete_type, decl_span, origin))| {\n                 let substs = opaque_type_key.substs;\n-                let concrete_type = decl.concrete_ty;\n+                // FIXME: why are the spans in decl_span often DUMMY_SP?\n+                let span = decl_span.substitute_dummy(span);\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n                 let universal_substs = infcx.tcx.fold_regions(substs, &mut false, |region, _| {\n-                    let vid = self.universal_regions.to_region_vid(region);\n-                    subst_regions.push(vid);\n-                    self.definitions[vid].external_name.unwrap_or_else(|| {\n-                        infcx\n-                            .tcx\n-                            .sess\n-                            .delay_span_bug(span, \"opaque type with non-universal region substs\");\n-                        infcx.tcx.lifetimes.re_static\n-                    })\n+                    let vid = self.to_region_vid(region);\n+                    trace!(?vid);\n+                    let scc = self.constraint_sccs.scc(vid);\n+                    trace!(?scc);\n+                    match self.scc_values.universal_regions_outlived_by(scc).find_map(|lb| {\n+                        self.eval_equal(vid, lb).then_some(self.definitions[lb].external_name?)\n+                    }) {\n+                        Some(region) => {\n+                            let vid = self.universal_regions.to_region_vid(region);\n+                            subst_regions.push(vid);\n+                            region\n+                        }\n+                        None => {\n+                            subst_regions.push(vid);\n+                            infcx.tcx.sess.delay_span_bug(\n+                                span,\n+                                \"opaque type with non-universal region substs\",\n+                            );\n+                            infcx.tcx.lifetimes.re_static\n+                        }\n+                    }\n                 });\n \n                 subst_regions.sort();\n@@ -100,12 +112,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span,\n                 );\n \n-                check_opaque_type_parameter_valid(\n-                    infcx.tcx,\n-                    opaque_type_key,\n-                    OpaqueTypeDecl { concrete_ty: remapped_type, ..decl },\n-                )\n-                .then_some((opaque_type_key, remapped_type))\n+                check_opaque_type_parameter_valid(infcx.tcx, opaque_type_key, origin, span)\n+                    .then_some((opaque_type_key, remapped_type))\n             })\n             .collect()\n     }\n@@ -149,9 +157,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n fn check_opaque_type_parameter_valid(\n     tcx: TyCtxt<'_>,\n     opaque_type_key: OpaqueTypeKey<'_>,\n-    decl: OpaqueTypeDecl<'_>,\n+    origin: OpaqueTyOrigin,\n+    span: Span,\n ) -> bool {\n-    match decl.origin {\n+    match origin {\n         // No need to check return position impl trait (RPIT)\n         // because for type and const parameters they are correct\n         // by construction: we convert\n@@ -177,7 +186,6 @@ fn check_opaque_type_parameter_valid(\n         // Check these\n         OpaqueTyOrigin::TyAlias => {}\n     }\n-    let span = decl.definition_span;\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n     let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {"}, {"sha": "83c8ecba1f17aa78d86d2af0a8a8c76dbc69bf06", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -147,9 +147,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Return types are a bit more complex. They may contain opaque `impl Trait` types.\n         let mir_output_ty = body.local_decls[RETURN_PLACE].ty;\n         let output_span = body.local_decls[RETURN_PLACE].source_info.span;\n-        if let Err(terr) = self.eq_opaque_type_and_type(\n-            mir_output_ty,\n+        if let Err(terr) = self.eq_types(\n             normalized_output_ty,\n+            mir_output_ty,\n             Locations::All(output_span),\n             ConstraintCategory::BoringNoLocation,\n         ) {\n@@ -169,9 +169,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let user_provided_output_ty = user_provided_sig.output();\n             let user_provided_output_ty =\n                 self.normalize(user_provided_output_ty, Locations::All(output_span));\n-            if let Err(err) = self.eq_opaque_type_and_type(\n-                mir_output_ty,\n+            if let Err(err) = self.eq_types(\n                 user_provided_output_ty,\n+                mir_output_ty,\n                 Locations::All(output_span),\n                 ConstraintCategory::BoringNoLocation,\n             ) {"}, {"sha": "da270be5ef0a800dfde597cdb6238564dde498e6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 60, "deletions": 173, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,6 +5,7 @@ use std::{fmt, iter, mem};\n \n use either::Either;\n \n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::vec_map::VecMap;\n@@ -15,12 +16,9 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{\n-    InferCtxt, InferOk, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n-};\n+use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime, NllRegionVariableOrigin};\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n@@ -41,7 +39,7 @@ use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::Fallible;\n-use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n+use rustc_trait_selection::traits::{self, ObligationCause};\n \n use rustc_const_eval::transform::{\n     check_consts::ConstCx, promote_consts::is_const_fn_in_array_repeat_expression,\n@@ -75,7 +73,7 @@ macro_rules! span_mirbug {\n             $context.last_span,\n             &format!(\n                 \"broken MIR in {:?} ({:?}): {}\",\n-                $context.body.source.def_id(),\n+                $context.body().source.def_id(),\n                 $elem,\n                 format_args!($($message)*),\n             ),\n@@ -193,24 +191,40 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             let opaque_type_values =\n                 infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-            opaque_type_values\n+            let opaque_type_values = opaque_type_values\n                 .into_iter()\n-                .filter_map(|(opaque_type_key, mut decl)| {\n-                    decl.concrete_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                .filter_map(|(opaque_type_key, decl)| {\n+                    let def_id = body.source.def_id().expect_local();\n+                    let body_id = cx.tcx().hir().local_def_id_to_hir_id(def_id);\n+                    let cause = ObligationCause::misc(body.span, body_id);\n+                    let hidden = cx\n+                        .fully_perform_op(\n+                            Locations::All(body.span),\n+                            ConstraintCategory::OpaqueType,\n+                            CustomTypeOp::new(\n+                                |infcx| {\n+                                    Ok(decl\n+                                        .hidden_type(infcx, &cause, param_env)\n+                                        .map_err(|e| e.0)?)\n+                                },\n+                                || \"opaque_type_map\".to_string(),\n+                            ),\n+                        )\n+                        .unwrap();\n+                    let mut hidden_type = infcx.resolve_vars_if_possible(hidden.ty);\n                     trace!(\n                         \"finalized opaque type {:?} to {:#?}\",\n                         opaque_type_key,\n-                        decl.concrete_ty.kind()\n+                        hidden_type.kind()\n                     );\n-                    if decl.concrete_ty.has_infer_types_or_consts() {\n+                    if hidden_type.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n-                            body.span,\n-                            &format!(\"could not resolve {:#?}\", decl.concrete_ty.kind()),\n+                            hidden.span,\n+                            &format!(\"could not resolve {:#?}\", hidden_type.kind()),\n                         );\n-                        decl.concrete_ty = infcx.tcx.ty_error();\n+                        hidden_type = infcx.tcx.ty_error();\n                     }\n-                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = decl.concrete_ty.kind()\n-                    {\n+                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = hidden_type.kind() {\n                         *def_id == opaque_type_key.def_id\n                     } else {\n                         false\n@@ -242,10 +256,15 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                         );\n                         None\n                     } else {\n-                        Some((opaque_type_key, decl))\n+                        Some((opaque_type_key, (hidden_type, hidden.span, decl.origin)))\n                     }\n                 })\n-                .collect()\n+                .collect();\n+            // `hidden_type` may re-register an opaque type, so we need to clean out the\n+            // newly re-added types. Either we got here successfully, so they are irrelevant,\n+            // or we already errored anyway.\n+            let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+            opaque_type_values\n         },\n     );\n \n@@ -275,7 +294,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         borrowck_context,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body, promoted);\n+        let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n         verifier.errors_reported\n     };\n@@ -332,7 +351,6 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n-    body: &'b Body<'tcx>,\n     promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     last_span: Span,\n     errors_reported: bool,\n@@ -468,7 +486,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        let rval_ty = rvalue.ty(self.body, self.tcx());\n+        let rval_ty = rvalue.ty(self.body(), self.tcx());\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n@@ -527,10 +545,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n-        body: &'b Body<'tcx>,\n         promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier { body, promoted, cx, last_span: body.span, errors_reported: false }\n+        TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n+    }\n+\n+    fn body(&self) -> &Body<'tcx> {\n+        self.cx.body\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -555,7 +576,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n+        let mut place_ty = PlaceTy::from_ty(self.body().local_decls[place.local].ty);\n \n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n@@ -600,7 +621,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, promoted_body);\n+        let parent_body = mem::replace(&mut self.cx.body, promoted_body);\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n@@ -636,7 +657,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             self.cx.typeck_mir(promoted_body);\n         }\n \n-        self.body = parent_body;\n+        self.cx.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n         swap_constraints(self);\n \n@@ -698,7 +719,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }))\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::from(i).ty(self.body, tcx).ty;\n+                let index_ty = Place::from(i).ty(self.body(), tcx).ty;\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::from_ty(span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i))\n                 } else {\n@@ -907,7 +928,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, (Ty<'tcx>, Span, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -1057,17 +1078,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n+    fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+\n     fn unsized_feature_enabled(&self) -> bool {\n         let features = self.tcx().features();\n         features.unsized_locals || features.unsized_fn_params\n     }\n \n     /// Equate the inferred type and the annotated type for user type annotations\n+    #[instrument(skip(self), level = \"debug\")]\n     fn check_user_type_annotations(&mut self) {\n-        debug!(\n-            \"check_user_type_annotations: user_type_annotations={:?}\",\n-            self.user_type_annotations\n-        );\n+        debug!(?self.user_type_annotations);\n         for user_annotation in self.user_type_annotations {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n@@ -1208,130 +1231,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// Equates a type `anon_ty` that may contain opaque types whose\n-    /// values are to be inferred by the MIR.\n-    ///\n-    /// The type `revealed_ty` contains the same type as `anon_ty`, but with the\n-    /// hidden types for impl traits revealed.\n-    ///\n-    /// # Example\n-    ///\n-    /// Consider a piece of code like\n-    ///\n-    /// ```rust\n-    /// type Foo<U> = impl Debug;\n-    ///\n-    /// fn foo<T: Debug>(t: T) -> Box<Foo<T>> {\n-    ///      Box::new((t, 22_u32))\n-    /// }\n-    /// ```\n-    ///\n-    /// Here, the function signature would be something like\n-    /// `fn(T) -> Box<impl Debug>`. The MIR return slot would have\n-    /// the type with the opaque type revealed, so `Box<(T, u32)>`.\n-    ///\n-    /// In terms of our function parameters:\n-    ///\n-    /// * `anon_ty` would be `Box<Foo<T>>` where `Foo<T>` is an opaque type\n-    ///   scoped to this function (note that it is parameterized by the\n-    ///   generics of `foo`). Note that `anon_ty` is not just the opaque type,\n-    ///   but the entire return type (which may contain opaque types within it).\n-    /// * `revealed_ty` would be `Box<(T, u32)>`\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn eq_opaque_type_and_type(\n-        &mut self,\n-        revealed_ty: Ty<'tcx>,\n-        anon_ty: Ty<'tcx>,\n-        locations: Locations,\n-        category: ConstraintCategory,\n-    ) -> Fallible<()> {\n-        // Fast path for the common case.\n-        if !anon_ty.has_opaque_types() {\n-            if let Err(terr) = self.eq_types(anon_ty, revealed_ty, locations, category) {\n-                span_mirbug!(\n-                    self,\n-                    locations,\n-                    \"eq_opaque_type_and_type: `{:?}=={:?}` failed with `{:?}`\",\n-                    revealed_ty,\n-                    anon_ty,\n-                    terr\n-                );\n-            }\n-            return Ok(());\n-        }\n-\n-        let param_env = self.param_env;\n-        let body = self.body;\n-        let mir_def_id = body.source.def_id().expect_local();\n-\n-        debug!(?mir_def_id);\n-        self.fully_perform_op(\n-            locations,\n-            category,\n-            CustomTypeOp::new(\n-                |infcx| {\n-                    let mut obligations = ObligationAccumulator::default();\n-\n-                    let dummy_body_id = hir::CRATE_HIR_ID;\n-\n-                    // Replace the opaque types defined by this function with\n-                    // inference variables, creating a map. In our example above,\n-                    // this would transform the type `Box<Foo<T>>` (where `Foo` is an opaque type)\n-                    // to `Box<?T>`, returning an `opaque_type_map` mapping `{Foo<T> -> ?T}`.\n-                    // (Note that the key of the map is both the def-id of `Foo` along with\n-                    // any generic parameters.)\n-                    let output_ty = obligations.add(infcx.instantiate_opaque_types(\n-                        dummy_body_id,\n-                        param_env,\n-                        anon_ty,\n-                        locations.span(body),\n-                    ));\n-                    debug!(?output_ty, ?revealed_ty);\n-\n-                    // Make sure that the inferred types are well-formed. I'm\n-                    // not entirely sure this is needed (the HIR type check\n-                    // didn't do this) but it seems sensible to prevent opaque\n-                    // types hiding ill-formed types.\n-                    obligations.obligations.push(traits::Obligation::new(\n-                        ObligationCause::dummy(),\n-                        param_env,\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(revealed_ty.into()))\n-                            .to_predicate(infcx.tcx),\n-                    ));\n-                    obligations.add(\n-                        infcx\n-                            .at(&ObligationCause::dummy(), param_env)\n-                            .eq(output_ty, revealed_ty)?,\n-                    );\n-\n-                    debug!(\"equated\");\n-\n-                    Ok(InferOk { value: (), obligations: obligations.into_vec() })\n-                },\n-                || \"input_output\".to_string(),\n-            ),\n-        )?;\n-\n-        // Finally, if we instantiated the anon types successfully, we\n-        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n-        // prove that `T: Iterator` where `T` is the type we\n-        // instantiated it with).\n-        for (opaque_type_key, opaque_decl) in self.infcx.opaque_types() {\n-            self.fully_perform_op(\n-                locations,\n-                ConstraintCategory::OpaqueType,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        infcx.constrain_opaque_type(opaque_type_key, &opaque_decl);\n-                        Ok(InferOk { value: (), obligations: vec![] })\n-                    },\n-                    || \"opaque_type_map\".to_string(),\n-                ),\n-            )?;\n-        }\n-        Ok(())\n-    }\n-\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -1881,6 +1780,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn ensure_place_sized(&mut self, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.tcx();\n \n+        // This may contain opaque types, resolve them to the underlying\n+        // type if defined in the current function. Otherwise we can't\n+        // necessarily prove sizedness of the type.\n+        let ty = self.infcx.resolve_vars_if_possible(ty);\n+\n         // Erase the regions from `ty` to get a global type.  The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n@@ -2773,20 +2677,3 @@ impl NormalizeLocation for Location {\n         Locations::Single(self)\n     }\n }\n-\n-#[derive(Debug, Default)]\n-struct ObligationAccumulator<'tcx> {\n-    obligations: PredicateObligations<'tcx>,\n-}\n-\n-impl<'tcx> ObligationAccumulator<'tcx> {\n-    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n-        let InferOk { value, obligations } = value;\n-        self.obligations.extend(obligations);\n-        value\n-    }\n-\n-    fn into_vec(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-}"}, {"sha": "ccf8b44206aa8c0d17812ba676851a9a39b952e9", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,14 +1,15 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Const, Ty};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n-use crate::type_check::{Locations, TypeChecker};\n+use crate::type_check::{CustomTypeOp, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -65,10 +66,7 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n \n impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n     fn span(&self) -> Span {\n-        match self.locations {\n-            Locations::All(span) => span,\n-            Locations::Single(_) => DUMMY_SP,\n-        }\n+        self.locations.span(self.type_checker.body)\n     }\n \n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n@@ -137,4 +135,54 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n+\n+    fn constrain_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool) {\n+        let param_env = self.param_env();\n+        let span = self.span();\n+        let def_id = self.type_checker.body.source.def_id().expect_local();\n+        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n+        let cause = ObligationCause::misc(span, body_id);\n+        self.type_checker\n+            .fully_perform_op(\n+                self.locations,\n+                self.category,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        let (concrete_ty, opaque_type_key) =\n+                            match (a.kind(), b.kind(), a_is_expected) {\n+                                (ty::Opaque(..), ty::Opaque(..), true) => {\n+                                    (b, a.expect_opaque_type())\n+                                }\n+                                (ty::Opaque(..), ty::Opaque(..), false) => {\n+                                    (a, b.expect_opaque_type())\n+                                }\n+                                (ty::Opaque(..), _, _) => (b, a.expect_opaque_type()),\n+                                (_, ty::Opaque(..), _) => (a, b.expect_opaque_type()),\n+                                _ => span_bug!(\n+                                    span,\n+                                    \"no opaque types in constrain_opaque_type {:?}, {:?}\",\n+                                    a,\n+                                    b\n+                                ),\n+                            };\n+                        let mut result = self.type_checker.infcx.constrain_opaque_type(\n+                            param_env,\n+                            opaque_type_key,\n+                            concrete_ty,\n+                            span,\n+                        )?;\n+                        result.obligations.push(infcx.opaque_ty_obligation(\n+                            a,\n+                            b,\n+                            a_is_expected,\n+                            param_env,\n+                            cause,\n+                        ));\n+                        Ok(result)\n+                    },\n+                    || \"constrain_opaque_type\".to_string(),\n+                ),\n+            )\n+            .unwrap();\n+    }\n }"}, {"sha": "a944b2d87ac6d42ff850c260099ea3b0815a104e", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -728,6 +728,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         self.tcx.fold_regions(value, &mut false, |_region, _depth| self.next_nll_region_var(origin))\n     }\n \n+    #[instrument(level = \"debug\", skip(self, indices))]\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -738,22 +739,15 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\n-            \"replace_bound_regions_with_nll_infer_vars(value={:?}, all_outlive_scope={:?})\",\n-            value, all_outlive_scope,\n-        );\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n-            debug!(\"replace_bound_regions_with_nll_infer_vars: br={:?}\", br);\n+            debug!(?br);\n             let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                 scope: all_outlive_scope.to_def_id(),\n                 bound_region: br.kind,\n             }));\n             let region_vid = self.next_nll_region_var(origin);\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n-            debug!(\n-                \"replace_bound_regions_with_nll_infer_vars: liberated_region={:?} => {:?}\",\n-                liberated_region, region_vid\n-            );\n+            debug!(?liberated_region, ?region_vid);\n             region_vid\n         });\n         value\n@@ -768,6 +762,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n+    #[instrument(skip(self, indices))]\n     fn replace_late_bound_regions_with_nll_infer_vars(\n         &self,\n         mir_def_id: LocalDefId,\n@@ -779,6 +774,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n+                debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });"}, {"sha": "e2dbeef35b9d386716a87873485b03dbdda39340", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n-use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n+use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeFoldable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::traits::SelectionContext;\n@@ -46,7 +46,10 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n+        // Peeking into opaque types causes cycles if the current function declares said opaque\n+        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n+        // analysis that looks at the actual usage withhin this function\n+        if !ty.has_opaque_types() && !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -100,7 +103,10 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n         location: Location,\n     ) -> bool {\n         let ty = ccx.body.local_decls[local].ty;\n-        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n+        // Peeking into opaque types causes cycles if the current function declares said opaque\n+        // type. Thus we avoid short circuiting on the type and instead run the more expensive\n+        // analysis that looks at the actual usage withhin this function\n+        if !ty.has_opaque_types() && !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n@@ -148,7 +154,12 @@ impl<'mir, 'tcx> Qualifs<'mir, 'tcx> {\n \n             // If we know that all values of the return type are structurally matchable, there's no\n             // need to run dataflow.\n-            _ if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) => false,\n+            // Opaque types do not participate in const generics or pattern matching, so we can safely count them out.\n+            _ if ccx.body.return_ty().has_opaque_types()\n+                || !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n+            {\n+                false\n+            }\n \n             hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n@@ -395,6 +406,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n                     | ty::PredicateKind::Projection(_)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                     ty::PredicateKind::ObjectSafe(_) => {\n                         bug!(\"object safe predicate on function: {:#?}\", predicate)"}, {"sha": "4aeb6adfe45712fa2c57e00ba18333280c99d7c0", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -78,7 +78,6 @@ pub fn equal_up_to_regions<'tcx>(\n     }\n \n     // Normalize lifetimes away on both sides, then compare.\n-    let param_env = param_env.with_reveal_all_normalized(tcx);\n     let normalize = |ty: Ty<'tcx>| {\n         tcx.normalize_erasing_regions(\n             param_env,\n@@ -169,9 +168,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n         // Normalize projections and things like that.\n-        // FIXME: We need to reveal_all, as some optimizations change types in ways\n-        // that require unfolding opaque types.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n+        let param_env = self.param_env;\n         let src = self.tcx.normalize_erasing_regions(param_env, src);\n         let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n "}, {"sha": "2f4b3844430e38afaf4ac523d09de47a10f59317", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -44,6 +44,15 @@ where\n         self.0.iter().find(|(key, _)| k == key.borrow()).map(|elem| &elem.1)\n     }\n \n+    /// Gets a mutable reference to the value in the entry.\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Eq,\n+    {\n+        self.0.iter_mut().find(|(key, _)| k == key.borrow()).map(|elem| &mut elem.1)\n+    }\n+\n     /// Returns the any value corresponding to the supplied predicate filter.\n     ///\n     /// The supplied predicate will be applied to each (key, value) pair and it will return a\n@@ -63,7 +72,7 @@ where\n         // This should return just one element, otherwise it's a bug\n         assert!(\n             filter.next().is_none(),\n-            \"Collection {:?} should have just one matching element\",\n+            \"Collection {:#?} should have just one matching element\",\n             self\n         );\n         Some(value)"}, {"sha": "7a82b169c5720c5182a6e1ea5675c7873bcf178e", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -34,6 +34,12 @@ pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n+    /// Whether we should define opaque types\n+    /// or just treat them opaquely.\n+    /// Currently only used to prevent predicate\n+    /// matching from matching anything against opaque\n+    /// types.\n+    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -49,7 +55,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env }\n+        At { infcx: self, cause, param_env, define_opaque_types: true }\n     }\n }\n \n@@ -64,6 +70,10 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n+    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n+        Self { define_opaque_types, ..self }\n+    }\n+\n     /// Hacky routine for equating two impl headers in coherence.\n     pub fn eq_impl_headers(\n         self,\n@@ -194,7 +204,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -211,7 +221,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -226,7 +236,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -241,7 +251,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)"}, {"sha": "ecb50dd60973fdb5b84feff81e9158a7a8d0e454", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, Const, OpaqueTypeKey, ToPredicate, Ty, TyCtxt};\n use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n@@ -90,6 +90,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             var_values: inference_vars,\n             region_constraints: QueryRegionConstraints::default(),\n             certainty: Certainty::Proven, // Ambiguities are OK!\n+            opaque_types: vec![],\n             value: answer,\n         })\n     }\n@@ -134,14 +135,27 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n \n+        let opaque_types = self.take_opaque_types_for_query_response();\n+\n         Ok(QueryResponse {\n             var_values: inference_vars,\n             region_constraints,\n             certainty,\n             value: answer,\n+            opaque_types,\n         })\n     }\n \n+    fn take_opaque_types_for_query_response(&self) -> Vec<(OpaqueTypeKey<'tcx>, Vec<Ty<'tcx>>)> {\n+        self.inner\n+            .borrow_mut()\n+            .opaque_type_storage\n+            .take_opaque_types()\n+            .into_iter()\n+            .map(|(k, v)| (k, v.hidden_types.into_iter().map(|ht| ht.ty).collect()))\n+            .collect()\n+    }\n+\n     /// Given the (canonicalized) result to a canonical query,\n     /// instantiates the result so it can be used, plugging in the\n     /// values from the canonical query. (Note that the result may\n@@ -224,13 +238,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n-        let result_subst =\n-            self.query_response_substitution_guess(cause, original_values, query_response);\n+        let InferOk { value: result_subst, mut obligations } = self\n+            .query_response_substitution_guess(cause, param_env, original_values, query_response)?;\n \n         // Compute `QueryOutlivesConstraint` values that unify each of\n         // the original values `v_o` that was canonicalized into a\n         // variable...\n-        let mut obligations = vec![];\n \n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n@@ -345,20 +358,25 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             original_values, query_response,\n         );\n \n-        let result_subst =\n-            self.query_response_substitution_guess(cause, original_values, query_response);\n+        let mut value = self.query_response_substitution_guess(\n+            cause,\n+            param_env,\n+            original_values,\n+            query_response,\n+        )?;\n \n-        let obligations = self\n-            .unify_query_response_substitution_guess(\n+        value.obligations.extend(\n+            self.unify_query_response_substitution_guess(\n                 cause,\n                 param_env,\n                 original_values,\n-                &result_subst,\n+                &value.value,\n                 query_response,\n             )?\n-            .into_obligations();\n+            .into_obligations(),\n+        );\n \n-        Ok(InferOk { value: result_subst, obligations })\n+        Ok(value)\n     }\n \n     /// Given the original values and the (canonicalized) result from\n@@ -373,9 +391,10 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     fn query_response_substitution_guess<R>(\n         &self,\n         cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n         original_values: &OriginalQueryValues<'tcx>,\n         query_response: &Canonical<'tcx, QueryResponse<'tcx, R>>,\n-    ) -> CanonicalVarValues<'tcx>\n+    ) -> InferResult<'tcx, CanonicalVarValues<'tcx>>\n     where\n         R: Debug + TypeFoldable<'tcx>,\n     {\n@@ -475,7 +494,19 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 .collect(),\n         };\n \n-        result_subst\n+        let mut obligations = vec![];\n+\n+        // Carry all newly resolved opaque types to the caller's scope\n+        for (key, tys) in &query_response.value.opaque_types {\n+            let substs = substitute_value(self.tcx, &result_subst, key.substs);\n+            let opaque = self.tcx.mk_opaque(key.def_id, substs);\n+            for &ty in tys {\n+                let ty = substitute_value(self.tcx, &result_subst, ty);\n+                obligations.extend(self.handle_opaque_type(opaque, ty, cause, param_env)?);\n+            }\n+        }\n+\n+        Ok(InferOk { value: result_subst, obligations })\n     }\n \n     /// Given a \"guess\" at the values for the canonical variables in\n@@ -691,4 +722,14 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     fn forbid_inference_vars() -> bool {\n         true\n     }\n+\n+    fn constrain_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool) {\n+        self.obligations.push(self.infcx.opaque_ty_obligation(\n+            a,\n+            b,\n+            a_is_expected,\n+            self.param_env,\n+            self.cause.clone(),\n+        ));\n+    }\n }"}, {"sha": "5668b6c10b000e97f6ac8831addb98b258ba1866", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -51,6 +51,12 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n+    /// Whether we should define opaque types\n+    /// or just treat them opaquely.\n+    /// Currently only used to prevent predicate\n+    /// matching from matching anything against opaque\n+    /// types.\n+    pub define_opaque_types: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -322,6 +328,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// will first instantiate `b_vid` with a *generalized* version\n     /// of `a_ty`. Generalization introduces other inference\n     /// variables wherever subtyping could occur.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn instantiate(\n         &mut self,\n         a_ty: Ty<'tcx>,\n@@ -334,8 +341,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // Get the actual variable that b_vid has been inferred to\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n-        debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n-\n         // Generalize type of `a_ty` appropriately depending on the\n         // direction.  As an example, assume:\n         //\n@@ -348,10 +353,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n         let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n-        debug!(\n-            \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n-            a_ty, dir, b_vid, b_ty\n-        );\n+        debug!(?b_ty);\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n         if needs_wf {\n@@ -392,13 +394,13 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n+    #[instrument(skip(self), level = \"trace\")]\n     fn generalize(\n         &self,\n         ty: Ty<'tcx>,\n         for_vid: ty::TyVid,\n         dir: RelationDir,\n     ) -> RelateResult<'tcx, Generalization<'tcx>> {\n-        debug!(\"generalize(ty={:?}, for_vid={:?}, dir={:?}\", ty, for_vid, dir);\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -412,7 +414,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             RelationDir::SupertypeOf => ty::Contravariant,\n         };\n \n-        debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n+        trace!(?ambient_variance);\n \n         let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n@@ -421,8 +423,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             TypeVariableValue::Unknown { universe } => universe,\n         };\n \n-        debug!(\"generalize: for_universe = {:?}\", for_universe);\n-        debug!(\"generalize: trace = {:?}\", self.trace);\n+        trace!(?for_universe);\n+        trace!(?self.trace);\n \n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -439,12 +441,12 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n-                debug!(\"generalize: failure {:?}\", e);\n+                debug!(?e, \"failure\");\n                 return Err(e);\n             }\n         };\n         let needs_wf = generalize.needs_wf;\n-        debug!(\"generalize: success {{ {:?}, {:?} }}\", ty, needs_wf);\n+        trace!(?ty, ?needs_wf, \"success\");\n         Ok(Generalization { ty, needs_wf })\n     }\n "}, {"sha": "9f6c6d3184533c2f9fe674f35cb51d49d32ee007", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -75,9 +75,9 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         trace!(a = ?a.kind(), b = ?b.kind());\n \n         let infcx = self.fields.infcx;\n+\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n-        trace!(a = ?a.kind(), b = ?b.kind(), \"replacements\");\n \n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n@@ -92,6 +92,21 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n                 self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n             }\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+                if self.fields.define_opaque_types && did.is_local() =>\n+            {\n+                self.fields.obligations.push(infcx.opaque_ty_obligation(\n+                    a,\n+                    b,\n+                    self.a_is_expected(),\n+                    self.param_env(),\n+                    self.fields.trace.cause.clone(),\n+                ));\n+            }\n+\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n             }"}, {"sha": "d159c14b1cfb7f17109300a3db14d7012e11a0df", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -214,8 +214,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Closure(..)\n-            | ty::GeneratorWitness(..)\n-            | ty::Opaque(..) => t.super_fold_with(self),\n+            | ty::Opaque(..)\n+            | ty::GeneratorWitness(..) => t.super_fold_with(self),\n \n             ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n         }"}, {"sha": "c4c4eab261e86de313bfc901c565ed3fd4853477", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,7 +4,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -111,12 +111,20 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n+        self.fields.obligations.extend(obligations)\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(v, a)?;\n         sub.relate(v, b)?;\n         Ok(())\n     }\n+\n+    fn define_opaque_types(&self) -> bool {\n+        self.fields.define_opaque_types\n+    }\n }\n \n impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {"}, {"sha": "6bda44f0ef256cad3a40d4a5f22ff1d22d26f90a", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -22,7 +22,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n use rustc_middle::ty::{self, Ty};\n@@ -32,6 +32,10 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n+\n+    fn define_opaque_types(&self) -> bool;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     //\n@@ -41,6 +45,7 @@ pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n+#[instrument(skip(this), level = \"debug\")]\n pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n     this: &mut L,\n     a: Ty<'tcx>,\n@@ -49,15 +54,17 @@ pub fn super_lattice_tys<'a, 'tcx: 'a, L>(\n where\n     L: LatticeDir<'a, 'tcx>,\n {\n-    debug!(\"{}.lattice_tys({:?}, {:?})\", this.tag(), a, b);\n+    debug!(\"{}\", this.tag());\n \n     if a == b {\n         return Ok(a);\n     }\n \n     let infcx = this.infcx();\n+\n     let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n     let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n+\n     match (a.kind(), b.kind()) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n@@ -94,6 +101,22 @@ where\n             Ok(v)\n         }\n \n+        (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+            infcx.super_combine_tys(this, a, b)\n+        }\n+        (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+            if this.define_opaque_types() && did.is_local() =>\n+        {\n+            this.add_obligations(vec![infcx.opaque_ty_obligation(\n+                a,\n+                b,\n+                this.a_is_expected(),\n+                this.param_env(),\n+                this.cause().clone(),\n+            )]);\n+            Ok(a)\n+        }\n+\n         _ => infcx.super_combine_tys(this, a, b),\n     }\n }"}, {"sha": "bbd8e00146905e991e99051a11db70e329fef1af", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,7 +4,7 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, PredicateObligation};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -117,10 +117,18 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n+    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n+        self.fields.obligations.extend(obligations)\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(a, v)?;\n         sub.relate(b, v)?;\n         Ok(())\n     }\n+\n+    fn define_opaque_types(&self) -> bool {\n+        self.fields.define_opaque_types\n+    }\n }"}, {"sha": "15ce690479b1ac0fd74fd5f1a689a91139f62b16", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n \n     #[inline]\n-    fn opaque_types(&mut self) -> opaque_types::OpaqueTypeTable<'_, 'tcx> {\n+    pub fn opaque_types(&mut self) -> opaque_types::OpaqueTypeTable<'_, 'tcx> {\n         self.opaque_type_storage.with_log(&mut self.undo_log)\n     }\n \n@@ -291,6 +291,10 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n     pub defining_use_anchor: Option<LocalDefId>,\n \n+    /// Used by WF-checking to not have to figure out hidden types itself, but\n+    /// to just invoke type_of to get the already computed hidden type from typeck.\n+    pub reveal_defining_opaque_types: bool,\n+\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -546,6 +550,7 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: Option<LocalDefId>,\n+    reveal_defining_opaque_types: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -554,7 +559,12 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n+        InferCtxtBuilder {\n+            tcx: self,\n+            defining_use_anchor: None,\n+            fresh_typeck_results: None,\n+            reveal_defining_opaque_types: false,\n+        }\n     }\n }\n \n@@ -578,6 +588,13 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    /// WF-checking doesn't need to recompute opaque types and can instead use\n+    /// the type_of query to get them from typeck.\n+    pub fn reveal_defining_opaque_types(mut self) -> Self {\n+        self.reveal_defining_opaque_types = true;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -602,11 +619,17 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            reveal_defining_opaque_types,\n+            ref fresh_typeck_results,\n+        } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n+            reveal_defining_opaque_types,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n@@ -728,13 +751,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n+        define_opaque_types: bool,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n             cause: None,\n             param_env,\n             obligations: PredicateObligations::new(),\n+            define_opaque_types,\n         }\n     }\n \n@@ -1050,12 +1075,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tcx.mk_ty_var(self.next_ty_var_id(origin))\n     }\n \n+    pub fn next_ty_var_id_in_universe(\n+        &self,\n+        origin: TypeVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> TyVid {\n+        self.inner.borrow_mut().type_variables().new_var(universe, origin)\n+    }\n+\n     pub fn next_ty_var_in_universe(\n         &self,\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables().new_var(universe, origin);\n+        let vid = self.next_ty_var_id_in_universe(origin, universe);\n         self.tcx.mk_ty_var(vid)\n     }\n "}, {"sha": "5f4555a78f311786743da1fdd1996c2afc0dd310", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -24,6 +24,7 @@\n use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeVisitor};\n@@ -89,6 +90,8 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n+    fn constrain_opaque_type(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, a_is_expected: bool);\n+\n     fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n@@ -279,7 +282,6 @@ where\n         projection_ty: ty::ProjectionTy<'tcx>,\n         value_ty: Ty<'tcx>,\n     ) -> Ty<'tcx> {\n-        use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n         use rustc_span::DUMMY_SP;\n \n         match *value_ty.kind() {\n@@ -288,6 +290,8 @@ where\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: DUMMY_SP,\n                 });\n+                // FIXME(lazy-normalization): This will always ICE, because the recursive\n+                // call will end up in the _ arm below.\n                 self.relate_projection_ty(projection_ty, var);\n                 self.relate_projection_ty(other_projection_ty, var);\n                 var\n@@ -533,6 +537,8 @@ where\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, mut b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let infcx = self.infcx;\n+\n         let a = self.infcx.shallow_resolve(a);\n \n         if !D::forbid_inference_vars() {\n@@ -561,6 +567,35 @@ where\n \n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.infcx.super_combine_tys(self, a, b)\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n+                let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n+                let mut generalize = |ty, ty_is_expected| {\n+                    let var = infcx.next_ty_var_id_in_universe(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: self.delegate.span(),\n+                        },\n+                        ty::UniverseIndex::ROOT,\n+                    );\n+                    if ty_is_expected {\n+                        self.relate_ty_var((ty, var))\n+                    } else {\n+                        self.relate_ty_var((var, ty))\n+                    }\n+                };\n+                let (a, b) = match (a.kind(), b.kind()) {\n+                    (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n+                    (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+                    _ => unreachable!(),\n+                };\n+                self.delegate.constrain_opaque_type(a, b, true);\n+                trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n+                Ok(a)\n+            }\n+\n             (&ty::Projection(projection_ty), _)\n                 if D::normalization() == NormalizationStrategy::Lazy =>\n             {"}, {"sha": "3ba4b9427251cfb8a0bef8a3ed19fd2b74ba62f6", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 288, "deletions": 150, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,13 @@\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::{InferCtxt, InferOk};\n-use crate::traits;\n+use crate::infer::{InferCtxt, InferOk, InferResult};\n+use crate::traits::{self, PredicateObligation, PredicateObligations};\n+use hir::def_id::{DefId, LocalDefId};\n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n@@ -21,11 +24,71 @@ pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct OpaqueTypeDecl<'tcx> {\n     /// The opaque type (`ty::Opaque`) for this declaration.\n     pub opaque_type: Ty<'tcx>,\n \n+    /// The hidden types that have been inferred for this opaque type.\n+    /// There can be multiple, but they are all `lub`ed together at the end\n+    /// to obtain the canonical hidden type.\n+    pub hidden_types: Vec<OpaqueHiddenType<'tcx>>,\n+\n+    /// The origin of the opaque type.\n+    pub origin: hir::OpaqueTyOrigin,\n+}\n+\n+impl<'tcx> OpaqueTypeDecl<'tcx> {\n+    pub fn hidden_type(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<\n+        InferOk<'tcx, OpaqueHiddenType<'tcx>>,\n+        (TypeError<'tcx>, OpaqueHiddenType<'tcx>, OpaqueHiddenType<'tcx>),\n+    > {\n+        let mut value = self.hidden_types[0];\n+        let mut obligations = vec![];\n+        let mut error: Option<(_, _, OpaqueHiddenType<'tcx>)> = None;\n+        for &next in self.hidden_types[1..].iter() {\n+            // FIXME: make use of the spans to get nicer diagnostics!\n+            let res = match infcx.at(cause, param_env).eq(value.ty, next.ty) {\n+                Ok(res) => res,\n+                Err(e) => {\n+                    // Try to improve the span. Sometimes we have dummy spans, sometimes we are pointing\n+                    // at an if/match instead of at the arm that gave us the type, but later spans point\n+                    // to the right thing.\n+                    if let Some((_, _, old)) = &mut error {\n+                        old.span = old.span.substitute_dummy(next.span);\n+                        // Shrink the span if possible\n+                        if old.span.contains(next.span) {\n+                            old.span = next.span;\n+                        }\n+                    } else {\n+                        let mut next = next;\n+                        next.span = next.span.substitute_dummy(cause.span(infcx.tcx));\n+                        error = Some((e, value, next));\n+                    }\n+                    continue;\n+                }\n+            };\n+            obligations.extend(res.obligations);\n+            value.span = value.span.substitute_dummy(next.span);\n+            // Shrink the span if possible\n+            if value.span.contains(next.span) {\n+                value.span = next.span;\n+            }\n+        }\n+        match error {\n+            None => Ok(InferOk { value, obligations }),\n+            Some(e) => Err(e),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, TypeFoldable)]\n+pub struct OpaqueHiddenType<'tcx> {\n     /// The span of this particular definition of the opaque type. So\n     /// for example:\n     ///\n@@ -39,7 +102,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// In cases where the fn returns `(impl Trait, impl Trait)` or\n     /// other such combinations, the result is currently\n     /// over-approximated, but better than nothing.\n-    pub definition_span: Span,\n+    pub span: Span,\n \n     /// The type variable that represents the value of the opaque type\n     /// that we require. In other words, after we compile this function,\n@@ -53,22 +116,21 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// those that are arguments to `Foo` in the constraint above. (In\n     /// other words, `?C` should not include `'b`, even though it's a\n     /// lifetime parameter on `foo`.)\n-    pub concrete_ty: Ty<'tcx>,\n-\n-    /// The origin of the opaque type.\n-    pub origin: hir::OpaqueTyOrigin,\n+    pub ty: Ty<'tcx>,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    /// Replaces all opaque types in `value` with fresh inference variables\n+    /// Links the opaque type with the given hidden type\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n-    ///     impl Iterator<Item = impl Debug>\n+    ///     opaque = impl Iterator<Item = impl Debug>\n+    ///     hidden = std::vec::IntoIter<i32>\n     ///\n-    /// this method would create two type variables, `?0` and `?1`. It would\n-    /// return the type `?0` but also the obligations:\n+    /// this method would register the opaque type `impl Iterator` to have\n+    /// the hidden type `std::vec::IntoIter<i32>` and create the type variable\n+    /// `?1` but also the obligations:\n     ///\n-    ///     ?0: Iterator<Item = ?1>\n+    ///     std::vec::IntoIter<i32>: Iterator<Item = ?1>\n     ///     ?1: Debug\n     ///\n     /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n@@ -85,22 +147,73 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///   obligations\n     /// - `value` -- the value within which we are instantiating opaque types\n     /// - `value_span` -- the span where the value came from, used in error reporting\n-    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+    pub fn instantiate_opaque_types(\n         &self,\n-        body_id: hir::HirId,\n+        ty: Ty<'tcx>,\n+        opaque: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-        value_span: Span,\n-    ) -> InferOk<'tcx, T> {\n-        debug!(\n-            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n-             param_env={:?}, value_span={:?})\",\n-            value, body_id, param_env, value_span,\n-        );\n-        let mut instantiator =\n-            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n-        let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value, obligations: instantiator.obligations }\n+    ) -> Option<InferOk<'tcx, Ty<'tcx>>> {\n+        let mut obligations = vec![];\n+        let value = Instantiator { infcx: self, cause, param_env, obligations: &mut obligations }\n+            .fold_opaque_ty_new(opaque, |_, _| ty)?;\n+        Some(InferOk { value, obligations })\n+    }\n+\n+    pub fn handle_opaque_type(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<PredicateObligations<'tcx>, TypeError<'tcx>> {\n+        if a.references_error() || b.references_error() {\n+            return Ok(vec![]);\n+        }\n+        if self.defining_use_anchor.is_some() {\n+            let process = |a: Ty<'tcx>, b: Ty<'tcx>| {\n+                if !matches!(a.kind(), ty::Opaque(..)) {\n+                    return None;\n+                }\n+                self.instantiate_opaque_types(b, a, cause.clone(), param_env)\n+                    .map(|res| res.obligations)\n+            };\n+            if let Some(res) = process(a, b) {\n+                Ok(res)\n+            } else if let Some(res) = process(b, a) {\n+                Ok(res)\n+            } else {\n+                // Rerun equality check, but this time error out due to\n+                // different types.\n+                match self.at(cause, param_env).define_opaque_types(false).eq(a, b) {\n+                    Ok(_) => span_bug!(\n+                        cause.span,\n+                        \"opaque types are never equal to anything but themselves: {:#?}\",\n+                        (a, b)\n+                    ),\n+                    Err(e) => Err(e),\n+                }\n+            }\n+        } else {\n+            let (opaque_type, hidden_ty) = match (a.kind(), b.kind()) {\n+                (ty::Opaque(..), _) => (a, b),\n+                (_, ty::Opaque(..)) => (b, a),\n+                types => span_bug!(\n+                    cause.span,\n+                    \"opaque type obligations only work for opaque types: {:#?}\",\n+                    types\n+                ),\n+            };\n+            let key = opaque_type.expect_opaque_type();\n+            let origin = self.opaque_ty_origin_unchecked(key.def_id, cause.span);\n+            self.inner.borrow_mut().opaque_types().register(\n+                key,\n+                opaque_type,\n+                OpaqueHiddenType { ty: hidden_ty, span: cause.span },\n+                origin,\n+            );\n+            Ok(vec![])\n+        }\n     }\n \n     /// Given the map `opaque_types` containing the opaque\n@@ -268,18 +381,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     pub fn constrain_opaque_type(\n         &self,\n+        param_env: ty::ParamEnv<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-    ) {\n+        concrete_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> InferResult<'tcx, ()> {\n         let def_id = opaque_type_key.def_id;\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n \n         debug!(?concrete_ty);\n \n-        let first_own_region = match opaque_defn.origin {\n+        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n             hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n                 // We lower\n                 //\n@@ -323,24 +438,44 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             op: |r| {\n                 self.member_constraint(\n                     opaque_type_key.def_id,\n-                    opaque_defn.definition_span,\n+                    span,\n                     concrete_ty,\n                     r,\n                     &choice_regions,\n                 )\n             },\n         });\n+        Ok(InferOk { value: (), obligations: vec![] })\n     }\n \n-    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n-        let tcx = self.tcx;\n-        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    pub fn opaque_ty_obligation(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        a_is_expected: bool,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n+        PredicateObligation::new(\n+            cause,\n+            param_env,\n+            self.tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::OpaqueType(a, b))),\n+        )\n+    }\n+\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn opaque_type_origin(&self, opaque_def_id: DefId, span: Span) -> Option<OpaqueTyOrigin> {\n+        let def_id = opaque_def_id.as_local()?;\n+        let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = self.defining_use_anchor?;\n-        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n+\n         let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n             span_bug!(\n-                tcx.def_span(def_id),\n-                \"weird opaque type: {:#?}\",\n+                span,\n+                \"weird opaque type: {:#?}, {:#?}\",\n+                opaque_def_id,\n                 item_kind\n             )\n         };\n@@ -351,12 +486,26 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n             // Named `type Foo = impl Bar;`\n             hir::OpaqueTyOrigin::TyAlias => {\n-                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n+                may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n+        trace!(?origin);\n         in_definition_scope.then_some(*origin)\n     }\n \n+    #[instrument(skip(self), level = \"trace\")]\n+    fn opaque_ty_origin_unchecked(&self, opaque_def_id: DefId, span: Span) -> OpaqueTyOrigin {\n+        let def_id = opaque_def_id.as_local().unwrap();\n+        let origin = match self.tcx.hir().expect_item(def_id).kind {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n+            ref itemkind => {\n+                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", opaque_def_id, itemkind)\n+            }\n+        };\n+        trace!(?origin);\n+        origin\n+    }\n+\n     pub fn opaque_types(&self) -> OpaqueTypeMap<'tcx> {\n         self.inner.borrow().opaque_type_storage.opaque_types()\n     }\n@@ -434,177 +583,166 @@ where\n     }\n }\n \n+pub enum UseKind {\n+    DefiningUse,\n+    OpaqueUse,\n+}\n+\n+impl UseKind {\n+    pub fn is_defining(self) -> bool {\n+        match self {\n+            UseKind::DefiningUse => true,\n+            UseKind::OpaqueUse => false,\n+        }\n+    }\n+}\n+\n struct Instantiator<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n+    cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    value_span: Span,\n-    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+    obligations: &'a mut PredicateObligations<'tcx>,\n }\n \n impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn instantiate_opaque_types(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let Some(ty) = self.fold_opaque_ty_new(ty, |infcx, span| {\n+            infcx.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            })\n+        }) {\n+            return ty;\n+        }\n \n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside its definition scope \\\n-                             def_id={:?}\",\n-                            def_id,\n-                        );\n-                    }\n-                }\n+        ty\n+    }\n \n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n+    fn fold_opaque_ty_new(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        mk_ty: impl FnOnce(&InferCtxt<'_, 'tcx>, Span) -> Ty<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        // Check that this is `impl Trait` type is\n+        // declared by `parent_def_id` -- i.e., one whose\n+        // value we are inferring.  At present, this is\n+        // always true during the first phase of\n+        // type-check, but not always true later on during\n+        // NLL. Once we support named opaque types more fully,\n+        // this same scenario will be able to arise during all phases.\n+        //\n+        // Here is an example using type alias `impl Trait`\n+        // that indicates the distinction we are checking for:\n+        //\n+        // ```rust\n+        // mod a {\n+        //   pub type Foo = impl Iterator;\n+        //   pub fn make_foo() -> Foo { .. }\n+        // }\n+        //\n+        // mod b {\n+        //   fn foo() -> a::Foo { a::make_foo() }\n+        // }\n+        // ```\n+        //\n+        // Here, the return type of `foo` references an\n+        // `Opaque` indeed, but not one whose value is\n+        // presently being inferred. You can get into a\n+        // similar situation with closure return types\n+        // today:\n+        //\n+        // ```rust\n+        // fn foo() -> impl Iterator { .. }\n+        // fn bar() {\n+        //     let x = || foo(); // returns the Opaque assoc with `foo`\n+        // }\n+        // ```\n+        let opaque_type_key = ty.expect_opaque_type();\n+        if let Some(origin) = self.infcx.opaque_type_origin(opaque_type_key.def_id, self.cause.span)\n+        {\n+            return Some(self.fold_opaque_ty(ty, opaque_type_key, origin, mk_ty));\n+        }\n+\n+        debug!(?ty, \"encountered opaque outside its definition scope\",);\n+        None\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self, mk_ty), level = \"debug\")]\n     fn fold_opaque_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n+        mk_ty: impl FnOnce(&InferCtxt<'_, 'tcx>, Span) -> Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n \n-        // Use the same type variable if the exact same opaque type appears more\n-        // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) =\n-            infcx.inner.borrow().opaque_type_storage.get_decl(&opaque_type_key)\n-        {\n-            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n-            return opaque_defn.concrete_ty;\n-        }\n-\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span: self.value_span,\n-        });\n+        let ty_var = mk_ty(infcx, self.cause.span);\n \n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n-        let definition_span = self.value_span;\n+        let span = self.cause.span;\n \n         self.infcx.inner.borrow_mut().opaque_types().register(\n             OpaqueTypeKey { def_id, substs },\n-            OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n+            ty,\n+            OpaqueHiddenType { ty: ty_var, span },\n+            origin,\n         );\n \n         debug!(\"generated new type inference var {:?}\", ty_var.kind());\n \n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n-        self.obligations.reserve(item_bounds.len());\n         for (predicate, _) in item_bounds {\n             debug!(?predicate);\n             let predicate = predicate.subst(tcx, substs);\n-            debug!(?predicate);\n \n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n                 ty_op: |ty| match *ty.kind() {\n+                    // We can't normalize associated types from `rustc_infer`,\n+                    // but we can eagerly register inference variables for them.\n+                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => infcx.infer_projection(\n+                        self.param_env,\n+                        projection_ty,\n+                        self.cause.clone(),\n+                        0,\n+                        &mut self.obligations,\n+                    ),\n                     // Replace all other mentions of the same opaque type with the hidden type,\n                     // as the bounds must hold on the hidden type after all.\n                     ty::Opaque(def_id2, substs2) if def_id == def_id2 && substs == substs2 => {\n                         ty_var\n                     }\n-                    // Instantiate nested instances of `impl Trait`.\n-                    ty::Opaque(..) => self.instantiate_opaque_types_in_map(ty),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n-\n-            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n-                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => {\n-                        infcx.infer_projection(\n-                            self.param_env,\n-                            *projection_ty,\n-                            traits::ObligationCause::misc(self.value_span, self.body_id),\n-                            0,\n-                            &mut self.obligations,\n-                        )\n-                    }\n+                    ty::Opaque(..) => self.instantiate_opaque_types(ty),\n                     _ => ty,\n                 },\n                 lt_op: |lt| lt,\n                 ct_op: |ct| ct,\n             });\n-            debug!(?predicate);\n \n             if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.term.references_error() {\n+                    // No point on adding these obligations since there's a type error involved.\n                     return tcx.ty_error();\n                 }\n+                trace!(\"{:#?}\", projection.term);\n             }\n-\n-            let cause =\n-                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n-\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n-            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n+            self.obligations.push(traits::Obligation::new(\n+                self.cause.clone(),\n+                self.param_env,\n+                predicate,\n+            ));\n         }\n-\n         ty_var\n     }\n }"}, {"sha": "dc47272c4fe057bdea0fdfa2a7a92c33d3e84af8", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,11 @@\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_hir::OpaqueTyOrigin;\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty};\n use rustc_span::DUMMY_SP;\n \n-use crate::infer::InferCtxtUndoLogs;\n+use crate::infer::{InferCtxtUndoLogs, UndoLog};\n \n-use super::{OpaqueTypeDecl, OpaqueTypeMap};\n+use super::{OpaqueHiddenType, OpaqueTypeDecl, OpaqueTypeMap};\n \n #[derive(Default, Debug)]\n pub struct OpaqueTypeStorage<'tcx> {\n@@ -14,32 +14,25 @@ pub struct OpaqueTypeStorage<'tcx> {\n     // variables to get the concrete type, which can be used to\n     // 'de-opaque' OpaqueTypeDecl, after typeck is done with all functions.\n     pub opaque_types: OpaqueTypeMap<'tcx>,\n-\n-    /// A map from inference variables created from opaque\n-    /// type instantiations (`ty::Infer`) to the actual opaque\n-    /// type (`ty::Opaque`). Used during fallback to map unconstrained\n-    /// opaque type inference variables to their corresponding\n-    /// opaque type.\n-    pub opaque_types_vars: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n }\n \n impl<'tcx> OpaqueTypeStorage<'tcx> {\n     #[instrument(level = \"debug\")]\n-    pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'tcx>) {\n-        match self.opaque_types.remove(&key) {\n-            None => bug!(\"reverted opaque type inference that was never registered\"),\n-            Some(decl) => assert_ne!(self.opaque_types_vars.remove(decl.concrete_ty), None),\n+    pub(crate) fn remove(&mut self, key: OpaqueTypeKey<'tcx>, idx: usize) {\n+        if idx == 0 {\n+            match self.opaque_types.remove(&key) {\n+                None => bug!(\"reverted opaque type inference that was never registered: {:?}\", key),\n+                Some(_) => {}\n+            }\n+        } else {\n+            self.opaque_types.get_mut(&key).unwrap().hidden_types.drain(idx..);\n         }\n     }\n \n     pub fn get_decl(&self, key: &OpaqueTypeKey<'tcx>) -> Option<&OpaqueTypeDecl<'tcx>> {\n         self.opaque_types.get(key)\n     }\n \n-    pub fn get_opaque_type_for_infer_var(&self, key: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-        self.opaque_types_vars.get(key).copied()\n-    }\n-\n     pub fn opaque_types(&self) -> OpaqueTypeMap<'tcx> {\n         self.opaque_types.clone()\n     }\n@@ -76,9 +69,20 @@ pub struct OpaqueTypeTable<'a, 'tcx> {\n \n impl<'a, 'tcx> OpaqueTypeTable<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn register(&mut self, key: OpaqueTypeKey<'tcx>, decl: OpaqueTypeDecl<'tcx>) {\n-        self.undo_log.push(key);\n+    pub fn register(\n+        &mut self,\n+        key: OpaqueTypeKey<'tcx>,\n+        opaque_type: Ty<'tcx>,\n+        ty: OpaqueHiddenType<'tcx>,\n+        origin: OpaqueTyOrigin,\n+    ) {\n+        if let Some(decl) = self.storage.opaque_types.get_mut(&key) {\n+            decl.hidden_types.push(ty);\n+            self.undo_log.push(UndoLog::OpaqueTypes(key, decl.hidden_types.len()));\n+            return;\n+        }\n+        let decl = OpaqueTypeDecl { opaque_type, hidden_types: vec![ty], origin };\n         self.storage.opaque_types.insert(key, decl);\n-        self.storage.opaque_types_vars.insert(decl.concrete_ty, decl.opaque_type);\n+        self.undo_log.push(UndoLog::OpaqueTypes(key, 0));\n     }\n }"}, {"sha": "b60ffc1878be44a38f776b0d48e8a1c14ea648b3", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -28,6 +28,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))"}, {"sha": "d554d7d935c52c570d7873e9d321a2c12bb405ae", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -153,6 +153,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This function may have to perform normalizations, and hence it\n     /// returns an `InferOk` with subobligations that must be\n     /// processed.\n+    #[instrument(level = \"debug\", skip(self, region_bound_pairs_map))]\n     pub fn process_registered_region_obligations(\n         &self,\n         region_bound_pairs_map: &FxHashMap<hir::HirId, RegionBoundPairs<'tcx>>,\n@@ -164,8 +165,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             \"cannot process registered region obligations in a snapshot\"\n         );\n \n-        debug!(?param_env, \"process_registered_region_obligations()\");\n-\n         let my_region_obligations = self.take_registered_region_obligations();\n \n         for (body_id, RegionObligation { sup_type, sub_region, origin }) in my_region_obligations {"}, {"sha": "e0a8219beede1804189c126ae68242efb65707ec", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2,6 +2,7 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::infer::combine::ConstEquateRelation;\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -74,16 +75,16 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n-\n         if a == b {\n             return Ok(a);\n         }\n \n         let infcx = self.fields.infcx;\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n+\n         match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(_)), &ty::Infer(TyVar(_))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -121,6 +122,40 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(self.tcx().ty_error())\n             }\n \n+            (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n+                Ok(a)\n+            }\n+            (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..))\n+                if self.fields.define_opaque_types && did.is_local() =>\n+            {\n+                let mut generalize = |ty, ty_is_expected| {\n+                    let var = infcx.next_ty_var_id_in_universe(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: self.fields.trace.cause.span,\n+                        },\n+                        ty::UniverseIndex::ROOT,\n+                    );\n+                    self.fields.instantiate(ty, RelationDir::SubtypeOf, var, ty_is_expected)?;\n+                    Ok(infcx.tcx.mk_ty_var(var))\n+                };\n+                let (a, b) = if self.a_is_expected { (a, b) } else { (b, a) };\n+                let (a, b) = match (a.kind(), b.kind()) {\n+                    (&ty::Opaque(..), _) => (a, generalize(b, true)?),\n+                    (_, &ty::Opaque(..)) => (generalize(a, false)?, b),\n+                    _ => unreachable!(),\n+                };\n+                self.fields.obligations.push(infcx.opaque_ty_obligation(\n+                    a,\n+                    b,\n+                    true,\n+                    self.param_env(),\n+                    self.fields.trace.cause.clone(),\n+                ));\n+                Ok(a)\n+            }\n+\n             _ => {\n                 self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)"}, {"sha": "8f4abfde3010a7693f6aa054df4812f7fa223bf5", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -18,7 +18,7 @@ pub struct Snapshot<'tcx> {\n \n /// Records the \"undo\" data for a single operation that affects some form of inference variable.\n pub(crate) enum UndoLog<'tcx> {\n-    OpaqueTypes(OpaqueTypeKey<'tcx>),\n+    OpaqueTypes(OpaqueTypeKey<'tcx>, usize),\n     TypeVariables(type_variable::UndoLog<'tcx>),\n     ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n     IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n@@ -43,7 +43,6 @@ macro_rules! impl_from {\n \n // Upcast from a single kind of \"undoable action\" to the general enum\n impl_from! {\n-    OpaqueTypes(OpaqueTypeKey<'tcx>),\n     RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n     TypeVariables(type_variable::UndoLog<'tcx>),\n \n@@ -66,7 +65,7 @@ impl_from! {\n impl<'tcx> Rollback<UndoLog<'tcx>> for InferCtxtInner<'tcx> {\n     fn reverse(&mut self, undo: UndoLog<'tcx>) {\n         match undo {\n-            UndoLog::OpaqueTypes(key) => self.opaque_type_storage.remove(key),\n+            UndoLog::OpaqueTypes(key, idx) => self.opaque_type_storage.remove(key, idx),\n             UndoLog::TypeVariables(undo) => self.type_variable_storage.reverse(undo),\n             UndoLog::ConstUnificationTable(undo) => self.const_unification_storage.reverse(undo),\n             UndoLog::IntUnificationTable(undo) => self.int_unification_storage.reverse(undo),"}, {"sha": "6600d5e4d0279a3f3303ab0eeada9d47f9e11f71", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -167,6 +167,9 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n+            ty::PredicateKind::OpaqueType(..) => {\n+                todo!(\"{:#?}\", obligation)\n+            }\n             ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates."}, {"sha": "442e756715b779bec738f31e7b9cb2f1ce65c487", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1654,6 +1654,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n+                OpaqueType(..) |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {"}, {"sha": "cc83010580f987b97cb8ea04e6599ea42d3362f3", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -23,7 +23,7 @@\n \n use crate::infer::MemberConstraint;\n use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, List, Region, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, List, OpaqueTypeKey, Region, Ty, TyCtxt};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use smallvec::SmallVec;\n@@ -178,6 +178,9 @@ pub struct QueryResponse<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub certainty: Certainty,\n+    /// List of opaque types for which we figured out a hidden type\n+    /// during the evaluation of the query.\n+    pub opaque_types: Vec<(OpaqueTypeKey<'tcx>, Vec<Ty<'tcx>>)>,\n     pub value: R,\n }\n "}, {"sha": "2642bddb9a4d33509467e6151330a203107e4a45", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -53,17 +53,17 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         self.relate(a, b)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn regions(\n         &mut self,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         Ok(a)\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }"}, {"sha": "7394bc5b2d8dd45c8382748b95d4096a2094aef7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -265,6 +265,10 @@ impl FlagComputation {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n+            ty::PredicateKind::OpaqueType(opaque, ty) => {\n+                self.add_ty(opaque);\n+                self.add_ty(ty);\n+            }\n         }\n     }\n "}, {"sha": "2fd0ca423cc944ff4de0ad0b6c59e0cc0e515d96", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1207,15 +1207,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n-    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n-            t,\n-            t.flags(),\n-            self.flags\n-        );\n-        if t.flags().intersects(self.flags) {\n+    #[instrument(skip(self), level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = t.flags();\n+        trace!(t.flags=?t.flags());\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n             ControlFlow::CONTINUE\n@@ -1235,7 +1231,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\")]\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);"}, {"sha": "d052b87577d2cf711b474cad63e7e86d5b74f9ca", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -628,6 +628,11 @@ pub enum PredicateKind<'tcx> {\n     ///\n     /// Only used for Chalk.\n     TypeWellFormedFromEnv(Ty<'tcx>),\n+\n+    /// Represents a hidden type assignment for an opaque type.\n+    /// Such obligations get processed by checking whether the item currently being\n+    /// type-checked may acually define it.\n+    OpaqueType(Ty<'tcx>, Ty<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -987,6 +992,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::OpaqueType(..)\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1005,6 +1011,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::OpaqueType(..)\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1045,7 +1052,18 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, TypeFoldable)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    HashStable,\n+    TyEncodable,\n+    TyDecodable,\n+    TypeFoldable,\n+    Lift\n+)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "62a0143817a9c7687b3013dccc09e7283b1db009", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2607,6 +2607,9 @@ define_print_and_forward_display! {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n+            ty::PredicateKind::OpaqueType(a, b) => {\n+                p!(\"opaque type assigment with `\", print(a), \"` == `\", print(b) ,\"`\")\n+            }\n         }\n     }\n "}, {"sha": "ef54832791d41a23558edad81edd6606442b39a8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -191,6 +191,9 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n+            ty::PredicateKind::OpaqueType(a, b) => {\n+                write!(f, \"OpaqueType({:?}, {:?})\", a.kind(), b.kind())\n+            }\n         }\n     }\n }\n@@ -463,6 +466,9 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 tcx.lift(ty).map(ty::PredicateKind::TypeWellFormedFromEnv)\n             }\n+            ty::PredicateKind::OpaqueType(opaque, ty) => {\n+                Some(ty::PredicateKind::OpaqueType(tcx.lift(opaque)?, tcx.lift(ty)?))\n+            }\n         }\n     }\n }"}, {"sha": "6b187f7da4c6d2f18781748fc0fe1abcb849c71b", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1816,6 +1816,13 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn expect_opaque_type(&self) -> ty::OpaqueTypeKey<'tcx> {\n+        match *self.kind() {\n+            Opaque(def_id, substs) => ty::OpaqueTypeKey { def_id, substs },\n+            _ => bug!(\"`expect_opaque_type` called on non-opaque type: {}\", self),\n+        }\n+    }\n+\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {"}, {"sha": "8cb19baa29230d15652b48fe8ec33a076b795c05", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n+use rustc_middle::{mir::*, ty};\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n use rustc_span::Span;\n@@ -192,7 +192,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // This return type is usually `()`, unless the block is diverging, in which case the\n             // return type is `!`. For the unit type, we need to actually return the unit, but in\n             // the case of `!`, no return value is required, as the block will never return.\n-            if destination_ty.is_unit() {\n+            // Opaque types of empty bodies also need this unit assignment, in order to infer that their\n+            // type is actually unit. Otherwise there will be no defining use found in the MIR.\n+            if destination_ty.is_unit() || matches!(destination_ty.kind(), ty::Opaque(..)) {\n                 // We only want to assign an implicit `()` as the return value of the block if the\n                 // block does not diverge. (Otherwise, we may try to assign a unit to a `!`-type.)\n                 this.cfg.push_assign_unit(block, source_info, destination, this.tcx);"}, {"sha": "545a7bc7d7d8a1995f059b0f1bc582336ba3fd61", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -186,7 +186,6 @@ impl<K: DepKind> EncoderState<K> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self, record_graph))]\n     fn encode_node(\n         &mut self,\n         node: &NodeInfo<K>,\n@@ -213,7 +212,6 @@ impl<K: DepKind> EncoderState<K> {\n             stat.edge_counter += edge_count as u64;\n         }\n \n-        debug!(?index, ?node);\n         let encoder = &mut self.encoder;\n         if self.result.is_ok() {\n             self.result = node.encode(encoder);"}, {"sha": "6b0910b475ff21893020d5e8315e2f7d2b301ce6", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -359,6 +359,7 @@ crate fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty"}, {"sha": "da04fb2cd2104241d99dc0ae180a2fb774c39baf", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -853,6 +853,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n             };\n         }"}, {"sha": "8624137d77687692f4041d78b8fd141d669b0403", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -775,6 +775,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n+\n+                    ty::PredicateKind::OpaqueType(..) => {\n+                        todo!(\"{:#?}\", obligation);\n+                    }\n                 }\n             }\n "}, {"sha": "68dd1cd2616837a6cd38df6e54c094c227402bff", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -397,6 +397,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::OpaqueType(..) => {\n+                    todo!(\"{:#?}\", obligation);\n+                }\n             },\n             Some(pred) => match pred {\n                 ty::PredicateKind::Trait(data) => {\n@@ -642,6 +645,20 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::OpaqueType(a, b) => {\n+                    match self.selcx.infcx().handle_opaque_type(\n+                        a,\n+                        b,\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                    ) {\n+                        Ok(value) => ProcessResult::Changed(mk_pending(value)),\n+                        Err(err) => ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n+                            ExpectedFound::new(true, a, b),\n+                            err,\n+                        )),\n+                    }\n+                }\n             },\n         }\n     }"}, {"sha": "cd6f381333ad0c4c21da8b6e5e892a3c3eb7a5d7", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -313,6 +313,7 @@ fn predicate_references_self<'tcx>(\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }\n@@ -347,6 +348,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }\n     })"}, {"sha": "3aa5ee366f78fa23d4f7284fcd2f2225a35cea5d", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{InferCtxt, InferOk};\n use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n-use crate::traits::{ObligationCause, TraitEngine};\n+use crate::traits::TraitEngine;\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -60,7 +60,6 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n ) -> Fallible<TypeOpOutput<'tcx, Op>> {\n     let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-    let dummy_body_id = ObligationCause::dummy().body_id;\n \n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n@@ -75,7 +74,6 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n     fulfill_cx.register_predicate_obligations(infcx, obligations);\n     let errors = fulfill_cx.select_all_or_error(infcx);\n     if !errors.is_empty() {"}, {"sha": "0c5d764e79d0cb25a472294b607a3dbb71ce5e48", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -254,6 +254,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n+            debug!(ty = ?obligation.predicate.skip_binder().self_ty(), \"ambiguous inference var or opaque type\");\n             // Self is a type variable (e.g., `_: AsRef<str>`).\n             //\n             // This is somewhat problematic, as the current scheme can't really"}, {"sha": "3b99183d8eb1ffc37c2b0f1b7bd8163b92adb5bb", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -37,6 +37,7 @@ use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n+use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n@@ -697,6 +698,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n+                ty::PredicateKind::OpaqueType(a, b) => {\n+                    match self.infcx().handle_opaque_type(\n+                        a,\n+                        b,\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                    ) {\n+                        Ok(obligations) => {\n+                            self.evaluate_predicates_recursively(previous_stack, obligations)\n+                        }\n+                        Err(_) => Ok(EvaluatedToErr),\n+                    }\n+                }\n             }\n         });\n \n@@ -1337,6 +1351,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, param_env, cache_fresh_trait_pred, dep_node), level = \"debug\")]\n     fn insert_candidate_cache(\n         &mut self,\n         mut param_env: ty::ParamEnv<'tcx>,\n@@ -1377,17 +1392,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a projection, look at the bounds of `T::Bar`, see if we can find a\n     /// `Baz` bound. We return indexes into the list returned by\n     /// `tcx.item_bounds` for any applicable bounds.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> smallvec::SmallVec<[usize; 2]> {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(obligation.predicate);\n         let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(poly_trait_predicate);\n-        debug!(\n-            ?placeholder_trait_predicate,\n-            \"match_projection_obligation_against_definition_bounds\"\n-        );\n+        debug!(?placeholder_trait_predicate);\n \n         let tcx = self.infcx.tcx;\n         let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n@@ -1438,7 +1451,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .collect();\n \n-        debug!(?matching_bounds, \"match_projection_obligation_against_definition_bounds\");\n+        debug!(?matching_bounds);\n         matching_bounds\n     }\n \n@@ -1468,6 +1481,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n@@ -1523,6 +1537,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            .define_opaque_types(false)\n             .sup(obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n@@ -2081,11 +2096,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => substs,\n             Err(()) => {\n-                bug!(\n-                    \"Impl {:?} was matchable against {:?} but now is not\",\n-                    impl_def_id,\n-                    obligation\n+                self.infcx.tcx.sess.delay_span_bug(\n+                    obligation.cause.span,\n+                    &format!(\n+                        \"Impl {:?} was matchable against {:?} but now is not\",\n+                        impl_def_id, obligation\n+                    ),\n                 );\n+                let value = self.infcx.fresh_substs_for_item(obligation.cause.span, impl_def_id);\n+                let err = self.tcx().ty_error();\n+                let value = value.fold_with(&mut BottomUpFolder {\n+                    tcx: self.tcx(),\n+                    ty_op: |_| err,\n+                    lt_op: |l| l,\n+                    ct_op: |c| c,\n+                });\n+                Normalized { value, obligations: vec![] }\n             }\n         }\n     }\n@@ -2222,6 +2248,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n+            // We don't want opaque types to just randomly match everything,\n+            // they should be opaque, even in their defining scope.\n+            .define_opaque_types(false)\n             .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())"}, {"sha": "68707fee44f99635bfbfe455034e8e61b03e56bb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -146,6 +146,10 @@ pub fn predicate_obligations<'a, 'tcx>(\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n+        ty::PredicateKind::OpaqueType(opaque, ty) => {\n+            wf.compute(opaque.into());\n+            wf.compute(ty.into());\n+        }\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }"}, {"sha": "71ea77dc3791088caadda56d5db0e77fa79abb9f", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -110,6 +110,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n@@ -196,6 +197,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n@@ -610,6 +612,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n@@ -739,6 +742,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }"}, {"sha": "287538e0764d3d577d7726262f69d6107c01a75f", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -142,6 +142,7 @@ crate fn evaluate_goal<'tcx>(\n                 var_values: CanonicalVarValues { var_values },\n                 region_constraints: QueryRegionConstraints::default(),\n                 certainty: Certainty::Proven,\n+                opaque_types: vec![],\n                 value: (),\n             },\n         };\n@@ -170,6 +171,7 @@ crate fn evaluate_goal<'tcx>(\n                                     .make_identity(tcx),\n                                 region_constraints: QueryRegionConstraints::default(),\n                                 certainty: Certainty::Ambiguous,\n+                                opaque_types: vec![],\n                                 value: (),\n                             },\n                         };"}, {"sha": "1535a46a01b475b89dac7b17f678aeb5f482fc09", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -105,6 +105,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);"}, {"sha": "c64e97074a6e02451066ff441eb2d7bc7d34f567", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -69,6 +69,7 @@ fn not_outlives_predicate<'tcx>(p: &ty::Predicate<'tcx>) -> bool {\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,\n     }\n }"}, {"sha": "94476ee2c4101fc51c1aa69cbd03ca6b105023e4", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -61,6 +61,12 @@ bitflags! {\n                                           | TypeFlags::HAS_CT_INFER.bits\n                                           | TypeFlags::HAS_TY_PLACEHOLDER.bits\n                                           | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                          // Opaque types may get resolved in the current scope and must\n+                                          // thus not be transported to other queries if it can be avoided.\n+                                          // FIXME: differentiate between crate-local opaque types\n+                                          // and opaque types from other crates, as only opaque types\n+                                          // from the local crate can possibly be a local name\n+                                          | TypeFlags::HAS_TY_OPAQUE.bits\n                                           // We consider 'freshened' types and constants\n                                           // to depend on a particular fn.\n                                           // The freshening process throws away information,"}, {"sha": "bc5662b5960936adc6e03a28766f38495fb712af", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -504,20 +504,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n-        span: Span,\n+        _span: Span,\n         outer_ty: &'tcx TyS<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n         match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {\n-            (Expectation::ExpectHasType(expected), Some((_id, ty)))\n+            (Expectation::ExpectHasType(expected), Some((_id, _ty)))\n                 if self.in_tail_expr && self.can_coerce(outer_ty, expected) =>\n             {\n-                let impl_trait_ret_ty =\n-                    self.infcx.instantiate_opaque_types(self.body_id, self.param_env, ty, span);\n-                assert!(\n-                    impl_trait_ret_ty.obligations.is_empty(),\n-                    \"we should never get new obligations here\"\n-                );\n                 let obligations = self.fulfillment_cx.borrow().pending_obligations();\n                 let mut suggest_box = !obligations.is_empty();\n                 for o in obligations {"}, {"sha": "19c3f00ed9357c155fbbbd1539aa8eef7e26f5cf", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -545,7 +545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n         fn_sig: ty::FnSig<'tcx>,\n     ) -> Ty<'tcx> {\n-        // `fn_sig` is the *signature* of the cosure being called. We\n+        // `fn_sig` is the *signature* of the closure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type."}, {"sha": "3405619f403b2c3277486b753164a708b0aebbef", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, OpaqueTypeKey, ParamEnv, RegionKind, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ParamEnv, RegionKind, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n@@ -81,8 +81,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     can_be_generator: Option<hir::Movability>,\n     return_type_pre_known: bool,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    let mut fn_sig = fn_sig;\n-\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n@@ -95,21 +93,13 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     let declared_ret_ty = fn_sig.output();\n \n-    let revealed_ret_ty =\n-        fcx.instantiate_opaque_types_from_value(declared_ret_ty, decl.output.span());\n-    debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(declared_ret_ty)));\n     fcx.ret_type_span = Some(decl.output.span());\n     if let ty::Opaque(..) = declared_ret_ty.kind() {\n+        // FIXME(oli-obk): remove this and have diagnostics check the signature's return type directly\n+        // as we don't reveal here anymore.\n         fcx.ret_coercion_impl_trait = Some(declared_ret_ty);\n     }\n-    fn_sig = tcx.mk_fn_sig(\n-        fn_sig.inputs().iter().cloned(),\n-        revealed_ret_ty,\n-        fn_sig.c_variadic,\n-        fn_sig.unsafety,\n-        fn_sig.abi,\n-    );\n \n     let span = body.value.span;\n \n@@ -251,7 +241,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n             fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n         debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n     }\n-    fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n+    fcx.demand_suptype(span, declared_ret_ty, actual_return_ty);\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n@@ -629,6 +619,8 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n+    let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n+\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n@@ -643,23 +635,12 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        let _ = inh.register_infer_ok_obligations(\n-            infcx.instantiate_opaque_types(hir_id, param_env, opaque_ty, span),\n-        );\n-\n-        for (OpaqueTypeKey { def_id, substs }, opaque_defn) in infcx.opaque_types() {\n-            let hidden_type = tcx.type_of(def_id).subst(tcx, substs);\n-            trace!(?hidden_type);\n-            match infcx.at(&misc_cause, param_env).eq(opaque_defn.concrete_ty, hidden_type) {\n-                Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n-                Err(ty_err) => tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\n-                        \"could not check bounds on revealed type `{}`:\\n{}\",\n-                        hidden_type, ty_err,\n-                    ),\n-                ),\n-            }\n+        match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+            Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+            Err(ty_err) => tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"could not unify `{}` with revealed type:\\n{}\", hidden_type, ty_err,),\n+            ),\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n@@ -671,7 +652,7 @@ fn check_opaque_meets_bounds<'tcx>(\n \n         match origin {\n             // Checked when type checking the function containing them.\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => return,\n+            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n             // Can have different predicates to their defining use\n             hir::OpaqueTyOrigin::TyAlias => {\n                 // Finally, resolve all regions. This catches wily misuses of\n@@ -680,6 +661,9 @@ fn check_opaque_meets_bounds<'tcx>(\n                 fcx.regionck_item(hir_id, span, FxHashSet::default());\n             }\n         }\n+\n+        // Clean up after ourselves\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n     });\n }\n "}, {"sha": "d4336563b96037bf7c8ff948b4b6b8a1c3f05483", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 79, "deletions": 16, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,16 +3,20 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n+use crate::rustc_middle::ty::subst::Subst;\n+use hir::OpaqueTyOrigin;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n+use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n@@ -172,6 +176,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n+            ty::Opaque(def_id, substs) => {\n+                let bounds = self.tcx.explicit_item_bounds(def_id);\n+                let sig = bounds.iter().find_map(|(pred, span)| match pred.kind().skip_binder() {\n+                    ty::PredicateKind::Projection(proj_predicate) => self\n+                        .deduce_sig_from_projection(\n+                            Some(*span),\n+                            pred.kind().rebind(proj_predicate.subst(self.tcx, substs)),\n+                        ),\n+                    _ => None,\n+                });\n+\n+                let kind = bounds\n+                    .iter()\n+                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(tp) => {\n+                            self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n+                        }\n+                        _ => None,\n+                    })\n+                    .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+                trace!(?sig, ?kind);\n+                (sig, kind)\n+            }\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -197,10 +224,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         let expected_sig =\n             self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(\n-                    \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n-                    obligation.predicate\n-                );\n+                debug!(?obligation.predicate);\n \n                 let bound_predicate = obligation.predicate.kind();\n                 if let ty::PredicateKind::Projection(proj_predicate) =\n@@ -401,9 +425,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // in this binder we are creating.\n         assert!(!expected_sig.sig.skip_binder().has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = expected_sig.sig.map_bound(|sig| {\n+            let output = self.hide_parent_opaque_types(\n+                sig.output(),\n+                expected_sig.cause_span.unwrap_or(DUMMY_SP),\n+                body.id().hir_id,\n+            );\n             self.tcx.mk_fn_sig(\n                 sig.inputs().iter().cloned(),\n-                sig.output(),\n+                output,\n                 sig.c_variadic,\n                 hir::Unsafety::Normal,\n                 Abi::RustCall,\n@@ -590,6 +619,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => astconv.ty_infer(None, decl.output.span()),\n             },\n         };\n+        let supplied_return =\n+            self.hide_parent_opaque_types(supplied_return, decl.output.span(), body.id().hir_id);\n \n         let result = ty::Binder::bind_with_vars(\n             self.tcx.mk_fn_sig(\n@@ -610,45 +641,77 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         result\n     }\n \n+    fn hide_parent_opaque_types(&self, ty: Ty<'tcx>, span: Span, body_id: hir::HirId) -> Ty<'tcx> {\n+        ty.fold_with(&mut ty::fold::BottomUpFolder {\n+            tcx: self.infcx.tcx,\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+            ty_op: |ty| match *ty.kind() {\n+                // Closures can't create hidden types for opaque types of their parent, as they\n+                // do not have all the outlives information available. Also `type_of` looks for\n+                // hidden types in the owner (so the closure's parent), so it would not find these\n+                // definitions.\n+                ty::Opaque(def_id, _substs)\n+                    if matches!(\n+                        self.infcx.opaque_type_origin(def_id, DUMMY_SP),\n+                        Some(OpaqueTyOrigin::FnReturn(..))\n+                    ) =>\n+                {\n+                    let ty_var = self.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span,\n+                    });\n+                    let cause = ObligationCause::misc(span, body_id);\n+                    self.register_predicates(vec![self.infcx.opaque_ty_obligation(\n+                        ty,\n+                        ty_var,\n+                        true,\n+                        self.param_env,\n+                        cause,\n+                    )]);\n+                    ty_var\n+                }\n+                _ => ty,\n+            },\n+        })\n+    }\n+\n     /// Invoked when we are translating the generator that results\n     /// from desugaring an `async fn`. Returns the \"sugared\" return\n     /// type of the `async fn` -- that is, the return type that the\n     /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn deduce_future_output_from_obligations(&self, expr_def_id: DefId) -> Option<Ty<'tcx>> {\n-        debug!(\"deduce_future_output_from_obligations(expr_def_id={:?})\", expr_def_id);\n-\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n         });\n \n-        // In practice, the return type of the surrounding function is\n-        // always a (not yet resolved) inference variable, because it\n-        // is the hidden type for an `impl Trait` that we are going to\n-        // be inferring.\n         let ret_ty = ret_coercion.borrow().expected_ty();\n         let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-        let ret_vid = match *ret_ty.kind() {\n-            ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n+        let (def_id, substs) = match *ret_ty.kind() {\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n             ty::Error(_) => return None,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),\n                 \"async fn generator return type not an inference variable\"\n             ),\n         };\n \n+        let item_bounds = self.tcx.explicit_item_bounds(def_id);\n+\n         // Search for a pending obligation like\n         //\n         // `<R as Future>::Output = T`\n         //\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n-        let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            let bound_predicate = obligation.predicate.kind();\n+        let output_ty = item_bounds.iter().find_map(|&(predicate, span)| {\n+            let bound_predicate = predicate.subst(self.tcx, substs).kind();\n             if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n                 self.deduce_future_output_from_projection(\n-                    obligation.cause.span,\n+                    span,\n                     bound_predicate.rebind(proj_predicate),\n                 )\n             } else {"}, {"sha": "8204a25e9112b71d99cea21425fefa753227178c", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1275,7 +1275,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n \n     /// Returns the current \"merged type\", representing our best-guess\n     /// at the LUB of the expressions we've seen so far (if any). This\n-    /// isn't *final* until you call `self.final()`, which will return\n+    /// isn't *final* until you call `self.complete()`, which will return\n     /// the merged type.\n     pub fn merged_ty(&self) -> Ty<'tcx> {\n         self.final_ty.unwrap_or(self.expected_ty)"}, {"sha": "9e1a70b7dfb929382497d1cdcbb5c15da3195694", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,6 @@\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::DUMMY_SP;\n use rustc_span::{self, Span};\n \n use super::Expectation::*;\n@@ -43,7 +44,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n     pub(super) fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match *self {\n+        match self.strip_opaque(fcx) {\n             ExpectHasType(ety) => {\n                 let ety = fcx.shallow_resolve(ety);\n                 if !ety.is_ty_var() { ExpectHasType(ety) } else { NoExpectation }\n@@ -104,14 +105,35 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// for the program to type-check). `only_has_type` will return\n     /// such a constraint, if it exists.\n     pub(super) fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n-        match self {\n-            ExpectHasType(ty) => Some(fcx.resolve_vars_if_possible(ty)),\n+        match self.strip_opaque(fcx) {\n+            ExpectHasType(ty) => Some(ty),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) | IsLast(_) => {\n                 None\n             }\n         }\n     }\n \n+    /// We must not treat opaque types as expected types in their defining scope, as that\n+    /// will break `fn foo() -> impl Trait { if cond { a } else { b } }` if `a` and `b` are\n+    /// only \"equal\" if they coerce to a common target, like two different function items\n+    /// coercing to a function pointer if they have the same signature.\n+    fn strip_opaque(self, fcx: &FnCtxt<'a, 'tcx>) -> Self {\n+        match self {\n+            ExpectHasType(ty) => {\n+                let ty = fcx.resolve_vars_if_possible(ty);\n+                match *ty.kind() {\n+                    ty::Opaque(def_id, _)\n+                        if fcx.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() =>\n+                    {\n+                        NoExpectation\n+                    }\n+                    _ => self,\n+                }\n+            }\n+            _ => self,\n+        }\n+    }\n+\n     /// Like `only_has_type`, but instead of returning `None` if no\n     /// hard constraint exists, creates a fresh type variable.\n     pub(super) fn coercion_target_type(self, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> Ty<'tcx> {"}, {"sha": "bbe34977c911a44dc13686f32af2935b6cad15eb", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 2, "deletions": 65, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n-        // Check if we have any unsolved varibales. If not, no need for fallback.\n+        // Check if we have any unsolved variables. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n             return false;\n@@ -66,16 +66,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // refer to opaque types.\n         self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n \n-        // We now run fallback again, but this time we allow it to replace\n-        // unconstrained opaque type variables, in addition to performing\n-        // other kinds of fallback.\n-        for ty in &self.unsolved_variables() {\n-            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n-        }\n-\n-        // See if we can make any more progress.\n-        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n         fallback_has_occurred\n     }\n \n@@ -136,59 +126,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         true\n     }\n \n-    /// Second round of fallback: Unconstrained type variables created\n-    /// from the instantiation of an opaque type fall back to the\n-    /// opaque type itself. This is a somewhat incomplete attempt to\n-    /// manage \"identity passthrough\" for `impl Trait` types.\n-    ///\n-    /// For example, in this code:\n-    ///\n-    ///```\n-    /// type MyType = impl Copy;\n-    /// fn defining_use() -> MyType { true }\n-    /// fn other_use() -> MyType { defining_use() }\n-    /// ```\n-    ///\n-    /// `defining_use` will constrain the instantiated inference\n-    /// variable to `bool`, while `other_use` will constrain\n-    /// the instantiated inference variable to `MyType`.\n-    ///\n-    /// When we process opaque types during writeback, we\n-    /// will handle cases like `other_use`, and not count\n-    /// them as defining usages\n-    ///\n-    /// However, we also need to handle cases like this:\n-    ///\n-    /// ```rust\n-    /// pub type Foo = impl Copy;\n-    /// fn produce() -> Option<Foo> {\n-    ///     None\n-    ///  }\n-    ///  ```\n-    ///\n-    /// In the above snippet, the inference variable created by\n-    /// instantiating `Option<Foo>` will be completely unconstrained.\n-    /// We treat this as a non-defining use by making the inference\n-    /// variable fall back to the opaque type itself.\n-    fn fallback_opaque_type_vars(&self, ty: Ty<'tcx>) -> bool {\n-        let span = self\n-            .infcx\n-            .type_var_origin(ty)\n-            .map(|origin| origin.span)\n-            .unwrap_or(rustc_span::DUMMY_SP);\n-        let oty = self.inner.borrow().opaque_type_storage.get_opaque_type_for_infer_var(ty);\n-        if let Some(opaque_ty) = oty {\n-            debug!(\n-                \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\",\n-                ty, opaque_ty\n-            );\n-            self.demand_eqtype(span, ty, opaque_ty);\n-            true\n-        } else {\n-            return false;\n-        }\n-    }\n-\n     /// The \"diverging fallback\" system is rather complicated. This is\n     /// a result of our need to balance 'do the right thing' with\n     /// backwards compatibility.\n@@ -281,7 +218,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .diverging_type_vars\n             .borrow()\n             .iter()\n-            .map(|&ty| self.infcx.shallow_resolve(ty))\n+            .map(|(&ty, _)| self.infcx.shallow_resolve(ty))\n             .filter_map(|ty| ty.ty_vid())\n             .map(|vid| self.infcx.root_var(vid))\n             .collect();"}, {"sha": "705b3207999a7619131325d00797ff78100f6860", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -274,7 +274,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for a in &adj {\n             if let Adjust::NeverToAny = a.kind {\n                 if a.target.is_ty_var() {\n-                    self.diverging_type_vars.borrow_mut().insert(a.target);\n+                    self.diverging_type_vars.borrow_mut().insert(a.target, expr.span);\n                     debug!(\"apply_adjustments: adding `{:?}` as diverging type var\", a.target);\n                 }\n             }\n@@ -367,23 +367,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (result, spans)\n     }\n \n-    /// Replaces the opaque types from the given value with type variables,\n-    /// and records the `OpaqueTypeMap` for later use during writeback. See\n-    /// `InferCtxt::instantiate_opaque_types` for more details.\n-    #[instrument(skip(self, value_span), level = \"debug\")]\n-    pub(in super::super) fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n-        &self,\n-        value: T,\n-        value_span: Span,\n-    ) -> T {\n-        self.register_infer_ok_obligations(self.instantiate_opaque_types(\n-            self.body_id,\n-            self.param_env,\n-            value,\n-            value_span,\n-        ))\n-    }\n-\n     /// Convenience method which tracks extra diagnostic information for normalization\n     /// that occurs as a result of WF checking. The `hir_id` is the `HirId` of the hir item\n     /// whose type is being wf-checked - this is used to construct a more precise span if\n@@ -720,6 +703,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // inference variable.\n                     ty::PredicateKind::ClosureKind(..) => None,\n                     ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+                    ty::PredicateKind::OpaqueType(..) => None,\n                 }\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))"}, {"sha": "c9b843aedb2d463011bab905e39177c0f28f0e70", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,7 +1,7 @@\n use super::callee::DeferredCallResolution;\n use super::MaybeInProgressTables;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::HirIdMap;\n@@ -58,7 +58,7 @@ pub struct Inherited<'a, 'tcx> {\n     /// Whenever we introduce an adjustment from `!` into a type variable,\n     /// we record that type variable here. This is later used to inform\n     /// fallback. See the `fallback` module for details.\n-    pub(super) diverging_type_vars: RefCell<FxHashSet<Ty<'tcx>>>,\n+    pub(super) diverging_type_vars: RefCell<FxHashMap<Ty<'tcx>, Span>>,\n }\n \n impl<'a, 'tcx> Deref for Inherited<'a, 'tcx> {\n@@ -95,6 +95,13 @@ impl<'tcx> InheritedBuilder<'tcx> {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n+\n+    /// WF-checking doesn't need to recompute opaque types and can instead use\n+    /// the type_of query to get them from typeck.\n+    pub fn reveal_defining_opaque_types(mut self) -> Self {\n+        self.infcx = self.infcx.reveal_defining_opaque_types();\n+        self\n+    }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n@@ -119,8 +126,8 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n-        debug!(\"register_predicate({:?})\", obligation);\n         if obligation.has_escaping_bound_vars() {\n             span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n         }"}, {"sha": "b8a45133fd7ea8361c896ef16db507e6d8c80542", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -858,6 +858,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::TypeOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });\n@@ -1477,6 +1478,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n+                    .define_opaque_types(false)\n                     .sup(candidate.xform_self_ty, self_ty);\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n@@ -1506,6 +1508,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // First check that the self type can be related.\n             let sub_obligations = match self\n                 .at(&ObligationCause::dummy(), self.param_env)\n+                .define_opaque_types(false)\n                 .sup(probe.xform_self_ty, self_ty)\n             {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n@@ -1653,6 +1656,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     );\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n+                        .define_opaque_types(false)\n                         .sup(return_ty, xform_ret_ty)\n                         .is_err()\n                     {"}, {"sha": "5094806e75f4a36834667a86ad0dbacd1b3fab0f", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -99,6 +99,8 @@ pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::*;\n pub use inherited::{Inherited, InheritedBuilder};\n+use rustc_infer::traits::ObligationCause;\n+use traits::ObligationCauseCode::MiscObligation;\n \n use crate::astconv::AstConv;\n use crate::check::gather_locals::GatherLocalsVisitor;\n@@ -341,6 +343,7 @@ fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::T\n     typeck_with_fallback(tcx, def_id, fallback)\n }\n \n+#[instrument(skip(tcx, fallback))]\n fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n@@ -471,6 +474,19 @@ fn typeck_with_fallback<'tcx>(\n             fcx.require_type_is_sized(ty, span, code);\n         }\n \n+        let opaque_types = fcx.infcx.inner.borrow_mut().opaque_type_storage.opaque_types();\n+        for (_, decl) in opaque_types {\n+            let cause = ObligationCause::new(body.value.span, id, MiscObligation);\n+            if let Err((err, expected, actual)) =\n+                decl.hidden_type(&fcx.infcx, &cause, fcx.param_env)\n+            {\n+                let cause = ObligationCause::new(actual.span, id, MiscObligation);\n+                fcx.report_mismatched_types(&cause, expected.ty, actual.ty, err)\n+                    .span_label(expected.span, \"type expected due to this\")\n+                    .emit();\n+            }\n+        }\n+\n         fcx.select_all_obligations_or_error();\n \n         if fn_sig.is_some() {"}, {"sha": "c0fa673774ffdb3e125e9510c47a6767ffd40d55", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -895,7 +895,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n \n fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n     CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id),\n+        inherited: Inherited::build(tcx, def_id).reveal_defining_opaque_types(),\n         id: hir::HirId::make_owner(def_id),\n         span,\n         param_env: tcx.param_env(def_id),"}, {"sha": "f97fedd9a6dab8ee24451bae56caadcb70ee5f0c", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 59, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -18,7 +18,6 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use std::mem;\n \n@@ -65,7 +64,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n-        wbcx.visit_opaque_types(body.value.span);\n+        wbcx.visit_opaque_types();\n         wbcx.visit_coercion_casts();\n         wbcx.visit_user_provided_tys();\n         wbcx.visit_user_provided_sigs();\n@@ -496,65 +495,12 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             fcx_typeck_results.generator_interior_types.clone();\n     }\n \n-    #[instrument(skip(self, span), level = \"debug\")]\n-    fn visit_opaque_types(&mut self, span: Span) {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_opaque_types(&mut self) {\n         let opaque_types =\n             self.fcx.infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        for (opaque_type_key, opaque_defn) in opaque_types {\n-            let hir_id =\n-                self.tcx().hir().local_def_id_to_hir_id(opaque_type_key.def_id.expect_local());\n-            let instantiated_ty = self.resolve(opaque_defn.concrete_ty, &hir_id);\n-\n-            debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n-\n-            let opaque_type_key = self.fcx.fully_resolve(opaque_type_key).unwrap();\n-\n-            // Prevent:\n-            // * `fn foo<T>() -> Foo<T>`\n-            // * `fn foo<T: Bound + Other>() -> Foo<T>`\n-            // from being defining.\n-\n-            // Also replace all generic params with the ones from the opaque type\n-            // definition so that\n-            // ```rust\n-            // type Foo<T> = impl Baz + 'static;\n-            // fn foo<U>() -> Foo<U> { .. }\n-            // ```\n-            // figures out the concrete type with `U`, but the stored type is with `T`.\n-\n-            // FIXME: why are we calling this here? This seems too early, and duplicated.\n-            let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n-                opaque_type_key,\n-                instantiated_ty,\n-                span,\n-            );\n-\n-            let mut skip_add = false;\n-\n-            if let ty::Opaque(definition_ty_def_id, _substs) = *definition_ty.kind() {\n-                if opaque_defn.origin == hir::OpaqueTyOrigin::TyAlias {\n-                    if opaque_type_key.def_id == definition_ty_def_id {\n-                        debug!(\n-                            \"skipping adding concrete definition for opaque type {:?} {:?}\",\n-                            opaque_defn, opaque_type_key.def_id\n-                        );\n-                        skip_add = true;\n-                    }\n-                }\n-            }\n-\n-            if opaque_type_key.substs.needs_infer() {\n-                span_bug!(span, \"{:#?} has inference variables\", opaque_type_key.substs)\n-            }\n-\n-            // We only want to add an entry into `concrete_opaque_types`\n-            // if we actually found a defining usage of this opaque type.\n-            // Otherwise, we do nothing - we'll either find a defining usage\n-            // in some other location, or we'll end up emitting an error due\n-            // to the lack of defining usage\n-            if !skip_add {\n-                self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id);\n-            }\n+        for (opaque_type_key, _) in opaque_types {\n+            self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id);\n         }\n     }\n "}, {"sha": "ce2f486bb7043ef1e7774f0b78bdae053c0901bd", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -389,13 +389,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n                         .copied()\n                         .unwrap_or_else(|| {\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its typeck results\",\n-                                    owner, def_id,\n-                                ),\n-                            );\n                             if let Some(ErrorReported) =\n                                 tcx.typeck(owner).tainted_by_errors\n                             {\n@@ -405,12 +398,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 tcx.ty_error()\n                             } else {\n                                 // We failed to resolve the opaque type or it\n-                                // resolves to itself. Return the non-revealed\n-                                // type, which should result in E0720.\n-                                tcx.mk_opaque(\n-                                    def_id.to_def_id(),\n-                                    InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-                                )\n+                                // resolves to itself. We interpret this as the\n+                                // no values of the hidden type ever being constructed,\n+                                // so we can just make the hidden type be `!`.\n+                                // For backwards compatibility reasons, we fall back to\n+                                // `()` until we the diverging default is changed.\n+                                tcx.mk_diverging_default()\n                             }\n                         });\n                     debug!(\"concrete_ty = {:?}\", concrete_ty);\n@@ -658,23 +651,23 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             // The opaque type itself or its children are not within its reveal scope.\n             if it.def_id.to_def_id() != self.def_id {\n                 self.check(it.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            trace!(?it.def_id);\n             self.check(it.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n@@ -684,12 +677,12 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n-    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n+    debug!(?scope);\n \n     if scope == hir::CRATE_HIR_ID {\n         tcx.hir().walk_toplevel_module(&mut locator);\n     } else {\n-        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n+        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n         match tcx.hir().get(scope) {\n             // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n             // This allows our visitor to process the defining item itself, causing"}, {"sha": "4227ed6ab3ad58af53068ef42a51ab51d20f74f0", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -427,6 +427,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::OpaqueType(..)\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "7839ce5e4ff48e51739b2b23808eec60eab27c14", "filename": "compiler/rustc_typeck/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -59,6 +59,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::OpaqueType(..)\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }"}, {"sha": "3fdc904bd327c3c40d196bc9f9fafacf54d520b7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -297,6 +297,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::OpaqueType(..)\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n         }\n     }"}, {"sha": "31564a0cbd5c64a059d7d412301b2e493a9382ba", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -305,7 +305,7 @@ pub fn return_impl_trait() -> i32        {\n }\n \n #[cfg(not(any(cfail1,cfail4)))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail3\")]\n #[rustc_clean(cfg = \"cfail5\", except = \"hir_owner, hir_owner_nodes, typeck, fn_sig, optimized_mir\")]\n #[rustc_clean(cfg = \"cfail6\")]"}, {"sha": "ac3df7fca5ab291873f8408d0f920ae19513db86", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -28,9 +28,10 @@ impl Bar for AssocNoCopy {\n \n impl Thing for AssocNoCopy {\n     type Out = Box<dyn Bar<Assoc: Copy>>;\n+    //~^ ERROR could not find defining uses\n \n     fn func() -> Self::Out {\n-        //~^ ERROR the trait bound `String: Copy` is not satisfied\n         Box::new(AssocNoCopy)\n+        //~^ ERROR the trait bound `String: Copy` is not satisfied\n     }\n }"}, {"sha": "3cbc3358d07fb143f745d4991ae4b4ed8cd914e4", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,9 +1,17 @@\n error[E0277]: the trait bound `String: Copy` is not satisfied\n-  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:32:18\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:34:9\n    |\n-LL |     fn func() -> Self::Out {\n-   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+LL |         Box::new(AssocNoCopy)\n+   |         ^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+   = note: required for the cast to the object type `dyn Bar<Assoc = impl Copy>`\n+\n+error: could not find defining uses\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:30:28\n+   |\n+LL |     type Out = Box<dyn Bar<Assoc: Copy>>;\n+   |                            ^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "30e4c1a3c537ba944b33af3544a6f29adb310ec6", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -23,8 +23,8 @@ fn bar() -> impl Bar {\n }\n \n fn baz() -> impl Bar<Item = i32> {\n-//~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n     bar()\n+    //~^ ERROR type mismatch resolving `<impl Bar as Foo>::Item == i32`\n }\n \n fn main() {"}, {"sha": "9523a54d954df0feb04d8715b818b744c4eba4fd", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,14 +1,16 @@\n error[E0271]: type mismatch resolving `<impl Bar as Foo>::Item == i32`\n-  --> $DIR/impl-trait-return-missing-constraint.rs:25:13\n+  --> $DIR/impl-trait-return-missing-constraint.rs:26:5\n    |\n LL | fn bar() -> impl Bar {\n-   |             -------- the found opaque type\n+   |             -------- the expected opaque type\n ...\n-LL | fn baz() -> impl Bar<Item = i32> {\n-   |             ^^^^^^^^^^^^^^^^^^^^ expected `i32`, found associated type\n+LL |     bar()\n+   |     ^^^^^ expected associated type, found `i32`\n    |\n-   = note:         expected type `i32`\n-           found associated type `<impl Bar as Foo>::Item`\n+   = note: expected associated type `<impl Bar as Foo>::Item`\n+                         found type `i32`\n+   = help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32` or calling a method that returns `<impl Bar as Foo>::Item`\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32`\n    |\n LL | fn bar() -> impl Bar<Item = i32> {"}, {"sha": "f21c811512416a34728af743624f6563dfe7def1", "filename": "src/test/ui/async-await/async-borrowck-escaping-block-error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-block-error.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,10 +8,10 @@ LL |     Box::new(async { x } )\n    |                    may outlive borrowed value `x`\n    |\n note: async block is returned here\n-  --> $DIR/async-borrowck-escaping-block-error.rs:4:20\n+  --> $DIR/async-borrowck-escaping-block-error.rs:6:5\n    |\n-LL | fn test_boxed() -> Box<impl std::future::Future<Output = u32>> {\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     Box::new(async { x } )\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n help: to force the async block to take ownership of `x` (and any other referenced variables), use the `move` keyword\n    |\n LL |     Box::new(async move { x } )"}, {"sha": "338483ff6acdcefd87c99079dd057a1a03ddd9db", "filename": "src/test/ui/async-await/async-error-span.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,8 +5,7 @@\n use std::future::Future;\n \n fn get_future() -> impl Future<Output = ()> {\n-//~^ ERROR `()` is not a future\n-    panic!()\n+    panic!() //~^ ERROR `()` is not a future\n }\n \n async fn foo() {"}, {"sha": "18e8dd940fa069037b96114b9f3d2919e62eec98", "filename": "src/test/ui/async-await/async-error-span.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,13 +8,13 @@ LL | fn get_future() -> impl Future<Output = ()> {\n    = note: () must be a future or must implement `IntoFuture` to be awaited\n \n error[E0698]: type inside `async fn` body must be known in this context\n-  --> $DIR/async-error-span.rs:13:9\n+  --> $DIR/async-error-span.rs:12:9\n    |\n LL |     let a;\n    |         ^ cannot infer type\n    |\n note: the type is part of the `async fn` body because of this `await`\n-  --> $DIR/async-error-span.rs:14:17\n+  --> $DIR/async-error-span.rs:13:17\n    |\n LL |     get_future().await;\n    |                 ^^^^^^"}, {"sha": "7cb02e5cf383d14cefb08b06ce701fd9bd49ebb6", "filename": "src/test/ui/async-await/issue-64130-4-async-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -13,9 +13,9 @@ impl Client {\n async fn get() { }\n \n pub fn foo() -> impl Future + Send {\n-    //~^ ERROR future cannot be sent between threads safely\n     let client = Client(Box::new(true));\n     async move {\n+        //~^ ERROR future cannot be sent between threads safely\n         match client.status() {\n             200 => {\n                 let _x = get().await;"}, {"sha": "2d4327f4ea8abfe7f0d03cb3d1b4bdf69e19ebb4", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,14 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-64130-4-async-move.rs:15:17\n+  --> $DIR/issue-64130-4-async-move.rs:17:5\n    |\n-LL | pub fn foo() -> impl Future + Send {\n-   |                 ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL | /     async move {\n+LL | |\n+LL | |         match client.status() {\n+LL | |             200 => {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `(dyn Any + Send + 'static)`\n note: future is not `Send` as this value is used across an await"}, {"sha": "631389e10f316a8f17e4284c3a9182a6aaae0e5e", "filename": "src/test/ui/async-await/issue-70818.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2,8 +2,8 @@\n \n use std::future::Future;\n fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n-//~^ Error future cannot be sent between threads safely\n     async { (ty, ty1) }\n+    //~^ Error future cannot be sent between threads safely\n }\n \n fn main() {}"}, {"sha": "3fc08c18bc0eb3921d7f28c76c1c187121a32108", "filename": "src/test/ui/async-await/issue-70818.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,11 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70818.rs:4:38\n+  --> $DIR/issue-70818.rs:5:5\n    |\n-LL | fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n-   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL |     async { (ty, ty1) }\n+   |     ^^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n note: captured value is not `Send`\n-  --> $DIR/issue-70818.rs:6:18\n+  --> $DIR/issue-70818.rs:5:18\n    |\n LL |     async { (ty, ty1) }\n    |                  ^^^ has type `U` which is not `Send`"}, {"sha": "494561229511ec5909fe2cdb882886c8d56e7392", "filename": "src/test/ui/async-await/issue-70935-complex-spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,8 +8,8 @@ async fn baz<T>(_c: impl FnMut() -> T) where T: Future<Output=()> {\n }\n \n fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n-    //~^ ERROR: future cannot be sent between threads safely\n     async move {\n+        //~^ ERROR: future cannot be sent between threads safely\n         baz(|| async{\n             foo(tx.clone());\n         }).await;"}, {"sha": "c7b6893afd6f1d5c4c913db0fe4f70ac3ed4a949", "filename": "src/test/ui/async-await/issue-70935-complex-spans.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70935-complex-spans.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,13 @@\n error: future cannot be sent between threads safely\n-  --> $DIR/issue-70935-complex-spans.rs:10:45\n+  --> $DIR/issue-70935-complex-spans.rs:11:5\n    |\n-LL | fn foo(tx: std::sync::mpsc::Sender<i32>) -> impl Future + Send {\n-   |                                             ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n+LL | /     async move {\n+LL | |\n+LL | |         baz(|| async{\n+LL | |             foo(tx.clone());\n+LL | |         }).await;\n+LL | |     }\n+   | |_____^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `Sender<i32>`\n note: future is not `Send` as this value is used across an await"}, {"sha": "ffb113c1d336794c5f58ef3f7005314487b01749", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.nll.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.nll.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -17,14 +17,13 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n   --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                    --                           ^^^^^^^^^^^^^^\n-   |                                    |\n-   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+   |                                                                 ^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+note: hidden type `(&'a u8, &'<empty> u8)` captures lifetime smaller than the function body\n+  --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n-LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n-   |                                                                                ++++\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |                                                                 ^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "32b4d18c162d46f98f6bca37ff119ca4c4592356", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,24 +1,26 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ret-impl-trait-one.rs:10:65\n+  --> $DIR/ret-impl-trait-one.rs:10:85\n    |\n-LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n-   |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n-   |                                                      |          |\n-   |                                                      |          ...but data from `a` is returned here\n-   |                                                      this parameter and the return type are declared with different lifetimes...\n+LL |   async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n+   |  ______________________________________________________------_____-------------------_^\n+   | |                                                      |\n+   | |                                                      this parameter and the return type are declared with different lifetimes...\n+LL | |\n+LL | |     (a, b)\n+LL | | }\n+   | |_^ ...but data from `a` is returned here\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n-   |                                    --                           ^^^^^^^^^^^^^^\n-   |                                    |\n-   |                                    hidden type `(&'a u8, &'b u8)` captures the lifetime `'b` as defined here\n+   |                                                                 ^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+note: hidden type `(&'a u8, &'<empty> u8)` captures lifetime smaller than the function body\n+  --> $DIR/ret-impl-trait-one.rs:16:65\n    |\n-LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n-   |                                                                                ++++\n+LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> {\n+   |                                                                 ^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cfb0ef1b33a2b69de5936a9cd44e51ce7b9c84f5", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,3 +3,4 @@\n \n pub const async fn x() {}\n //~^ ERROR functions cannot be both `const` and `async`\n+//~| ERROR cycle detected"}, {"sha": "fd76c282f9629c475253bc0197f6cd699999489b", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -7,5 +7,36 @@ LL | pub const async fn x() {}\n    |     |     `async` because of this\n    |     `const` because of this\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing type of `x::{opaque#0}`\n+  --> $DIR/no-const-async.rs:4:24\n+   |\n+LL | pub const async fn x() {}\n+   |                        ^\n+   |\n+note: ...which requires borrow-checking `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `x`...\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `x::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/no-const-async.rs:4:1\n+   |\n+LL | pub const async fn x() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "edc4cb8ac5df37153345b5a8453538bb330da90a", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2,7 +2,8 @@\n // Test that impl trait does not allow creating recursive types that are\n // otherwise forbidden when using `async` and `await`.\n \n-async fn recursive_async_function() -> () { //~ ERROR\n+async fn recursive_async_function() -> () {\n+    //~^ ERROR recursion in an `async fn` requires boxing\n     recursive_async_function().await;\n }\n "}, {"sha": "046f1dfea323878d1d1725abfac6ab76c724fbc4", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -21,7 +21,6 @@ async fn dummy() {}\n async fn suggest_await_in_async_fn_return() {\n     dummy()\n     //~^ ERROR mismatched types [E0308]\n-    //~| HELP consider using a semicolon here\n     //~| HELP consider `await`ing on the `Future`\n     //~| SUGGESTION .await\n }"}, {"sha": "a60571dc11df6d4120041ad093068bb25197a461", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -33,13 +33,9 @@ help: consider `await`ing on the `Future`\n    |\n LL |     dummy().await\n    |            ++++++\n-help: consider using a semicolon here\n-   |\n-LL |     dummy();\n-   |            +\n \n error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/suggest-missing-await.rs:35:9\n+  --> $DIR/suggest-missing-await.rs:34:9\n    |\n LL |       let _x = if true {\n    |  ______________-\n@@ -53,15 +49,20 @@ LL | |\n LL | |     };\n    | |_____- `if` and `else` have incompatible types\n    |\n-   = note:   expected type `impl Future<Output = ()>`\n-           found unit type `()`\n+note: while checking the return type of the `async fn`\n+  --> $DIR/suggest-missing-await.rs:18:18\n+   |\n+LL | async fn dummy() {}\n+   |                  ^ checked the `Output` of this `async fn`, expected opaque type\n+   = note: expected opaque type `impl Future<Output = ()>`\n+                found unit type `()`\n help: consider `await`ing on the `Future`\n    |\n LL |         dummy().await\n    |                ++++++\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/suggest-missing-await.rs:45:14\n+  --> $DIR/suggest-missing-await.rs:44:14\n    |\n LL |       let _x = match 0usize {\n    |  ______________-\n@@ -89,7 +90,7 @@ LL ~         1 => dummy().await,\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:53:9\n+  --> $DIR/suggest-missing-await.rs:52:9\n    |\n LL |         () => {}\n    |         ^^ expected opaque type, found `()`\n@@ -107,13 +108,13 @@ LL |     let _x = match dummy().await {\n    |                           ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:67:9\n+  --> $DIR/suggest-missing-await.rs:66:9\n    |\n LL |         Ok(_) => {}\n    |         ^^^^^ expected opaque type, found enum `Result`\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:57:28\n+  --> $DIR/suggest-missing-await.rs:56:28\n    |\n LL | async fn dummy_result() -> Result<(), ()> {\n    |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type\n@@ -125,13 +126,13 @@ LL |     match dummy_result().await {\n    |                         ++++++\n \n error[E0308]: mismatched types\n-  --> $DIR/suggest-missing-await.rs:69:9\n+  --> $DIR/suggest-missing-await.rs:68:9\n    |\n LL |         Err(_) => {}\n    |         ^^^^^^ expected opaque type, found enum `Result`\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/suggest-missing-await.rs:57:28\n+  --> $DIR/suggest-missing-await.rs:56:28\n    |\n LL | async fn dummy_result() -> Result<(), ()> {\n    |                            ^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type"}, {"sha": "ccf41adce6bd83f769dcb48e8b461691b84be03f", "filename": "src/test/ui/cast/casts-differing-anon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     // this is an `*mut fmt::Debug` in practice\n     let mut b_raw = Box::into_raw(b);\n     // ... and they should not be mixable\n-    b_raw = f_raw as *mut _; //~ ERROR is invalid\n+    b_raw = f_raw as *mut _; //~ ERROR mismatched types\n }"}, {"sha": "2d08903c5ef69c39b6007a32eb2ddf33f4cfd53f", "filename": "src/test/ui/cast/casts-differing-anon.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcasts-differing-anon.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,19 @@\n-error[E0606]: casting `*mut impl Debug + ?Sized` as `*mut impl Debug + ?Sized` is invalid\n+error[E0308]: mismatched types\n   --> $DIR/casts-differing-anon.rs:21:13\n    |\n+LL | fn foo() -> Box<impl fmt::Debug+?Sized> {\n+   |                 ---------------------- the found opaque type\n+...\n+LL | fn bar() -> Box<impl fmt::Debug+?Sized> {\n+   |                 ---------------------- the expected opaque type\n+...\n LL |     b_raw = f_raw as *mut _;\n-   |             ^^^^^^^^^^^^^^^\n+   |             ^^^^^ expected opaque type, found a different opaque type\n    |\n-   = note: vtable kinds may not match\n+   = note: expected opaque type `impl Debug + ?Sized` (opaque type at <$DIR/casts-differing-anon.rs:7:17>)\n+              found opaque type `impl Debug + ?Sized` (opaque type at <$DIR/casts-differing-anon.rs:3:17>)\n+   = note: distinct uses of `impl Trait` result in different opaque types\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0606`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "46379a3815a4db9b32188fdefbdc813025176b08", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/borrowck/borrowck-4.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-4.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,10 +8,10 @@ LL |        println!(\"{:?}\", p);\n    |                         - `p` is borrowed here\n    |\n note: closure is returned here\n-  --> $DIR/borrowck-4.rs:8:14\n+  --> $DIR/borrowck-4.rs:15:5\n    |\n-LL | fn foo () -> impl FnMut()->() {\n-   |              ^^^^^^^^^^^^^^^^\n+LL |     c\n+   |     ^\n help: to force the closure to take ownership of `p` (and any other referenced variables), use the `move` keyword\n    |\n LL |     let mut c = move || {"}, {"sha": "9dc486980aaca215af8098ac8f9d187ef8e0c4ed", "filename": "src/test/ui/conservative_impl_trait.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: `()` is not an iterator\n-  --> $DIR/conservative_impl_trait.rs:3:33\n+  --> $DIR/conservative_impl_trait.rs:3:60\n    |\n-LL | fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n+LL |   fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n+   |  ____________________________________________________________^\n+LL | |\n+LL | | }\n+   | |_^ `()` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `()`\n "}, {"sha": "b3bd88ad7d5d8dd3e592978fcbc12a83a56bb394", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,8 +4,8 @@ trait Trait {}\n impl<const N: u32> Trait for Uwu<N> {}\n \n fn rawr() -> impl Trait {\n-    //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n     Uwu::<10, 12>\n+    //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n }\n \n trait Traitor<const N: u8 = 1, const M: u8 = N> { }\n@@ -15,13 +15,13 @@ impl Traitor<1, 2> for u64 {}\n \n \n fn uwu<const N: u8>() -> impl Traitor<N> {\n-    //~^ error: the trait bound `u32: Traitor<N, N>` is not satisfied\n     1_u32\n+    //~^ error: the trait bound `u32: Traitor<N, N>` is not satisfied\n }\n \n fn owo() -> impl Traitor {\n-    //~^ error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n     1_u64\n+    //~^ error: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n }\n \n fn main() {"}, {"sha": "ec23952114cdfc0a6960cac6762acb13ae0b09a4", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,26 +1,26 @@\n error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:6:14\n+  --> $DIR/rp_impl_trait_fail.rs:7:5\n    |\n-LL | fn rawr() -> impl Trait {\n-   |              ^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n+LL |     Uwu::<10, 12>\n+   |     ^^^^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n    |\n    = help: the following implementations were found:\n              <Uwu<N> as Trait>\n \n error[E0277]: the trait bound `u32: Traitor<N, N>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:17:26\n+  --> $DIR/rp_impl_trait_fail.rs:18:5\n    |\n-LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n-   |                          ^^^^^^^^^^^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n+LL |     1_u32\n+   |     ^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n    |\n    = help: the following implementations were found:\n              <u32 as Traitor<N, 2_u8>>\n \n error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:22:13\n+  --> $DIR/rp_impl_trait_fail.rs:23:5\n    |\n-LL | fn owo() -> impl Traitor {\n-   |             ^^^^^^^^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n+LL |     1_u64\n+   |     ^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n    |\n    = help: the following implementations were found:\n              <u64 as Traitor<1_u8, 2_u8>>"}, {"sha": "eab5a6190ef51a0d62d4039bc6cb15ed1a67bfb2", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,11 +4,9 @@\n //~^^^ ERROR `main` function not found in crate\n pub mod foo {\n     type MainFn = impl Fn();\n-    //~^ ERROR could not find defining uses\n \n     fn bar() {}\n     pub const BAR: MainFn = bar;\n-    //~^ ERROR mismatched types [E0308]\n }\n \n use foo::BAR as main;"}, {"sha": "83a189e01e0132b8dc98ce68cdb4ca2f56ce97c4", "filename": "src/test/ui/entry-point/imported_main_const_fn_item_type_forbidden.stderr", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fentry-point%2Fimported_main_const_fn_item_type_forbidden.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -12,25 +12,6 @@ LL | | use foo::BAR as main;\n    |       |\n    |       non-function item at `crate::main` is found\n \n-error[E0308]: mismatched types\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:10:29\n-   |\n-LL |     type MainFn = impl Fn();\n-   |                   --------- the expected opaque type\n-...\n-LL |     pub const BAR: MainFn = bar;\n-   |                             ^^^ expected opaque type, found fn item\n-   |\n-   = note: expected opaque type `impl Fn()`\n-                  found fn item `fn() {bar}`\n-\n-error: could not find defining uses\n-  --> $DIR/imported_main_const_fn_item_type_forbidden.rs:6:19\n-   |\n-LL |     type MainFn = impl Fn();\n-   |                   ^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0601.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "6dfd7f6840f1b8807daef10c35f9dc063d8b9c84", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,13 +1,13 @@\n // ignore-compare-mode-chalk\n+// check-pass\n #![feature(type_alias_impl_trait)]\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n-//~^ ERROR could not find defining uses\n \n struct Bar(Foo);\n fn define() -> Bar {\n-    Bar(42) //~ ERROR mismatched types\n+    Bar(42)\n }\n \n type Foo2 = impl Debug;\n@@ -17,21 +17,18 @@ fn define2() {\n }\n \n type Foo3 = impl Debug;\n-//~^ ERROR could not find defining uses\n \n fn define3(x: Foo3) {\n-    let y: i32 = x; //~ ERROR mismatched types\n+    let y: i32 = x;\n }\n fn define3_1() {\n-    define3(42) //~ ERROR mismatched types\n+    define3(42)\n }\n \n type Foo4 = impl Debug;\n-//~^ ERROR could not find defining uses\n \n fn define4() {\n     let y: Foo4 = 42;\n-    //~^ ERROR mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "da3ddb1c50979f852528bc26518b9b028dd54c88", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,73 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:10:9\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL |     Bar(42)\n-   |         ^^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:23:18\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ---------- the found opaque type\n-...\n-LL |     let y: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-   |\n-   = note:     expected type `i32`\n-           found opaque type `impl Debug`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:26:13\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ---------- the expected opaque type\n-...\n-LL |     define3(42)\n-   |             ^^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:33:19\n-   |\n-LL | type Foo4 = impl Debug;\n-   |             ---------- the expected opaque type\n-...\n-LL |     let y: Foo4 = 42;\n-   |            ----   ^^ expected opaque type, found integer\n-   |            |\n-   |            expected due to this\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:5:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:19:13\n-   |\n-LL | type Foo3 = impl Debug;\n-   |             ^^^^^^^^^^\n-\n-error: could not find defining uses\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:29:13\n-   |\n-LL | type Foo4 = impl Debug;\n-   |             ^^^^^^^^^^\n-\n-error: aborting due to 7 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "c4905995a860a59187a6a4779703efd49c78b4b4", "filename": "src/test/ui/generator/issue-88653.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,10 +6,10 @@\n use std::ops::Generator;\n \n fn foo(bar: bool) -> impl Generator<(bool,)> {\n-//~^ ERROR: type mismatch in generator arguments [E0631]\n-//~| NOTE: expected signature of `fn((bool,)) -> _`\n     |bar| {\n     //~^ NOTE: found signature of `fn(bool) -> _`\n+    //~| ERROR: type mismatch in generator arguments [E0631]\n+    //~| NOTE: expected signature of `fn((bool,)) -> _`\n         if bar {\n             yield bar;\n         }"}, {"sha": "a44e273f854ceb80e3acff5a1aac4346aef0603c", "filename": "src/test/ui/generator/issue-88653.stderr", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-88653.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,18 @@\n error[E0631]: type mismatch in generator arguments\n-  --> $DIR/issue-88653.rs:8:22\n+  --> $DIR/issue-88653.rs:9:5\n    |\n-LL | fn foo(bar: bool) -> impl Generator<(bool,)> {\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn((bool,)) -> _`\n-...\n-LL |     |bar| {\n-   |     ----- found signature of `fn(bool) -> _`\n+LL |       |bar| {\n+   |       ^----\n+   |       |\n+   |  _____found signature of `fn(bool) -> _`\n+   | |\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^ expected signature of `fn((bool,)) -> _`\n \n error: aborting due to previous error\n "}, {"sha": "d1b16b6e10da0fe05f5727e4e61cdb17d01ea137", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2,8 +2,8 @@\n \n use std::ops::Generator;\n \n-fn foo() -> impl Generator<Return = i32> { //~ ERROR type mismatch\n-    || {\n+fn foo() -> impl Generator<Return = i32> {\n+    || { //~ ERROR type mismatch\n         if false {\n             return Ok(6);\n         }"}, {"sha": "3e78e5b53ba1fe818ec46970fc37e16fe33ed7ff", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -13,13 +13,19 @@ LL |             return Ok(6);\n    |                    ^^^^^\n \n error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6] as Generator>::Return == i32`\n-  --> $DIR/type-mismatch-signature-deduction.rs:5:13\n+  --> $DIR/type-mismatch-signature-deduction.rs:6:5\n    |\n-LL | fn foo() -> impl Generator<Return = i32> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found enum `Result`\n+LL | /     || {\n+LL | |         if false {\n+LL | |             return Ok(6);\n+LL | |         }\n+...  |\n+LL | |         5\n+LL | |     }\n+   | |_____^ expected enum `Result`, found `i32`\n    |\n-   = note: expected type `i32`\n-              found enum `Result<{integer}, _>`\n+   = note: expected enum `Result<{integer}, _>`\n+              found type `i32`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "16b56db75debc67132efea5c8a22a0793843cc5f", "filename": "src/test/ui/generic-associated-types/issue-87258_a.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -16,7 +16,8 @@ pub trait Trait2 {\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = impl Trait1;\n-    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n+    //~^ ERROR could not find defining uses\n+    fn foo<'a>() -> Self::FooFuture<'a> {\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "25166a5f5e12945650b70e8234f7dc66f098be15", "filename": "src/test/ui/generic-associated-types/issue-87258_a.stderr", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_a.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,8 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-87258_a.rs:19:21\n+error: could not find defining uses\n+  --> $DIR/issue-87258_a.rs:18:26\n    |\n-LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n-   |                     ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n+LL |     type FooFuture<'a> = impl Trait1;\n+   |                          ^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "30bdc29474eb6759ac30ba7d853eca61662aea7a", "filename": "src/test/ui/generic-associated-types/issue-87258_b.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -15,10 +15,11 @@ pub trait Trait2 {\n }\n \n type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n+//~^ ERROR could not find defining uses\n \n impl<'c, S: Trait2> Trait2 for &'c mut S {\n     type FooFuture<'a> = Helper<'c, 'a, S>;\n-    fn foo<'a>() -> Self::FooFuture<'a> { //~ ERROR\n+    fn foo<'a>() -> Self::FooFuture<'a> {\n         Struct(unimplemented!())\n     }\n }"}, {"sha": "ea30117201e0f3f22bdd966761ab06c5ec30aed9", "filename": "src/test/ui/generic-associated-types/issue-87258_b.stderr", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-87258_b.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,8 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-87258_b.rs:21:21\n+error: could not find defining uses\n+  --> $DIR/issue-87258_b.rs:17:49\n    |\n-LL |     fn foo<'a>() -> Self::FooFuture<'a> {\n-   |                     ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: hidden type `Struct<'_>` captures lifetime '_#7r\n+LL | type Helper<'xenon, 'yttrium, KABOOM: Trait2> = impl Trait1;\n+   |                                                 ^^^^^^^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "6c3a75c85714ab89fad9edaf4acf79ddf85f507a", "filename": "src/test/ui/generic-associated-types/issue-88595.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -16,10 +16,10 @@ LL |     type B<'b> = impl Clone;\n    |            ^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-88595.rs:23:23\n+  --> $DIR/issue-88595.rs:23:35\n    |\n LL |     fn a(&'a self) -> Self::B<'a> {}\n-   |                       ^^^^^^^^^^^\n+   |                                   ^^\n    |\n note: lifetime used multiple times\n   --> $DIR/issue-88595.rs:18:6"}, {"sha": "f8c89829e1646760dbebe5ea832c34b7406f707d", "filename": "src/test/ui/generic-associated-types/issue-92096.migrate.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.migrate.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,18 +1,20 @@\n error[E0311]: the parameter type `C` may not live long enough\n-  --> $DIR/issue-92096.rs:20:33\n+  --> $DIR/issue-92096.rs:24:5\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n-   |                 |\n-   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n+   |                 - help: consider adding an explicit lifetime bound...: `C: 'a`\n+...\n+LL |     async move { c.connect().await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n \n error[E0311]: the parameter type `C` may not live long enough\n-  --> $DIR/issue-92096.rs:20:33\n+  --> $DIR/issue-92096.rs:24:5\n    |\n LL | fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-   |                 -               ^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n-   |                 |\n-   |                 help: consider adding an explicit lifetime bound...: `C: 'a`\n+   |                 - help: consider adding an explicit lifetime bound...: `C: 'a`\n+...\n+LL |     async move { c.connect().await }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `C` will meet its required lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2bc1af5506ffd50876bd11eb68b819021799bc33", "filename": "src/test/ui/generic-associated-types/issue-92096.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-92096.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -18,12 +18,12 @@ trait Client {\n }\n \n fn call_connect<C>(c: &'_ C) -> impl '_ + Future + Send\n-//[migrate]~^ ERROR the parameter\n-//[migrate]~| ERROR the parameter\n where\n     C: Client + Send + Sync,\n {\n     async move { c.connect().await }\n+    //[migrate]~^ ERROR the parameter\n+    //[migrate]~| ERROR the parameter\n }\n \n fn main() {}"}, {"sha": "d2452abab02549987b5352dfcd8624a60d307108", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -11,6 +11,7 @@ fn main() {\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n     //~^ ERROR cycle detected\n+    //~| ERROR cycle detected\n     send(cycle2().clone());\n \n     Rc::new(Cell::new(5))"}, {"sha": "14db864f1c28af51ad3dcbf60085e9860f920818", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 97, "deletions": 15, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -30,47 +30,129 @@ note: ...which requires building MIR for `cycle1`...\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:14:5\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing type of `cycle2::{opaque#0}`...\n+  --> $DIR/auto-trait-leak.rs:20:16\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   |                ^^^^^^^^^^\n+note: ...which requires borrow-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:20:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/auto-trait-leak.rs:1:1\n+   |\n+LL | / use std::cell::Cell;\n+LL | | use std::rc::Rc;\n+LL | |\n+LL | | fn send<T: Send>(_: T) {}\n+...  |\n+LL | |     Rc::new(String::from(\"foo\"))\n+LL | | }\n+   | |_^\n+\n+error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n+  --> $DIR/auto-trait-leak.rs:12:16\n    |\n-LL |     send(cycle2().clone());\n-   |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+LL | fn cycle1() -> impl Clone {\n+   |                ^^^^^^^^^^\n+   |\n+note: ...which requires borrow-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing MIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires computing type of `cycle2::{opaque#0}`...\n-  --> $DIR/auto-trait-leak.rs:19:16\n+  --> $DIR/auto-trait-leak.rs:20:16\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:20:5\n+  --> $DIR/auto-trait-leak.rs:20:1\n    |\n-LL |     send(cycle1().clone());\n-   |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1\n@@ -84,6 +166,6 @@ LL | |     Rc::new(String::from(\"foo\"))\n LL | | }\n    | |_^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "20ddad0547ef2b8eddf2db970ab1427360ac24ce", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -23,8 +23,8 @@ mod impl_trait {\n \n     /// `T::Assoc` can't be normalized any further here.\n     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n-        //~^ ERROR: type mismatch\n         Foo(())\n+        //~^ ERROR: type mismatch\n     }\n }\n \n@@ -39,9 +39,9 @@ mod lifetimes {\n \n     /// Missing bound constraining `Assoc`, `T::Assoc` can't be normalized further.\n     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-        //~^ ERROR: type mismatch\n-        //~^^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+        //~^ ERROR `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n         Foo(())\n+        //~^ ERROR: type mismatch\n     }\n }\n "}, {"sha": "01fb853e1d1f7b568846dbac312974818acd8cfc", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,16 +1,16 @@\n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:25:32\n+  --> $DIR/bound-normalization-fail.rs:26:9\n    |\n-LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output = T::Assoc> {\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n+LL |         Foo(())\n+   |         ^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n    |\n-note: expected this to be `<T as impl_trait::Trait>::Assoc`\n+note: expected this to be `()`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note: expected associated type `<T as impl_trait::Trait>::Assoc`\n-                    found unit type `()`\n+   = note:    expected unit type `()`\n+           found associated type `<T as impl_trait::Trait>::Assoc`\n help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc` to `()`\n    |\n LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n@@ -23,18 +23,18 @@ LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:41:41\n+  --> $DIR/bound-normalization-fail.rs:43:9\n    |\n-LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+LL |         Foo(())\n+   |         ^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n    |\n-note: expected this to be `<T as lifetimes::Trait<'static>>::Assoc`\n+note: expected this to be `()`\n   --> $DIR/bound-normalization-fail.rs:14:19\n    |\n LL |     type Output = T;\n    |                   ^\n-   = note: expected associated type `<T as lifetimes::Trait<'static>>::Assoc`\n-                    found unit type `()`\n+   = note:    expected unit type `()`\n+           found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {"}, {"sha": "750687e2322284fc055ad262e08b0edd6254ed10", "filename": "src/test/ui/impl-trait/does-not-live-long-enough.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdoes-not-live-long-enough.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -7,10 +7,10 @@ LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref\n    |                                 may outlive borrowed value `prefix`\n    |\n note: closure is returned here\n-  --> $DIR/does-not-live-long-enough.rs:5:55\n+  --> $DIR/does-not-live-long-enough.rs:6:9\n    |\n-LL |     fn started_with<'a>(&'a self, prefix: &'a str) -> impl Iterator<Item=&'a str> {\n-   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         self.data.iter().filter(|s| s.starts_with(prefix)).map(|s| s.as_ref())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: to force the closure to take ownership of `prefix` (and any other referenced variables), use the `move` keyword\n    |\n LL |         self.data.iter().filter(move |s| s.starts_with(prefix)).map(|s| s.as_ref())"}, {"sha": "59770c10da2b2e14ab039a20c45618bc5283208d", "filename": "src/test/ui/impl-trait/equality.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -17,8 +17,8 @@ fn two(x: bool) -> impl Foo {\n     //~| expected `i32`, found `u32`\n }\n \n-fn sum_to(n: u32) -> impl Foo { //~ ERROR type annotations needed\n-    if n == 0 {\n+fn sum_to(n: u32) -> impl Foo {\n+    if n == 0 { //~ ERROR type annotations needed\n         0\n     } else {\n         n + sum_to(n - 1)"}, {"sha": "f79411c1003ebdad8e693167ff2b7b92e8df306a", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -11,20 +11,11 @@ LL | #![feature(specialization)]\n error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n-LL | fn two(x: bool) -> impl Foo {\n-   |                    -------- expected because this return type...\n-LL |     if x {\n LL |         return 1_i32;\n-   |                ----- ...is found to be `i32` here\n+   |                ----- type expected due to this\n LL |     }\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: if the trait `Foo` were object safe, you could return a boxed trait object\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11\n@@ -35,10 +26,15 @@ LL |         n + sum_to(n - 1)\n    = help: the trait `Add<impl Foo>` is not implemented for `u32`\n \n error[E0283]: type annotations needed\n-  --> $DIR/equality.rs:20:22\n-   |\n-LL | fn sum_to(n: u32) -> impl Foo {\n-   |                      ^^^^^^^^ cannot infer type for type `{integer}`\n+  --> $DIR/equality.rs:21:5\n+   |\n+LL | /     if n == 0 {\n+LL | |         0\n+LL | |     } else {\n+LL | |         n + sum_to(n - 1)\n+LL | |\n+LL | |     }\n+   | |_____^ cannot infer type for type `{integer}`\n    |\n    = note: multiple `impl`s satisfying `{integer}: ToString` found in the `alloc` crate:\n            - impl ToString for i8;"}, {"sha": "fd33fa7c674f185e97a24a70987892b6e9af0b95", "filename": "src/test/ui/impl-trait/equality2.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -15,9 +15,7 @@ LL | fn hide<T: Foo>(x: T) -> impl Foo {\n    |                          -------- the found opaque type\n ...\n LL |     let _: u32 = hide(0_u32);\n-   |            ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n-   |            |\n-   |            expected due to this\n+   |                  ^^^^^^^^^^^ expected `u32`, found opaque type\n    |\n    = note:     expected type `u32`\n            found opaque type `impl Foo`"}, {"sha": "1e6eb5bb355888c04904570ec6cd6232dd1814db", "filename": "src/test/ui/impl-trait/fallback.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffallback.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+fn take_edge_counters(\n+    x: &mut Option<Vec<i32>>,\n+) -> Option<impl Iterator<Item = i32>> {\n+    x.take().map_or(None, |m| Some(m.into_iter()))\n+}\n+\n+fn main() {}"}, {"sha": "ae07c89276861140342005edf0fa90f54650ad45", "filename": "src/test/ui/impl-trait/hidden-lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -26,8 +26,8 @@ impl<T> Swap for Rc<RefCell<T>> {\n // Here we are hiding `'b` making the caller believe that `&'a mut &'s T` and\n // `&'a mut &'l T` are the same type.\n fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-    //~^ ERROR hidden type\n     x\n+    //~^ ERROR hidden type\n }\n \n fn dangle_ref() -> &'static [i32; 3] {\n@@ -43,8 +43,8 @@ fn dangle_ref() -> &'static [i32; 3] {\n // This is different to the previous example because the concrete return type\n // only has a single lifetime.\n fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-    //~^ ERROR hidden type\n     x\n+    //~^ ERROR hidden type\n }\n \n fn dangle_rc_refcell() -> &'static [i32; 3] {"}, {"sha": "97652f5462ef02487b72a2c6dc7588a4eed0f37d", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,23 +1,23 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:28:54\n+  --> $DIR/hidden-lifetimes.rs:29:5\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n-   |                 --                                   ^^^^^^^^^^^^^^\n-   |                 |\n-   |                 hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+   |                 -- hidden type `&'a mut &'b T` captures the lifetime `'b` as defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/hidden-lifetimes.rs:45:70\n+  --> $DIR/hidden-lifetimes.rs:46:5\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n-   |                        --                                            ^^^^^^^^^^^^^^\n-   |                        |\n-   |                        hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+   |                        -- hidden type `Rc<RefCell<&'b T>>` captures the lifetime `'b` as defined here\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |"}, {"sha": "7d29882995355351663b8ae358e5ee976186c661", "filename": "src/test/ui/impl-trait/issue-55872-1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,13 +8,13 @@ pub trait Bar {\n \n impl<S: Default> Bar for S {\n     type E = impl Copy;\n+    //~^ ERROR could not find defining uses\n \n     fn foo<T: Default>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-        //~| ERROR impl has stricter requirements than trait\n-        //~| ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n-        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~^ ERROR impl has stricter requirements than trait\n         (S::default(), T::default())\n+        //~^ ERROR the trait bound `S: Copy` is not satisfied in `(S, T)` [E0277]\n+        //~| ERROR the trait bound `T: Copy` is not satisfied in `(S, T)` [E0277]\n     }\n }\n "}, {"sha": "95138d86743ccae64376367ece4c9e019061c6db", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,5 @@\n error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/issue-55872-1.rs:12:15\n+  --> $DIR/issue-55872-1.rs:13:15\n    |\n LL |     fn foo<T>() -> Self::E;\n    |     ----------------------- definition of `foo` from trait\n@@ -8,10 +8,10 @@ LL |     fn foo<T: Default>() -> Self::E {\n    |               ^^^^^^^ impl has extra requirement `T: Default`\n \n error[E0277]: the trait bound `S: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:29\n+  --> $DIR/issue-55872-1.rs:15:9\n    |\n-LL |     fn foo<T: Default>() -> Self::E {\n-   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n+LL |         (S::default(), T::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n@@ -20,29 +20,22 @@ LL | impl<S: Default + std::marker::Copy> Bar for S {\n    |                 +++++++++++++++++++\n \n error[E0277]: the trait bound `T: Copy` is not satisfied in `(S, T)`\n-  --> $DIR/issue-55872-1.rs:12:29\n+  --> $DIR/issue-55872-1.rs:15:9\n    |\n-LL |     fn foo<T: Default>() -> Self::E {\n-   |                             ^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n+LL |         (S::default(), T::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n help: consider further restricting this bound\n    |\n LL |     fn foo<T: Default + std::marker::Copy>() -> Self::E {\n    |                       +++++++++++++++++++\n \n-error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-1.rs:12:37\n-   |\n-LL |       fn foo<T: Default>() -> Self::E {\n-   |  _____________________________________^\n-LL | |\n-LL | |\n-LL | |\n-LL | |\n-LL | |         (S::default(), T::default())\n-LL | |     }\n-   | |_____^\n+error: could not find defining uses\n+  --> $DIR/issue-55872-1.rs:10:14\n+   |\n+LL |     type E = impl Copy;\n+   |              ^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f0bc0b5272784dbfcf73c1bafdd92b6424aacf30", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,17 +4,16 @@\n #![feature(type_alias_impl_trait)]\n \n pub trait Bar {\n-    type E: Copy;\n+    type E: Send;\n \n     fn foo<T>() -> Self::E;\n }\n \n impl<S> Bar for S {\n-    type E = impl std::marker::Copy;\n+    type E = impl std::marker::Send;\n     fn foo<T>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-        //~| ERROR the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n         async {}\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "71090bdbf8061909314c83d226b5f9125424b410", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,20 +1,8 @@\n-error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n-  --> $DIR/issue-55872-2.rs:14:20\n-   |\n-LL |     fn foo<T>() -> Self::E {\n-   |                    ^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n-\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-2.rs:14:28\n+  --> $DIR/issue-55872-2.rs:15:9\n    |\n-LL |       fn foo<T>() -> Self::E {\n-   |  ____________________________^\n-LL | |\n-LL | |\n-LL | |         async {}\n-LL | |     }\n-   | |_____^\n+LL |         async {}\n+   |         ^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "70f3c3c737ac98afe13fbd6ca26256a6387254d7", "filename": "src/test/ui/impl-trait/issue-55872-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,21 @@\n+// edition:2018\n+// ignore-compare-mode-chalk\n+\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Bar {\n+    type E: Copy;\n+\n+    fn foo<T>() -> Self::E;\n+}\n+\n+impl<S> Bar for S {\n+    type E = impl std::marker::Copy;\n+    //~^ ERROR could not find defining uses\n+    fn foo<T>() -> Self::E {\n+        async {}\n+        //~^ ERROR the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied [E0277]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5ef0b02006a71b3619c9e472a575406cc91c231c", "filename": "src/test/ui/impl-trait/issue-55872-3.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-3.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n+  --> $DIR/issue-55872-3.rs:16:9\n+   |\n+LL |         async {}\n+   |         ^^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n+\n+error: could not find defining uses\n+  --> $DIR/issue-55872-3.rs:13:14\n+   |\n+LL |     type E = impl std::marker::Copy;\n+   |              ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "65874d22ac6f3c92ae393da33488a801f334dce9", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -11,8 +11,8 @@ impl<S> Bar for S {\n     type E = impl Copy;\n \n     fn foo<T>() -> Self::E {\n-        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         || ()\n+        //~^ ERROR type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "7abcf6a05942268c5eb875a073fc3663497ef653", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872.rs:13:28\n+  --> $DIR/issue-55872.rs:14:9\n    |\n-LL |       fn foo<T>() -> Self::E {\n-   |  ____________________________^\n-LL | |\n-LL | |         || ()\n-LL | |     }\n-   | |_____^\n+LL |         || ()\n+   |         ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "d556e968f34e5f170bd7c40873e4d314de747d0e", "filename": "src/test/ui/impl-trait/issue-72911.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,7 +5,7 @@ pub struct Lint {}\n impl Lint {}\n \n pub fn gather_all() -> impl Iterator<Item = Lint> {\n-    //~^ ERROR: cannot resolve opaque type\n+    //~^ ERROR `()` is not an iterator\n     lint_files().flat_map(|f| gather_from_file(&f))\n }\n \n@@ -16,6 +16,7 @@ fn gather_from_file(dir_entry: &foo::MissingItem) -> impl Iterator<Item = Lint>\n \n fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n     //~^ ERROR: failed to resolve\n+    //~| ERROR `()` is not an iterator\n     unimplemented!()\n }\n "}, {"sha": "51648e6154dc3a5f0d702355080c6cc436faf608", "filename": "src/test/ui/impl-trait/issue-72911.stderr", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-72911.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -10,25 +10,23 @@ error[E0433]: failed to resolve: use of undeclared crate or module `foo`\n LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n    |                                         ^^^ use of undeclared crate or module `foo`\n \n-error[E0720]: cannot resolve opaque type\n+error[E0277]: `()` is not an iterator\n   --> $DIR/issue-72911.rs:7:24\n    |\n LL | pub fn gather_all() -> impl Iterator<Item = Lint> {\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ recursive opaque type\n-LL |\n-LL |     lint_files().flat_map(|f| gather_from_file(&f))\n-   |     -----------------------------------------------\n-   |     |\n-   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-   |     returning here with type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-...\n-LL | fn gather_from_file(dir_entry: &foo::MissingItem) -> impl Iterator<Item = Lint> {\n-   |                                                      -------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n-...\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `()`\n+\n+error[E0277]: `()` is not an iterator\n+  --> $DIR/issue-72911.rs:17:20\n+   |\n LL | fn lint_files() -> impl Iterator<Item = foo::MissingItem> {\n-   |                    -------------------------------------- returning this opaque type `FlatMap<impl Iterator<Item = [type error]>, [type error], [closure@$DIR/issue-72911.rs:9:27: 9:51]>`\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n+   |\n+   = help: the trait `Iterator` is not implemented for `()`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0433, E0720.\n-For more information about an error, try `rustc --explain E0433`.\n+Some errors have detailed explanations: E0277, E0433.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "42e5436390cbc5e7dd9b5f2218fa0115e8bd4ed4", "filename": "src/test/ui/impl-trait/issues/issue-70877.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,12 @@\n #![feature(type_alias_impl_trait)]\n \n+// check-pass\n+\n type FooArg<'a> = &'a dyn ToString;\n type FooRet = impl std::fmt::Debug;\n \n type FooItem = Box<dyn Fn(FooArg) -> FooRet>;\n-type Foo = impl Iterator<Item = FooItem>; //~ ERROR: type mismatch\n+type Foo = impl Iterator<Item = FooItem>;\n \n #[repr(C)]\n struct Bar(u8);"}, {"sha": "fe48e92da5eacc7d44c4a758f24b0413679c0cd3", "filename": "src/test/ui/impl-trait/issues/issue-70877.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-70877.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,20 +0,0 @@\n-error[E0271]: type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-  --> $DIR/issue-70877.rs:7:12\n-   |\n-LL | type FooRet = impl std::fmt::Debug;\n-   |               -------------------- the found opaque type\n-...\n-LL | type Foo = impl Iterator<Item = FooItem>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Bar as Iterator>::Item == Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-   |\n-note: expected this to be `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-  --> $DIR/issue-70877.rs:13:17\n-   |\n-LL |     type Item = FooItem;\n-   |                 ^^^^^^^\n-   = note: expected struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> Option<String> + 'static)>`\n-              found struct `Box<(dyn for<'r> Fn(&'r (dyn ToString + 'r)) -> impl Debug + 'static)>`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "b13ab6bad7fbed4e25354efeafa036b46e826ac6", "filename": "src/test/ui/impl-trait/issues/issue-78722.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -10,7 +10,8 @@ struct Bug {\n             async {}\n         }\n         let f: F = async { 1 };\n-        //~^ ERROR mismatched types [E0308]\n+        //~^ ERROR `async` blocks are not allowed in constants\n+        //~| ERROR destructors cannot be evaluated at compile-time\n         1\n     }],\n }"}, {"sha": "975c771759f9ba04bf5fbcd808f0b5fd7f8a7b3a", "filename": "src/test/ui/impl-trait/issues/issue-78722.stderr", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,23 +1,22 @@\n-error[E0308]: mismatched types\n+error[E0658]: `async` blocks are not allowed in constants\n   --> $DIR/issue-78722.rs:12:20\n    |\n-LL | type F = impl core::future::Future<Output = u8>;\n-   |          -------------------------------------- the expected opaque type\n-...\n LL |         let f: F = async { 1 };\n-   |                -   ^^^^^^^^^^^ expected opaque type, found a different opaque type\n-   |                |\n-   |                expected due to this\n-   |\n-  ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n+   |                    ^^^^^^^^^^^\n    |\n-LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                           ------------------------------- the found opaque type\n+   = note: see issue #85368 <https://github.com/rust-lang/rust/issues/85368> for more information\n+   = help: add `#![feature(const_async_blocks)]` to the crate attributes to enable\n+\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/issue-78722.rs:12:13\n    |\n-   = note: expected opaque type `impl Future<Output = u8>`\n-              found opaque type `impl Future<Output = [async output]>`\n-   = note: distinct uses of `impl Trait` result in different opaque types\n+LL |         let f: F = async { 1 };\n+   |             ^ constants cannot evaluate destructors\n+...\n+LL |     }],\n+   |     - value is dropped here\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0493, E0658.\n+For more information about an error, try `rustc --explain E0493`."}, {"sha": "0786e66ca8b06c6969184d2160f97a18bd5c1a3f", "filename": "src/test/ui/impl-trait/issues/issue-86201.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,10 @@\n #![feature(unboxed_closures)]\n #![feature(type_alias_impl_trait)]\n \n+// check-pass\n+\n type FunType = impl Fn<()>;\n-//~^ ERROR could not find defining uses\n static STATIC_FN: FunType = some_fn;\n-//~^ ERROR mismatched types\n \n fn some_fn() {}\n "}, {"sha": "b1460096ded66d3119023e21099d1886ce602f53", "filename": "src/test/ui/impl-trait/issues/issue-86201.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-86201.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,21 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-86201.rs:6:29\n-   |\n-LL | type FunType = impl Fn<()>;\n-   |                ----------- the expected opaque type\n-LL |\n-LL | static STATIC_FN: FunType = some_fn;\n-   |                             ^^^^^^^ expected opaque type, found fn item\n-   |\n-   = note: expected opaque type `impl Fn<()>`\n-                  found fn item `fn() {some_fn}`\n-\n-error: could not find defining uses\n-  --> $DIR/issue-86201.rs:4:16\n-   |\n-LL | type FunType = impl Fn<()>;\n-   |                ^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "834f2dc6cb5b6dfde14de37e2e7cd83d73e9c85e", "filename": "src/test/ui/impl-trait/lifetimes2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Flifetimes2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+pub fn keys<'a>(x: &'a Result<u32, u32>) -> impl std::fmt::Debug + 'a {\n+    match x {\n+        Ok(map) => Ok(map),\n+        Err(map) => Err(map),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f5aaf1185211b44d67e06cc6b7deffa351b64ea0", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,7 +8,6 @@ impl<T: Copy> Copy for CopyIfEq<T, T> {}\n type E<'a, 'b> = impl Sized;\n \n fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n     let v = CopyIfEq::<*mut _, *mut _>(&mut { x }, &mut y);\n \n     // This assignment requires that `x` and `y` have the same type due to the\n@@ -21,6 +20,7 @@ fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n         let _: &'b i32 = *u.0;\n     }\n     u.0\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "b837b64110365d47585e9d702a7d52c2f51d33ca", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/error-handling-2.rs:10:60\n+  --> $DIR/error-handling-2.rs:22:5\n    |\n LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-   |        --                                                  ^^^^^^^^^\n-   |        |\n-   |        hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n+   |        -- hidden type `*mut &'a i32` captures the lifetime `'a` as defined here\n+...\n+LL |     u.0\n+   |     ^^^\n \n error: aborting due to previous error\n "}, {"sha": "c4b56cd62534fabb7b6bb1ccd125cef428aa4f13", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -14,7 +14,6 @@ struct Ordinary<'a>(&'a u8);\n // by both `'a` and `'b`.\n \n fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n where\n     'a: 'e,\n     'b: 'd,\n@@ -27,6 +26,8 @@ where\n     // 'a in ['d, 'e]\n     // ```\n     if condition() { a } else { b }\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    //~| ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "04a5d73e0d378b25434da8f072b8161a7d612a82", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,16 +1,31 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unrelated.rs:16:74\n+  --> $DIR/ordinary-bounds-unrelated.rs:28:22\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n-   |                     --                                                   ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                      ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e> + 'b\n    |                                                                                             ++++\n \n-error: aborting due to previous error\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unrelated.rs:28:33\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                                 ^\n+   |\n+help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e> + 'b\n+   |                                                                                             ++++\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0700`."}, {"sha": "ff2832c8986e50c558233b44cd62016947a6a043", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -16,7 +16,6 @@ struct Ordinary<'a>(&'a u8);\n // consider the loans for both `'a` and `'b` alive.\n \n fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n {\n     // We return a value:\n     //\n@@ -30,6 +29,8 @@ fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n     //\n     // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n     if condition() { a } else { b }\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    //~| ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n }\n \n fn condition() -> bool {"}, {"sha": "018ba3ea5f7609ab5a89fc616c35ea09c5af7348", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,16 +1,31 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ordinary-bounds-unsuited.rs:18:62\n+  --> $DIR/ordinary-bounds-unsuited.rs:31:22\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n-   |                     --                                       ^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                      ^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> + 'b\n    |                                                                                 ++++\n \n-error: aborting due to previous error\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unsuited.rs:31:33\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+   |                     -- hidden type `Ordinary<'b>` captures the lifetime `'b` as defined here\n+...\n+LL |     if condition() { a } else { b }\n+   |                                 ^\n+   |\n+help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> + 'b\n+   |                                                                                 ++++\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0700`."}, {"sha": "eb38f84d4afec35c89c6ba4b691f2fe53d5c553d", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^\n+   |              ----                 ^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^\n+   |             --                             ^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -67,23 +67,23 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              --                             ^^^^^^^^^^^^^^^^\n-   |                              |\n-   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n+LL |     move |_| println!(\"{}\", y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:39:5\n    |\n-LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                                   ^^^^^^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "02ea0255912ab390240ee006707eaa443e8f8d8a", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -31,13 +31,13 @@ fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x } //~ ERRO\n // Tests that a closure type containing 'b cannot be returned from a type where\n // only 'a was expected.\n fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-    //~^ ERROR: captures lifetime that does not appear in bounds\n     move |_| println!(\"{}\", y)\n+    //~^ ERROR: captures lifetime that does not appear in bounds\n }\n \n fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-    //~^ ERROR the parameter type `T` may not live long enough\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "77ba0bf908763a90128278f93036c4aa5a8189f7", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:23\n+  --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |              ----     ^^^^^^^^^\n+   |              ----                 ^\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n@@ -12,10 +12,10 @@ LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:32\n+  --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             --                 ^^^^^^^^^\n+   |             --                             ^\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n@@ -28,15 +28,10 @@ error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'sta\n   --> $DIR/must_outlive_least_region_or_bound.rs:9:46\n    |\n LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n-   |               ----                           ^ ...is used here...\n+   |               ----                           ^ ...is used and required to live as long as `'static` here\n    |               |\n    |               this data with an anonymous lifetime `'_`...\n    |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:9:24\n-   |\n-LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n-   |                        ^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n@@ -50,15 +45,10 @@ error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n-   |                     -------                           ^ ...is used here...\n+   |                     -------                           ^ ...is used and required to live as long as `'static` here\n    |                     |\n    |                     this data with lifetime `'a`...\n    |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:11:33\n-   |\n-LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n-   |                                 ^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n@@ -69,10 +59,10 @@ LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n    |                     ~~~~~~~~~~~~\n \n error[E0621]: explicit lifetime required in the type of `x`\n-  --> $DIR/must_outlive_least_region_or_bound.rs:13:24\n+  --> $DIR/must_outlive_least_region_or_bound.rs:13:41\n    |\n LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n-   |               ----     ^^^^^^^^^^^^^^ lifetime `'a` required\n+   |               ----                      ^ lifetime `'a` required\n    |               |\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n@@ -95,13 +85,8 @@ error[E0759]: `x` has lifetime `'a` but it needs to satisfy a `'static` lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                      ------- this data with lifetime `'a`...        ^ ...is used here...\n-   |\n-note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:29:34\n+   |                      ------- this data with lifetime `'a`...        ^ ...is used and required to live as long as `'static` here\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n@@ -112,25 +97,25 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ~~~~~~~~~~~~\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n-   |                              --                             ^^^^^^^^^^^^^^^^\n-   |                              |\n-   |                              hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:35:5: 35:31]` captures the lifetime `'b` as defined here\n+   |                              -- hidden type `[closure@$DIR/must_outlive_least_region_or_bound.rs:34:5: 34:31]` captures the lifetime `'b` as defined here\n+LL |     move |_| println!(\"{}\", y)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:39:5\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |                                 |\n-   |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n+   |                                 -- help: consider adding an explicit lifetime bound...: `T: 'static +`\n+LL |     x\n+   |     ^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0759]: `x` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement\n   --> $DIR/must_outlive_least_region_or_bound.rs:16:50"}, {"sha": "4b4116887dc27ef5f17c87950070c5535108e896", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,47 +1,20 @@\n error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n    |\n-LL | fn can() -> impl NotObjectSafe {\n-   |             ------------------ expected because this return type...\n-LL |     if true {\n LL |         return A;\n-   |                - ...is found to be `A` here\n+   |                - type expected due to this\n LL |     }\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n    |\n-LL | fn cat() -> impl ObjectSafe {\n-   |             --------------- expected because this return type...\n-LL |     if true {\n LL |         return A;\n-   |                - ...is found to be `A` here\n+   |                - type expected due to this\n LL |     }\n LL |     B\n    |     ^ expected struct `A`, found struct `B`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn cat() -> Box<dyn ObjectSafe> {\n-   |             ~~~~~~~           +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(A);\n-LL |     }\n-LL ~     Box::new(B)\n-   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9f9a6c784e638d64607e03e57c7e70c76db0715e", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -14,10 +14,10 @@ fn bar() -> impl std::fmt::Display {\n }\n \n fn baz() -> impl std::fmt::Display {\n-    if false {\n+    if false { //~ ERROR mismatched types\n         return 0i32;\n     } else {\n-        1u32 //~ ERROR mismatched types\n+        1u32\n     }\n }\n \n@@ -30,9 +30,9 @@ fn qux() -> impl std::fmt::Display {\n }\n \n fn bat() -> impl std::fmt::Display {\n-    match 13 {\n+    match 13 { //~ ERROR mismatched types\n         0 => return 0i32,\n-        _ => 1u32, //~ ERROR mismatched types\n+        _ => 1u32,\n     }\n }\n \n@@ -45,12 +45,12 @@ fn can() -> impl std::fmt::Display {\n }\n \n fn cat() -> impl std::fmt::Display {\n-    match 13 {\n+    match 13 { //~ ERROR mismatched types\n         0 => {\n             return 0i32;\n         }\n         _ => {\n-            1u32 //~ ERROR mismatched types\n+            1u32\n         }\n     }\n }"}, {"sha": "eb0d3a52a4eb76990c7a435572d9adeb419f5aef", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 28, "deletions": 150, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,83 +1,31 @@\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n-LL | fn foo() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n+   |                ---- type expected due to this\n LL |     }\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn foo() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     }\n-LL ~     Box::new(1u32)\n-   |\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:12:16\n    |\n-LL | fn bar() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n+   |                ---- type expected due to this\n LL |     } else {\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn bar() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     } else {\n-LL ~         return Box::new(1u32);\n-   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:20:9\n-   |\n-LL | fn baz() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     if false {\n-LL |         return 0i32;\n-   |                ---- ...is found to be `i32` here\n-LL |     } else {\n-LL |         1u32\n-   |         ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn baz() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         return Box::new(0i32);\n-LL |     } else {\n-LL ~         Box::new(1u32)\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:17:5\n    |\n+LL | /     if false {\n+LL | |         return 0i32;\n+   | |                ---- type expected due to this\n+LL | |     } else {\n+LL | |         1u32\n+LL | |     }\n+   | |_____^ expected `i32`, found `u32`\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:28:9\n@@ -103,87 +51,38 @@ LL ~         Box::new(1u32)\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:35:14\n-   |\n-LL | fn bat() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-LL |     match 13 {\n-LL |         0 => return 0i32,\n-   |                     ---- ...is found to be `i32` here\n-LL |         _ => 1u32,\n-   |              ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn bat() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         0 => return Box::new(0i32),\n-LL ~         _ => Box::new(1u32),\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:33:5\n    |\n+LL | /     match 13 {\n+LL | |         0 => return 0i32,\n+   | |                     ---- type expected due to this\n+LL | |         _ => 1u32,\n+LL | |     }\n+   | |_____^ expected `i32`, found `u32`\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:40:5\n    |\n-LL |   fn can() -> impl std::fmt::Display {\n-   |               ---------------------- expected because this return type...\n LL | /     match 13 {\n LL | |         0 => return 0i32,\n-   | |                     ---- ...is found to be `i32` here\n+   | |                     ---- type expected due to this\n LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn can() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~     Box::new(match 13 {\n-LL ~         0 => return Box::new(0i32),\n-LL |         1 => 1u32,\n-LL |         _ => 2u32,\n-LL ~     })\n-   |\n \n error[E0308]: mismatched types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:53:13\n-   |\n-LL | fn cat() -> impl std::fmt::Display {\n-   |             ---------------------- expected because this return type...\n-...\n-LL |             return 0i32;\n-   |                    ---- ...is found to be `i32` here\n-...\n-LL |             1u32\n-   |             ^^^^ expected `i32`, found `u32`\n-   |\n-   = note: to return `impl Trait`, all returned values must be of the same type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = help: you could instead create a new `enum` with a variant for each returned type\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn cat() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~             return Box::new(0i32);\n-LL |         }\n-LL |         _ => {\n-LL ~             Box::new(1u32)\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:48:5\n    |\n+LL | /     match 13 {\n+LL | |         0 => {\n+LL | |             return 0i32;\n+   | |                    ---- type expected due to this\n+LL | |         }\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^ expected `i32`, found `u32`\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:61:14\n@@ -196,16 +95,6 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____- `match` arms have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn dog() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         0 => Box::new(0i32),\n-LL ~         1 => Box::new(1u32),\n-   |\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n@@ -218,17 +107,6 @@ LL | |         1u32\n    | |         ^^^^ expected `i32`, found `u32`\n LL | |     }\n    | |_____- `if` and `else` have incompatible types\n-   |\n-help: you could change the return type to be a boxed trait object\n-   |\n-LL | fn apt() -> Box<dyn std::fmt::Display> {\n-   |             ~~~~~~~                  +\n-help: if you change the return type to expect trait objects, box the returned expressions\n-   |\n-LL ~         Box::new(0i32)\n-LL |     } else {\n-LL ~         Box::new(1u32)\n-   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13"}, {"sha": "2e7cb21592cb0b714cfacf8a28d7c3b3ce3a859d", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -11,8 +11,8 @@ pub trait Test {}\n impl<T> Test for T where T: Super<Assoc = ()> {}\n \n fn test() -> impl Test {\n-    //~^ERROR type mismatch resolving `<() as Super>::Assoc == ()`\n     ()\n+    //~^ERROR type mismatch resolving `<() as Super>::Assoc == ()`\n }\n \n fn main() {"}, {"sha": "5ef1e9abef6319538191a4af186185341c3e9b6e", "filename": "src/test/ui/impl-trait/projection-mismatch-in-impl-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprojection-mismatch-in-impl-where-clause.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,10 @@\n error[E0271]: type mismatch resolving `<() as Super>::Assoc == ()`\n-  --> $DIR/projection-mismatch-in-impl-where-clause.rs:13:14\n+  --> $DIR/projection-mismatch-in-impl-where-clause.rs:14:5\n    |\n-LL | fn test() -> impl Test {\n-   |              ^^^^^^^^^ type mismatch resolving `<() as Super>::Assoc == ()`\n+LL |     ()\n+   |     ^^ type mismatch resolving `<() as Super>::Assoc == ()`\n    |\n-note: expected this to be `()`\n+note: expected this to be `u8`\n   --> $DIR/projection-mismatch-in-impl-where-clause.rs:6:18\n    |\n LL |     type Assoc = u8;"}, {"sha": "211f7972dbca890e17e5af268e44acce89defd36", "filename": "src/test/ui/impl-trait/question_mark.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fquestion_mark.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn foo() -> impl MyTrait {\n+    panic!();\n+    MyStruct\n+}\n+\n+struct MyStruct;\n+trait MyTrait {}\n+\n+impl MyTrait for MyStruct {}\n+\n+fn main() {}"}, {"sha": "540a280f0a319d8303a3071b786b987edd2ea5a4", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,9 +1,8 @@\n-// Test that an `impl Trait` type that expands to itself is an error.\n+// check-pass\n \n #![allow(unconditional_recursion)]\n \n fn test() -> impl Sized {\n-    //~^ ERROR E0720\n     test()\n }\n "}, {"sha": "5a3027ec751a91126268ddd7bc3eb8691c248246", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,12 +0,0 @@\n-error[E0720]: cannot resolve opaque type\n-  --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n-   |\n-LL | fn test() -> impl Sized {\n-   |              ^^^^^^^^^^ recursive opaque type\n-LL |\n-LL |     test()\n-   |     ------ returning here with type `impl Sized`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0720`."}, {"sha": "ffc0cd9d10c34fc9e4bbbf05b38769b5f1b95e5b", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,7 +5,7 @@\n #![allow(unconditional_recursion)]\n \n fn option(i: i32) -> impl Sized {\n-    //~^ ERROR\n+    //~^ ERROR cannot resolve opaque type\n     if i < 0 { None } else { Some((option(i - 1), i)) }\n }\n "}, {"sha": "18e3a5bcaa449df00b1f6295a4601448b37a3504", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -13,10 +13,10 @@ trait Trait<'a> { }\n impl Trait<'b> for Cell<&'a u32> { }\n \n fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n-    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n where 'x: 'y\n {\n     x\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0700]\n }\n \n fn main() { }"}, {"sha": "690d049ec8f620bc1de240d1f61197562e646779", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/region-escape-via-bound.rs:15:29\n+  --> $DIR/region-escape-via-bound.rs:18:5\n    |\n-LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n-   |                             ^^^^^^^^^^^^^^\n-LL |\n LL | where 'x: 'y\n    |       -- hidden type `Cell<&'x u32>` captures the lifetime `'x` as defined here\n+LL | {\n+LL |     x\n+   |     ^\n    |\n help: to declare that the `impl Trait` captures `'x`, you can add an explicit `'x` lifetime bound\n    |"}, {"sha": "f940c1949d0b8345be0c2102b0702330e97bae2d", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,14 +4,14 @@ struct A {\n \n impl A {\n     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n-        self.x.iter().map(|a| a.0)\n     }\n     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n         //~^ ERROR: captures lifetime that does not appear in bounds\n         //~| ERROR: captures lifetime that does not appear in bounds\n-        self.x.iter().map(|a| a.0)\n     }\n }\n "}, {"sha": "bc8e39f9c504cf7380ce0cdbe7325a1735a694d6", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,49 +1,49 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n+  --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                         |\n-   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:6:35\n+  --> $DIR/static-return-lifetime-infered.rs:7:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         -----     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                         |\n-   |                         hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:9:27: 9:34]>` captures the anonymous lifetime defined here\n+   |                         ----- hidden type `Map<std::slice::Iter<'_, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:7:27: 7:34]>` captures the anonymous lifetime defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:11:37\n+  --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/static-return-lifetime-infered.rs:11:37\n+  --> $DIR/static-return-lifetime-infered.rs:12:9\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    --               ^^^^^^^^^^^^^^^^^^^^^^^\n-   |                    |\n-   |                    hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:14:27: 14:34]>` captures the lifetime `'a` as defined here\n+   |                    -- hidden type `Map<std::slice::Iter<'a, (u32, u32)>, [closure@$DIR/static-return-lifetime-infered.rs:12:27: 12:34]>` captures the lifetime `'a` as defined here\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n    |"}, {"sha": "e0b77544d439d0b0279f5276c20db6ae5b81845b", "filename": "src/test/ui/impl-trait/type_parameters_captured.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:7:20\n+  --> $DIR/type_parameters_captured.rs:8:5\n    |\n-LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |                    ^^^^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "81ee7d3f8a561dc5436d1d4b32990348b3fc58fa", "filename": "src/test/ui/impl-trait/type_parameters_captured.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,8 +5,8 @@ impl<T> Any for T {}\n \n // Check that type parameters are captured and not considered 'static\n fn foo<T>(x: T) -> impl Any + 'static {\n-    //~^ ERROR the parameter type `T` may not live long enough\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "c0de4f4b4a0c5edcaff88849391435fc031ae264", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,10 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:7:20\n+  --> $DIR/type_parameters_captured.rs:8:5\n    |\n LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        -           ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |        |\n-   |        help: consider adding an explicit lifetime bound...: `T: 'static`\n+   |        - help: consider adding an explicit lifetime bound...: `T: 'static`\n+LL |     x\n+   |     ^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "d5a87b5d468340b3673d52c926b971597a9cc834", "filename": "src/test/ui/impl-trait/where-allowed-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,7 @@\n-//! Ideally, these tests would go in `where-allowed.rs`, but we bail out\n-//! too early to display them.\n use std::fmt::Debug;\n \n-// Disallowed\n-fn in_adt_in_return() -> Vec<impl Debug> { panic!() } //~ ERROR cannot resolve opaque type\n+// check-pass\n+\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n \n fn main() {}"}, {"sha": "b8e06725cbcdd6493683dc2ca34fd4d775d5cc27", "filename": "src/test/ui/impl-trait/where-allowed-2.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed-2.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,13 +0,0 @@\n-error[E0720]: cannot resolve opaque type\n-  --> $DIR/where-allowed-2.rs:6:30\n-   |\n-LL | fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n-   |                              ^^^^^^^^^^    -------- this returned value is of `!` type\n-   |                              |\n-   |                              cannot resolve opaque type\n-   |\n-   = help: this error will resolve once the item's body returns a concrete type\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0720`."}, {"sha": "89e07037afd424bf797e17bec9917a39d0c332f1", "filename": "src/test/ui/issues-71798.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fissues-71798.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fissues-71798.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,6 @@\n fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-    *x //~^ ERROR `u32` is not a future\n+    *x\n+    //~^ ERROR `u32` is not a future\n }\n \n fn main() {"}, {"sha": "1efa886436e0d3ed8eea9a73c62ee4ae0b458b2a", "filename": "src/test/ui/issues-71798.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fissues-71798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fissues-71798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,14 +1,14 @@\n error[E0425]: cannot find value `u` in this scope\n-  --> $DIR/issues-71798.rs:6:24\n+  --> $DIR/issues-71798.rs:7:24\n    |\n LL |     let _ = test_ref & u;\n    |                        ^ not found in this scope\n \n error[E0277]: `u32` is not a future\n-  --> $DIR/issues-71798.rs:1:25\n+  --> $DIR/issues-71798.rs:2:5\n    |\n-LL | fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `u32` is not a future\n+LL |     *x\n+   |     ^^ `u32` is not a future\n    |\n    = help: the trait `Future` is not implemented for `u32`\n    = note: u32 must be a future or must implement `IntoFuture` to be awaited"}, {"sha": "e5f26822f26708c43b30e1af545b6a218f7a521c", "filename": "src/test/ui/lang-items/lang-item-missing-generator.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-missing-generator.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: requires `generator` lang_item\n-  --> $DIR/lang-item-missing-generator.rs:15:17\n+  --> $DIR/lang-item-missing-generator.rs:15:22\n    |\n LL | pub fn abc() -> impl FnOnce(f32) {\n-   |                 ^^^^^^^^^^^^^^^^\n+   |                      ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "84bfa2d848755a9c64991d460bc917b985ead622", "filename": "src/test/ui/lazy-type-alias-impl-trait/freeze_cycle.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Ffreeze_cycle.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,46 @@\n+// check-pass\n+\n+#![feature(gen_future, generator_trait, negative_impls, const_fn_trait_bound, const_impl_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+use std::task::{Poll, Context};\n+use std::future::{Future};\n+use std::ptr::NonNull;\n+use std::pin::Pin;\n+\n+fn main() {}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub struct ResumeTy(NonNull<Context<'static>>);\n+\n+unsafe impl Send for ResumeTy {}\n+\n+unsafe impl Sync for ResumeTy {}\n+\n+pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n+where\n+    T: Generator<ResumeTy, Yield = ()>,\n+{\n+    struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n+\n+    // We rely on the fact that async/await futures are immovable in order to create\n+    // self-referential borrows in the underlying generator.\n+    impl<T: Generator<ResumeTy, Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+    impl<T: Generator<ResumeTy, Yield = ()>> Future for GenFuture<T> {\n+        type Output = T::Return;\n+        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+            // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection.\n+            let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n+\n+            // Resume the generator, turning the `&mut Context` into a `NonNull` raw pointer. The\n+            // `.await` lowering will safely cast that back to a `&mut Context`.\n+            match gen.resume(ResumeTy(NonNull::from(cx).cast::<Context<'static>>())) {\n+                GeneratorState::Yielded(()) => Poll::Pending,\n+                GeneratorState::Complete(x) => Poll::Ready(x),\n+            }\n+        }\n+    }\n+\n+    GenFuture(gen)\n+}"}, {"sha": "d07d732c78570c74368044af764d6983cee5652c", "filename": "src/test/ui/lazy-type-alias-impl-trait/infer_cross_function.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Finfer_cross_function.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+fn main() {}\n+\n+trait Reader {}\n+\n+struct Unit<R>(R);\n+struct ResDwarf<R>(R);\n+\n+struct Context<R: Reader> {\n+    dwarf: ResDwarf<R>,\n+}\n+\n+struct Range;\n+\n+struct ResUnit<R>(R);\n+\n+impl<R: Reader + 'static> Context<R> {\n+    fn find_dwarf_unit(&self, probe: u64) -> Option<&Unit<R>> {\n+        let x = self.find_units(probe);\n+        None\n+    }\n+\n+    fn find_units(&self, probe: u64) -> impl Iterator<Item = &ResUnit<R>> {\n+        std::iter::empty()\n+    }\n+}"}, {"sha": "f75a88aa8f0645da33663b44e051b2a00a682f69", "filename": "src/test/ui/lazy-type-alias-impl-trait/lifetime_inference.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Flifetime_inference.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+fn main() {}\n+\n+fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+    move || iter.nth(step)\n+}"}, {"sha": "f8291112739c116d0550b51f13b281a5747c40b8", "filename": "src/test/ui/lazy-type-alias-impl-trait/nested.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fnested.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+fn main() {}\n+\n+struct RawTableInner<A> {\n+    alloc: A,\n+}\n+\n+impl<A> RawTableInner<A> {\n+    fn prepare_resize(\n+        self,\n+    ) -> ScopeGuard<Self, impl FnMut(&mut Self)> {\n+        ScopeGuard { dropfn: move |self_| {}, value: self,  }\n+    }\n+}\n+\n+pub struct ScopeGuard<T, F>\n+where\n+    F: FnMut(&mut T),\n+{\n+    dropfn: F,\n+    value: T,\n+}"}, {"sha": "8d03b5158d66278c4521a579b743d3574d0c2ade", "filename": "src/test/ui/lazy-type-alias-impl-trait/opaque_vs_opaque.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fopaque_vs_opaque.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+fn main() {}\n+\n+fn filter_fold<T, Acc, PRED: FnMut(&T) -> bool, FOLD: FnMut(Acc, T) -> Acc>(\n+    mut predicate: PRED,\n+    mut fold: FOLD,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}"}, {"sha": "007101498238d7f12fc52fabec521565a7b97056", "filename": "src/test/ui/lazy-type-alias-impl-trait/unsized_sized_opaque.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Funsized_sized_opaque.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+fn main() {}\n+\n+pub struct PairSlices<'a, 'b, T> {\n+    pub(crate) a0: &'a mut [T],\n+    pub(crate) a1: &'a mut [T],\n+    pub(crate) b0: &'b [T],\n+    pub(crate) b1: &'b [T],\n+}\n+\n+impl<'a, 'b, T> PairSlices<'a, 'b, T> {\n+    pub fn remainder(self) -> impl Iterator<Item = &'b [T]> {\n+        IntoIterator::into_iter([self.b0, self.b1])\n+    }\n+}"}, {"sha": "fd49b4842a74f6036e52865310a179f9c9db7264", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,8 +6,8 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-//~^ ERROR not satisfied\n     Ok(())\n+    //~^ ERROR not satisfied\n }\n \n fn main() {}"}, {"sha": "7f8384d7eca8d90e511deba1a542ffd2eb14bb11", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Result<(), _>: Future` is not satisfied\n-  --> $DIR/lifetime-elision-return-type-trait.rs:8:13\n+  --> $DIR/lifetime-elision-return-type-trait.rs:9:5\n    |\n-LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n+LL |     Ok(())\n+   |     ^^^^^^ the trait `Future` is not implemented for `Result<(), _>`\n \n error: aborting due to previous error\n "}, {"sha": "7d020841180012580290b044c221ea6b79b2df02", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,7 +6,8 @@ fn main() {}\n \n trait T {}\n \n-fn should_ret_unit() -> impl T {\n-    //~^ ERROR the trait bound `(): T` is not satisfied\n-    panic!()\n+fn should_ret_unit() {\n+    foo(panic!()) //~ ERROR\n }\n+\n+fn foo(_: impl T) {}"}, {"sha": "54abed383000dc8134137db45fa06923d8cfe74e", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,14 @@\n error[E0277]: the trait bound `(): T` is not satisfied\n-  --> $DIR/feature-gate-never_type_fallback.rs:9:25\n+  --> $DIR/feature-gate-never_type_fallback.rs:10:5\n    |\n-LL | fn should_ret_unit() -> impl T {\n-   |                         ^^^^^^ the trait `T` is not implemented for `()`\n+LL |     foo(panic!())\n+   |     ^^^ the trait `T` is not implemented for `()`\n+   |\n+note: required by a bound in `foo`\n+  --> $DIR/feature-gate-never_type_fallback.rs:13:16\n+   |\n+LL | fn foo(_: impl T) {}\n+   |                ^ required by this bound in `foo`\n \n error: aborting due to previous error\n "}, {"sha": "cc9520c1b24c8818d8584b08c193f1764b997ae5", "filename": "src/test/ui/never_type/impl_trait_fallback.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+fn main() {}\n+\n+trait T {}\n+impl T for () {}\n+\n+fn should_ret_unit() -> impl T {\n+    panic!()\n+}"}, {"sha": "f73d953bdbd0b6e10aaf2d268e53d2a802a315de", "filename": "src/test/ui/never_type/impl_trait_fallback2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,21 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait T {}\n+impl T for i32 {}\n+\n+fn should_ret_unit() -> impl T {\n+    //~^ ERROR `(): T` is not satisfied\n+    panic!()\n+}\n+\n+type Foo = impl T;\n+\n+fn a() -> Foo {\n+    panic!()\n+}\n+\n+fn b() -> Foo {\n+    42\n+}"}, {"sha": "2f50b9d245900f0bb1f6c90c68085b3f755b06e5", "filename": "src/test/ui/never_type/impl_trait_fallback2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `(): T` is not satisfied\n+  --> $DIR/impl_trait_fallback2.rs:8:25\n+   |\n+LL | fn should_ret_unit() -> impl T {\n+   |                         ^^^^^^ the trait `T` is not implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a44402a22b956066c631b5b0b7a2c3cad8d74492", "filename": "src/test/ui/never_type/impl_trait_fallback3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {}\n+\n+trait T {\n+    type Assoc;\n+}\n+\n+type Foo = impl T;\n+//~^ ERROR could not find defining uses\n+\n+fn a() -> Foo {\n+    // This is not a defining use, it doesn't actually constrain the opaque type.\n+    panic!()\n+}"}, {"sha": "de04758a1e31164c48c6b5f3ec18d6486ca4b60f", "filename": "src/test/ui/never_type/impl_trait_fallback3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback3.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,8 @@\n+error: could not find defining uses\n+  --> $DIR/impl_trait_fallback3.rs:9:12\n+   |\n+LL | type Foo = impl T;\n+   |            ^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe62773fa02dbd2be3cb1f9d8e03a4faf45357cf", "filename": "src/test/ui/never_type/impl_trait_fallback4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait T {\n+    type Assoc: Cake;\n+}\n+\n+trait Cake: std::fmt::Display {\n+    fn cake() -> Self;\n+}\n+\n+type Foo = impl T;\n+\n+fn foo() -> impl T {\n+    //~^ ERROR `(): T` is not satisfied\n+    panic!()\n+}\n+\n+fn a() -> Foo {\n+    foo()\n+}\n+\n+fn main() {\n+    println!(\"{}\", <Foo as T>::Assoc::cake());\n+}"}, {"sha": "f2e216e9044c00a50eac5adb4728813370bc3881", "filename": "src/test/ui/never_type/impl_trait_fallback4.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback4.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,9 @@\n+error[E0277]: the trait bound `(): T` is not satisfied\n+  --> $DIR/impl_trait_fallback4.rs:13:13\n+   |\n+LL | fn foo() -> impl T {\n+   |             ^^^^^^ the trait `T` is not implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2f4cbf8322bbd13f648cc30c708c8f1eae2f7683", "filename": "src/test/ui/nll/issue-52113.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -29,9 +29,9 @@ fn produce3<'a, 'b: 'a>(data: &'a mut Vec<&'a u32>, value: &'b u32) -> impl Bazi\n fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n     let x = move || {\n         let value: &'a u32 = value;\n-        data.push(value);\n+        data.push(value); //~ ERROR lifetime may not live long enough\n     };\n-    x //~ ERROR lifetime may not live long enough\n+    x\n }\n \n fn main() {}"}, {"sha": "d82affef26d2f5efd2305bf8448970a6dc0871a0", "filename": "src/test/ui/nll/issue-52113.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/issue-52113.rs:34:5\n+  --> $DIR/issue-52113.rs:32:9\n    |\n LL | fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n    |                --  -- lifetime `'b` defined here"}, {"sha": "97dc016068bed85abe50f1e81c3ff81c9ccaf4c2", "filename": "src/test/ui/nll/issue-73159-rpit-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -7,8 +7,8 @@ struct Foo<'a>(&'a [u8]);\n \n impl<'a> Foo<'a> {\n     fn make_it(&self) -> impl Iterator<Item = u8> {\n-        //~^ ERROR: captures lifetime that does not appear in bounds\n         self.0.iter().copied()\n+        //~^ ERROR: captures lifetime that does not appear in bounds\n     }\n }\n "}, {"sha": "a3e9c0b44c21078c76a54e23a4bbeb177dac259a", "filename": "src/test/ui/nll/issue-73159-rpit-static.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-73159-rpit-static.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,11 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-73159-rpit-static.rs:9:26\n+  --> $DIR/issue-73159-rpit-static.rs:10:9\n    |\n LL | impl<'a> Foo<'a> {\n    |      -- hidden type `Copied<std::slice::Iter<'a, u8>>` captures the lifetime `'a` as defined here\n LL |     fn make_it(&self) -> impl Iterator<Item = u8> {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         self.0.iter().copied()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "c04185d08142481a928ae978c214943acaff011b", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,8 +8,8 @@ trait Foo<'a> {\n impl<'a, T> Foo<'a> for T { }\n \n fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n-//~^ ERROR captures lifetime that does not appear in bounds\n     x\n+    //~^ ERROR captures lifetime that does not appear in bounds\n }\n \n fn main() {}"}, {"sha": "96481810e33a2f7d780ba2807d62fb94a5b953a1", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,5 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/impl-trait-captures.rs:10:25\n+  --> $DIR/impl-trait-captures.rs:11:5\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n    |                  --     ^^^^^^^^^^^^"}, {"sha": "3548ad03a7d3d9fc6a7578dc21bf59f646d6f251", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,11 +5,11 @@\n use std::fmt::Debug;\n \n fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: Debug,\n {\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n@@ -20,11 +20,11 @@ where\n }\n \n fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: 'b + Debug,\n {\n     x\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a"}, {"sha": "31ee540cce9f70ccf63bcd4f9baed4e8f5276ae7", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,16 +1,16 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:7:35\n+  --> $DIR/impl-trait-outlives.rs:11:5\n    |\n-LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n-   |                                   ^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:22:42\n+  --> $DIR/impl-trait-outlives.rs:26:5\n    |\n-LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n-   |                                          ^^^^^^^^^^^^^^^\n+LL |     x\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'a`...\n "}, {"sha": "cf5d3dab4aadad1f5b3e73b5f4b98db565906d25", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -9,8 +9,9 @@ fn main() {\n     unsafe fn ff2() {} // OK.\n     const fn ff3() {} // OK.\n     extern \"C\" fn ff4() {} // OK.\n-    const async unsafe extern \"C\" fn ff5() {} // OK.\n+    const async unsafe extern \"C\" fn ff5() {}\n     //~^ ERROR functions cannot be both `const` and `async`\n+    //~| ERROR cycle detected\n \n     trait X {\n         async fn ft1(); //~ ERROR functions in traits cannot be declared `async`\n@@ -26,15 +27,14 @@ fn main() {\n     struct Y;\n     impl X for Y {\n         async fn ft1() {} //~ ERROR functions in traits cannot be declared `async`\n-        //~^ ERROR method `ft1` has an incompatible type for trait\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR functions in traits cannot be declared const\n         extern \"C\" fn ft4() {}\n         const async unsafe extern \"C\" fn ft5() {}\n         //~^ ERROR functions in traits cannot be declared `async`\n         //~| ERROR functions in traits cannot be declared const\n-        //~| ERROR method `ft5` has an incompatible type for trait\n         //~| ERROR functions cannot be both `const` and `async`\n+        //~| ERROR cycle detected\n     }\n \n     impl Y {\n@@ -44,6 +44,7 @@ fn main() {\n         extern \"C\" fn fi4() {} // OK.\n         const async unsafe extern \"C\" fn fi5() {}\n         //~^ ERROR functions cannot be both `const` and `async`\n+        //~| ERROR cycle detected\n     }\n \n     extern \"C\" {"}, {"sha": "1d7460b8d36057c584527abe95a40628c3fc01f9", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 113, "deletions": 41, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,14 +1,14 @@\n error: functions cannot be both `const` and `async`\n   --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-LL |     const async unsafe extern \"C\" fn ff5() {} // OK.\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n    |     ^^^^^-^^^^^------------------------------\n    |     |     |\n    |     |     `async` because of this\n    |     `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:16:9\n+  --> $DIR/fn-header-semantic-fail.rs:17:9\n    |\n LL |         async fn ft1();\n    |         -----^^^^^^^^^^\n@@ -19,19 +19,19 @@ LL |         async fn ft1();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:18:9\n+  --> $DIR/fn-header-semantic-fail.rs:19:9\n    |\n LL |         const fn ft3();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0379]: functions in traits cannot be declared const\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^ functions in traits cannot be const\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,7 +42,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:20:9\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5();\n    |         ^^^^^-^^^^^----------------------------\n@@ -51,7 +51,7 @@ LL |         const async unsafe extern \"C\" fn ft5();\n    |         `const` because of this\n \n error[E0706]: functions in traits cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:28:9\n+  --> $DIR/fn-header-semantic-fail.rs:29:9\n    |\n LL |         async fn ft1() {}\n    |         -----^^^^^^^^^^^^\n@@ -103,7 +103,7 @@ LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         `const` because of this\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:50:18\n+  --> $DIR/fn-header-semantic-fail.rs:51:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -116,7 +116,7 @@ LL |         fn fe1();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:51:19\n+  --> $DIR/fn-header-semantic-fail.rs:52:19\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -130,7 +130,7 @@ LL |         fn fe2();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:52:18\n+  --> $DIR/fn-header-semantic-fail.rs:53:18\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -144,7 +144,7 @@ LL |         fn fe3();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:53:23\n+  --> $DIR/fn-header-semantic-fail.rs:54:23\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -158,7 +158,7 @@ LL |         fn fe4();\n    |         ~~\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:54:42\n+  --> $DIR/fn-header-semantic-fail.rs:55:42\n    |\n LL |     extern \"C\" {\n    |     ---------- in this `extern` block\n@@ -172,51 +172,123 @@ LL |         fn fe5();\n    |         ~~\n \n error: functions cannot be both `const` and `async`\n-  --> $DIR/fn-header-semantic-fail.rs:54:9\n+  --> $DIR/fn-header-semantic-fail.rs:55:9\n    |\n LL |         const async unsafe extern \"C\" fn fe5();\n    |         ^^^^^-^^^^^----------------------------\n    |         |     |\n    |         |     `async` because of this\n    |         `const` because of this\n \n-error[E0053]: method `ft1` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:28:24\n+error[E0391]: cycle detected when computing type of `main::ff5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:12:44\n    |\n-LL |         async fn ft1() {}\n-   |                        ^\n-   |                        |\n-   |                        checked the `Output` of this `async fn`, found opaque type\n-   |                        expected `()`, found opaque type\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |                                            ^\n    |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/fn-header-semantic-fail.rs:16:23\n+note: ...which requires borrow-checking `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n-LL |         async fn ft1();\n-   |                       ^\n-   = note: expected fn pointer `fn()`\n-              found fn pointer `fn() -> impl Future<Output = ()>`\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::ff5`...\n+  --> $DIR/fn-header-semantic-fail.rs:12:5\n+   |\n+LL |     const async unsafe extern \"C\" fn ff5() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::ff5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n-error[E0053]: method `ft5` has an incompatible type for trait\n+error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5::{opaque#0}`\n   --> $DIR/fn-header-semantic-fail.rs:33:48\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |                                                ^\n-   |                                                |\n-   |                                                checked the `Output` of this `async fn`, found opaque type\n-   |                                                expected `()`, found opaque type\n    |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/fn-header-semantic-fail.rs:20:47\n+note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n    |\n-LL |         const async unsafe extern \"C\" fn ft5();\n-   |                                               ^\n-   = note: expected fn pointer `unsafe extern \"C\" fn()`\n-              found fn pointer `unsafe extern \"C\" fn() -> impl Future<Output = ()>`\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5`...\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 38:6>::ft5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5::{opaque#0}`\n+  --> $DIR/fn-header-semantic-fail.rs:45:48\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |                                                ^\n+   |\n+note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5`...\n+  --> $DIR/fn-header-semantic-fail.rs:45:9\n+   |\n+LL |         const async unsafe extern \"C\" fn fi5() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 48:6>::fi5::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in top-level module\n+  --> $DIR/fn-header-semantic-fail.rs:5:1\n+   |\n+LL | / #![feature(const_extern_fn)]\n+LL | |\n+LL | | fn main() {\n+LL | |     async fn ff1() {} // OK.\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 21 previous errors\n \n-Some errors have detailed explanations: E0053, E0379, E0706.\n-For more information about an error, try `rustc --explain E0053`.\n+Some errors have detailed explanations: E0379, E0391, E0706.\n+For more information about an error, try `rustc --explain E0379`."}, {"sha": "68ea4a026d7bf3622e0f9e3d6117e977c05a07ad", "filename": "src/test/ui/polymorphization/generators.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -32,7 +32,6 @@ where\n \n #[rustc_polymorphize_error]\n pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;\n@@ -58,7 +57,6 @@ pub fn used_type_in_return<R: Default>() -> impl Generator<(), Yield = u32, Retu\n \n #[rustc_polymorphize_error]\n pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-    //~^ ERROR item has unused generic parameters\n     || {\n         //~^ ERROR item has unused generic parameters\n         yield 1;"}, {"sha": "1152bcb0734a63490ef7a65683f52b7de7afc8a0", "filename": "src/test/ui/polymorphization/generators.stderr", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fgenerators.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,11 +8,10 @@ LL | #![feature(generic_const_exprs, generators, generator_trait, rustc_attrs)]\n    = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:36:5\n+  --> $DIR/generators.rs:35:5\n    |\n LL |   pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                      - generic parameter `T` is unused\n-LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n@@ -21,29 +20,16 @@ LL | |     }\n    | |_____^\n \n error: item has unused generic parameters\n-  --> $DIR/generators.rs:34:8\n-   |\n-LL | pub fn unused_type<T>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-   |        ^^^^^^^^^^^ - generic parameter `T` is unused\n-\n-error: item has unused generic parameters\n-  --> $DIR/generators.rs:62:5\n+  --> $DIR/generators.rs:60:5\n    |\n LL |   pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n    |                             - generic parameter `T` is unused\n-LL |\n LL | /     || {\n LL | |\n LL | |         yield 1;\n LL | |         2\n LL | |     }\n    | |_____^\n \n-error: item has unused generic parameters\n-  --> $DIR/generators.rs:60:8\n-   |\n-LL | pub fn unused_const<const T: u32>() -> impl Generator<(), Yield = u32, Return = u32> + Unpin {\n-   |        ^^^^^^^^^^^^       - generic parameter `T` is unused\n-\n-error: aborting due to 4 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "49462f52fb4c2355375bd633eb76b28dcd730501", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -14,7 +14,6 @@ trait B {\n impl B for A {\n     async fn associated(); //~ ERROR without body\n     //~^ ERROR cannot be declared `async`\n-    //~| ERROR incompatible type for trait\n }\n \n fn main() {}"}, {"sha": "a473f42fc2cf805ffdd235531abac1672d17c56a", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -44,25 +44,6 @@ LL |     async fn associated();\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-error[E0053]: method `associated` has an incompatible type for trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:26\n-   |\n-LL |     async fn associated();\n-   |                          ^\n-   |                          |\n-   |                          checked the `Output` of this `async fn`, found opaque type\n-   |                          expected `()`, found opaque type\n-   |\n-   = note: while checking the return type of the `async fn`\n-note: type in trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:11:26\n-   |\n-LL |     async fn associated();\n-   |                          ^\n-   = note: expected fn pointer `fn()`\n-              found fn pointer `fn() -> impl Future<Output = ()>`\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0053, E0706.\n-For more information about an error, try `rustc --explain E0053`.\n+For more information about this error, try `rustc --explain E0706`."}, {"sha": "8ddc3f2c34bd8ff341de3d88da2b2491294f8286", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2,14 +2,13 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -          ^^^^^^^^^^\n-   |                          |\n-   |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n+   |                                     ^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+note: hidden type `Pin<&'<empty> Foo>` captures lifetime smaller than the function body\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:37\n    |\n-LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n-   |                                                ++++\n+LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n+   |                                     ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "abdc650c68e78d46b85949e92ba38e38c448123a", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:31\n+  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                    -----      ^^^^^^^^^^\n+   |                    -----                   ^^^^\n    |                    |\n    |                    hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |"}, {"sha": "07c1d8bccbaba1e39ed3a8358cc194b60e0950e4", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the trait bound `(): Bar` is not satisfied\n-  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:13\n+  --> $DIR/impl-trait-return-trailing-semicolon.rs:3:22\n    |\n-LL | fn foo() -> impl Bar {\n-   |             ^^^^^^^^ the trait `Bar` is not implemented for `()`\n-LL |     5;\n-   |      - consider removing this semicolon\n+LL |   fn foo() -> impl Bar {\n+   |  ______________________^\n+LL | |     5;\n+LL | | }\n+   | |_^ the trait `Bar` is not implemented for `()`\n \n error: aborting due to previous error\n "}, {"sha": "f13e653cb06bda42de0288a36c7535ace1cf5322", "filename": "src/test/ui/suggestions/issue-81098.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-81098.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,19 +1,23 @@\n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:3:13\n+  --> $DIR/issue-81098.rs:3:37\n    |\n-LL | fn wat() -> impl core::fmt::Display {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n+LL |   fn wat() -> impl core::fmt::Display {\n+   |  _____________________________________^\n+LL | |     fn why() {}\n+LL | | }\n+   | |_^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n \n error[E0277]: `()` doesn't implement `std::fmt::Display`\n-  --> $DIR/issue-81098.rs:9:12\n+  --> $DIR/issue-81098.rs:9:36\n    |\n-LL | fn ok() -> impl core::fmt::Display {\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^ `()` cannot be formatted with the default formatter\n-LL |     1;\n-   |      - consider removing this semicolon\n+LL |   fn ok() -> impl core::fmt::Display {\n+   |  ____________________________________^\n+LL | |     1;\n+LL | | }\n+   | |_^ `()` cannot be formatted with the default formatter\n    |\n    = help: the trait `std::fmt::Display` is not implemented for `()`\n    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead"}, {"sha": "c7f1215c8cc44f30b8aec22e940928972783711f", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -7,13 +7,18 @@ LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n    |\n-LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n@@ -32,13 +37,18 @@ LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:38:23\n    |\n-LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n@@ -53,13 +63,18 @@ LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:49:30\n    |\n-LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n@@ -74,13 +89,18 @@ LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n LL |             remaining: self.0.iter(),\n    |                        ------ ^^^^\n    |                        |\n-   |                        ...is used here...\n+   |                        ...is used and required to live as long as `'static` here\n    |\n-note: ...and is required to live as long as `'static` here\n+note: `'static` lifetime requirement introduced by the return type\n   --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n    |\n-LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requirement introduced by this return type\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________- because of this returned expression\n help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {"}, {"sha": "a02664ad7ca69e8f1cb405cfd6d93bfe9cb501e9", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -16,6 +16,9 @@ fn extra_semicolon() {\n async fn async_dummy() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE while checking the return type of the `async fn`\n //~| NOTE in this expansion of desugaring of `async` block or function\n+//~| NOTE while checking the return type of the `async fn`\n+//~| NOTE in this expansion of desugaring of `async` block or function\n+//~| NOTE checked the `Output` of this `async fn`, expected opaque type\n async fn async_dummy2() {} //~ NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE checked the `Output` of this `async fn`, found opaque type\n //~| NOTE while checking the return type of the `async fn`\n@@ -31,7 +34,7 @@ async fn async_extra_semicolon_same() {\n         }\n         false => async_dummy(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n-        //~| NOTE expected type `()`\n+        //~| NOTE expected unit type `()`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -44,7 +47,7 @@ async fn async_extra_semicolon_different() {\n         }\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected `()`, found opaque type\n-        //~| NOTE expected type `()`\n+        //~| NOTE expected unit type `()`\n         //~| HELP consider `await`ing on the `Future`\n     };\n }\n@@ -55,7 +58,7 @@ async fn async_different_futures() {\n         //~| HELP consider `await`ing on both `Future`s\n         false => async_dummy2(), //~ ERROR `match` arms have incompatible types\n         //~^ NOTE expected opaque type, found a different opaque type\n-        //~| NOTE expected type `impl Future<Output = ()>`\n+        //~| NOTE expected opaque type `impl Future<Output = ()>`\n         //~| NOTE distinct uses of `impl Trait` result in different opaque types\n     };\n }"}, {"sha": "4c4b782bd6fb17047767617efbe86e64c2906b3d", "filename": "src/test/ui/suggestions/match-prev-arm-needing-semi.stderr", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-prev-arm-needing-semi.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:32:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:35:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -20,8 +20,8 @@ note: while checking the return type of the `async fn`\n    |\n LL | async fn async_dummy() {}\n    |                        ^ checked the `Output` of this `async fn`, found opaque type\n-   = note:     expected type `()`\n-           found opaque type `impl Future<Output = ()>`\n+   = note: expected unit type `()`\n+            found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy().await,\n@@ -33,7 +33,7 @@ LL +             async_dummy()\n    | \n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:45:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:48:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -50,12 +50,12 @@ LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:19:25\n+  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n    |\n LL | async fn async_dummy2() {}\n    |                         ^ checked the `Output` of this `async fn`, found opaque type\n-   = note:     expected type `()`\n-           found opaque type `impl Future<Output = ()>`\n+   = note: expected unit type `()`\n+            found opaque type `impl Future<Output = ()>`\n help: consider `await`ing on the `Future`\n    |\n LL |         false => async_dummy2().await,\n@@ -69,7 +69,7 @@ LL ~         false => Box::new(async_dummy2()),\n    |\n \n error[E0308]: `match` arms have incompatible types\n-  --> $DIR/match-prev-arm-needing-semi.rs:56:18\n+  --> $DIR/match-prev-arm-needing-semi.rs:59:18\n    |\n LL |       let _ = match true {\n    |  _____________-\n@@ -84,12 +84,17 @@ LL | |     };\n    | |_____- `match` arms have incompatible types\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/match-prev-arm-needing-semi.rs:19:25\n+  --> $DIR/match-prev-arm-needing-semi.rs:16:24\n+   |\n+LL | async fn async_dummy() {}\n+   |                        ^ checked the `Output` of this `async fn`, expected opaque type\n+note: while checking the return type of the `async fn`\n+  --> $DIR/match-prev-arm-needing-semi.rs:22:25\n    |\n LL | async fn async_dummy2() {}\n    |                         ^ checked the `Output` of this `async fn`, found opaque type\n-   = note:     expected type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n-           found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:19:25>)\n+   = note: expected opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:16:24>)\n+              found opaque type `impl Future<Output = ()>` (opaque type at <$DIR/match-prev-arm-needing-semi.rs:22:25>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "133ffb058739250011df2fe7c15174346a1213d9", "filename": "src/test/ui/suggestions/opaque-type-error.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fopaque-type-error.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/opaque-type-error.rs:20:9\n    |\n+LL |   fn thing_one() -> impl Future<Output = Result<(), ()>> {\n+   |                     ------------------------------------ the expected opaque type\n+...\n LL |   fn thing_two() -> impl Future<Output = Result<(), ()>> {\n    |                     ------------------------------------ the found opaque type\n ...\n@@ -13,8 +16,8 @@ LL | |         thing_two()\n LL | |     }.await\n    | |_____- `if` and `else` have incompatible types\n    |\n-   = note:     expected type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n-           found opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n+   = note: expected opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:8:19>)\n+              found opaque type `impl Future<Output = Result<(), ()>>` (opaque type at <$DIR/opaque-type-error.rs:12:19>)\n    = note: distinct uses of `impl Trait` result in different opaque types\n help: consider `await`ing on both `Future`s\n    |"}, {"sha": "185207b9800bbc0c41b4f53d5d7e1fb106965e2c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,14 +1,12 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n-\n+// check-pass\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n \n-// FIXME: This should compile, but it currently doesn't\n fn foo1(mut x: Foo) {\n     x = 22_u32;\n-    //~^ ERROR: mismatched types [E0308]\n }\n \n fn foo2(mut x: Foo) {"}, {"sha": "a87e44a048b250c09704b31158b51aacf0c8a60c", "filename": "src/test/ui/type-alias-impl-trait/argument-types.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fargument-types.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,17 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/argument-types.rs:10:9\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL | fn foo1(mut x: Foo) {\n-   |                --- expected due to this parameter type\n-LL |     x = 22_u32;\n-   |         ^^^^^^ expected opaque type, found `u32`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "b456b1445e7845ebbe29bf76a8514dd2bd57d4a6", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,6 +6,7 @@\n mod m {\n     type Foo = impl std::fmt::Debug;\n     //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n+    //~| ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n \n     pub fn foo() -> Foo {\n         22_u32"}, {"sha": "4c44875b4a548eb85a4d3a51fbe115d571b87d78", "filename": "src/test/ui/type-alias-impl-trait/auto-trait-leakage3.stderr", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauto-trait-leakage3.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,18 +5,35 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/auto-trait-leakage3.rs:15:9\n+  --> $DIR/auto-trait-leakage3.rs:15:5\n    |\n-LL |         is_send(foo());\n-   |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/auto-trait-leakage3.rs:6:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error: aborting due to previous error\n+error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n+  --> $DIR/auto-trait-leakage3.rs:7:16\n+   |\n+LL |     type Foo = impl std::fmt::Debug;\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires type-checking `m::bar`...\n+  --> $DIR/auto-trait-leakage3.rs:15:5\n+   |\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in module `m`\n+  --> $DIR/auto-trait-leakage3.rs:6:1\n+   |\n+LL | mod m {\n+   | ^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0391`."}, {"sha": "2177bf3b1c4989db6639629e8bc86ecfba4b9ed9", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -14,6 +14,6 @@ trait Trait<U> {}\n impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     ()\n+    //~^ ERROR type annotations needed\n }"}, {"sha": "4ff14333c1969a5b0f655098600af55059732072", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,14 +1,8 @@\n-error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:16:46\n+error[E0282]: type annotations needed\n+  --> $DIR/bound_reduction2.rs:17:5\n    |\n-LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |                                              ^^^^^^^^^^^^^\n-   |\n-note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n-  --> $DIR/bound_reduction2.rs:9:10\n-   |\n-LL | type Foo<V> = impl Trait<V>;\n-   |          ^\n+LL |     ()\n+   |     ^^ cannot infer type\n \n error: could not find defining uses\n   --> $DIR/bound_reduction2.rs:9:15\n@@ -18,3 +12,4 @@ LL | type Foo<V> = impl Trait<V>;\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "d694d3822388e17ff722066dd7f856f2209be9df", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,11 +4,12 @@\n #![feature(type_alias_impl_trait)]\n \n type X<'a> = impl Into<&'static str> + From<&'a str>;\n-//~^ ERROR mismatched types\n+//~^ ERROR could not find defining uses\n \n fn f<'a: 'static>(t: &'a str) -> X<'a> {\n     //~^ WARNING unnecessary lifetime parameter\n     t\n+    //~^ ERROR non-defining opaque type use\n }\n \n fn extend_lt<'a>(o: &'a str) -> &'static str {"}, {"sha": "11bc926c961a5edd7777ea5e9507bd2ef6d4b66c", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,21 +6,20 @@ LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n    |\n    = help: you can use the `'static` lifetime directly, in place of `'a`\n \n-error[E0308]: mismatched types\n-  --> $DIR/bounds-are-checked.rs:6:14\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/bounds-are-checked.rs:11:5\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected trait `From<&'a str>`\n-              found trait `From<&'static str>`\n-note: the lifetime `'a` as defined here...\n-  --> $DIR/bounds-are-checked.rs:6:8\n+   |        -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL |     t\n+   |     ^\n+\n+error: could not find defining uses\n+  --> $DIR/bounds-are-checked.rs:6:14\n    |\n LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n-   |        ^^\n-   = note: ...does not necessarily outlive the static lifetime\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "4564ef6b8f6a083937ccbcd81712e12ac1aa2a2b", "filename": "src/test/ui/type-alias-impl-trait/declared_but_not_defined_in_scope.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdeclared_but_not_defined_in_scope.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -10,13 +10,11 @@ error[E0308]: mismatched types\n LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ---------------------- the expected opaque type\n ...\n-LL | fn bomp() -> boo::Boo {\n-   |              -------- expected `impl Debug` because of return type\n LL |     \"\"\n    |     ^^ expected opaque type, found `&str`\n    |\n    = note: expected opaque type `impl Debug`\n-                found reference `&'static str`\n+                found reference `&str`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7740f774ebca4ad58af5c3869026abc758ce473d", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,5 +1,5 @@\n #![feature(type_alias_impl_trait)]\n-\n+// check-pass\n fn main() {}\n \n // two definitions with different types\n@@ -10,11 +10,9 @@ fn foo() -> Foo {\n }\n \n fn bar() -> Foo {\n-    //~^ ERROR concrete type differs from previous\n     panic!()\n }\n \n fn boo() -> Foo {\n-    //~^ ERROR concrete type differs from previous\n     loop {}\n }"}, {"sha": "6274029e4f524b0772100efea89953411b7bb57e", "filename": "src/test/ui/type-alias-impl-trait/different_defining_uses_never_type.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,26 +0,0 @@\n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/different_defining_uses_never_type.rs:12:1\n-   |\n-LL | fn bar() -> Foo {\n-   | ^^^^^^^^^^^^^^^ expected `&'static str`, got `()`\n-   |\n-note: previous use here\n-  --> $DIR/different_defining_uses_never_type.rs:8:1\n-   |\n-LL | fn foo() -> Foo {\n-   | ^^^^^^^^^^^^^^^\n-\n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/different_defining_uses_never_type.rs:17:1\n-   |\n-LL | fn boo() -> Foo {\n-   | ^^^^^^^^^^^^^^^ expected `&'static str`, got `()`\n-   |\n-note: previous use here\n-  --> $DIR/different_defining_uses_never_type.rs:8:1\n-   |\n-LL | fn foo() -> Foo {\n-   | ^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "d99ed58127bd44e127e390f73958b1f9f1aaddd3", "filename": "src/test/ui/type-alias-impl-trait/field-types.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,20 +1,18 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n-// FIXME This should compile, but it currently doesn't\n+// check-pass\n \n use std::fmt::Debug;\n \n type Foo = impl Debug;\n-//~^ ERROR: could not find defining uses\n \n struct Bar {\n     foo: Foo,\n }\n \n fn bar() -> Bar {\n     Bar { foo: \"foo\" }\n-    //~^ ERROR: mismatched types [E0308]\n }\n \n fn main() {}"}, {"sha": "18c2abbdf37213900b5df5746159f6059519ce26", "filename": "src/test/ui/type-alias-impl-trait/field-types.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ffield-types.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,21 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/field-types.rs:16:16\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL |     Bar { foo: \"foo\" }\n-   |                ^^^^^ expected opaque type, found `&str`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                found reference `&'static str`\n-\n-error: could not find defining uses\n-  --> $DIR/field-types.rs:8:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "e7768c246c2074ec4fbd0badc99e92a5d562dc32", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,6 +6,6 @@ type Two<'a, 'b> = impl std::fmt::Debug;\n //~^ ERROR could not find defining uses\n \n fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n-    //~^ ERROR non-defining opaque type use\n     t\n+    //~^ ERROR non-defining opaque type use\n }"}, {"sha": "bcd3a71dc18fb92ae76fc11cf21324c39497f676", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_lifetime_param.rs:8:26\n+  --> $DIR/generic_duplicate_lifetime_param.rs:9:5\n    |\n-LL | fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n-   |                          ^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: lifetime used multiple times\n   --> $DIR/generic_duplicate_lifetime_param.rs:5:10"}, {"sha": "e854434a59fc95914344f501446f5946e5a52f56", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -13,16 +13,16 @@ type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n //~^ ERROR could not find defining uses\n \n fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }"}, {"sha": "48b3a4d287a7aaa50fa01673b0a9cb5f9433c7e3", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:15:30\n+  --> $DIR/generic_duplicate_param_use.rs:16:5\n    |\n-LL | fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n-   |                              ^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: type used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:8:13\n@@ -17,10 +17,10 @@ LL | type TwoTys<T, U> = impl Debug;\n    |                     ^^^^^^^^^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:20:36\n+  --> $DIR/generic_duplicate_param_use.rs:21:5\n    |\n-LL | fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n-   |                                    ^^^^^^^^^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: lifetime used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:10:19\n@@ -35,10 +35,10 @@ LL | type TwoLifetimes<'a, 'b> = impl Debug;\n    |                             ^^^^^^^^^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:25:50\n+  --> $DIR/generic_duplicate_param_use.rs:26:5\n    |\n-LL | fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n-   |                                                  ^^^^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: constant used multiple times\n   --> $DIR/generic_duplicate_param_use.rs:12:22"}, {"sha": "da9dd5baa3d0fcf4159a39223e5984615945cead", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -9,8 +9,8 @@ type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {"}, {"sha": "e62218fe0832c5093057e2431b511b6c222c7a3a", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use2.rs:11:27\n+  --> $DIR/generic_duplicate_param_use2.rs:12:5\n    |\n-LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n-   |                           ^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: type used multiple times\n   --> $DIR/generic_duplicate_param_use2.rs:8:10"}, {"sha": "b21280e2db56ac88860f5deed2e9e1691eb0d6c7", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -9,8 +9,8 @@ type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {"}, {"sha": "cb4e0f04aa1467c2cf5ef866fe6b814f76657d89", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use3.rs:11:27\n+  --> $DIR/generic_duplicate_param_use3.rs:12:5\n    |\n-LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n-   |                           ^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: type used multiple times\n   --> $DIR/generic_duplicate_param_use3.rs:8:10"}, {"sha": "1e22930a5034b28779d4f6909426b5dc07c2d991", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -9,8 +9,8 @@ type Two<T, U> = impl Debug;\n //~^ ERROR `U` doesn't implement `Debug`\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     t\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {"}, {"sha": "64268abce50c0d78f089caebae7146844375d803", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use4.rs:11:27\n+  --> $DIR/generic_duplicate_param_use4.rs:12:5\n    |\n-LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n-   |                           ^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n note: type used multiple times\n   --> $DIR/generic_duplicate_param_use4.rs:8:10"}, {"sha": "2fe5c68ab576f9f34319307ce60df70e80727645", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -14,16 +14,16 @@ type OneConst<const X: usize> = impl Debug;\n // Not defining uses, because they doesn't define *all* possible generics.\n \n fn concrete_ty() -> OneTy<u32> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     5u32\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn concrete_lifetime() -> OneLifetime<'static> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     6u32\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn concrete_const() -> OneConst<{ 123 }> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     7u32\n+    //~^ ERROR non-defining opaque type use in defining scope\n }"}, {"sha": "1b2084b630f295872ffcfe67fefb462ab6658e02", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:16:21\n+  --> $DIR/generic_nondefining_use.rs:17:5\n    |\n-LL | fn concrete_ty() -> OneTy<u32> {\n-   |                     ^^^^^^^^^^\n+LL |     5u32\n+   |     ^^^^\n    |\n note: used non-generic type `u32` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:7:12\n@@ -17,13 +17,13 @@ LL | type OneTy<T> = impl Debug;\n    |                 ^^^^^^^^^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:21:27\n+  --> $DIR/generic_nondefining_use.rs:22:5\n    |\n LL | type OneLifetime<'a> = impl Debug;\n    |                  -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n ...\n-LL | fn concrete_lifetime() -> OneLifetime<'static> {\n-   |                           ^^^^^^^^^^^^^^^^^^^^\n+LL |     6u32\n+   |     ^^^^\n \n error: could not find defining uses\n   --> $DIR/generic_nondefining_use.rs:9:24\n@@ -32,10 +32,10 @@ LL | type OneLifetime<'a> = impl Debug;\n    |                        ^^^^^^^^^^\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:26:24\n+  --> $DIR/generic_nondefining_use.rs:27:5\n    |\n-LL | fn concrete_const() -> OneConst<{ 123 }> {\n-   |                        ^^^^^^^^^^^^^^^^^\n+LL |     7u32\n+   |     ^^^^\n    |\n note: used non-generic constant `123_usize` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:11:21"}, {"sha": "c70f473cff57890ebdb6ba49478610756d9e6902", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,6 +6,6 @@ type WrongGeneric<T: 'static> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n-    //~^ ERROR type parameter `V` is part of concrete type but not used in parameter list\n     v\n+    //~^ ERROR type parameter `V` is part of concrete type but not used in parameter list\n }"}, {"sha": "fd720239a5239adb002b24137a9bb4f58d4594b8", "filename": "src/test/ui/type-alias-impl-trait/generic_not_used.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_not_used.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,14 +5,10 @@ LL | type WrongGeneric<T: 'static> = impl 'static;\n    |                                 ^^^^^^^^^^^^\n \n error: type parameter `V` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/generic_not_used.rs:8:73\n+  --> $DIR/generic_not_used.rs:9:5\n    |\n-LL |   fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n-   |  _________________________________________________________________________^\n-LL | |\n-LL | |     v\n-LL | | }\n-   | |_^\n+LL |     v\n+   |     ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8c5659ed12c08a7758ffb7c674ad976cb122c76b", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,33 +1,31 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error: non-defining opaque type use in defining scope\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n LL |     let z: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-...\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                        ------------ the found opaque type\n+   |                  ^\n+   |\n+note: used non-generic type `&'static i32` for generic parameter\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:19\n    |\n-   = note:     expected type `i32`\n-           found opaque type `impl Sized`\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                   ^\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:15:5\n    |\n-LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                              ^^^^^^^^^^^^^^^\n+LL |     t\n+   |     ^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n@@ -37,5 +35,4 @@ LL | type WrongGeneric<T> = impl 'static;\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0308, E0310.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "4a7d640fe84de23831987dbfdb2f4d5cdd2862b0", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,13 +3,15 @@\n fn main() {\n     let y = 42;\n     let x = wrong_generic(&y);\n-    let z: i32 = x; //~ ERROR mismatched types\n+    let z: i32 = x;\n+    //~^ ERROR non-defining opaque type use\n }\n \n type WrongGeneric<T> = impl 'static;\n //~^ ERROR: at least one trait must be specified\n+//~| ERROR could not find defining uses\n \n fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-    //~^ ERROR the parameter type `T` may not live long enough\n     t\n+    //~^ ERROR the parameter type `T` may not live long enough\n }"}, {"sha": "22f8a757aad1d06fb64d9cd24346cf6aa8facb70", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,32 +1,35 @@\n error: at least one trait must be specified\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n    |\n LL | type WrongGeneric<T> = impl 'static;\n    |                        ^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error: non-defining opaque type use in defining scope\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n LL |     let z: i32 = x;\n-   |            ---   ^ expected `i32`, found opaque type\n-   |            |\n-   |            expected due to this\n-...\n-LL | type WrongGeneric<T> = impl 'static;\n-   |                        ------------ the found opaque type\n+   |                  ^\n+   |\n+note: used non-generic type `&'static i32` for generic parameter\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:19\n    |\n-   = note:     expected type `i32`\n-           found opaque type `impl Sized`\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                   ^\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:12:30\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:15:5\n    |\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n-   |                  -           ^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n-   |                  |\n-   |                  help: consider adding an explicit lifetime bound...: `T: 'static`\n+   |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n+LL |     t\n+   |     ^ ...so that the type `T` will meet its required lifetime bounds\n+\n+error: could not find defining uses\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:10:24\n+   |\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                        ^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0308, E0310.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "d00b6ce3f82c54820c62ff8a8756339cc72a85f0", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,7 +3,8 @@\n \n mod m {\n     type Foo = impl std::fmt::Debug;\n-    //~^ ERROR: cycle detected when computing type of `m::Foo::{opaque#0}` [E0391]\n+    //~^ ERROR cycle detected\n+    //~| ERROR cycle detected\n \n     // Cycle: error today, but it'd be nice if it eventually worked\n \n@@ -15,9 +16,8 @@ mod m {\n         is_send(foo()); // Today: error\n     }\n \n-    fn baz() {\n+    fn baz() { //~ ERROR concrete type differs from previous defining opaque type use\n         let f: Foo = 22_u32;\n-        //~^ ERROR: mismatched types [E0308]\n     }\n \n     fn is_send<T: Send>(_: T) {}"}, {"sha": "90032f589e009c074ce4835f3f48b1592f4ad6c9", "filename": "src/test/ui/type-alias-impl-trait/inference-cycle.stderr", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Finference-cycle.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,33 +5,47 @@ LL |     type Foo = impl std::fmt::Debug;\n    |                ^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires type-checking `m::bar`...\n-  --> $DIR/inference-cycle.rs:15:9\n+  --> $DIR/inference-cycle.rs:15:5\n    |\n-LL |         is_send(foo()); // Today: error\n-   |         ^^^^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::fmt::Debug: core::marker::Send`...\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n    = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in module `m`\n   --> $DIR/inference-cycle.rs:4:1\n    |\n LL | mod m {\n    | ^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/inference-cycle.rs:19:22\n+error[E0391]: cycle detected when computing type of `m::Foo::{opaque#0}`\n+  --> $DIR/inference-cycle.rs:5:16\n    |\n LL |     type Foo = impl std::fmt::Debug;\n-   |                -------------------- the expected opaque type\n-...\n-LL |         let f: Foo = 22_u32;\n-   |                ---   ^^^^^^ expected opaque type, found `u32`\n-   |                |\n-   |                expected due to this\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires type-checking `m::bar`...\n+  --> $DIR/inference-cycle.rs:15:5\n+   |\n+LL |     pub fn bar() {\n+   |     ^^^^^^^^^^^^\n+   = note: ...which again requires computing type of `m::Foo::{opaque#0}`, completing the cycle\n+note: cycle used when checking item types in module `m`\n+  --> $DIR/inference-cycle.rs:4:1\n+   |\n+LL | mod m {\n+   | ^^^^^\n+\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/inference-cycle.rs:19:5\n+   |\n+LL |     fn baz() {\n+   |     ^^^^^^^^ expected `()`, got `u32`\n+   |\n+note: previous use here\n+  --> $DIR/inference-cycle.rs:11:5\n+   |\n+LL |     pub fn foo() -> Foo {\n+   |     ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0308, E0391.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "34be42027440904a206ea52cc130dbb0268634a6", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -18,8 +18,8 @@ impl Foo for S2 {\n     type Item = impl Debug;\n \n     fn foo<T: Debug>(_: T) -> Self::Item {\n-        //~^ Error type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         S::<T>(Default::default())\n+        //~^ Error type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "34f0aa0d98d9ab781fb346b9592bca16dcc87f95", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-53598.rs:20:42\n+  --> $DIR/issue-53598.rs:21:9\n    |\n-LL |       fn foo<T: Debug>(_: T) -> Self::Item {\n-   |  __________________________________________^\n-LL | |\n-LL | |         S::<T>(Default::default())\n-LL | |     }\n-   | |_____^\n+LL |         S::<T>(Default::default())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "91aa77f2268b2fc89dfe5a5a179d8ba04d3b8a81", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -15,10 +15,11 @@ struct X;\n \n impl Foo for X {\n     type Bar = impl Baz<Self, Self>;\n+    //~^ ERROR could not find defining uses\n \n     fn bar(&self) -> Self::Bar {\n-        //~^ ERROR implementation of `FnOnce` is not general enough\n         |x| x\n+        //~^ ERROR implementation of `FnOnce` is not general enough\n     }\n }\n "}, {"sha": "c684a8bf6b01f3598778e4ec56e44e834eb8044a", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,11 +1,17 @@\n error: implementation of `FnOnce` is not general enough\n-  --> $DIR/issue-57611-trait-alias.rs:19:22\n+  --> $DIR/issue-57611-trait-alias.rs:21:9\n    |\n-LL |     fn bar(&self) -> Self::Bar {\n-   |                      ^^^^^^^^^ implementation of `FnOnce` is not general enough\n+LL |         |x| x\n+   |         ^^^^^ implementation of `FnOnce` is not general enough\n    |\n    = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n    = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "ba8bda76cecf6cf5473af6e0e9beafec3bb2a037", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -14,8 +14,8 @@ impl<C> Foo for C {\n     type Bar = impl Foo;\n \n     fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n-        //~^ Error type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n         self\n+        //~^ Error type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n     }\n }\n "}, {"sha": "56ad997f843142e7de6f4213810ea76a4003aad2", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,12 +1,8 @@\n error: type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-57700.rs:16:58\n+  --> $DIR/issue-57700.rs:17:9\n    |\n-LL |       fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n-   |  __________________________________________________________^\n-LL | |\n-LL | |         self\n-LL | |     }\n-   | |_____^\n+LL |         self\n+   |         ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e4ba7f8e2a6238c87f13b61086309a636baf6820", "filename": "src/test/ui/type-alias-impl-trait/issue-58951-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-58951-2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+\n+mod defining_use_scope {\n+    pub type A = impl Iterator;\n+\n+    pub fn def_a() -> A {\n+        0..1\n+    }\n+}\n+use defining_use_scope::*;\n+\n+pub fn use_a() {\n+    def_a().map(|x| x);\n+}\n+\n+fn main() {}"}, {"sha": "f2ecd5a455bfd9b24dc14bc589d68fff6bca74d6", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,10 +8,10 @@ trait Bug {\n \n impl Bug for &() {\n     type Item = impl Bug; //~ ERROR `impl Trait` in type aliases is unstable\n+    //~^ ERROR could not find defining uses\n \n     const FUN: fn() -> Self::Item = || ();\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n-    //~| ERROR non-defining opaque type use in defining scope\n }\n \n fn main() {}"}, {"sha": "fbe071ac85773fcafffa361e463764533ff15767", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,22 +8,19 @@ LL |     type Item = impl Bug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0277]: the trait bound `(): Bug` is not satisfied\n-  --> $DIR/issue-60371.rs:12:40\n+  --> $DIR/issue-60371.rs:13:40\n    |\n LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                        ^ the trait `Bug` is not implemented for `()`\n+   |                                        ^^ the trait `Bug` is not implemented for `()`\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60371.rs:12:37\n+error: could not find defining uses\n+  --> $DIR/issue-60371.rs:10:17\n    |\n-LL | impl Bug for &() {\n-   |              - cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n-...\n-LL |     const FUN: fn() -> Self::Item = || ();\n-   |                                     ^^^^^\n+LL |     type Item = impl Bug;\n+   |                 ^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "e645663c3420a596b0d289b4aa55c5ea87452b25", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -18,8 +18,8 @@ where\n {\n     type BitsIter = IterBitsIter<T, E, u8>;\n     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-        //~^ ERROR non-defining opaque type use in defining scope\n         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+        //~^ ERROR non-defining opaque type use in defining scope\n     }\n }\n "}, {"sha": "0a260a247c0824d349d2755e9924eb06145ff014", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60564.rs:20:34\n+  --> $DIR/issue-60564.rs:21:9\n    |\n-LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n-   |                                  ^^^^^^^^^^^^^^\n+LL |         (0u8..n).rev().map(move |shift| ((self >> T::from(shift)) & T::from(1)).try_into().unwrap())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: used non-generic type `u8` for generic parameter\n   --> $DIR/issue-60564.rs:8:25"}, {"sha": "3d20b7e37190dbf6ec86bcc8520fcc10ef4de636", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,9 +3,12 @@\n #![feature(type_alias_impl_trait)]\n \n type Closure = impl FnOnce();\n+//~^ ERROR could not find defining uses\n \n fn c() -> Closure {\n-    || -> Closure { || () } //~ ERROR: mismatched types\n+    || -> Closure { || () }\n+    //~^ ERROR: mismatched types\n+    //~| ERROR: expected a `FnOnce<()>` closure, found `()`\n }\n \n fn main() {}"}, {"sha": "385e816eebf52ac8f03df3ecc18b41930191a49e", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,17 +1,32 @@\n+error[E0277]: expected a `FnOnce<()>` closure, found `()`\n+  --> $DIR/issue-63279.rs:9:11\n+   |\n+LL |     || -> Closure { || () }\n+   |           ^^^^^^^ expected an `FnOnce<()>` closure, found `()`\n+   |\n+   = help: the trait `FnOnce<()>` is not implemented for `()`\n+   = note: wrap the `()` in a closure with no arguments: `|| { /* code */ }`\n+\n error[E0308]: mismatched types\n-  --> $DIR/issue-63279.rs:8:5\n+  --> $DIR/issue-63279.rs:9:21\n    |\n-LL | type Closure = impl FnOnce();\n-   |                ------------- the found opaque type\n-...\n LL |     || -> Closure { || () }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+   |                     ^^^^^ expected `()`, found closure\n    |\n-   = note: expected type `[closure@$DIR/issue-63279.rs:8:21: 8:26]`\n-           found closure `[closure@$DIR/issue-63279.rs:8:5: 8:28]`\n-   = note: no two closures, even if identical, have the same type\n-   = help: consider boxing your closure and/or using it as a trait object\n+   = note: expected unit type `()`\n+                found closure `[closure@$DIR/issue-63279.rs:9:21: 9:26]`\n+help: you might have meant to return this value\n+   |\n+LL |     || -> Closure { return || (); }\n+   |                     ++++++      +\n+\n+error: could not find defining uses\n+  --> $DIR/issue-63279.rs:5:16\n+   |\n+LL | type Closure = impl FnOnce();\n+   |                ^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0277, E0308.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "7066a0535e1848e975b2cf124b605fbdddbdb241", "filename": "src/test/ui/type-alias-impl-trait/issue-63355.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63355.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,6 +1,5 @@\n #![feature(type_alias_impl_trait)]\n-#![feature(type_alias_impl_trait)]\n-#![allow(incomplete_features)]\n+// check-pass\n \n pub trait Foo {}\n \n@@ -28,11 +27,8 @@ impl Bar for () {\n     }\n }\n \n-// FIXME(#86731): The below is illegal use of `type_alias_impl_trait`\n-// but the compiler doesn't report it, we should fix it.\n pub type FooImpl = impl Foo;\n pub type BarImpl = impl Bar<Foo = FooImpl>;\n-//~^ ERROR: type mismatch resolving `<() as Bar>::Foo == ()`\n \n impl Baz for () {\n     type Foo = FooImpl;"}, {"sha": "6fc6b4bfe1f0048cff2e0fe98fd8c080646e7984", "filename": "src/test/ui/type-alias-impl-trait/issue-63355.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63355.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63355.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63355.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,19 +0,0 @@\n-error[E0271]: type mismatch resolving `<() as Bar>::Foo == ()`\n-  --> $DIR/issue-63355.rs:34:20\n-   |\n-LL | pub type FooImpl = impl Foo;\n-   |                    -------- the found opaque type\n-LL | pub type BarImpl = impl Bar<Foo = FooImpl>;\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<() as Bar>::Foo == ()`\n-   |\n-note: expected this to be `()`\n-  --> $DIR/issue-63355.rs:24:16\n-   |\n-LL |     type Foo = FooImpl;\n-   |                ^^^^^^^\n-   = note: expected unit type `()`\n-            found opaque type `impl Foo`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "3524d1ea8a4d51c7335a822dbf90e5618d0227f8", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-68368-non-defining-use-2.rs:9:15\n+  --> $DIR/issue-68368-non-defining-use-2.rs:9:29\n    |\n LL | fn f<'a>() -> Alias<'a, ()> {}\n-   |               ^^^^^^^^^^^^^\n+   |                             ^^\n    |\n note: used non-generic type `()` for generic parameter\n   --> $DIR/issue-68368-non-defining-use-2.rs:7:16"}, {"sha": "3f7c57f721d55adc060305e3a217ad46356af14a", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-68368-non-defining-use.rs:9:15\n+  --> $DIR/issue-68368-non-defining-use.rs:9:29\n    |\n LL | fn f<'a>() -> Alias<'a, ()> {}\n-   |               ^^^^^^^^^^^^^\n+   |                             ^^\n    |\n note: used non-generic type `()` for generic parameter\n   --> $DIR/issue-68368-non-defining-use.rs:7:16"}, {"sha": "eceaef30e042946cffc0ae394f5a0bfaf0c5fc3a", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -3,6 +3,7 @@\n #![feature(type_alias_impl_trait)]\n \n type Test = impl Copy;\n+//~^ ERROR could not find defining uses\n \n fn test() -> Test {\n     let y = || -> Test { () };"}, {"sha": "475a0052234265245ea13ef2031ea85d2c4b0fda", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,9 +1,17 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-74280.rs:9:5\n+  --> $DIR/issue-74280.rs:10:5\n    |\n+LL |     let y = || -> Test { () };\n+   |                          -- type expected due to this\n LL |     7\n    |     ^ expected `()`, found integer\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/issue-74280.rs:5:13\n+   |\n+LL | type Test = impl Copy;\n+   |             ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "9e742a2550029b038c18d8d9744d30edb72e8ea8", "filename": "src/test/ui/type-alias-impl-trait/issue-77179.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,7 +5,7 @@ LL | fn test() -> Pointer<_> {\n    |              --------^-\n    |              |       |\n    |              |       not allowed in type signatures\n-   |              help: replace with the correct return type: `Box<i32>`\n+   |              help: replace with the correct return type: `impl Deref<Target = i32>`\n \n error: aborting due to previous error\n "}, {"sha": "3a75dc6fe7ba05403f8b471b457780cc009c2776", "filename": "src/test/ui/type-alias-impl-trait/issue-89686.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-89686.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-89686.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-89686.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -2,18 +2,18 @@ error[E0271]: type mismatch resolving `<impl Future<Output = [async output]> as\n   --> $DIR/issue-89686.rs:7:17\n    |\n LL | type G<'a, T> = impl Future<Output = ()>;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found associated type\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found `()`\n ...\n LL |         async move { self.f().await }\n-   |                    ------------------ the found `async` block\n+   |                    ------------------ the expected `async` block\n    |\n   ::: $SRC_DIR/core/src/future/mod.rs:LL:COL\n    |\n LL | pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n-   |                                           ------------------------------- the found opaque type\n+   |                                           ------------------------------- the expected opaque type\n    |\n-   = note:    expected unit type `()`\n-           found associated type `<impl Future<Output = [async output]> as Future>::Output`\n+   = note: expected associated type `<impl Future<Output = [async output]> as Future>::Output`\n+                    found unit type `()`\n    = help: consider constraining the associated type `<impl Future<Output = [async output]> as Future>::Output` to `()`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n "}, {"sha": "49ce39c57d193eca06488f12593e8444df5631e4", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,10 +5,11 @@\n #![feature(type_alias_impl_trait)]\n \n type X<A, B> = impl Into<&'static A>;\n+//~^ ERROR could not find defining uses\n \n fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n-    //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n     (a, a)\n+    //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n }\n \n fn main() {"}, {"sha": "4c3f527a21421ab6e36958f006d0dff6bddc82ad", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,15 +1,21 @@\n error[E0277]: the trait bound `&'static B: From<&A>` is not satisfied\n-  --> $DIR/multiple-def-uses-in-one-fn.rs:9:45\n+  --> $DIR/multiple-def-uses-in-one-fn.rs:11:9\n    |\n-LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n-   |                                             ^^^^^^^^^^^^^^^^^^ the trait `From<&A>` is not implemented for `&'static B`\n+LL |     (a, a)\n+   |         ^ the trait `From<&A>` is not implemented for `&'static B`\n    |\n    = note: required because of the requirements on the impl of `Into<&'static B>` for `&A`\n help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n    |                                                                ++++++++++++++++++++++++++\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/multiple-def-uses-in-one-fn.rs:7:16\n+   |\n+LL | type X<A, B> = impl Into<&'static A>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "65bd12d9a9ab976744ef6378d1ba95ff1a7a4683", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn3.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -6,7 +6,9 @@ LL | fn g<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A\n    |      |\n    |      expected type parameter\n LL |     (a, b)\n-   |         ^ expected type parameter `A`, found type parameter `B`\n+   |      -  ^ expected type parameter `A`, found type parameter `B`\n+   |      |\n+   |      type expected due to this\n    |\n    = note: expected type parameter `A`\n               found type parameter `B`"}, {"sha": "075235ec15d4f314004c330a30557d90c69f9bc2", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n-// check-pass\n-\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n+// check-pass\n+\n use std::fmt::Debug;\n \n type FooX = impl Debug;"}, {"sha": "365f10f947518680dc684dbfe8150759f3c36b93", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -4,16 +4,17 @@\n use std::fmt::Debug;\n \n type FooX = impl Debug;\n-//~^ ERROR: could not find defining uses\n+//~^ ERROR could not find defining uses\n \n trait Foo<A> {}\n \n impl Foo<()> for () {}\n impl Foo<u32> for () {}\n \n fn foo() -> impl Foo<FooX> {\n-    //~^ ERROR: the trait bound `(): Foo<impl Debug>` is not satisfied [E0277]\n     ()\n+    //~^ ERROR: type annotations needed\n+    //~| ERROR: type annotations needed\n }\n \n fn main() {}"}, {"sha": "294cd07675b88a1c6f1c1c0a801ffa7b414c4f4e", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference2.stderr", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,19 +1,30 @@\n-error[E0277]: the trait bound `(): Foo<impl Debug>` is not satisfied\n-  --> $DIR/nested-tait-inference2.rs:14:13\n+error[E0282]: type annotations needed\n+  --> $DIR/nested-tait-inference2.rs:15:5\n    |\n-LL | fn foo() -> impl Foo<FooX> {\n-   |             ^^^^^^^^^^^^^^ the trait `Foo<impl Debug>` is not implemented for `()`\n+LL |     ()\n+   |     ^^ cannot infer type\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/nested-tait-inference2.rs:15:5\n+   |\n+LL |     ()\n+   |     ^^ cannot infer type\n+   |\n+note: multiple `impl`s satisfying `(): Foo<_>` found\n+  --> $DIR/nested-tait-inference2.rs:11:1\n    |\n-   = help: the following implementations were found:\n-             <() as Foo<()>>\n-             <() as Foo<u32>>\n+LL | impl Foo<()> for () {}\n+   | ^^^^^^^^^^^^^^^^^^^\n+LL | impl Foo<u32> for () {}\n+   | ^^^^^^^^^^^^^^^^^^^^\n \n error: could not find defining uses\n   --> $DIR/nested-tait-inference2.rs:6:13\n    |\n LL | type FooX = impl Debug;\n    |             ^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "e884fa0a48d67989fff5c281fb9f0075d6cda860", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,17 @@\n+#![feature(type_alias_impl_trait)]\n+#![allow(dead_code)]\n+\n+use std::fmt::Debug;\n+\n+type FooX = impl Debug;\n+//~^ could not find defining uses\n+\n+trait Foo<A> { }\n+\n+impl Foo<FooX> for () { }\n+\n+fn foo() -> impl Foo<FooX> {\n+    ()\n+}\n+\n+fn main() { }"}, {"sha": "6bbed0032b5151ebcffd859b44dc4f94f53e3a34", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,8 @@\n+error: could not find defining uses\n+  --> $DIR/nested-tait-inference3.rs:6:13\n+   |\n+LL | type FooX = impl Debug;\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fed5ac07c901e5266345ff8ad8e30764126b2e45", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,15 +1,14 @@\n #![feature(type_alias_impl_trait)]\n-\n+// check-pass\n fn main() {}\n \n-// don't reveal the concrete type\n type NoReveal = impl std::fmt::Debug;\n \n fn define_no_reveal() -> NoReveal {\n     \"\"\n }\n \n fn no_reveal(x: NoReveal) {\n-    let _: &'static str = x; //~ mismatched types\n-    let _ = x as &'static str; //~ non-primitive cast\n+    let _: &'static str = x;\n+    let _ = x as &'static str;\n }"}, {"sha": "b438f84451649f248c1f67c21917291a87510f7e", "filename": "src/test/ui/type-alias-impl-trait/never_reveal_concrete_type.stderr", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnever_reveal_concrete_type.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,24 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/never_reveal_concrete_type.rs:13:27\n-   |\n-LL | type NoReveal = impl std::fmt::Debug;\n-   |                 -------------------- the found opaque type\n-...\n-LL |     let _: &'static str = x;\n-   |            ------------   ^ expected `&str`, found opaque type\n-   |            |\n-   |            expected due to this\n-   |\n-   = note: expected reference `&'static str`\n-            found opaque type `impl Debug`\n-\n-error[E0605]: non-primitive cast: `impl Debug` as `&'static str`\n-  --> $DIR/never_reveal_concrete_type.rs:14:13\n-   |\n-LL |     let _ = x as &'static str;\n-   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0308, E0605.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "d12160a979312ca8954d18378c8904abe80afaf3", "filename": "src/test/ui/type-alias-impl-trait/no_revealing_outside_defining_module.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fno_revealing_outside_defining_module.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -5,9 +5,7 @@ LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ---------------------- the found opaque type\n ...\n LL |     let _: &str = bomp();\n-   |            ----   ^^^^^^ expected `&str`, found opaque type\n-   |            |\n-   |            expected due to this\n+   |                   ^^^^^^ expected `&str`, found opaque type\n    |\n    = note: expected reference `&str`\n             found opaque type `impl Debug`\n@@ -18,13 +16,11 @@ error[E0308]: mismatched types\n LL |     pub type Boo = impl ::std::fmt::Debug;\n    |                    ---------------------- the expected opaque type\n ...\n-LL | fn bomp() -> boo::Boo {\n-   |              -------- expected `impl Debug` because of return type\n LL |     \"\"\n    |     ^^ expected opaque type, found `&str`\n    |\n    = note: expected opaque type `impl Debug`\n-                found reference `&'static str`\n+                found reference `&str`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cad3ff87749a6235cc71189c424ced6cbb6d4a95", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -8,8 +8,8 @@ type Two<T, U> = impl Debug;\n //~^ ERROR `T` doesn't implement `Debug`\n \n fn two<T: Debug>(t: T) -> Two<T, u32> {\n-    //~^ ERROR non-defining opaque type use in defining scope\n     (t, 4i8)\n+    //~^ ERROR non-defining opaque type use in defining scope\n }\n \n fn three<T: Debug, U>(t: T) -> Two<T, U> {"}, {"sha": "aa05f62eb53eacf837003aeca075b6f3dd89ccdc", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,8 +1,8 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/not_a_defining_use.rs:10:27\n+  --> $DIR/not_a_defining_use.rs:11:5\n    |\n-LL | fn two<T: Debug>(t: T) -> Two<T, u32> {\n-   |                           ^^^^^^^^^^^\n+LL |     (t, 4i8)\n+   |     ^^^^^^^^\n    |\n note: used non-generic type `u32` for generic parameter\n   --> $DIR/not_a_defining_use.rs:7:13"}, {"sha": "748a279e43989521e548e817598db416d1643876", "filename": "src/test/ui/type-alias-impl-trait/static-const-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstatic-const-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstatic-const-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstatic-const-types.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,13 +1,13 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n-// FIXME: This should compile, but it currently doesn't\n+// check-pass\n \n use std::fmt::Debug;\n \n-type Foo = impl Debug; //~ ERROR could not find defining uses\n+type Foo = impl Debug;\n \n-static FOO1: Foo = 22_u32; //~ ERROR mismatched types\n-const FOO2: Foo = 22_u32; //~ ERROR mismatched types\n+static FOO1: Foo = 22_u32;\n+const FOO2: Foo = 22_u32;\n \n fn main() {}"}, {"sha": "6f4c2944f72851e4ec6b1c8084091b1d86d19b2f", "filename": "src/test/ui/type-alias-impl-trait/static-const-types.stderr", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstatic-const-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstatic-const-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstatic-const-types.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,33 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/static-const-types.rs:10:20\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-LL | \n-LL | static FOO1: Foo = 22_u32;\n-   |                    ^^^^^^ expected opaque type, found `u32`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/static-const-types.rs:11:19\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL | const FOO2: Foo = 22_u32;\n-   |                   ^^^^^^ expected opaque type, found `u32`\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error: could not find defining uses\n-  --> $DIR/static-const-types.rs:8:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "e0d24146179bcd8a3e9c036fdff87b7d477b4c80", "filename": "src/test/ui/type-alias-impl-trait/structural-match-no-leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -11,7 +11,7 @@ const fn leak_free() -> Bar {\n const LEAK_FREE: Bar = leak_free();\n \n fn leak_free_test() {\n-    match todo!() {\n+    match LEAK_FREE {\n         LEAK_FREE => (),\n         //~^ `impl Send` cannot be used in patterns\n         _ => (),"}, {"sha": "1a2c373bac124fadd00e297d68c90e93c07adc32", "filename": "src/test/ui/type-alias-impl-trait/structural-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -12,7 +12,7 @@ const fn value() -> Foo {\n const VALUE: Foo = value();\n \n fn test() {\n-    match todo!() {\n+    match VALUE {\n         VALUE => (),\n         //~^ `impl Send` cannot be used in patterns\n         _ => (),"}, {"sha": "5630e036be34b317cb9eea81a716b718fc81d9b4", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-const.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,13 +1,11 @@\n #![feature(type_alias_impl_trait)]\n-\n+// check-pass\n // Ensures that `const` items can constrain an opaque `impl Trait`.\n \n use std::fmt::Debug;\n \n pub type Foo = impl Debug;\n-//~^ ERROR could not find defining uses\n \n const _FOO: Foo = 5;\n-//~^ ERROR mismatched types [E0308]\n \n fn main() {}"}, {"sha": "e2567e87ac676700f0bf7c5ad00152f0c4472a6f", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait-const.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b5984597202489c5e42461db530fa48e45a8e/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait-const.stderr?ref=8d2b5984597202489c5e42461db530fa48e45a8e", "patch": "@@ -1,21 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/type-alias-impl-trait-const.rs:10:19\n-   |\n-LL | pub type Foo = impl Debug;\n-   |                ---------- the expected opaque type\n-...\n-LL | const _FOO: Foo = 5;\n-   |                   ^ expected opaque type, found integer\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `{integer}`\n-\n-error: could not find defining uses\n-  --> $DIR/type-alias-impl-trait-const.rs:7:16\n-   |\n-LL | pub type Foo = impl Debug;\n-   |                ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "70c2ee4278ca218be1d44876c135cad0b505cc95", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,4 +1,4 @@\n-// run-pass\n+// check-pass\n \n #![allow(dead_code)]\n #![allow(unused_assignments)]"}, {"sha": "67f56bcde939a69588bda927b205d25c1d78620f", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait2.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait2.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -0,0 +1,84 @@\n+// check-pass\n+\n+#![allow(dead_code)]\n+#![allow(unused_assignments)]\n+#![allow(unused_variables)]\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {\n+    assert_eq!(foo().to_string(), \"foo\");\n+    assert_eq!(bar1().to_string(), \"bar1\");\n+    assert_eq!(bar2().to_string(), \"bar2\");\n+    let mut x = bar1();\n+    x = bar2();\n+    assert_eq!(my_iter(42u8).collect::<Vec<u8>>(), vec![42u8]);\n+}\n+\n+use defining_use_scope::*;\n+\n+mod defining_use_scope {\n+    // single definition\n+    pub type Foo = impl std::fmt::Display;\n+\n+    pub fn foo() -> Foo {\n+        \"foo\"\n+    }\n+\n+    // two definitions\n+    pub type Bar = impl std::fmt::Display;\n+\n+    pub fn bar1() -> Bar {\n+        \"bar1\"\n+    }\n+\n+    pub fn bar2() -> Bar {\n+        \"bar2\"\n+    }\n+\n+    pub type MyIter<T> = impl Iterator<Item = T>;\n+\n+    pub fn my_iter<T>(t: T) -> MyIter<T> {\n+        std::iter::once(t)\n+    }\n+\n+    fn my_iter2<T>(t: T) -> MyIter<T> {\n+        std::iter::once(t)\n+    }\n+\n+    // param names should not have an effect!\n+    fn my_iter3<U>(u: U) -> MyIter<U> {\n+        std::iter::once(u)\n+    }\n+\n+    // param position should not have an effect!\n+    fn my_iter4<U, V>(_: U, v: V) -> MyIter<V> {\n+        std::iter::once(v)\n+    }\n+\n+    // param names should not have an effect!\n+    type MyOtherIter<T> = impl Iterator<Item = T>;\n+\n+    fn my_other_iter<U>(u: U) -> MyOtherIter<U> {\n+        std::iter::once(u)\n+    }\n+\n+    trait Trait {}\n+    type GenericBound<'a, T: Trait + 'a> = impl Sized + 'a;\n+\n+    fn generic_bound<'a, T: Trait + 'a>(t: T) -> GenericBound<'a, T> {\n+        t\n+    }\n+\n+    mod pass_through {\n+        pub type Passthrough<T: 'static> = impl Sized + 'static;\n+\n+        fn define_passthrough<T: 'static>(t: T) -> Passthrough<T> {\n+            t\n+        }\n+    }\n+\n+    fn use_passthrough(x: pass_through::Passthrough<u32>) -> pass_through::Passthrough<u32> {\n+        x\n+    }\n+\n+}"}, {"sha": "4e9d1788b94d833e6fca30adec602bbdaf3a141c", "filename": "src/test/ui/type-alias-impl-trait/type_of_a_let.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,27 +1,20 @@\n #![feature(type_alias_impl_trait)]\n #![allow(dead_code)]\n \n-// FIXME This should compile, but it currently doesn't\n-\n use std::fmt::Debug;\n \n type Foo = impl Debug;\n-//~^ ERROR: could not find defining uses\n \n fn foo1() -> u32 {\n     let x: Foo = 22_u32;\n-    //~^ ERROR: mismatched types [E0308]\n     x\n-    //~^ ERROR: mismatched types [E0308]\n }\n \n fn foo2() -> u32 {\n     let x: Foo = 22_u32;\n-    //~^ ERROR: mismatched types [E0308]\n     let y: Foo = x;\n-    same_type((x, y));\n-    y\n-    //~^ ERROR: mismatched types [E0308]\n+    same_type((x, y)); //~ ERROR use of moved value\n+    y //~ ERROR use of moved value\n }\n \n fn same_type<T>(x: (T, T)) {}"}, {"sha": "eccd3f9048f0e5b778b2b5b9d360d0fd0784a152", "filename": "src/test/ui/type-alias-impl-trait/type_of_a_let.stderr", "status": "modified", "additions": 16, "deletions": 60, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype_of_a_let.stderr?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -1,67 +1,23 @@\n-error[E0308]: mismatched types\n-  --> $DIR/type_of_a_let.rs:12:18\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/type_of_a_let.rs:16:16\n    |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n LL |     let x: Foo = 22_u32;\n-   |            ---   ^^^^^^ expected opaque type, found `u32`\n-   |            |\n-   |            expected due to this\n-   |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type_of_a_let.rs:14:5\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the found opaque type\n-...\n-LL | fn foo1() -> u32 {\n-   |              --- expected `u32` because of return type\n-...\n-LL |     x\n-   |     ^ expected `u32`, found opaque type\n-   |\n-   = note:     expected type `u32`\n-           found opaque type `impl Debug`\n+   |         - move occurs because `x` has type `impl Debug`, which does not implement the `Copy` trait\n+LL |     let y: Foo = x;\n+   |                  - value moved here\n+LL |     same_type((x, y));\n+   |                ^ value used here after move\n \n-error[E0308]: mismatched types\n-  --> $DIR/type_of_a_let.rs:19:18\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the expected opaque type\n-...\n-LL |     let x: Foo = 22_u32;\n-   |            ---   ^^^^^^ expected opaque type, found `u32`\n-   |            |\n-   |            expected due to this\n+error[E0382]: use of moved value: `y`\n+  --> $DIR/type_of_a_let.rs:17:5\n    |\n-   = note: expected opaque type `impl Debug`\n-                     found type `u32`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type_of_a_let.rs:23:5\n-   |\n-LL | type Foo = impl Debug;\n-   |            ---------- the found opaque type\n-...\n-LL | fn foo2() -> u32 {\n-   |              --- expected `u32` because of return type\n-...\n+LL |     let y: Foo = x;\n+   |         - move occurs because `y` has type `impl Debug`, which does not implement the `Copy` trait\n+LL |     same_type((x, y));\n+   |                   - value moved here\n LL |     y\n-   |     ^ expected `u32`, found opaque type\n-   |\n-   = note:     expected type `u32`\n-           found opaque type `impl Debug`\n-\n-error: could not find defining uses\n-  --> $DIR/type_of_a_let.rs:8:12\n-   |\n-LL | type Foo = impl Debug;\n-   |            ^^^^^^^^^^\n+   |     ^ value used here after move\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "5407b5e8ed93e8c014503b099723485fc67660c3", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f6e06b7c0262a6940b5161f3ac507084e7daea6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=0f6e06b7c0262a6940b5161f3ac507084e7daea6", "patch": "@@ -32,6 +32,7 @@ pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv:\n                 | ty::PredicateKind::Projection(_)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),"}]}