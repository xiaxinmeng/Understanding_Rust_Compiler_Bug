{"sha": "3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0Nzg4OTdmODZjYzFiM2UzZjgzZTlkNGU3Y2VkZmY0MTcyMWZiMDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T18:33:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-13T18:33:54Z"}, "message": "internal: remove DiagnosticWithFix infra", "tree": {"sha": "9700c178acb48fcc029f4120169f00a94d7308f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9700c178acb48fcc029f4120169f00a94d7308f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "html_url": "https://github.com/rust-lang/rust/commit/3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc30c5ccbeba2a102922da497809dd3f812544c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc30c5ccbeba2a102922da497809dd3f812544c4", "html_url": "https://github.com/rust-lang/rust/commit/fc30c5ccbeba2a102922da497809dd3f812544c4"}], "stats": {"total": 1119, "additions": 534, "deletions": 585}, "files": [{"sha": "7978c1fc225b8bd1bfec4dfc5fbf71fd676704be", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 492, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "patch": "@@ -16,20 +16,19 @@ mod no_such_field;\n mod remove_this_semicolon;\n mod replace_filter_map_next_with_find_map;\n mod unimplemented_builtin_macro;\n+mod unlinked_file;\n mod unresolved_extern_crate;\n mod unresolved_import;\n mod unresolved_macro_call;\n mod unresolved_module;\n mod unresolved_proc_macro;\n \n-mod fixes;\n mod field_shorthand;\n-mod unlinked_file;\n \n use std::cell::RefCell;\n \n use hir::{\n-    diagnostics::{AnyDiagnostic, Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n+    diagnostics::{AnyDiagnostic, DiagnosticCode, DiagnosticSinkBuilder},\n     Semantics,\n };\n use ide_assists::AssistResolveStrategy;\n@@ -38,15 +37,13 @@ use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode, SyntaxNodePtr, TextRange, TextSize,\n+    SyntaxNode, TextRange,\n };\n use text_edit::TextEdit;\n use unlinked_file::UnlinkedFile;\n \n use crate::{Assist, AssistId, AssistKind, FileId, Label, SourceChange};\n \n-use self::fixes::DiagnosticWithFixes;\n-\n #[derive(Debug)]\n pub struct Diagnostic {\n     // pub name: Option<String>,\n@@ -165,19 +162,6 @@ pub(crate) fn diagnostics(\n     }\n     let res = RefCell::new(res);\n     let sink_builder = DiagnosticSinkBuilder::new()\n-        .on::<UnlinkedFile, _>(|d| {\n-            // Limit diagnostic to the first few characters in the file. This matches how VS Code\n-            // renders it with the full span, but on other editors, and is less invasive.\n-            let range = sema.diagnostics_display_range(d.display_source()).range;\n-            let range = range.intersect(TextRange::up_to(TextSize::of(\"...\"))).unwrap_or(range);\n-\n-            // Override severity and mark as unused.\n-            res.borrow_mut().push(\n-                Diagnostic::hint(range, d.message())\n-                    .with_fixes(d.fixes(&sema, resolve))\n-                    .with_code(Some(d.code())),\n-            );\n-        })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n         .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n@@ -197,18 +181,22 @@ pub(crate) fn diagnostics(\n \n     let mut diags = Vec::new();\n     let internal_diagnostics = cfg!(test);\n-    match sema.to_module_def(file_id) {\n-        Some(m) => diags = m.diagnostics(db, &mut sink, internal_diagnostics),\n-        None => {\n-            sink.push(UnlinkedFile { file_id, node: SyntaxNodePtr::new(parse.tree().syntax()) });\n-        }\n+    let module = sema.to_module_def(file_id);\n+    if let Some(m) = module {\n+        diags = m.diagnostics(db, &mut sink, internal_diagnostics)\n     }\n \n     drop(sink);\n \n     let mut res = res.into_inner();\n \n     let ctx = DiagnosticsContext { config, sema, resolve };\n+    if module.is_none() {\n+        let d = UnlinkedFile { file: file_id };\n+        let d = unlinked_file::unlinked_file(&ctx, &d);\n+        res.push(d)\n+    }\n+\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n@@ -234,16 +222,20 @@ pub(crate) fn diagnostics(\n                 None => continue,\n             }\n         };\n+        res.push(d)\n+    }\n+\n+    res.retain(|d| {\n         if let Some(code) = d.code {\n             if ctx.config.disabled.contains(code.as_str()) {\n-                continue;\n+                return false;\n             }\n         }\n         if ctx.config.disable_experimental && d.experimental {\n-            continue;\n+            return false;\n         }\n-        res.push(d)\n-    }\n+        true\n+    });\n \n     res\n }\n@@ -378,8 +370,9 @@ mod tests {\n             file_position.offset\n         );\n     }\n+\n     /// Checks that there's a diagnostic *without* fix at `$0`.\n-    fn check_no_fix(ra_fixture: &str) {\n+    pub(crate) fn check_no_fix(ra_fixture: &str) {\n         let (analysis, file_position) = fixture::position(ra_fixture);\n         let diagnostic = analysis\n             .diagnostics(\n@@ -523,142 +516,6 @@ mod a {\n         assert!(!diagnostics.is_empty());\n     }\n \n-    #[test]\n-    fn unlinked_file_prepend_first_item() {\n-        cov_mark::check!(unlinked_file_prepend_before_first_item);\n-        // Only tests the first one for `pub mod` since the rest are the same\n-        check_fixes(\n-            r#\"\n-//- /main.rs\n-fn f() {}\n-//- /foo.rs\n-$0\n-\"#,\n-            vec![\n-                r#\"\n-mod foo;\n-\n-fn f() {}\n-\"#,\n-                r#\"\n-pub mod foo;\n-\n-fn f() {}\n-\"#,\n-            ],\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_append_mod() {\n-        cov_mark::check!(unlinked_file_append_to_existing_mods);\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-//! Comment on top\n-\n-mod preexisting;\n-\n-mod preexisting2;\n-\n-struct S;\n-\n-mod preexisting_bottom;)\n-//- /foo.rs\n-$0\n-\"#,\n-            r#\"\n-//! Comment on top\n-\n-mod preexisting;\n-\n-mod preexisting2;\n-mod foo;\n-\n-struct S;\n-\n-mod preexisting_bottom;)\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_insert_in_empty_file() {\n-        cov_mark::check!(unlinked_file_empty_file);\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-//- /foo.rs\n-$0\n-\"#,\n-            r#\"\n-mod foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_old_style_modrs() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod submod;\n-//- /submod/mod.rs\n-// in mod.rs\n-//- /submod/foo.rs\n-$0\n-\"#,\n-            r#\"\n-// in mod.rs\n-mod foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_new_style_mod() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod submod;\n-//- /submod.rs\n-//- /submod/foo.rs\n-$0\n-\"#,\n-            r#\"\n-mod foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_with_cfg_off() {\n-        cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);\n-        check_no_fix(\n-            r#\"\n-//- /main.rs\n-#[cfg(never)]\n-mod foo;\n-\n-//- /foo.rs\n-$0\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn unlinked_file_with_cfg_on() {\n-        check_diagnostics(\n-            r#\"\n-//- /main.rs\n-#[cfg(not(never))]\n-mod foo;\n-\n-//- /foo.rs\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn import_extern_crate_clash_with_inner_item() {\n         // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n@@ -1595,330 +1452,3 @@ fn main() {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod decl_check_tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n-\n-    #[test]\n-    fn incorrect_function_name() {\n-        check_diagnostics(\n-            r#\"\n-fn NonSnakeCaseName() {}\n-// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_function_params() {\n-        check_diagnostics(\n-            r#\"\n-fn foo(SomeParam: u8) {}\n-    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n-\n-fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n-                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_variable_names() {\n-        check_diagnostics(\n-            r#\"\n-fn foo() {\n-    let SOME_VALUE = 10;\n-     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n-    let AnotherValue = 20;\n-     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_struct_names() {\n-        check_diagnostics(\n-            r#\"\n-struct non_camel_case_name {}\n-    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n-\n-struct SCREAMING_CASE {}\n-    // ^^^^^^^^^^^^^^ Structure `SCREAMING_CASE` should have CamelCase name, e.g. `ScreamingCase`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_camel_cased_acronyms_in_struct_name() {\n-        check_diagnostics(\n-            r#\"\n-struct AABB {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_struct_field() {\n-        check_diagnostics(\n-            r#\"\n-struct SomeStruct { SomeField: u8 }\n-                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_enum_names() {\n-        check_diagnostics(\n-            r#\"\n-enum some_enum { Val(u8) }\n-  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n-\n-enum SOME_ENUM {}\n-  // ^^^^^^^^^ Enum `SOME_ENUM` should have CamelCase name, e.g. `SomeEnum`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_camel_cased_acronyms_in_enum_name() {\n-        check_diagnostics(\n-            r#\"\n-enum AABB {}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_enum_variant_name() {\n-        check_diagnostics(\n-            r#\"\n-enum SomeEnum { SOME_VARIANT(u8) }\n-             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_const_name() {\n-        check_diagnostics(\n-            r#\"\n-const some_weird_const: u8 = 10;\n-   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn incorrect_static_name() {\n-        check_diagnostics(\n-            r#\"\n-static some_weird_const: u8 = 10;\n-    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fn_inside_impl_struct() {\n-        check_diagnostics(\n-            r#\"\n-struct someStruct;\n-    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n-\n-impl someStruct {\n-    fn SomeFunc(&self) {\n-    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n-        let WHY_VAR_IS_CAPS = 10;\n-         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_diagnostic_for_enum_varinats() {\n-        check_diagnostics(\n-            r#\"\n-enum Option { Some, None }\n-\n-fn main() {\n-    match Option::None {\n-        None => (),\n-        Some => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn non_let_bind() {\n-        check_diagnostics(\n-            r#\"\n-enum Option { Some, None }\n-\n-fn main() {\n-    match Option::None {\n-        SOME_VAR @ None => (),\n-     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n-        Some => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn allow_attributes() {\n-        check_diagnostics(\n-            r#\"\n-#[allow(non_snake_case)]\n-fn NonSnakeCaseName(SOME_VAR: u8) -> u8{\n-    // cov_flags generated output from elsewhere in this file\n-    extern \"C\" {\n-        #[no_mangle]\n-        static lower_case: u8;\n-    }\n-\n-    let OtherVar = SOME_VAR + 1;\n-    OtherVar\n-}\n-\n-#[allow(nonstandard_style)]\n-mod CheckNonstandardStyle {\n-    fn HiImABadFnName() {}\n-}\n-\n-#[allow(bad_style)]\n-mod CheckBadStyle {\n-    fn HiImABadFnName() {}\n-}\n-\n-mod F {\n-    #![allow(non_snake_case)]\n-    fn CheckItWorksWithModAttr(BAD_NAME_HI: u8) {}\n-}\n-\n-#[allow(non_snake_case, non_camel_case_types)]\n-pub struct some_type {\n-    SOME_FIELD: u8,\n-    SomeField: u16,\n-}\n-\n-#[allow(non_upper_case_globals)]\n-pub const some_const: u8 = 10;\n-\n-#[allow(non_upper_case_globals)]\n-pub static SomeStatic: u8 = 10;\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn allow_attributes_crate_attr() {\n-        check_diagnostics(\n-            r#\"\n-#![allow(non_snake_case)]\n-\n-mod F {\n-    fn CheckItWorksWithCrateAttr(BAD_NAME_HI: u8) {}\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn bug_trait_inside_fn() {\n-        // FIXME:\n-        // This is broken, and in fact, should not even be looked at by this\n-        // lint in the first place. There's weird stuff going on in the\n-        // collection phase.\n-        // It's currently being brought in by:\n-        // * validate_func on `a` recursing into modules\n-        // * then it finds the trait and then the function while iterating\n-        //   through modules\n-        // * then validate_func is called on Dirty\n-        // * ... which then proceeds to look at some unknown module taking no\n-        //   attrs from either the impl or the fn a, and then finally to the root\n-        //   module\n-        //\n-        // It should find the attribute on the trait, but it *doesn't even see\n-        // the trait* as far as I can tell.\n-\n-        check_diagnostics(\n-            r#\"\n-trait T { fn a(); }\n-struct U {}\n-impl T for U {\n-    fn a() {\n-        // this comes out of bitflags, mostly\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            const HiImAlsoBad: u8 = 2;\n-            #[inline]\n-            fn Dirty(&self) -> bool {\n-                false\n-            }\n-        }\n-\n-    }\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn bug_traits_arent_checked() {\n-        // FIXME: Traits and functions in traits aren't currently checked by\n-        // r-a, even though rustc will complain about them.\n-        check_diagnostics(\n-            r#\"\n-trait BAD_TRAIT {\n-    // ^^^^^^^^^ Trait `BAD_TRAIT` should have CamelCase name, e.g. `BadTrait`\n-    fn BAD_FUNCTION();\n-    // ^^^^^^^^^^^^ Function `BAD_FUNCTION` should have snake_case name, e.g. `bad_function`\n-    fn BadFunction();\n-    // ^^^^^^^^^^^^ Function `BadFunction` should have snake_case name, e.g. `bad_function`\n-}\n-    \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn ignores_extern_items() {\n-        cov_mark::check!(extern_func_incorrect_case_ignored);\n-        cov_mark::check!(extern_static_incorrect_case_ignored);\n-        check_diagnostics(\n-            r#\"\n-extern {\n-    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n-    pub static SomeStatic: u8 = 10;\n-}\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn infinite_loop_inner_items() {\n-        check_diagnostics(\n-            r#\"\n-fn qualify() {\n-    mod foo {\n-        use super::*;\n-    }\n-}\n-            \"#,\n-        )\n-    }\n-\n-    #[test] // Issue #8809.\n-    fn parenthesized_parameter() {\n-        check_diagnostics(r#\"fn f((O): _) {}\"#)\n-    }\n-}"}, {"sha": "d763dca93fd1ebcdfc445caeb373f0799e5f6297", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc30c5ccbeba2a102922da497809dd3f812544c4/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc30c5ccbeba2a102922da497809dd3f812544c4/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=fc30c5ccbeba2a102922da497809dd3f812544c4", "patch": "@@ -1,24 +0,0 @@\n-//! Provides a way to attach fixes to the diagnostics.\n-//! The same module also has all curret custom fixes for the diagnostics implemented.\n-\n-use hir::{diagnostics::Diagnostic, Semantics};\n-use ide_assists::AssistResolveStrategy;\n-use ide_db::RootDatabase;\n-\n-use crate::Assist;\n-\n-/// A [Diagnostic] that potentially has some fixes available.\n-///\n-/// [Diagnostic]: hir::diagnostics::Diagnostic\n-pub(crate) trait DiagnosticWithFixes: Diagnostic {\n-    /// `resolve` determines if the diagnostic should fill in the `edit` field\n-    /// of the assist.\n-    ///\n-    /// If `resolve` is false, the edit will be computed later, on demand, and\n-    /// can be omitted.\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>>;\n-}"}, {"sha": "83239440042a2347cda9490839912239a45b13f7", "filename": "crates/ide/src/diagnostics/incorrect_case.rs", "status": "modified", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/crates%2Fide%2Fsrc%2Fdiagnostics%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/crates%2Fide%2Fsrc%2Fdiagnostics%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fincorrect_case.rs?ref=3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "patch": "@@ -163,4 +163,326 @@ impl TestStruct {\n \n         check_fix(input, expected);\n     }\n+\n+    #[test]\n+    fn incorrect_function_name() {\n+        check_diagnostics(\n+            r#\"\n+fn NonSnakeCaseName() {}\n+// ^^^^^^^^^^^^^^^^ Function `NonSnakeCaseName` should have snake_case name, e.g. `non_snake_case_name`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_function_params() {\n+        check_diagnostics(\n+            r#\"\n+fn foo(SomeParam: u8) {}\n+    // ^^^^^^^^^ Parameter `SomeParam` should have snake_case name, e.g. `some_param`\n+\n+fn foo2(ok_param: &str, CAPS_PARAM: u8) {}\n+                     // ^^^^^^^^^^ Parameter `CAPS_PARAM` should have snake_case name, e.g. `caps_param`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_variable_names() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let SOME_VALUE = 10;\n+     // ^^^^^^^^^^ Variable `SOME_VALUE` should have snake_case name, e.g. `some_value`\n+    let AnotherValue = 20;\n+     // ^^^^^^^^^^^^ Variable `AnotherValue` should have snake_case name, e.g. `another_value`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_names() {\n+        check_diagnostics(\n+            r#\"\n+struct non_camel_case_name {}\n+    // ^^^^^^^^^^^^^^^^^^^ Structure `non_camel_case_name` should have CamelCase name, e.g. `NonCamelCaseName`\n+\n+struct SCREAMING_CASE {}\n+    // ^^^^^^^^^^^^^^ Structure `SCREAMING_CASE` should have CamelCase name, e.g. `ScreamingCase`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_camel_cased_acronyms_in_struct_name() {\n+        check_diagnostics(\n+            r#\"\n+struct AABB {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_struct_field() {\n+        check_diagnostics(\n+            r#\"\n+struct SomeStruct { SomeField: u8 }\n+                 // ^^^^^^^^^ Field `SomeField` should have snake_case name, e.g. `some_field`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_names() {\n+        check_diagnostics(\n+            r#\"\n+enum some_enum { Val(u8) }\n+  // ^^^^^^^^^ Enum `some_enum` should have CamelCase name, e.g. `SomeEnum`\n+\n+enum SOME_ENUM {}\n+  // ^^^^^^^^^ Enum `SOME_ENUM` should have CamelCase name, e.g. `SomeEnum`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_camel_cased_acronyms_in_enum_name() {\n+        check_diagnostics(\n+            r#\"\n+enum AABB {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_enum_variant_name() {\n+        check_diagnostics(\n+            r#\"\n+enum SomeEnum { SOME_VARIANT(u8) }\n+             // ^^^^^^^^^^^^ Variant `SOME_VARIANT` should have CamelCase name, e.g. `SomeVariant`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_const_name() {\n+        check_diagnostics(\n+            r#\"\n+const some_weird_const: u8 = 10;\n+   // ^^^^^^^^^^^^^^^^ Constant `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn incorrect_static_name() {\n+        check_diagnostics(\n+            r#\"\n+static some_weird_const: u8 = 10;\n+    // ^^^^^^^^^^^^^^^^ Static variable `some_weird_const` should have UPPER_SNAKE_CASE name, e.g. `SOME_WEIRD_CONST`\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fn_inside_impl_struct() {\n+        check_diagnostics(\n+            r#\"\n+struct someStruct;\n+    // ^^^^^^^^^^ Structure `someStruct` should have CamelCase name, e.g. `SomeStruct`\n+\n+impl someStruct {\n+    fn SomeFunc(&self) {\n+    // ^^^^^^^^ Function `SomeFunc` should have snake_case name, e.g. `some_func`\n+        let WHY_VAR_IS_CAPS = 10;\n+         // ^^^^^^^^^^^^^^^ Variable `WHY_VAR_IS_CAPS` should have snake_case name, e.g. `why_var_is_caps`\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_for_enum_varinats() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        None => (),\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn non_let_bind() {\n+        check_diagnostics(\n+            r#\"\n+enum Option { Some, None }\n+\n+fn main() {\n+    match Option::None {\n+        SOME_VAR @ None => (),\n+     // ^^^^^^^^ Variable `SOME_VAR` should have snake_case name, e.g. `some_var`\n+        Some => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_attributes_crate_attr() {\n+        check_diagnostics(\n+            r#\"\n+#![allow(non_snake_case)]\n+\n+mod F {\n+    fn CheckItWorksWithCrateAttr(BAD_NAME_HI: u8) {}\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn bug_trait_inside_fn() {\n+        // FIXME:\n+        // This is broken, and in fact, should not even be looked at by this\n+        // lint in the first place. There's weird stuff going on in the\n+        // collection phase.\n+        // It's currently being brought in by:\n+        // * validate_func on `a` recursing into modules\n+        // * then it finds the trait and then the function while iterating\n+        //   through modules\n+        // * then validate_func is called on Dirty\n+        // * ... which then proceeds to look at some unknown module taking no\n+        //   attrs from either the impl or the fn a, and then finally to the root\n+        //   module\n+        //\n+        // It should find the attribute on the trait, but it *doesn't even see\n+        // the trait* as far as I can tell.\n+\n+        check_diagnostics(\n+            r#\"\n+trait T { fn a(); }\n+struct U {}\n+impl T for U {\n+    fn a() {\n+        // this comes out of bitflags, mostly\n+        #[allow(non_snake_case)]\n+        trait __BitFlags {\n+            const HiImAlsoBad: u8 = 2;\n+            #[inline]\n+            fn Dirty(&self) -> bool {\n+                false\n+            }\n+        }\n+\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn infinite_loop_inner_items() {\n+        check_diagnostics(\n+            r#\"\n+fn qualify() {\n+    mod foo {\n+        use super::*;\n+    }\n+}\n+            \"#,\n+        )\n+    }\n+\n+    #[test] // Issue #8809.\n+    fn parenthesized_parameter() {\n+        check_diagnostics(r#\"fn f((O): _) {}\"#)\n+    }\n+\n+    #[test]\n+    fn ignores_extern_items() {\n+        cov_mark::check!(extern_func_incorrect_case_ignored);\n+        cov_mark::check!(extern_static_incorrect_case_ignored);\n+        check_diagnostics(\n+            r#\"\n+extern {\n+    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n+    pub static SomeStatic: u8 = 10;\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn bug_traits_arent_checked() {\n+        // FIXME: Traits and functions in traits aren't currently checked by\n+        // r-a, even though rustc will complain about them.\n+        check_diagnostics(\n+            r#\"\n+trait BAD_TRAIT {\n+    // ^^^^^^^^^ Trait `BAD_TRAIT` should have CamelCase name, e.g. `BadTrait`\n+    fn BAD_FUNCTION();\n+    // ^^^^^^^^^^^^ Function `BAD_FUNCTION` should have snake_case name, e.g. `bad_function`\n+    fn BadFunction();\n+    // ^^^^^^^^^^^^ Function `BadFunction` should have snake_case name, e.g. `bad_function`\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn allow_attributes() {\n+        check_diagnostics(\n+            r#\"\n+#[allow(non_snake_case)]\n+fn NonSnakeCaseName(SOME_VAR: u8) -> u8{\n+    // cov_flags generated output from elsewhere in this file\n+    extern \"C\" {\n+        #[no_mangle]\n+        static lower_case: u8;\n+    }\n+\n+    let OtherVar = SOME_VAR + 1;\n+    OtherVar\n+}\n+\n+#[allow(nonstandard_style)]\n+mod CheckNonstandardStyle {\n+    fn HiImABadFnName() {}\n+}\n+\n+#[allow(bad_style)]\n+mod CheckBadStyle {\n+    fn HiImABadFnName() {}\n+}\n+\n+mod F {\n+    #![allow(non_snake_case)]\n+    fn CheckItWorksWithModAttr(BAD_NAME_HI: u8) {}\n+}\n+\n+#[allow(non_snake_case, non_camel_case_types)]\n+pub struct some_type {\n+    SOME_FIELD: u8,\n+    SomeField: u16,\n+}\n+\n+#[allow(non_upper_case_globals)]\n+pub const some_const: u8 = 10;\n+\n+#[allow(non_upper_case_globals)]\n+pub static SomeStatic: u8 = 10;\n+    \"#,\n+        );\n+    }\n }"}, {"sha": "a5b2e339978c13aa1ae334bf85a791d36f529e51", "filename": "crates/ide/src/diagnostics/unlinked_file.rs", "status": "modified", "additions": 190, "deletions": 69, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3478897f86cc1b3e3f83e9d4e7cedff41721fb04/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs?ref=3478897f86cc1b3e3f83e9d4e7cedff41721fb04", "patch": "@@ -1,104 +1,84 @@\n //! Diagnostic emitted for files that aren't part of any crate.\n \n-use hir::{\n-    db::DefDatabase,\n-    diagnostics::{Diagnostic, DiagnosticCode},\n-    InFile,\n-};\n-use ide_assists::AssistResolveStrategy;\n+use hir::db::DefDatabase;\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n     RootDatabase,\n };\n use syntax::{\n     ast::{self, ModuleItemOwner, NameOwner},\n-    AstNode, SyntaxNodePtr,\n+    AstNode, TextRange, TextSize,\n };\n use text_edit::TextEdit;\n \n use crate::{\n-    diagnostics::{fix, fixes::DiagnosticWithFixes},\n-    Assist,\n+    diagnostics::{fix, DiagnosticsContext},\n+    Assist, Diagnostic,\n };\n \n+#[derive(Debug)]\n+pub(crate) struct UnlinkedFile {\n+    pub(crate) file: FileId,\n+}\n+\n // Diagnostic: unlinked-file\n //\n // This diagnostic is shown for files that are not included in any crate, or files that are part of\n // crates rust-analyzer failed to discover. The file will not have IDE features available.\n-#[derive(Debug)]\n-pub(crate) struct UnlinkedFile {\n-    pub(crate) file_id: FileId,\n-    pub(crate) node: SyntaxNodePtr,\n+pub(super) fn unlinked_file(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Diagnostic {\n+    // Limit diagnostic to the first few characters in the file. This matches how VS Code\n+    // renders it with the full span, but on other editors, and is less invasive.\n+    let range = ctx.sema.db.parse(d.file).syntax_node().text_range();\n+    // FIXME: This is wrong if one of the first three characters is not ascii: `//\u042b`.\n+    let range = range.intersect(TextRange::up_to(TextSize::of(\"...\"))).unwrap_or(range);\n+\n+    Diagnostic::new(\"unlinked-file\", \"file not included in module tree\", range)\n+        .with_fixes(fixes(ctx, d))\n }\n \n-impl Diagnostic for UnlinkedFile {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"unlinked-file\")\n-    }\n+fn fixes(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Option<Vec<Assist>> {\n+    // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,\n+    // suggest that as a fix.\n \n-    fn message(&self) -> String {\n-        \"file not included in module tree\".to_string()\n-    }\n+    let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(d.file));\n+    let our_path = source_root.path_for_file(&d.file)?;\n+    let module_name = our_path.name_and_extension()?.0;\n \n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile::new(self.file_id.into(), self.node.clone())\n-    }\n+    // Candidates to look for:\n+    // - `mod.rs` in the same folder\n+    //   - we also check `main.rs` and `lib.rs`\n+    // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n+    let parent = our_path.parent()?;\n+    let mut paths = vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n \n-    fn as_any(&self) -> &(dyn std::any::Any + Send + 'static) {\n-        self\n+    // `submod/bla.rs` -> `submod.rs`\n+    if let Some(newmod) = (|| {\n+        let name = parent.name_and_extension()?.0;\n+        parent.parent()?.join(&format!(\"{}.rs\", name))\n+    })() {\n+        paths.push(newmod);\n     }\n-}\n \n-impl DiagnosticWithFixes for UnlinkedFile {\n-    fn fixes(\n-        &self,\n-        sema: &hir::Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,\n-        // suggest that as a fix.\n-\n-        let source_root = sema.db.source_root(sema.db.file_source_root(self.file_id));\n-        let our_path = source_root.path_for_file(&self.file_id)?;\n-        let module_name = our_path.name_and_extension()?.0;\n-\n-        // Candidates to look for:\n-        // - `mod.rs` in the same folder\n-        //   - we also check `main.rs` and `lib.rs`\n-        // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n-        let parent = our_path.parent()?;\n-        let mut paths =\n-            vec![parent.join(\"mod.rs\")?, parent.join(\"lib.rs\")?, parent.join(\"main.rs\")?];\n-\n-        // `submod/bla.rs` -> `submod.rs`\n-        if let Some(newmod) = (|| {\n-            let name = parent.name_and_extension()?.0;\n-            parent.parent()?.join(&format!(\"{}.rs\", name))\n-        })() {\n-            paths.push(newmod);\n-        }\n+    for path in &paths {\n+        if let Some(parent_id) = source_root.file_for_path(path) {\n+            for krate in ctx.sema.db.relevant_crates(*parent_id).iter() {\n+                let crate_def_map = ctx.sema.db.crate_def_map(*krate);\n+                for (_, module) in crate_def_map.modules() {\n+                    if module.origin.is_inline() {\n+                        // We don't handle inline `mod parent {}`s, they use different paths.\n+                        continue;\n+                    }\n \n-        for path in &paths {\n-            if let Some(parent_id) = source_root.file_for_path(path) {\n-                for krate in sema.db.relevant_crates(*parent_id).iter() {\n-                    let crate_def_map = sema.db.crate_def_map(*krate);\n-                    for (_, module) in crate_def_map.modules() {\n-                        if module.origin.is_inline() {\n-                            // We don't handle inline `mod parent {}`s, they use different paths.\n-                            continue;\n-                        }\n-\n-                        if module.origin.file_id() == Some(*parent_id) {\n-                            return make_fixes(sema.db, *parent_id, module_name, self.file_id);\n-                        }\n+                    if module.origin.file_id() == Some(*parent_id) {\n+                        return make_fixes(ctx.sema.db, *parent_id, module_name, d.file);\n                     }\n                 }\n             }\n         }\n-\n-        None\n     }\n+\n+    None\n }\n \n fn make_fixes(\n@@ -181,3 +161,144 @@ fn make_fixes(\n         ),\n     ])\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n+\n+    #[test]\n+    fn unlinked_file_prepend_first_item() {\n+        cov_mark::check!(unlinked_file_prepend_before_first_item);\n+        // Only tests the first one for `pub mod` since the rest are the same\n+        check_fixes(\n+            r#\"\n+//- /main.rs\n+fn f() {}\n+//- /foo.rs\n+$0\n+\"#,\n+            vec![\n+                r#\"\n+mod foo;\n+\n+fn f() {}\n+\"#,\n+                r#\"\n+pub mod foo;\n+\n+fn f() {}\n+\"#,\n+            ],\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_append_mod() {\n+        cov_mark::check!(unlinked_file_append_to_existing_mods);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+mod foo;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_in_empty_file() {\n+        cov_mark::check!(unlinked_file_empty_file);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_old_style_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod/mod.rs\n+// in mod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+// in mod.rs\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_new_style_mod() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_off() {\n+        cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);\n+        check_no_fix(\n+            r#\"\n+//- /main.rs\n+#[cfg(never)]\n+mod foo;\n+\n+//- /foo.rs\n+$0\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_on() {\n+        check_diagnostics(\n+            r#\"\n+//- /main.rs\n+#[cfg(not(never))]\n+mod foo;\n+\n+//- /foo.rs\n+\"#,\n+        );\n+    }\n+}"}]}