{"sha": "d322f990b04e3b598afd6a47c09a0277f73031aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjJmOTkwYjA0ZTNiNTk4YWZkNmE0N2MwOWEwMjc3ZjczMDMxYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-26T08:13:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-26T08:13:31Z"}, "message": "Auto merge of #32496 - Manishearth:rollup, r=Manishearth\n\nRollup of 11 pull requests\n\n- Successful merges: #32131, #32199, #32257, #32325, #32435, #32447, #32448, #32456, #32469, #32476, #32482\n- Failed merges: #32240", "tree": {"sha": "aa4db313962bedd35e235ad3913408133d0e0848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4db313962bedd35e235ad3913408133d0e0848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d322f990b04e3b598afd6a47c09a0277f73031aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d322f990b04e3b598afd6a47c09a0277f73031aa", "html_url": "https://github.com/rust-lang/rust/commit/d322f990b04e3b598afd6a47c09a0277f73031aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d322f990b04e3b598afd6a47c09a0277f73031aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d2d2be6c61c17da8027a72da91f87a0e2487f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2d2be6c61c17da8027a72da91f87a0e2487f74", "html_url": "https://github.com/rust-lang/rust/commit/8d2d2be6c61c17da8027a72da91f87a0e2487f74"}, {"sha": "6c10866b0241b6f37f1f5e30eaed3ac316b63ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c10866b0241b6f37f1f5e30eaed3ac316b63ea4", "html_url": "https://github.com/rust-lang/rust/commit/6c10866b0241b6f37f1f5e30eaed3ac316b63ea4"}], "stats": {"total": 1132, "additions": 825, "deletions": 307}, "files": [{"sha": "d5a5e2b47419f00ccd9fa4cf8fd4c579ffd7e6b9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1953,7 +1953,10 @@ impl StrExt for str {\n \n     #[inline]\n     fn is_char_boundary(&self, index: usize) -> bool {\n-        if index == self.len() { return true; }\n+        // 0 and len are always ok.\n+        // Test for 0 explicitly so that it can optimize out the check\n+        // easily and skip reading string data for that case.\n+        if index == 0 || index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n             Some(&b) => b < 128 || b >= 192,\n@@ -2026,6 +2029,7 @@ impl StrExt for str {\n         self.find(pat)\n     }\n \n+    #[inline]\n     fn split_at(&self, mid: usize) -> (&str, &str) {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(mid) {"}, {"sha": "9348c05d444613ee930062f449f99d28e53fb83f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1261,7 +1261,7 @@ compiled:\n fn foo<T: Index<u8>>(x: T){}\n \n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { ... }\n+trait Index<Idx> { /* ... */ }\n \n foo(true); // `bool` does not implement `Index<u8>`\n ```\n@@ -1291,7 +1291,7 @@ compiled:\n fn foo<T: Index<u8>>(x: T){}\n \n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { ... }\n+trait Index<Idx> { /* ... */ }\n \n foo(true); // `bool` does not implement `Index<u8>`\n ```\n@@ -1319,7 +1319,7 @@ compiled:\n fn foo<T: Index<u8>>(x: T){}\n \n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { ... }\n+trait Index<Idx> { /* ... */ }\n \n foo(true); // `bool` does not implement `Index<u8>`\n ```"}, {"sha": "879b894562092f6847cb8f45c5a02e37c46439f6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -136,6 +136,19 @@ declare_lint! {\n     \"type parameter default erroneously allowed in invalid location\"\n }\n \n+declare_lint! {\n+    pub ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+    Warn,\n+    \"floating-point constants cannot be used in patterns\"\n+}\n+\n+declare_lint! {\n+    pub ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n+    Deny,\n+    \"constants of struct or enum type can only be used in a pattern if \\\n+     the struct or enum has `#[derive(PartialEq, Eq)]`\"\n+}\n+\n declare_lint! {\n     pub MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n     Deny,\n@@ -193,6 +206,8 @@ impl LintPass for HardwiredLints {\n             PRIVATE_IN_PUBLIC,\n             INACCESSIBLE_EXTERN_CRATE,\n             INVALID_TYPE_PARAM_DEFAULT,\n+            ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+            ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n             MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n             CONST_ERR,\n             RAW_POINTER_DERIVE,"}, {"sha": "3414d509d953fd9c2ad18f42414491c42d652193", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -478,15 +478,24 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                     Some(Def::Const(did)) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n-                            const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n-\n-                                if let Some(ref mut renaming_map) = self.renaming_map {\n-                                    // Record any renamings we do here\n-                                    record_renamings(const_expr, &pat, renaming_map);\n+                            match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n+                                Ok(new_pat) => {\n+                                    if let Some(ref mut map) = self.renaming_map {\n+                                        // Record any renamings we do here\n+                                        record_renamings(const_expr, &pat, map);\n+                                    }\n+                                    new_pat\n                                 }\n-\n-                                new_pat\n-                            })\n+                                Err(def_id) => {\n+                                    self.failed = true;\n+                                    self.tcx.sess.span_err(\n+                                        pat.span,\n+                                        &format!(\"constants of the type `{}` \\\n+                                                  cannot be used in patterns\",\n+                                                 self.tcx.item_path_str(def_id)));\n+                                    pat\n+                                }\n+                            }\n                         } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,"}, {"sha": "c102822e8c126049579f254cc5e4bd4056a8e38d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -16,6 +16,7 @@ use self::EvalHint::*;\n \n use front::map as ast_map;\n use front::map::blocks::FnLikeNode;\n+use lint;\n use middle::cstore::{self, CrateStore, InlinedItem};\n use middle::{infer, subst, traits};\n use middle::def::Def;\n@@ -323,10 +324,41 @@ impl ConstVal {\n     }\n }\n \n-pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n+                         -> Result<P<hir::Pat>, DefId> {\n+    let pat_ty = tcx.expr_ty(expr);\n+    debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n+    match pat_ty.sty {\n+        ty::TyFloat(_) => {\n+            tcx.sess.add_lint(\n+                lint::builtin::ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+                pat_id,\n+                span,\n+                format!(\"floating point constants cannot be used in patterns\"));\n+        }\n+        ty::TyEnum(adt_def, _) |\n+        ty::TyStruct(adt_def, _) => {\n+            if !tcx.has_attr(adt_def.did, \"structural_match\") {\n+                tcx.sess.add_lint(\n+                    lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n+                    pat_id,\n+                    span,\n+                    format!(\"to use a constant of type `{}` \\\n+                             in a pattern, \\\n+                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                            tcx.item_path_str(adt_def.did),\n+                            tcx.item_path_str(adt_def.did)));\n+            }\n+        }\n+        _ => { }\n+    }\n+\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            PatKind::Tup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n+            PatKind::Tup(try!(exprs.iter()\n+                                  .map(|expr| const_expr_to_pat(tcx, &expr,\n+                                                                pat_id, span))\n+                                  .collect())),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -336,31 +368,41 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n             let path = match def.full_def() {\n                 Def::Struct(def_id) => def_to_path(tcx, def_id),\n                 Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n-                Def::Fn(..) => return P(hir::Pat {\n+                Def::Fn(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n                     span: span,\n-                }),\n+                })),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n+            let pats = try!(args.iter()\n+                                .map(|expr| const_expr_to_pat(tcx, &**expr,\n+                                                              pat_id, span))\n+                                .collect());\n             PatKind::TupleStruct(path, Some(pats))\n         }\n \n         hir::ExprStruct(ref path, ref fields, None) => {\n-            let field_pats = fields.iter().map(|field| codemap::Spanned {\n-                span: codemap::DUMMY_SP,\n-                node: hir::FieldPat {\n-                    name: field.name.node,\n-                    pat: const_expr_to_pat(tcx, &field.expr, span),\n-                    is_shorthand: false,\n-                },\n-            }).collect();\n+            let field_pats =\n+                try!(fields.iter()\n+                           .map(|field| Ok(codemap::Spanned {\n+                               span: codemap::DUMMY_SP,\n+                               node: hir::FieldPat {\n+                                   name: field.name.node,\n+                                   pat: try!(const_expr_to_pat(tcx, &field.expr,\n+                                                               pat_id, span)),\n+                                   is_shorthand: false,\n+                               },\n+                           }))\n+                           .collect());\n             PatKind::Struct(path.clone(), field_pats, false)\n         }\n \n         hir::ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n+            let pats = try!(exprs.iter()\n+                                 .map(|expr| const_expr_to_pat(tcx, &expr,\n+                                                               pat_id, span))\n+                                 .collect());\n             PatKind::Vec(pats, None, hir::HirVec::new())\n         }\n \n@@ -373,15 +415,15 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n                 Some(Def::AssociatedConst(def_id)) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n-                    return const_expr_to_pat(tcx, expr, span);\n+                    return const_expr_to_pat(tcx, expr, pat_id, span);\n                 },\n                 _ => unreachable!(),\n             }\n         }\n \n         _ => PatKind::Lit(P(expr.clone()))\n     };\n-    P(hir::Pat { id: expr.id, node: pat, span: span })\n+    Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n pub fn eval_const_expr(tcx: &TyCtxt, e: &Expr) -> ConstVal {"}, {"sha": "8c180ecb233b64a82a7e1297478d5591a48f5825", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -614,9 +614,15 @@ macro_rules! make_mir_visitor {\n \n             fn super_constant(&mut self,\n                               constant: & $($mutability)* Constant<'tcx>) {\n-                self.visit_span(& $($mutability)* constant.span);\n-                self.visit_ty(& $($mutability)* constant.ty);\n-                self.visit_literal(& $($mutability)* constant.literal);\n+                let Constant {\n+                    ref $($mutability)* span,\n+                    ref $($mutability)* ty,\n+                    ref $($mutability)* literal,\n+                } = *constant;\n+\n+                self.visit_span(span);\n+                self.visit_ty(ty);\n+                self.visit_literal(literal);\n             }\n \n             fn super_typed_const_val(&mut self,\n@@ -626,6 +632,7 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* ty,\n                     ref $($mutability)* value,\n                 } = *constant;\n+\n                 self.visit_span(span);\n                 self.visit_ty(ty);\n                 self.visit_const_usize(value);"}, {"sha": "19123f0f15ef4e5d512885c3c75cdfa5dd5d6244", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -252,7 +252,13 @@ impl Session {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n         match lints.get_mut(&id) {\n-            Some(arr) => { arr.push((lint_id, sp, msg)); return; }\n+            Some(arr) => {\n+                let tuple = (lint_id, sp, msg);\n+                if !arr.contains(&tuple) {\n+                    arr.push(tuple);\n+                }\n+                return;\n+            }\n             None => {}\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));"}, {"sha": "9ed21117cebca587e7e2dc4d32f05320987273cc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -179,6 +179,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(OVERLAPPING_INHERENT_IMPLS),\n             reference: \"issue #22889 <https://github.com/rust-lang/rust/issues/22889>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN),\n+            reference: \"RFC 1445 <https://github.com/rust-lang/rfcs/pull/1445>\",\n+        },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN),\n+            reference: \"RFC 1445 <https://github.com/rust-lang/rfcs/pull/1445>\",\n+        },\n         ]);\n \n     // We have one lint pass defined specially"}, {"sha": "a582a4622a6d0cf070adb52985116993012d6091", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -90,9 +90,16 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                         let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n                         match const_eval::lookup_const_by_id(self.cx.tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n-                                let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n-                                                                        pat.span);\n-                                return self.to_pattern(&pat);\n+                                match const_eval::const_expr_to_pat(self.cx.tcx,\n+                                                                    const_expr,\n+                                                                    pat.id,\n+                                                                    pat.span) {\n+                                    Ok(pat) =>\n+                                        return self.to_pattern(&pat),\n+                                    Err(_) =>\n+                                        self.cx.tcx.sess.span_bug(\n+                                            pat.span, \"illegal constant\"),\n+                                }\n                             }\n                             None => {\n                                 self.cx.tcx.sess.span_bug("}, {"sha": "6ea684c2f5c686b242db17d14ab338813180c03c", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 7, "deletions": 84, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -12,7 +12,8 @@\n //! We want to do this once just before trans, so trans does not have to take\n //! care erasing regions all over the place.\n \n-use rustc::middle::ty::{self, TyCtxt};\n+use rustc::middle::subst::Substs;\n+use rustc::middle::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, Pass};\n@@ -28,94 +29,16 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n             tcx: tcx\n         }\n     }\n-\n-    fn erase_regions_return_ty(&mut self, fn_output: &mut ty::FnOutput<'tcx>) {\n-        match *fn_output {\n-            ty::FnConverging(ref mut ty) => {\n-                *ty = self.tcx.erase_regions(ty);\n-            },\n-            ty::FnDiverging => {}\n-        }\n-    }\n-\n-    fn erase_regions_tys<'b, T>(&mut self, tys: T)\n-        where T: Iterator<Item = &'b mut ty::Ty<'tcx>>,\n-              'tcx: 'b\n-    {\n-        for ty in tys {\n-            *ty = self.tcx.erase_regions(ty);\n-        }\n-    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n-    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n-        self.erase_regions_return_ty(&mut mir.return_ty);\n-        self.erase_regions_tys(mir.var_decls.iter_mut().map(|d| &mut d.ty));\n-        self.erase_regions_tys(mir.arg_decls.iter_mut().map(|d| &mut d.ty));\n-        self.erase_regions_tys(mir.temp_decls.iter_mut().map(|d| &mut d.ty));\n-        self.super_mir(mir);\n-    }\n-\n-    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &mut Terminator<'tcx>) {\n-        match terminator.kind {\n-            TerminatorKind::Goto { .. } |\n-            TerminatorKind::Resume |\n-            TerminatorKind::Return |\n-            TerminatorKind::If { .. } |\n-            TerminatorKind::Switch { .. } |\n-            TerminatorKind::Drop { .. } |\n-            TerminatorKind::Call { .. } => {\n-                /* nothing to do */\n-            },\n-            TerminatorKind::SwitchInt { ref mut switch_ty, .. } => {\n-                *switch_ty = self.tcx.erase_regions(switch_ty);\n-            },\n-        }\n-        self.super_terminator(bb, terminator);\n-    }\n-\n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Use(_) |\n-            Rvalue::Len(_) |\n-            Rvalue::BinaryOp(_, _, _) |\n-            Rvalue::UnaryOp(_, _) |\n-            Rvalue::Slice { input: _, from_start: _, from_end: _ } |\n-            Rvalue::InlineAsm {..} => {},\n-\n-            Rvalue::Repeat(_, ref mut value) => value.ty = self.tcx.erase_regions(&value.ty),\n-            Rvalue::Ref(ref mut region, _, _) => *region = ty::ReStatic,\n-            Rvalue::Cast(_, _, ref mut ty) => *ty = self.tcx.erase_regions(ty),\n-            Rvalue::Box(ref mut ty) => *ty = self.tcx.erase_regions(ty),\n-\n-\n-            Rvalue::Aggregate(AggregateKind::Vec, _) |\n-            Rvalue::Aggregate(AggregateKind::Tuple, _) => {},\n-            Rvalue::Aggregate(AggregateKind::Adt(_, _, ref mut substs), _) =>\n-                *substs = self.tcx.mk_substs(self.tcx.erase_regions(*substs)),\n-            Rvalue::Aggregate(AggregateKind::Closure(def_id, ref mut closure_substs), _) => {\n-                let cloned = Box::new(closure_substs.clone());\n-                let ty = self.tcx.mk_closure_from_closure_substs(def_id, cloned);\n-                let erased = self.tcx.erase_regions(&ty);\n-                *closure_substs = match erased.sty {\n-                    ty::TyClosure(_, ref closure_substs) => &*closure_substs,\n-                    _ => unreachable!()\n-                };\n-            }\n-        }\n-        self.super_rvalue(rvalue);\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n+        let old_ty = *ty;\n+        *ty = self.tcx.erase_regions(&old_ty);\n     }\n \n-    fn visit_constant(&mut self, constant: &mut Constant<'tcx>) {\n-        constant.ty = self.tcx.erase_regions(&constant.ty);\n-        match constant.literal {\n-            Literal::Item { ref mut substs, .. } => {\n-                *substs = self.tcx.mk_substs(self.tcx.erase_regions(substs));\n-            }\n-            Literal::Value { .. } => { /* nothing to do */ }\n-        }\n-        self.super_constant(constant);\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n+        *substs = self.tcx.mk_substs(self.tcx.erase_regions(*substs));\n     }\n }\n "}, {"sha": "8a196768ae5168ea178c4c7f1f511b787474c0c7", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -205,51 +205,6 @@ about what constitutes an Item declaration and what does not:\n https://doc.rust-lang.org/reference.html#statements\n \"##,\n \n-E0317: r##\"\n-User-defined types or type parameters cannot shadow the primitive types.\n-This error indicates you tried to define a type, struct or enum with the same\n-name as an existing primitive type:\n-\n-```compile_fail\n-struct u8 {\n-    // ...\n-}\n-```\n-\n-To fix this, simply name it something else.\n-\n-Such an error may also occur if you define a type parameter which shadows a\n-primitive type. An example would be something like:\n-\n-```compile_fail\n-impl<u8> MyTrait for Option<u8> {\n-    // ...\n-}\n-```\n-\n-In such a case, if you meant for `u8` to be a generic type parameter (i.e. any\n-type can be used in its place), use something like `T` instead:\n-\n-```ignore\n-impl<T> MyTrait for Option<T> {\n-    // ...\n-}\n-```\n-\n-On the other hand, if you wished to refer to the specific type `u8`, remove it\n-from the type parameter list:\n-\n-```ignore\n-impl MyTrait for Option<u8> {\n-    // ...\n-}\n-\n-See the Types section of the reference for more information about the primitive\n-types:\n-\n-https://doc.rust-lang.org/reference.html#types\n-\"##,\n-\n E0364: r##\"\n Private items cannot be publicly re-exported.  This error indicates that you\n attempted to `pub use` a type or value that was not itself public."}, {"sha": "ab1d708f952ef02f57c6956746805575391abe81", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 30, "deletions": 55, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1619,15 +1619,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         intravisit::walk_crate(self, krate);\n     }\n \n-    fn check_if_primitive_type_name(&self, name: Name, span: Span) {\n-        if let Some(_) = self.primitive_type_table.primitive_types.get(&name) {\n-            span_err!(self.session,\n-                      span,\n-                      E0317,\n-                      \"user-defined types or type parameters cannot shadow the primitive types\");\n-        }\n-    }\n-\n     fn resolve_item(&mut self, item: &Item) {\n         let name = item.name;\n \n@@ -1637,8 +1628,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemEnum(_, ref generics) |\n             ItemTy(_, ref generics) |\n             ItemStruct(_, ref generics) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n                 self.with_type_parameter_rib(HasTypeParameters(generics, TypeSpace, ItemRibKind),\n                                              |this| intravisit::walk_item(this, item));\n             }\n@@ -1659,8 +1648,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n-                self.check_if_primitive_type_name(name, item.span);\n-\n                 // Create a new rib for the trait-wide type parameters.\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                TypeSpace,\n@@ -1695,8 +1682,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n-                                    this.check_if_primitive_type_name(trait_item.name,\n-                                                                      trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n                                         intravisit::walk_trait_item(this, trait_item)\n                                     });\n@@ -1720,28 +1705,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemUse(ref view_path) => {\n-                // check for imports shadowing primitive types\n-                let check_rename = |this: &Self, id, name| {\n-                    match this.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                        Some(Def::Enum(..)) | Some(Def::TyAlias(..)) | Some(Def::Struct(..)) |\n-                        Some(Def::Trait(..)) | None => {\n-                            this.check_if_primitive_type_name(name, item.span);\n-                        }\n-                        _ => {}\n-                    }\n-                };\n-\n                 match view_path.node {\n-                    hir::ViewPathSimple(name, _) => {\n-                        check_rename(self, item.id, name);\n-                    }\n                     hir::ViewPathList(ref prefix, ref items) => {\n-                        for item in items {\n-                            if let Some(name) = item.node.rename() {\n-                                check_rename(self, item.node.id(), name);\n-                            }\n-                        }\n-\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n                             match self.resolve_crate_relative_path(prefix.span,\n@@ -1922,9 +1887,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_generics(&mut self, generics: &Generics) {\n-        for type_parameter in generics.ty_params.iter() {\n-            self.check_if_primitive_type_name(type_parameter.name, type_parameter.span);\n-        }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n                 &hir::WherePredicate::BoundPredicate(_) |\n@@ -2658,15 +2620,37 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Try to find a path to an item in a module.\n         let last_ident = segments.last().unwrap().identifier;\n-        if segments.len() <= 1 {\n-            let unqualified_def = self.resolve_identifier(last_ident, namespace, true);\n-            return unqualified_def.and_then(|def| self.adjust_local_def(def, span))\n-                                  .map(|def| {\n-                                      PathResolution::new(def, path_depth)\n-                                  });\n-        }\n+        // Resolve a single identifier with fallback to primitive types\n+        let resolve_identifier_with_fallback = |this: &mut Self, record_used| {\n+            let def = this.resolve_identifier(last_ident, namespace, record_used);\n+            match def {\n+                None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n+                    this.primitive_type_table\n+                        .primitive_types\n+                        .get(&last_ident.unhygienic_name)\n+                        .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n+                _ => def\n+            }\n+        };\n \n-        let unqualified_def = self.resolve_identifier(last_ident, namespace, false);\n+        if segments.len() == 1 {\n+            // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n+            // don't report an error right away, but try to fallback to a primitive type.\n+            // So, we are still able to successfully resolve something like\n+            //\n+            // use std::u8; // bring module u8 in scope\n+            // fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            //     u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+            //                     // not to non-existent std::u8::max_value\n+            // }\n+            //\n+            // Such behavior is required for backward compatibility.\n+            // The same fallback is used when `a` resolves to nothing.\n+            let unqualified_def = resolve_identifier_with_fallback(self, true);\n+            return unqualified_def.and_then(|def| self.adjust_local_def(def, span)).map(mk_res);\n+        }\n+\n+        let unqualified_def = resolve_identifier_with_fallback(self, false);\n         let def = self.resolve_module_relative_path(span, segments, namespace);\n         match (def, unqualified_def) {\n             (Some(d), Some(ref ud)) if d == ud.def => {\n@@ -2692,15 +2676,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n-        // First, check to see whether the name is a primitive type.\n-        if namespace == TypeNS {\n-            if let Some(&prim_ty) = self.primitive_type_table\n-                                        .primitive_types\n-                                        .get(&identifier.unhygienic_name) {\n-                return Some(LocalDef::from_def(Def::PrimTy(prim_ty)));\n-            }\n-        }\n-\n         self.resolve_identifier_in_local_ribs(identifier, namespace, record_used)\n     }\n "}, {"sha": "bd556c0f2ebf60f67ea659c52431f2bc0fd3cdc9", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -80,6 +80,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     mir_map: &'a MirMap<'tcx>,\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n+    available_monomorphizations: RefCell<FnvHashSet<String>>,\n     available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n     use_dll_storage_attrs: bool,\n \n@@ -105,7 +106,6 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<usize>>,\n-    available_monomorphizations: RefCell<FnvHashSet<String>>,\n     /// Cache generated vtables\n     vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n@@ -357,6 +357,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             },\n             check_overflow: check_overflow,\n             check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n+            available_monomorphizations: RefCell::new(FnvHashSet()),\n             available_drop_glues: RefCell::new(FnvHashMap()),\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashMap()),\n@@ -474,7 +475,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 external_srcs: RefCell::new(NodeMap()),\n                 instances: RefCell::new(FnvHashMap()),\n                 monomorphizing: RefCell::new(DefIdMap()),\n-                available_monomorphizations: RefCell::new(FnvHashSet()),\n                 vtables: RefCell::new(FnvHashMap()),\n                 const_cstr_cache: RefCell::new(FnvHashMap()),\n                 const_unsized: RefCell::new(FnvHashMap()),\n@@ -723,7 +723,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn available_monomorphizations<'a>(&'a self) -> &'a RefCell<FnvHashSet<String>> {\n-        &self.local.available_monomorphizations\n+        &self.shared.available_monomorphizations\n     }\n \n     pub fn available_drop_glues(&self) -> &RefCell<FnvHashMap<DropGlueKind<'tcx>, String>> {"}, {"sha": "6fc26bb7eed71fd48940bce6fee5e0858c01446c", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1152,9 +1152,10 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f32 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n+        if self == NEG_INFINITY {\n+            NEG_INFINITY\n+        } else {\n+            (self + ((self * self) + 1.0).sqrt()).ln()\n         }\n     }\n "}, {"sha": "93e5969a275c3f9855fdfd7f1a102c41c6d5d0de", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1023,9 +1023,10 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f64 {\n-        match self {\n-            NEG_INFINITY => NEG_INFINITY,\n-            x => (x + ((x * x) + 1.0).sqrt()).ln(),\n+        if self == NEG_INFINITY {\n+            NEG_INFINITY\n+        } else {\n+            (self + ((self * self) + 1.0).sqrt()).ln()\n         }\n     }\n "}, {"sha": "c1ef60852a7c856e314dea260471ad0c8dc731c6", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -339,7 +339,7 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn status(&mut self) -> io::Result<ExitStatus> {\n-        self.inner.spawn(imp::Stdio::Inherit, false).map(Child::from_inner)\n+        self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n                   .and_then(|mut p| p.wait())\n     }\n }"}, {"sha": "6d966a0f6944c681cbd387ab2a346a5754ef8ad8", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -13,7 +13,7 @@ use prelude::v1::*;\n use alloc::boxed::FnBox;\n use cmp;\n #[cfg(not(any(target_env = \"newlib\", target_os = \"solaris\")))]\n-use ffi::CString;\n+use ffi::CStr;\n use io;\n use libc;\n use mem;\n@@ -84,48 +84,43 @@ impl Thread {\n     #[cfg(any(target_os = \"linux\",\n               target_os = \"android\",\n               target_os = \"emscripten\"))]\n-    pub fn set_name(name: &str) {\n+    pub fn set_name(name: &CStr) {\n         const PR_SET_NAME: libc::c_int = 15;\n-        let cname = CString::new(name).unwrap_or_else(|_| {\n-            panic!(\"thread name may not contain interior null bytes\")\n-        });\n         // pthread wrapper only appeared in glibc 2.12, so we use syscall\n         // directly.\n         unsafe {\n-            libc::prctl(PR_SET_NAME, cname.as_ptr() as libc::c_ulong, 0, 0, 0);\n+            libc::prctl(PR_SET_NAME, name.as_ptr() as libc::c_ulong, 0, 0, 0);\n         }\n     }\n \n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\",\n               target_os = \"bitrig\",\n               target_os = \"openbsd\"))]\n-    pub fn set_name(name: &str) {\n-        let cname = CString::new(name).unwrap();\n+    pub fn set_name(name: &CStr) {\n         unsafe {\n-            libc::pthread_set_name_np(libc::pthread_self(), cname.as_ptr());\n+            libc::pthread_set_name_np(libc::pthread_self(), name.as_ptr());\n         }\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    pub fn set_name(name: &str) {\n-        let cname = CString::new(name).unwrap();\n+    pub fn set_name(name: &CStr) {\n         unsafe {\n-            libc::pthread_setname_np(cname.as_ptr());\n+            libc::pthread_setname_np(name.as_ptr());\n         }\n     }\n \n     #[cfg(target_os = \"netbsd\")]\n-    pub fn set_name(name: &str) {\n+    pub fn set_name(name: &CStr) {\n+        use ffi::CString;\n         let cname = CString::new(&b\"%s\"[..]).unwrap();\n-        let carg = CString::new(name).unwrap();\n         unsafe {\n             libc::pthread_setname_np(libc::pthread_self(), cname.as_ptr(),\n-                                     carg.as_ptr() as *mut libc::c_void);\n+                                     name.as_ptr() as *mut libc::c_void);\n         }\n     }\n     #[cfg(any(target_env = \"newlib\", target_os = \"solaris\"))]\n-    pub fn set_name(_name: &str) {\n+    pub fn set_name(_name: &CStr) {\n         // Newlib and Illumos has no way to set a thread name.\n     }\n "}, {"sha": "0383e92c79ec7b24a2c1d0c8ff4575e404c4ac1a", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n \n use alloc::boxed::FnBox;\n use io;\n+use ffi::CStr;\n use mem;\n use libc::c_void;\n use ptr;\n@@ -54,7 +55,7 @@ impl Thread {\n         }\n     }\n \n-    pub fn set_name(_name: &str) {\n+    pub fn set_name(_name: &CStr) {\n         // Windows threads are nameless\n         // The names in MSVC debugger are obtained using a \"magic\" exception,\n         // which requires a use of MS C++ extensions."}, {"sha": "b3549dc12645aec854e0c0ec3d4d1b90ede910e9", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -166,6 +166,8 @@ use any::Any;\n use cell::UnsafeCell;\n use fmt;\n use io;\n+use str;\n+use ffi::{CStr, CString};\n use sync::{Mutex, Condvar, Arc};\n use sys::thread as imp;\n use sys_common::thread_info;\n@@ -267,7 +269,7 @@ impl Builder {\n         let their_packet = my_packet.clone();\n \n         let main = move || {\n-            if let Some(name) = their_thread.name() {\n+            if let Some(name) = their_thread.cname() {\n                 imp::Thread::set_name(name);\n             }\n             unsafe {\n@@ -450,7 +452,7 @@ pub fn park_timeout(dur: Duration) {\n \n /// The internal representation of a `Thread` handle\n struct Inner {\n-    name: Option<String>,\n+    name: Option<CString>,      // Guaranteed to be UTF-8\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n     cvar: Condvar,\n }\n@@ -465,9 +467,12 @@ pub struct Thread {\n impl Thread {\n     // Used only internally to construct a thread object without spawning\n     fn new(name: Option<String>) -> Thread {\n+        let cname = name.map(|n| CString::new(n).unwrap_or_else(|_| {\n+            panic!(\"thread name may not contain interior null bytes\")\n+        }));\n         Thread {\n             inner: Arc::new(Inner {\n-                name: name,\n+                name: cname,\n                 lock: Mutex::new(false),\n                 cvar: Condvar::new(),\n             })\n@@ -489,6 +494,10 @@ impl Thread {\n     /// Gets the thread's name.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn name(&self) -> Option<&str> {\n+        self.cname().map(|s| unsafe { str::from_utf8_unchecked(s.to_bytes()) } )\n+    }\n+\n+    fn cname(&self) -> Option<&CStr> {\n         self.inner.name.as_ref().map(|s| &**s)\n     }\n }\n@@ -622,6 +631,12 @@ mod tests {\n         }).unwrap().join().unwrap();\n     }\n \n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_named_thread() {\n+        let _ = Builder::new().name(\"ada l\\0velace\".to_string()).spawn(|| {});\n+    }\n+\n     #[test]\n     fn test_run_basic() {\n         let (tx, rx) = channel();"}, {"sha": "945eb6a42e5a7854ee6555b979934fe814081248", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ops::{Add, Sub, Mul, Div};\n+use ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n@@ -105,6 +105,13 @@ impl Add for Duration {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl AddAssign for Duration {\n+    fn add_assign(&mut self, rhs: Duration) {\n+        *self = *self + rhs;\n+    }\n+}\n+\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n impl Sub for Duration {\n     type Output = Duration;\n@@ -124,6 +131,13 @@ impl Sub for Duration {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl SubAssign for Duration {\n+    fn sub_assign(&mut self, rhs: Duration) {\n+        *self = *self - rhs;\n+    }\n+}\n+\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n impl Mul<u32> for Duration {\n     type Output = Duration;\n@@ -141,6 +155,13 @@ impl Mul<u32> for Duration {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl MulAssign<u32> for Duration {\n+    fn mul_assign(&mut self, rhs: u32) {\n+        *self = *self * rhs;\n+    }\n+}\n+\n #[stable(feature = \"duration\", since = \"1.3.0\")]\n impl Div<u32> for Duration {\n     type Output = Duration;\n@@ -155,6 +176,13 @@ impl Div<u32> for Duration {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl DivAssign<u32> for Duration {\n+    fn div_assign(&mut self, rhs: u32) {\n+        *self = *self / rhs;\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::Duration;"}, {"sha": "bc50b0d3a7066c8e44e313de078bc15fab1769cc", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -24,7 +24,7 @@\n \n use error::Error;\n use fmt;\n-use ops::{Add, Sub};\n+use ops::{Add, Sub, AddAssign, SubAssign};\n use sys::time;\n use sys_common::FromInner;\n \n@@ -172,6 +172,13 @@ impl Add<Duration> for Instant {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl AddAssign<Duration> for Instant {\n+    fn add_assign(&mut self, other: Duration) {\n+        *self = *self + other;\n+    }\n+}\n+\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n impl Sub<Duration> for Instant {\n     type Output = Instant;\n@@ -181,6 +188,13 @@ impl Sub<Duration> for Instant {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl SubAssign<Duration> for Instant {\n+    fn sub_assign(&mut self, other: Duration) {\n+        *self = *self - other;\n+    }\n+}\n+\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n impl Sub<Instant> for Instant {\n     type Output = Duration;\n@@ -254,6 +268,13 @@ impl Add<Duration> for SystemTime {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl AddAssign<Duration> for SystemTime {\n+    fn add_assign(&mut self, other: Duration) {\n+        *self = *self + other;\n+    }\n+}\n+\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n impl Sub<Duration> for SystemTime {\n     type Output = SystemTime;\n@@ -263,6 +284,13 @@ impl Sub<Duration> for SystemTime {\n     }\n }\n \n+#[stable(feature = \"time_augmented_assignment\", since = \"1.9.0\")]\n+impl SubAssign<Duration> for SystemTime {\n+    fn sub_assign(&mut self, other: Duration) {\n+        *self = *self - other;\n+    }\n+}\n+\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n impl fmt::Debug for SystemTime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "f771ee95bd1215696ca6557771290ca1a372755d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1304,6 +1304,31 @@ impl CodeMap {\n         return a;\n     }\n \n+    /// Check if the backtrace `subtrace` contains `suptrace` as a prefix.\n+    pub fn more_specific_trace(&self,\n+                              mut subtrace: ExpnId,\n+                              suptrace: ExpnId)\n+                              -> bool {\n+        loop {\n+            if subtrace == suptrace {\n+                return true;\n+            }\n+\n+            let stop = self.with_expn_info(subtrace, |opt_expn_info| {\n+                if let Some(expn_info) = opt_expn_info {\n+                    subtrace = expn_info.call_site.expn_id;\n+                    false\n+                } else {\n+                    true\n+                }\n+            });\n+\n+            if stop {\n+                return false;\n+            }\n+        }\n+    }\n+\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);"}, {"sha": "8550617560df3ed7840259c812b60b6a3c2c9649", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -33,7 +33,7 @@ use visit::Visitor;\n use std_inject;\n \n use std::collections::HashSet;\n-\n+use std::env;\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n@@ -1275,11 +1275,41 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n }\n \n fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n-    /* this discards information in the case of macro-defining macros */\n-    Span {\n-        lo: sp.lo,\n-        hi: sp.hi,\n-        expn_id: cx.backtrace(),\n+    debug!(\"new_span(sp={:?})\", sp);\n+\n+    if cx.codemap().more_specific_trace(sp.expn_id, cx.backtrace()) {\n+        // If the span we are looking at has a backtrace that has more\n+        // detail than our current backtrace, then we keep that\n+        // backtrace.  Honestly, I have no idea if this makes sense,\n+        // because I have no idea why we are stripping the backtrace\n+        // below. But the reason I made this change is because, in\n+        // deriving, we were generating attributes with a specific\n+        // backtrace, which was essential for `#[structural_match]` to\n+        // be properly supported, but these backtraces were being\n+        // stripped and replaced with a null backtrace. Sort of\n+        // unclear why this is the case. --nmatsakis\n+        debug!(\"new_span: keeping trace from {:?} because it is more specific\",\n+               sp.expn_id);\n+        sp\n+    } else {\n+        // This discards information in the case of macro-defining macros.\n+        //\n+        // The comment above was originally added in\n+        // b7ec2488ff2f29681fe28691d20fd2c260a9e454 in Feb 2012. I\n+        // *THINK* the reason we are doing this is because we want to\n+        // replace the backtrace of the macro contents with the\n+        // backtrace that contains the macro use. But it's pretty\n+        // unclear to me. --nmatsakis\n+        let sp1 = Span {\n+            lo: sp.lo,\n+            hi: sp.hi,\n+            expn_id: cx.backtrace(),\n+        };\n+        debug!(\"new_span({:?}) = {:?}\", sp, sp1);\n+        if sp.expn_id.into_u32() == 0 && env::var_os(\"NDM\").is_some() {\n+            panic!(\"NDM\");\n+        }\n+        sp1\n     }\n }\n "}, {"sha": "cd88aaa459750aea937ae4395ce382ef1da09387", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -109,6 +109,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     // to bootstrap fix for #5723.\n     (\"issue_5723_bootstrap\", \"1.0.0\", None, Accepted),\n \n+    (\"structural_match\", \"1.8.0\", Some(31434), Active),\n+\n     // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n     (\"opt_out_copy\", \"1.0.0\", None, Removed),\n \n@@ -304,6 +306,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"link_args\", Normal, Ungated),\n     (\"macro_escape\", Normal, Ungated),\n \n+    // RFC #1445.\n+    (\"structural_match\", Whitelisted, Gated(\"structural_match\",\n+                                            \"the semantics of constant patterns is \\\n+                                             not yet settled\")),\n+\n     // Not used any more, but we can't feature gate it\n     (\"no_stack_check\", Normal, Ungated),\n \n@@ -682,7 +689,7 @@ impl<'a> Context<'a> {\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         let has_feature = self.has_feature(feature);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", feature, span, has_feature);\n-        if !has_feature {\n+        if !has_feature && !self.cm.span_allows_unstable(span) {\n             emit_feature_err(self.span_handler, feature, span, GateIssue::Language, explain);\n         }\n     }"}, {"sha": "82715f263c96db0a58d91ac08447389f3f095841", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -268,8 +268,8 @@ pub struct Parser<'a> {\n     /// Used to determine the path to externally loaded source files\n     pub filename: Option<String>,\n     pub mod_path_stack: Vec<InternedString>,\n-    /// Stack of spans of open delimiters. Used for error message.\n-    pub open_braces: Vec<Span>,\n+    /// Stack of open delimiters and their spans. Used for error message.\n+    pub open_braces: Vec<(token::DelimToken, Span)>,\n     /// Flag if this parser \"owns\" the directory that it is currently parsing\n     /// in. This will affect how nested files are looked up.\n     pub owns_directory: bool,\n@@ -895,7 +895,7 @@ impl<'a> Parser<'a> {\n                                          sep: SeqSep,\n                                          f: F)\n                                          -> Vec<T>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>\n     {\n         self.parse_seq_to_before_tokens(&[ket], sep, f, |mut e| e.emit())\n     }\n@@ -2755,8 +2755,8 @@ impl<'a> Parser<'a> {\n                 let mut err: DiagnosticBuilder<'a> =\n                     self.diagnostic().struct_span_err(self.span,\n                                                       \"this file contains an un-closed delimiter\");\n-                for sp in &self.open_braces {\n-                    err.span_help(*sp, \"did you mean to close this delimiter?\");\n+                for &(_, sp) in &self.open_braces {\n+                    err.span_help(sp, \"did you mean to close this delimiter?\");\n                 }\n \n                 Err(err)\n@@ -2766,23 +2766,66 @@ impl<'a> Parser<'a> {\n                 let pre_span = self.span;\n \n                 // Parse the open delimiter.\n-                self.open_braces.push(self.span);\n+                self.open_braces.push((delim, self.span));\n                 let open_span = self.span;\n                 self.bump();\n \n-                // Parse the token trees within the delimiters\n-                let tts = self.parse_seq_to_before_end(&token::CloseDelim(delim),\n-                                                       SeqSep::none(),\n-                                                       |p| p.parse_token_tree());\n+                // Parse the token trees within the delimiters.\n+                // We stop at any delimiter so we can try to recover if the user\n+                // uses an incorrect delimiter.\n+                let tts = self.parse_seq_to_before_tokens(&[&token::CloseDelim(token::Brace),\n+                                                            &token::CloseDelim(token::Paren),\n+                                                            &token::CloseDelim(token::Bracket)],\n+                                                          SeqSep::none(),\n+                                                          |p| p.parse_token_tree(),\n+                                                          |mut e| e.emit());\n \n-                // Parse the close delimiter.\n                 let close_span = self.span;\n-                self.bump();\n-                self.open_braces.pop().unwrap();\n-\n                 // Expand to cover the entire delimited token tree\n                 let span = Span { hi: close_span.hi, ..pre_span };\n \n+                match self.token {\n+                    // Correct delmiter.\n+                    token::CloseDelim(d) if d == delim => {\n+                        self.open_braces.pop().unwrap();\n+\n+                        // Parse the close delimiter.\n+                        self.bump();\n+                    }\n+                    // Incorect delimiter.\n+                    token::CloseDelim(other) => {\n+                        let token_str = self.this_token_to_string();\n+                        let mut err = self.diagnostic().struct_span_err(self.span,\n+                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n+                        // This is a conservative error: only report the last unclosed delimiter.\n+                        // The previous unclosed delimiters could actually be closed! The parser\n+                        // just hasn't gotten to them yet.\n+                        if let Some(&(_, sp)) = self.open_braces.last() {\n+                            err.span_note(sp, \"unclosed delimiter\");\n+                        };\n+                        err.emit();\n+\n+                        self.open_braces.pop().unwrap();\n+\n+                        // If the incorrect delimter matches an earlier opening\n+                        // delimiter, then don't consume it (it can be used to\n+                        // close the earlier one)Otherwise, consume it.\n+                        // E.g., we try to recover from:\n+                        // fn foo() {\n+                        //     bar(baz(\n+                        // }  // Incorrect delimiter but matches the earlier `{`\n+                        if !self.open_braces.iter().any(|&(b, _)| b == other) {\n+                            self.bump();\n+                        }\n+                    }\n+                    token::Eof => {\n+                        // Silently recover, the EOF token will be seen again\n+                        // and an error emitted then. Thus we don't pop from\n+                        // self.open_braces here.\n+                    },\n+                    _ => unreachable!(),\n+                }\n+\n                 Ok(TokenTree::Delimited(span, Rc::new(Delimited {\n                     delim: delim,\n                     open_span: open_span,\n@@ -2798,16 +2841,11 @@ impl<'a> Parser<'a> {\n                 maybe_whole!(deref self, NtTT);\n                 match self.token {\n                     token::CloseDelim(_) => {\n+                        // An unexpected closing delimiter (i.e., there is no\n+                        // matching opening delimiter).\n                         let token_str = self.this_token_to_string();\n-                        let mut err = self.diagnostic().struct_span_err(self.span,\n-                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n-                        // This is a conservative error: only report the last unclosed delimiter.\n-                        // The previous unclosed delimiters could actually be closed! The parser\n-                        // just hasn't gotten to them yet.\n-                        if let Some(&sp) = self.open_braces.last() {\n-                            err.span_note(sp, \"unclosed delimiter\");\n-                        };\n-\n+                        let err = self.diagnostic().struct_span_err(self.span,\n+                            &format!(\"unexpected close delimiter: `{}`\", token_str));\n                         Err(err)\n                     },\n                     /* we ought to allow different depths of unquotation */\n@@ -3825,7 +3863,9 @@ impl<'a> Parser<'a> {\n     fn recover_stmt_(&mut self, break_on_semi: SemiColonMode) {\n         let mut brace_depth = 0;\n         let mut bracket_depth = 0;\n+        debug!(\"recover_stmt_ enter loop\");\n         loop {\n+            debug!(\"recover_stmt_ loop {:?}\", self.token);\n             match self.token {\n                 token::OpenDelim(token::DelimToken::Brace) => {\n                     brace_depth += 1;\n@@ -3837,6 +3877,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::CloseDelim(token::DelimToken::Brace) => {\n                     if brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n                         return;\n                     }\n                     brace_depth -= 1;\n@@ -3849,12 +3890,16 @@ impl<'a> Parser<'a> {\n                     }\n                     self.bump();\n                 }\n-                token::Eof => return,\n+                token::Eof => {\n+                    debug!(\"recover_stmt_ return - Eof\");\n+                    return;\n+                }\n                 token::Semi => {\n                     self.bump();\n                     if break_on_semi == SemiColonMode::Break &&\n                        brace_depth == 0 &&\n                        bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n                         return;\n                     }\n                 }\n@@ -4043,6 +4088,8 @@ impl<'a> Parser<'a> {\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n                 s\n+            } else if self.token == token::Eof {\n+                break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;"}, {"sha": "671f3e4a7e3302cf265464adb617a4096c77e840", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -10,4 +10,5 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n fmt_macros = { path = \"../libfmt_macros\" }\n+log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "1774167e8300007214d1d2bc56d9d9af25de9561", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -78,7 +78,10 @@ fn expand_derive(cx: &mut ExtCtxt,\n                  mitem: &MetaItem,\n                  annotatable: Annotatable)\n                  -> Annotatable {\n-    annotatable.map_item_or(|item| {\n+    debug!(\"expand_derive: span = {:?}\", span);\n+    debug!(\"expand_derive: mitem = {:?}\", mitem);\n+    debug!(\"expand_derive: annotatable input  = {:?}\", annotatable);\n+    let annot = annotatable.map_item_or(|item| {\n         item.map(|mut item| {\n             if mitem.value_str().is_some() {\n                 cx.span_err(mitem.span, \"unexpected value in `derive`\");\n@@ -89,6 +92,9 @@ fn expand_derive(cx: &mut ExtCtxt,\n                 cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n             }\n \n+            let mut found_partial_eq = false;\n+            let mut found_eq = false;\n+\n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n                     MetaItemKind::Word(ref tname) => tname,\n@@ -107,17 +113,64 @@ fn expand_derive(cx: &mut ExtCtxt,\n                     continue;\n                 }\n \n+                if &tname[..] == \"Eq\" {\n+                    found_eq = true;\n+                } else if &tname[..] == \"PartialEq\" {\n+                    found_partial_eq = true;\n+                }\n+\n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n                 item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n                     intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n             }\n \n+            // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n+            // `#[structural_match]` attribute.\n+            if found_partial_eq && found_eq {\n+                // This span is **very** sensitive and crucial to\n+                // getting the stability behavior we want. What we are\n+                // doing is marking `#[structural_match]` with the\n+                // span of the `#[deriving(...)]` attribute (the\n+                // entire attribute, not just the `PartialEq` or `Eq`\n+                // part), but with the current backtrace. The current\n+                // backtrace will contain a topmost entry that IS this\n+                // `#[deriving(...)]` attribute and with the\n+                // \"allow-unstable\" flag set to true.\n+                //\n+                // Note that we do NOT use the span of the `Eq`\n+                // text itself. You might think this is\n+                // equivalent, because the `Eq` appears within the\n+                // `#[deriving(Eq)]` attribute, and hence we would\n+                // inherit the \"allows unstable\" from the\n+                // backtrace.  But in fact this is not always the\n+                // case. The actual source text that led to\n+                // deriving can be `#[$attr]`, for example, where\n+                // `$attr == deriving(Eq)`. In that case, the\n+                // \"#[structural_match]\" would be considered to\n+                // originate not from the deriving call but from\n+                // text outside the deriving call, and hence would\n+                // be forbidden from using unstable\n+                // content.\n+                //\n+                // See tests src/run-pass/rfc1445 for\n+                // examples. --nmatsakis\n+                let span = Span { expn_id: cx.backtrace(), .. span };\n+                assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n+                debug!(\"inserting structural_match with span {:?}\", span);\n+                let structural_match = intern_and_get_ident(\"structural_match\");\n+                item.attrs.push(cx.attribute(span,\n+                                             cx.meta_word(span,\n+                                                          structural_match)));\n+            }\n+\n             item\n         })\n     }, |a| {\n         cx.span_err(span, \"`derive` can only be applied to items\");\n         a\n-    })\n+    });\n+    debug!(\"expand_derive: annotatable output = {:?}\", annot);\n+    annot\n }\n \n macro_rules! derive_traits {"}, {"sha": "f214ecdc3368dd4278ee4565b070b46c0bafb30c", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -24,6 +24,7 @@\n #![feature(str_char)]\n \n extern crate fmt_macros;\n+#[macro_use] extern crate log;\n #[macro_use]\n extern crate syntax;\n "}, {"sha": "eaccaf3cdbd27c6e4f51ba747555bd06d5c6b375", "filename": "src/test/compile-fail/issue-10636-2.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10636-2.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,11 +11,9 @@\n // FIXME(31528) we emit a bunch of silly errors here due to continuing past the\n // first one. This would be easy-ish to address by better recovery in tokenisation.\n \n-// compile-flags: -Z parse-only\n-\n-pub fn trace_option(option: Option<isize>) { //~ HELP did you mean to close this delimiter?\n+pub fn trace_option(option: Option<isize>) {\n     option.map(|some| 42; //~ NOTE: unclosed delimiter\n                           //~^ ERROR: expected one of\n+                          //~^^ ERROR: mismatched types\n } //~ ERROR: incorrect close delimiter\n //~^ ERROR: expected one of\n-//~ ERROR: this file contains an un-closed delimiter", "previous_filename": "src/test/parse-fail/issue-10636-2.rs"}, {"sha": "b6a04bee85d4faada3cd72a60121f4043e3b2474", "filename": "src/test/compile-fail/issue-31804.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31804.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that error recovery in the parser to an EOF does not give an infinite\n+// spew of errors.\n+\n+fn main() {\n+    let\n+} //~ ERROR unexpected token: `}`"}, {"sha": "f6b7e13c4f5e9328593e8bab6c99e8b233d8ffac", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -24,9 +24,13 @@ fn main() { //~ ERROR compilation successful\n         _ => {},\n     };\n     //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n+    //~| WARNING floating point constants cannot be used\n+    //~| WARNING this was previously accepted\n     match [x, 1.0] {\n         [NAN, _] => {},\n         _ => {},\n     };\n     //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n+    //~| WARNING floating point constants cannot be used\n+    //~| WARNING this was previously accepted\n }"}, {"sha": "1f2d7819e26d8abc91c4d85af257cf930f12da9e", "filename": "src/test/compile-fail/rfc1445/feature-gate.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Frfc1445%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Frfc1445%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Ffeature-gate.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that structural match is only permitted with a feature gate,\n+// and that if a feature gate is supplied, it permits the type to be\n+// used in a match.\n+\n+// revisions: with_gate no_gate\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+#![feature(rustc_attrs)]\n+#![cfg_attr(with_gate, feature(structural_match))]\n+\n+#[structural_match] //[no_gate]~ ERROR semantics of constant patterns is not yet settled\n+struct Foo {\n+    x: u32\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+#[rustc_error]\n+fn main() { //[with_gate]~ ERROR compilation successful\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "c573e3e8e28b27cb4d97e494cc5110051d493725", "filename": "src/test/compile-fail/rfc1445/match-forbidden-without-eq.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+\n+use std::f32;\n+\n+#[derive(PartialEq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+\n+    let x = 0.0;\n+    match x {\n+        f32::INFINITY => { }\n+        //~^ ERROR floating point constants cannot be used in patterns\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+}"}, {"sha": "029df08ebc37a99234834573c8572706f3d5d853", "filename": "src/test/compile-fail/rfc1445/match-requires-both-partialeq-and-eq.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![deny(future_incompatible)]\n+\n+#[derive(Eq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+impl PartialEq for Foo {\n+    fn eq(&self, _: &Foo) -> bool {\n+        false // ha ha sucker!\n+    }\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n+        //~| WARNING will become a hard error\n+        _ => { }\n+    }\n+}"}, {"sha": "ab429ab878073c02585aa91f7e87b0f2d56db446", "filename": "src/test/compile-fail/token-error-correct-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-2.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do some basic error correcton in the tokeniser (and don't ICE).\n+\n+fn main() {\n+    if foo { //~ NOTE: unclosed delimiter\n+    //~^ ERROR: unresolved name `foo`\n+    ) //~ ERROR: incorrect close delimiter: `)`\n+}"}, {"sha": "fe8c9f690139f65a3b72991504f571cc59bd3609", "filename": "src/test/compile-fail/token-error-correct-3.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct-3.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do some basic error correcton in the tokeniser (and don't spew\n+// too many bogus errors).\n+\n+pub mod raw {\n+    use std::{io, fs};\n+    use std::path::Path;\n+\n+    pub fn ensure_dir_exists<P: AsRef<Path>, F: FnOnce(&Path)>(path: P,\n+                                                               callback: F)\n+                                                               -> io::Result<bool> {\n+        if !is_directory(path.as_ref()) { //~ ERROR: unresolved name `is_directory`\n+            callback(path.as_ref();  //~ NOTE: unclosed delimiter\n+                     //~^ ERROR: expected one of\n+            fs::create_dir_all(path.as_ref()).map(|()| true) //~ ERROR: expected one of\n+        } else { //~ ERROR: incorrect close delimiter: `}`\n+            Ok(false);\n+        }\n+\n+        panic!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6c54acd7bdbf60827ec5a665ac15d29b0a6ce12f", "filename": "src/test/compile-fail/token-error-correct.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftoken-error-correct.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do some basic error correcton in the tokeniser.\n+\n+fn main() {\n+    foo(bar(; //~ NOTE: unclosed delimiter\n+    //~^ NOTE: unclosed delimiter\n+    //~^^ ERROR: unexpected token: `;`\n+    //~^^^ ERROR: unresolved name `bar`\n+    //~^^^^ ERROR: unresolved name `foo`\n+} //~ ERROR: incorrect close delimiter: `}`\n+//~^ ERROR: incorrect close delimiter: `}`"}, {"sha": "6974238ac72f2cd4b6dd3d883cf27c60e8681e42", "filename": "src/test/debuginfo/constant-in-match-pattern.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-in-match-pattern.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -21,15 +21,18 @@\n \n const CONSTANT: u64 = 3;\n \n+#[derive(PartialEq, Eq)]\n struct Struct {\n     a: isize,\n     b: usize,\n }\n const STRUCT: Struct = Struct { a: 1, b: 2 };\n \n+#[derive(PartialEq, Eq)]\n struct TupleStruct(u32);\n const TUPLE_STRUCT: TupleStruct = TupleStruct(4);\n \n+#[derive(PartialEq, Eq)]\n enum Enum {\n     Variant1(char),\n     Variant2 { a: u8 },"}, {"sha": "f24c544073578ff07def143413cec0e14cfaf49b", "filename": "src/test/parse-fail/issue-2354-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fparse-fail%2Fissue-2354-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fparse-fail%2Fissue-2354-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-2354-1.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-static foo: isize = 2; } //~ ERROR incorrect close delimiter:\n+static foo: isize = 2; } //~ ERROR unexpected close delimiter:"}, {"sha": "cbc0ed0ccdb84760bb98e6f69f68d5e15c574806", "filename": "src/test/parse-fail/macro-mismatched-delim-paren-brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fparse-fail%2Fmacro-mismatched-delim-paren-brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Fparse-fail%2Fmacro-mismatched-delim-paren-brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmacro-mismatched-delim-paren-brace.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -14,4 +14,4 @@ fn main() {\n     foo! (\n         bar, \"baz\", 1, 2.0\n     } //~ ERROR incorrect close delimiter\n-}\n+} //~ ERROR unexpected close delimiter: `}`"}, {"sha": "01d1b27bfc99f803a42643588485cae13edbb471", "filename": "src/test/run-pass/associated-const-match-patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -17,6 +17,7 @@ use empty_struct::XEmpty2 as XFoo;\n \n struct Foo;\n \n+#[derive(PartialEq, Eq)]\n enum Bar {\n     Var1,\n     Var2,"}, {"sha": "0060150fbece01b90c07e411bfb31b4db4ae8a58", "filename": "src/test/run-pass/empty-struct-braces.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-struct-braces.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -18,7 +18,10 @@ use empty_struct::*;\n \n struct Empty1 {}\n struct Empty2;\n+\n+#[derive(PartialEq, Eq)]\n struct Empty3 {}\n+\n const Empty3: Empty3 = Empty3 {};\n \n enum E {"}, {"sha": "5c9ee74472b12c5047286d8fccc8e015cce43f73", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(collections)]\n \n extern crate collections;"}, {"sha": "dd3d952224c057edcb1070ba5ca5f0c96bde6867", "filename": "src/test/run-pass/issue-20427.rs", "status": "renamed", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fissue-20427.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20427.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,17 +9,17 @@\n // except according to those terms.\n \n // aux-build:i8.rs\n+// ignore-pretty (#23623)\n+\n extern crate i8;\n use std::string as i16;\n static i32: i32 = 0;\n const i64: i64 = 0;\n fn u8(f32: f32) {}\n fn f<f64>(f64: f64) {}\n-//~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n-type u16 = u16; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-enum u32 {} //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-struct u64; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n-trait bool {} //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n+enum u32 {}\n+struct u64;\n+trait bool {}\n \n mod char {\n     extern crate i8;\n@@ -40,29 +40,52 @@ mod char {\n         use super::u8_ as u8;\n         use super::f_ as f64;\n         use super::u16_ as u16;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::u32_ as u32;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::u64_ as u64;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::bool_ as bool;\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::{bool_ as str};\n-        //~^ ERROR user-defined types or type parameters cannot shadow the primitive types\n         use super::char_ as char;\n     }\n }\n \n trait isize_ {\n-    type isize; //~ ERROR user-defined types or type parameters cannot shadow the primitive types\n+    type isize;\n }\n \n fn usize<'usize>(usize: &'usize usize) -> &'usize usize { usize }\n \n+mod reuse {\n+    use std::mem::size_of;\n+\n+    type u8 = u64;\n+    use std::string::String as i16;\n+\n+    pub fn check<u16>() {\n+        assert_eq!(size_of::<u8>(), 8);\n+        assert_eq!(size_of::<::u64>(), 0);\n+        assert_eq!(size_of::<i16>(), 3 * size_of::<*const ()>());\n+        assert_eq!(size_of::<u16>(), 0);\n+    }\n+}\n+\n+mod guard {\n+    pub fn check() {\n+        use std::u8; // bring module u8 in scope\n+        fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+                            // not to non-existent std::u8::max_value\n+        }\n+        assert_eq!(f(), u8::MAX); // OK, resolves to std::u8::MAX\n+    }\n+}\n+\n fn main() {\n     let bool = true;\n-    match bool {\n+    let _ = match bool {\n         str @ true => if str { i32 as i64 } else { i64 },\n         false => i64,\n     };\n+\n+    reuse::check::<u64>();\n+    guard::check();\n }", "previous_filename": "src/test/compile-fail/issue-20427.rs"}, {"sha": "9700ed247959b43039d5bb8afebdf5a81be1b2e4", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -9,18 +9,24 @@\n // except according to those terms.\n \n \n+#[derive(PartialEq, Eq)]\n struct NewBool(bool);\n \n+#[derive(PartialEq, Eq)]\n enum Direction {\n     North,\n     East,\n     South,\n     West\n }\n+\n+#[derive(PartialEq, Eq)]\n struct Foo {\n     bar: Option<Direction>,\n     baz: NewBool\n }\n+\n+#[derive(PartialEq, Eq)]\n enum EnumWithStructVariants {\n     Variant1(bool),\n     Variant2 {\n@@ -37,7 +43,7 @@ const VARIANT2_NORTH: EnumWithStructVariants = EnumWithStructVariants::Variant2\n     dir: Direction::North };\n \n pub mod glfw {\n-    #[derive(Copy, Clone)]\n+    #[derive(Copy, Clone, PartialEq, Eq)]\n     pub struct InputState(usize);\n \n     pub const RELEASE  : InputState = InputState(0);\n@@ -82,13 +88,15 @@ fn issue_14576() {\n         _ => unreachable!()\n     }\n \n+    #[derive(PartialEq, Eq)]\n     enum C { D = 3, E = 4 }\n     const F : C = C::D;\n \n     assert_eq!(match C::D { F => 1, _ => 2, }, 1);\n }\n \n fn issue_13731() {\n+    #[derive(PartialEq, Eq)]\n     enum A { AA(()) }\n     const B: A = A::AA(());\n \n@@ -99,6 +107,7 @@ fn issue_13731() {\n \n fn issue_15393() {\n     #![allow(dead_code)]\n+    #[derive(PartialEq, Eq)]\n     struct Flags {\n         bits: usize\n     }"}, {"sha": "2ad47c4f116ae9a34d6dbd22c145ed65391b280c", "filename": "src/test/run-pass/process-status-inherits-stdin.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fprocess-status-inherits-stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Fprocess-status-inherits-stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-status-inherits-stdin.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::io;\n+use std::io::Write;\n+use std::process::{Command, Stdio};\n+\n+fn main() {\n+    let mut args = env::args();\n+    let me = args.next().unwrap();\n+    let arg = args.next();\n+    match arg.as_ref().map(|s| &s[..]) {\n+        None => {\n+            let mut s = Command::new(&me)\n+                                .arg(\"a1\")\n+                                .stdin(Stdio::piped())\n+                                .spawn()\n+                                .unwrap();\n+            s.stdin.take().unwrap().write_all(b\"foo\\n\").unwrap();\n+            let s = s.wait().unwrap();\n+            assert!(s.success());\n+        }\n+        Some(\"a1\") => {\n+            let s = Command::new(&me).arg(\"a2\").status().unwrap();\n+            assert!(s.success());\n+        }\n+        Some(..) => {\n+            let mut s = String::new();\n+            io::stdin().read_line(&mut s).unwrap();\n+            assert_eq!(s, \"foo\\n\");\n+        }\n+    }\n+}"}, {"sha": "241fe6c6ab1e9a3c05bd86d58945ec9978145fde", "filename": "src/test/run-pass/rfc1445/eq-allows-match-on-ty-in-macro.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match-on-ty-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match-on-ty-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match-on-ty-in-macro.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+macro_rules! foo {\n+    (#[$attr:meta] $x:ident) => {\n+        #[$attr]\n+        struct $x {\n+            x: u32\n+        }\n+    }\n+}\n+\n+foo! { #[derive(PartialEq, Eq)] Foo }\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "f02a45625c9f6e5b10b655e9f7e6c9b92494bbcf", "filename": "src/test/run-pass/rfc1445/eq-allows-match.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d322f990b04e3b598afd6a47c09a0277f73031aa/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc1445%2Feq-allows-match.rs?ref=d322f990b04e3b598afd6a47c09a0277f73031aa", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+#[derive(PartialEq, Eq)]\n+struct Foo {\n+    x: u32\n+}\n+\n+const FOO: Foo = Foo { x: 0 };\n+\n+fn main() {\n+    let y = Foo { x: 1 };\n+    match y {\n+        FOO => { }\n+        _ => { }\n+    }\n+}"}]}