{"sha": "aacd18f4ed860420cb89cd103a9832ef47e838f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhY2QxOGY0ZWQ4NjA0MjBjYjg5Y2QxMDNhOTgzMmVmNDdlODM4ZjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-07T01:14:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-07T02:15:39Z"}, "message": "first shot at integrating ref/value bindings into borrowck\n(more needed)", "tree": {"sha": "e9184245deceed12c2e98f24283ae31d218b8572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9184245deceed12c2e98f24283ae31d218b8572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aacd18f4ed860420cb89cd103a9832ef47e838f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aacd18f4ed860420cb89cd103a9832ef47e838f3", "html_url": "https://github.com/rust-lang/rust/commit/aacd18f4ed860420cb89cd103a9832ef47e838f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aacd18f4ed860420cb89cd103a9832ef47e838f3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60f47eabe2ef2730b98713dee2b5fd59513e8c6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/60f47eabe2ef2730b98713dee2b5fd59513e8c6c", "html_url": "https://github.com/rust-lang/rust/commit/60f47eabe2ef2730b98713dee2b5fd59513e8c6c"}], "stats": {"total": 182, "additions": 125, "deletions": 57}, "files": [{"sha": "50a903551cd8c84a5c86825e15270affb17fa696", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -454,6 +454,12 @@ impl methods of get_type_for_node for ty::ctxt {\n     }\n }\n \n+impl borrowck_ctxt {\n+    fn is_subregion_of(r_sub: ty::region, r_sup: ty::region) -> bool {\n+        region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n+    }\n+}\n+\n impl error_methods for borrowck_ctxt {\n     fn report_if_err(bres: bckres<()>) {\n         match bres {"}, {"sha": "23baa0976f8cc42557ec629d19b3747e8b1e6413", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -9,6 +9,7 @@\n import categorization::{public_methods, opt_deref_kind};\n import loan::public_methods;\n import preserve::{public_methods, preserve_condition, pc_ok, pc_if_pure};\n+import ty::ty_region;\n \n export gather_loans;\n \n@@ -105,10 +106,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n         // make sure that the thing we are pointing out stays valid\n         // for the lifetime `scope_r` of the resulting ptr:\n-        let scope_r =\n-            match check ty::get(tcx.ty(ex)).struct {\n-              ty::ty_rptr(r, _) => r\n-            };\n+        let scope_r = ty_region(tcx.ty(ex));\n         self.guarantee_valid(base_cmt, mutbl, scope_r);\n         visit::visit_expr(ex, self, vt);\n       }\n@@ -474,37 +472,60 @@ impl methods for gather_loan_ctxt {\n             }\n           }\n \n-          ast::pat_ident(_, _, none) if self.pat_is_variant(pat) => {\n-            // nullary variant\n-            debug!{\"nullary variant\"};\n-          }\n-          ast::pat_ident(_, id, o_pat) => {\n-            // XXX: Needs to take by-ref/by-val into account.\n-\n-            // x or x @ p --- `x` must remain valid for the scope of the alt\n-            debug!{\"defines identifier %s\", pprust::path_to_str(id)};\n-\n-            // Note: there is a discussion of the function of\n-            // cat_discr in the method preserve():\n-            let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n-            let arm_scope = ty::re_scope(arm_id);\n-\n-            // Remember the mutability of the location that this\n-            // binding refers to.  This will be used later when\n-            // categorizing the binding.  This is a bit of a hack that\n-            // would be better fixed by #2329; in that case we could\n-            // allow the user to specify if they want an imm, const,\n-            // or mut binding, or else just reflect the mutability\n-            // through the type of the region pointer.\n-            self.bccx.binding_map.insert(pat.id, cmt1.mutbl);\n-\n-            self.guarantee_valid(cmt1, m_const, arm_scope);\n-\n+          ast::pat_ident(bm, id, o_pat) if !self.pat_is_variant(pat) => {\n+            match bm {\n+              ast::bind_by_value => {\n+                // copying does not borrow anything, so no check is required\n+              }\n+              ast::bind_by_ref(mutbl) => {\n+                // ref x or ref x @ p --- creates a ptr which must\n+                // remain valid for the scope of the alt\n+\n+                // find the region of the resulting pointer (note that\n+                // the type of such a pattern will *always* be a\n+                // region pointer)\n+                let scope_r = ty_region(tcx.ty(pat));\n+\n+                // if the scope of the region ptr turns out to be\n+                // specific to this arm, wrap the categorization with\n+                // a cat_discr() node.  There is a detailed discussion\n+                // of the function of this node in method preserve():\n+                let arm_scope = ty::re_scope(arm_id);\n+                if self.bccx.is_subregion_of(scope_r, arm_scope) {\n+                    let cmt_discr = self.bccx.cat_discr(cmt, alt_id);\n+                    self.guarantee_valid(cmt_discr, mutbl, scope_r);\n+                } else {\n+                    self.guarantee_valid(cmt, mutbl, scope_r);\n+                }\n+              }\n+              ast::bind_by_implicit_ref => {\n+                // Note: there is a discussion of the function of\n+                // cat_discr in the method preserve():\n+                let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n+                let arm_scope = ty::re_scope(arm_id);\n+\n+                // Remember the mutability of the location that this\n+                // binding refers to.  This will be used later when\n+                // categorizing the binding.  This is a bit of a hack that\n+                // would be better fixed by #2329; in that case we could\n+                // allow the user to specify if they want an imm, const,\n+                // or mut binding, or else just reflect the mutability\n+                // through the type of the region pointer.\n+                self.bccx.binding_map.insert(pat.id, cmt1.mutbl);\n+\n+                self.guarantee_valid(cmt1, m_const, arm_scope);\n+              }\n+            }\n             for o_pat.each |p| {\n                 self.gather_pat(cmt, p, arm_id, alt_id);\n             }\n           }\n \n+          ast::pat_ident(*) => {\n+              // nullary variant: ignore.\n+              assert self.pat_is_variant(pat);\n+          }\n+\n           ast::pat_rec(field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {"}, {"sha": "9411545754f29de2f52f615a51687a575d098517", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -39,8 +39,7 @@ impl loan_methods for loan_ctxt {\n     fn ok_with_loan_of(cmt: cmt,\n                        scope_ub: ty::region,\n                        mutbl: ast::mutability) -> bckres<()> {\n-        let region_map = self.tcx().region_map;\n-        if region::subregion(region_map, scope_ub, self.scope_region) {\n+        if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n             // Note: all cmt's that we deal with will have a non-none\n             // lp, because the entry point into this routine,\n             // `borrowck_ctxt::loan()`, rejects any cmt with a"}, {"sha": "7993a9725171f3c63693dccaae4185c0541e005d", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -232,16 +232,6 @@ impl private_methods for &preserve_ctxt {\n             // node appears to draw the line between what will be rooted\n             // in the *arm* vs the *alt*.\n \n-            // current scope must be the arm, which is always a child of alt:\n-            assert {\n-                match check self.scope_region {\n-                  ty::re_scope(arm_id) => {\n-                    self.tcx().region_map.get(arm_id) == alt_id\n-                  }\n-                  _ => {false}\n-                }\n-            };\n-\n             let alt_rooting_ctxt =\n                 preserve_ctxt({scope_region: ty::re_scope(alt_id)\n                                with **self});\n@@ -289,8 +279,7 @@ impl private_methods for &preserve_ctxt {\n     /// is a subscope of `scope_ub`; if so, success.\n     fn compare_scope(cmt: cmt,\n                      scope_ub: ty::region) -> bckres<preserve_condition> {\n-        let region_map = self.tcx().region_map;\n-        if region::subregion(region_map, scope_ub, self.scope_region) {\n+        if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n             ok(pc_ok)\n         } else {\n             err({cmt:cmt, code:err_out_of_scope(scope_ub,\n@@ -326,12 +315,11 @@ impl private_methods for &preserve_ctxt {\n           // we can only root values if the desired region is some concrete\n           // scope within the fn body\n           ty::re_scope(scope_id) => {\n-            let region_map = self.tcx().region_map;\n             #debug[\"Considering root map entry for %s: \\\n                     node %d:%u -> scope_id %?, root_ub %?\",\n                    self.bccx.cmt_to_repr(cmt), base.id,\n                    derefs, scope_id, self.root_ub];\n-            if region::subregion(region_map, root_region, self.scope_region) {\n+            if self.bccx.is_subregion_of(self.scope_region, root_region) {\n                 #debug[\"Elected to root\"];\n                 let rk = {id: base.id, derefs: derefs};\n                 self.bccx.root_map.insert(rk, scope_id);"}, {"sha": "91ba7ea60d7b748431791b49b9d1212782fb1190", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -99,15 +99,17 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n /// Determines whether one region is a subregion of another.  This is\n /// intended to run *after inference* and sadly the logic is somewhat\n /// duplicated with the code in infer.rs.\n-fn subregion(region_map: region_map,\n-             super_region: ty::region,\n-             sub_region: ty::region) -> bool {\n-    super_region == sub_region ||\n-        match (super_region, sub_region) {\n-          (ty::re_static, _) => {true}\n-\n-          (ty::re_scope(super_scope), ty::re_scope(sub_scope)) |\n-          (ty::re_free(super_scope, _), ty::re_scope(sub_scope)) => {\n+fn is_subregion_of(region_map: region_map,\n+                   sub_region: ty::region,\n+                   super_region: ty::region) -> bool {\n+    sub_region == super_region ||\n+        match (sub_region, super_region) {\n+          (_, ty::re_static) => {\n+            true\n+          }\n+\n+          (ty::re_scope(sub_scope), ty::re_scope(super_scope)) |\n+          (ty::re_scope(sub_scope), ty::re_free(super_scope, _)) => {\n             scope_contains(region_map, super_scope, sub_scope)\n           }\n "}, {"sha": "60461db08c4175d01c9ed45e00f329cb0aa36187", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -107,6 +107,7 @@ export tbox_has_flag;\n export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n+export ty_region;\n export kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n@@ -2297,8 +2298,15 @@ fn ty_fn_ret_style(fty: t) -> ast::ret_style {\n \n fn is_fn_ty(fty: t) -> bool {\n     match get(fty).struct {\n-      ty_fn(_) => return true,\n-      _ => return false\n+      ty_fn(_) => true,\n+      _ => false\n+    }\n+}\n+\n+fn ty_region(ty: t) -> region {\n+    match get(ty).struct {\n+      ty_rptr(r, _) => r,\n+      s => fail fmt!{\"ty_region() invoked on non-rptr: %?\", s}\n     }\n }\n "}, {"sha": "2b8ec9d7419dfbc444a4a942642f34902d033849", "filename": "src/test/compile-fail/borrowck-pat-by-value-binding.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-by-value-binding.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -0,0 +1,34 @@\n+fn process<T>(_t: T) {}\n+\n+fn match_const_opt_by_mut_ref(v: &const option<int>) {\n+    match *v {\n+      some(ref mut i) => process(i), //~ ERROR illegal borrow\n+      none => ()\n+    }\n+}\n+\n+fn match_const_opt_by_const_ref(v: &const option<int>) {\n+    match *v {\n+      some(ref const i) => process(i), //~ ERROR illegal borrow unless pure\n+      //~^ NOTE impure due to\n+      none => ()\n+    }\n+}\n+\n+fn match_const_opt_by_imm_ref(v: &const option<int>) {\n+    match *v {\n+      some(ref i) => process(i), //~ ERROR illegal borrow unless pure\n+      //~^ NOTE impure due to\n+      none => ()\n+    }\n+}\n+\n+fn match_const_opt_by_value(v: &const option<int>) {\n+    match *v {\n+      some(copy i) => process(i),\n+      none => ()\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "e4a33d58feb6e143ba95d67777057237cd4e23ca", "filename": "src/test/compile-fail/borrowck-ref-mut-of-imm.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aacd18f4ed860420cb89cd103a9832ef47e838f3/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-ref-mut-of-imm.rs?ref=aacd18f4ed860420cb89cd103a9832ef47e838f3", "patch": "@@ -0,0 +1,10 @@\n+fn destructure(x: option<int>) -> int {\n+    match x {\n+      none => 0,\n+      some(ref mut v) => *v //~ ERROR illegal borrow\n+    }\n+}\n+\n+fn main() {\n+    assert destructure(some(22)) == 22;\n+}"}]}