{"sha": "c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNGVmNWQ3ZTRmNDRmOGU2NTYwMGEyYzM4NjZmNTg2MWM0MDFlYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-01T19:06:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-01T19:06:51Z"}, "message": "auto merge of #11255 : klutzy/rust/small-cleanup, r=pcwalton\n\nThis patchset removes some `@`s and unnecessary traits,\r\nand replaces a function (`dummy_sp()`) returning constant value\r\nby static variable.", "tree": {"sha": "9c31384ec271d66958fd9cc376232a2f554f74f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c31384ec271d66958fd9cc376232a2f554f74f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "html_url": "https://github.com/rust-lang/rust/commit/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51ace54597984b221321d1cac0f80c50f9e00f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ace54597984b221321d1cac0f80c50f9e00f71", "html_url": "https://github.com/rust-lang/rust/commit/51ace54597984b221321d1cac0f80c50f9e00f71"}, {"sha": "9cdad685a39fd826174a6cbcd283ad2dee41e175", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cdad685a39fd826174a6cbcd283ad2dee41e175", "html_url": "https://github.com/rust-lang/rust/commit/9cdad685a39fd826174a6cbcd283ad2dee41e175"}], "stats": {"total": 420, "additions": 194, "deletions": 226}, "files": [{"sha": "c4a3e21cbad8bb2d0495241f4faded2112cbf4aa", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -686,7 +686,7 @@ pub fn host_triple() -> ~str {\n     (env!(\"CFG_COMPILER\")).to_owned()\n }\n \n-pub fn build_session_options(binary: @str,\n+pub fn build_session_options(binary: ~str,\n                              matches: &getopts::Matches,\n                              demitter: @diagnostic::Emitter)\n                              -> @session::options {\n@@ -883,7 +883,7 @@ pub fn build_session(sopts: @session::options, demitter: @diagnostic::Emitter)\n pub fn build_session_(sopts: @session::options,\n                       cm: @codemap::CodeMap,\n                       demitter: @diagnostic::Emitter,\n-                      span_diagnostic_handler: @mut diagnostic::span_handler)\n+                      span_diagnostic_handler: @mut diagnostic::SpanHandler)\n                       -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n@@ -1105,7 +1105,7 @@ pub fn build_output_filenames(input: &input,\n     }\n }\n \n-pub fn early_error(emitter: @diagnostic::Emitter, msg: &str) -> ! {\n+pub fn early_error(emitter: &diagnostic::Emitter, msg: &str) -> ! {\n     emitter.emit(None, msg, diagnostic::fatal);\n     fail!();\n }\n@@ -1135,7 +1135,7 @@ mod test {\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n         let sessopts = build_session_options(\n-            @\"rustc\",\n+            ~\"rustc\",\n             matches,\n             @diagnostic::DefaultEmitter as @diagnostic::Emitter);\n         let sess = build_session(sessopts,\n@@ -1158,7 +1158,7 @@ mod test {\n               }\n             };\n         let sessopts = build_session_options(\n-            @\"rustc\",\n+            ~\"rustc\",\n             matches,\n             @diagnostic::DefaultEmitter as @diagnostic::Emitter);\n         let sess = build_session(sessopts,"}, {"sha": "3f9274bc901b558df6ce6fde81f39835e2b9ee9c", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -163,7 +163,7 @@ pub struct options {\n     // will be added to the crate AST node.  This should not be used for\n     // anything except building the full crate config prior to parsing.\n     cfg: ast::CrateConfig,\n-    binary: @str,\n+    binary: ~str,\n     test: bool,\n     parse_only: bool,\n     no_trans: bool,\n@@ -209,7 +209,7 @@ pub struct Session_ {\n     // For a library crate, this is always none\n     entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     entry_type: Cell<Option<EntryFnType>>,\n-    span_diagnostic: @mut diagnostic::span_handler,\n+    span_diagnostic: @mut diagnostic::SpanHandler,\n     filesearch: @filesearch::FileSearch,\n     building_library: Cell<bool>,\n     working_dir: Path,\n@@ -292,7 +292,7 @@ impl Session_ {\n \n         v\n     }\n-    pub fn diagnostic(&self) -> @mut diagnostic::span_handler {\n+    pub fn diagnostic(&self) -> @mut diagnostic::SpanHandler {\n         self.span_diagnostic\n     }\n     pub fn debugging_opt(&self, opt: uint) -> bool {\n@@ -395,7 +395,7 @@ pub fn basic_options() -> @options {\n         target_cpu: ~\"generic\",\n         target_feature: ~\"\",\n         cfg: ~[],\n-        binary: @\"rustc\",\n+        binary: ~\"rustc\",\n         test: false,\n         parse_only: false,\n         no_trans: false,"}, {"sha": "97ffc1490f5efe4a58e339e575fa1a0b7932ba26", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -14,7 +14,7 @@ use driver::session::Session;\n use std::vec;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::dummy_sp;\n+use syntax::codemap::DUMMY_SP;\n use syntax::codemap;\n use syntax::fold::ast_fold;\n use syntax::fold;\n@@ -47,7 +47,7 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n fn spanned<T>(x: T) -> codemap::Spanned<T> {\n     codemap::Spanned {\n         node: x,\n-        span: dummy_sp(),\n+        span: DUMMY_SP,\n     }\n }\n \n@@ -66,7 +66,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n                                             ast::DUMMY_NODE_ID),\n             attrs: ~[],\n             vis: ast::private,\n-            span: dummy_sp()\n+            span: DUMMY_SP\n         }];\n \n         if use_uv(&crate) && !self.sess.building_library.get() {\n@@ -77,7 +77,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n                                                 ast::DUMMY_NODE_ID),\n                 attrs: ~[],\n                 vis: ast::private,\n-                span: dummy_sp()\n+                span: DUMMY_SP\n             });\n             vis.push(ast::view_item {\n                 node: ast::view_item_extern_mod(self.sess.ident_of(\"rustuv\"),\n@@ -86,7 +86,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n                                                 ast::DUMMY_NODE_ID),\n                 attrs: ~[],\n                 vis: ast::private,\n-                span: dummy_sp()\n+                span: DUMMY_SP\n             });\n         }\n \n@@ -121,7 +121,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n \n     fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n         let prelude_path = ast::Path {\n-            span: dummy_sp(),\n+            span: DUMMY_SP,\n             global: false,\n             segments: ~[\n                 ast::PathSegment {\n@@ -143,7 +143,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n             node: ast::view_item_use(~[vp]),\n             attrs: ~[],\n             vis: ast::private,\n-            span: dummy_sp(),\n+            span: DUMMY_SP,\n         };\n \n         let vis = vec::append(~[vi2], module.view_items);"}, {"sha": "2b104cde95ae7697444aa19cc5cb174d6decb66c", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -19,7 +19,7 @@ use std::vec;\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::codemap::{dummy_sp, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n+use syntax::codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold::ast_fold;\n@@ -164,7 +164,7 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n     };\n \n     cx.ext_cx.bt_push(ExpnInfo {\n-        call_site: dummy_sp(),\n+        call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             name: @\"test\",\n             format: MacroAttribute,\n@@ -298,7 +298,7 @@ fn mk_std(cx: &TestCtxt) -> ast::view_item {\n         node: vi,\n         attrs: ~[],\n         vis: ast::public,\n-        span: dummy_sp()\n+        span: DUMMY_SP\n     }\n }\n \n@@ -335,7 +335,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::public,\n-        span: dummy_sp(),\n+        span: DUMMY_SP,\n      };\n \n     debug!(\"Synthetic test module:\\n{}\\n\",\n@@ -345,12 +345,12 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {\n-    codemap::Spanned { node: t, span: dummy_sp() }\n+    codemap::Spanned { node: t, span: DUMMY_SP }\n }\n \n fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n     ast::Path {\n-        span: dummy_sp(),\n+        span: DUMMY_SP,\n         global: false,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n@@ -362,7 +362,7 @@ fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n \n fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n     ast::Path {\n-        span: dummy_sp(),\n+        span: DUMMY_SP,\n         global: true,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n@@ -403,13 +403,13 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     let inner_expr = @ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprVec(descs, ast::MutImmutable),\n-        span: dummy_sp(),\n+        span: DUMMY_SP,\n     };\n \n     @ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprVstore(inner_expr, ast::ExprVstoreSlice),\n-        span: dummy_sp(),\n+        span: DUMMY_SP,\n     }\n }\n "}, {"sha": "e6afdf7fe1466f306ef0bbf17e43f36ad8ba67a0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -197,7 +197,7 @@ pub fn describe_debug_flags() {\n \n pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     let mut args = args.to_owned();\n-    let binary = args.shift().to_managed();\n+    let binary = args.shift();\n \n     if args.is_empty() { usage(binary); return; }\n \n@@ -348,7 +348,7 @@ struct RustcEmitter {\n \n impl diagnostic::Emitter for RustcEmitter {\n     fn emit(&self,\n-            cmsp: Option<(@codemap::CodeMap, codemap::Span)>,\n+            cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n             msg: &str,\n             lvl: diagnostic::level) {\n         if lvl == diagnostic::fatal {"}, {"sha": "33e407dec1a1044105873a00a5b28cb2ed2968f5", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -21,8 +21,8 @@ use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span, dummy_sp};\n-use syntax::diagnostic::span_handler;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::crateid::CrateId;\n@@ -86,7 +86,7 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n }\n \n fn warn_if_multiple_versions(e: &mut Env,\n-                             diag: @mut span_handler,\n+                             diag: @mut SpanHandler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n         let name = crate_cache[crate_cache.len() - 1].crateid.name.clone();\n@@ -346,7 +346,7 @@ fn resolve_crate_deps(e: &mut Env, cdata: &[u8]) -> cstore::cnum_map {\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span.\n-            let fake_span = dummy_sp();\n+            let fake_span = DUMMY_SP;\n             let local_cnum = resolve_crate(e, cname_str, cname_str, dep.vers,\n                                            dep.hash, fake_span);\n             cnum_map.insert(extrn_cnum, local_cnum);"}, {"sha": "4e4ab981bf672b50c3498c9fc2ecf8c1bbc527f0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -1099,7 +1099,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n                         value: meta_item,\n                         is_sugared_doc: false,\n                     },\n-                    span: codemap::dummy_sp()\n+                    span: codemap::DUMMY_SP\n                 });\n             true\n         });"}, {"sha": "ba46d29902e1725223ab3ebf8d3c8ff714d50d81", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -39,7 +39,7 @@ use syntax::ast_map;\n use syntax::ast_util::*;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::diagnostic::span_handler;\n+use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::ast_util;\n use syntax::visit::Visitor;\n@@ -57,7 +57,7 @@ pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n                                              ii: ast::inlined_item|;\n \n pub struct EncodeParams<'a> {\n-    diag: @mut span_handler,\n+    diag: @mut SpanHandler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<HashMap<ast::NodeId, ~str>>,\n@@ -83,7 +83,7 @@ struct Stats {\n }\n \n pub struct EncodeContext<'a> {\n-    diag: @mut span_handler,\n+    diag: @mut SpanHandler,\n     tcx: ty::ctxt,\n     stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,"}, {"sha": "37e6a46d6ba2ee2696cb4980506c9823cc84a2c7", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -19,7 +19,7 @@ use metadata::encoder;\n use metadata::filesearch::{FileMatches, FileDoesntMatch};\n use metadata::filesearch;\n use syntax::codemap::Span;\n-use syntax::diagnostic::span_handler;\n+use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::ident_interner;\n use syntax::crateid::CrateId;\n use syntax::attr;\n@@ -231,8 +231,8 @@ impl Context {\n     }\n }\n \n-pub fn note_crateid_attr(diag: @mut span_handler,\n-                       crateid: &CrateId) {\n+pub fn note_crateid_attr(diag: @mut SpanHandler,\n+                         crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n "}, {"sha": "e6ed70bd4dc858ea22b64675d8ac9dbac15d8f95", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -24,15 +24,15 @@ use middle::ty;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n-use syntax::diagnostic::span_handler;\n+use syntax::diagnostic::SpanHandler;\n use syntax::print::pprust::*;\n \n macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n     format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n ) )\n \n pub struct ctxt {\n-    diag: @mut span_handler,\n+    diag: @mut SpanHandler,\n     // Def -> str Callback:\n     ds: extern \"Rust\" fn(DefId) -> ~str,\n     // The type context."}, {"sha": "f413dfd2451ccd0bd0ec2aabd27e6f9b8f3b047d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -218,7 +218,7 @@ impl ExtendedDecodeContext {\n         ast::DefId { crate: ast::LOCAL_CRATE, node: self.tr_id(did.node) }\n     }\n     pub fn tr_span(&self, _span: Span) -> Span {\n-        codemap::dummy_sp() // FIXME (#1972): handle span properly\n+        codemap::DUMMY_SP // FIXME (#1972): handle span properly\n     }\n }\n "}, {"sha": "079c275026887d9f297b73f0e02bafb6afbceb9d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -23,7 +23,7 @@ use std::num;\n use std::vec;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n-use syntax::codemap::{Span, dummy_sp, Spanned};\n+use syntax::codemap::{Span, DUMMY_SP, Spanned};\n use syntax::visit;\n use syntax::visit::{Visitor,fn_kind};\n \n@@ -536,11 +536,11 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n }\n \n fn wild() -> @Pat {\n-    @Pat {id: 0, node: PatWild, span: dummy_sp()}\n+    @Pat {id: 0, node: PatWild, span: DUMMY_SP}\n }\n \n fn wild_multi() -> @Pat {\n-    @Pat {id: 0, node: PatWildMulti, span: dummy_sp()}\n+    @Pat {id: 0, node: PatWildMulti, span: DUMMY_SP}\n }\n \n fn specialize(cx: &MatchCheckCtxt,"}, {"sha": "5de4de89b8e1e3564f563d8d1f8f633cb50eb698", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -24,7 +24,7 @@ use syntax::parse::token;\n use syntax::parse::token::{ident_interner, interner_get};\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n-use syntax::codemap::{Span, dummy_sp, Pos};\n+use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::opt_vec::OptVec;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -1643,7 +1643,7 @@ impl Resolver {\n                                                   NormalModuleKind,\n                                                   true,\n                                                   is_public,\n-                                                  dummy_sp());\n+                                                  DUMMY_SP);\n               }\n             }\n           }\n@@ -1661,16 +1661,16 @@ impl Resolver {\n             // public.\n             let is_public = vis != ast::private;\n             if is_struct {\n-                child_name_bindings.define_type(def, dummy_sp(), is_public);\n+                child_name_bindings.define_type(def, DUMMY_SP, is_public);\n                 self.structs.insert(variant_id);\n             } else {\n-                child_name_bindings.define_value(def, dummy_sp(), is_public);\n+                child_name_bindings.define_value(def, DUMMY_SP, is_public);\n             }\n           }\n           DefFn(..) | DefStaticMethod(..) | DefStatic(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n-            child_name_bindings.define_value(def, dummy_sp(), is_public);\n+            child_name_bindings.define_value(def, DUMMY_SP, is_public);\n           }\n           DefTrait(def_id) => {\n               debug!(\"(building reduced graph for external \\\n@@ -1711,7 +1711,7 @@ impl Resolver {\n                   }\n               }\n \n-              child_name_bindings.define_type(def, dummy_sp(), is_public);\n+              child_name_bindings.define_type(def, DUMMY_SP, is_public);\n \n               // Define a module if necessary.\n               let parent_link = self.get_parent_link(new_parent, ident);\n@@ -1720,21 +1720,21 @@ impl Resolver {\n                                                   TraitModuleKind,\n                                                   true,\n                                                   is_public,\n-                                                  dummy_sp())\n+                                                  DUMMY_SP)\n           }\n           DefTy(_) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n-              child_name_bindings.define_type(def, dummy_sp(), is_public);\n+              child_name_bindings.define_type(def, DUMMY_SP, is_public);\n           }\n           DefStruct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building type and value for {}\",\n                    final_ident);\n-            child_name_bindings.define_type(def, dummy_sp(), is_public);\n+            child_name_bindings.define_type(def, DUMMY_SP, is_public);\n             if csearch::get_struct_fields(self.session.cstore, def_id).len() == 0 {\n-                child_name_bindings.define_value(def, dummy_sp(), is_public);\n+                child_name_bindings.define_value(def, DUMMY_SP, is_public);\n             }\n             self.structs.insert(def_id);\n           }\n@@ -1782,7 +1782,7 @@ impl Resolver {\n                             self.add_child(ident,\n                                            ModuleReducedGraphParent(root),\n                                            OverwriteDuplicates,\n-                                           dummy_sp());\n+                                           DUMMY_SP);\n \n                         self.handle_external_def(def,\n                                                  visibility,\n@@ -1814,7 +1814,7 @@ impl Resolver {\n                                         final_ident,\n                                         ModuleReducedGraphParent(root),\n                                         OverwriteDuplicates,\n-                                        dummy_sp());\n+                                        DUMMY_SP);\n \n                                 // Process the static methods. First,\n                                 // create the module.\n@@ -1842,7 +1842,7 @@ impl Resolver {\n                                             ImplModuleKind,\n                                             true,\n                                             true,\n-                                            dummy_sp());\n+                                            DUMMY_SP);\n                                         type_module =\n                                             child_name_bindings.\n                                                 get_module();\n@@ -1864,13 +1864,13 @@ impl Resolver {\n                                         self.add_child(ident,\n                                                        new_parent,\n                                                        OverwriteDuplicates,\n-                                                       dummy_sp());\n+                                                       DUMMY_SP);\n                                     let def = DefFn(\n                                         static_method_info.def_id,\n                                         static_method_info.purity);\n \n                                     method_name_bindings.define_value(\n-                                        def, dummy_sp(),\n+                                        def, DUMMY_SP,\n                                         visibility == ast::public);\n                                 }\n                             }\n@@ -5576,7 +5576,7 @@ impl Resolver {\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n         if vi.vis == public { return }\n-        if vi.span == dummy_sp() { return }\n+        if vi.span == DUMMY_SP { return }\n \n         match vi.node {\n             view_item_extern_mod(..) => {} // ignore"}, {"sha": "d9ba2c68f436fbf2634189a20a0381bdbd6650f4", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -227,7 +227,7 @@ use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n-use syntax::codemap::{Span, dummy_sp};\n+use syntax::codemap::{Span, DUMMY_SP};\n \n // An option identifying a literal: either a unit-like struct or an\n // expression.\n@@ -617,7 +617,7 @@ fn enter_opt<'r>(bcx: @Block,\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     let mut i = 0;\n     enter_match(bcx, tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n@@ -758,7 +758,7 @@ fn enter_rec_or_struct<'r>(bcx: @Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n@@ -793,7 +793,7 @@ fn enter_tup<'r>(bcx: @Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => Some((*elts).clone()),\n@@ -819,7 +819,7 @@ fn enter_tuple_struct<'r>(bcx: @Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatEnum(_, Some(ref elts)) => Some((*elts).clone()),\n@@ -844,7 +844,7 @@ fn enter_box<'r>(bcx: @Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatBox(sub) => {\n@@ -871,7 +871,7 @@ fn enter_uniq<'r>(bcx: @Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n+    let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: DUMMY_SP};\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatUniq(sub) => {\n@@ -898,7 +898,7 @@ fn enter_region<'r>(bcx: @Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: dummy_sp() };\n+    let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: DUMMY_SP };\n     enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n@@ -1535,7 +1535,7 @@ fn compile_submatch_continue(mut bcx: @Block,\n                                 vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n-    let mut pat_span = dummy_sp();\n+    let mut pat_span = DUMMY_SP;\n     for br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)"}, {"sha": "4f075c79dc8796d9d3e0d29962a6bec266454057", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -2107,7 +2107,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n             ty: varg.ty(),\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n-                codemap::dummy_sp(),\n+                codemap::DUMMY_SP,\n                 special_idents::arg),\n             id: varg.id(),\n         }"}, {"sha": "c00df5f165cb34f034f67b2840f8d1c0e8f335d2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -678,7 +678,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     };\n \n     // This can be the case for functions inlined from another crate\n-    if span == codemap::dummy_sp() {\n+    if span == codemap::DUMMY_SP {\n         return FunctionWithoutDebugInfo;\n     }\n \n@@ -797,7 +797,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     }\n                 };\n \n-                signature.push(type_metadata(cx, return_type, codemap::dummy_sp()));\n+                signature.push(type_metadata(cx, return_type, codemap::DUMMY_SP));\n             }\n         }\n \n@@ -812,7 +812,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 }\n             };\n \n-            signature.push(type_metadata(cx, arg_type, codemap::dummy_sp()));\n+            signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n         return create_DIArray(DIB(cx), signature);\n@@ -856,7 +856,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             if cx.sess.opts.extra_debuginfo {\n                 let actual_self_type_metadata = type_metadata(cx,\n                                                               actual_self_type,\n-                                                              codemap::dummy_sp());\n+                                                              codemap::DUMMY_SP);\n \n                 let ident = special_idents::type_self;\n \n@@ -897,7 +897,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n             // Again, only create type information if extra_debuginfo is enabled\n             if cx.sess.opts.extra_debuginfo {\n-                let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n+                let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n@@ -1271,7 +1271,7 @@ impl RecursiveTypeDescription {\n                                               llvm_type,\n                                               member_descriptions,\n                                               file_metadata,\n-                                              codemap::dummy_sp());\n+                                              codemap::DUMMY_SP);\n                 return metadata_stub;\n             }\n         }\n@@ -1364,7 +1364,7 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n                                               variant_llvm_type,\n                                               member_descriptions,\n                                               self.file_metadata,\n-                                              codemap::dummy_sp());\n+                                              codemap::DUMMY_SP);\n                 MemberDescription {\n                     name: @\"\",\n                     llvm_type: variant_llvm_type,\n@@ -1419,12 +1419,12 @@ fn describe_variant(cx: &CrateContext,\n                 cx.sess.span_warn(span,\n                     format!(\"debuginfo::enum_metadata()::adt_struct_metadata() - Unexpected node \\\n                           type: {:?}. This is a bug.\", node));\n-                codemap::dummy_sp()\n+                codemap::DUMMY_SP\n             }\n         }\n     } else {\n         // For definitions from other crates we have no location information available.\n-        codemap::dummy_sp()\n+        codemap::DUMMY_SP\n     };\n \n     let metadata_stub = create_struct_stub(cx,\n@@ -1511,7 +1511,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n         let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n         let discriminant_base_type_metadata = type_metadata(cx, adt::ty_of_inttype(inttype),\n-                                                            codemap::dummy_sp());\n+                                                            codemap::DUMMY_SP);\n         enum_name.with_c_str(|enum_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerationType(\n@@ -1773,13 +1773,13 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let int_type = ty::mk_int();\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n-    let nil_pointer_type_metadata = type_metadata(cx, nil_pointer_type, codemap::dummy_sp());\n+    let nil_pointer_type_metadata = type_metadata(cx, nil_pointer_type, codemap::DUMMY_SP);\n \n     let member_descriptions = [\n         MemberDescription {\n             name: @\"refcnt\",\n             llvm_type: member_llvm_types[0],\n-            type_metadata: type_metadata(cx, int_type, codemap::dummy_sp()),\n+            type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n@@ -2086,14 +2086,14 @@ fn type_metadata(cx: &CrateContext,\n         let content_type_metadata = type_metadata(\n             cx,\n             type_in_box,\n-            codemap::dummy_sp());\n+            codemap::DUMMY_SP);\n \n         let box_metadata = boxed_type_metadata(\n             cx,\n             Some(content_type_name),\n             content_llvm_type,\n             content_type_metadata,\n-            codemap::dummy_sp());\n+            codemap::DUMMY_SP);\n \n         pointer_type_metadata(cx, pointer_type, box_metadata)\n     }\n@@ -2294,13 +2294,13 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n                 cx.sess.span_warn(warning_span,\n                     format!(\"debuginfo::get_namespace_and_span_for_item() \\\n                              - Unexpected node type: {:?}\", *node));\n-                codemap::dummy_sp()\n+                codemap::DUMMY_SP\n             }\n         };\n         definition_span\n     } else {\n         // For external items there is no span information\n-        codemap::dummy_sp()\n+        codemap::DUMMY_SP\n     };\n \n     (containing_scope, definition_span)"}, {"sha": "78b06d62480645f37025274a6a00f97af37d995d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -267,7 +267,7 @@ pub type ctxt = @ctxt_;\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n struct ctxt_ {\n-    diag: @mut syntax::diagnostic::span_handler,\n+    diag: @mut syntax::diagnostic::SpanHandler,\n     interner: RefCell<HashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,"}, {"sha": "9b71da4f767f6c773604709a2beaa6585ea1f9d4", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -326,7 +326,7 @@ pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     indent(|| {\n         cx.probe(|| {\n             let trace = TypeTrace {\n-                origin: Misc(codemap::dummy_sp()),\n+                origin: Misc(codemap::DUMMY_SP),\n                 values: Types(expected_found(true, a, b))\n             };\n             cx.sub(true, trace).tys(a, b)\n@@ -418,7 +418,7 @@ pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     indent(|| {\n         cx.probe(|| {\n             let trace = TypeTrace {\n-                origin: Misc(codemap::dummy_sp()),\n+                origin: Misc(codemap::DUMMY_SP),\n                 values: Types(expected_found(true, a, b))\n             };\n             Coerce(cx.combine_fields(true, trace)).tys(a, b)\n@@ -927,7 +927,7 @@ impl RegionVariableOrigin {\n             BoundRegionInFnCall(a, _) => a,\n             BoundRegionInFnType(a, _) => a,\n             BoundRegionInTypeOrImpl(a) => a,\n-            BoundRegionInCoherence => codemap::dummy_sp(),\n+            BoundRegionInCoherence => codemap::DUMMY_SP,\n         }\n     }\n }"}, {"sha": "f2ea3a320ee556040fe97275094c4c020fe66be0", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -29,7 +29,7 @@ use extra::getopts::{opt_present};\n use extra::getopts;\n use extra::getopts;\n use extra::oldmap::HashMap;\n-use syntax::codemap::dummy_sp;\n+use syntax::codemap::DUMMY_SP;\n use syntax::parse::parse_crate_from_source_str;\n use syntax::{ast, attr, parse};\n \n@@ -221,9 +221,9 @@ impl Env {\n         ty::mk_imm_rptr(self.tcx, ty::ReStatic, self.t_int())\n     }\n \n-    pub fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }\n+    pub fn lub() -> Lub { Lub(self.infcx.combine_fields(true, DUMMY_SP)) }\n \n-    pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, dummy_sp())) }\n+    pub fn glb() -> Glb { Glb(self.infcx.combine_fields(true, DUMMY_SP)) }\n \n     pub fn resolve_regions(exp_count: uint) {\n         debug!(\"resolve_regions(%u)\", exp_count);"}, {"sha": "63b923943656504fdc5123d4656e23d5e67370cf", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -49,7 +49,7 @@ fn get_ast_and_resolve(cpath: &Path,\n     let input = file_input(cpath.clone());\n \n     let sessopts = @driver::session::options {\n-        binary: @\"rustdoc\",\n+        binary: ~\"rustdoc\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n         outputs: ~[driver::session::OutputDylib],"}, {"sha": "3bec73597607b77fd824fd87d557a66c60e11436", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -40,7 +40,7 @@ impl Module {\n             name       : name,\n             id: 0,\n             vis: ast::private,\n-            where: syntax::codemap::dummy_sp(),\n+            where: syntax::codemap::DUMMY_SP,\n             attrs      : ~[],\n             structs    : ~[],\n             enums      : ~[],"}, {"sha": "480ace2e4194824a13b3a55f3a5b41cae9f757c6", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -38,7 +38,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     let libs = @RefCell::new(libs.move_iter().collect());\n \n     let sessopts = @session::options {\n-        binary: @\"rustdoc\",\n+        binary: ~\"rustdoc\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: libs,\n         outputs: ~[session::OutputDylib],\n@@ -98,7 +98,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n     let input = driver::str_input(test);\n \n     let sessopts = @session::options {\n-        binary: @\"rustdoctest\",\n+        binary: ~\"rustdoctest\",\n         maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: @RefCell::new(libs),\n         outputs: ~[session::OutputExecutable],"}, {"sha": "ae58495fa8a7a1a7b3493a8ac9de49d772aa8700", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -101,7 +101,7 @@ impl<'a> PkgScript<'a> {\n                  workspace: &Path,\n                  id: &'a CrateId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n-        let binary = os::args()[0].to_managed();\n+        let binary = os::args()[0].to_owned();\n         // Build the rustc session data structures to pass\n         // to the compiler\n         debug!(\"pkgscript parse: {}\", sysroot.display());"}, {"sha": "2ceed4f3df7e4803e4de3e3e731731da98d198a1", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -1823,7 +1823,7 @@ fn test_linker_build() {\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let matches = getopts([], optgroups());\n-    let options = build_session_options(@\"rustpkg\",\n+    let options = build_session_options(~\"rustpkg\",\n                                         matches.as_ref().unwrap(),\n                                         @diagnostic::DefaultEmitter as\n                                             @diagnostic::Emitter);"}, {"sha": "a081c2a31afedf727fb57a1fc2df7e04431c718f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -19,7 +19,7 @@ use extra::workcache;\n use rustc::driver::{driver, session};\n use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n-use syntax::codemap::{dummy_sp, Spanned};\n+use syntax::codemap::{DUMMY_SP, Spanned};\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n@@ -189,7 +189,7 @@ pub fn compile_input(context: &BuildContext,\n     // Make the output directory if it doesn't exist already\n     fs::mkdir_recursive(&out_dir, io::UserRWX);\n \n-    let binary = os::args()[0].to_managed();\n+    let binary = os::args()[0].to_owned();\n \n     debug!(\"flags: {}\", flags.connect(\" \"));\n     debug!(\"cfgs: {}\", cfgs.connect(\" \"));\n@@ -631,7 +631,7 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n pub fn mk_string_lit(s: @str) -> ast::lit {\n     Spanned {\n         node: ast::lit_str(s, ast::CookedStr),\n-        span: dummy_sp()\n+        span: DUMMY_SP\n     }\n }\n "}, {"sha": "504a51f80a8e80127cd7b8add0a9840676c4f62b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -15,7 +15,7 @@ use ast_util::{inlined_item_utils, stmt_id};\n use ast_util;\n use codemap::Span;\n use codemap;\n-use diagnostic::span_handler;\n+use diagnostic::SpanHandler;\n use parse::token::get_ident_interner;\n use parse::token::ident_interner;\n use parse::token::special_idents;\n@@ -197,7 +197,7 @@ pub type map = @mut HashMap<NodeId, ast_node>;\n pub struct Ctx {\n     map: map,\n     path: path,\n-    diag: @mut span_handler,\n+    diag: @mut SpanHandler,\n }\n \n impl Ctx {\n@@ -418,7 +418,7 @@ impl Visitor<()> for Ctx {\n     }\n }\n \n-pub fn map_crate(diag: @mut span_handler, c: &Crate) -> map {\n+pub fn map_crate(diag: @mut SpanHandler, c: &Crate) -> map {\n     let cx = @mut Ctx {\n         map: @mut HashMap::new(),\n         path: ~[],\n@@ -431,7 +431,7 @@ pub fn map_crate(diag: @mut span_handler, c: &Crate) -> map {\n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n-pub fn map_decoded_item(diag: @mut span_handler,\n+pub fn map_decoded_item(diag: @mut SpanHandler,\n                         map: map,\n                         path: path,\n                         ii: &inlined_item) {"}, {"sha": "7a3ac0f2f4d9a2705b8e45fab479fcfcba6573a2", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -14,7 +14,7 @@ use ast;\n use ast::{Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n-use diagnostic::span_handler;\n+use diagnostic::SpanHandler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crateid::CrateId;\n \n@@ -355,7 +355,7 @@ pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It) -> O\n     None\n }\n \n-pub fn require_unique_names(diagnostic: @mut span_handler,\n+pub fn require_unique_names(diagnostic: @mut SpanHandler,\n                             metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n@@ -381,7 +381,7 @@ pub fn require_unique_names(diagnostic: @mut span_handler,\n  * present (before fields, if any) with that type; reprensentation\n  * optimizations which would remove it will not be done.\n  */\n-pub fn find_repr_attr(diagnostic: @mut span_handler, attr: @ast::MetaItem, acc: ReprAttr)\n+pub fn find_repr_attr(diagnostic: @mut SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n     -> ReprAttr {\n     let mut acc = acc;\n     match attr.node {"}, {"sha": "97d3db074bb00f3be24836771a573554747c4639", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -90,6 +90,8 @@ pub struct Span {\n     expn_info: Option<@ExpnInfo>\n }\n \n+pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n+\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Spanned<T> {\n     node: T,\n@@ -112,7 +114,7 @@ impl<S:Encoder> Encodable<S> for Span {\n \n impl<D:Decoder> Decodable<D> for Span {\n     fn decode(_d: &mut D) -> Span {\n-        dummy_sp()\n+        DUMMY_SP\n     }\n }\n \n@@ -125,19 +127,14 @@ pub fn respan<T>(sp: Span, t: T) -> Spanned<T> {\n }\n \n pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n-    respan(dummy_sp(), t)\n+    respan(DUMMY_SP, t)\n }\n \n /* assuming that we're not in macro expansion */\n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n     Span {lo: lo, hi: hi, expn_info: None}\n }\n \n-// make this a const, once the compiler supports it\n-pub fn dummy_sp() -> Span { return mk_sp(BytePos(0), BytePos(0)); }\n-\n-\n-\n /// A source code location used for error reporting\n pub struct Loc {\n     /// Information about the original source\n@@ -350,7 +347,7 @@ impl CodeMap {\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {\n         let files = &*self.files;\n-        if files.len() == 0 && sp == dummy_sp() {\n+        if files.len() == 0 && sp == DUMMY_SP {\n             return ~\"no-location\";\n         }\n "}, {"sha": "c905281cdb235c17e3bfe6581a817aa80a83d70a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 50, "deletions": 78, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -21,100 +21,72 @@ static BUG_REPORT_URL: &'static str =\n \n pub trait Emitter {\n     fn emit(&self,\n-            cmsp: Option<(@codemap::CodeMap, Span)>,\n-            msg: &str,\n-            lvl: level);\n-}\n-\n-// a handler deals with errors; certain errors\n-// (fatal, bug, unimpl) may cause immediate exit,\n-// others log errors for later reporting.\n-pub trait handler {\n-    fn fatal(@mut self, msg: &str) -> !;\n-    fn err(@mut self, msg: &str);\n-    fn bump_err_count(@mut self);\n-    fn err_count(@mut self) -> uint;\n-    fn has_errors(@mut self) -> bool;\n-    fn abort_if_errors(@mut self);\n-    fn warn(@mut self, msg: &str);\n-    fn note(@mut self, msg: &str);\n-    // used to indicate a bug in the compiler:\n-    fn bug(@mut self, msg: &str) -> !;\n-    fn unimpl(@mut self, msg: &str) -> !;\n-    fn emit(@mut self,\n-            cmsp: Option<(@codemap::CodeMap, Span)>,\n+            cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level);\n }\n \n // a span-handler is like a handler but also\n // accepts span information for source-location\n // reporting.\n-pub trait span_handler {\n-    fn span_fatal(@mut self, sp: Span, msg: &str) -> !;\n-    fn span_err(@mut self, sp: Span, msg: &str);\n-    fn span_warn(@mut self, sp: Span, msg: &str);\n-    fn span_note(@mut self, sp: Span, msg: &str);\n-    fn span_bug(@mut self, sp: Span, msg: &str) -> !;\n-    fn span_unimpl(@mut self, sp: Span, msg: &str) -> !;\n-    fn handler(@mut self) -> @mut handler;\n-}\n-\n-struct HandlerT {\n-    err_count: uint,\n-    emit: @Emitter,\n-}\n-\n-struct CodemapT {\n-    handler: @mut handler,\n+pub struct SpanHandler {\n+    handler: @mut Handler,\n     cm: @codemap::CodeMap,\n }\n \n-impl span_handler for CodemapT {\n-    fn span_fatal(@mut self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((self.cm, sp)), msg, fatal);\n+impl SpanHandler {\n+    pub fn span_fatal(@mut self, sp: Span, msg: &str) -> ! {\n+        self.handler.emit(Some((&*self.cm, sp)), msg, fatal);\n         fail!();\n     }\n-    fn span_err(@mut self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((self.cm, sp)), msg, error);\n+    pub fn span_err(@mut self, sp: Span, msg: &str) {\n+        self.handler.emit(Some((&*self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n-    fn span_warn(@mut self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((self.cm, sp)), msg, warning);\n+    pub fn span_warn(@mut self, sp: Span, msg: &str) {\n+        self.handler.emit(Some((&*self.cm, sp)), msg, warning);\n     }\n-    fn span_note(@mut self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((self.cm, sp)), msg, note);\n+    pub fn span_note(@mut self, sp: Span, msg: &str) {\n+        self.handler.emit(Some((&*self.cm, sp)), msg, note);\n     }\n-    fn span_bug(@mut self, sp: Span, msg: &str) -> ! {\n+    pub fn span_bug(@mut self, sp: Span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    fn span_unimpl(@mut self, sp: Span, msg: &str) -> ! {\n+    pub fn span_unimpl(@mut self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    fn handler(@mut self) -> @mut handler {\n+    pub fn handler(@mut self) -> @mut Handler {\n         self.handler\n     }\n }\n \n-impl handler for HandlerT {\n-    fn fatal(@mut self, msg: &str) -> ! {\n+// a handler deals with errors; certain errors\n+// (fatal, bug, unimpl) may cause immediate exit,\n+// others log errors for later reporting.\n+pub struct Handler {\n+    err_count: uint,\n+    emit: @Emitter,\n+}\n+\n+impl Handler {\n+    pub fn fatal(@mut self, msg: &str) -> ! {\n         self.emit.emit(None, msg, fatal);\n         fail!();\n     }\n-    fn err(@mut self, msg: &str) {\n+    pub fn err(@mut self, msg: &str) {\n         self.emit.emit(None, msg, error);\n         self.bump_err_count();\n     }\n-    fn bump_err_count(@mut self) {\n+    pub fn bump_err_count(@mut self) {\n         self.err_count += 1u;\n     }\n-    fn err_count(@mut self) -> uint {\n+    pub fn err_count(@mut self) -> uint {\n         self.err_count\n     }\n-    fn has_errors(@mut self) -> bool {\n+    pub fn has_errors(@mut self) -> bool {\n         self.err_count > 0u\n     }\n-    fn abort_if_errors(@mut self) {\n+    pub fn abort_if_errors(@mut self) {\n         let s;\n         match self.err_count {\n           0u => return,\n@@ -126,20 +98,20 @@ impl handler for HandlerT {\n         }\n         self.fatal(s);\n     }\n-    fn warn(@mut self, msg: &str) {\n+    pub fn warn(@mut self, msg: &str) {\n         self.emit.emit(None, msg, warning);\n     }\n-    fn note(@mut self, msg: &str) {\n+    pub fn note(@mut self, msg: &str) {\n         self.emit.emit(None, msg, note);\n     }\n-    fn bug(@mut self, msg: &str) -> ! {\n+    pub fn bug(@mut self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n-    fn unimpl(@mut self, msg: &str) -> ! {\n+    pub fn unimpl(@mut self, msg: &str) -> ! {\n         self.bug(~\"unimplemented \" + msg);\n     }\n-    fn emit(@mut self,\n-            cmsp: Option<(@codemap::CodeMap, Span)>,\n+    pub fn emit(@mut self,\n+            cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level) {\n         self.emit.emit(cmsp, msg, lvl);\n@@ -151,24 +123,24 @@ pub fn ice_msg(msg: &str) -> ~str {\n             \\nWe would appreciate a bug report: {}\", msg, BUG_REPORT_URL)\n }\n \n-pub fn mk_span_handler(handler: @mut handler, cm: @codemap::CodeMap)\n-                    -> @mut span_handler {\n-    @mut CodemapT {\n+pub fn mk_span_handler(handler: @mut Handler, cm: @codemap::CodeMap)\n+                    -> @mut SpanHandler {\n+    @mut SpanHandler {\n         handler: handler,\n         cm: cm,\n-    } as @mut span_handler\n+    }\n }\n \n-pub fn mk_handler(emitter: Option<@Emitter>) -> @mut handler {\n+pub fn mk_handler(emitter: Option<@Emitter>) -> @mut Handler {\n     let emit: @Emitter = match emitter {\n         Some(e) => e,\n         None => @DefaultEmitter as @Emitter\n     };\n \n-    @mut HandlerT {\n+    @mut Handler {\n         err_count: 0,\n         emit: emit,\n-    } as @mut handler\n+    }\n }\n \n #[deriving(Eq)]\n@@ -255,7 +227,7 @@ pub struct DefaultEmitter;\n \n impl Emitter for DefaultEmitter {\n     fn emit(&self,\n-            cmsp: Option<(@codemap::CodeMap, Span)>,\n+            cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: level) {\n         match cmsp {\n@@ -272,20 +244,20 @@ impl Emitter for DefaultEmitter {\n     }\n }\n \n-fn highlight_lines(cm: @codemap::CodeMap,\n+fn highlight_lines(cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: level,\n-                   lines: @codemap::FileLines) {\n+                   lines: &codemap::FileLines) {\n     let fm = lines.file;\n     let mut err = io::stderr();\n     let err = &mut err as &mut io::Writer;\n \n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n     let mut elided = false;\n-    let mut display_lines = /* FIXME (#2543) */ lines.lines.clone();\n+    let mut display_lines = lines.lines.as_slice();\n     if display_lines.len() > max_lines {\n-        display_lines = display_lines.slice(0u, max_lines).to_owned();\n+        display_lines = display_lines.slice(0u, max_lines);\n         elided = true;\n     }\n     // Print the offending lines\n@@ -339,7 +311,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     }\n }\n \n-fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n+fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_default(~\"\", |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n@@ -356,7 +328,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n }\n \n pub fn expect<T:Clone>(\n-              diag: @mut span_handler,\n+              diag: @mut SpanHandler,\n               opt: Option<T>,\n               msg: || -> ~str)\n               -> T {"}, {"sha": "7c2dad34002cf7eab7bbab0734122a2de668e314", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -12,7 +12,6 @@ use ast;\n use ast::Name;\n use codemap;\n use codemap::{CodeMap, Span, ExpnInfo};\n-use diagnostic::span_handler;\n use ext;\n use ext::expand;\n use parse;"}, {"sha": "1a3513ab81c93b05710bffac8473674bdb83d552", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -12,7 +12,7 @@ use abi::AbiSet;\n use ast::{P, Ident};\n use ast;\n use ast_util;\n-use codemap::{Span, respan, dummy_sp};\n+use codemap::{Span, respan, DUMMY_SP};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n use fold::ast_fold;\n@@ -321,7 +321,7 @@ impl AstBuilder for ExtCtxt {\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty_path(\n-            self.path_all(dummy_sp(),\n+            self.path_all(DUMMY_SP,\n                           true,\n                           ~[\n                               self.ident_of(\"std\"),\n@@ -348,7 +348,7 @@ impl AstBuilder for ExtCtxt {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ty_nil,\n-            span: dummy_sp(),\n+            span: DUMMY_SP,\n         })\n     }\n \n@@ -361,13 +361,13 @@ impl AstBuilder for ExtCtxt {\n     // incorrect code.\n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n         opt_vec::take_vec(\n-            ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n+            ty_params.map(|p| self.ty_ident(DUMMY_SP, p.ident)))\n     }\n \n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[P<ast::Ty>] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(dummy_sp(), ~[p.ident]), None)))\n+                self.path_global(DUMMY_SP, ~[p.ident]), None)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {"}, {"sha": "be336128275f18af59aff79ce0413a97aafd8beb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -1279,12 +1279,12 @@ mod test {\n     // make a MetaWord outer attribute with the given name\n     fn make_dummy_attr(s: @str) -> ast::Attribute {\n         Spanned {\n-            span:codemap::dummy_sp(),\n+            span:codemap::DUMMY_SP,\n             node: Attribute_ {\n                 style: AttrOuter,\n                 value: @Spanned {\n                     node: MetaWord(s),\n-                    span: codemap::dummy_sp(),\n+                    span: codemap::DUMMY_SP,\n                 },\n                 is_sugared_doc: false,\n             }"}, {"sha": "05d402a2ba284c945b7ac3cb3fa5abe0641f0522", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -11,7 +11,7 @@\n use ast::{Ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n-use codemap::{Span, Spanned, dummy_sp};\n+use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{AnyMacro, ExtCtxt, MacResult, MRAny, MRDef, MacroDef};\n use ext::base::{NormalTT, SyntaxExpanderTTTrait};\n use ext::base;\n@@ -109,7 +109,7 @@ fn generic_extension(cx: &ExtCtxt,\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n-    let mut best_fail_spot = dummy_sp();\n+    let mut best_fail_spot = DUMMY_SP;\n     let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n     let s_d = cx.parse_sess().span_diagnostic;\n@@ -178,7 +178,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     fn ms(m: matcher_) -> matcher {\n         Spanned {\n             node: m.clone(),\n-            span: dummy_sp()\n+            span: DUMMY_SP\n         }\n     }\n "}, {"sha": "cbce5fb16cbb54689a2ac1ae13d63e129409c4ed", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -10,8 +10,8 @@\n \n use ast;\n use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,Ident};\n-use codemap::{Span, dummy_sp};\n-use diagnostic::span_handler;\n+use codemap::{Span, DUMMY_SP};\n+use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n use parse::token::{ident_to_str};\n@@ -30,7 +30,7 @@ struct TtFrame {\n }\n \n pub struct TtReader {\n-    sp_diag: @mut span_handler,\n+    sp_diag: @mut SpanHandler,\n     // the unzipped tree:\n     stack: @mut TtFrame,\n     /* for MBE-style macro transcription */\n@@ -45,7 +45,7 @@ pub struct TtReader {\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: @mut span_handler,\n+pub fn new_tt_reader(sp_diag: @mut SpanHandler,\n                      interp: Option<HashMap<Ident,@named_match>>,\n                      src: ~[ast::token_tree])\n                   -> @mut TtReader {\n@@ -66,7 +66,7 @@ pub fn new_tt_reader(sp_diag: @mut span_handler,\n         repeat_len: ~[],\n         /* dummy values, never read: */\n         cur_tok: EOF,\n-        cur_span: dummy_sp()\n+        cur_span: DUMMY_SP\n     };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;"}, {"sha": "b1390253d19452423441117dd236ffb099a91ae3", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -342,7 +342,7 @@ pub struct lit {\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n-                                    @mut diagnostic::span_handler,\n+                                    @mut diagnostic::SpanHandler,\n                                     path: @str,\n                                     srdr: &mut io::Reader)\n                                  -> (~[cmnt], ~[lit]) {"}, {"sha": "2c3d03eefea17e9a831c24a2fff8df523edf2939", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n-use diagnostic::span_handler;\n+use diagnostic::SpanHandler;\n use ext::tt::transcribe::{tt_next_token};\n use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n@@ -29,7 +29,7 @@ pub trait reader {\n     fn is_eof(@mut self) -> bool;\n     fn next_token(@mut self) -> TokenAndSpan;\n     fn fatal(@mut self, ~str) -> !;\n-    fn span_diag(@mut self) -> @mut span_handler;\n+    fn span_diag(@mut self) -> @mut SpanHandler;\n     fn peek(@mut self) -> TokenAndSpan;\n     fn dup(@mut self) -> @mut reader;\n }\n@@ -41,7 +41,7 @@ pub struct TokenAndSpan {\n }\n \n pub struct StringReader {\n-    span_diagnostic: @mut span_handler,\n+    span_diagnostic: @mut SpanHandler,\n     src: @str,\n     // The absolute offset within the codemap of the next character to read\n     pos: BytePos,\n@@ -57,7 +57,7 @@ pub struct StringReader {\n     peek_span: Span\n }\n \n-pub fn new_string_reader(span_diagnostic: @mut span_handler,\n+pub fn new_string_reader(span_diagnostic: @mut SpanHandler,\n                          filemap: @codemap::FileMap)\n                       -> @mut StringReader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap);\n@@ -66,7 +66,7 @@ pub fn new_string_reader(span_diagnostic: @mut span_handler,\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-pub fn new_low_level_string_reader(span_diagnostic: @mut span_handler,\n+pub fn new_low_level_string_reader(span_diagnostic: @mut SpanHandler,\n                                    filemap: @codemap::FileMap)\n                                 -> @mut StringReader {\n     // Force the initial reader bump to start on a fresh line\n@@ -81,7 +81,7 @@ pub fn new_low_level_string_reader(span_diagnostic: @mut span_handler,\n         filemap: filemap,\n         /* dummy values; not read */\n         peek_tok: token::EOF,\n-        peek_span: codemap::dummy_sp()\n+        peek_span: codemap::DUMMY_SP\n     };\n     bump(r);\n     return r;\n@@ -118,7 +118,7 @@ impl reader for StringReader {\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(self.peek_span, m)\n     }\n-    fn span_diag(@mut self) -> @mut span_handler { self.span_diagnostic }\n+    fn span_diag(@mut self) -> @mut SpanHandler { self.span_diagnostic }\n     fn peek(@mut self) -> TokenAndSpan {\n         // XXX(pcwalton): Bad copy!\n         TokenAndSpan {\n@@ -139,7 +139,7 @@ impl reader for TtReader {\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span, m);\n     }\n-    fn span_diag(@mut self) -> @mut span_handler { self.sp_diag }\n+    fn span_diag(@mut self) -> @mut SpanHandler { self.sp_diag }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.clone(),"}, {"sha": "8aedc1462406f3635a2f6aff6cc3c562cb19895f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -14,7 +14,7 @@\n use ast;\n use codemap::{Span, CodeMap, FileMap, FileSubstr};\n use codemap;\n-use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n+use diagnostic::{SpanHandler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n@@ -41,7 +41,7 @@ pub mod obsolete;\n // info about a parsing session.\n pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n-    span_diagnostic: @mut span_handler, // better be the same as the one in the reader!\n+    span_diagnostic: @mut SpanHandler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: ~[Path],\n }\n@@ -55,7 +55,7 @@ pub fn new_parse_sess(demitter: Option<@Emitter>) -> @mut ParseSess {\n     }\n }\n \n-pub fn new_parse_sess_special_handler(sh: @mut span_handler,\n+pub fn new_parse_sess_special_handler(sh: @mut SpanHandler,\n                                       cm: @codemap::CodeMap)\n                                    -> @mut ParseSess {\n     @mut ParseSess {"}, {"sha": "960e28ca84f8fc81658e4cd485933c059ec5c685", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c34ef5d7e4f44f8e65600a2c3866f5861c401ea1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c34ef5d7e4f44f8e65600a2c3866f5861c401ea1", "patch": "@@ -118,7 +118,7 @@ pub static default_columns: uint = 78u;\n // copy forward.\n pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n-                   span_diagnostic: @mut diagnostic::span_handler,\n+                   span_diagnostic: @mut diagnostic::SpanHandler,\n                    crate: &ast::Crate,\n                    filename: @str,\n                    input: @mut io::Reader,\n@@ -2422,7 +2422,7 @@ mod test {\n             inputs: ~[],\n             output: ast::P(ast::Ty {id: 0,\n                                     node: ast::ty_nil,\n-                                    span: codemap::dummy_sp()}),\n+                                    span: codemap::DUMMY_SP}),\n             cf: ast::return_val,\n             variadic: false\n         };\n@@ -2436,7 +2436,7 @@ mod test {\n     fn test_variant_to_str() {\n         let ident = token::str_to_ident(\"principal_skinner\");\n \n-        let var = codemap::respan(codemap::dummy_sp(), ast::variant_ {\n+        let var = codemap::respan(codemap::DUMMY_SP, ast::variant_ {\n             name: ident,\n             attrs: ~[],\n             // making this up as I go.... ?"}]}