{"sha": "58e644736521b2916a6734aa225603c539bfeeed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZTY0NDczNjUyMWIyOTE2YTY3MzRhYTIyNTYwM2M1MzliZmVlZWQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-18T17:04:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-18T17:04:01Z"}, "message": "Rollup merge of #71599 - ldm0:fnclo, r=nikomatsakis\n\nSupport coercion between (FnDef | Closure) and (FnDef | Closure)\n\nFixes #46742, fixes #48109\nInject `Closure` into the `FnDef x FnDef` coercion special case, which makes coercion of `(FnDef | Closure) x (FnDef | Closure)` possible, where closures should be **non-capturing**.", "tree": {"sha": "091e965d4db66505b632e7a63aa7cf3bb054f9d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/091e965d4db66505b632e7a63aa7cf3bb054f9d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58e644736521b2916a6734aa225603c539bfeeed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJewsABCRBK7hj4Ov3rIwAAdHIIAGcjUstT84ejD4vVk8bxBOXr\niZVsP0XCkPg8zBwB7CZG+qNK0i15FEplZT+nT66yoLgUOfaOCSUAhQih+S/T0zY9\nZN+yTbx7vX5TWSIAMHuOenh/JqH7FgmNB/lEeTj37l5i6E22iybm/zl/7lbR7yvP\nt0rkKOl5R9c5HHjO9DKyzexNZaybSkgYYKwGersRuKRAj/u8qsBU4/rnaedrA2cm\nahZd1i4cQZkt68Lo96TLCsLYh/XCU6AEVU37Jy6yovhugU+PTlpS0h1v+GlQlQsD\n+UHQGdGQfx10n+0j4BOyRSzydxExPYLOHKLT3v2dtDtviN1Bc2p1RKc10uD60fs=\n=WmVS\n-----END PGP SIGNATURE-----\n", "payload": "tree 091e965d4db66505b632e7a63aa7cf3bb054f9d2\nparent 9e2a6a29ce82e4fc5decad86dab7911a38582438\nparent 42396b1fac0435254f24e8393a27f76019b44219\nauthor Dylan DPC <dylan.dpc@gmail.com> 1589821441 +0200\ncommitter GitHub <noreply@github.com> 1589821441 +0200\n\nRollup merge of #71599 - ldm0:fnclo, r=nikomatsakis\n\nSupport coercion between (FnDef | Closure) and (FnDef | Closure)\n\nFixes #46742, fixes #48109\nInject `Closure` into the `FnDef x FnDef` coercion special case, which makes coercion of `(FnDef | Closure) x (FnDef | Closure)` possible, where closures should be **non-capturing**.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58e644736521b2916a6734aa225603c539bfeeed", "html_url": "https://github.com/rust-lang/rust/commit/58e644736521b2916a6734aa225603c539bfeeed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58e644736521b2916a6734aa225603c539bfeeed/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e2a6a29ce82e4fc5decad86dab7911a38582438", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e2a6a29ce82e4fc5decad86dab7911a38582438", "html_url": "https://github.com/rust-lang/rust/commit/9e2a6a29ce82e4fc5decad86dab7911a38582438"}, {"sha": "42396b1fac0435254f24e8393a27f76019b44219", "url": "https://api.github.com/repos/rust-lang/rust/commits/42396b1fac0435254f24e8393a27f76019b44219", "html_url": "https://github.com/rust-lang/rust/commit/42396b1fac0435254f24e8393a27f76019b44219"}], "stats": {"total": 563, "additions": 512, "deletions": 51}, "files": [{"sha": "33f5fbe785821ef3ee6e0aace4e69bddb04340b4", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -2069,24 +2069,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n-    /// Given a closure signature `sig`, returns an equivalent `fn`\n-    /// type with the same signature. Detuples and so forth -- so\n-    /// e.g., if we have a sig with `Fn<(u32, i32)>` then you would get\n-    /// a `fn(u32, i32)`.\n-    /// `unsafety` determines the unsafety of the `fn` type. If you pass\n+    /// Given a closure signature, returns an equivalent fn signature. Detuples\n+    /// and so forth -- so e.g., if we have a sig with `Fn<(u32, i32)>` then\n+    /// you would get a `fn(u32, i32)`.\n+    /// `unsafety` determines the unsafety of the fn signature. If you pass\n     /// `hir::Unsafety::Unsafe` in the previous example, then you would get\n     /// an `unsafe fn (u32, i32)`.\n     /// It cannot convert a closure that requires unsafe.\n-    pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>, unsafety: hir::Unsafety) -> Ty<'tcx> {\n-        let converted_sig = sig.map_bound(|s| {\n+    pub fn signature_unclosure(\n+        self,\n+        sig: PolyFnSig<'tcx>,\n+        unsafety: hir::Unsafety,\n+    ) -> PolyFnSig<'tcx> {\n+        sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].kind {\n                 ty::Tuple(params) => params.into_iter().map(|k| k.expect_ty()),\n                 _ => bug!(),\n             };\n             self.mk_fn_sig(params_iter, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n-        });\n-\n-        self.mk_fn_ptr(converted_sig)\n+        })\n     }\n \n     #[allow(rustc::usage_of_ty_tykind)]"}, {"sha": "526914721bebe21c866732874554f0ea0cea93a4", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -2088,7 +2088,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n-                        let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig, *unsafety);\n+                        let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n                             ty_fn_ptr_from,"}, {"sha": "54562cf38addd1eb2ae3915d780ab6b1e2613c1a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -793,7 +793,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n                 let closure_sig = substs_a.as_closure().sig();\n                 let unsafety = fn_ty.unsafety();\n-                let pointer_ty = self.tcx.coerce_closure_fn_ty(closure_sig, unsafety);\n+                let pointer_ty =\n+                    self.tcx.mk_fn_ptr(self.tcx.signature_unclosure(closure_sig, unsafety));\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\", a, b, pointer_ty);\n                 self.unify_and(\n                     pointer_ty,\n@@ -909,23 +910,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n-        // Two function item types of differing IDs or InternalSubsts.\n-        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.kind, &new_ty.kind) {\n-            // Don't reify if the function types have a LUB, i.e., they\n-            // are the same function and their parameters have a LUB.\n-            let lub_ty = self\n-                .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                .map(|ok| self.register_infer_ok_obligations(ok));\n-\n-            if lub_ty.is_ok() {\n-                // We have a LUB of prev_ty and new_ty, just return it.\n-                return lub_ty;\n+        // Function items or non-capturing closures of differing IDs or InternalSubsts.\n+        let (a_sig, b_sig) = {\n+            let is_capturing_closure = |ty| {\n+                if let &ty::Closure(_, substs) = ty {\n+                    substs.as_closure().upvar_tys().next().is_some()\n+                } else {\n+                    false\n+                }\n+            };\n+            if is_capturing_closure(&prev_ty.kind) || is_capturing_closure(&new_ty.kind) {\n+                (None, None)\n+            } else {\n+                match (&prev_ty.kind, &new_ty.kind) {\n+                    (&ty::FnDef(..), &ty::FnDef(..)) => {\n+                        // Don't reify if the function types have a LUB, i.e., they\n+                        // are the same function and their parameters have a LUB.\n+                        match self\n+                            .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n+                        {\n+                            // We have a LUB of prev_ty and new_ty, just return it.\n+                            Ok(ok) => return Ok(self.register_infer_ok_obligations(ok)),\n+                            Err(_) => {\n+                                (Some(prev_ty.fn_sig(self.tcx)), Some(new_ty.fn_sig(self.tcx)))\n+                            }\n+                        }\n+                    }\n+                    (&ty::Closure(_, substs), &ty::FnDef(..)) => {\n+                        let b_sig = new_ty.fn_sig(self.tcx);\n+                        let a_sig = self\n+                            .tcx\n+                            .signature_unclosure(substs.as_closure().sig(), b_sig.unsafety());\n+                        (Some(a_sig), Some(b_sig))\n+                    }\n+                    (&ty::FnDef(..), &ty::Closure(_, substs)) => {\n+                        let a_sig = prev_ty.fn_sig(self.tcx);\n+                        let b_sig = self\n+                            .tcx\n+                            .signature_unclosure(substs.as_closure().sig(), a_sig.unsafety());\n+                        (Some(a_sig), Some(b_sig))\n+                    }\n+                    (&ty::Closure(_, substs_a), &ty::Closure(_, substs_b)) => (\n+                        Some(self.tcx.signature_unclosure(\n+                            substs_a.as_closure().sig(),\n+                            hir::Unsafety::Normal,\n+                        )),\n+                        Some(self.tcx.signature_unclosure(\n+                            substs_b.as_closure().sig(),\n+                            hir::Unsafety::Normal,\n+                        )),\n+                    ),\n+                    _ => (None, None),\n+                }\n             }\n-\n+        };\n+        if let (Some(a_sig), Some(b_sig)) = (a_sig, b_sig) {\n             // The signature must match.\n-            let a_sig = prev_ty.fn_sig(self.tcx);\n             let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n-            let b_sig = new_ty.fn_sig(self.tcx);\n             let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n             let sig = self\n                 .at(cause, self.param_env)\n@@ -935,17 +976,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Reify both sides and return the reified fn pointer type.\n             let fn_ptr = self.tcx.mk_fn_ptr(sig);\n-            for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                // The only adjustment that can produce an fn item is\n-                // `NeverToAny`, so this should always be valid.\n+            let prev_adjustment = match prev_ty.kind {\n+                ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(a_sig.unsafety())),\n+                ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                _ => unreachable!(),\n+            };\n+            let next_adjustment = match new_ty.kind {\n+                ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(b_sig.unsafety())),\n+                ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                _ => unreachable!(),\n+            };\n+            for expr in exprs.iter().map(|e| e.as_coercion_site()) {\n                 self.apply_adjustments(\n                     expr,\n-                    vec![Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::ReifyFnPointer),\n-                        target: fn_ptr,\n-                    }],\n+                    vec![Adjustment { kind: prev_adjustment.clone(), target: fn_ptr }],\n                 );\n             }\n+            self.apply_adjustments(new, vec![Adjustment { kind: next_adjustment, target: fn_ptr }]);\n             return Ok(fn_ptr);\n         }\n "}, {"sha": "9133a292103089ed8e4221aad2a9d4f8c8f0f237", "filename": "src/test/ui/closures/closure_cap_coerce_many_fail.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,39 @@\n+fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+fn main() {\n+    // We shouldn't coerce capturing closure to a function\n+    let cap = 0;\n+    let _ = match \"+\" {\n+        \"+\" => add,\n+        \"-\" => |a, b| (a - b + cap) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+\n+\n+    // We shouldn't coerce capturing closure to a non-capturing closure\n+    let _ = match \"+\" {\n+        \"+\" => |a, b| (a + b) as i32,\n+        \"-\" => |a, b| (a - b + cap) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+\n+\n+    // We shouldn't coerce non-capturing closure to a capturing closure\n+    let _ = match \"+\" {\n+        \"+\" => |a, b| (a + b + cap) as i32,\n+        \"-\" => |a, b| (a - b) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+\n+    // We shouldn't coerce capturing closure to a capturing closure\n+    let _ = match \"+\" {\n+        \"+\" => |a, b| (a + b + cap) as i32,\n+        \"-\" => |a, b| (a - b + cap) as i32,\n+        _ => unimplemented!(),\n+    };\n+    //~^^^ ERROR `match` arms have incompatible types\n+}"}, {"sha": "63eb0bd8fabad3d4bc4ba84bb021832474f22088", "filename": "src/test/ui/closures/closure_cap_coerce_many_fail.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_cap_coerce_many_fail.stderr?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,73 @@\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:9:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => add,\n+   | |                --- this is found to be of type `fn(i32, i32) -> i32 {add}`\n+LL | |         \"-\" => |a, b| (a - b + cap) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected fn item, found closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `fn(i32, i32) -> i32 {add}`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:9:16: 9:43 cap:_]`\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:18:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => |a, b| (a + b) as i32,\n+   | |                --------------------- this is found to be of type `[closure@$DIR/closure_cap_coerce_many_fail.rs:17:16: 17:37]`\n+LL | |         \"-\" => |a, b| (a - b + cap) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/closure_cap_coerce_many_fail.rs:17:16: 17:37]`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:18:16: 18:43 cap:_]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:27:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => |a, b| (a + b + cap) as i32,\n+   | |                --------------------------- this is found to be of type `[closure@$DIR/closure_cap_coerce_many_fail.rs:26:16: 26:43 cap:_]`\n+LL | |         \"-\" => |a, b| (a - b) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/closure_cap_coerce_many_fail.rs:26:16: 26:43 cap:_]`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:27:16: 27:37]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/closure_cap_coerce_many_fail.rs:35:16\n+   |\n+LL |       let _ = match \"+\" {\n+   |  _____________-\n+LL | |         \"+\" => |a, b| (a + b + cap) as i32,\n+   | |                --------------------------- this is found to be of type `[closure@$DIR/closure_cap_coerce_many_fail.rs:34:16: 34:43 cap:_]`\n+LL | |         \"-\" => |a, b| (a - b + cap) as i32,\n+   | |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found a different closure\n+LL | |         _ => unimplemented!(),\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/closure_cap_coerce_many_fail.rs:34:16: 34:43 cap:_]`\n+           found closure `[closure@$DIR/closure_cap_coerce_many_fail.rs:35:16: 35:43 cap:_]`\n+   = note: no two closures, even if identical, have the same type\n+   = help: consider boxing your closure and/or using it as a trait object\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "ce461810ec990239c82cab6cfa126a0e11e9e45c", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_check_pass.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_check_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_check_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_check_pass.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,166 @@\n+// check-pass\n+// Ensure non-capturing Closure passes CoerceMany.\n+fn foo(x: usize) -> usize {\n+    0\n+}\n+\n+fn bar(x: usize) -> usize {\n+    1\n+}\n+\n+fn main() {\n+    // One FnDef and one non-capturing Closure\n+    let _ = match 0 {\n+        0 => foo,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        2 => |a| 2,\n+        0 => foo,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [foo, |a| 2];\n+    let _ = [|a| 2, foo];\n+\n+\n+\n+    // Two FnDefs and one non-capturing Closure\n+    let _ = match 0 {\n+        0 => foo,\n+        1 => bar,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        0 => foo,\n+        2 => |a| 2,\n+        1 => bar,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        2 => |a| 2,\n+        0 => foo,\n+        1 => bar,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [foo, bar, |a| 2];\n+    let _ = [foo, |a| 2, bar];\n+    let _ = [|a| 2, foo, bar];\n+\n+\n+\n+    // One FnDef and two non-capturing Closures\n+    let _ = match 0 {\n+        0 => foo,\n+        1 => |a| 1,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        1 => |a| 1,\n+        0 => foo,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = match 0 {\n+        1 => |a| 1,\n+        2 => |a| 2,\n+        0 => foo,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [foo, |a| 1, |a| 2];\n+    let _ = [|a| 1, foo, |a| 2];\n+    let _ = [|a| 1, |a| 2, foo];\n+\n+\n+\n+    // Three non-capturing Closures\n+    let _ = match 0 {\n+        0 => |a: usize| 0,\n+        1 => |a| 1,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let _ = [|a: usize| 0, |a| 1, |a| 2];\n+\n+\n+\n+    // Three non-capturing Closures variable\n+    let clo0 = |a: usize| 0;\n+    let clo1 = |a| 1;\n+    let clo2 = |a| 2;\n+    let _ = match 0 {\n+        0 => clo0,\n+        1 => clo1,\n+        2 => clo2,\n+        _ => unimplemented!(),\n+    };\n+\n+    let clo0 = |a: usize| 0;\n+    let clo1 = |a| 1;\n+    let clo2 = |a| 2;\n+    let _ = [clo0, clo1, clo2];\n+\n+\n+\n+    // --- Function pointer related part\n+\n+    // Closure is not in a variable\n+    type FnPointer = fn(usize) -> usize;\n+\n+    let _ = match 0 {\n+        0 => foo as FnPointer,\n+        2 => |a| 2,\n+        _ => unimplemented!(),\n+    };\n+    let _ = match 0 {\n+        2 => |a| 2,\n+        0 => foo as FnPointer,\n+        _ => unimplemented!(),\n+    };\n+    let _ = [foo as FnPointer, |a| 2];\n+    let _ = [|a| 2, foo as FnPointer];\n+    let _ = [foo, bar, |x| x];\n+    let _ = [foo as FnPointer, bar, |x| x];\n+    let _ = [foo, bar as FnPointer, |x| x];\n+    let _ = [foo, bar, (|x| x) as FnPointer];\n+    let _ = [foo as FnPointer, bar as FnPointer, |x| x];\n+\n+    // Closure is in a variable\n+    let x = |a| 2;\n+    let _ = match 0 {\n+        0 => foo as FnPointer,\n+        2 => x,\n+        _ => unimplemented!(),\n+    };\n+    let x = |a| 2;\n+    let _ = match 0 {\n+        2 => x,\n+        0 => foo as FnPointer,\n+        _ => unimplemented!(),\n+    };\n+    let x = |a| 2;\n+    let _ = [foo as FnPointer, x];\n+    let _ = [x, foo as FnPointer];\n+\n+    let x = |a| 2;\n+    let _ = [foo, bar, x];\n+    let x: FnPointer = |a| 2;\n+    let _ = [foo, bar, x];\n+    let x = |a| 2;\n+    let _ = [foo, bar as FnPointer, x];\n+    let x = |a| 2;\n+    let _ = [foo as FnPointer, bar, x];\n+    let x = |a| 2;\n+    let _ = [foo as FnPointer, bar as FnPointer, x];\n+}"}, {"sha": "3c5fe8a55027656ea72970caa1eb35bb1cd01421", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_run_pass.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_run_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_run_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_run_pass.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,59 @@\n+// run-pass\n+// Ensure non-capturing Closure passing CoerceMany work correctly.\n+fn foo(_: usize) -> usize {\n+    0\n+}\n+\n+fn bar(_: usize) -> usize {\n+    1\n+}\n+\n+fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+\n+fn main() {\n+    // Coerce result check\n+\n+    type FnPointer = fn(usize) -> usize;\n+\n+    let c = |x| x;\n+    let c_pointer: FnPointer = c;\n+    assert_eq!(c_pointer(42), 42);\n+\n+    let f = match 0 {\n+        0 => foo,\n+        1 => |_| 1,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 0);\n+\n+    let f = match 2 {\n+        2 => |_| 2,\n+        0 => foo,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 2);\n+\n+    let f = match 1 {\n+        0 => foo,\n+        1 => bar,\n+        2 => |_| 2,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 1);\n+\n+    let clo0 = |_: usize| 0;\n+    let clo1 = |_| 1;\n+    let clo2 = |_| 2;\n+    let f = match 0 {\n+        0 => clo0,\n+        1 => clo1,\n+        2 => clo2,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(f(42), 0);\n+\n+    let funcs = [add, |a, b| (a - b) as i32];\n+    assert_eq!([funcs[0](5, 5), funcs[1](5, 5)], [10, 0]);\n+}"}, {"sha": "76a0f2914103d5c304b4e70402f68664bed980f8", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_unsafe_0.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,22 @@\n+// Ensure we get unsafe function after coercion\n+unsafe fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+fn main() {\n+    // We can coerce non-capturing closure to unsafe function\n+    let foo = match \"+\" {\n+        \"+\" => add,\n+        \"-\" => |a, b| (a - b) as i32,\n+        _ => unimplemented!(),\n+    };\n+    let result: i32 = foo(5, 5); //~ ERROR call to unsafe function\n+\n+\n+    // We can coerce unsafe function to non-capturing closure\n+    let foo = match \"+\" {\n+        \"-\" => |a, b| (a - b) as i32,\n+        \"+\" => add,\n+        _ => unimplemented!(),\n+    };\n+    let result: i32 = foo(5, 5); //~ ERROR call to unsafe function\n+}"}, {"sha": "190b4792ebcbc5e563fb973e759584f79d179d90", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_unsafe_0.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_0.stderr?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,19 @@\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/closure_no_cap_coerce_many_unsafe_0.rs:12:23\n+   |\n+LL |     let result: i32 = foo(5, 5);\n+   |                       ^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/closure_no_cap_coerce_many_unsafe_0.rs:21:23\n+   |\n+LL |     let result: i32 = foo(5, 5);\n+   |                       ^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "a6d6125a1b9f9d689bb3242dac4ad04d8f5f128e", "filename": "src/test/ui/closures/closure_no_cap_coerce_many_unsafe_1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure_no_cap_coerce_many_unsafe_1.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+// Ensure we get correct unsafe function after coercion\n+unsafe fn add(a: i32, b: i32) -> i32 {\n+    a + b\n+}\n+fn main() {\n+    // We can coerce non-capturing closure to unsafe function\n+    let foo = match \"+\" {\n+        \"+\" => add,\n+        \"-\" => |a, b| (a - b) as i32,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(unsafe { foo(5, 5) }, 10);\n+\n+\n+    // We can coerce unsafe function to non-capturing closure\n+    let foo = match \"-\" {\n+        \"-\" => |a, b| (a - b) as i32,\n+        \"+\" => add,\n+        _ => unimplemented!(),\n+    };\n+    assert_eq!(unsafe { foo(5, 5) }, 0);\n+}"}, {"sha": "cd8dc486906bbb0559a79bb3bee3b79d5fc6cd52", "filename": "src/test/ui/closures/issue-46742.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fissue-46742.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fissue-46742.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-46742.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+fn main() {\n+    let _: i32 = (match \"\" {\n+        \"+\" => ::std::ops::Add::add,\n+        \"-\" => ::std::ops::Sub::sub,\n+        \"<\" => |a,b| (a < b) as i32,\n+        _ => unimplemented!(),\n+    })(5, 5);\n+}"}, {"sha": "ce1f2a0364764b3da61064f4e79989865f0dbc86", "filename": "src/test/ui/closures/issue-48109.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fissue-48109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fclosures%2Fissue-48109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-48109.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+fn useful(i: usize) -> usize {\n+    i\n+}\n+\n+fn useful2(i: usize) -> usize {\n+    i\n+}\n+\n+fn main() {\n+    for f in &[useful, useful2, |x| x] {\n+        println!(\"{}\", f(6));\n+    }\n+}"}, {"sha": "7df036c8e3a45ddbcb8b3cc1aefc57dca24d81ea", "filename": "src/test/ui/issues/issue-24036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.rs?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -10,7 +10,7 @@ fn closure_from_match() {\n         2 => |c| c - 1,\n         _ => |c| c - 1\n     };\n-    //~^^^ ERROR `match` arms have incompatible types\n+    //~^^^^ ERROR type annotations needed\n }\n \n fn main() { }"}, {"sha": "e6b8367f74fb56830708e4251c91ed79e4161d6a", "filename": "src/test/ui/issues/issue-24036.stderr", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58e644736521b2916a6734aa225603c539bfeeed/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24036.stderr?ref=58e644736521b2916a6734aa225603c539bfeeed", "patch": "@@ -11,24 +11,13 @@ LL |     x = |c| c + 1;\n    = note: no two closures, even if identical, have the same type\n    = help: consider boxing your closure and/or using it as a trait object\n \n-error[E0308]: `match` arms have incompatible types\n-  --> $DIR/issue-24036.rs:10:14\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-24036.rs:9:15\n    |\n-LL |       let x = match 1usize {\n-   |  _____________-\n-LL | |         1 => |c| c + 1,\n-   | |              --------- this is found to be of type `[closure@$DIR/issue-24036.rs:9:14: 9:23]`\n-LL | |         2 => |c| c - 1,\n-   | |              ^^^^^^^^^ expected closure, found a different closure\n-LL | |         _ => |c| c - 1\n-LL | |     };\n-   | |_____- `match` arms have incompatible types\n-   |\n-   = note: expected type `[closure@$DIR/issue-24036.rs:9:14: 9:23]`\n-           found closure `[closure@$DIR/issue-24036.rs:10:14: 10:23]`\n-   = note: no two closures, even if identical, have the same type\n-   = help: consider boxing your closure and/or using it as a trait object\n+LL |         1 => |c| c + 1,\n+   |               ^ consider giving this closure parameter a type\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}]}