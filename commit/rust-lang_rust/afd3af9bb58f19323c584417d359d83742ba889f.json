{"sha": "afd3af9bb58f19323c584417d359d83742ba889f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZDNhZjliYjU4ZjE5MzIzYzU4NDQxN2QzNTlkODM3NDJiYTg4OWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-04T00:55:59Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-04T00:55:59Z"}, "message": "rustc: Remove LLVM unions and represent tags as (discriminant, byte blob) pairs", "tree": {"sha": "1b4a916c86cdcf3dabc0fe773fd8f82b52c4afe6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4a916c86cdcf3dabc0fe773fd8f82b52c4afe6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd3af9bb58f19323c584417d359d83742ba889f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd3af9bb58f19323c584417d359d83742ba889f", "html_url": "https://github.com/rust-lang/rust/commit/afd3af9bb58f19323c584417d359d83742ba889f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd3af9bb58f19323c584417d359d83742ba889f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f371dc613adb41a9d62eecc9dd7dbde92b5f38a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f371dc613adb41a9d62eecc9dd7dbde92b5f38a2", "html_url": "https://github.com/rust-lang/rust/commit/f371dc613adb41a9d62eecc9dd7dbde92b5f38a2"}], "stats": {"total": 119, "additions": 80, "deletions": 39}, "files": [{"sha": "6063c3c653f45459e8732152a67ab950b87663cd", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/afd3af9bb58f19323c584417d359d83742ba889f/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd3af9bb58f19323c584417d359d83742ba889f/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=afd3af9bb58f19323c584417d359d83742ba889f", "patch": "@@ -14,6 +14,7 @@ import llvm.ModuleProviderRef;\n import llvm.MemoryBufferRef;\n import llvm.PassManagerRef;\n import llvm.UseRef;\n+import llvm.TargetDataRef;\n import llvm.Linkage;\n import llvm.Attribute;\n import llvm.Visibility;\n@@ -69,6 +70,7 @@ native mod llvm = llvm_lib {\n     type MemoryBufferRef;\n     type PassManagerRef;\n     type UseRef;\n+    type TargetDataRef;\n \n     /* FIXME: These are enums in the C header. Represent them how, in rust? */\n     type Linkage;\n@@ -167,13 +169,6 @@ native mod llvm = llvm_lib {\n     fn LLVMGetStructElementTypes(TypeRef StructTy, vbuf Dest);\n     fn LLVMIsPackedStruct(TypeRef StructTy) -> Bool;\n \n-    /* Operations on union types */\n-    fn LLVMUnionTypeInContext(ContextRef C, vbuf ElementTypes,\n-                              uint ElementCount) -> TypeRef;\n-    fn LLVMUnionType(vbuf ElementTypes, uint ElementCount) -> TypeRef;\n-    fn LLVMCountUnionElementTypes(TypeRef UnionTy) -> uint;\n-    fn LLVMGetUnionElementTypes(TypeRef UnionTy, vbuf Dest);\n-\n     /* Operations on array, pointer, and vector types (sequence types) */\n     fn LLVMArrayType(TypeRef ElementType, uint ElementCount) -> TypeRef;\n     fn LLVMPointerType(TypeRef ElementType, uint AddressSpace) -> TypeRef;\n@@ -261,7 +256,6 @@ native mod llvm = llvm_lib {\n     fn LLVMConstStruct(vbuf ConstantVals, uint Count,\n                        Bool Packed) -> ValueRef;\n     fn LLVMConstVector(vbuf ScalarConstantVals, uint Size) -> ValueRef;\n-    fn LLVMConstUnion(TypeRef Ty, ValueRef Val) -> ValueRef;\n \n     /* Constant expressions */\n     fn LLVMAlignOf(TypeRef Ty) -> ValueRef;\n@@ -684,6 +678,15 @@ native mod llvm = llvm_lib {\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n     fn LLVMWriteBitcodeToFile(ModuleRef M, sbuf Path) -> int;\n+\n+    /** Creates target data from a target layout string. */\n+    fn LLVMCreateTargetData(sbuf StringRep) -> TargetDataRef;\n+    /** Returns the size of a type. FIXME: rv is actually a ULongLong! */\n+    fn LLVMStoreSizeOfType(TargetDataRef TD, TypeRef Ty) -> uint;\n+    /** Returns the alignment of a type. */\n+    fn LLVMPreferredAlignmentOfType(TargetDataRef TD, TypeRef Ty) -> uint;\n+    /** Disposes target data. */\n+    fn LLVMDisposeTargetData(TargetDataRef TD);\n }\n \n /* Slightly more terse object-interface to LLVM's 'builder' functions. */\n@@ -1186,14 +1189,26 @@ fn type_to_str(TypeRef ty) -> str {\n         case (12) { ret \"Opaque\"; }\n         case (13) { ret \"Vector\"; }\n         case (14) { ret \"Metadata\"; }\n-        case (15) { ret \"Union\"; }\n         case (_) {\n             log \"unknown TypeKind\" + util.common.istr(kind as int);\n             fail;\n         }\n     }\n }\n \n+/* Memory-managed interface to target data. */\n+\n+obj target_data_dtor(TargetDataRef TD) {\n+    drop { llvm.LLVMDisposeTargetData(TD); }\n+}\n+\n+type target_data = rec(TargetDataRef lltd, target_data_dtor dtor);\n+\n+fn mk_target_data(str string_rep) -> target_data {\n+    auto lltd = llvm.LLVMCreateTargetData(_str.buf(string_rep));\n+    ret rec(lltd=lltd, dtor=target_data_dtor(lltd));\n+}\n+\n \n //\n // Local Variables:"}, {"sha": "ae8408c2c43e64622a3f0e08d75fe9f42ca753c6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 56, "deletions": 30, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/afd3af9bb58f19323c584417d359d83742ba889f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd3af9bb58f19323c584417d359d83742ba889f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=afd3af9bb58f19323c584417d359d83742ba889f", "patch": "@@ -21,8 +21,10 @@ import util.common.new_str_hash;\n \n import lib.llvm.llvm;\n import lib.llvm.builder;\n+import lib.llvm.target_data;\n import lib.llvm.type_handle;\n import lib.llvm.mk_type_handle;\n+import lib.llvm.mk_target_data;\n import lib.llvm.llvm.ModuleRef;\n import lib.llvm.llvm.ValueRef;\n import lib.llvm.llvm.TypeRef;\n@@ -47,10 +49,12 @@ type glue_fns = rec(ValueRef activate_glue,\n \n tag arity { nullary; n_ary; }\n type tag_info = rec(type_handle th,\n-                    mutable vec[tup(ast.def_id,arity)] variants);\n+                    mutable vec[tup(ast.def_id,arity)] variants,\n+                    mutable uint size);\n \n state type crate_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n+                            target_data td,\n                             hashmap[str, ValueRef] upcalls,\n                             hashmap[str, ValueRef] intrinsics,\n                             hashmap[str, ValueRef] item_names,\n@@ -187,11 +191,6 @@ fn T_struct(vec[TypeRef] elts) -> TypeRef {\n                             False);\n }\n \n-fn T_union(vec[TypeRef] elts) -> TypeRef {\n-    ret llvm.LLVMUnionType(_vec.buf[TypeRef](elts),\n-                           _vec.len[TypeRef](elts));\n-}\n-\n fn T_opaque() -> TypeRef {\n     ret llvm.LLVMOpaqueType();\n }\n@@ -369,6 +368,17 @@ fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n     ret g;\n }\n \n+fn C_zero_byte_arr(uint size) -> ValueRef {\n+    auto i = 0u;\n+    let vec[ValueRef] elts = vec();\n+    while (i < size) {\n+        elts += vec(C_integral(0, T_i8()));\n+        i += 1u;\n+    }\n+    ret llvm.LLVMConstArray(T_i8(), _vec.buf[ValueRef](elts),\n+                            _vec.len[ValueRef](elts));\n+}\n+\n fn C_struct(vec[ValueRef] elts) -> ValueRef {\n     ret llvm.LLVMConstStruct(_vec.buf[ValueRef](elts),\n                              _vec.len[ValueRef](elts),\n@@ -388,10 +398,6 @@ fn C_tydesc(TypeRef t) -> ValueRef {\n                      C_null(T_ptr(T_opaque()))));      // is_stateful\n }\n \n-fn C_union(TypeRef ty, ValueRef val) -> ValueRef {\n-    ret llvm.LLVMConstUnion(ty, val);\n-}\n-\n fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n@@ -538,6 +544,19 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n     ret res(next_cx, phi);\n }\n \n+fn type_of_variant(@crate_ctxt cx, &ast.variant v) -> TypeRef {\n+    let vec[TypeRef] lltys = vec();\n+    alt (typeck.ann_to_type(v.ann).struct) {\n+        case (typeck.ty_fn(?args, _)) {\n+            for (typeck.arg arg in args) {\n+                lltys += vec(type_of(cx, arg.ty));\n+            }\n+        }\n+        case (_) { fail; }\n+    }\n+    ret T_struct(lltys);\n+}\n+\n type val_and_ty_fn =\n     fn(@block_ctxt cx, ValueRef v, @typeck.ty t) -> result;\n \n@@ -611,18 +630,23 @@ fn iter_structural_ty(@block_ctxt cx,\n                         let vec[ValueRef] vals = vec(C_int(0), C_int(1),\n                                                      C_int(i as int));\n                         auto llvar = variant_cx.build.GEP(v, vals);\n+                        auto llvarty = type_of_variant(cx.fcx.ccx,\n+                                                       variants.(i));\n \n                         auto fn_ty = typeck.ann_to_type(variants.(i).ann);\n                         alt (fn_ty.struct) {\n                             case (typeck.ty_fn(?args, _)) {\n+                                auto llvarp = variant_cx.build.\n+                                    TruncOrBitCast(llunion_ptr,\n+                                                   T_ptr(llvarty));\n+\n                                 auto j = 0u;\n                                 for (typeck.arg a in args) {\n-                                    auto idx = vec(C_int(0), C_int(j as int));\n-                                    auto llfp = variant_cx.build.GEP(llvar,\n-                                                                     idx);\n+                                    auto llfldp = variant_cx.build.GEP(llvarp,\n+                                        vec(C_int(0), C_int(j as int)));\n                                     auto llfld =\n                                         load_non_structural(variant_cx,\n-                                                            llfp, a.ty);\n+                                                            llfldp, a.ty);\n \n                                     auto res = f(variant_cx, llfld, a.ty);\n                                     variant_cx = res.bcx;\n@@ -1891,7 +1915,8 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n             auto navi = new_def_hash[uint]();\n             let vec[tup(ast.def_id,arity)] variant_info = vec();\n             cx.tags.insert(tag_id, @rec(th=mk_type_handle(),\n-                                        mutable variants=variant_info));\n+                                        mutable variants=variant_info,\n+                                        mutable size=0u));\n             cx.items.insert(tag_id, i);\n         }\n \n@@ -1918,38 +1943,37 @@ fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n fn resolve_tag_types_for_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_tag(_, ?variants, _, ?tag_id)) {\n-            let vec[TypeRef] variant_tys = vec();\n+            auto max_align = 0u;\n+            auto max_size = 0u;\n \n             auto info = cx.tags.get(tag_id);\n             let vec[tup(ast.def_id,arity)] variant_info = vec();\n \n             for (ast.variant variant in variants) {\n                 auto arity_info;\n                 if (_vec.len[@ast.ty](variant.args) > 0u) {\n-                    let vec[TypeRef] lltys = vec();\n-\n-                    alt (typeck.ann_to_type(variant.ann).struct) {\n-                        case (typeck.ty_fn(?args, _)) {\n-                            for (typeck.arg arg in args) {\n-                                lltys += vec(type_of(cx, arg.ty));\n-                            }\n-                        }\n-                        case (_) { fail; }\n-                    }\n+                    auto llvariantty = type_of_variant(cx, variant);\n+                    auto align = llvm.LLVMPreferredAlignmentOfType(cx.td.lltd,\n+                                                                 llvariantty);\n+                    auto size = llvm.LLVMStoreSizeOfType(cx.td.lltd,\n+                                                         llvariantty) as uint;\n+                    if (max_align < align) { max_align = align; }\n+                    if (max_size < size) { max_size = size; }\n \n-                    variant_tys += vec(T_struct(lltys));\n                     arity_info = n_ary;\n                 } else {\n-                    variant_tys += vec(T_nil());\n                     arity_info = nullary;\n                 }\n \n                 variant_info += vec(tup(variant.id, arity_info));\n             }\n \n             info.variants = variant_info;\n+            info.size = max_size;\n \n-            auto tag_ty = T_struct(vec(T_int(), T_union(variant_tys)));\n+            // FIXME: alignment is wrong here, manually insert padding I\n+            // guess :(\n+            auto tag_ty = T_struct(vec(T_int(), T_array(T_i8(), max_size)));\n             auto th = cx.tags.get(tag_id).th.llth;\n             llvm.LLVMRefineType(llvm.LLVMResolveTypeHandle(th), tag_ty);\n         }\n@@ -1990,7 +2014,7 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                 alt (variant_info._1) {\n                     case (nullary) {\n                         // Nullary tags become constants.\n-                        auto union_val = C_union(union_ty, C_nil());\n+                        auto union_val = C_zero_byte_arr(info.size as uint);\n                         auto val = C_struct(vec(C_int(i as int), union_val));\n \n                         // FIXME: better name\n@@ -2153,6 +2177,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n \n     llvm.LLVMSetDataLayout(llmod, _str.buf(x86.get_data_layout()));\n     llvm.LLVMSetTarget(llmod, _str.buf(x86.get_target_triple()));\n+    auto td = mk_target_data(x86.get_data_layout());\n \n     llvm.LLVMSetModuleInlineAsm(llmod, _str.buf(x86.get_module_asm()));\n \n@@ -2183,6 +2208,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n \n     auto cx = @rec(sess = sess,\n                    llmod = llmod,\n+                   td = td,\n                    upcalls = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,\n                    item_names = new_str_hash[ValueRef](),"}]}