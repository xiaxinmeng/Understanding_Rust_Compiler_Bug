{"sha": "974e17b9ea63b38b4a512742fc877a7e4ee94e03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NGUxN2I5ZWE2M2IzOGI0YTUxMjc0MmZjODc3YTdlNGVlOTRlMDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T16:33:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-17T19:50:24Z"}, "message": "rollup merge of #19770: csouth3/iterator-wrapperstructs\n\nUsing a type alias for iterator implementations is fragile since this exposes the implementation to users of the iterator, and any changes could break existing code.\n\nThis PR changes the iterators of `BTreeMap`, `BTreeSet`, `HashMap`, and `HashSet` to use proper new types, rather than type aliases.  However, since it is fair-game to treat a type-alias as the aliased type, this is a:\n\n[breaking-change].", "tree": {"sha": "dc63380c7fcc1f2dcad8ff2ffa5d0a46c056c8cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc63380c7fcc1f2dcad8ff2ffa5d0a46c056c8cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/974e17b9ea63b38b4a512742fc877a7e4ee94e03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/974e17b9ea63b38b4a512742fc877a7e4ee94e03", "html_url": "https://github.com/rust-lang/rust/commit/974e17b9ea63b38b4a512742fc877a7e4ee94e03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/974e17b9ea63b38b4a512742fc877a7e4ee94e03/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126a83f433db665cf6ad6389070104dff5b1eccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/126a83f433db665cf6ad6389070104dff5b1eccc", "html_url": "https://github.com/rust-lang/rust/commit/126a83f433db665cf6ad6389070104dff5b1eccc"}, {"sha": "341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "url": "https://api.github.com/repos/rust-lang/rust/commits/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "html_url": "https://github.com/rust-lang/rust/commit/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26"}], "stats": {"total": 216, "additions": 146, "deletions": 70}, "files": [{"sha": "f7d73c1044263f59d7a29a20700c61e98b46c0b9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=974e17b9ea63b38b4a512742fc877a7e4ee94e03", "patch": "@@ -29,6 +29,7 @@ use std::hash::{Writer, Hash};\n use core::default::Default;\n use core::{iter, fmt, mem};\n use core::fmt::Show;\n+use core::iter::Map;\n \n use ring_buf::RingBuf;\n \n@@ -110,12 +111,14 @@ pub struct MoveEntries<K, V> {\n }\n \n /// An iterator over a BTreeMap's keys.\n-pub type Keys<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n+pub struct Keys<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+}\n \n /// An iterator over a BTreeMap's values.\n-pub type Values<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n+pub struct Values<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+}\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n pub enum Entry<'a, K:'a, V:'a> {\n@@ -1054,6 +1057,25 @@ impl<K, V> DoubleEndedIterator<(K, V)> for MoveEntries<K, V> {\n impl<K, V> ExactSizeIterator<(K, V)> for MoveEntries<K, V> {}\n \n \n+impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<&'a K> for Keys<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSizeIterator<&'a K> for Keys<'a, K, V> {}\n+\n+\n+impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+impl<'a, K, V> DoubleEndedIterator<&'a V> for Values<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n+}\n+impl<'a, K, V> ExactSizeIterator<&'a V> for Values<'a, K, V> {}\n+\n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n@@ -1204,7 +1226,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.iter().map(first)\n+        Keys { inner: self.iter().map(first) }\n     }\n \n     /// Gets an iterator over the values of the map.\n@@ -1225,7 +1247,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n \n-        self.iter().map(second)\n+        Values { inner: self.iter().map(second) }\n     }\n \n     /// Return the number of elements in the map."}, {"sha": "dbba5ebdc9968eaabc3f531dd9884498524e53b4", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=974e17b9ea63b38b4a512742fc877a7e4ee94e03", "patch": "@@ -17,8 +17,8 @@ use btree_map::{BTreeMap, Keys, MoveEntries};\n use std::hash::Hash;\n use core::borrow::BorrowFrom;\n use core::default::Default;\n-use core::{iter, fmt};\n-use core::iter::Peekable;\n+use core::fmt;\n+use core::iter::{Peekable, Map};\n use core::fmt::Show;\n \n // FIXME(conventions): implement bounded iterators\n@@ -33,11 +33,14 @@ pub struct BTreeSet<T>{\n }\n \n /// An iterator over a BTreeSet's items.\n-pub type Items<'a, T> = Keys<'a, T, ()>;\n+pub struct Items<'a, T: 'a> {\n+    iter: Keys<'a, T, ()>\n+}\n \n /// An owning iterator over a BTreeSet's items.\n-pub type MoveItems<T> =\n-    iter::Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>;\n+pub struct MoveItems<T> {\n+    iter: Map<(T, ()), T, MoveEntries<T, ()>, fn((T, ())) -> T>\n+}\n \n /// A lazy iterator producing elements in the set difference (in-order).\n pub struct DifferenceItems<'a, T:'a> {\n@@ -105,7 +108,7 @@ impl<T> BTreeSet<T> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Items<'a, T> {\n-        self.map.keys()\n+        Items { iter: self.map.keys() }\n     }\n \n     /// Gets an iterator for moving out the BtreeSet's contents.\n@@ -124,7 +127,7 @@ impl<T> BTreeSet<T> {\n     pub fn into_iter(self) -> MoveItems<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.map.into_iter().map(first)\n+        MoveItems { iter: self.map.into_iter().map(first) }\n     }\n }\n \n@@ -635,6 +638,25 @@ impl<T: Show> Show for BTreeSet<T> {\n     }\n }\n \n+impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<'a, T> DoubleEndedIterator<&'a T> for Items<'a, T> {\n+    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+}\n+impl<'a, T> ExactSizeIterator<&'a T> for Items<'a, T> {}\n+\n+\n+impl<T> Iterator<T> for MoveItems<T> {\n+    fn next(&mut self) -> Option<T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n+    fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n+}\n+impl<T> ExactSizeIterator<T> for MoveItems<T> {}\n+\n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {"}, {"sha": "d22e7b2f764f50262a9fceee9487ea1221737778", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=974e17b9ea63b38b4a512742fc877a7e4ee94e03", "patch": "@@ -20,7 +20,7 @@ use cmp::{max, Eq, Equiv, PartialEq};\n use default::Default;\n use fmt::{mod, Show};\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{mod, Iterator, IteratorExt, FromIterator, Extend};\n+use iter::{mod, Iterator, IteratorExt, FromIterator, Extend, Map};\n use kinds::Sized;\n use mem::{mod, replace};\n use num::{Int, UnsignedInt};\n@@ -859,7 +859,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn keys(&self) -> Keys<K, V> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.iter().map(first)\n+        Keys { inner: self.iter().map(first) }\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n@@ -883,7 +883,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn values(&self) -> Values<K, V> {\n         fn second<A, B>((_, b): (A, B)) -> B { b }\n \n-        self.iter().map(second)\n+        Values { inner: self.iter().map(second) }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n@@ -1335,6 +1335,16 @@ pub struct MoveEntries<K, V> {\n     >\n }\n \n+/// HashMap keys iterator\n+pub struct Keys<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+}\n+\n+/// HashMap values iterator\n+pub struct Values<'a, K: 'a, V: 'a> {\n+    inner: Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+}\n+\n /// A view into a single occupied location in a HashMap\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n@@ -1365,36 +1375,28 @@ enum VacantEntryState<K, V, M> {\n }\n \n impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n-        self.inner.next()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.inner.size_hint()\n-    }\n+    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n-        self.inner.next()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.inner.size_hint()\n-    }\n+    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n impl<K, V> Iterator<(K, V)> for MoveEntries<K, V> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(K, V)> {\n-        self.inner.next()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.inner.size_hint()\n-    }\n+    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+}\n+\n+impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n@@ -1448,14 +1450,6 @@ impl<'a, K, V> VacantEntry<'a, K, V> {\n     }\n }\n \n-/// HashMap keys iterator\n-pub type Keys<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a K, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>;\n-\n-/// HashMap values iterator\n-pub type Values<'a, K, V> =\n-    iter::Map<(&'a K, &'a V), &'a V, Entries<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>;\n-\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n     fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {\n         let (lower, _) = iter.size_hint();"}, {"sha": "c4356d910641592b54249e415bfa5bff8a78443d", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/974e17b9ea63b38b4a512742fc877a7e4ee94e03/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=974e17b9ea63b38b4a512742fc877a7e4ee94e03", "patch": "@@ -17,12 +17,11 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, IteratorExt, FromIterator, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n-use iter;\n+use iter::{Iterator, IteratorExt, FromIterator, Map, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n-use super::map::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n+use super::map::{HashMap, MoveEntries, Keys, INITIAL_CAPACITY};\n \n // FIXME(conventions): implement BitOr, BitAnd, BitXor, and Sub\n \n@@ -252,7 +251,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        self.map.keys()\n+        SetItems { iter: self.map.keys() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n@@ -279,7 +278,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     pub fn into_iter(self) -> SetMoveItems<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.map.into_iter().map(first)\n+        SetMoveItems { iter: self.map.into_iter().map(first) }\n     }\n \n     /// Visit the values representing the difference.\n@@ -312,7 +311,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             if !other.contains(elt) { Some(elt) } else { None }\n         }\n \n-        repeat(other).zip(self.iter()).filter_map(filter)\n+        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the symmetric difference.\n@@ -337,8 +336,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n-        self.difference(other).chain(other.difference(self))\n+        -> SymDifferenceItems<'a, T, H> {\n+        SymDifferenceItems { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n     /// Visit the values representing the intersection.\n@@ -366,7 +365,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             if other.contains(elt) { Some(elt) } else { None }\n         }\n \n-        repeat(other).zip(self.iter()).filter_map(filter)\n+        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the union.\n@@ -387,9 +386,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n-        self.iter().chain(other.difference(self))\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> UnionItems<'a, T, H> {\n+        UnionItems { iter: self.iter().chain(other.difference(self)) }\n     }\n \n     /// Return the number of elements in the set\n@@ -617,21 +615,61 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n }\n \n /// HashSet iterator\n-pub type SetItems<'a, K> =\n-    iter::Map<(&'a K, &'a ()), &'a K, Entries<'a, K, ()>, fn((&'a K, &'a ())) -> &'a K>;\n+pub struct SetItems<'a, K: 'a> {\n+    iter: Keys<'a, K, ()>\n+}\n \n /// HashSet move iterator\n-pub type SetMoveItems<K> = iter::Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>;\n+pub struct SetMoveItems<K> {\n+    iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n+}\n \n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n-/// Set operations iterator\n-pub type SetAlgebraItems<'a, T, H> = FilterMap<\n-    (&'a HashSet<T, H>, &'a T),\n-    &'a T,\n-    Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n-    for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n->;\n+/// Set operations iterator, used directly for intersection and difference\n+pub struct SetAlgebraItems<'a, T: 'a, H: 'a> {\n+    iter: FilterMap<\n+        (&'a HashSet<T, H>, &'a T),\n+        &'a T,\n+        Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n+        for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n+    >\n+}\n+\n+/// Symmetric difference iterator.\n+pub struct SymDifferenceItems<'a, T: 'a, H: 'a> {\n+    iter: Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>>\n+}\n+\n+/// Set union iterator.\n+pub struct UnionItems<'a, T: 'a, H: 'a> {\n+    iter: Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>>\n+}\n+\n+impl<'a, K> Iterator<&'a K> for SetItems<'a, K> {\n+    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<K> Iterator<K> for SetMoveItems<K> {\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for SetAlgebraItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for SymDifferenceItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for UnionItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n \n #[cfg(test)]\n mod test_set {"}]}