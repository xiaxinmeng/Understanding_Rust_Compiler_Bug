{"sha": "2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmN2E1ZjQ5MDI5Mjc5YmQ3MzRlZjg3ZmQ2NWFlOTkyYjJhZDlmNDA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T03:04:23Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T15:47:04Z"}, "message": "libcore: make iterator adaptors `Clone`able", "tree": {"sha": "14f7ea79b795ed88a001e510efbf5807828a1f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f7ea79b795ed88a001e510efbf5807828a1f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "html_url": "https://github.com/rust-lang/rust/commit/2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/comments", "author": null, "committer": null, "parents": [{"sha": "444fa1b7cffcd99ca5b8abb51acf979f06a25899", "url": "https://api.github.com/repos/rust-lang/rust/commits/444fa1b7cffcd99ca5b8abb51acf979f06a25899", "html_url": "https://github.com/rust-lang/rust/commit/444fa1b7cffcd99ca5b8abb51acf979f06a25899"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "1eac8a39ebaec6b98afc45edb6d2afd6cec55bb3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "patch": "@@ -1388,6 +1388,19 @@ pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, F> Clone for Map<A, B, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(A) -> B,\n+{\n+    fn clone(&self) -> Map<A, B, I, F> {\n+        Map {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n     #[inline]\n     fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n@@ -1449,6 +1462,19 @@ pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for Filter<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> Filter<A, I, P> {\n+        Filter {\n+            iter: self.iter.clone(),\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1494,6 +1520,19 @@ pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B>\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(A) -> Option<B>,\n+{\n+    fn clone(&self) -> FilterMap<A, B, I, F> {\n+        FilterMap {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n     I: Iterator<A>,\n@@ -1657,6 +1696,20 @@ pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for SkipWhile<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> SkipWhile<A, I, P> {\n+        SkipWhile {\n+            iter: self.iter.clone(),\n+            flag: self.flag,\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1686,6 +1739,20 @@ pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     predicate: P,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, P> Clone for TakeWhile<A, I, P> where\n+    I: Clone + Iterator<A>,\n+    P: Clone + FnMut(&A) -> bool,\n+{\n+    fn clone(&self) -> TakeWhile<A, I, P> {\n+        TakeWhile {\n+            iter: self.iter.clone(),\n+            flag: self.flag,\n+            predicate: self.predicate.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n     #[inline]\n@@ -1847,6 +1914,21 @@ pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Op\n     pub state: St,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n+    I: Clone + Iterator<A>,\n+    St: Clone,\n+    F: Clone + FnMut(&mut St, A) -> Option<B>,\n+{\n+    fn clone(&self) -> Scan<A, B, I, St, F> {\n+        Scan {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+            state: self.state.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n     I: Iterator<A>,\n@@ -1876,6 +1958,22 @@ pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut\n     backiter: Option<U>,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n+    I: Clone + Iterator<A>,\n+    U: Clone + Iterator<B>,\n+    F: Clone + FnMut(A) -> U,\n+{\n+    fn clone(&self) -> FlatMap<A, B, I, U, F> {\n+        FlatMap {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+            frontiter: self.frontiter.clone(),\n+            backiter: self.backiter.clone(),\n+        }\n+    }\n+}\n+\n #[unstable = \"trait is unstable\"]\n impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n     I: Iterator<A>,\n@@ -2020,6 +2118,19 @@ pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     f: F,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, I, F> Clone for Inspect<A, I, F> where\n+    I: Clone + Iterator<A>,\n+    F: Clone + FnMut(&A),\n+{\n+    fn clone(&self) -> Inspect<A, I, F> {\n+        Inspect {\n+            iter: self.iter.clone(),\n+            f: self.f.clone(),\n+        }\n+    }\n+}\n+\n impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n@@ -2114,6 +2225,19 @@ pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     pub state: St,\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<A, St, F> Clone for Unfold<A, St, F> where\n+    F: Clone + FnMut(&mut St) -> Option<A>,\n+    St: Clone,\n+{\n+    fn clone(&self) -> Unfold<A, St, F> {\n+        Unfold {\n+            f: self.f.clone(),\n+            state: self.state.clone(),\n+        }\n+    }\n+}\n+\n #[experimental]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator"}, {"sha": "059292c11f24f4181af0b3e7430e855e146d4096", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "patch": "@@ -1291,6 +1291,17 @@ pub struct Splits<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n+// FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n+impl<'a, T, P> Clone for Splits<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Splits<'a, T, P> {\n+        Splits {\n+            v: self.v,\n+            pred: self.pred.clone(),\n+            finished: self.finished,\n+        }\n+    }\n+}\n+\n #[experimental = \"needs review\"]\n impl<'a, T, P> Iterator<&'a [T]> for Splits<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]"}, {"sha": "ef68daa8ce592a594d30e4b0b1fc1f5287b98024", "filename": "src/test/run-pass/issue-12677.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/src%2Ftest%2Frun-pass%2Fissue-12677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f7a5f49029279bd734ef87fd65ae992b2ad9f40/src%2Ftest%2Frun-pass%2Fissue-12677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12677.rs?ref=2f7a5f49029279bd734ef87fd65ae992b2ad9f40", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let s = \"Hello\";\n+    let first = s.bytes();\n+    let second = first.clone();\n+\n+    assert_eq!(first.collect::<Vec<u8>>(), second.collect::<Vec<u8>>())\n+}"}]}