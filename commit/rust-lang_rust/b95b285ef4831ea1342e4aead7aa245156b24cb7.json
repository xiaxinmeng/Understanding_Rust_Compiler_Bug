{"sha": "b95b285ef4831ea1342e4aead7aa245156b24cb7", "node_id": "C_kwDOAAsO6NoAKGI5NWIyODVlZjQ4MzFlYTEzNDJlNGFlYWQ3YWEyNDUxNTZiMjRjYjc", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-08-30T19:39:28Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-09-13T00:29:11Z"}, "message": "Make x.py check work", "tree": {"sha": "b7edebb7be761cb472fc25ec6ae323565eebfff2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7edebb7be761cb472fc25ec6ae323565eebfff2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b95b285ef4831ea1342e4aead7aa245156b24cb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b95b285ef4831ea1342e4aead7aa245156b24cb7", "html_url": "https://github.com/rust-lang/rust/commit/b95b285ef4831ea1342e4aead7aa245156b24cb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b95b285ef4831ea1342e4aead7aa245156b24cb7/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e313a50b20ad3a2eaabceecb3505b523202c750", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e313a50b20ad3a2eaabceecb3505b523202c750", "html_url": "https://github.com/rust-lang/rust/commit/4e313a50b20ad3a2eaabceecb3505b523202c750"}], "stats": {"total": 335, "additions": 204, "deletions": 131}, "files": [{"sha": "78cc589cc291bbed1e0f1451a156c57cc5425cc5", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b95b285ef4831ea1342e4aead7aa245156b24cb7/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b95b285ef4831ea1342e4aead7aa245156b24cb7/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=b95b285ef4831ea1342e4aead7aa245156b24cb7", "patch": "@@ -2,11 +2,18 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n-use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n+use rustc_typeck::check::{\n+    cast::{self, CastCheckResult},\n+    FnCtxt, Inherited,\n+};\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n-pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+pub(super) fn is_layout_incompatible<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    from: Ty<'tcx>,\n+    to: Ty<'tcx>,\n+) -> bool {\n     if let Ok(from) = cx.tcx.try_normalize_erasing_regions(cx.param_env, from)\n         && let Ok(to) = cx.tcx.try_normalize_erasing_regions(cx.param_env, to)\n         && let Ok(from_layout) = cx.tcx.layout_of(cx.param_env.and(from))\n@@ -29,7 +36,9 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) -> bool {\n-    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n+    use CastKind::{\n+        AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast,\n+    };\n     matches!(\n         check_cast(cx, e, from_ty, to_ty),\n         Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n@@ -40,20 +49,22 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n /// the cast. In certain cases, including some invalid casts from array references\n /// to pointers, this may cause additional errors to be emitted and/or ICE error\n /// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n+fn check_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> Option<CastKind> {\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner;\n \n     Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n         let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n \n         // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(\n-            !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n-        );\n+        assert!(!fn_ctxt.errors_reported_since_creation(), \"Newly created FnCtxt contained errors\");\n \n-        if let Ok(check) = CastCheck::new(\n+        if let CastCheckResult::Deferred(check) = cast::check_cast(\n             &fn_ctxt, e, from_ty, to_ty,\n             // We won't show any error to the user, so we don't care what the span is here.\n             DUMMY_SP, DUMMY_SP,"}, {"sha": "781744870cb9194ef1f4f852560c39da86c455df", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 86, "deletions": 55, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/b95b285ef4831ea1342e4aead7aa245156b24cb7/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b95b285ef4831ea1342e4aead7aa245156b24cb7/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=b95b285ef4831ea1342e4aead7aa245156b24cb7", "patch": "@@ -18,7 +18,11 @@ use std::borrow::Cow;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<RustcVersion>) -> McfResult {\n+pub fn is_min_const_fn<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+    msrv: Option<RustcVersion>,\n+) -> McfResult {\n     let def_id = body.source.def_id();\n     let mut current = def_id;\n     loop {\n@@ -33,10 +37,18 @@ pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv:\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n-                ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n-                ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n-                ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n-                ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::ObjectSafe(_) => {\n+                    panic!(\"object safe predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateKind::ClosureKind(..) => {\n+                    panic!(\"closure kind predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateKind::Subtype(_) => {\n+                    panic!(\"subtype predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateKind::Coerce(_) => {\n+                    panic!(\"coerce predicate on function: {:#?}\", predicate)\n+                }\n             }\n         }\n         match predicates.parent {\n@@ -77,22 +89,23 @@ fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n         match ty.kind() {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 return Err((span, \"mutable references in const fn are unstable\".into()));\n-            },\n+            }\n             ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n             ty::FnPtr(..) => {\n                 return Err((span, \"function pointers in const fn are unstable\".into()));\n-            },\n-            ty::Dynamic(preds, _) => {\n+            }\n+            ty::Dynamic(preds, _, _) => {\n                 for pred in preds.iter() {\n                     match pred.skip_binder() {\n-                        ty::ExistentialPredicate::AutoTrait(_) | ty::ExistentialPredicate::Projection(_) => {\n+                        ty::ExistentialPredicate::AutoTrait(_)\n+                        | ty::ExistentialPredicate::Projection(_) => {\n                             return Err((\n                                 span,\n                                 \"trait bounds other than `Sized` \\\n                                  on const fn parameters are unstable\"\n                                     .into(),\n                             ));\n-                        },\n+                        }\n                         ty::ExistentialPredicate::Trait(trait_ref) => {\n                             if Some(trait_ref.def_id) != tcx.lang_items().sized_trait() {\n                                 return Err((\n@@ -102,11 +115,11 @@ fn check_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n                                         .into(),\n                                 ));\n                             }\n-                        },\n+                        }\n                     }\n                 }\n-            },\n-            _ => {},\n+            }\n+            _ => {}\n         }\n     }\n     Ok(())\n@@ -120,10 +133,13 @@ fn check_rvalue<'tcx>(\n     span: Span,\n ) -> McfResult {\n     match rvalue {\n-        Rvalue::ThreadLocalRef(_) => Err((span, \"cannot access thread local storage in const fn\".into())),\n-        Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-            check_place(tcx, *place, span, body)\n-        },\n+        Rvalue::ThreadLocalRef(_) => {\n+            Err((span, \"cannot access thread local storage in const fn\".into()))\n+        }\n+        Rvalue::Len(place)\n+        | Rvalue::Discriminant(place)\n+        | Rvalue::Ref(_, _, place)\n+        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, body),\n         Rvalue::CopyForDeref(place) => check_place(tcx, *place, span, body),\n         Rvalue::Repeat(operand, _)\n         | Rvalue::Use(operand)\n@@ -136,7 +152,9 @@ fn check_rvalue<'tcx>(\n         ) => check_operand(tcx, operand, span, body),\n         Rvalue::Cast(\n             CastKind::Pointer(\n-                PointerCast::UnsafeFnPointer | PointerCast::ClosureFnPointer(_) | PointerCast::ReifyFnPointer,\n+                PointerCast::UnsafeFnPointer\n+                | PointerCast::ClosureFnPointer(_)\n+                | PointerCast::ReifyFnPointer,\n             ),\n             _,\n             _,\n@@ -146,7 +164,10 @@ fn check_rvalue<'tcx>(\n                 deref_ty.ty\n             } else {\n                 // We cannot allow this for now.\n-                return Err((span, \"unsizing casts are only allowed for references right now\".into()));\n+                return Err((\n+                    span,\n+                    \"unsizing casts are only allowed for references right now\".into(),\n+                ));\n             };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n             if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n@@ -157,10 +178,14 @@ fn check_rvalue<'tcx>(\n                 // We just can't allow trait objects until we have figured out trait method calls.\n                 Err((span, \"unsizing casts are not allowed in const fn\".into()))\n             }\n-        },\n+        }\n         Rvalue::Cast(CastKind::PointerExposeAddress, _, _) => {\n             Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n-        },\n+        }\n+        Rvalue::Cast(CastKind::DynStar, _, _) => {\n+            // FIXME(dyn-star)\n+            unimplemented!()\n+        }\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, box (lhs, rhs)) | Rvalue::CheckedBinaryOp(_, box (lhs, rhs)) => {\n             check_operand(tcx, lhs, span, body)?;\n@@ -169,27 +194,26 @@ fn check_rvalue<'tcx>(\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n             } else {\n-                Err((\n-                    span,\n-                    \"only int, `bool` and `char` operations are stable in const fn\".into(),\n-                ))\n+                Err((span, \"only int, `bool` and `char` operations are stable in const fn\".into()))\n             }\n-        },\n-        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) | Rvalue::ShallowInitBox(_, _) => Ok(()),\n+        }\n+        Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) | Rvalue::ShallowInitBox(_, _) => {\n+            Ok(())\n+        }\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {\n                 check_operand(tcx, operand, span, body)\n             } else {\n                 Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n             }\n-        },\n+        }\n         Rvalue::Aggregate(_, operands) => {\n             for operand in operands {\n                 check_operand(tcx, operand, span, body)?;\n             }\n             Ok(())\n-        },\n+        }\n     }\n }\n \n@@ -204,7 +228,7 @@ fn check_statement<'tcx>(\n         StatementKind::Assign(box (place, rval)) => {\n             check_place(tcx, *place, span, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n-        },\n+        }\n \n         StatementKind::FakeRead(box (_, place)) => check_place(tcx, *place, span, body),\n         // just an assignment\n@@ -214,14 +238,15 @@ fn check_statement<'tcx>(\n \n         StatementKind::Intrinsic(box NonDivergingIntrinsic::Assume(op)) => check_operand(tcx, op, span, body),\n \n-        StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(\n-            rustc_middle::mir::CopyNonOverlapping { dst, src, count },\n-        )) => {\n+        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n+            dst,\n+            src,\n+            count,\n+        }) => {\n             check_operand(tcx, dst, span, body)?;\n             check_operand(tcx, src, span, body)?;\n             check_operand(tcx, count, span, body)\n-        },\n-\n+        }\n         // These are all NOPs\n         StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n@@ -232,7 +257,12 @@ fn check_statement<'tcx>(\n     }\n }\n \n-fn check_operand<'tcx>(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n+fn check_operand<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    operand: &Operand<'tcx>,\n+    span: Span,\n+    body: &Body<'tcx>,\n+) -> McfResult {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n@@ -242,7 +272,12 @@ fn check_operand<'tcx>(tcx: TyCtxt<'tcx>, operand: &Operand<'tcx>, span: Span, b\n     }\n }\n \n-fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &Body<'tcx>) -> McfResult {\n+fn check_place<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    place: Place<'tcx>,\n+    span: Span,\n+    body: &Body<'tcx>,\n+) -> McfResult {\n     let mut cursor = place.projection.as_ref();\n     while let [ref proj_base @ .., elem] = *cursor {\n         cursor = proj_base;\n@@ -255,12 +290,12 @@ fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &B\n                         return Err((span, \"accessing union fields is unstable\".into()));\n                     }\n                 }\n-            },\n+            }\n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Deref\n-            | ProjectionElem::Index(_) => {},\n+            | ProjectionElem::Index(_) => {}\n         }\n     }\n \n@@ -286,18 +321,16 @@ fn check_terminator<'a, 'tcx>(\n         TerminatorKind::DropAndReplace { place, value, .. } => {\n             check_place(tcx, *place, span, body)?;\n             check_operand(tcx, value, span, body)\n-        },\n+        }\n \n-        TerminatorKind::SwitchInt {\n-            discr,\n-            switch_ty: _,\n-            targets: _,\n-        } => check_operand(tcx, discr, span, body),\n+        TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n+            check_operand(tcx, discr, span, body)\n+        }\n \n         TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n         TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n             Err((span, \"const fn generators are unstable\".into()))\n-        },\n+        }\n \n         TerminatorKind::Call {\n             func,\n@@ -342,17 +375,15 @@ fn check_terminator<'a, 'tcx>(\n             } else {\n                 Err((span, \"can only call other const fns within const fn\".into()))\n             }\n-        },\n+        }\n \n-        TerminatorKind::Assert {\n-            cond,\n-            expected: _,\n-            msg: _,\n-            target: _,\n-            cleanup: _,\n-        } => check_operand(tcx, cond, span, body),\n+        TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n+            check_operand(tcx, cond, span, body)\n+        }\n \n-        TerminatorKind::InlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n+        TerminatorKind::InlineAsm { .. } => {\n+            Err((span, \"cannot use inline assembly in const fn\".into()))\n+        }\n     }\n }\n "}, {"sha": "99803ae93a712dd0d202d04ea4d590256b2dc4a8", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/b95b285ef4831ea1342e4aead7aa245156b24cb7/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b95b285ef4831ea1342e4aead7aa245156b24cb7/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=b95b285ef4831ea1342e4aead7aa245156b24cb7", "patch": "@@ -14,8 +14,9 @@ use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n-    Region, RegionKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind,\n+    ProjectionTy, Region, RegionKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    UintTy, VariantDef, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -166,9 +167,7 @@ pub fn implements_trait_with_env<'tcx>(\n     }\n     let ty_params = tcx.mk_substs(ty_params.iter());\n     tcx.infer_ctxt().enter(|infcx| {\n-        infcx\n-            .type_implements_trait(trait_id, ty, ty_params, param_env)\n-            .must_apply_modulo_regions()\n+        infcx.type_implements_trait(trait_id, ty, ty_params, param_env).must_apply_modulo_regions()\n     })\n }\n \n@@ -185,11 +184,14 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.has_attr(adt.did(), sym::must_use),\n         ty::Foreign(did) => cx.tcx.has_attr(*did, sym::must_use),\n-        ty::Slice(ty) | ty::Array(ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _) => {\n+        ty::Slice(ty)\n+        | ty::Array(ty, _)\n+        | ty::RawPtr(ty::TypeAndMut { ty, .. })\n+        | ty::Ref(_, ty, _) => {\n             // for the Array case we don't need to care for the len == 0 case\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n-        },\n+        }\n         ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n@@ -200,8 +202,8 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        },\n-        ty::Dynamic(binder, _) => {\n+        }\n+        ty::Dynamic(binder, _, _) => {\n             for predicate in binder.iter() {\n                 if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder() {\n                     if cx.tcx.has_attr(trait_ref.def_id, sym::must_use) {\n@@ -210,7 +212,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n                 }\n             }\n             false\n-        },\n+        }\n         _ => false,\n     }\n }\n@@ -220,7 +222,11 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n // not succeed\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n-pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn is_normalizable<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> bool {\n     is_normalizable_helper(cx, param_env, ty, &mut FxHashMap::default())\n }\n \n@@ -240,15 +246,14 @@ fn is_normalizable_helper<'tcx>(\n         if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n             match ty.kind() {\n                 ty::Adt(def, substs) => def.variants().iter().all(|variant| {\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n+                    variant.fields.iter().all(|field| {\n+                        is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache)\n+                    })\n                 }),\n                 _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n-                    },\n+                    }\n                     _ => true, // if inner_ty == ty, we've already checked it\n                 }),\n             }\n@@ -273,7 +278,9 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match *ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => {\n+            is_recursively_primitive_type(inner_type)\n+        }\n         ty::Tuple(inner_types) => inner_types.iter().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -313,11 +320,9 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n /// Returns `false` if the `LangItem` is not defined.\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n     match ty.kind() {\n-        ty::Adt(adt, _) => cx\n-            .tcx\n-            .lang_items()\n-            .require(lang_item)\n-            .map_or(false, |li| li == adt.did()),\n+        ty::Adt(adt, _) => {\n+            cx.tcx.lang_items().require(lang_item).map_or(false, |li| li == adt.did())\n+        }\n         _ => false,\n     }\n }\n@@ -342,7 +347,11 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n /// deallocate memory. For these types, and composites containing them, changing the drop order\n /// won't result in any observable side effects.\n pub fn needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    fn needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+    fn needs_ordered_drop_inner<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        ty: Ty<'tcx>,\n+        seen: &mut FxHashSet<Ty<'tcx>>,\n+    ) -> bool {\n         if !seen.insert(ty) {\n             return false;\n         }\n@@ -393,11 +402,7 @@ pub fn needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n-        if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(*ty, count + 1)\n-        } else {\n-            (ty, count)\n-        }\n+        if let ty::Ref(_, ty, _) = ty.kind() { peel(*ty, count + 1) } else { (ty, count) }\n     }\n     peel(ty, 0)\n }\n@@ -452,17 +457,18 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n                 return false;\n             }\n \n-            substs_a\n-                .iter()\n-                .zip(substs_b.iter())\n-                .all(|(arg_a, arg_b)| match (arg_a.unpack(), arg_b.unpack()) {\n-                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => inner_a == inner_b,\n+            substs_a.iter().zip(substs_b.iter()).all(|(arg_a, arg_b)| {\n+                match (arg_a.unpack(), arg_b.unpack()) {\n+                    (GenericArgKind::Const(inner_a), GenericArgKind::Const(inner_b)) => {\n+                        inner_a == inner_b\n+                    }\n                     (GenericArgKind::Type(type_a), GenericArgKind::Type(type_b)) => {\n                         same_type_and_consts(type_a, type_b)\n-                    },\n+                    }\n                     _ => true,\n-                })\n-        },\n+                }\n+            })\n+        }\n         _ => a == b,\n     }\n }\n@@ -478,7 +484,10 @@ pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n }\n \n /// Gets an iterator over all predicates which apply to the given item.\n-pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(Predicate<'_>, Span)> {\n+pub fn all_predicates_of(\n+    tcx: TyCtxt<'_>,\n+    id: DefId,\n+) -> impl Iterator<Item = &(Predicate<'_>, Span)> {\n     let mut next_id = Some(id);\n     iter::from_fn(move || {\n         next_id.take().map(|id| {\n@@ -508,7 +517,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 } else {\n                     Some(sig.input(i))\n                 }\n-            },\n+            }\n             Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n             Self::Trait(inputs, _, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n         }\n@@ -517,7 +526,10 @@ impl<'tcx> ExprFnSig<'tcx> {\n     /// Gets the argument type at the given offset. For closures this will also get the type as\n     /// written. This will return `None` when the index is out of bounds only for variadic\n     /// functions, otherwise this will panic.\n-    pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n+    pub fn input_with_hir(\n+        self,\n+        i: usize,\n+    ) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n         match self {\n             Self::Sig(sig, _) => {\n                 if sig.c_variadic() {\n@@ -528,7 +540,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n                 } else {\n                     Some((None, sig.input(i)))\n                 }\n-            },\n+            }\n             Self::Closure(decl, sig) => Some((\n                 decl.and_then(|decl| decl.inputs.get(i)),\n                 sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n@@ -547,17 +559,15 @@ impl<'tcx> ExprFnSig<'tcx> {\n     }\n \n     pub fn predicates_id(&self) -> Option<DefId> {\n-        if let ExprFnSig::Sig(_, id) | ExprFnSig::Trait(_, _, id) = *self {\n-            id\n-        } else {\n-            None\n-        }\n+        if let ExprFnSig::Sig(_, id) | ExprFnSig::Trait(_, _, id) = *self { id } else { None }\n     }\n }\n \n /// If the expression is function like, get the signature for it.\n pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n-    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n+    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) =\n+        path_res(cx, expr)\n+    {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id), Some(id)))\n     } else {\n         ty_sig(cx, cx.typeck_results().expr_ty_adjusted(expr).peel_refs())\n@@ -571,15 +581,17 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n     }\n     match *ty.kind() {\n         ty::Closure(id, subs) => {\n-            let decl = id\n-                .as_local()\n-                .and_then(|id| cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id)));\n+            let decl = id.as_local().and_then(|id| {\n+                cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id))\n+            });\n             Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n-        },\n-        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id))),\n+        }\n+        ty::FnDef(id, subs) => {\n+            Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs), Some(id)))\n+        }\n         ty::Opaque(id, _) => sig_from_bounds(cx, ty, cx.tcx.item_bounds(id), cx.tcx.opt_parent(id)),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig, None)),\n-        ty::Dynamic(bounds, _) => {\n+        ty::Dynamic(bounds, _, _) => {\n             let lang_items = cx.tcx.lang_items();\n             match bounds.principal() {\n                 Some(bound)\n@@ -589,16 +601,19 @@ pub fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'t\n                 {\n                     let output = bounds\n                         .projection_bounds()\n-                        .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n+                        .find(|p| {\n+                            lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id())\n+                        })\n                         .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n                     Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output, None))\n-                },\n+                }\n                 _ => None,\n             }\n-        },\n+        }\n         ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n             Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n-            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n+            _ => sig_for_projection(cx, proj)\n+                .or_else(|| sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None)),\n         },\n         ty::Param(_) => sig_from_bounds(cx, ty, cx.param_env.caller_bounds(), None),\n         _ => None,\n@@ -629,7 +644,7 @@ fn sig_from_bounds<'tcx>(\n                     return None;\n                 }\n                 inputs = Some(i);\n-            },\n+            }\n             PredicateKind::Projection(p)\n                 if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n                     && p.projection_ty.self_ty() == ty =>\n@@ -639,15 +654,18 @@ fn sig_from_bounds<'tcx>(\n                     return None;\n                 }\n                 output = Some(pred.kind().rebind(p.term.ty().unwrap()));\n-            },\n+            }\n             _ => (),\n         }\n     }\n \n     inputs.map(|ty| ExprFnSig::Trait(ty, output, predicates_id))\n }\n \n-fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+fn sig_for_projection<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: ProjectionTy<'tcx>,\n+) -> Option<ExprFnSig<'tcx>> {\n     let mut inputs = None;\n     let mut output = None;\n     let lang_items = cx.tcx.lang_items();\n@@ -673,8 +691,10 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                     return None;\n                 }\n                 inputs = Some(i);\n-            },\n-            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n+            }\n+            PredicateKind::Projection(p)\n+                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() =>\n+            {\n                 if output.is_some() {\n                     // Multiple different fn trait impls. Is this even allowed?\n                     return None;\n@@ -683,7 +703,7 @@ fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> O\n                     pred.map_bound(|pred| pred.kind().rebind(p.term.ty().unwrap()))\n                         .subst(cx.tcx, ty.substs),\n                 );\n-            },\n+            }\n             _ => (),\n         }\n     }\n@@ -777,7 +797,10 @@ pub fn for_each_top_level_late_bound_region<B>(\n                 ControlFlow::Continue(())\n             }\n         }\n-        fn visit_binder<T: TypeVisitable<'tcx>>(&mut self, t: &Binder<'tcx, T>) -> ControlFlow<Self::BreakTy> {\n+        fn visit_binder<T: TypeVisitable<'tcx>>(\n+            &mut self,\n+            t: &Binder<'tcx, T>,\n+        ) -> ControlFlow<Self::BreakTy> {\n             self.index += 1;\n             let res = t.super_visit_with(self);\n             self.index -= 1;\n@@ -791,19 +814,27 @@ pub fn for_each_top_level_late_bound_region<B>(\n pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n     match res {\n         Res::Def(DefKind::Struct, id) => Some(cx.tcx.adt_def(id).non_enum_variant()),\n-        Res::Def(DefKind::Variant, id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id)),\n-        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant()),\n+        Res::Def(DefKind::Variant, id) => {\n+            Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id))\n+        }\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => {\n+            Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant())\n+        }\n         Res::Def(DefKind::Ctor(CtorOf::Variant, _), id) => {\n             let var_id = cx.tcx.parent(id);\n             Some(cx.tcx.adt_def(cx.tcx.parent(var_id)).variant_with_id(var_id))\n-        },\n+        }\n         Res::SelfCtor(id) => Some(cx.tcx.type_of(id).ty_adt_def().unwrap().non_enum_variant()),\n         _ => None,\n     }\n }\n \n /// Checks if the type is a type parameter implementing `FnOnce`, but not `FnMut`.\n-pub fn ty_is_fn_once_param<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, predicates: &'tcx [Predicate<'_>]) -> bool {\n+pub fn ty_is_fn_once_param<'tcx>(\n+    tcx: TyCtxt<'_>,\n+    ty: Ty<'tcx>,\n+    predicates: &'tcx [Predicate<'_>],\n+) -> bool {\n     let ty::Param(ty) = *ty.kind() else {\n         return false;\n     };"}]}