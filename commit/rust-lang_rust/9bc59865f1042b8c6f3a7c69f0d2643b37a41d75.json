{"sha": "9bc59865f1042b8c6f3a7c69f0d2643b37a41d75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYzU5ODY1ZjEwNDJiOGM2ZjNhN2M2OWYwZDI2NDNiMzdhNDFkNzU=", "commit": {"author": {"name": "Shaun Steenkamp", "email": "theguywholikeslinux@gmail.com", "date": "2018-02-06T08:56:27Z"}, "committer": {"name": "Shaun Steenkamp", "email": "theguywholikeslinux@gmail.com", "date": "2018-02-06T15:43:34Z"}, "message": "38880 don't compute hash when searching an empty HashMap\n\nThis addresses issue #38880", "tree": {"sha": "14810c1104a5e65cf673aa5c60375b3e538d930a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14810c1104a5e65cf673aa5c60375b3e538d930a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bc59865f1042b8c6f3a7c69f0d2643b37a41d75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bc59865f1042b8c6f3a7c69f0d2643b37a41d75", "html_url": "https://github.com/rust-lang/rust/commit/9bc59865f1042b8c6f3a7c69f0d2643b37a41d75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bc59865f1042b8c6f3a7c69f0d2643b37a41d75/comments", "author": {"login": "technicalguy", "id": 5120940, "node_id": "MDQ6VXNlcjUxMjA5NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/5120940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/technicalguy", "html_url": "https://github.com/technicalguy", "followers_url": "https://api.github.com/users/technicalguy/followers", "following_url": "https://api.github.com/users/technicalguy/following{/other_user}", "gists_url": "https://api.github.com/users/technicalguy/gists{/gist_id}", "starred_url": "https://api.github.com/users/technicalguy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/technicalguy/subscriptions", "organizations_url": "https://api.github.com/users/technicalguy/orgs", "repos_url": "https://api.github.com/users/technicalguy/repos", "events_url": "https://api.github.com/users/technicalguy/events{/privacy}", "received_events_url": "https://api.github.com/users/technicalguy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "technicalguy", "id": 5120940, "node_id": "MDQ6VXNlcjUxMjA5NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/5120940?v=4", "gravatar_id": "", "url": "https://api.github.com/users/technicalguy", "html_url": "https://github.com/technicalguy", "followers_url": "https://api.github.com/users/technicalguy/followers", "following_url": "https://api.github.com/users/technicalguy/following{/other_user}", "gists_url": "https://api.github.com/users/technicalguy/gists{/gist_id}", "starred_url": "https://api.github.com/users/technicalguy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/technicalguy/subscriptions", "organizations_url": "https://api.github.com/users/technicalguy/orgs", "repos_url": "https://api.github.com/users/technicalguy/repos", "events_url": "https://api.github.com/users/technicalguy/events{/privacy}", "received_events_url": "https://api.github.com/users/technicalguy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca7d839088cbfe5b9bf232f5c27c48703d4f1605", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7d839088cbfe5b9bf232f5c27c48703d4f1605", "html_url": "https://github.com/rust-lang/rust/commit/ca7d839088cbfe5b9bf232f5c27c48703d4f1605"}], "stats": {"total": 40, "additions": 35, "deletions": 5}, "files": [{"sha": "74c4382f16a5d14f1232ec0aa5fa4e344668c454", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9bc59865f1042b8c6f3a7c69f0d2643b37a41d75/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bc59865f1042b8c6f3a7c69f0d2643b37a41d75/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9bc59865f1042b8c6f3a7c69f0d2643b37a41d75", "patch": "@@ -397,9 +397,21 @@ pub struct HashMap<K, V, S = RandomState> {\n     resize_policy: DefaultResizePolicy,\n }\n \n+/// Search for a pre-hashed key when the hash map is known to be non-empty.\n+#[inline]\n+fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, is_match: F)\n+    -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n+{\n+    // Do not check the capacity as an extra branch could slow the lookup.\n+    search_hashed_body(table, hash, is_match)\n+}\n+\n /// Search for a pre-hashed key.\n+/// If you don't already know the hash, use search or search_mut instead\n #[inline]\n-fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>\n+fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n     where M: Deref<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n {\n@@ -410,6 +422,16 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n         return InternalEntry::TableIsEmpty;\n     }\n \n+    search_hashed_body(table, hash, is_match)\n+}\n+\n+/// The body of the search_hashed[_nonempty] functions\n+#[inline]\n+fn search_hashed_body<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+    -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n+{\n     let size = table.size();\n     let mut probe = Bucket::new(table, hash);\n     let mut displacement = 0;\n@@ -550,17 +572,25 @@ impl<K, V, S> HashMap<K, V, S>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n-        let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n+        if self.table.capacity() != 0 {\n+            let hash = self.make_hash(q);\n+            search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+        } else {\n+            InternalEntry::TableIsEmpty\n+        }\n     }\n \n     #[inline]\n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n     {\n-        let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        if self.table.capacity() != 0 {\n+            let hash = self.make_hash(q);\n+            search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        } else {\n+            InternalEntry::TableIsEmpty\n+        }\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold"}]}