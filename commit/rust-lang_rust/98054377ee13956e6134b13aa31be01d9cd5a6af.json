{"sha": "98054377ee13956e6134b13aa31be01d9cd5a6af", "node_id": "C_kwDOAAsO6NoAKDk4MDU0Mzc3ZWUxMzk1NmU2MTM0YjEzYWEzMWJlMDFkOWNkNWE2YWY", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-03-04T08:17:26Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-05-06T07:03:38Z"}, "message": "Add a dedicated length-prefixing method to `Hasher`\n\nThis accomplishes two main goals:\n- Make it clear who is responsible for prefix-freedom, including how they should do it\n- Make it feasible for a `Hasher` that *doesn't* care about Hash-DoS resistance to get better performance by not hashing lengths\n\nThis does not change rustc-hash, since that's in an external crate, but that could potentially use it in future.", "tree": {"sha": "c08f6fb1a70c834ba46216f550f0ebb69a57b46b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c08f6fb1a70c834ba46216f550f0ebb69a57b46b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98054377ee13956e6134b13aa31be01d9cd5a6af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98054377ee13956e6134b13aa31be01d9cd5a6af", "html_url": "https://github.com/rust-lang/rust/commit/98054377ee13956e6134b13aa31be01d9cd5a6af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98054377ee13956e6134b13aa31be01d9cd5a6af/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "086bf7a8ff3550ff1f4c8e78d8b3a7804fdbbb36", "url": "https://api.github.com/repos/rust-lang/rust/commits/086bf7a8ff3550ff1f4c8e78d8b3a7804fdbbb36", "html_url": "https://github.com/rust-lang/rust/commit/086bf7a8ff3550ff1f4c8e78d8b3a7804fdbbb36"}], "stats": {"total": 172, "additions": 166, "deletions": 6}, "files": [{"sha": "2cedee3b771d7dbbd769160270a9ef7471fe2f00", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -18,6 +18,7 @@\n #![feature(generators)]\n #![feature(let_else)]\n #![feature(hash_raw_entry)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "abd25f46ad54fa2d60b065e6fddcbc71b74dcb7f", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -462,6 +462,14 @@ impl Hasher for SipHasher128 {\n         self.slice_write(msg);\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        // This hasher works byte-wise, and `0xFF` cannot show up in a `str`,\n+        // so just hashing the one extra byte is enough to be prefix-free.\n+        self.write(s.as_bytes());\n+        self.write_u8(0xFF);\n+    }\n+\n     fn finish(&self) -> u64 {\n         panic!(\"SipHasher128 cannot provide valid 64 bit hashes\")\n     }"}, {"sha": "c8bb4fc5e6af6f2cbccfd9aa78b705e2bbda15a5", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -73,6 +73,17 @@ impl Hasher for StableHasher {\n         self.state.write(bytes);\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.state.write_str(s);\n+    }\n+\n+    #[inline]\n+    fn write_length_prefix(&mut self, len: usize) {\n+        // Our impl for `usize` will extend it if needed.\n+        self.write_usize(len);\n+    }\n+\n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n         self.state.write_u8(i);"}, {"sha": "c07536f0d0ce1c997a3d415d8886fec4237ec1cd", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -1369,6 +1369,12 @@ impl<T: ?Sized + Hasher, A: Allocator> Hasher for Box<T, A> {\n     fn write_isize(&mut self, i: isize) {\n         (**self).write_isize(i)\n     }\n+    fn write_length_prefix(&mut self, len: usize) {\n+        (**self).write_length_prefix(len)\n+    }\n+    fn write_str(&mut self, s: &str) {\n+        (**self).write_str(s)\n+    }\n }\n \n #[cfg(not(no_global_oom_handling))]"}, {"sha": "264c217c9ef235faa2e96b2b5e485f868a84f3d7", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -1990,7 +1990,7 @@ impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.len().hash(state);\n+        state.write_length_prefix(self.len());\n         for elt in self {\n             elt.hash(state);\n         }"}, {"sha": "67dc4f30f3179c9d6681f900443cf224f2ac8f5a", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -1944,7 +1944,7 @@ impl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash> Hash for LinkedList<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.len().hash(state);\n+        state.write_length_prefix(self.len());\n         for elt in self {\n             elt.hash(state);\n         }"}, {"sha": "04900ead579a14510ae7b23004c3d47c18399c53", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -2899,7 +2899,7 @@ impl<T: Ord, A: Allocator> Ord for VecDeque<T, A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Hash, A: Allocator> Hash for VecDeque<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.len().hash(state);\n+        state.write_length_prefix(self.len());\n         // It's not possible to use Hash::hash_slice on slices\n         // returned by as_slices method as their length can vary\n         // in otherwise identical deques."}, {"sha": "ecebc7ed9ac850692661f014e4df15f024b04199", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -117,6 +117,7 @@\n #![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n #![feature(layout_for_ptr)]"}, {"sha": "20b1411ea34f4e2a3e1ef98aaf6d96d5a7f919d0", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 104, "deletions": 3, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -333,6 +333,12 @@ pub trait Hasher {\n     ///\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// You generally should not do length-prefixing as part of implementing\n+    /// this method.  It's up to the [`Hash`] implementation to call\n+    /// [`Hasher::write_length_prefix`] before sequences that need it.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n@@ -409,6 +415,96 @@ pub trait Hasher {\n     fn write_isize(&mut self, i: isize) {\n         self.write_usize(i as usize)\n     }\n+\n+    /// Writes a length prefix into this hasher, as part of being prefix-free.\n+    ///\n+    /// If you're implementing [`Hash`] for a custom collection, call this before\n+    /// writing its contents to this `Hasher`.  That way\n+    /// `(collection![1, 2, 3], collection![4, 5])` and\n+    /// `(collection![1, 2], collection![3, 4, 5])` will provide different\n+    /// sequences of values to the `Hasher`\n+    ///\n+    /// The `impl<T> Hash for [T]` includes a call to this method, so if you're\n+    /// hashing a slice (or array or vector) via its `Hash::hash` method,\n+    /// you should **not** call this yourself.\n+    ///\n+    /// This method is only for providing domain separation.  If you want to\n+    /// hash a `usize` that represents part of the *data*, then it's important\n+    /// that you pass it to [`Hasher::write_usize`] instead of to this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hasher_prefixfree_extras)]\n+    /// # // Stubs to make the `impl` below pass the compiler\n+    /// # struct MyCollection<T>(Option<T>);\n+    /// # impl<T> MyCollection<T> {\n+    /// #     fn len(&self) -> usize { todo!() }\n+    /// # }\n+    /// # impl<'a, T> IntoIterator for &'a MyCollection<T> {\n+    /// #     type Item = T;\n+    /// #     type IntoIter = std::iter::Empty<T>;\n+    /// #     fn into_iter(self) -> Self::IntoIter { todo!() }\n+    /// # }\n+    ///\n+    /// use std::hash::{Hash, Hasher};\n+    /// impl<T: Hash> Hash for MyCollection<T> {\n+    ///     fn hash<H: Hasher>(&self, state: &mut H) {\n+    ///         state.write_length_prefix(self.len());\n+    ///         for elt in self {\n+    ///             elt.hash(state);\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// If you've decided that your `Hasher` is willing to be susceptible to\n+    /// Hash-DoS attacks, then you might consider skipping hashing some or all\n+    /// of the `len` provided in the name of increased performance.\n+    #[inline]\n+    #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"96762\")]\n+    fn write_length_prefix(&mut self, len: usize) {\n+        self.write_usize(len);\n+    }\n+\n+    /// Writes a single `str` into this hasher.\n+    ///\n+    /// If you're implementing [`Hash`], you generally do not need to call this,\n+    /// as the `impl Hash for str` does, so you should prefer that instead.\n+    ///\n+    /// This includes the domain separator for prefix-freedom, so you should\n+    /// **not** call `Self::write_length_prefix` before calling this.\n+    ///\n+    /// # Note to Implementers\n+    ///\n+    /// The default implementation of this method includes a call to\n+    /// [`Self::write_length_prefix`], so if your implementation of `Hasher`\n+    /// doesn't care about prefix-freedom and you've thus overridden\n+    /// that method to do nothing, there's no need to override this one.\n+    ///\n+    /// This method is available to be overridden separately from the others\n+    /// as `str` being UTF-8 means that it never contains `0xFF` bytes, which\n+    /// can be used to provide prefix-freedom cheaper than hashing a length.\n+    ///\n+    /// For example, if your `Hasher` works byte-by-byte (perhaps by accumulating\n+    /// them into a buffer), then you can hash the bytes of the `str` followed\n+    /// by a single `0xFF` byte.\n+    ///\n+    /// If your `Hasher` works in chunks, you can also do this by being careful\n+    /// about how you pad partial chunks.  If the chunks are padded with `0x00`\n+    /// bytes then just hashing an extra `0xFF` byte doesn't necessarily\n+    /// provide prefix-freedom, as `\"ab\"` and `\"ab\\u{0}\"` would likely hash\n+    /// the same sequence of chunks.  But if you pad with `0xFF` bytes instead,\n+    /// ensuring at least one padding byte, then it can often provide\n+    /// prefix-freedom cheaper than hashing the length would.\n+    #[inline]\n+    #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"96762\")]\n+    fn write_str(&mut self, s: &str) {\n+        self.write_length_prefix(s.len());\n+        self.write(s.as_bytes());\n+    }\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n@@ -455,6 +551,12 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n     fn write_isize(&mut self, i: isize) {\n         (**self).write_isize(i)\n     }\n+    fn write_length_prefix(&mut self, len: usize) {\n+        (**self).write_length_prefix(len)\n+    }\n+    fn write_str(&mut self, s: &str) {\n+        (**self).write_str(s)\n+    }\n }\n \n /// A trait for creating instances of [`Hasher`].\n@@ -709,8 +811,7 @@ mod impls {\n     impl Hash for str {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            state.write(self.as_bytes());\n-            state.write_u8(0xff)\n+            state.write_str(self);\n         }\n     }\n \n@@ -767,7 +868,7 @@ mod impls {\n     impl<T: Hash> Hash for [T] {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            self.len().hash(state);\n+            state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }"}, {"sha": "9d7daf1f1a075f9cb9a390eafc8fabcb2d44487f", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -233,6 +233,11 @@ impl super::Hasher for SipHasher {\n         self.0.hasher.write(msg)\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.0.hasher.write_str(s);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         self.0.hasher.finish()\n@@ -246,6 +251,11 @@ impl super::Hasher for SipHasher13 {\n         self.hasher.write(msg)\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.hasher.write_str(s);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         self.hasher.finish()\n@@ -307,6 +317,14 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n         self.ntail = left;\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        // This hasher works byte-wise, and `0xFF` cannot show up in a `str`,\n+        // so just hashing the one extra byte is enough to be prefix-free.\n+        self.write(s.as_bytes());\n+        self.write_u8(0xFF);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         let mut state = self.state;"}, {"sha": "5bc6aac1778f50a62249da8c9a5778d0b1fd09ab", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -20,6 +20,10 @@ impl Hasher for MyHasher {\n             self.hash += *byte as u64;\n         }\n     }\n+    fn write_str(&mut self, s: &str) {\n+        self.write(s.as_bytes());\n+        self.write_u8(0xFF);\n+    }\n     fn finish(&self) -> u64 {\n         self.hash\n     }"}, {"sha": "934f1cf376cee156ea2ac0aa83bb02c3ea919783", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -37,6 +37,7 @@\n #![feature(future_join)]\n #![feature(future_poll_fn)]\n #![feature(array_from_fn)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(try_find)]\n #![feature(inline_const)]"}, {"sha": "e38368790e69a10693aa1e7f8e5311c8bd79edd5", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -3006,11 +3006,19 @@ impl Default for DefaultHasher {\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n impl Hasher for DefaultHasher {\n+    // The underlying `SipHasher13` doesn't override the other\n+    // `write_*` methods, so it's ok not to forward them here.\n+\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.write(msg)\n     }\n \n+    #[inline]\n+    fn write_str(&mut self, s: &str) {\n+        self.0.write_str(s);\n+    }\n+\n     #[inline]\n     fn finish(&self) -> u64 {\n         self.0.finish()"}, {"sha": "8ee50925f85f8e1ac04cf059c738e0093624a930", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98054377ee13956e6134b13aa31be01d9cd5a6af/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=98054377ee13956e6134b13aa31be01d9cd5a6af", "patch": "@@ -270,6 +270,7 @@\n #![feature(exact_size_is_empty)]\n #![feature(extend_one)]\n #![feature(float_minimum_maximum)]\n+#![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(maybe_uninit_slice)]"}]}