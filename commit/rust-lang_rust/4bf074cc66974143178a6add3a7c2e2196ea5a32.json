{"sha": "4bf074cc66974143178a6add3a7c2e2196ea5a32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZjA3NGNjNjY5NzQxNDMxNzhhNmFkZDNhN2MyZTIxOTZlYTVhMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-17T21:01:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-17T21:01:35Z"}, "message": "auto merge of #7134 : vadimcn/rust/DIBuilder, r=jdm\n\nThis commit fixes rustc's debug info generation and turns debug-info tests back on.\r\n\r\nThe old generator used to write out LLVM metadata directly, however it seems that debug metadata format is not stable and keeps changing from release to release.  So I wrapped LLVM's official debug info API - the DIBuilder class, and now rustc will use that.\r\n\r\nOne bit of old functionality that still doesn't work, is debug info for function arguments.  Someone more familiar with the compiler guts will need to look into that.\r\n\r\nAlso, unfortunately, debug info is still won't work on Windows,- due to a LLVM bug (http://llvm.org/bugs/show_bug.cgi?id=16249).\r\n\r\nResolves issues #5836, #5848, #6814", "tree": {"sha": "0b57c19fce94133f8eee96f7367bfedb86f7a812", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b57c19fce94133f8eee96f7367bfedb86f7a812"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bf074cc66974143178a6add3a7c2e2196ea5a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf074cc66974143178a6add3a7c2e2196ea5a32", "html_url": "https://github.com/rust-lang/rust/commit/4bf074cc66974143178a6add3a7c2e2196ea5a32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bf074cc66974143178a6add3a7c2e2196ea5a32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "644774c1b15c107d8cb74c756ea69e342844a5c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/644774c1b15c107d8cb74c756ea69e342844a5c9", "html_url": "https://github.com/rust-lang/rust/commit/644774c1b15c107d8cb74c756ea69e342844a5c9"}, {"sha": "adff46250ed9e9b3c31da65b2997a5458e41305a", "url": "https://api.github.com/repos/rust-lang/rust/commits/adff46250ed9e9b3c31da65b2997a5458e41305a", "html_url": "https://github.com/rust-lang/rust/commit/adff46250ed9e9b3c31da65b2997a5458e41305a"}], "stats": {"total": 1694, "additions": 946, "deletions": 748}, "files": [{"sha": "93fe258d167ed4a3c43eb4e2602cf2d819dbed71", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -23,7 +23,7 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n     assert!(prog.ends_with(\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n \n-    env = do vec::map(env) |pair| {\n+    env = do env.map() |pair| {\n         let (k,v) = copy *pair;\n         if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }"}, {"sha": "835dd55711b5739d181e65f1f1f02b5419a9a9ed", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 203, "deletions": 2, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -224,13 +224,50 @@ pub type SectionIteratorRef = *SectionIterator_opaque;\n pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n \n+pub mod debuginfo {\n+    use super::{ValueRef};\n+\n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *DIBuilder_opaque;\n+\n+    pub type DIDescriptor = ValueRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12\n+    }\n+}\n+\n pub mod llvm {\n     use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef, ExecutionEngineRef};\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n-    use super::{ValueRef,PassRef};\n-\n+    use super::{ValueRef, PassRef};\n+    use super::debuginfo::*;\n     use core::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong};\n \n     #[link_args = \"-Lrustllvm -lrustllvm\"]\n@@ -929,6 +966,12 @@ pub mod llvm {\n         #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n+        #[fast_ffi]\n+        pub unsafe fn LLVMMoveBasicBlockAfter(BB: BasicBlockRef, MoveAfter: BasicBlockRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMMoveBasicBlockBefore(BB: BasicBlockRef, MoveBefore: BasicBlockRef);\n+\n         /* Operations on instructions */\n         #[fast_ffi]\n         pub unsafe fn LLVMGetInstructionParent(Inst: ValueRef)\n@@ -1885,6 +1928,164 @@ pub mod llvm {\n                                     AlignStack: Bool, Dialect: c_uint)\n                                  -> ValueRef;\n \n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderDispose(Builder: DIBuilderRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderFinalize(Builder: DIBuilderRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateCompileUnit(\n+            Builder: DIBuilderRef,\n+            Lang: c_uint,\n+            File: *c_char,\n+            Dir: *c_char,\n+            Producer: *c_char,\n+            isOptimized: bool,\n+            Flags: *c_char,\n+            RuntimeVer: c_uint,\n+            SplitName: *c_char);\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateFile(\n+            Builder: DIBuilderRef,\n+            Filename: *c_char,\n+            Directory: *c_char) -> DIFile;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateSubroutineType(\n+            Builder: DIBuilderRef,\n+            File: DIFile,\n+            ParameterTypes: DIArray) -> DICompositeType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateFunction(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            LinkageName: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            Ty: DIType,\n+            isLocalToUnit: bool,\n+            isDefinition: bool,\n+            ScopeLine: c_uint,\n+            Flags: c_uint,\n+            isOptimized: bool,\n+            Fn: ValueRef,\n+            TParam: ValueRef,\n+            Decl: ValueRef) -> DISubprogram;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateBasicType(\n+            Builder: DIBuilderRef,\n+            Name: *c_char,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Encoding: c_uint) -> DIBasicType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreatePointerType(\n+            Builder: DIBuilderRef,\n+            PointeeTy: DIType,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Name: *c_char) -> DIDerivedType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateStructType(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Flags: c_uint,\n+            DerivedFrom: DIType,\n+            Elements: DIArray,\n+            RunTimeLang: c_uint,\n+            VTableHolder: ValueRef) -> DICompositeType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateMemberType(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            OffsetInBits: c_ulonglong,\n+            Flags: c_uint,\n+            Ty: DIType) -> DIDerivedType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateLexicalBlock(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            File: DIFile,\n+            Line: c_uint,\n+            Col: c_uint) -> DILexicalBlock;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateLocalVariable(\n+            Builder: DIBuilderRef,\n+            Tag: c_uint,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            Ty: DIType,\n+            AlwaysPreserve: bool,\n+            Flags: c_uint,\n+            ArgNo: c_uint) -> DIVariable;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateArrayType(\n+            Builder: DIBuilderRef,\n+            Size: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Ty: DIType,\n+            Subscripts: DIArray) -> DIType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderCreateVectorType(\n+            Builder: DIBuilderRef,\n+            Size: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Ty: DIType,\n+            Subscripts: DIArray) -> DIType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderGetOrCreateSubrange(\n+            Builder: DIBuilderRef,\n+            Lo: c_longlong,\n+            Count: c_longlong) -> DISubrange;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderGetOrCreateArray(\n+            Builder: DIBuilderRef,\n+            Ptr: *DIDescriptor,\n+            Count: c_uint) -> DIArray;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderInsertDeclareAtEnd(\n+            Builder: DIBuilderRef,\n+            Val: ValueRef,\n+            VarInfo: DIVariable,\n+            InsertAtEnd: BasicBlockRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn LLVMDIBuilderInsertDeclareBefore(\n+            Builder: DIBuilderRef,\n+            Val: ValueRef,\n+            VarInfo: DIVariable,\n+            InsertBefore: ValueRef) -> ValueRef;\n     }\n }\n "}, {"sha": "55fc22a8fcc02856c9af1169c782c084b5b40aa6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -1908,6 +1908,12 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     finish(bcx);\n     cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n \n+    // Put return block after all other blocks.\n+    // This somewhat improves single-stepping experience in debugger.\n+    unsafe {\n+        llvm::LLVMMoveBasicBlockAfter(fcx.llreturn, bcx.llbb);\n+    }\n+\n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n }\n@@ -3102,6 +3108,9 @@ pub fn trans_crate(sess: session::Session,\n     fill_crate_map(ccx, ccx.crate_map);\n     glue::emit_tydescs(ccx);\n     write_abi_version(ccx);\n+    if ccx.sess.opts.debuginfo {\n+        debuginfo::finalize(ccx);\n+    }\n \n     // Translate the metadata.\n     write_metadata(ccx, crate);"}, {"sha": "7aab1d0239e6f0ee469fde14b86a0235e6bcb5c2", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -148,7 +148,7 @@ impl CrateContext {\n             lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n             let crate_map = decl_crate_map(sess, link_meta, llmod);\n             let dbg_cx = if sess.opts.debuginfo {\n-                Some(debuginfo::mk_ctxt(name.to_owned()))\n+                Some(debuginfo::DebugContext::new(llmod, name.to_owned()))\n             } else {\n                 None\n             };"}, {"sha": "91e3276d8aa644b83a1afce655e7ae97ed761a32", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 456, "deletions": 729, "changes": 1185, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,31 +11,28 @@\n use core::prelude::*;\n \n use driver::session;\n-use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n-use middle::trans::context::task_llcx;\n+use lib::llvm::{ValueRef, ModuleRef, ContextRef};\n+use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::cast;\n use core::hashmap::HashMap;\n use core::libc;\n-use core::option;\n+use core::libc::c_uint;\n+use core::cmp;\n use core::ptr;\n-use core::str;\n+use core::str::as_c_str;\n use core::sys;\n use core::vec;\n use syntax::codemap::span;\n use syntax::{ast, codemap, ast_util, ast_map};\n \n-static LLVMDebugVersion: int = (9 << 16);\n-\n static DW_LANG_RUST: int = 0x9000;\n-static DW_VIRTUALITY_none: int = 0;\n \n static CompileUnitTag: int = 17;\n static FileDescriptorTag: int = 41;\n@@ -59,302 +56,169 @@ static DW_ATE_signed_char: int = 0x06;\n static DW_ATE_unsigned: int = 0x07;\n static DW_ATE_unsigned_char: int = 0x08;\n \n-fn llstr(s: &str) -> ValueRef {\n-    do str::as_c_str(s) |sbuf| {\n-        unsafe {\n-            llvm::LLVMMDStringInContext(task_llcx(),\n-                                        sbuf,\n-                                        s.len() as libc::c_uint)\n-        }\n-    }\n-}\n-fn lltag(lltag: int) -> ValueRef {\n-    lli32(LLVMDebugVersion | lltag)\n-}\n-fn lli32(val: int) -> ValueRef {\n-    C_i32(val as i32)\n-}\n-fn lli64(val: int) -> ValueRef {\n-    C_i64(val as i64)\n-}\n-fn lli1(bval: bool) -> ValueRef {\n-    C_i1(bval)\n-}\n-fn llmdnode(elems: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMMDNodeInContext(task_llcx(),\n-                                  vec::raw::to_ptr(elems),\n-                                  elems.len() as libc::c_uint)\n-    }\n-}\n-fn llunused() -> ValueRef {\n-    lli32(0x0)\n-}\n-fn llnull() -> ValueRef {\n-    unsafe {\n-        cast::transmute(ptr::null::<ValueRef>())\n-    }\n-}\n-\n-fn add_named_metadata(cx: &CrateContext, name: ~str, val: ValueRef) {\n-    str::as_c_str(name, |sbuf| {\n-        unsafe {\n-            llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n-        }\n-    })\n-}\n-\n ////////////////\n \n pub struct DebugContext {\n-    llmetadata: metadata_cache,\n     names: namegen,\n-    crate_file: ~str\n-}\n-\n-pub fn mk_ctxt(crate: ~str) -> DebugContext {\n-    DebugContext {\n-        llmetadata: @mut HashMap::new(),\n-        names: new_namegen(),\n-        crate_file: crate\n+    crate_file: ~str,\n+    llcontext: ContextRef,\n+    builder: DIBuilderRef,\n+    curr_loc: (uint, uint),\n+    created_files: HashMap<~str, DIFile>,\n+    created_functions: HashMap<ast::node_id, DISubprogram>,\n+    created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n+    created_types: HashMap<uint, DIType>\n+}\n+\n+impl DebugContext {\n+    pub fn new(llmod: ModuleRef, crate: ~str) -> DebugContext {\n+        debug!(\"DebugContext::new\");\n+        let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n+        // DIBuilder inherits context from the module, so we'd better use the same one\n+        let llcontext = unsafe { llvm::LLVMGetModuleContext(llmod) };\n+        return DebugContext {\n+            names: new_namegen(),\n+            crate_file: crate,\n+            llcontext: llcontext,\n+            builder: builder,\n+            curr_loc: (0, 0),\n+            created_files: HashMap::new(),\n+            created_functions: HashMap::new(),\n+            created_blocks: HashMap::new(),\n+            created_types: HashMap::new(),\n+        };\n     }\n }\n \n-fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let mut existing = match cache.pop(&mdtag) {\n-        Some(arr) => arr, None => ~[]\n-    };\n-    existing.push(val);\n-    cache.insert(mdtag, existing);\n-}\n-\n-struct Metadata<T> {\n-    node: ValueRef,\n-    data: T\n-}\n-\n-struct FileMetadata {\n-    path: ~str\n-}\n-struct CompileUnitMetadata {\n-    name: ~str\n-}\n-struct SubProgramMetadata {\n-    id: ast::node_id\n-}\n-struct LocalVarMetadata {\n-    id: ast::node_id\n-}\n-struct TyDescMetadata {\n-    hash: uint\n-}\n-struct BlockMetadata {\n-    start: codemap::Loc,\n-    end: codemap::Loc\n-}\n-struct ArgumentMetadata {\n-    id: ast::node_id\n-}\n-struct RetvalMetadata {\n-    id: ast::node_id\n+#[inline]\n+fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n+    cx.dbg_cx.get_mut_ref()\n }\n \n-type metadata_cache = @mut HashMap<int, ~[debug_metadata]>;\n-\n-enum debug_metadata {\n-    file_metadata(@Metadata<FileMetadata>),\n-    compile_unit_metadata(@Metadata<CompileUnitMetadata>),\n-    subprogram_metadata(@Metadata<SubProgramMetadata>),\n-    local_var_metadata(@Metadata<LocalVarMetadata>),\n-    tydesc_metadata(@Metadata<TyDescMetadata>),\n-    block_metadata(@Metadata<BlockMetadata>),\n-    argument_metadata(@Metadata<ArgumentMetadata>),\n-    retval_metadata(@Metadata<RetvalMetadata>),\n+#[inline]\n+fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx.get_ref().builder\n }\n \n-fn cast_safely<T:Copy,U>(val: T) -> U {\n+/// Create any deferred debug metadata nodes\n+pub fn finalize(cx: @mut CrateContext) {\n+    debug!(\"finalize\");\n+    create_compile_unit(cx);\n     unsafe {\n-        let val2 = val;\n-        return cast::transmute(val2);\n-    }\n-}\n-\n-fn md_from_metadata<T>(val: debug_metadata) -> T {\n-    match val {\n-      file_metadata(md) => cast_safely(md),\n-      compile_unit_metadata(md) => cast_safely(md),\n-      subprogram_metadata(md) => cast_safely(md),\n-      local_var_metadata(md) => cast_safely(md),\n-      tydesc_metadata(md) => cast_safely(md),\n-      block_metadata(md) => cast_safely(md),\n-      argument_metadata(md) => cast_safely(md),\n-      retval_metadata(md) => cast_safely(md)\n-    }\n+        llvm::LLVMDIBuilderFinalize(DIB(cx));\n+        llvm::LLVMDIBuilderDispose(DIB(cx));\n+    };\n }\n \n-fn cached_metadata<T:Copy>(cache: metadata_cache,\n-                            mdtag: int,\n-                            eq_fn: &fn(md: T) -> bool)\n-                         -> Option<T> {\n-    if cache.contains_key(&mdtag) {\n-        let items = cache.get(&mdtag);\n-        for items.each |item| {\n-            let md: T = md_from_metadata::<T>(*item);\n-            if eq_fn(copy md) {\n-                return option::Some(copy md);\n-            }\n-        }\n-    }\n-    return option::None;\n+fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n+    };\n }\n \n-fn create_compile_unit(cx: &mut CrateContext) -> @Metadata<CompileUnitMetadata> {\n-    let cache = get_cache(cx);\n-    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n-    let tg = CompileUnitTag;\n-    match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n-                        |md| md.data.name == crate_name) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+fn create_compile_unit(cx: @mut CrateContext) {\n+    let dcx = dbg_cx(cx);\n+    let crate_name: &str = dcx.crate_file;\n+    let work_dir = cx.sess.working_dir.to_str();\n+    let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n+\n+    do as_c_str(crate_name) |crate_name| {\n+    do as_c_str(work_dir) |work_dir| {\n+    do as_c_str(producer) |producer| {\n+    do as_c_str(\"\") |flags| {\n+    do as_c_str(\"\") |split_name| { unsafe {\n+        llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n+            DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+            cx.sess.opts.optimize != session::No,\n+            flags, 0, split_name);\n+    }}}}}};\n+}\n+\n+fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n+    match dbg_cx(cx).created_files.find_equiv(&full_path) {\n+        Some(file_md) => return *file_md,\n+        None => ()\n     }\n \n-    let (_, work_dir) = get_file_path_and_dir(\n-        cx.sess.working_dir.to_str(), crate_name);\n-    let unit_metadata = ~[lltag(tg),\n-                         llunused(),\n-                         lli32(DW_LANG_RUST),\n-                         llstr(crate_name),\n-                         llstr(work_dir),\n-                         llstr(env!(\"CFG_VERSION\")),\n-                         lli1(true), // deprecated: main compile unit\n-                         lli1(cx.sess.opts.optimize != session::No),\n-                         llstr(\"\"), // flags (???)\n-                         lli32(0) // runtime version (???)\n-                        ];\n-    let unit_node = llmdnode(unit_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-    let mdval = @Metadata {\n-        node: unit_node,\n-        data: CompileUnitMetadata {\n-            name: crate_name\n-        }\n-    };\n-    update_cache(cache, tg, compile_unit_metadata(mdval));\n+    debug!(\"create_file: %s\", full_path);\n \n-    return mdval;\n-}\n+    let work_dir = cx.sess.working_dir.to_str();\n+    let file_name =\n+        if full_path.starts_with(work_dir) {\n+            full_path.slice(work_dir.len() + 1u, full_path.len())\n+        } else {\n+            full_path\n+        };\n \n-fn get_cache(cx: &CrateContext) -> metadata_cache {\n-    cx.dbg_cx.get_ref().llmetadata\n-}\n+    let file_md =\n+        do as_c_str(file_name) |file_name| {\n+        do as_c_str(work_dir) |work_dir| { unsafe {\n+            llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n+        }}};\n \n-fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n-    (if full_path.starts_with(work_dir) {\n-        full_path.slice(work_dir.len() + 1u,\n-                   full_path.len()).to_owned()\n-    } else {\n-        full_path.to_owned()\n-    }, work_dir.to_owned())\n+    dbg_cx(cx).created_files.insert(full_path.to_owned(), file_md);\n+    return file_md;\n }\n \n-fn create_file(cx: &mut CrateContext, full_path: ~str)\n-    -> @Metadata<FileMetadata> {\n-    let cache = get_cache(cx);;\n-    let tg = FileDescriptorTag;\n-    match cached_metadata::<@Metadata<FileMetadata>>(\n-        cache, tg, |md| md.data.path == full_path) {\n-        option::Some(md) => return md,\n-        option::None => ()\n-    }\n-\n-    let (file_path, work_dir) =\n-        get_file_path_and_dir(cx.sess.working_dir.to_str(),\n-                              full_path);\n-    let unit_node = create_compile_unit(cx).node;\n-    let file_md = ~[lltag(tg),\n-                   llstr(file_path),\n-                   llstr(work_dir),\n-                   unit_node];\n-    let val = llmdnode(file_md);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: FileMetadata {\n-            path: full_path\n-        }\n-    };\n-    update_cache(cache, tg, file_metadata(mdval));\n-    return mdval;\n+/// Return codemap::Loc corresponding to the beginning of the span\n+fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n+    return cx.sess.codemap.lookup_char_pos(span.lo);\n }\n \n-fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n-    cm.lookup_char_pos(sp.lo).line\n-}\n+fn create_block(bcx: block) -> DILexicalBlock {\n+    let mut bcx = bcx;\n+    let cx = bcx.ccx();\n \n-fn create_block(mut cx: block) -> @Metadata<BlockMetadata> {\n-    let cache = get_cache(cx.ccx());\n-    while cx.node_info.is_none() {\n-        match cx.parent {\n-          Some(b) => cx = b,\n+    while bcx.node_info.is_none() {\n+        match bcx.parent {\n+          Some(b) => bcx = b,\n           None => fail!()\n         }\n     }\n-    let sp = cx.node_info.get().span;\n-\n-    let start = cx.sess().codemap.lookup_char_pos(sp.lo);\n-    let fname = /*bad*/copy start.file.name;\n-    let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n-    let tg = LexicalBlockTag;\n-    /*match cached_metadata::<@Metadata<BlockMetadata>>(\n-        cache, tg,\n-        {|md| start == md.data.start && end == md.data.end}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n-\n-    let parent = match cx.parent {\n-        None => create_function(cx.fcx).node,\n-        Some(bcx) => create_block(bcx).node\n-    };\n-    let file_node = create_file(cx.ccx(), /* bad */ fname.to_owned());\n-    let unique_id = match cache.find(&LexicalBlockTag) {\n-      option::Some(v) => v.len() as int,\n-      option::None => 0\n+    let span = bcx.node_info.get().span;\n+    let id = bcx.node_info.get().id;\n+\n+    match dbg_cx(cx).created_blocks.find(&id) {\n+        Some(block) => return *block,\n+        None => ()\n+    }\n+\n+    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(span));\n+\n+    let parent = match bcx.parent {\n+        None => create_function(bcx.fcx),\n+        Some(b) => create_block(b)\n     };\n-    let lldata = ~[lltag(tg),\n-                  parent,\n-                  lli32(start.line.to_int()),\n-                  lli32(start.col.to_int()),\n-                  file_node.node,\n-                  lli32(unique_id)\n-                 ];\n-    let val = llmdnode(lldata);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: BlockMetadata {\n-            start: start,\n-            end: end\n-        }\n+    let cx = bcx.ccx();\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let block_md = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(cx),\n+            parent, file_md,\n+            loc.line as c_uint, loc.col.to_uint() as c_uint)\n     };\n-    //update_cache(cache, tg, block_metadata(mdval));\n-    return mdval;\n+\n+    dbg_cx(cx).created_blocks.insert(id, block_md);\n+\n+    return block_md;\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (int, int) {\n+fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty) as int,\n-     machine::llalign_of_pref(cx, llty) as int)\n+    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n }\n \n-fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let cache = get_cache(cx);\n-    let tg = BasicTypeDescriptorTag;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, |md| ty::type_id(t) == md.data.hash) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n+    let ty_id = ty::type_id(t);\n+    match dbg_cx(cx).created_types.find(&ty_id) {\n+        Some(ty_md) => return *ty_md,\n+        None => ()\n     }\n \n+    debug!(\"create_basic_type: %?\", ty::get(t));\n+\n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n         ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n@@ -378,383 +242,275 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::create_basic_type - t is invalid type\")\n+        _ => cx.sess.bug(~\"debuginfo::create_basic_type - t is invalid type\")\n     };\n \n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let cu_node = create_compile_unit(cx);\n     let (size, align) = size_and_align_of(cx, t);\n-    let lldata = ~[lltag(tg),\n-                  cu_node.node,\n-                  llstr(name),\n-                  file_node.node,\n-                  lli32(0), //XXX source line\n-                  lli64(size * 8),  // size in bits\n-                  lli64(align * 8), // alignment in bits\n-                  lli64(0), //XXX offset?\n-                  lli32(0), //XXX flags?\n-                  lli32(encoding)];\n-    let llnode = llmdnode(lldata);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n+    let ty_md = do as_c_str(name) |name| { unsafe {\n+            llvm::LLVMDIBuilderCreateBasicType(\n+                DIB(cx), name,\n+                size * 8 as u64, align * 8 as u64, encoding as c_uint)\n+        }};\n+\n+    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n+    return ty_md;\n }\n \n-fn create_pointer_type(cx: &mut CrateContext, t: ty::t, span: span,\n-                       pointee: @Metadata<TyDescMetadata>)\n-    -> @Metadata<TyDescMetadata> {\n-    let tg = PointerTypeTag;\n-    /*let cache = cx.llmetadata;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n+fn create_pointer_type(cx: @mut CrateContext, t: ty::t, _span: span, pointee: DIType) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    //let cu_node = create_compile_unit(cx, fname);\n     let name = ty_to_str(cx.tcx, t);\n-    let llnode = create_derived_type(tg, file_node.node, name, 0, size * 8,\n-                                     align * 8, 0, pointee.node);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    //update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n-}\n-\n-struct StructCtxt {\n-    file: ValueRef,\n-    name: @str,\n-    line: int,\n-    members: ~[ValueRef],\n-    total_size: int,\n-    align: int\n-}\n+    let ptr_md = do as_c_str(name) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreatePointerType(DIB(cx),\n+                pointee, size * 8 as u64, align * 8 as u64, name)\n+    }};\n+    return ptr_md;\n+}\n+\n+struct StructContext {\n+    builder: DIBuilderRef,\n+    file: DIFile,\n+    name: ~str,\n+    line: uint,\n+    members: ~[DIDerivedType],\n+    total_size: uint,\n+    align: uint\n+}\n+\n+impl StructContext {\n+    fn new(cx: &CrateContext, name: ~str, file: DIFile, line: uint) -> ~StructContext {\n+        debug!(\"StructContext::create: %s\", name);\n+        let scx = ~StructContext {\n+            builder: DIB(cx),\n+            file: file,\n+            name: name,\n+            line: line,\n+            members: ~[],\n+            total_size: 0,\n+            align: 1\n+        };\n+        return scx;\n+    }\n \n-fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n-    return create_composite_type(StructureTypeTag,\n-                                 cx.name,\n-                                 cx.file,\n-                                 cx.line,\n-                                 cx.total_size,\n-                                 cx.align,\n-                                 0,\n-                                 None,\n-                                 Some(/*bad*/copy cx.members));\n-}\n+    fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n+        debug!(\"StructContext(%s)::add_member: %s, size=%u, align=%u\",\n+                self.name, name, size, align);\n+        let offset = roundup(self.total_size, align);\n+        let mem_t = do as_c_str(name) |name| { unsafe {\n+            llvm::LLVMDIBuilderCreateMemberType(\n+                self.builder, ptr::null(), name, self.file, line as c_uint,\n+                size * 8 as u64, align * 8 as u64, offset * 8 as u64,\n+                0, ty)\n+            }};\n+        self.members.push(mem_t);\n+        self.total_size = offset + size;\n+        // struct alignment is the max alignment of its' members\n+        self.align = cmp::max(self.align, align);\n+    }\n \n-fn create_structure(file: @Metadata<FileMetadata>, name: @str, line: int)\n-                 -> @mut StructCtxt {\n-    let cx = @mut StructCtxt {\n-        file: file.node,\n-        name: name,\n-        line: line,\n-        members: ~[],\n-        total_size: 0,\n-        align: 64 //XXX different alignment per arch?\n-    };\n-    return cx;\n+    fn finalize(&self) -> DICompositeType {\n+        debug!(\"StructContext(%s)::finalize: total_size=%u, align=%u\",\n+                self.name, self.total_size, self.align);\n+        let members_md = create_DIArray(self.builder, self.members);\n+\n+        let struct_md =\n+            do as_c_str(self.name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateStructType(\n+                    self.builder, self.file, name,\n+                    self.file, self.line as c_uint,\n+                    self.total_size * 8 as u64, self.align * 8 as u64, 0, ptr::null(),\n+                    members_md, 0, ptr::null())\n+            }};\n+        return struct_md;\n+    }\n }\n \n-fn create_derived_type(type_tag: int, file: ValueRef, name: &str, line: int,\n-                       size: int, align: int, offset: int, ty: ValueRef)\n-    -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  file,\n-                  llstr(name),\n-                  file,\n-                  lli32(line),\n-                  lli64(size),\n-                  lli64(align),\n-                  lli64(offset),\n-                  lli32(0),\n-                  ty];\n-    return llmdnode(lldata);\n+#[inline]\n+fn roundup(x: uint, a: uint) -> uint {\n+    ((x + (a - 1)) / a) * a\n }\n \n-fn add_member(cx: @mut StructCtxt,\n-              name: &str,\n-              line: int,\n-              size: int,\n-              align: int,\n-              ty: ValueRef) {\n-    cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n-                                        size * 8, align * 8, cx.total_size,\n-                                        ty));\n-    cx.total_size += size * 8;\n-}\n+fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: span)\n+                -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n \n-fn create_struct(cx: &mut CrateContext, t: ty::t, fields: ~[ty::field],\n-                 span: span) -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let scx = create_structure(file_node, (ty_to_str(cx.tcx, t)).to_managed(),\n-                               line_from_span(cx.sess.codemap, span) as int);\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, t), file_md, loc.line);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, cx.sess.str_of(field.ident),\n-                   line_from_span(cx.sess.codemap, span) as int,\n-                   size as int, align as int, ty_md.node);\n+        scx.add_member(cx.sess.str_of(field.ident), loc.line, size, align, ty_md);\n     }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n+    return scx.finalize();\n }\n \n-fn create_tuple(cx: &mut CrateContext, t: ty::t, elements: &[ty::t], span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let scx = create_structure(file_node,\n-                               cx.sess.str_of(\n-                                   ((/*bad*/copy cx.dbg_cx).get().names)\n-                                   (\"tuple\")),\n-                               line_from_span(cx.sess.codemap, span) as int);\n+// returns (void* type as a ValueRef, size in bytes, align in bytes)\n+fn voidptr(cx: @mut CrateContext) -> (DIDerivedType, uint, uint) {\n+    let size = sys::size_of::<ValueRef>();\n+    let align = sys::min_align_of::<ValueRef>();\n+    let vp = do as_c_str(\"*void\") |name| { unsafe {\n+            llvm::LLVMDIBuilderCreatePointerType(DIB(cx), ptr::null(),\n+                size*8 as u64, align*8 as u64, name)\n+        }};\n+    return (vp, size, align);\n+}\n+\n+fn create_tuple(cx: @mut CrateContext, _t: ty::t, elements: &[ty::t], span: span)\n+                -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let name = (cx.sess.str_of((dbg_cx(cx).names)(\"tuple\"))).to_owned();\n+    let mut scx = StructContext::new(cx, name, file_md, loc.line);\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n-        add_member(scx, \"\", line_from_span(cx.sess.codemap, span) as int,\n-                   size as int, align as int, ty_md.node);\n+        scx.add_member(\"\", loc.line, size, align, ty_md);\n     }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n+    return scx.finalize();\n }\n \n-// returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr() -> (ValueRef, int, int) {\n-    let null = ptr::null();\n-    let size = sys::size_of::<ValueRef>() as int;\n-    let align = sys::min_align_of::<ValueRef>() as int;\n-    let vp = create_derived_type(PointerTypeTag, null, \"\", 0,\n-                                 size, align, 0, null);\n-    return (vp, size, align);\n-}\n-\n-fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n-                     span: span, boxed: @Metadata<TyDescMetadata>)\n-    -> @Metadata<TyDescMetadata> {\n-    //let tg = StructureTypeTag;\n-    /*let cache = cx.llmetadata;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(contents) == ty::hash_ty(md.data.hash)}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    //let cu_node = create_compile_unit_metadata(cx, fname);\n+fn create_boxed_type(cx: @mut CrateContext, contents: ty::t,\n+                     span: span, boxed: DIType) -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n-    let scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n-    add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, refcount_type.node);\n+\n+    let mut scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n+    scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), refcount_type);\n     // the tydesc and other pointers should be irrelevant to the\n     // debugger, so treat them as void* types\n-    let (vp, vpsize, vpalign) = voidptr();\n-    add_member(scx, \"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(scx, \"prev\", 0, vpsize, vpalign, vp);\n-    add_member(scx, \"next\", 0, vpsize, vpalign, vp);\n+    let (vp, vpsize, vpalign) = voidptr(cx);\n+    scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n     let (size, align) = size_and_align_of(cx, contents);\n-    add_member(scx, \"boxed\", 0, size, align, boxed.node);\n-    let llnode = finish_structure(scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(contents)\n-        }\n-    };\n-    //update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n-}\n-\n-fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n-                         line: int, size: int, align: int, offset: int,\n-                         derived: Option<ValueRef>,\n-                         members: Option<~[ValueRef]>)\n-    -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  file,\n-                  llstr(name), // type name\n-                  file, // source file definition\n-                  lli32(line), // source line definition\n-                  lli64(size), // size of members\n-                  lli64(align), // align\n-                  lli32/*64*/(offset), // offset\n-                  lli32(0), // flags\n-                  if derived.is_none() {\n-                      llnull()\n-                  } else { // derived from\n-                      derived.get()\n-                  },\n-                  if members.is_none() {\n-                      llnull()\n-                  } else { //members\n-                      llmdnode(members.get())\n-                  },\n-                  lli32(0),  // runtime language\n-                  llnull()\n-                 ];\n-    return llmdnode(lldata);\n+    scx.add_member(\"boxed\", 0, size, align, boxed);\n+    return scx.finalize();\n }\n \n-fn create_fixed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    len: int, span: span) -> @Metadata<TyDescMetadata> {\n-    let t_md = create_ty(cx, elem_t, span);\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+fn create_fixed_vec(cx: @mut CrateContext, _vec_t: ty::t, elem_t: ty::t,\n+                    len: uint, span: span) -> DIType {\n+    let elem_ty_md = create_ty(cx, elem_t, span);\n     let (size, align) = size_and_align_of(cx, elem_t);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n-    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    let array = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n-                                      size * len, align, 0, Some(t_md.node),\n-                                      Some(~[subrange]));\n-    @Metadata {\n-        node: array,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    }\n+\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, len as i64)\n+    };\n+\n+    let subscripts = create_DIArray(DIB(cx), [subrange]);\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n+            size * len * 8 as u64, align * 8 as u64, elem_ty_md, subscripts)\n+    };\n }\n \n-fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    vec_ty_span: codemap::span)\n-    -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, vec_ty_span);\n-    let file_node = create_file(cx, fname.to_owned());\n+fn create_boxed_vec(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n+                    vec_ty_span: span) -> DICompositeType {\n+    let loc = span_start(cx, vec_ty_span);\n+    let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n-    let vec_scx = create_structure(file_node,\n-                               ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n+\n+    let mut vec_scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n-    add_member(vec_scx, \"fill\", 0, sys::size_of::<libc::size_t>() as int,\n-               sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    add_member(vec_scx, \"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n-               sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n+    vec_scx.add_member(\"fill\", 0, sys::size_of::<libc::size_t>(),\n+               sys::min_align_of::<libc::size_t>(), size_t_type);\n+    vec_scx.add_member(\"alloc\", 0, sys::size_of::<libc::size_t>(),\n+               sys::min_align_of::<libc::size_t>(), size_t_type);\n+    let subrange = unsafe {\n+        llvm::LLVMDIBuilderGetOrCreateSubrange(DIB(cx), 0_i64, 0_i64)\n+    };\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    let data_ptr = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n-                                         arr_size, arr_align, 0,\n-                                         Some(elem_ty_md.node),\n-                                         Some(~[subrange]));\n-    add_member(vec_scx, \"data\", 0, 0, // clang says the size should be 0\n-               sys::min_align_of::<u8>() as int, data_ptr);\n-    let llnode = finish_structure(vec_scx);\n-    let vec_md = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n+\n+    let subscripts = create_DIArray(DIB(cx), [subrange]);\n+    let data_ptr = unsafe {\n+        llvm::LLVMDIBuilderCreateArrayType(DIB(cx),\n+            arr_size * 8 as u64, arr_align * 8 as u64, elem_ty_md, subscripts)\n     };\n+    vec_scx.add_member(\"data\", 0, 0, // clang says the size should be 0\n+               sys::min_align_of::<u8>(), data_ptr);\n+    let vec_md = vec_scx.finalize();\n \n-    let box_scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n+    let mut box_scx = StructContext::new(cx, fmt!(\"box<%s>\", name), file_md, 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n-    add_member(box_scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, refcount_type.node);\n-    let (vp, vpsize, vpalign) = voidptr();\n-    add_member(box_scx, \"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, \"prev\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, \"next\", 0, vpsize, vpalign, vp);\n-    let size = 2 * sys::size_of::<int>() as int;\n-    let align = sys::min_align_of::<int>() as int;\n-    add_member(box_scx, \"boxed\", 0, size, align, vec_md.node);\n-    let llnode = finish_structure(box_scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(elem_t)\n-        }\n-    };\n+    box_scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), refcount_type);\n+    let (vp, vpsize, vpalign) = voidptr(cx);\n+    box_scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+    box_scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+    box_scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n+    let size = 2 * sys::size_of::<int>();\n+    let align = sys::min_align_of::<int>();\n+    box_scx.add_member(\"boxed\", 0, size, align, vec_md);\n+    let mdval = box_scx.finalize();\n     return mdval;\n }\n \n-fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+fn create_vec_slice(cx: @mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+                    -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n-    let (_, ptr_size, ptr_align) = voidptr();\n-    add_member(scx, \"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n-    add_member(scx, \"length\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, uint_type.node);\n-    let llnode = finish_structure(scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    };\n-    return mdval;\n+\n+    let mut scx = StructContext::new(cx, ty_to_str(cx.tcx, vec_t), file_md, 0);\n+    let (_, ptr_size, ptr_align) = voidptr(cx);\n+    scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n+    scx.add_member(\"length\", 0, sys::size_of::<uint>(),\n+                    sys::min_align_of::<uint>(), uint_type);\n+    return scx.finalize();\n }\n \n-fn create_fn_ty(cx: &mut CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n-                span: span) -> @Metadata<TyDescMetadata> {\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let (vp, _, _) = voidptr();\n+fn create_fn_ty(cx: @mut CrateContext, _fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+                span: span) -> DICompositeType {\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+    let (vp, _, _) = voidptr(cx);\n     let output_md = create_ty(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span).node };\n-    let members = ~[output_ptr_md.node, vp] + inputs_vals;\n-    let llnode = create_composite_type(SubroutineTag, \"\", file_node.node,\n-                                       0, 0, 0, 0, None, Some(members));\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(fn_ty)\n-        }\n+    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span) };\n+    let members = ~[output_ptr_md, vp] + inputs_vals;\n+\n+    return unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_md,\n+            create_DIArray(DIB(cx), members))\n     };\n-    return mdval;\n }\n \n-fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n+fn create_unimpl_ty(cx: @mut CrateContext, t: ty::t) -> DIType {\n+    let name = ty_to_str(cx.tcx, t);\n+    let md = do as_c_str(fmt!(\"NYI<%s>\", name)) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateBasicType(\n+            DIB(cx), name,\n+            0_u64, 8_u64, DW_ATE_unsigned as c_uint)\n+        }};\n+    return md;\n+}\n+\n+fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n+    let ty_id = ty::type_id(t);\n+    match dbg_cx(cx).created_types.find(&ty_id) {\n+        Some(ty_md) => return *ty_md,\n+        None => ()\n+    }\n+\n     debug!(\"create_ty: %?\", ty::get(t));\n-    /*let cache = get_cache(cx);\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| t == md.data.hash}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n \n     let sty = copy ty::get(t).sty;\n-    match sty {\n+    let ty_md = match sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, i8_t, len as int + 1, span)\n+                    create_fixed_vec(cx, t, i8_t, len + 1, span)\n                 },\n                 ty::vstore_uniq | ty::vstore_box => {\n                     let box_md = create_boxed_vec(cx, t, i8_t, span);\n@@ -766,7 +522,8 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n             }\n         },\n         ty::ty_enum(_did, ref _substs) => {\n-            cx.sess.span_bug(span, \"debuginfo for enum NYI\")\n+            cx.sess.span_note(span, \"debuginfo for enum NYI\");\n+            create_unimpl_ty(cx, t)\n         }\n         ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n             let boxed = create_ty(cx, mt.ty, span);\n@@ -776,7 +533,7 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, mt.ty, len as int, span)\n+                    create_fixed_vec(cx, t, mt.ty, len, span)\n                 },\n                 ty::vstore_uniq | ty::vstore_box => {\n                     let box_md = create_boxed_vec(cx, t, mt.ty, span);\n@@ -792,18 +549,21 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n             create_pointer_type(cx, t, span, pointee)\n         },\n         ty::ty_rptr(ref _region, ref _mt) => {\n-            cx.sess.span_bug(span, \"debuginfo for rptr NYI\")\n+            cx.sess.span_note(span, \"debuginfo for rptr NYI\");\n+            create_unimpl_ty(cx, t)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n             let inputs = barefnty.sig.inputs.map(|a| *a);\n             let output = barefnty.sig.output;\n             create_fn_ty(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n-            cx.sess.span_bug(span, \"debuginfo for closure NYI\")\n+            cx.sess.span_note(span, \"debuginfo for closure NYI\");\n+            create_unimpl_ty(cx, t)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _) => {\n-            cx.sess.span_bug(span, \"debuginfo for trait NYI\")\n+            cx.sess.span_note(span, \"debuginfo for trait NYI\");\n+            create_unimpl_ty(cx, t)\n         },\n         ty::ty_struct(did, ref substs) => {\n             let fields = ty::struct_fields(cx.tcx, did, substs);\n@@ -812,60 +572,42 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n         ty::ty_tup(ref elements) => {\n             create_tuple(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in create_ty\")\n-    }\n-}\n-\n-fn filename_from_span(cx: &CrateContext, sp: codemap::span) -> @str {\n-    cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n-}\n+        _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n+    };\n \n-fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n-              line: int, ret_ty: ValueRef) -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  context,\n-                  llstr(name),\n-                  file,\n-                  lli32(line),\n-                  ret_ty,\n-                  lli32(0)\n-                 ];\n-    return llmdnode(lldata);\n+    dbg_cx(cx).created_types.insert(ty_id, ty_md);\n+    return ty_md;\n }\n \n-pub fn create_local_var(bcx: block, local: @ast::local)\n-    -> @Metadata<LocalVarMetadata> {\n+pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n-    let cache = get_cache(cx);\n-    let tg = AutoVariableTag;\n-    match cached_metadata::<@Metadata<LocalVarMetadata>>(\n-        cache, tg, |md| md.data.id == local.node.id) {\n-      option::Some(md) => return md,\n-      option::None => ()\n-    }\n \n-    let name = match local.node.pat.node {\n+    let ident = match local.node.pat.node {\n       ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n-      _ => fail!(\"no single variable name for local\")\n+      _ => {\n+        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n+        return ptr::null();\n+      }\n     };\n-    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n+    let name: &str = cx.sess.str_of(ident);\n+    debug!(\"create_local_var: %s\", name);\n+\n+    let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, /*bad*/ loc.file.name.to_owned());\n+    let filemd = create_file(cx, loc.file.name);\n     let context = match bcx.parent {\n-        None => create_function(bcx.fcx).node,\n-        Some(_) => create_block(bcx).node\n+        None => create_function(bcx.fcx),\n+        Some(_) => create_block(bcx)\n     };\n-    let mdnode = create_var(tg, context, cx.sess.str_of(name),\n-                            filemd.node, loc.line as int, tymd.node);\n-    let mdval = @Metadata {\n-        node: mdnode,\n-        data: LocalVarMetadata {\n-            id: local.node.id\n-        }\n-    };\n-    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n+\n+    let var_md = do as_c_str(name) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateLocalVariable(\n+            DIB(cx), AutoVariableTag as u32,\n+            context, name, filemd,\n+            loc.line as c_uint, tymd, false, 0, 0)\n+        }};\n \n     // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n     let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n@@ -876,92 +618,94 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n                 fmt!(\"No entry in lllocals table for %?\", local.node.id));\n         }\n     };\n-    let declargs = ~[llmdnode([llptr]), mdnode];\n-    trans::build::Call(bcx, cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n-                       declargs);\n-    return mdval;\n+\n+    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+    unsafe {\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+    }\n+\n+    return var_md;\n }\n \n-pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n-    -> Option<@Metadata<ArgumentMetadata>> {\n+pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+    debug!(\"create_arg\");\n+    if true {\n+        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n+        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        return None;\n+    }\n+\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n-    let cache = get_cache(cx);\n-    let tg = ArgVariableTag;\n-    match cached_metadata::<@Metadata<ArgumentMetadata>>(\n-        cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-      option::Some(md) => return Some(md),\n-      option::None => ()\n-    }\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+    let loc = span_start(cx, span);\n     if \"<intrinsic>\" == loc.file.name {\n         return None;\n     }\n+\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, /* bad */ loc.file.name.to_owned());\n-    let context = create_function(bcx.fcx);\n+    let filemd = create_file(cx, loc.file.name);\n+    let context = create_function(fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n-            let mdnode = create_var(\n-                tg,\n-                context.node,\n-                cx.sess.str_of(*path.idents.last()),\n-                filemd.node,\n-                loc.line as int,\n-                tymd.node\n-            );\n-\n-            let mdval = @Metadata {\n-                node: mdnode,\n-                data: ArgumentMetadata {\n-                    id: arg.id\n-                }\n-            };\n-            update_cache(cache, tg, argument_metadata(mdval));\n+            let ident = path.idents.last();\n+            let name: &str = cx.sess.str_of(*ident);\n+            let mdnode = do as_c_str(name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n+                    ArgVariableTag as u32, context, name,\n+                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n+                    // XXX need to pass in a real argument number\n+            }};\n \n             let llptr = fcx.llargs.get_copy(&arg.id);\n-            let declargs = ~[llmdnode([llptr]), mdnode];\n-            trans::build::Call(bcx,\n-                               cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n-                               declargs);\n-            return Some(mdval);\n+            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                        DIB(cx), llptr, mdnode, bcx.llbb);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+            }\n+            return Some(mdnode);\n         }\n         _ => {\n             return None;\n         }\n     }\n }\n \n-pub fn update_source_pos(cx: block, s: span) {\n-    if !cx.sess().opts.debuginfo || (*s.lo == 0 && *s.hi == 0) {\n+fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n+    if dbg_cx(cx).curr_loc == (line, col) {\n         return;\n     }\n-    let cm = cx.sess().codemap;\n-    let blockmd = create_block(cx);\n-    let loc = cm.lookup_char_pos(s.lo);\n-    let scopedata = ~[lli32(loc.line.to_int()),\n-                     lli32(loc.col.to_int()),\n-                     blockmd.node,\n-                     llnull()];\n-    let dbgscope = llmdnode(scopedata);\n+    debug!(\"setting debug location to %u %u\", line, col);\n+    dbg_cx(cx).curr_loc = (line, col);\n+\n+    let elems = ~[C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n+        let dbg_loc = llvm::LLVMMDNodeInContext(\n+                dbg_cx(cx).llcontext, vec::raw::to_ptr(elems),\n+                elems.len() as libc::c_uint);\n+        llvm::LLVMSetCurrentDebugLocation(cx.builder.B, dbg_loc);\n     }\n }\n \n-pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n-    let mut cx = fcx.ccx;\n-\n-    debug!(\"~~\");\n+/// Set current debug location at the beginning of the span\n+pub fn update_source_pos(bcx: block, span: span) {\n+    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+        return;\n+    }\n+    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n+    let loc = span_start(bcx.ccx(), span);\n+    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n+}\n \n+pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+    let cx = fcx.ccx;\n     let fcx = &mut *fcx;\n-\n-    let sp = fcx.span.get();\n-    debug!(\"%s\", cx.sess.codemap.span_to_str(sp));\n+    let span = fcx.span.get();\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n       ast_map::node_item(item, _) => {\n@@ -978,8 +722,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n-            let dbg_cx = cx.dbg_cx.get_ref();\n-            ((dbg_cx.names)(\"fn\"), decl.output, expr.id)\n+            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")\n@@ -988,62 +731,46 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n \n-    debug!(\"%?\", ident);\n-    debug!(\"%?\", id);\n-\n-    let cache = get_cache(cx);\n-    match cached_metadata::<@Metadata<SubProgramMetadata>>(\n-        cache, SubprogramTag, |md| md.data.id == id) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+    match dbg_cx(cx).created_functions.find(&id) {\n+        Some(fn_md) => return *fn_md,\n+        None => ()\n     }\n \n-    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    let file_node = create_file(cx, loc.file.name.to_owned()).node;\n-    let ty_node = if cx.sess.opts.extra_debuginfo {\n+    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n-          ast::ty_nil => llnull(),\n+          ast::ty_nil => ptr::null(),\n           _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n-                         ret_ty.span).node\n+                         ret_ty.span)\n         }\n     } else {\n-        llnull()\n+        ptr::null()\n     };\n-    let sub_node = create_composite_type(SubroutineTag, \"\", file_node, 0, 0,\n-                                         0, 0, option::None,\n-                                         option::Some(~[ty_node]));\n-\n-    let fn_metadata = ~[lltag(SubprogramTag),\n-                       llunused(),\n-                       file_node,\n-                       llstr(cx.sess.str_of(ident)),\n-                        //XXX fully-qualified C++ name:\n-                       llstr(cx.sess.str_of(ident)),\n-                       llstr(\"\"), //XXX MIPS name?????\n-                       file_node,\n-                       lli32(loc.line as int),\n-                       sub_node,\n-                       lli1(false), //XXX static (check export)\n-                       lli1(true), // defined in compilation unit\n-                       lli32(DW_VIRTUALITY_none), // virtual-ness\n-                       lli32(0i), //index into virt func\n-                       /*llnull()*/ lli32(0), // base type with vtbl\n-                       lli32(256), // flags\n-                       lli1(cx.sess.opts.optimize != session::No),\n-                       fcx.llfn\n-                       //list of template params\n-                       //func decl descriptor\n-                       //list of func vars\n-                      ];\n-    let val = llmdnode(fn_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.sp\", val);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: SubProgramMetadata {\n-            id: id\n-        }\n+\n+    let fn_ty = unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n+            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n     };\n-    update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n \n-    return mdval;\n+    let fn_md =\n+        do as_c_str(cx.sess.str_of(ident)) |name| {\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                DIB(cx),\n+                file_md,\n+                name, linkage,\n+                file_md, loc.line as c_uint,\n+                fn_ty, false, true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn, ptr::null(), ptr::null())\n+            }}};\n+\n+    dbg_cx(cx).created_functions.insert(id, fn_md);\n+    return fn_md;\n }"}, {"sha": "614c1723c5fb75c0710b326e0f6688e59290dcb7", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -560,3 +560,228 @@ extern \"C\" bool LLVMRustStartMultithreading() {\n     assert(lock.release());\n     return ret;\n }\n+\n+\n+typedef DIBuilder* DIBuilderRef;\n+\n+template<typename DIT>\n+DIT unwrapDI(LLVMValueRef ref) { \n+    return DIT(ref ? unwrap<MDNode>(ref) : NULL); \n+}\n+\n+extern \"C\" DIBuilderRef LLVMDIBuilderCreate(LLVMModuleRef M) {\n+    return new DIBuilder(*unwrap(M));\n+}\n+\n+extern \"C\" void LLVMDIBuilderDispose(DIBuilderRef Builder) {\n+    delete Builder;\n+}\n+\n+extern \"C\" void LLVMDIBuilderFinalize(DIBuilderRef Builder) {\n+    Builder->finalize();\n+}\n+\n+extern \"C\" void LLVMDIBuilderCreateCompileUnit(\n+    DIBuilderRef Builder,\n+    unsigned Lang,\n+    const char* File,\n+    const char* Dir,\n+    const char* Producer,\n+    bool isOptimized,\n+    const char* Flags,\n+    unsigned RuntimeVer,\n+    const char* SplitName) {\n+    Builder->createCompileUnit(Lang, File, Dir, Producer, isOptimized,\n+        Flags, RuntimeVer, SplitName);\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateFile(\n+    DIBuilderRef Builder,\n+    const char* Filename,\n+    const char* Directory) {\n+    return wrap(Builder->createFile(Filename, Directory));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateSubroutineType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef File, \n+    LLVMValueRef ParameterTypes) {\n+    return wrap(Builder->createSubroutineType(\n+        unwrapDI<DIFile>(File), \n+        unwrapDI<DIArray>(ParameterTypes)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateFunction(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope, \n+    const char* Name,\n+    const char* LinkageName,\n+    LLVMValueRef File,  \n+    unsigned LineNo,\n+    LLVMValueRef Ty, \n+    bool isLocalToUnit,\n+    bool isDefinition,\n+    unsigned ScopeLine,\n+    unsigned Flags,\n+    bool isOptimized,\n+    LLVMValueRef Fn,\n+    LLVMValueRef TParam,\n+    LLVMValueRef Decl) {\n+    return wrap(Builder->createFunction(\n+        unwrapDI<DIScope>(Scope), Name, LinkageName, \n+        unwrapDI<DIFile>(File), LineNo, \n+        unwrapDI<DIType>(Ty), isLocalToUnit, isDefinition, ScopeLine, \n+        Flags, isOptimized,\n+        unwrap<Function>(Fn), \n+        unwrapDI<MDNode*>(TParam),\n+        unwrapDI<MDNode*>(Decl)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateBasicType(\n+    DIBuilderRef Builder,\n+    const char* Name,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    unsigned Encoding) {\n+    return wrap(Builder->createBasicType(\n+        Name, SizeInBits, \n+        AlignInBits, Encoding));\n+}\n+    \n+extern \"C\" LLVMValueRef LLVMDIBuilderCreatePointerType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef PointeeTy,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    const char* Name) {\n+    return wrap(Builder->createPointerType(\n+        unwrapDI<DIType>(PointeeTy), SizeInBits, AlignInBits, Name));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateStructType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNumber,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    unsigned Flags,\n+    LLVMValueRef DerivedFrom,\n+    LLVMValueRef Elements,\n+    unsigned RunTimeLang,\n+    LLVMValueRef VTableHolder) {\n+    return wrap(Builder->createStructType(\n+        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIFile>(File), LineNumber, \n+        SizeInBits, AlignInBits, Flags, \n+        unwrapDI<DIType>(DerivedFrom), \n+        unwrapDI<DIArray>(Elements), RunTimeLang, \n+        unwrapDI<MDNode*>(VTableHolder)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateMemberType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNo,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    uint64_t OffsetInBits,\n+    unsigned Flags,\n+    LLVMValueRef Ty) {\n+    return wrap(Builder->createMemberType(\n+        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIFile>(File), LineNo,\n+        SizeInBits, AlignInBits, OffsetInBits, Flags, \n+        unwrapDI<DIType>(Ty)));\n+}\n+    \n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateLexicalBlock(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    LLVMValueRef File,\n+    unsigned Line,\n+    unsigned Col) {\n+    return wrap(Builder->createLexicalBlock(\n+        unwrapDI<DIDescriptor>(Scope), \n+        unwrapDI<DIFile>(File), Line, Col));\n+}\n+    \n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateLocalVariable(\n+    DIBuilderRef Builder,\n+    unsigned Tag,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNo,\n+    LLVMValueRef Ty,\n+    bool AlwaysPreserve,\n+    unsigned Flags,\n+    unsigned ArgNo) {\n+    return wrap(Builder->createLocalVariable(Tag, \n+        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIFile>(File), \n+        LineNo, \n+        unwrapDI<DIType>(Ty), AlwaysPreserve, Flags, ArgNo));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateArrayType(\n+    DIBuilderRef Builder,\n+    uint64_t Size,  \n+    uint64_t AlignInBits,  \n+    LLVMValueRef Ty, \n+    LLVMValueRef Subscripts) {\n+    return wrap(Builder->createArrayType(Size, AlignInBits,\n+        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIArray>(Subscripts)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateVectorType(\n+    DIBuilderRef Builder,\n+    uint64_t Size,  \n+    uint64_t AlignInBits,  \n+    LLVMValueRef Ty, \n+    LLVMValueRef Subscripts) {\n+    return wrap(Builder->createVectorType(Size, AlignInBits,\n+        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIArray>(Subscripts)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderGetOrCreateSubrange(\n+    DIBuilderRef Builder, \n+    int64_t Lo, \n+    int64_t Count) {\n+    return wrap(Builder->getOrCreateSubrange(Lo, Count));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderGetOrCreateArray(\n+    DIBuilderRef Builder,\n+    LLVMValueRef* Ptr, \n+    unsigned Count) {\n+    return wrap(Builder->getOrCreateArray(\n+        ArrayRef<Value*>(reinterpret_cast<Value**>(Ptr), Count)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Val,\n+    LLVMValueRef VarInfo,\n+    LLVMBasicBlockRef InsertAtEnd) {\n+    return wrap(Builder->insertDeclare(\n+        unwrap(Val), \n+        unwrapDI<DIVariable>(VarInfo), \n+        unwrap(InsertAtEnd)));\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Val,\n+    LLVMValueRef VarInfo,\n+    LLVMValueRef InsertBefore) {\n+    return wrap(Builder->insertDeclare(\n+        unwrap(Val), \n+        unwrapDI<DIVariable>(VarInfo), \n+        unwrap<Instruction>(InsertBefore)));\n+}"}, {"sha": "2a3f7de9bf5a07659ba2ef9b74c50c71a531090e", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -588,3 +588,22 @@ LLVMInlineAsm\n LLVMInitializePasses\n LLVMAddPass\n LLVMCreatePass\n+LLVMDIBuilderCreate\n+LLVMDIBuilderDispose\n+LLVMDIBuilderFinalize\n+LLVMDIBuilderCreateCompileUnit\n+LLVMDIBuilderCreateLocalVariable\n+LLVMDIBuilderCreateFunction\n+LLVMDIBuilderCreateFile\n+LLVMDIBuilderCreateLexicalBlock\n+LLVMDIBuilderCreateBasicType\n+LLVMDIBuilderCreatePointerType\n+LLVMDIBuilderCreateMemberType\n+LLVMDIBuilderCreateStructType\n+LLVMDIBuilderGetOrCreateSubrange\n+LLVMDIBuilderCreateArrayType\n+LLVMDIBuilderCreateVectorType\n+LLVMDIBuilderCreateSubroutineType\n+LLVMDIBuilderGetOrCreateArray\n+LLVMDIBuilderInsertDeclareAtEnd\n+LLVMDIBuilderInsertDeclareBefore"}, {"sha": "d4202abd2854e685a9e6c0774143bbf67b5eb6fd", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -43,6 +43,8 @@\n #include \"llvm/Transforms/IPO.h\"\n #include \"llvm/Transforms/Instrumentation.h\"\n #include \"llvm/Transforms/Vectorize.h\"\n+#include \"llvm/DebugInfo.h\"\n+#include \"llvm/DIBuilder.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n #include \"llvm-c/ExecutionEngine.h\""}, {"sha": "616740c850c5431d81d8c99a2b80630197ad2d2d", "filename": "src/test/debug-info/basic-types.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // Caveats - gdb prints any 8-bit value (meaning rust i8 and u8 values)\n // as its numerical value along with its associated ASCII char, there\n@@ -17,8 +17,9 @@\n // its numerical value.\n \n // compile-flags:-Z extra-debug-info\n-// debugger:break 67\n+// debugger:break _zzz\n // debugger:run\n+// debugger:finish\n // debugger:print b\n // check:$1 = false\n // debugger:print i\n@@ -66,5 +67,7 @@ fn main() {\n     let f: float = 1.5;\n     let f32: f32 = 2.5;\n     let f64: f64 = 3.5;\n-    let _z = ();\n+    _zzz();\n }\n+\n+fn _zzz() {()}"}, {"sha": "3e5483ad75b3a4a0360d472ea8cfecf17ae9c0e3", "filename": "src/test/debug-info/box.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n-// debugger:break 29\n+// debugger:break _zzz\n // debugger:run\n+// debugger:finish\n // debugger:print a->boxed\n // check:$1 = 1\n // debugger:print b->boxed\n@@ -28,5 +29,7 @@ fn main() {\n     let b = ~(2, 3.5);\n     let c = @4;\n     let d = @false;\n-    let _z = 0;\n+    _zzz();\n }\n+\n+fn _zzz() {()}\n\\ No newline at end of file"}, {"sha": "ddfac9cbeea8f6312632990e585df7b034a73f27", "filename": "src/test/debug-info/struct.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n-// debugger:break 29\n+// debugger:break _zzz\n // debugger:run\n+// debugger:finish\n // debugger:print pair\n // check:$1 = {x = 1, y = 2}\n // debugger:print pair.x\n@@ -28,5 +29,7 @@ struct Pair {\n \n fn main() {\n     let pair = Pair { x: 1, y: 2 };\n-    let _z = ();\n+    _zzz();\n }\n+\n+fn _zzz() {()}\n\\ No newline at end of file"}, {"sha": "a50996871cee98e9e960b0abbcffdb91fd2cb6bc", "filename": "src/test/debug-info/tuple.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -8,16 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n-// debugger:break 20\n+// debugger:break _zzz\n // debugger:run\n+// debugger:finish\n // debugger:print t\n // check:$1 = {4, 5.5, true}\n \n fn main() {\n     let t = (4, 5.5, true);\n-    let _z = ();\n+    _zzz();\n }\n+\n+fn _zzz() {()}\n\\ No newline at end of file"}, {"sha": "c87849ac4b6ddc9b4fbbdee0f0eabb314d69d7b3", "filename": "src/test/debug-info/vec.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf074cc66974143178a6add3a7c2e2196ea5a32/src%2Ftest%2Fdebug-info%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec.rs?ref=4bf074cc66974143178a6add3a7c2e2196ea5a32", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n \n // compile-flags:-Z extra-debug-info\n // debugger:set print pretty off\n-// debugger:break 29\n+// debugger:break _zzz\n // debugger:run\n+// debugger:finish\n // debugger:print a\n // check:$1 = {1, 2, 3}\n // debugger:print b.vec[0]\n@@ -28,5 +29,7 @@ fn main() {\n     let b = &[4, 5, 6];\n     let c = @[7, 8, 9];\n     let d = ~[10, 11, 12];\n-    let _z = 0;\n+    _zzz();\n }\n+\n+fn _zzz() {()}\n\\ No newline at end of file"}]}