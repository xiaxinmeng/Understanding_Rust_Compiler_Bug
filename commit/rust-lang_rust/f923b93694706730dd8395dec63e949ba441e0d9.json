{"sha": "f923b93694706730dd8395dec63e949ba441e0d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MjNiOTM2OTQ3MDY3MzBkZDgzOTVkZWM2M2U5NDliYTQ0MWUwZDk=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-04-08T15:18:10Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-05-16T16:57:32Z"}, "message": "term: add docs and windows support\n\nCloses #2807", "tree": {"sha": "e9c76d496c4431f5fe7380887913c7ca71a1c1e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c76d496c4431f5fe7380887913c7ca71a1c1e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f923b93694706730dd8395dec63e949ba441e0d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f923b93694706730dd8395dec63e949ba441e0d9", "html_url": "https://github.com/rust-lang/rust/commit/f923b93694706730dd8395dec63e949ba441e0d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f923b93694706730dd8395dec63e949ba441e0d9/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e30198d9d4d4d016949625062bde002bc33aa574", "url": "https://api.github.com/repos/rust-lang/rust/commits/e30198d9d4d4d016949625062bde002bc33aa574", "html_url": "https://github.com/rust-lang/rust/commit/e30198d9d4d4d016949625062bde002bc33aa574"}], "stats": {"total": 620, "additions": 440, "deletions": 180}, "files": [{"sha": "895819a5a50c0aae692a26c9e904a4155dac5908", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f923b93694706730dd8395dec63e949ba441e0d9/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f923b93694706730dd8395dec63e949ba441e0d9/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=f923b93694706730dd8395dec63e949ba441e0d9", "patch": "@@ -73,7 +73,7 @@ DEPS_arena := std collections\n DEPS_graphviz := std\n DEPS_glob := std\n DEPS_serialize := std collections log\n-DEPS_term := std collections\n+DEPS_term := std collections log\n DEPS_semver := std\n DEPS_uuid := std serialize rand\n DEPS_sync := std"}, {"sha": "8f5452c23f26b8adff50af31890dec740060545b", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 107, "deletions": 179, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/f923b93694706730dd8395dec63e949ba441e0d9/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f923b93694706730dd8395dec63e949ba441e0d9/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=f923b93694706730dd8395dec63e949ba441e0d9", "patch": "@@ -8,7 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Simple ANSI color library\n+//! Terminal formatting library.\n+//!\n+//! This crate provides the `Terminal` trait, which abstracts over an [ANSI\n+//! Termina][ansi] to provide color printing, among other things. There are two implementations,\n+//! the `TerminfoTerminal`, which uses control characters from a\n+//! [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n+//! API][win].\n+//!\n+//! ## Example\n+//!\n+//! ```rust\n+//! extern crate term;\n+//!\n+//! fn main() {\n+//!     let mut t = term::stdout();\n+//!     t.fg(term::color::GREEN);\n+//!     println!(\"hello, \");\n+//!     t.fg(term::color::RED);\n+//!     println(\"world!\");\n+//!     t.reset();\n+//! }\n+//! ```\n+//!\n+//! [ansi]: https://en.wikipedia.org/wiki/ANSI_escape_code\n+//! [win]: http://msdn.microsoft.com/en-us/library/windows/desktop/ms682010%28v=vs.85%29.aspx\n+//! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![crate_id = \"term#0.11.0-pre\"]\n #![comment = \"Simple ANSI color library\"]\n@@ -19,22 +44,76 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n \n-#![feature(macro_rules)]\n+#![feature(macro_rules, phase)]\n \n #![deny(missing_doc)]\n \n+#[phase(syntax, link)] extern crate log;\n extern crate collections;\n \n-use std::io;\n-use std::os;\n-use terminfo::TermInfo;\n-use terminfo::searcher::open;\n-use terminfo::parser::compiled::{parse, msys_terminfo};\n-use terminfo::parm::{expand, Number, Variables};\n+pub use terminfo::TerminfoTerminal;\n+#[cfg(windows)]\n+pub use win::WinConsole;\n+\n+use std::io::IoResult;\n \n pub mod terminfo;\n \n-// FIXME (#2807): Windows support.\n+#[cfg(windows)]\n+mod win;\n+\n+#[cfg(not(windows))]\n+/// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub fn stdout() -> Option<~Terminal<~Writer:Send>:Send> {\n+    let ti: Option<TerminfoTerminal<~Writer:Send>>\n+        = Terminal::new(~std::io::stdout() as ~Writer:Send);\n+    ti.map(|t| ~t as ~Terminal<~Writer:Send>:Send)\n+}\n+\n+#[cfg(windows)]\n+/// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub fn stdout() -> Option<~Terminal<~Writer:Send>:Send> {\n+    let ti: Option<TerminfoTerminal<~Writer:Send>>\n+        = Terminal::new(~std::io::stdout() as ~Writer:Send);\n+\n+    match ti {\n+        Some(t) => Some(~t as ~Terminal<~Writer:Send>:Send),\n+        None => {\n+            let wc: Option<WinConsole<~Writer:Send>>\n+                = Terminal::new(~std::io::stdout() as ~Writer:Send);\n+            wc.map(|w| ~w as ~Terminal<~Writer:Send>:Send)\n+        }\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+/// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n+/// opened.\n+pub fn stderr() -> Option<~Terminal<~Writer:Send>:Send> {\n+    let ti: Option<TerminfoTerminal<~Writer:Send>>\n+        = Terminal::new(~std::io::stderr() as ~Writer:Send);\n+    ti.map(|t| ~t as ~Terminal<~Writer:Send>:Send)\n+}\n+\n+#[cfg(windows)]\n+/// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n+/// opened.\n+pub fn stderr() -> Option<~Terminal<~Writer:Send>:Send> {\n+    let ti: Option<TerminfoTerminal<~Writer:Send>>\n+        = Terminal::new(~std::io::stderr() as ~Writer:Send);\n+\n+    match ti {\n+        Some(t) => Some(~t as ~Terminal<~Writer:Send>:Send),\n+        None => {\n+            let wc: Option<WinConsole<~Writer:Send>>\n+                = Terminal::new(~std::io::stderr() as ~Writer:Send);\n+            wc.map(|w| ~w as ~Terminal<~Writer:Send>:Send)\n+        }\n+    }\n+}\n+\n \n /// Terminal color definitions\n pub mod color {\n@@ -91,200 +170,49 @@ pub mod attr {\n     }\n }\n \n-fn cap_for_attr(attr: attr::Attr) -> &'static str {\n-    match attr {\n-        attr::Bold               => \"bold\",\n-        attr::Dim                => \"dim\",\n-        attr::Italic(true)       => \"sitm\",\n-        attr::Italic(false)      => \"ritm\",\n-        attr::Underline(true)    => \"smul\",\n-        attr::Underline(false)   => \"rmul\",\n-        attr::Blink              => \"blink\",\n-        attr::Standout(true)     => \"smso\",\n-        attr::Standout(false)    => \"rmso\",\n-        attr::Reverse            => \"rev\",\n-        attr::Secure             => \"invis\",\n-        attr::ForegroundColor(_) => \"setaf\",\n-        attr::BackgroundColor(_) => \"setab\"\n-    }\n-}\n-\n-/// A Terminal that knows how many colors it supports, with a reference to its\n-/// parsed TermInfo database record.\n-pub struct Terminal<T> {\n-    num_colors: u16,\n-    out: T,\n-    ti: Box<TermInfo>,\n-}\n-\n-impl<T: Writer> Terminal<T> {\n-    /// Returns a wrapped output stream (`Terminal<T>`) as a `Result`.\n-    ///\n-    /// Returns `Err()` if the TERM environment variable is undefined.\n-    /// TERM should be set to something like `xterm-color` or `screen-256color`.\n-    ///\n-    /// Returns `Err()` on failure to open the terminfo database correctly.\n-    /// Also, in the event that the individual terminfo database entry can not\n-    /// be parsed.\n-    pub fn new(out: T) -> Result<Terminal<T>, StrBuf> {\n-        let term = match os::getenv(\"TERM\") {\n-            Some(t) => t,\n-            None => {\n-                return Err(\"TERM environment variable undefined\".to_strbuf())\n-            }\n-        };\n-\n-        let mut file = match open(term) {\n-            Ok(file) => file,\n-            Err(err) => {\n-                if \"cygwin\" == term { // msys terminal\n-                    return Ok(Terminal {\n-                        out: out,\n-                        ti: msys_terminfo(),\n-                        num_colors: 8\n-                    });\n-                }\n-                return Err(err);\n-            }\n-        };\n+/// A terminal with similar capabilities to an ANSI Terminal\n+/// (foreground/background colors etc).\n+pub trait Terminal<T: Writer>: Writer {\n+    /// Returns `None` whenever the terminal cannot be created for some\n+    /// reason.\n+    fn new(out: T) -> Option<Self>;\n \n-        let inf = try!(parse(&mut file, false));\n-\n-        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n-                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n-                 } else { 0 };\n-\n-        return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n-    }\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n     /// if there was an I/O error.\n-    pub fn fg(&mut self, color: color::Color) -> io::IoResult<bool> {\n-        let color = self.dim_if_necessary(color);\n-        if self.num_colors > color {\n-            let s = expand(self.ti\n-                               .strings\n-                               .find_equiv(&(\"setaf\"))\n-                               .unwrap()\n-                               .as_slice(),\n-                           [Number(color as int)], &mut Variables::new());\n-            if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n-                return Ok(true)\n-            }\n-        }\n-        Ok(false)\n-    }\n+    fn fg(&mut self, color: color::Color) -> IoResult<bool>;\n+\n     /// Sets the background color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n     /// if there was an I/O error.\n-    pub fn bg(&mut self, color: color::Color) -> io::IoResult<bool> {\n-        let color = self.dim_if_necessary(color);\n-        if self.num_colors > color {\n-            let s = expand(self.ti\n-                               .strings\n-                               .find_equiv(&(\"setab\"))\n-                               .unwrap()\n-                               .as_slice(),\n-                           [Number(color as int)], &mut Variables::new());\n-            if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n-                return Ok(true)\n-            }\n-        }\n-        Ok(false)\n-    }\n+    fn bg(&mut self, color: color::Color) -> IoResult<bool>;\n \n-    /// Sets the given terminal attribute, if supported.\n-    /// Returns `Ok(true)` if the attribute was supported, `Ok(false)` otherwise,\n-    /// and `Err(e)` if there was an I/O error.\n-    pub fn attr(&mut self, attr: attr::Attr) -> io::IoResult<bool> {\n-        match attr {\n-            attr::ForegroundColor(c) => self.fg(c),\n-            attr::BackgroundColor(c) => self.bg(c),\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                let parm = self.ti.strings.find_equiv(&cap);\n-                if parm.is_some() {\n-                    let s = expand(parm.unwrap().as_slice(),\n-                                   [],\n-                                   &mut Variables::new());\n-                    if s.is_ok() {\n-                        try!(self.out.write(s.unwrap().as_slice()));\n-                        return Ok(true)\n-                    }\n-                }\n-                Ok(false)\n-            }\n-        }\n-    }\n+    /// Sets the given terminal attribute, if supported.  Returns `Ok(true)`\n+    /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n+    /// there was an I/O error.\n+    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool>;\n \n     /// Returns whether the given terminal attribute is supported.\n-    pub fn supports_attr(&self, attr: attr::Attr) -> bool {\n-        match attr {\n-            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n-                self.num_colors > 0\n-            }\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                self.ti.strings.find_equiv(&cap).is_some()\n-            }\n-        }\n-    }\n+    fn supports_attr(&self, attr: attr::Attr) -> bool;\n \n     /// Resets all terminal attributes and color to the default.\n     /// Returns `Ok()`.\n-    pub fn reset(&mut self) -> io::IoResult<()> {\n-        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n-        if cap.is_none() {\n-            // are there any terminals that have color/attrs and not sgr0?\n-            // Try falling back to sgr, then op\n-            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n-            if cap.is_none() {\n-                cap = self.ti.strings.find_equiv(&(\"op\"));\n-            }\n-        }\n-        let s = cap.map_or(Err(\"can't find terminfo capability \\\n-                                `sgr0`\".to_strbuf()), |op| {\n-            expand(op.as_slice(), [], &mut Variables::new())\n-        });\n-        if s.is_ok() {\n-            return self.out.write(s.unwrap().as_slice())\n-        }\n-        Ok(())\n-    }\n-\n-    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n-        if color >= self.num_colors && color >= 8 && color < 16 {\n-            color-8\n-        } else { color }\n-    }\n+    fn reset(&mut self) -> IoResult<()>;\n \n-    /// Returns the contained stream\n-    pub fn unwrap(self) -> T { self.out }\n+    /// Returns the contained stream, destroying the `Terminal`\n+    fn unwrap(self) -> T;\n \n     /// Gets an immutable reference to the stream inside\n-    pub fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n+    fn get_ref<'a>(&'a self) -> &'a T;\n \n     /// Gets a mutable reference to the stream inside\n-    pub fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n-}\n-\n-impl<T: Writer> Writer for Terminal<T> {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.out.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::IoResult<()> {\n-        self.out.flush()\n-    }\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T;\n }"}, {"sha": "93a7657fae9e454fe5726b0965ba32664bbe56b9", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f923b93694706730dd8395dec63e949ba441e0d9/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f923b93694706730dd8395dec63e949ba441e0d9/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=f923b93694706730dd8395dec63e949ba441e0d9", "patch": "@@ -11,6 +11,16 @@\n //! Terminfo database interface.\n \n use collections::HashMap;\n+use std::io::IoResult;\n+use std::os;\n+\n+use attr;\n+use color;\n+use Terminal;\n+use self::searcher::open;\n+use self::parser::compiled::{parse, msys_terminfo};\n+use self::parm::{expand, Number, Variables};\n+\n \n /// A parsed terminfo database entry.\n pub struct TermInfo {\n@@ -32,3 +42,179 @@ pub mod parser {\n     pub mod compiled;\n }\n pub mod parm;\n+\n+\n+fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+    match attr {\n+        attr::Bold               => \"bold\",\n+        attr::Dim                => \"dim\",\n+        attr::Italic(true)       => \"sitm\",\n+        attr::Italic(false)      => \"ritm\",\n+        attr::Underline(true)    => \"smul\",\n+        attr::Underline(false)   => \"rmul\",\n+        attr::Blink              => \"blink\",\n+        attr::Standout(true)     => \"smso\",\n+        attr::Standout(false)    => \"rmso\",\n+        attr::Reverse            => \"rev\",\n+        attr::Secure             => \"invis\",\n+        attr::ForegroundColor(_) => \"setaf\",\n+        attr::BackgroundColor(_) => \"setab\"\n+    }\n+}\n+\n+/// A Terminal that knows how many colors it supports, with a reference to its\n+/// parsed Terminfo database record.\n+pub struct TerminfoTerminal<T> {\n+    num_colors: u16,\n+    out: T,\n+    ti: ~TermInfo\n+}\n+\n+impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n+    fn new(out: T) -> Option<TerminfoTerminal<T>> {\n+        let term = match os::getenv(\"TERM\") {\n+            Some(t) => t,\n+            None => {\n+                debug!(\"TERM environment variable not defined\");\n+                return None;\n+            }\n+        };\n+\n+        let entry = open(term);\n+        if entry.is_err() {\n+            if os::getenv(\"MSYSCON\").map_or(false, |s| \"mintty.exe\" == s) {\n+                // msys terminal\n+                return Some(TerminfoTerminal {out: out, ti: msys_terminfo(), num_colors: 8});\n+            }\n+            debug!(\"error finding terminfo entry: {}\", entry.unwrap_err());\n+            return None;\n+        }\n+\n+        let mut file = entry.unwrap();\n+        let ti = parse(&mut file, false);\n+        if ti.is_err() {\n+            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n+            return None;\n+        }\n+\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n+                 } else { 0 };\n+\n+        return Some(TerminfoTerminal {out: out, ti: inf, num_colors: nc});\n+    }\n+\n+    fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n+            let s = expand(self.ti\n+                               .strings\n+                               .find_equiv(&(\"setaf\"))\n+                               .unwrap()\n+                               .as_slice(),\n+                           [Number(color as int)], &mut Variables::new());\n+            if s.is_ok() {\n+                try!(self.out.write(s.unwrap().as_slice()));\n+                return Ok(true)\n+            }\n+        }\n+        Ok(false)\n+    }\n+\n+    fn bg(&mut self, color: color::Color) -> IoResult<bool> {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n+            let s = expand(self.ti\n+                               .strings\n+                               .find_equiv(&(\"setab\"))\n+                               .unwrap()\n+                               .as_slice(),\n+                           [Number(color as int)], &mut Variables::new());\n+            if s.is_ok() {\n+                try!(self.out.write(s.unwrap().as_slice()));\n+                return Ok(true)\n+            }\n+        }\n+        Ok(false)\n+    }\n+\n+    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> {\n+        match attr {\n+            attr::ForegroundColor(c) => self.fg(c),\n+            attr::BackgroundColor(c) => self.bg(c),\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                let parm = self.ti.strings.find_equiv(&cap);\n+                if parm.is_some() {\n+                    let s = expand(parm.unwrap().as_slice(),\n+                                   [],\n+                                   &mut Variables::new());\n+                    if s.is_ok() {\n+                        try!(self.out.write(s.unwrap().as_slice()));\n+                        return Ok(true)\n+                    }\n+                }\n+                Ok(false)\n+            }\n+        }\n+    }\n+\n+    fn supports_attr(&self, attr: attr::Attr) -> bool {\n+        match attr {\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n+                self.num_colors > 0\n+            }\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                self.ti.strings.find_equiv(&cap).is_some()\n+            }\n+        }\n+    }\n+\n+    fn reset(&mut self) -> IoResult<()> {\n+        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n+        if cap.is_none() {\n+            // are there any terminals that have color/attrs and not sgr0?\n+            // Try falling back to sgr, then op\n+            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n+            if cap.is_none() {\n+                cap = self.ti.strings.find_equiv(&(\"op\"));\n+            }\n+        }\n+        let s = cap.map_or(Err(~\"can't find terminfo capability `sgr0`\"), |op| {\n+            expand(op.as_slice(), [], &mut Variables::new())\n+        });\n+        if s.is_ok() {\n+            return self.out.write(s.unwrap().as_slice())\n+        }\n+        Ok(())\n+    }\n+\n+    fn unwrap(self) -> T { self.out }\n+\n+    fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n+\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n+}\n+\n+impl<T: Writer> TerminfoTerminal<T> {\n+    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+        if color >= self.num_colors && color >= 8 && color < 16 {\n+            color-8\n+        } else { color }\n+    }\n+}\n+\n+\n+impl<T: Writer> Writer for TerminfoTerminal<T> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.out.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.out.flush()\n+    }\n+}\n+"}, {"sha": "063f93cebac464f2196b6eb432d86cb5bfb1e3a1", "filename": "src/libterm/win.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f923b93694706730dd8395dec63e949ba441e0d9/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f923b93694706730dd8395dec63e949ba441e0d9/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=f923b93694706730dd8395dec63e949ba441e0d9", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows console handling\n+\n+// FIXME (#13400): this is only a tiny fraction of the win32 console api\n+\n+extern crate libc;\n+\n+use std::io::IoResult;\n+\n+use attr;\n+use color;\n+use Terminal;\n+\n+pub struct WinConsole<T> {\n+    buf: T,\n+    foreground: color::Color,\n+    background: color::Color,\n+}\n+\n+#[link(name = \"kernel32\")]\n+extern \"system\" {\n+    fn SetConsoleTextAttribute(handle: libc::HANDLE, attr: libc::WORD) -> libc::BOOL;\n+    fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+}\n+\n+fn color_to_bits(color: color::Color) -> u16 {\n+    // magic numbers from mingw-w64's wincon.h\n+\n+    let bits = match color % 8 {\n+        color::BLACK   => 0,\n+        color::BLUE    => 0x1,\n+        color::GREEN   => 0x2,\n+        color::RED     => 0x4,\n+        color::YELLOW  => 0x2 | 0x4,\n+        color::MAGENTA => 0x1 | 0x4,\n+        color::CYAN    => 0x1 | 0x2,\n+        color::WHITE   => 0x1 | 0x2 | 0x4,\n+        _ => unreachable!()\n+    };\n+\n+    if color >= 8 {\n+        bits | 0x8\n+    } else {\n+        bits\n+    }\n+}\n+\n+impl<T: Writer> WinConsole<T> {\n+    fn apply(&mut self) {\n+        let mut accum: libc::WORD = 0;\n+        accum |= color_to_bits(self.foreground);\n+        accum |= color_to_bits(self.background) << 4;\n+\n+        unsafe {\n+            // Magic -11 means stdout, from\n+            // http://msdn.microsoft.com/en-us/library/windows/desktop/ms683231%28v=vs.85%29.aspx\n+            //\n+            // You may be wondering, \"but what about stderr?\", and the answer\n+            // to that is that setting terminal attributes on the stdout\n+            // handle also sets them for stderr, since they go to the same\n+            // terminal! Admittedly, this is fragile, since stderr could be\n+            // redirected to a different console. This is good enough for\n+            // rustc though. See #13400.\n+            let out = GetStdHandle(-11);\n+            SetConsoleTextAttribute(out, accum);\n+        }\n+    }\n+}\n+\n+impl<T: Writer> Writer for WinConsole<T> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.buf.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.buf.flush()\n+    }\n+}\n+\n+impl<T: Writer> Terminal<T> for WinConsole<T> {\n+    fn new(out: T) -> Option<WinConsole<T>> {\n+        Some(WinConsole { buf: out, foreground: color::WHITE, background: color::BLACK })\n+    }\n+\n+    fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n+        self.foreground = color;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn bg(&mut self, color: color::Color) -> IoResult<bool> {\n+        self.background = color;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> {\n+        match attr {\n+            attr::ForegroundColor(f) => {\n+                self.foreground = f;\n+                self.apply();\n+                Ok(true)\n+            },\n+            attr::BackgroundColor(b) => {\n+                self.background = b;\n+                self.apply();\n+                Ok(true)\n+            },\n+            _ => Ok(false)\n+        }\n+    }\n+\n+    fn supports_attr(&self, attr: attr::Attr) -> bool {\n+        // it claims support for underscore and reverse video, but I can't get\n+        // it to do anything -cmr\n+        match attr {\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn reset(&mut self) -> IoResult<()> {\n+        self.foreground = color::WHITE;\n+        self.background = color::BLACK;\n+        self.apply();\n+\n+        Ok(())\n+    }\n+\n+    fn unwrap(self) -> T { self.buf }\n+\n+    fn get_ref<'a>(&'a self) -> &'a T { &self.buf }\n+\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }\n+}"}]}