{"sha": "9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NTJiY2RkOTJkZmQwOTA0OWNlOWRkMjk5YjRiZmM1MTNhYzA3NWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-03T11:09:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-03T11:09:31Z"}, "message": "Auto merge of #33861 - Amanieu:lock_elision_fix, r=alexcrichton\n\nMake sure Mutex and RwLock can't be re-locked on the same thread\n\nFixes #33770\n\nr? @alexcrichton", "tree": {"sha": "30e4ca00974aaf0c10b6a8ac546cd5e63026fda0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30e4ca00974aaf0c10b6a8ac546cd5e63026fda0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "html_url": "https://github.com/rust-lang/rust/commit/9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95206f438f1573e95601f06b315a151de010e92f", "url": "https://api.github.com/repos/rust-lang/rust/commits/95206f438f1573e95601f06b315a151de010e92f", "html_url": "https://github.com/rust-lang/rust/commit/95206f438f1573e95601f06b315a151de010e92f"}, {"sha": "fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "html_url": "https://github.com/rust-lang/rust/commit/fc4b35612550d833cefcd586cb13ebc0dc5a51e1"}], "stats": {"total": 225, "additions": 214, "deletions": 11}, "files": [{"sha": "45d85899e99d33e291b2bf3259881b46cc5365d7", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -1 +1 @@\n-Subproject commit b19b5465a1235be3323363cdc11838739b593029\n+Subproject commit 45d85899e99d33e291b2bf3259881b46cc5365d7"}, {"sha": "c75a5c09146a495abe9e626efea78e605f9d8b12", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -204,10 +204,14 @@ impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n-        Mutex {\n+        let mut m = Mutex {\n             inner: box StaticMutex::new(),\n             data: UnsafeCell::new(t),\n+        };\n+        unsafe {\n+            m.inner.lock.init();\n         }\n+        m\n     }\n }\n "}, {"sha": "7a2183c522f5b92154b198e55aea3cdc4455a5f4", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -27,6 +27,12 @@ impl Mutex {\n     /// first used with any of the functions below.\n     pub const fn new() -> Mutex { Mutex(imp::Mutex::new()) }\n \n+    /// Prepare the mutex for use.\n+    ///\n+    /// This should be called once the mutex is at a stable memory address.\n+    #[inline]\n+    pub unsafe fn init(&mut self) { self.0.init() }\n+\n     /// Locks the mutex blocking the current thread until it is available.\n     ///\n     /// Behavior is undefined if the mutex has been moved between this and any"}, {"sha": "52cf3f97c5c83ba49e12fb37a746710d87840160", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -30,6 +30,39 @@ impl Mutex {\n         Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n     }\n     #[inline]\n+    pub unsafe fn init(&mut self) {\n+        // Issue #33770\n+        //\n+        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n+        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n+        // try to re-lock it from the same thread when you already hold a lock.\n+        //\n+        // In practice, glibc takes advantage of this undefined behavior to\n+        // implement hardware lock elision, which uses hardware transactional\n+        // memory to avoid acquiring the lock. While a transaction is in\n+        // progress, the lock appears to be unlocked. This isn't a problem for\n+        // other threads since the transactional memory will abort if a conflict\n+        // is detected, however no abort is generated if re-locking from the\n+        // same thread.\n+        //\n+        // Since locking the same mutex twice will result in two aliasing &mut\n+        // references, we instead create the mutex with type\n+        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n+        // re-lock it from the same thread, thus avoiding undefined behavior.\n+        //\n+        // We can't do anything for StaticMutex, but that type is deprecated\n+        // anyways.\n+        let mut attr: libc::pthread_mutexattr_t = mem::uninitialized();\n+        let r = libc::pthread_mutexattr_init(&mut attr);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutexattr_settype(&mut attr, libc::PTHREAD_MUTEX_NORMAL);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutex_init(self.inner.get(), &attr);\n+        debug_assert_eq!(r, 0);\n+        let r = libc::pthread_mutexattr_destroy(&mut attr);\n+        debug_assert_eq!(r, 0);\n+    }\n+    #[inline]\n     pub unsafe fn lock(&self) {\n         let r = libc::pthread_mutex_lock(self.inner.get());\n         debug_assert_eq!(r, 0);"}, {"sha": "fbd4e1d120817ebc21a0b5e4e08d2f8593ff02d2", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -10,15 +10,24 @@\n \n use libc;\n use cell::UnsafeCell;\n+use sync::atomic::{AtomicUsize, Ordering};\n \n-pub struct RWLock { inner: UnsafeCell<libc::pthread_rwlock_t> }\n+pub struct RWLock {\n+    inner: UnsafeCell<libc::pthread_rwlock_t>,\n+    write_locked: UnsafeCell<bool>,\n+    num_readers: AtomicUsize,\n+}\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER) }\n+        RWLock {\n+            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n+            write_locked: UnsafeCell::new(false),\n+            num_readers: AtomicUsize::new(0),\n+        }\n     }\n     #[inline]\n     pub unsafe fn read(&self) {\n@@ -35,37 +44,86 @@ impl RWLock {\n         //\n         // We roughly maintain the deadlocking behavior by panicking to ensure\n         // that this lock acquisition does not succeed.\n-        if r == libc::EDEADLK {\n+        //\n+        // We also check whether there this lock is already write locked. This\n+        // is only possible if it was write locked by the current thread and\n+        // the implementation allows recursive locking. The POSIX standard\n+        // doesn't require recursivly locking a rwlock to deadlock, but we can't\n+        // allow that because it could lead to aliasing issues.\n+        if r == libc::EDEADLK || *self.write_locked.get() {\n+            if r == 0 {\n+                self.raw_unlock();\n+            }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n+            self.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        libc::pthread_rwlock_tryrdlock(self.inner.get()) == 0\n+        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n+        if r == 0 {\n+            if *self.write_locked.get() {\n+                self.raw_unlock();\n+                false\n+            } else {\n+                self.num_readers.fetch_add(1, Ordering::Relaxed);\n+                true\n+            }\n+        } else {\n+            false\n+        }\n     }\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // see comments above for why we check for EDEADLK\n-        if r == libc::EDEADLK {\n+        // See comments above for why we check for EDEADLK and write_locked. We\n+        // also need to check that num_readers is 0.\n+        if r == libc::EDEADLK || *self.write_locked.get() ||\n+           self.num_readers.load(Ordering::Relaxed) != 0 {\n+            if r == 0 {\n+                self.raw_unlock();\n+            }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n         }\n+        *self.write_locked.get() = true;\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        libc::pthread_rwlock_trywrlock(self.inner.get()) == 0\n+        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n+        if r == 0 {\n+            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+                self.raw_unlock();\n+                false\n+            } else {\n+                *self.write_locked.get() = true;\n+                true\n+            }\n+        } else {\n+            false\n+        }\n     }\n     #[inline]\n-    pub unsafe fn read_unlock(&self) {\n+    unsafe fn raw_unlock(&self) {\n         let r = libc::pthread_rwlock_unlock(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n-    pub unsafe fn write_unlock(&self) { self.read_unlock() }\n+    pub unsafe fn read_unlock(&self) {\n+        debug_assert!(!*self.write_locked.get());\n+        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n+        self.raw_unlock();\n+    }\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n+        debug_assert!(*self.write_locked.get());\n+        *self.write_locked.get() = false;\n+        self.raw_unlock();\n+    }\n     #[inline]\n     pub unsafe fn destroy(&self) {\n         let r = libc::pthread_rwlock_destroy(self.inner.get());"}, {"sha": "8762b34e3da484df7fbf49854f4ac57f754a8a1d", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -64,6 +64,8 @@ impl Mutex {\n             held: UnsafeCell::new(false),\n         }\n     }\n+    #[inline]\n+    pub unsafe fn init(&mut self) {}\n     pub unsafe fn lock(&self) {\n         match kind() {\n             Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),"}, {"sha": "f5635fddaf951c9514fd1b0b8c08529cfbc7eb46", "filename": "src/test/run-pass/issue-33770.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Ftest%2Frun-pass%2Fissue-33770.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9552bcdd92dfd09049ce9dd299b4bfc513ac075d/src%2Ftest%2Frun-pass%2Fissue-33770.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-33770.rs?ref=9552bcdd92dfd09049ce9dd299b4bfc513ac075d", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::process::{Command, Stdio};\n+use std::env;\n+use std::sync::{Mutex, RwLock};\n+use std::time::Duration;\n+use std::thread;\n+\n+fn test_mutex() {\n+    let m = Mutex::new(0);\n+    let _g = m.lock().unwrap();\n+    let _g2 = m.lock().unwrap();\n+}\n+\n+fn test_try_mutex() {\n+    let m = Mutex::new(0);\n+    let _g = m.lock().unwrap();\n+    let _g2 = m.try_lock().unwrap();\n+}\n+\n+fn test_rwlock_ww() {\n+    let m = RwLock::new(0);\n+    let _g = m.write().unwrap();\n+    let _g2 = m.write().unwrap();\n+}\n+\n+fn test_try_rwlock_ww() {\n+    let m = RwLock::new(0);\n+    let _g = m.write().unwrap();\n+    let _g2 = m.try_write().unwrap();\n+}\n+\n+fn test_rwlock_rw() {\n+    let m = RwLock::new(0);\n+    let _g = m.read().unwrap();\n+    let _g2 = m.write().unwrap();\n+}\n+\n+fn test_try_rwlock_rw() {\n+    let m = RwLock::new(0);\n+    let _g = m.read().unwrap();\n+    let _g2 = m.try_write().unwrap();\n+}\n+\n+fn test_rwlock_wr() {\n+    let m = RwLock::new(0);\n+    let _g = m.write().unwrap();\n+    let _g2 = m.read().unwrap();\n+}\n+\n+fn test_try_rwlock_wr() {\n+    let m = RwLock::new(0);\n+    let _g = m.write().unwrap();\n+    let _g2 = m.try_read().unwrap();\n+}\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() > 1 {\n+        match &*args[1] {\n+            \"mutex\" => test_mutex(),\n+            \"try_mutex\" => test_try_mutex(),\n+            \"rwlock_ww\" => test_rwlock_ww(),\n+            \"try_rwlock_ww\" => test_try_rwlock_ww(),\n+            \"rwlock_rw\" => test_rwlock_rw(),\n+            \"try_rwlock_rw\" => test_try_rwlock_rw(),\n+            \"rwlock_wr\" => test_rwlock_wr(),\n+            \"try_rwlock_wr\" => test_try_rwlock_wr(),\n+            _ => unreachable!(),\n+        }\n+        // If we reach this point then the test failed\n+        println!(\"TEST FAILED: {}\", args[1]);\n+    } else {\n+        let mut v = vec![];\n+        v.push(Command::new(&args[0]).arg(\"mutex\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"try_mutex\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"rwlock_ww\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"try_rwlock_ww\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"rwlock_rw\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"try_rwlock_rw\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"rwlock_wr\").stderr(Stdio::null()).spawn().unwrap());\n+        v.push(Command::new(&args[0]).arg(\"try_rwlock_wr\").stderr(Stdio::null()).spawn().unwrap());\n+\n+        thread::sleep(Duration::new(1, 0));\n+\n+        // Make sure all subprocesses either panicked or were killed because they deadlocked\n+        for mut c in v {\n+            c.kill().ok();\n+            assert!(!c.wait().unwrap().success());\n+        }\n+    }\n+}"}]}