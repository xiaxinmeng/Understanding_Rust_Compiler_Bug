{"sha": "7e38a89a7b970181be083691504825a23e6b0a0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMzhhODlhN2I5NzAxODFiZTA4MzY5MTUwNDgyNWEyM2U2YjBhMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-06T23:49:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-06T23:49:57Z"}, "message": "Auto merge of #38835 - alexcrichton:less-overlapped, r=brson\n\nstd: Don't pass overlapped handles to processes\n\nThis commit fixes a mistake introduced in #31618 where overlapped handles were\nleaked to child processes on Windows. On Windows once a handle is in overlapped\nmode it should always have I/O executed with an instance of `OVERLAPPED`. Most\nchild processes, however, are not prepared to have their stdio handles in\noverlapped mode as they don't use `OVERLAPPED` on reads/writes to the handle.\n\nNow we haven't had any odd behavior in Rust up to this point, and the original\nbug was introduced almost a year ago. I believe this is because it turns out\nthat if you *don't* pass an `OVERLAPPED` then the system will [supply one for\nyou][link]. In this case everything will go awry if you concurrently operate on\nthe handle. In Rust, however, the stdio handles are always locked, and there's\nno way to not use them unlocked in libstd. Due to that change we've always had\nsynchronized access to these handles, which means that Rust programs typically\n\"just work\".\n\nConversely, though, this commit fixes the test case included, which exhibits\nbehavior that other programs Rust spawns may attempt to execute. Namely, the\nstdio handles may be concurrently used and having them in overlapped mode wreaks\nhavoc.\n\n[link]: https://blogs.msdn.microsoft.com/oldnewthing/20121012-00/?p=6343\n\nCloses #38811", "tree": {"sha": "68cbc73d98cba21932fd3ed19d73205811f7d6ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68cbc73d98cba21932fd3ed19d73205811f7d6ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e38a89a7b970181be083691504825a23e6b0a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e38a89a7b970181be083691504825a23e6b0a0f", "html_url": "https://github.com/rust-lang/rust/commit/7e38a89a7b970181be083691504825a23e6b0a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e38a89a7b970181be083691504825a23e6b0a0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "373efe8794defedc8ce41e258910560423d0c0b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/373efe8794defedc8ce41e258910560423d0c0b7", "html_url": "https://github.com/rust-lang/rust/commit/373efe8794defedc8ce41e258910560423d0c0b7"}, {"sha": "5148918db606689abea8f971ceb6c5bec4c0ba52", "url": "https://api.github.com/repos/rust-lang/rust/commits/5148918db606689abea8f971ceb6c5bec4c0ba52", "html_url": "https://github.com/rust-lang/rust/commit/5148918db606689abea8f971ceb6c5bec4c0ba52"}], "stats": {"total": 182, "additions": 153, "deletions": 29}, "files": [{"sha": "910d802f05902a10b81d028aac8c1b994b06d1f6", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=7e38a89a7b970181be083691504825a23e6b0a0f", "patch": "@@ -282,6 +282,7 @@ pub const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n \n pub const PIPE_ACCESS_INBOUND: DWORD = 0x00000001;\n+pub const PIPE_ACCESS_OUTBOUND: DWORD = 0x00000002;\n pub const FILE_FLAG_FIRST_PIPE_INSTANCE: DWORD = 0x00080000;\n pub const FILE_FLAG_OVERLAPPED: DWORD = 0x40000000;\n pub const PIPE_WAIT: DWORD = 0x00000000;"}, {"sha": "8073473f7ff5b8c6144d938adae1ae887a37d35a", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=7e38a89a7b970181be083691504825a23e6b0a0f", "patch": "@@ -29,18 +29,43 @@ pub struct AnonPipe {\n     inner: Handle,\n }\n \n-pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+pub struct Pipes {\n+    pub ours: AnonPipe,\n+    pub theirs: AnonPipe,\n+}\n+\n+/// Although this looks similar to `anon_pipe` in the Unix module it's actually\n+/// subtly different. Here we'll return two pipes in the `Pipes` return value,\n+/// but one is intended for \"us\" where as the other is intended for \"someone\n+/// else\".\n+///\n+/// Currently the only use case for this function is pipes for stdio on\n+/// processes in the standard library, so \"ours\" is the one that'll stay in our\n+/// process whereas \"theirs\" will be inherited to a child.\n+///\n+/// The ours/theirs pipes are *not* specifically readable or writable. Each\n+/// one only supports a read or a write, but which is which depends on the\n+/// boolean flag given. If `ours_readable` is true then `ours` is readable where\n+/// `theirs` is writable. Conversely if `ours_readable` is false then `ours` is\n+/// writable where `theirs` is readable.\n+///\n+/// Also note that the `ours` pipe is always a handle opened up in overlapped\n+/// mode. This means that technically speaking it should only ever be used\n+/// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n+/// once at a time (which we do indeed guarantee).\n+pub fn anon_pipe(ours_readable: bool) -> io::Result<Pipes> {\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n-    // operations.\n-    //\n-    // Instead, we create a \"hopefully unique\" name and create a named pipe\n-    // which has overlapped operations enabled.\n+    // operations. Instead, we create a \"hopefully unique\" name and create a\n+    // named pipe which has overlapped operations enabled.\n     //\n-    // Once we do this, we connect do it as usual via `CreateFileW`, and then we\n-    // return those reader/writer halves.\n+    // Once we do this, we connect do it as usual via `CreateFileW`, and then\n+    // we return those reader/writer halves. Note that the `ours` pipe return\n+    // value is always the named pipe, whereas `theirs` is just the normal file.\n+    // This should hopefully shield us from child processes which assume their\n+    // stdout is a named pipe, which would indeed be odd!\n     unsafe {\n-        let reader;\n+        let ours;\n         let mut name;\n         let mut tries = 0;\n         let mut reject_remote_clients_flag = c::PIPE_REJECT_REMOTE_CLIENTS;\n@@ -54,11 +79,16 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                                   .encode_wide()\n                                   .chain(Some(0))\n                                   .collect::<Vec<_>>();\n+            let mut flags = c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n+                c::FILE_FLAG_OVERLAPPED;\n+            if ours_readable {\n+                flags |= c::PIPE_ACCESS_INBOUND;\n+            } else {\n+                flags |= c::PIPE_ACCESS_OUTBOUND;\n+            }\n \n             let handle = c::CreateNamedPipeW(wide_name.as_ptr(),\n-                                             c::PIPE_ACCESS_INBOUND |\n-                                             c::FILE_FLAG_FIRST_PIPE_INSTANCE |\n-                                             c::FILE_FLAG_OVERLAPPED,\n+                                             flags,\n                                              c::PIPE_TYPE_BYTE |\n                                              c::PIPE_READMODE_BYTE |\n                                              c::PIPE_WAIT |\n@@ -101,21 +131,28 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                 }\n                 return Err(err)\n             }\n-            reader = Handle::new(handle);\n+            ours = Handle::new(handle);\n             break\n         }\n \n-        // Connect to the named pipe we just created in write-only mode (also\n-        // overlapped for async I/O below).\n+        // Connect to the named pipe we just created. This handle is going to be\n+        // returned in `theirs`, so if `ours` is readable we want this to be\n+        // writable, otherwise if `ours` is writable we want this to be\n+        // readable.\n+        //\n+        // Additionally we don't enable overlapped mode on this because most\n+        // client processes aren't enabled to work with that.\n         let mut opts = OpenOptions::new();\n-        opts.write(true);\n-        opts.read(false);\n+        opts.write(ours_readable);\n+        opts.read(!ours_readable);\n         opts.share_mode(0);\n-        opts.attributes(c::FILE_FLAG_OVERLAPPED);\n-        let writer = File::open(Path::new(&name), &opts)?;\n-        let writer = AnonPipe { inner: writer.into_handle() };\n+        let theirs = File::open(Path::new(&name), &opts)?;\n+        let theirs = AnonPipe { inner: theirs.into_handle() };\n \n-        Ok((AnonPipe { inner: reader }, AnonPipe { inner: writer.into_handle() }))\n+        Ok(Pipes {\n+            ours: AnonPipe { inner: ours },\n+            theirs: AnonPipe { inner: theirs.into_handle() },\n+        })\n     }\n }\n "}, {"sha": "7dc8959e1b6830f206d791b5aeabe224b29a8fce", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=7e38a89a7b970181be083691504825a23e6b0a0f", "patch": "@@ -264,19 +264,15 @@ impl Stdio {\n             }\n \n             Stdio::MakePipe => {\n-                let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if stdio_id == c::STD_INPUT_HANDLE {\n-                    (writer, reader)\n-                } else {\n-                    (reader, writer)\n-                };\n-                *pipe = Some(ours);\n+                let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n+                let pipes = pipe::anon_pipe(ours_readable)?;\n+                *pipe = Some(pipes.ours);\n                 cvt(unsafe {\n-                    c::SetHandleInformation(theirs.handle().raw(),\n+                    c::SetHandleInformation(pipes.theirs.handle().raw(),\n                                             c::HANDLE_FLAG_INHERIT,\n                                             c::HANDLE_FLAG_INHERIT)\n                 })?;\n-                Ok(theirs.into_handle())\n+                Ok(pipes.theirs.into_handle())\n             }\n \n             Stdio::Handle(ref handle) => {"}, {"sha": "74170ca6506ec8bef6787cd127913bc142f99a18", "filename": "src/test/run-pass/stdio-is-blocking.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Ftest%2Frun-pass%2Fstdio-is-blocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e38a89a7b970181be083691504825a23e6b0a0f/src%2Ftest%2Frun-pass%2Fstdio-is-blocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstdio-is-blocking.rs?ref=7e38a89a7b970181be083691504825a23e6b0a0f", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::io::prelude::*;\n+use std::process::Command;\n+use std::thread;\n+\n+const THREADS: usize = 20;\n+const WRITES: usize = 100;\n+const WRITE_SIZE: usize = 1024 * 32;\n+\n+fn main() {\n+    let args = env::args().collect::<Vec<_>>();\n+    if args.len() == 1 {\n+        parent();\n+    } else {\n+        child();\n+    }\n+}\n+\n+fn parent() {\n+    let me = env::current_exe().unwrap();\n+    let mut cmd = Command::new(me);\n+    cmd.arg(\"run-the-test\");\n+    let output = cmd.output().unwrap();\n+    assert!(output.status.success());\n+    assert_eq!(output.stderr.len(), 0);\n+    assert_eq!(output.stdout.len(), WRITES * THREADS * WRITE_SIZE);\n+    for byte in output.stdout.iter() {\n+        assert_eq!(*byte, b'a');\n+    }\n+}\n+\n+fn child() {\n+    let threads = (0..THREADS).map(|_| {\n+        thread::spawn(|| {\n+            let buf = [b'a'; WRITE_SIZE];\n+            for _ in 0..WRITES {\n+                write_all(&buf);\n+            }\n+        })\n+    }).collect::<Vec<_>>();\n+\n+    for thread in threads {\n+        thread.join().unwrap();\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn write_all(buf: &[u8]) {\n+    use std::fs::File;\n+    use std::mem;\n+    use std::os::unix::prelude::*;\n+\n+    let mut file = unsafe { File::from_raw_fd(1) };\n+    let res = file.write_all(buf);\n+    mem::forget(file);\n+    res.unwrap();\n+}\n+\n+#[cfg(windows)]\n+fn write_all(buf: &[u8]) {\n+    use std::fs::File;\n+    use std::mem;\n+    use std::os::windows::raw::*;\n+    use std::os::windows::prelude::*;\n+\n+    const STD_OUTPUT_HANDLE: u32 = (-11i32) as u32;\n+\n+    extern \"system\" {\n+        fn GetStdHandle(handle: u32) -> HANDLE;\n+    }\n+\n+    let mut file = unsafe {\n+        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n+        assert!(!handle.is_null());\n+        File::from_raw_handle(handle)\n+    };\n+    let res = file.write_all(buf);\n+    mem::forget(file);\n+    res.unwrap();\n+}"}]}