{"sha": "e78fac56015ca2d926237704b02e555604a99e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OGZhYzU2MDE1Y2EyZDkyNjIzNzcwNGIwMmU1NTU2MDRhOTllOWQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-03-31T08:40:31Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-03-31T08:40:31Z"}, "message": "Handle the case of partially captured drop type", "tree": {"sha": "cdc515f3fd044d0f927b12a0f01688e9f705ff8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdc515f3fd044d0f927b12a0f01688e9f705ff8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e78fac56015ca2d926237704b02e555604a99e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e78fac56015ca2d926237704b02e555604a99e9d", "html_url": "https://github.com/rust-lang/rust/commit/e78fac56015ca2d926237704b02e555604a99e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e78fac56015ca2d926237704b02e555604a99e9d/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2e52fffc28e18c7896f05792843d1cdd18c7ecb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e52fffc28e18c7896f05792843d1cdd18c7ecb", "html_url": "https://github.com/rust-lang/rust/commit/f2e52fffc28e18c7896f05792843d1cdd18c7ecb"}], "stats": {"total": 42, "additions": 23, "deletions": 19}, "files": [{"sha": "124076a889b6fa14bf5b85540f127f43319d62c8", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e78fac56015ca2d926237704b02e555604a99e9d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78fac56015ca2d926237704b02e555604a99e9d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=e78fac56015ca2d926237704b02e555604a99e9d", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// `w[c]`.\n     /// Notation:\n     /// - Ty(place): Type of place\n-    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_projs`\n+    /// - `(a, b)`: Represents the function parameters `base_path_ty` and `captured_by_move_projs`\n     /// respectively.\n     /// ```\n     ///                  (Ty(w), [ &[p, x], &[c] ])\n@@ -700,7 +700,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         closure_def_id: DefId,\n         closure_span: Span,\n         base_path_ty: Ty<'tcx>,\n-        captured_projs: Vec<&[Projection<'tcx>]>,\n+        captured_by_move_projs: Vec<&[Projection<'tcx>]>,\n     ) -> bool {\n         let needs_drop = |ty: Ty<'tcx>| {\n             ty.needs_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local()))\n@@ -725,33 +725,37 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // eg. If `a.b` is captured and we are processing `a.b`, then we can't have the closure also\n         //     capture `a.b.c`, because that voilates min capture.\n-        let is_completely_captured = captured_projs.iter().any(|projs| projs.is_empty());\n+        let is_completely_captured = captured_by_move_projs.iter().any(|projs| projs.is_empty());\n \n-        assert!(!is_completely_captured || (captured_projs.len() == 1));\n+        assert!(!is_completely_captured || (captured_by_move_projs.len() == 1));\n \n         if is_completely_captured {\n             // The place is captured entirely, so doesn't matter if needs dtor, it will be drop\n             // when the closure is dropped.\n             return false;\n         }\n \n+        if captured_by_move_projs.is_empty() {\n+            return needs_drop(base_path_ty);\n+        }\n+\n         if is_drop_defined_for_ty {\n             // If drop is implemented for this type then we need it to be fully captured,\n-            // which we know it is not because of the previous check. Therefore we need to\n-            // do migrate.\n-            return true;\n-        }\n+            // and we know it is not completely captured because of the previous checks.\n \n-        if captured_projs.is_empty() {\n-            return needs_drop(base_path_ty);\n+            // Note that this is a bug in the user code that will be reported by the\n+            // borrow checker, since we can't move out of drop types.\n+\n+            // The bug exists in the user's code pre-migration, and we don't migrate here.\n+            return false;\n         }\n \n         match base_path_ty.kind() {\n             // Observations:\n-            // - `captured_projs` is not empty. Therefore we can call\n-            //   `captured_projs.first().unwrap()` safely.\n-            // - All entries in `captured_projs` have atleast one projection.\n-            //   Therefore we can call `captured_projs.first().unwrap().first().unwrap()` safely.\n+            // - `captured_by_move_projs` is not empty. Therefore we can call\n+            //   `captured_by_move_projs.first().unwrap()` safely.\n+            // - All entries in `captured_by_move_projs` have atleast one projection.\n+            //   Therefore we can call `captured_by_move_projs.first().unwrap().first().unwrap()` safely.\n \n             // We don't capture derefs in case of move captures, which would have be applied to\n             // access any further paths.\n@@ -761,19 +765,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             ty::Adt(def, substs) => {\n                 // Multi-varaint enums are captured in entirety,\n-                // which would've been handled in the case of single empty slice in `captured_projs`.\n+                // which would've been handled in the case of single empty slice in `captured_by_move_projs`.\n                 assert_eq!(def.variants.len(), 1);\n \n                 // Only Field projections can be applied to a non-box Adt.\n                 assert!(\n-                    captured_projs.iter().all(|projs| matches!(\n+                    captured_by_move_projs.iter().all(|projs| matches!(\n                         projs.first().unwrap().kind,\n                         ProjectionKind::Field(..)\n                     ))\n                 );\n                 def.variants.get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n                     |(i, field)| {\n-                        let paths_using_field = captured_projs\n+                        let paths_using_field = captured_by_move_projs\n                             .iter()\n                             .filter_map(|projs| {\n                                 if let ProjectionKind::Field(field_idx, _) =\n@@ -800,14 +804,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Tuple(..) => {\n                 // Only Field projections can be applied to a tuple.\n                 assert!(\n-                    captured_projs.iter().all(|projs| matches!(\n+                    captured_by_move_projs.iter().all(|projs| matches!(\n                         projs.first().unwrap().kind,\n                         ProjectionKind::Field(..)\n                     ))\n                 );\n \n                 base_path_ty.tuple_fields().enumerate().any(|(i, element_ty)| {\n-                    let paths_using_field = captured_projs\n+                    let paths_using_field = captured_by_move_projs\n                         .iter()\n                         .filter_map(|projs| {\n                             if let ProjectionKind::Field(field_idx, _) = projs.first().unwrap().kind"}]}