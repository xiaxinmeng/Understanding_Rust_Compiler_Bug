{"sha": "e69ff21207d83864e13f6c8631733f4f0c32ba0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2OWZmMjEyMDdkODM4NjRlMTNmNmM4NjMxNzMzZjRmMGMzMmJhMGQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T20:19:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "kill old module_map", "tree": {"sha": "4c8b33bd7e8c873ad8963eeab0185e8d62e74b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c8b33bd7e8c873ad8963eeab0185e8d62e74b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e69ff21207d83864e13f6c8631733f4f0c32ba0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e69ff21207d83864e13f6c8631733f4f0c32ba0d", "html_url": "https://github.com/rust-lang/rust/commit/e69ff21207d83864e13f6c8631733f4f0c32ba0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e69ff21207d83864e13f6c8631733f4f0c32ba0d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ebeb0db8de65434db79c86aeed5473bfb21334f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ebeb0db8de65434db79c86aeed5473bfb21334f", "html_url": "https://github.com/rust-lang/rust/commit/3ebeb0db8de65434db79c86aeed5473bfb21334f"}], "stats": {"total": 779, "additions": 239, "deletions": 540}, "files": [{"sha": "f26be104638a152ca18f204e2a5be6167199dfcb", "filename": "crates/libanalysis/src/db/imp.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fimp.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -122,9 +122,6 @@ impl QueryRegistry {\n         let config = config.with_query(id, q.f());\n         self.config= Some(config);\n     }\n-    pub(super) fn finish(mut self) -> salsa::QueryConfig<State, Data> {\n-        self.config.take().unwrap()\n-    }\n }\n \n fn hash<T: Hash>(x: &T) -> u64 {"}, {"sha": "22769d1120e504452e51de960f93aed61a80b258", "filename": "crates/libanalysis/src/db/mod.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb%2Fmod.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -29,6 +29,12 @@ pub(crate) struct QueryRegistry {\n     imp: imp::QueryRegistry,\n }\n \n+impl Default for Db {\n+    fn default() -> Db {\n+        Db::new()\n+    }\n+}\n+\n impl Db {\n     pub(crate) fn new() -> Db {\n         let reg = QueryRegistry::new();\n@@ -44,6 +50,7 @@ impl Db {\n         let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n         f(ctx)\n     }\n+    #[allow(unused)]\n     pub(crate) fn trace_query<F: FnOnce(QueryCtx) -> R, R>(&self, f: F) -> (R, Vec<&'static str>) {\n         let ctx = QueryCtx { imp: &self.imp.imp.query_ctx() };\n         let res = f(ctx);\n@@ -65,42 +72,11 @@ pub(crate) fn file_text(ctx: QueryCtx, file_id: FileId) -> Arc<String> {\n pub(crate) fn file_set(ctx: QueryCtx) -> Arc<(Vec<FileId>, FileResolverImp)> {\n     imp::file_set(ctx)\n }\n-pub(crate) use self::queries::file_syntax;\n-\n-mod queries {\n-    use std::sync::Arc;\n-    use libsyntax2::File;\n-    use libeditor::LineIndex;\n-    use {FileId};\n-    use super::{Query, QueryCtx, QueryRegistry, file_text};\n-\n-    pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n-        reg.add(FILE_SYNTAX, \"FILE_SYNTAX\");\n-        reg.add(FILE_LINES, \"FILE_LINES\");\n-    }\n-\n-    pub(crate) fn file_syntax(ctx: QueryCtx, file_id: FileId) -> File {\n-        (&*ctx.get(FILE_SYNTAX, file_id)).clone()\n-    }\n-    pub(crate) fn file_lines(ctx: QueryCtx, file_id: FileId) -> Arc<LineIndex> {\n-        ctx.get(FILE_LINES, file_id)\n-    }\n-\n-    pub(super) const FILE_SYNTAX: Query<FileId, File> = Query(16, |ctx, file_id: &FileId| {\n-        let text = file_text(ctx, *file_id);\n-        File::parse(&*text)\n-    });\n-    pub(super) const FILE_LINES: Query<FileId, LineIndex> = Query(17, |ctx, file_id: &FileId| {\n-        let text = file_text(ctx, *file_id);\n-        LineIndex::new(&*text)\n-    });\n-}\n-\n impl QueryRegistry {\n     fn new() -> QueryRegistry {\n         let mut reg = QueryRegistry { imp: imp::QueryRegistry::new() };\n-        queries::register_queries(&mut reg);\n-        ::module_map_db::register_queries(&mut reg);\n+        ::queries::register_queries(&mut reg);\n+        ::module_map::register_queries(&mut reg);\n         reg\n     }\n     pub(crate) fn add<Q: imp::EvalQuery>(&mut self, q: Q, name: &'static str) {"}, {"sha": "93a4158e4412bb287369c2155e8550d736d96f99", "filename": "crates/libanalysis/src/descriptors.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdescriptors.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -140,7 +140,7 @@ impl ModuleTreeDescriptor {\n             .links\n             .iter()\n             .filter(|it| it.name(self) == name)\n-            .map(|link| link.owner(self))\n+            .flat_map(|link| link.points_to(self).iter().map(|&node| self.node(node).file_id))\n             .collect()\n     }\n     pub(crate) fn problems<'a, 'b>(&'b self, file_id: FileId, root: ast::Root<'a>) -> Vec<(ast::Name<'a>, &'b Problem)> {\n@@ -172,6 +172,9 @@ impl Link {\n         let owner = tree.link(self).owner;\n         tree.node(owner).file_id\n     }\n+    fn points_to(self, tree: &ModuleTreeDescriptor) -> &[Node] {\n+        &tree.link(self).points_to\n+    }\n     pub(crate) fn bind_source<'a>(self, tree: &ModuleTreeDescriptor, root: ast::Root<'a>) -> ast::Module<'a> {\n         modules(root)\n             .filter(|(name, _)| name == &tree.link(self).name)"}, {"sha": "6f3191fe7311f8ef4a7f729767d6609ec151bc2b", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -5,6 +5,7 @@ use std::{\n     },\n     fmt,\n     collections::{HashSet, VecDeque},\n+    iter,\n };\n \n use relative_path::RelativePath;\n@@ -75,14 +76,12 @@ impl AnalysisHostImpl {\n     }\n     pub fn change_files(&mut self, changes: &mut dyn Iterator<Item=(FileId, Option<String>)>) {\n         let data = self.data_mut();\n-        for (file_id, text) in changes {\n-            data.root.update(file_id, text);\n-        }\n+        data.root = Arc::new(data.root.apply_changes(changes, None));\n     }\n     pub fn set_file_resolver(&mut self, resolver: FileResolverImp) {\n         let data = self.data_mut();\n         data.file_resolver = resolver.clone();\n-        data.root.set_file_resolver(resolver);\n+        data.root = Arc::new(data.root.apply_changes(&mut iter::empty(), Some(resolver)));\n     }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         let mut visited = HashSet::new();\n@@ -124,18 +123,17 @@ impl Clone for AnalysisImpl {\n impl AnalysisImpl {\n     fn root(&self, file_id: FileId) -> &SourceRoot {\n         if self.data.root.contains(file_id) {\n-            return &self.data.root;\n+            return &*self.data.root;\n         }\n         &**self.data.libs.iter().find(|it| it.contains(file_id)).unwrap()\n     }\n-    pub fn file_syntax(&self, file_id: FileId) -> &File {\n+    pub fn file_syntax(&self, file_id: FileId) -> File {\n         self.root(file_id).syntax(file_id)\n     }\n-    pub fn file_line_index(&self, file_id: FileId) -> &LineIndex {\n+    pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.root(file_id).lines(file_id)\n     }\n     pub fn world_symbols(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n-        self.reindex();\n         let mut buf = Vec::new();\n         if query.libs {\n             self.data.libs.iter()\n@@ -308,19 +306,13 @@ impl AnalysisImpl {\n         };\n         module_tree.child_module_by_name(file_id, name.as_str())\n     }\n-\n-    fn reindex(&self) {\n-        if self.needs_reindex.compare_and_swap(true, false, SeqCst) {\n-            self.data.root.reindex();\n-        }\n-    }\n }\n \n #[derive(Default, Clone, Debug)]\n struct WorldData {\n     file_resolver: FileResolverImp,\n     crate_graph: CrateGraph,\n-    root: WritableSourceRoot,\n+    root: Arc<WritableSourceRoot>,\n     libs: Vec<Arc<ReadonlySourceRoot>>,\n }\n "}, {"sha": "b4b7a6a304e0b4c9bd7583e4b4702c65d3781518", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -14,11 +14,11 @@ extern crate salsa;\n \n mod symbol_index;\n mod module_map;\n-pub(crate) mod module_map_db;\n mod imp;\n mod job;\n mod roots;\n mod db;\n+mod queries;\n mod descriptors;\n \n use std::{\n@@ -166,8 +166,8 @@ impl Analysis {\n     pub fn file_syntax(&self, file_id: FileId) -> File {\n         self.imp.file_syntax(file_id).clone()\n     }\n-    pub fn file_line_index(&self, file_id: FileId) -> LineIndex {\n-        self.imp.file_line_index(file_id).clone()\n+    pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n+        self.imp.file_line_index(file_id)\n     }\n     pub fn extend_selection(&self, file: &File, range: TextRange) -> TextRange {\n         libeditor::extend_selection(file, range).unwrap_or(range)\n@@ -177,19 +177,19 @@ impl Analysis {\n     }\n     pub fn syntax_tree(&self, file_id: FileId) -> String {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::syntax_tree(file)\n+        libeditor::syntax_tree(&file)\n     }\n     pub fn join_lines(&self, file_id: FileId, range: TextRange) -> SourceChange {\n         let file = self.imp.file_syntax(file_id);\n-        SourceChange::from_local_edit(file_id, \"join lines\", libeditor::join_lines(file, range))\n+        SourceChange::from_local_edit(file_id, \"join lines\", libeditor::join_lines(&file, range))\n     }\n     pub fn on_eq_typed(&self, file_id: FileId, offset: TextUnit) -> Option<SourceChange> {\n         let file = self.imp.file_syntax(file_id);\n-        Some(SourceChange::from_local_edit(file_id, \"add semicolon\", libeditor::on_eq_typed(file, offset)?))\n+        Some(SourceChange::from_local_edit(file_id, \"add semicolon\", libeditor::on_eq_typed(&file, offset)?))\n     }\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::file_structure(file)\n+        libeditor::file_structure(&file)\n     }\n     pub fn symbol_search(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         self.imp.world_symbols(query, token)\n@@ -208,15 +208,15 @@ impl Analysis {\n     }\n     pub fn runnables(&self, file_id: FileId) -> Vec<Runnable> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::runnables(file)\n+        libeditor::runnables(&file)\n     }\n     pub fn highlight(&self, file_id: FileId) -> Vec<HighlightedRange> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::highlight(file)\n+        libeditor::highlight(&file)\n     }\n     pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n         let file = self.imp.file_syntax(file_id);\n-        libeditor::scope_completion(file, offset)\n+        libeditor::scope_completion(&file, offset)\n     }\n     pub fn assists(&self, file_id: FileId, range: TextRange) -> Vec<SourceChange> {\n         self.imp.assists(file_id, range)"}, {"sha": "a21f55fff1e6863c281aa989451a2c7b0c77dc39", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 131, "deletions": 255, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -1,281 +1,157 @@\n-use relative_path::RelativePathBuf;\n-use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n-use libsyntax2::{\n-    File,\n-    ast::{self, AstNode, NameOwner},\n-    SyntaxNode, SmolStr,\n+use std::sync::Arc;\n+use {\n+    FileId,\n+    db::{\n+        Query, QueryRegistry, QueryCtx,\n+        file_set\n+    },\n+    queries::file_syntax,\n+    descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n };\n-use {FileId, imp::FileResolverImp};\n-\n-type SyntaxProvider<'a> = dyn Fn(FileId) -> &'a File + 'a;\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct ModuleId(FileId);\n-\n-#[derive(Debug, Default)]\n-pub struct ModuleMap {\n-    state: RwLock<State>,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ChangeKind {\n-    Delete, Insert, Update\n-}\n-\n-impl Clone for ModuleMap {\n-    fn clone(&self) -> ModuleMap {\n-        let state = self.state.read().clone();\n-        ModuleMap { state: RwLock::new(state) }\n-    }\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-struct State {\n-    file_resolver: FileResolverImp,\n-    changes: Vec<(FileId, ChangeKind)>,\n-    links: Vec<Link>,\n-}\n \n-#[derive(Clone, Debug)]\n-struct Link {\n-    owner: ModuleId,\n-    syntax: SyntaxNode,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n+pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n+    reg.add(MODULE_DESCR, \"MODULE_DESCR\");\n+    reg.add(MODULE_TREE, \"MODULE_TREE\");\n }\n \n-#[derive(Clone, Debug)]\n-pub enum Problem {\n-    UnresolvedModule {\n-        candidate: RelativePathBuf,\n-    },\n-    NotDirOwner {\n-        move_to: RelativePathBuf,\n-        candidate: RelativePathBuf,\n-    }\n+pub(crate) fn module_tree(ctx: QueryCtx) -> Arc<ModuleTreeDescriptor> {\n+    ctx.get(MODULE_TREE, ())\n }\n \n-impl ModuleMap {\n-    pub fn new() -> ModuleMap {\n-        Default::default()\n-    }\n-    pub fn update_file(&mut self, file_id: FileId, change_kind: ChangeKind) {\n-        self.state.get_mut().changes.push((file_id, change_kind));\n-    }\n-    pub(crate) fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n-        self.state.get_mut().file_resolver = file_resolver;\n-    }\n-    pub fn module2file(&self, m: ModuleId) -> FileId {\n-        m.0\n-    }\n-    pub fn file2module(&self, file_id: FileId) -> ModuleId {\n-        ModuleId(file_id)\n-    }\n-    pub fn child_module_by_name<'a>(\n-        &self,\n-        parent_mod: ModuleId,\n-        child_mod: &str,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> Vec<ModuleId> {\n-        self.links(syntax_provider)\n-            .links\n-            .iter()\n-            .filter(|link| link.owner == parent_mod)\n-            .filter(|link| link.name() == child_mod)\n-            .filter_map(|it| it.points_to.first())\n-            .map(|&it| it)\n-            .collect()\n-    }\n-\n-    pub fn parent_modules(\n-        &self,\n-        m: ModuleId,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> Vec<(ModuleId, SmolStr, SyntaxNode)> {\n-        let mut res = Vec::new();\n-        self.for_each_parent_link(m, syntax_provider, |link| {\n-            res.push(\n-                (link.owner, link.name().clone(), link.syntax.clone())\n-            )\n-        });\n-        res\n-    }\n-\n-    pub fn parent_module_ids(\n-        &self,\n-        m: ModuleId,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> Vec<ModuleId> {\n-        let mut res = Vec::new();\n-        self.for_each_parent_link(m, syntax_provider, |link| res.push(link.owner));\n-        res\n-    }\n-\n-    fn for_each_parent_link(\n-        &self,\n-        m: ModuleId,\n-        syntax_provider: &SyntaxProvider,\n-        f: impl FnMut(&Link)\n-    ) {\n-        self.links(syntax_provider)\n-            .links\n-            .iter()\n-            .filter(move |link| link.points_to.iter().any(|&it| it == m))\n-            .for_each(f)\n+const MODULE_DESCR: Query<FileId, ModuleDescriptor> = Query(30, |ctx, &file_id| {\n+    let file = file_syntax(ctx, file_id);\n+    ModuleDescriptor::new(file.ast())\n+});\n+\n+const MODULE_TREE: Query<(), ModuleTreeDescriptor> = Query(31, |ctx, _| {\n+    let file_set = file_set(ctx);\n+    let mut files = Vec::new();\n+    for &file_id in file_set.0.iter() {\n+        let module_descr = ctx.get(MODULE_DESCR, file_id);\n+        files.push((file_id, module_descr));\n+    }\n+    ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.1)\n+});\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::collections::HashMap;\n+    use im;\n+    use relative_path::{RelativePath, RelativePathBuf};\n+    use {\n+        db::{Db},\n+        imp::FileResolverImp,\n+        FileId, FileResolver,\n+    };\n+    use super::*;\n+\n+    #[derive(Debug)]\n+    struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n+\n+    impl FileResolver for FileMap {\n+        fn file_stem(&self, file_id: FileId) -> String {\n+            self.0[&file_id].file_stem().unwrap().to_string()\n+        }\n+        fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n+            let path = self.0[&file_id].join(rel).normalize();\n+            self.0.iter()\n+                .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n+                .next()\n+        }\n     }\n \n-    pub fn problems(\n-        &self,\n-        file: FileId,\n-        syntax_provider: &SyntaxProvider,\n-        mut cb: impl FnMut(ast::Name, &Problem),\n-    ) {\n-        let module = self.file2module(file);\n-        let links = self.links(syntax_provider);\n-        links\n-            .links\n-            .iter()\n-            .filter(|link| link.owner == module)\n-            .filter_map(|link| {\n-                let problem = link.problem.as_ref()?;\n-                Some((link, problem))\n-            })\n-            .for_each(|(link, problem)| cb(link.name_node(), problem))\n+    struct Fixture {\n+        next_file_id: u32,\n+        fm: im::HashMap<FileId, RelativePathBuf>,\n+        db: Db,\n     }\n \n-    fn links(\n-        &self,\n-        syntax_provider: &SyntaxProvider,\n-    ) -> RwLockReadGuard<State> {\n-        {\n-            let guard = self.state.read();\n-            if guard.changes.is_empty() {\n-                return guard;\n+    impl Fixture {\n+        fn new() -> Fixture {\n+            Fixture {\n+                next_file_id: 1,\n+                fm: im::HashMap::new(),\n+                db: Db::new(),\n             }\n         }\n-        let mut guard = self.state.write();\n-        if !guard.changes.is_empty() {\n-            guard.apply_changes(syntax_provider);\n+        fn add_file(&mut self, path: &str, text: &str) -> FileId {\n+            assert!(path.starts_with(\"/\"));\n+            let file_id = FileId(self.next_file_id);\n+            self.next_file_id += 1;\n+            self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n+            new_state.file_resolver = FileResolverImp::new(\n+                Arc::new(FileMap(self.fm.clone()))\n+            );\n+            self.db = self.db.with_changes(new_state, &[file_id], true);\n+            file_id\n         }\n-        assert!(guard.changes.is_empty());\n-        RwLockWriteGuard::downgrade(guard)\n-    }\n-}\n-\n-impl State {\n-    pub fn apply_changes(\n-        &mut self,\n-        syntax_provider: &SyntaxProvider,\n-    ) {\n-        let mut reresolve = false;\n-        for (file_id, kind) in self.changes.drain(..) {\n-            let mod_id = ModuleId(file_id);\n-            self.links.retain(|link| link.owner != mod_id);\n-            match kind {\n-                ChangeKind::Delete => {\n-                    for link in self.links.iter_mut() {\n-                        link.points_to.retain(|&x| x != mod_id);\n-                    }\n-                }\n-                ChangeKind::Insert => {\n-                    let file = syntax_provider(file_id);\n-                    self.links.extend(\n-                        file\n-                            .ast()\n-                            .modules()\n-                            .filter_map(|it| Link::new(mod_id, it))\n-                    );\n-                    reresolve = true;\n-                }\n-                ChangeKind::Update => {\n-                    let file = syntax_provider(file_id);\n-                    let resolver = &self.file_resolver;\n-                    self.links.extend(\n-                        file\n-                            .ast()\n-                            .modules()\n-                            .filter_map(|it| Link::new(mod_id, it))\n-                            .map(|mut link| {\n-                                link.resolve(resolver);\n-                                link\n-                            })\n-                    );\n-                }\n-            }\n+        fn remove_file(&mut self, file_id: FileId) {\n+            self.fm.remove(&file_id);\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.remove(&file_id);\n+            new_state.file_resolver = FileResolverImp::new(\n+                Arc::new(FileMap(self.fm.clone()))\n+            );\n+            self.db = self.db.with_changes(new_state, &[file_id], true);\n         }\n-        if reresolve {\n-            for link in self.links.iter_mut() {\n-                link.resolve(&self.file_resolver)\n-            }\n+        fn change_file(&mut self, file_id: FileId, new_text: &str) {\n+            let mut new_state = self.db.state().clone();\n+            new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n+            self.db = self.db.with_changes(new_state, &[file_id], false);\n         }\n-    }\n-}\n+        fn check_parent_modules(\n+            &self,\n+            file_id: FileId,\n+            expected: &[FileId],\n+            queries: &[(&'static str, u64)]\n+        ) {\n+            let (tree, events) = self.db.trace_query(|ctx| module_tree(ctx));\n+            let actual = tree.parent_modules(file_id)\n+                .into_iter()\n+                .map(|link| link.owner(&tree))\n+                .collect::<Vec<_>>();\n+            assert_eq!(actual.as_slice(), expected);\n+            let mut counts = HashMap::new();\n+            events.into_iter()\n+               .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n+            for &(query_id, expected_count) in queries.iter() {\n+                let actual_count = *counts.get(&query_id).unwrap_or(&0);\n+                assert_eq!(\n+                    actual_count,\n+                    expected_count,\n+                    \"counts for {} differ\",\n+                    query_id,\n+                )\n+            }\n \n-impl Link {\n-    fn new(owner: ModuleId, module: ast::Module) -> Option<Link> {\n-        if module.name().is_none() {\n-            return None;\n         }\n-        let link = Link {\n-            owner,\n-            syntax: module.syntax().owned(),\n-            points_to: Vec::new(),\n-            problem: None,\n-        };\n-        Some(link)\n     }\n \n-    fn name(&self) -> SmolStr {\n-        self.name_node().text()\n-    }\n+    #[test]\n+    fn test_parent_module() {\n+        let mut f = Fixture::new();\n+        let foo = f.add_file(\"/foo.rs\", \"\");\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-    fn name_node(&self) -> ast::Name {\n-        self.ast().name().unwrap()\n-    }\n+        let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n \n-    fn ast(&self) -> ast::Module {\n-        ast::Module::cast(self.syntax.borrowed())\n-            .unwrap()\n-    }\n+        f.change_file(lib, \"\");\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-    fn resolve(&mut self, file_resolver: &FileResolverImp) {\n-        if !self.ast().has_semi() {\n-            self.problem = None;\n-            self.points_to = Vec::new();\n-            return;\n-        }\n-        let (points_to, problem) = resolve_submodule(self.owner.0, &self.name(), file_resolver);\n-        self.problem = problem;\n-        self.points_to = points_to.into_iter().map(ModuleId).collect();\n-    }\n-}\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n \n-pub(crate) fn resolve_submodule(file_id: FileId, name: &SmolStr, file_resolver: &FileResolverImp) -> (Vec<FileId>, Option<Problem>) {\n-    let mod_name = file_resolver.file_stem(file_id);\n-    let is_dir_owner =\n-        mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+        f.change_file(lib, \"mod bar;\");\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n \n-    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n-    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n-    let points_to: Vec<FileId>;\n-    let problem: Option<Problem>;\n-    if is_dir_owner {\n-        points_to = [&file_mod, &dir_mod].iter()\n-            .filter_map(|path| file_resolver.resolve(file_id, path))\n-            .collect();\n-        problem = if points_to.is_empty() {\n-            Some(Problem::UnresolvedModule {\n-                candidate: file_mod,\n-            })\n-        } else {\n-            None\n-        }\n-    } else {\n-        points_to = Vec::new();\n-        problem = Some(Problem::NotDirOwner {\n-            move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n-            candidate: file_mod,\n-        });\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n+\n+        f.remove_file(lib);\n+        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n     }\n-    (points_to, problem)\n }"}, {"sha": "adad943da50a0903cf08b9959784d9defdba8dd4", "filename": "crates/libanalysis/src/module_map_db/mod.rs", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/3ebeb0db8de65434db79c86aeed5473bfb21334f/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebeb0db8de65434db79c86aeed5473bfb21334f/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db%2Fmod.rs?ref=3ebeb0db8de65434db79c86aeed5473bfb21334f", "patch": "@@ -1,159 +0,0 @@\n-use std::sync::Arc;\n-use {\n-    FileId,\n-    db::{\n-        Query, QueryRegistry, QueryCtx,\n-        file_syntax, file_set\n-    },\n-    descriptors::{ModuleDescriptor, ModuleTreeDescriptor}\n-};\n-\n-pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n-    reg.add(MODULE_DESCR, \"MODULE_DESCR\");\n-}\n-\n-pub(crate) fn module_tree(ctx: QueryCtx) -> Arc<ModuleTreeDescriptor> {\n-    ctx.get(MODULE_TREE, ())\n-}\n-\n-impl<'a> QueryCtx<'a> {\n-    fn module_descr(&self, file_id: FileId) -> Arc<ModuleDescriptor> {\n-        self.get(MODULE_DESCR, file_id)\n-    }\n-}\n-\n-const MODULE_DESCR: Query<FileId, ModuleDescriptor> = Query(30, |ctx, &file_id| {\n-    let file = file_syntax(ctx, file_id);\n-    ModuleDescriptor::new(file.ast())\n-});\n-\n-const MODULE_TREE: Query<(), ModuleTreeDescriptor> = Query(31, |ctx, _| {\n-    let file_set = file_set(ctx);\n-    let mut files = Vec::new();\n-    for &file_id in file_set.0.iter() {\n-        let module_descr = ctx.get(MODULE_DESCR, file_id);\n-        files.push((file_id, module_descr));\n-    }\n-    ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.1)\n-});\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::collections::HashMap;\n-    use im;\n-    use relative_path::{RelativePath, RelativePathBuf};\n-    use {\n-        db::{Query, Db, State},\n-        imp::FileResolverImp,\n-        FileId, FileResolver,\n-    };\n-    use super::*;\n-\n-    #[derive(Debug)]\n-    struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n-\n-    impl FileResolver for FileMap {\n-        fn file_stem(&self, file_id: FileId) -> String {\n-            self.0[&file_id].file_stem().unwrap().to_string()\n-        }\n-        fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n-            let path = self.0[&file_id].join(rel).normalize();\n-            self.0.iter()\n-                .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n-                .next()\n-        }\n-    }\n-\n-    struct Fixture {\n-        next_file_id: u32,\n-        fm: im::HashMap<FileId, RelativePathBuf>,\n-        db: Db,\n-    }\n-\n-    impl Fixture {\n-        fn new() -> Fixture {\n-            Fixture {\n-                next_file_id: 1,\n-                fm: im::HashMap::new(),\n-                db: Db::new(),\n-            }\n-        }\n-        fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-            assert!(path.starts_with(\"/\"));\n-            let file_id = FileId(self.next_file_id);\n-            self.next_file_id += 1;\n-            self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n-            let mut new_state = self.db.state().clone();\n-            new_state.file_map.insert(file_id, Arc::new(text.to_string()));\n-            new_state.file_resolver = FileResolverImp::new(\n-                Arc::new(FileMap(self.fm.clone()))\n-            );\n-            self.db = self.db.with_changes(new_state, &[file_id], true);\n-            file_id\n-        }\n-        fn remove_file(&mut self, file_id: FileId) {\n-            self.fm.remove(&file_id);\n-            let mut new_state = self.db.state().clone();\n-            new_state.file_map.remove(&file_id);\n-            new_state.file_resolver = FileResolverImp::new(\n-                Arc::new(FileMap(self.fm.clone()))\n-            );\n-            self.db = self.db.with_changes(new_state, &[file_id], true);\n-        }\n-        fn change_file(&mut self, file_id: FileId, new_text: &str) {\n-            let mut new_state = self.db.state().clone();\n-            new_state.file_map.insert(file_id, Arc::new(new_text.to_string()));\n-            self.db = self.db.with_changes(new_state, &[file_id], false);\n-        }\n-        fn check_parent_modules(\n-            &self,\n-            file_id: FileId,\n-            expected: &[FileId],\n-            queries: &[(&'static str, u64)]\n-        ) {\n-            let (actual, events) = self.db.trace_query(|ctx| {\n-                ctx.get(PARENT_MODULE, file_id)\n-            });\n-            assert_eq!(actual.as_slice(), expected);\n-            let mut counts = HashMap::new();\n-            events.into_iter()\n-               .for_each(|event| *counts.entry(event).or_insert(0) += 1);\n-            for &(query_id, expected_count) in queries.iter() {\n-                let actual_count = *counts.get(&query_id).unwrap_or(&0);\n-                assert_eq!(\n-                    actual_count,\n-                    expected_count,\n-                    \"counts for {} differ\",\n-                    query_id,\n-                )\n-            }\n-\n-        }\n-    }\n-\n-    #[test]\n-    fn test_parent_module() {\n-        let mut f = Fixture::new();\n-        let foo = f.add_file(\"/foo.rs\", \"\");\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-        let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 0)]);\n-\n-        f.change_file(lib, \"\");\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-        f.change_file(lib, \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-\n-        f.change_file(lib, \"mod bar;\");\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 1)]);\n-\n-        f.change_file(lib, \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(\"MODULE_DESCR\", 1)]);\n-\n-        f.remove_file(lib);\n-        f.check_parent_modules(foo, &[], &[(\"MODULE_DESCR\", 0)]);\n-    }\n-}"}, {"sha": "9d6754fd47c1ecd628c48de60cc338a900390146", "filename": "crates/libanalysis/src/queries.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fqueries.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -0,0 +1,28 @@\n+use std::sync::Arc;\n+use libsyntax2::File;\n+use libeditor::LineIndex;\n+use {\n+    FileId,\n+    db::{Query, QueryCtx, QueryRegistry, file_text},\n+};\n+\n+pub(crate) fn register_queries(reg: &mut QueryRegistry) {\n+    reg.add(FILE_SYNTAX, \"FILE_SYNTAX\");\n+    reg.add(FILE_LINES, \"FILE_LINES\");\n+}\n+\n+pub(crate) fn file_syntax(ctx: QueryCtx, file_id: FileId) -> File {\n+    (&*ctx.get(FILE_SYNTAX, file_id)).clone()\n+}\n+pub(crate) fn file_lines(ctx: QueryCtx, file_id: FileId) -> Arc<LineIndex> {\n+    ctx.get(FILE_LINES, file_id)\n+}\n+\n+const FILE_SYNTAX: Query<FileId, File> = Query(16, |ctx, file_id: &FileId| {\n+    let text = file_text(ctx, *file_id);\n+    File::parse(&*text)\n+});\n+const FILE_LINES: Query<FileId, LineIndex> = Query(17, |ctx, file_id: &FileId| {\n+    let text = file_text(ctx, *file_id);\n+    LineIndex::new(&*text)\n+});"}, {"sha": "0e7253ba2fb7a2c688c46c538b9abbf43b13a802", "filename": "crates/libanalysis/src/roots.rs", "status": "modified", "additions": 50, "deletions": 64, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e69ff21207d83864e13f6c8631733f4f0c32ba0d/crates%2Flibanalysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Froots.rs?ref=e69ff21207d83864e13f6c8631733f4f0c32ba0d", "patch": "@@ -1,6 +1,5 @@\n use std::{\n     collections::HashMap,\n-    time::Instant,\n     sync::Arc,\n     panic,\n };\n@@ -13,83 +12,74 @@ use libsyntax2::File;\n use {\n     FileId,\n     imp::FileResolverImp,\n-    module_map::{ModuleMap, ChangeKind},\n     symbol_index::SymbolIndex,\n     descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n+    db::Db,\n };\n \n pub(crate) trait SourceRoot {\n     fn contains(&self, file_id: FileId) -> bool;\n-    fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n-        unimplemented!()\n-    }\n-    // fn module_map(&self) -> &ModuleMap;\n-    fn lines(&self, file_id: FileId) -> &LineIndex;\n-    fn syntax(&self, file_id: FileId) -> &File;\n+    fn module_tree(&self) -> Arc<ModuleTreeDescriptor>;\n+    fn lines(&self, file_id: FileId) -> Arc<LineIndex>;\n+    fn syntax(&self, file_id: FileId) -> File;\n     fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>);\n }\n \n-#[derive(Clone, Default, Debug)]\n+#[derive(Default, Debug)]\n pub(crate) struct WritableSourceRoot {\n-    file_map: HashMap<FileId, Arc<(FileData, OnceCell<SymbolIndex>)>>,\n-    module_map: ModuleMap,\n+    db: Db,\n }\n \n impl WritableSourceRoot {\n-    pub fn update(&mut self, file_id: FileId, text: Option<String>) {\n-        let change_kind = if self.file_map.remove(&file_id).is_some() {\n-            if text.is_some() {\n-                ChangeKind::Update\n-            } else {\n-                ChangeKind::Delete\n+    pub fn apply_changes(\n+        &self,\n+        changes: &mut dyn Iterator<Item=(FileId, Option<String>)>,\n+        file_resolver: Option<FileResolverImp>,\n+    ) -> WritableSourceRoot {\n+        let resolver_changed = file_resolver.is_some();\n+        let mut changed_files = Vec::new();\n+        let mut new_state = self.db.state().clone();\n+\n+        for (file_id, text) in changes {\n+            changed_files.push(file_id);\n+            match text {\n+                Some(text) => {\n+                    new_state.file_map.insert(file_id, Arc::new(text));\n+                },\n+                None => {\n+                    new_state.file_map.remove(&file_id);\n+                }\n             }\n-        } else {\n-            ChangeKind::Insert\n-        };\n-        self.module_map.update_file(file_id, change_kind);\n-        self.file_map.remove(&file_id);\n-        if let Some(text) = text {\n-            let file_data = FileData::new(text);\n-            self.file_map.insert(file_id, Arc::new((file_data, Default::default())));\n         }\n-    }\n-    pub fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n-        self.module_map.set_file_resolver(file_resolver)\n-    }\n-    pub fn reindex(&self) {\n-        let now = Instant::now();\n-        self.file_map\n-            .par_iter()\n-            .for_each(|(&file_id, data)| {\n-                symbols(file_id, data);\n-            });\n-        info!(\"parallel indexing took {:?}\", now.elapsed());\n-\n-    }\n-    fn data(&self, file_id: FileId) -> &FileData {\n-        match self.file_map.get(&file_id) {\n-            Some(data) => &data.0,\n-            None => panic!(\"unknown file: {:?}\", file_id),\n+        if let Some(file_resolver) = file_resolver {\n+            new_state.file_resolver = file_resolver\n+        }\n+        WritableSourceRoot {\n+            db: self.db.with_changes(new_state, &changed_files, resolver_changed)\n         }\n     }\n }\n \n impl SourceRoot for WritableSourceRoot {\n+    fn module_tree(&self) -> Arc<ModuleTreeDescriptor> {\n+        self.db.make_query(::module_map::module_tree)\n+    }\n+\n     fn contains(&self, file_id: FileId) -> bool {\n-        self.file_map.contains_key(&file_id)\n+        self.db.state().file_map.contains_key(&file_id)\n     }\n-    fn lines(&self, file_id: FileId) -> &LineIndex {\n-        self.data(file_id).lines()\n+    fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n+        self.db.make_query(|ctx| ::queries::file_lines(ctx, file_id))\n     }\n-    fn syntax(&self, file_id: FileId) -> &File {\n-        self.data(file_id).syntax()\n+    fn syntax(&self, file_id: FileId) -> File {\n+        self.db.make_query(|ctx| ::queries::file_syntax(ctx, file_id))\n     }\n     fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>) {\n-        acc.extend(\n-            self.file_map\n-                .iter()\n-                .map(|(&file_id, data)| symbols(file_id, data))\n-        )\n+        // acc.extend(\n+        //     self.file_map\n+        //         .iter()\n+        //         .map(|(&file_id, data)| symbols(file_id, data))\n+        // )\n     }\n }\n \n@@ -101,7 +91,7 @@ fn symbols(file_id: FileId, (data, symbols): &(FileData, OnceCell<SymbolIndex>))\n #[derive(Debug)]\n struct FileData {\n     text: String,\n-    lines: OnceCell<LineIndex>,\n+    lines: OnceCell<Arc<LineIndex>>,\n     syntax: OnceCell<File>,\n }\n \n@@ -113,8 +103,8 @@ impl FileData {\n             lines: OnceCell::new(),\n         }\n     }\n-    fn lines(&self) -> &LineIndex {\n-        self.lines.get_or_init(|| LineIndex::new(&self.text))\n+    fn lines(&self) -> &Arc<LineIndex> {\n+        self.lines.get_or_init(|| Arc::new(LineIndex::new(&self.text)))\n     }\n     fn syntax(&self) -> &File {\n         let text = &self.text;\n@@ -127,10 +117,6 @@ impl FileData {\n             }\n         }\n     }\n-    fn syntax_transient(&self) -> File {\n-        self.syntax.get().map(|s| s.clone())\n-            .unwrap_or_else(|| File::parse(&self.text))\n-    }\n }\n \n #[derive(Debug)]\n@@ -184,11 +170,11 @@ impl SourceRoot for ReadonlySourceRoot {\n     fn contains(&self, file_id: FileId) -> bool {\n         self.file_map.contains_key(&file_id)\n     }\n-    fn lines(&self, file_id: FileId) -> &LineIndex {\n-        self.data(file_id).lines()\n+    fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n+        Arc::clone(self.data(file_id).lines())\n     }\n-    fn syntax(&self, file_id: FileId) -> &File {\n-        self.data(file_id).syntax()\n+    fn syntax(&self, file_id: FileId) -> File {\n+        self.data(file_id).syntax().clone()\n     }\n     fn symbols<'a>(&'a self, acc: &mut Vec<&'a SymbolIndex>) {\n         acc.push(&self.symbol_index)"}]}