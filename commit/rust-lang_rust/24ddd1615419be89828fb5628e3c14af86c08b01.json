{"sha": "24ddd1615419be89828fb5628e3c14af86c08b01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZGRkMTYxNTQxOWJlODk4MjhmYjU2MjhlM2MxNGFmODZjMDhiMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-12T13:41:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-12T13:41:43Z"}, "message": "Auto merge of #61722 - eddyb:vowel-exclusion-zone, r=oli-obk\n\nrustc: replace `TyCtxt<'a, 'gcx, 'tcx>` with `TyCtxt<'gcx, 'tcx>`.\n\nThis first lifetime parameter of `TyCtxt` has been phantom for a while, thanks to @Zoxc, but was never removed, and I'm doing this now in preparation for removing the `'gcx`/`'tcx` split.\n\nI wasn't going to do this as a separate step, and instead start converting uses of `TyCtxt` to a single-lifetime alias of it (e.g. `type TyCx<'tcx> = TyCtxt<'tcx, 'tcx, 'tcx>;`) but it turns out (as @Zoxc rightly predicted) that there is far more fallout from not needing a lifetime for the first parameter of `TyCtxt`.\n\nThat is, going from `TyCtxt<'a, 'gcx, 'tcx>` to `TyCtxt<'tcx, 'gcx, 'tcx>` (the first commit in this PR) has the largest amount of fallout out of all the changes we might make (because it can require removing the `'a` parameter of `struct`s containing `tcx: TyCtxt<'a, ...>`), and is the hardest to automate (because `'a` is used everywhere, not just with `TyCtxt`, unlike, say `'gcx, 'tcx` -> `'tcx`).\n\nSo I'm submitting this now to get it out of the way and reduce further friction in the future.\n\n**EDIT**: for the `rustfmt` commit, I used https://github.com/rust-lang/rustfmt/issues/1324#issuecomment-482109952, and manually filtered out some noise, like in #61735, but unlike that PR, there was also a weird bug to work around.\nIt should be reviewed separately, and dropped if unwanted.\n\ncc @rust-lang/compiler r? @nikomatsakis", "tree": {"sha": "0af40c207a95f4e5371fb9812e3992af86fdb5ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0af40c207a95f4e5371fb9812e3992af86fdb5ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ddd1615419be89828fb5628e3c14af86c08b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ddd1615419be89828fb5628e3c14af86c08b01", "html_url": "https://github.com/rust-lang/rust/commit/24ddd1615419be89828fb5628e3c14af86c08b01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ddd1615419be89828fb5628e3c14af86c08b01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d7a1c9dc81b0da3140fe008a2276d6f2c266f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7a1c9dc81b0da3140fe008a2276d6f2c266f10", "html_url": "https://github.com/rust-lang/rust/commit/3d7a1c9dc81b0da3140fe008a2276d6f2c266f10"}, {"sha": "4c98cb6f7586d92be37c94c6063fa9645a448e92", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c98cb6f7586d92be37c94c6063fa9645a448e92", "html_url": "https://github.com/rust-lang/rust/commit/4c98cb6f7586d92be37c94c6063fa9645a448e92"}], "stats": {"total": 7701, "additions": 3873, "deletions": 3828}, "files": [{"sha": "a2e7ebfdb0e4b270c190e6190e46941d13fd2d61", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -8,7 +8,7 @@ use crate::hir::{self, PatKind};\n use crate::hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     owner_def_id: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     graph: CFGGraph,\n@@ -30,8 +30,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break`\n }\n \n-pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           body: &hir::Body) -> CFG {\n+pub fn construct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n "}, {"sha": "481b5c72e9304a6ae8029fce7cd4384978ede739", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -12,7 +12,7 @@ pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n pub struct LabelledCFG<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges"}, {"sha": "d25d58bfd1fa65a3769ce3977b26b961304e0492", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -49,8 +49,7 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         body: &hir::Body) -> CFG {\n+    pub fn new<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n "}, {"sha": "82bba96dd4cc77ce5c9b72eacf94d09a4a13d253", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -204,7 +204,7 @@ macro_rules! define_dep_nodes {\n         impl DepNode {\n             #[allow(unreachable_code, non_snake_case)]\n             #[inline(always)]\n-            pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            pub fn new<'a, 'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>,\n                                        dep: DepConstructor<'gcx>)\n                                        -> DepNode\n                 where 'gcx: 'a + 'tcx,\n@@ -307,7 +307,7 @@ macro_rules! define_dep_nodes {\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n             #[inline]\n-            pub fn extract_def_id(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<DefId> {\n+            pub fn extract_def_id(&self, tcx: TyCtxt<'_, '_>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n                     tcx.def_path_hash_to_def_id.as_ref()?\n@@ -400,7 +400,7 @@ impl DefPathHash {\n \n impl DefId {\n     #[inline(always)]\n-    pub fn to_dep_node(self, tcx: TyCtxt<'_, '_, '_>, kind: DepKind) -> DepNode {\n+    pub fn to_dep_node(self, tcx: TyCtxt<'_, '_>, kind: DepKind) -> DepNode {\n         DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n     }\n }\n@@ -442,49 +442,50 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n ]);\n \n pub trait RecoverKey<'tcx>: Sized {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self>;\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self>;\n }\n \n impl RecoverKey<'tcx> for CrateNum {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.krate)\n     }\n }\n \n impl RecoverKey<'tcx> for DefId {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx)\n     }\n }\n \n impl RecoverKey<'tcx> for DefIndex {\n-    fn recover(tcx: TyCtxt<'_, 'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n+    fn recover(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> Option<Self> {\n         dep_node.extract_def_id(tcx).map(|id| id.index)\n     }\n }\n \n-trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n+trait DepNodeParams<'gcx: 'tcx, 'tcx>: fmt::Debug {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+    fn to_fingerprint(&self, _: TyCtxt<'gcx, 'tcx>) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, _: TyCtxt<'gcx, 'tcx>) -> String {\n         format!(\"{:?}\", self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'a>> + fmt::Debug\n+impl<'gcx: 'tcx, 'tcx, T> DepNodeParams<'gcx, 'tcx> for T\n+where\n+    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n-    default fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Fingerprint {\n         let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n \n@@ -493,58 +494,58 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n         hasher.finish()\n     }\n \n-    default fn to_debug_str(&self, _: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    default fn to_debug_str(&self, _: TyCtxt<'gcx, 'tcx>) -> String {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefId {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for DefIndex {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for DefIndex {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n         tcx.hir().definitions().def_path_hash(*self).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n         tcx.def_path_str(DefId::local(*self))\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for CrateNum {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n         let def_id = DefId {\n             krate: *self,\n             index: CRATE_DEF_INDEX,\n         };\n         tcx.def_path_hash(def_id).0\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n         tcx.crate_name(*self).as_str().to_string()\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n         let (def_id_0, def_id_1) = *self;\n \n         let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n@@ -553,7 +554,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n         def_path_hash_0.0.combine(def_path_hash_1.0)\n     }\n \n-    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+    fn to_debug_str(&self, tcx: TyCtxt<'gcx, 'tcx>) -> String {\n         let (def_id_0, def_id_1) = *self;\n \n         format!(\"({}, {})\",\n@@ -562,13 +563,13 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, De\n     }\n }\n \n-impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n+impl<'gcx: 'tcx, 'tcx> DepNodeParams<'gcx, 'tcx> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_, '_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_, '_>) -> Fingerprint {\n         let HirId {\n             owner,\n             local_id,"}, {"sha": "40ccd6e7b280a8f6c8d063da423eb2027a45bf46", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -90,7 +90,6 @@ where\n }\n \n impl DepGraph {\n-\n     pub fn new(prev_graph: PreviousDepGraph,\n                prev_work_products: FxHashMap<WorkProductId, WorkProduct>) -> DepGraph {\n         let prev_graph_node_count = prev_graph.node_count();\n@@ -558,8 +557,8 @@ impl DepGraph {\n     /// a node index can be found for that node.\n     pub fn try_mark_green_and_read(\n         &self,\n-        tcx: TyCtxt<'_, '_, '_>,\n-        dep_node: &DepNode\n+        tcx: TyCtxt<'_, '_>,\n+        dep_node: &DepNode,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n             debug_assert!(self.is_green(&dep_node));\n@@ -570,8 +569,8 @@ impl DepGraph {\n \n     pub fn try_mark_green(\n         &self,\n-        tcx: TyCtxt<'_, '_, '_>,\n-        dep_node: &DepNode\n+        tcx: TyCtxt<'_, '_>,\n+        dep_node: &DepNode,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n@@ -604,10 +603,10 @@ impl DepGraph {\n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<'tcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         data: &DepGraphData,\n         prev_dep_node_index: SerializedDepNodeIndex,\n-        dep_node: &DepNode\n+        dep_node: &DepNode,\n     ) -> Option<DepNodeIndex> {\n         debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n \n@@ -791,7 +790,7 @@ impl DepGraph {\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         data: &DepGraphData,\n         dep_node_index: DepNodeIndex,\n         did_allocation: bool,\n@@ -842,7 +841,7 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn exec_cache_promotions<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n             data.colors.values.indices().filter_map(|prev_index| {"}, {"sha": "62667c957cdc0c2f62aa9e5d4646bbacdba63c8b", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -33,8 +33,7 @@ impl DepGraphSafe for DefId {\n \n /// The type context itself can be used to access all kinds of tracked\n /// state, but those accesses should always generate read events.\n-impl<'a, 'gcx, 'tcx> DepGraphSafe for TyCtxt<'a, 'gcx, 'tcx> {\n-}\n+impl<'gcx, 'tcx> DepGraphSafe for TyCtxt<'gcx, 'tcx> {}\n \n /// Tuples make it easy to build up state.\n impl<A, B> DepGraphSafe for (A, B)"}, {"sha": "4d13d91c8f27d03ee3e36f64b78790e03feb9072", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -87,11 +87,11 @@ impl Target {\n     }\n }\n \n-struct CheckAttrVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CheckAttrVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n+impl CheckAttrVisitor<'tcx> {\n     /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n@@ -310,7 +310,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CheckAttrVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -347,7 +347,7 @@ fn is_c_like_enum(item: &hir::Item) -> bool {\n     }\n }\n \n-fn check_mod_attrs<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_attrs<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CheckAttrVisitor { tcx }.as_deep_visitor()"}, {"sha": "b3abe50a5952fc29359da97dd64cc28347c08d92", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -177,7 +177,7 @@ impl DefId {\n         LocalDefId::from_def_id(self)\n     }\n \n-    pub fn describe_as_module(&self, tcx: TyCtxt<'_, '_, '_>) -> String {\n+    pub fn describe_as_module(&self, tcx: TyCtxt<'_, '_>) -> String {\n         if self.is_local() && self.index == CRATE_DEF_INDEX {\n             format!(\"top-level module\")\n         } else {"}, {"sha": "332d15c319379b0a0834367ba280151f75e6bbbb", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -55,7 +55,7 @@ impl Visitor<'tcx> for LocalCollector {\n }\n \n struct CaptureCollector<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     locals: &'a FxHashSet<HirId>,\n     upvars: FxIndexMap<HirId, hir::Upvar>,\n }"}, {"sha": "4b5b458b2afb757ef86acd775beb8aec7a52c0ac", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -205,8 +205,8 @@ for &'b mut T {\n     }\n }\n \n-impl<'a, 'gcx, 'lcx> StableHashingContextProvider<'a> for TyCtxt<'a, 'gcx, 'lcx> {\n-    fn get_stable_hashing_context(&self) -> StableHashingContext<'a> {\n+impl StableHashingContextProvider<'lcx> for TyCtxt<'gcx, 'lcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'lcx> {\n         (*self).create_stable_hashing_context()\n     }\n }"}, {"sha": "dadac4b1e6b8f69da81caa620d0553f0f3c922f0", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -277,7 +277,7 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n \n struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: Option<&'cx InferCtxt<'cx, 'gcx, 'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     variables: SmallVec<[CanonicalVarInfo; 8]>,\n     query_state: &'cx mut OriginalQueryValues<'tcx>,\n     // Note that indices is only used once `var_values` is big enough to be\n@@ -290,7 +290,7 @@ struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -501,7 +501,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     fn canonicalize<V>(\n         value: &V,\n         infcx: Option<&InferCtxt<'_, 'gcx, 'tcx>>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalize_region_mode: &dyn CanonicalizeRegionMode,\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'gcx, V>"}, {"sha": "85e784d0ca5fb85c4c8186f4258cbb6805064b91", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -478,7 +478,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n     /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n     /// we'll return a substitution `subst` with:\n     /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn make_identity(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n         use crate::ty::subst::UnpackedKind;\n \n         CanonicalVarValues {"}, {"sha": "345889ca44174de612e692ff692907834a7d0dd1", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -29,7 +29,7 @@ use crate::ty::subst::{Kind, UnpackedKind};\n use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n-impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n     /// canonical key `canonical_key`, this method will create a new\n     /// inference context, instantiate the key, and run your operation\n@@ -647,7 +647,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n /// Given the region obligations and constraints scraped from the infcx,\n /// creates query region constraints.\n pub fn make_query_outlives<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> Vec<QueryRegionConstraint<'tcx>> {"}, {"sha": "d1310771fb353520b75e30a94e6b0edbf41b54df", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -14,7 +14,7 @@ use crate::ty::{self, TyCtxt};\n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n-    pub fn substitute(&self, tcx: TyCtxt<'_, '_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    pub fn substitute(&self, tcx: TyCtxt<'_, 'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n         V: TypeFoldable<'tcx>,\n     {\n@@ -29,7 +29,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     /// V, replacing each of the canonical variables.\n     pub fn substitute_projected<T>(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         var_values: &CanonicalVarValues<'tcx>,\n         projection_fn: impl FnOnce(&V) -> &T,\n     ) -> T\n@@ -46,7 +46,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n /// must be values for the set of canonical variables that appear in\n /// `value`.\n pub(super) fn substitute_value<'a, 'tcx, T>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     var_values: &CanonicalVarValues<'tcx>,\n     value: &'a T,\n ) -> T"}, {"sha": "d886efd33915f9a9ee5770ca8012246d8a4a8d11", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -58,12 +58,14 @@ pub enum RelationDir {\n }\n \n impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n-    pub fn super_combine_tys<R>(&self,\n-                                relation: &mut R,\n-                                a: Ty<'tcx>,\n-                                b: Ty<'tcx>)\n-                                -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'infcx, 'gcx, 'tcx>\n+    pub fn super_combine_tys<R>(\n+        &self,\n+        relation: &mut R,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -123,7 +125,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n     where\n-        R: TypeRelation<'infcx, 'gcx, 'tcx>,\n+        R: TypeRelation<'gcx, 'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -207,7 +209,7 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n }\n \n impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -413,8 +415,8 @@ struct Generalization<'tcx> {\n     needs_wf: bool,\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+impl TypeRelation<'gcx, 'tcx> for Generalizer<'_, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "a9e0e3376a54db789af13667128c0c9cc93fa815", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -24,12 +24,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Equate<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Equate<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Equate<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "d50cb8e61a60b37e2f0f65064c790d2895665135", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -67,7 +67,7 @@ mod need_type_info;\n \n pub mod nice_region_error;\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn note_and_explain_region(\n         self,\n         region_scope_tree: &region::ScopeTree,\n@@ -445,13 +445,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         use ty::print::Printer;\n         use ty::subst::Kind;\n \n-        struct AbsolutePathPrinter<'a, 'gcx, 'tcx> {\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        struct AbsolutePathPrinter<'gcx, 'tcx> {\n+            tcx: TyCtxt<'gcx, 'tcx>,\n         }\n \n         struct NonTrivialPath;\n \n-        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'_, 'gcx, 'tcx> {\n+        impl<'gcx, 'tcx> Printer<'gcx, 'tcx> for AbsolutePathPrinter<'gcx, 'tcx> {\n             type Error = NonTrivialPath;\n \n             type Path = Vec<String>;\n@@ -460,7 +460,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             type DynExistential = !;\n             type Const = !;\n \n-            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+            fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx> {\n                 self.tcx\n             }\n "}, {"sha": "8dd415ec9af4c3323cc2aa1e4b4415d3f3d8b351", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -81,8 +81,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n // walk the types like &mut Vec<&u8> and &u8 looking for the HIR\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n-struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct FindNestedTypeVisitor<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     // The bound_region corresponding to the Refree(freeregion)\n     // associated with the anonymous region we are looking for.\n     bound_region: ty::BoundRegion,\n@@ -92,7 +92,7 @@ struct FindNestedTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     current_index: ty::DebruijnIndex,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n+impl Visitor<'gcx> for FindNestedTypeVisitor<'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -208,14 +208,14 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n // and would walk the types like Vec<Ref> in the above example and Ref looking for the HIR\n // where that lifetime appears. This allows us to highlight the\n // specific part of the type in the error message.\n-struct TyPathVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct TyPathVisitor<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     found_it: bool,\n     bound_region: ty::BoundRegion,\n     current_index: ty::DebruijnIndex,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n+impl Visitor<'gcx> for TyPathVisitor<'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }"}, {"sha": "dc9ec15cb24927b926aef5cadb386620399bc1d7", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -56,7 +56,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         Self { infcx, error: None, regions: Some((span, sub, sup)), tables }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "8631236c0e36e8c2f1aa3fd00c4c3188233a640d", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -321,14 +321,14 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n     ) {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n-        struct Highlighted<'a, 'gcx, 'tcx, T> {\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        struct Highlighted<'gcx, 'tcx, T> {\n+            tcx: TyCtxt<'gcx, 'tcx>,\n             highlight: RegionHighlightMode,\n             value: T,\n         }\n \n-        impl<'a, 'gcx, 'tcx, T> Highlighted<'a, 'gcx, 'tcx, T> {\n-            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'a, 'gcx, 'tcx, U> {\n+        impl<'gcx, 'tcx, T> Highlighted<'gcx, 'tcx, T> {\n+            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'gcx, 'tcx, U> {\n                 Highlighted {\n                     tcx: self.tcx,\n                     highlight: self.highlight,\n@@ -337,8 +337,11 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'a, 'gcx, 'tcx, T> fmt::Display for Highlighted<'a, 'gcx, 'tcx, T>\n-            where T: for<'b, 'c> Print<'gcx, 'tcx,\n+        impl<'gcx, 'tcx, T> fmt::Display for Highlighted<'gcx, 'tcx, T>\n+        where\n+            T: for<'a, 'b, 'c> Print<\n+                'gcx,\n+                'tcx,\n                 FmtPrinter<'a, 'gcx, 'tcx, &'b mut fmt::Formatter<'c>>,\n                 Error = fmt::Error,\n             >,"}, {"sha": "641e5b127e8d0f8abda4d253399a9a37bf04e52a", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "ef6ea20c6dfba5c4b62eb4918c7fdbdcb4146c8e", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -143,7 +143,7 @@ pub struct InferenceFudger<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "0b3c0904d1777b9d7f14eeed473c5294cf8a4b41", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,12 +21,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Glb<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Glb<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Glb<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "236ebc19340bb37a5c84213278a3014ace82cc03", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -27,7 +27,7 @@ use crate::ty::TyVar;\n use crate::ty::{self, Ty};\n use crate::ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n+pub trait LatticeDir<'f, 'gcx: 'f + 'tcx, 'tcx: 'f>: TypeRelation<'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;"}, {"sha": "1612a2a54d10cb847590e7c6abb8e247ba5fd1c0", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -103,7 +103,7 @@ struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.region_rels.tcx\n     }\n \n@@ -136,7 +136,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n     /// Initially, the value for all variables is set to `'empty`, the\n     /// empty region. The `expansion` phase will grow this larger.\n-    fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n+    fn construct_var_data(&self, tcx: TyCtxt<'_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n             values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars())\n@@ -785,7 +785,7 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n }\n \n impl<'tcx> LexicalRegionResolutions<'tcx> {\n-    fn normalize<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    fn normalize<T>(&self, tcx: TyCtxt<'_, 'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "ab49968ce24db4504a2f24d46c0103400e88b9d2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,12 +21,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Lub<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Lub<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Lub<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n "}, {"sha": "11918eccfd0768cc7994a59a37381278beea75c0", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -91,7 +91,7 @@ impl SuppressRegionErrors {\n     /// Indicates that the MIR borrowck will repeat these region\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n-    pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    pub fn when_nll_is_enabled(tcx: TyCtxt<'_, '_>) -> Self {\n         match tcx.borrowck_mode() {\n             // If we're on Migrate mode, report AST region errors\n             BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n@@ -102,8 +102,8 @@ impl SuppressRegionErrors {\n     }\n }\n \n-pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct InferCtxt<'a, 'gcx, 'tcx> {\n+    pub tcx: TyCtxt<'gcx, 'tcx>,\n \n     /// During type-checking/inference of a body, `in_progress_tables`\n     /// contains a reference to the tables being built up, which are\n@@ -465,21 +465,21 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n /// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n /// Necessary because we can't write the following bound:\n /// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)`.\n-pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+pub struct InferCtxtBuilder<'gcx, 'tcx> {\n+    global_tcx: TyCtxt<'gcx, 'gcx>,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt(self) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+impl TyCtxt<'gcx, 'gcx> {\n+    pub fn infer_ctxt<'tcx>(self) -> InferCtxtBuilder<'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n             fresh_tables: None,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> InferCtxtBuilder<'gcx, 'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n     pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n@@ -498,7 +498,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         &'tcx mut self,\n         span: Span,\n         canonical: &Canonical<'tcx, T>,\n-        f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n+        f: impl for<'a> FnOnce(InferCtxt<'a, 'gcx, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n     ) -> R\n     where\n         T: TypeFoldable<'tcx>,\n@@ -510,7 +510,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn enter<R>(&'tcx mut self, f: impl for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R) -> R {\n+    pub fn enter<R>(&'tcx mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'gcx, 'tcx>) -> R) -> R {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref fresh_tables,\n@@ -1600,7 +1600,7 @@ impl<'a, 'gcx, 'tcx> ShallowResolver<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -1624,7 +1624,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ShallowResolver<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n+impl<'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.cause.span\n     }\n@@ -1641,7 +1641,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n         }\n     }\n \n-    pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: ObligationCause::dummy(),\n             values: Types(ExpectedFound {"}, {"sha": "f6ba13d2aa8f85c899691b741fab8ccd27114e01", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -494,11 +494,11 @@ impl VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n     }\n }\n \n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n+impl<D> TypeRelation<'gcx, 'tcx> for TypeRelating<'me, 'gcx, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -823,11 +823,11 @@ where\n     universe: ty::UniverseIndex,\n }\n \n-impl<D> TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n+impl<D> TypeRelation<'gcx, 'tcx> for TypeGeneralizer<'me, 'gcx, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "355d527e8efb8c226817ec10e49b4c2ecca67c29", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -552,8 +552,8 @@ impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, '_, 'tcx>\n     }\n }\n \n-struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+struct ReverseMapper<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n \n     /// If errors have already been reported in this fn, we suppress\n     /// our own errors because they are sometimes derivative.\n@@ -567,9 +567,9 @@ struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     hidden_ty: Option<Ty<'tcx>>,\n }\n \n-impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n+impl ReverseMapper<'gcx, 'tcx> {\n     fn new(\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n         map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n@@ -599,8 +599,8 @@ impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for ReverseMapper<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -944,7 +944,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// and `opaque_hir_id` is the `HirId` of the definition of the existential type `Baz`.\n /// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n pub fn may_define_existential_type(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     def_id: DefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {"}, {"sha": "c2ae561fcd39fd6f074c70f76442ddac5c51dded", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -28,11 +28,12 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details.\n-    pub fn lub_free_regions<'a, 'gcx>(&self,\n-                                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      r_a: Region<'tcx>,\n-                                      r_b: Region<'tcx>)\n-                                      -> Region<'tcx> {\n+    pub fn lub_free_regions<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        r_a: Region<'tcx>,\n+        r_b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n         assert!(is_free(r_a));\n         assert!(is_free(r_b));\n@@ -90,7 +91,7 @@ impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n         self.relation.maybe_map(|&fr| tcx.lift(&fr))\n                      .map(|relation| FreeRegionMap { relation })\n     }"}, {"sha": "ddc1cd0ff3ffaa8837e610fc5e7df9aeb18f2dc0", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -233,7 +233,7 @@ where\n     // See the comments on `process_registered_region_obligations` for the meaning\n     // of these fields.\n     delegate: D,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     verify_bound: VerifyBoundCx<'cx, 'gcx, 'tcx>,\n }\n \n@@ -260,7 +260,7 @@ where\n {\n     pub fn new(\n         delegate: D,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "72079a6adc9fba394cda0859265e8a8b126221cf", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -13,15 +13,15 @@ use crate::util::captures::Captures;\n /// accrues them into the `region_obligations` code, but for NLL we\n /// use something else.\n pub struct VerifyBoundCx<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         region_bound_pairs: &'cx RegionBoundPairs<'tcx>,\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "5fc6523feba55b744cc3b240ac6cb51a795c0e99", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// refactor the constraint set.\n     pub fn leak_check(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         overly_polymorphic: bool,\n         placeholder_map: &PlaceholderMap<'tcx>,\n         _snapshot: &CombinedSnapshot<'_, 'tcx>,\n@@ -109,7 +109,7 @@ impl<'tcx> TaintSet<'tcx> {\n \n     fn fixed_point(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         undo_log: &[UndoLog<'tcx>],\n         verifys: &[Verify<'tcx>],\n     ) {"}, {"sha": "cab102907f6035c5fe04ab1e93ef75f91611fd02", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -700,7 +700,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn lub_regions(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -722,7 +722,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn glb_regions(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -744,7 +744,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn opportunistic_resolve_var(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         rid: RegionVid,\n     ) -> ty::Region<'tcx> {\n         let vid = self.unification_table.probe_value(rid).min_vid;\n@@ -760,7 +760,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     fn combine_vars(\n         &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         t: CombineMapType,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -849,8 +849,8 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+impl<'gcx, 'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.item_def_id, p.substs),"}, {"sha": "774ebdcdd25029148ff018c493c46d8a7fb7116f", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -61,7 +61,7 @@ impl<'a, 'gcx, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -177,7 +177,7 @@ struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "e17da50d7be8cef027eeca523b4af31848a43cf2", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -31,11 +31,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> Sub<'combine, 'infcx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n-    for Sub<'combine, 'infcx, 'gcx, 'tcx>\n-{\n+impl TypeRelation<'gcx, 'tcx> for Sub<'combine, 'infcx, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'infcx, 'gcx, 'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R"}, {"sha": "7f9880031f3f070f1d396a27bb8b63f45788fd5e", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -10,7 +10,7 @@ use std::marker::PhantomData;\n use std::cell::RefMut;\n \n pub trait ToType {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn to_type<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -52,7 +52,7 @@ impl UnifyKey for ty::RegionVid {\n }\n \n impl ToType for IntVarValue {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -72,7 +72,7 @@ impl UnifyKey for ty::FloatVid {\n impl EqUnifyValue for FloatVarValue {}\n \n impl ToType for FloatVarValue {\n-    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(self.0)\n     }\n }"}, {"sha": "c6a77a314be6ae067db1c0fa1e5368145b83b55c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -509,7 +509,7 @@ impl LintStore {\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n \n     /// Side-tables for the body we are in.\n     // FIXME: Make this lazy to avoid running the TypeckTables query?\n@@ -780,11 +780,11 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// }\n     /// ```\n     pub fn get_def_path(&self, def_id: DefId) -> Vec<Symbol> {\n-        pub struct AbsolutePathPrinter<'a, 'tcx> {\n-            pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        pub struct AbsolutePathPrinter<'tcx> {\n+            pub tcx: TyCtxt<'tcx, 'tcx>,\n         }\n \n-        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n             type Error = !;\n \n             type Path = Vec<Symbol>;\n@@ -793,7 +793,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             type DynExistential = ();\n             type Const = ();\n \n-            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+            fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n                 self.tcx\n             }\n \n@@ -1372,7 +1372,7 @@ macro_rules! late_lint_pass_impl {\n late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     module_def_id: DefId,\n     pass: T,\n ) {\n@@ -1404,7 +1404,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n }\n \n pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     module_def_id: DefId,\n     builtin_lints: T,\n ) {\n@@ -1423,10 +1423,7 @@ pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     }\n }\n \n-fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    pass: T\n-) {\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx, 'tcx>, pass: T) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -1460,8 +1457,8 @@ fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n }\n \n fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    builtin_lints: T\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    builtin_lints: T,\n ) {\n     let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n \n@@ -1494,7 +1491,7 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n /// Performs lint checking on a crate.\n pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     builtin_lints: impl FnOnce() -> T + Send,\n ) {\n     join(|| {"}, {"sha": "5a17eee173d5ab1c5b922ea69ce86df7e2ddddaa", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -761,14 +761,12 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n     return err\n }\n \n-pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_, '_>, id: hir::HirId) -> bool {\n+pub fn maybe_lint_level_root(tcx: TyCtxt<'_, '_>, id: hir::HirId) -> bool {\n     let attrs = tcx.hir().attrs_by_hir_id(id);\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n-fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n-    -> &'tcx LintLevelMap\n-{\n+fn lint_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> &'tcx LintLevelMap {\n     assert_eq!(cnum, LOCAL_CRATE);\n     let mut builder = LintLevelMapBuilder {\n         levels: LintLevelSets::builder(tcx.sess),\n@@ -787,12 +785,12 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n-struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n+struct LintLevelMapBuilder<'tcx> {\n     levels: levels::LintLevelsBuilder<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n+impl LintLevelMapBuilder<'tcx> {\n     fn with_lint_attrs<F>(&mut self,\n                           id: hir::HirId,\n                           attrs: &[ast::Attribute],\n@@ -808,7 +806,7 @@ impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n+impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }"}, {"sha": "aeacd3722b4385ade11ed818e2aa53faf78654c1", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -195,7 +195,7 @@ macro_rules! CloneLiftImpls {\n         $(\n             impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n                 type Lifted = Self;\n-                fn lift_to_tcx<'a, 'gcx>(&self, _: $crate::ty::TyCtxt<'a, 'gcx, $tcx>) -> Option<Self> {\n+                fn lift_to_tcx<'gcx>(&self, _: $crate::ty::TyCtxt<'gcx, $tcx>) -> Option<Self> {\n                     Some(Clone::clone(self))\n                 }\n             }\n@@ -264,7 +264,7 @@ macro_rules! BraceStructLiftImpl {\n         {\n             type Lifted = $lifted;\n \n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+            fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<$lifted> {\n                 $(let $field = tcx.lift(&self.$field)?;)*\n                 Some(Self::Lifted { $($field),* })\n             }\n@@ -283,7 +283,7 @@ macro_rules! EnumLiftImpl {\n         {\n             type Lifted = $lifted;\n \n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n+            fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<$lifted> {\n                 EnumLiftImpl!(@Variants(self, tcx) input($($variants)*) output())\n             }\n         }"}, {"sha": "f258f06b87dccecd1d01ad6f4b66263cac4c24e2", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -211,9 +211,7 @@ pub trait CrateStore {\n     fn crates_untracked(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn encode_metadata<'a, 'tcx>(&self,\n-                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                 -> EncodedMetadata;\n+    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -228,9 +226,7 @@ pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n // In order to get this left-to-right dependency ordering, we perform a\n // topological sort of all crates putting the leaves at the right-most\n // positions.\n-pub fn used_crates(tcx: TyCtxt<'_, '_, '_>, prefer: LinkagePreference)\n-    -> Vec<(CrateNum, LibSource)>\n-{\n+pub fn used_crates(tcx: TyCtxt<'_, '_>, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n     let mut libs = tcx.crates()\n         .iter()\n         .cloned()"}, {"sha": "18e19e802e889da4d40f4276d4716e2e89fb516c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -26,8 +26,7 @@ use syntax_pos;\n // explored. For example, if it's a live Node::Item that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            hir_id: hir::HirId) -> bool {\n+fn should_explore<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: hir::HirId) -> bool {\n     match tcx.hir().find_by_hir_id(hir_id) {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n@@ -41,7 +40,7 @@ fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<hir::HirId>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     live_symbols: FxHashSet<hir::HirId>,\n     repr_has_repr_c: bool,\n@@ -302,9 +301,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n-                                    id: hir::HirId,\n-                                    attrs: &[ast::Attribute]) -> bool {\n+fn has_allow_dead_code_or_lang_attr(\n+    tcx: TyCtxt<'_, '_>,\n+    id: hir::HirId,\n+    attrs: &[ast::Attribute],\n+) -> bool {\n     if attr::contains_name(attrs, sym::lang) {\n         return true;\n     }\n@@ -353,7 +354,7 @@ fn has_allow_dead_code_or_lang_attr(tcx: TyCtxt<'_, '_, '_>,\n struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<hir::HirId>,\n     krate: &'k hir::Crate,\n-    tcx: TyCtxt<'k, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     // see `MarkSymbolVisitor::struct_constructors`\n     struct_constructors: FxHashMap<hir::HirId, hir::HirId>,\n }\n@@ -423,8 +424,8 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     }\n }\n \n-fn create_and_seed_worklist<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn create_and_seed_worklist<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     access_levels: &privacy::AccessLevels,\n     krate: &hir::Crate,\n ) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n@@ -451,10 +452,11 @@ fn create_and_seed_worklist<'a, 'tcx>(\n     (life_seeder.worklist, life_seeder.struct_constructors)\n }\n \n-fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       access_levels: &privacy::AccessLevels,\n-                       krate: &hir::Crate)\n-                       -> FxHashSet<hir::HirId> {\n+fn find_live<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    access_levels: &privacy::AccessLevels,\n+    krate: &hir::Crate,\n+) -> FxHashSet<hir::HirId> {\n     let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n@@ -471,12 +473,12 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     symbol_visitor.live_symbols\n }\n \n-struct DeadVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct DeadVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     live_symbols: FxHashSet<hir::HirId>,\n }\n \n-impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n+impl DeadVisitor<'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n         let should_warn = match item.node {\n             hir::ItemKind::Static(..)\n@@ -554,7 +556,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     /// Walk nested items in place so that we don't report dead-code\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n@@ -660,7 +662,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "2f6a3f2f02721e8ba0563060dbbbcd526a07d995", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -81,7 +81,7 @@ pub enum Linkage {\n     Dynamic,\n }\n \n-pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn calculate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let sess = &tcx.sess;\n     let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n         let linkage = calculate_type(tcx, ty);\n@@ -92,9 +92,7 @@ pub fn calculate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     sess.dependency_formats.set(fmts);\n }\n \n-fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: config::CrateType) -> DependencyList {\n-\n+fn calculate_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: config::CrateType) -> DependencyList {\n     let sess = &tcx.sess;\n \n     if !sess.opts.output_types.should_codegen() {\n@@ -242,10 +240,12 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ret\n }\n \n-fn add_library(tcx: TyCtxt<'_, '_, '_>,\n-               cnum: CrateNum,\n-               link: LinkagePreference,\n-               m: &mut FxHashMap<CrateNum, LinkagePreference>) {\n+fn add_library(\n+    tcx: TyCtxt<'_, '_>,\n+    cnum: CrateNum,\n+    link: LinkagePreference,\n+    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n+) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -267,7 +267,7 @@ fn add_library(tcx: TyCtxt<'_, '_, '_>,\n     }\n }\n \n-fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyList> {\n+fn attempt_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n     let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n@@ -324,7 +324,7 @@ fn activate_injected_dep(injected: Option<CrateNum>,\n \n // After the linkage for a crate has been determined we need to verify that\n // there's only going to be one allocator in the output.\n-fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n+fn verify_ok<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, list: &[Linkage]) {\n     let sess = &tcx.sess;\n     if list.len() == 0 {\n         return"}, {"sha": "024196e35647cdd39263480357a6282debbf2d53", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n }\n \n-fn entry_fn(tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n+fn entry_fn(tcx: TyCtxt<'_, '_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let any_exe = tcx.sess.crate_types.borrow().iter().any(|ty| {\n@@ -141,7 +141,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n }\n \n fn configure_main(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     visitor: &EntryContext<'_, '_>,\n ) -> Option<(DefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n@@ -179,7 +179,7 @@ fn configure_main(\n     }\n }\n \n-pub fn find_entry_point(tcx: TyCtxt<'_, '_, '_>) -> Option<(DefId, EntryFnType)> {\n+pub fn find_entry_point(tcx: TyCtxt<'_, '_>) -> Option<(DefId, EntryFnType)> {\n     tcx.entry_fn(LOCAL_CRATE)\n }\n "}, {"sha": "9e7af280408bd0bba77ef8306693e1a0f5911d62", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -38,9 +38,7 @@ pub enum ExportedSymbol<'tcx> {\n }\n \n impl<'tcx> ExportedSymbol<'tcx> {\n-    pub fn symbol_name(&self,\n-                       tcx: TyCtxt<'_, 'tcx, '_>)\n-                       -> ty::SymbolName {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'tcx, '_>) -> ty::SymbolName {\n         match *self {\n             ExportedSymbol::NonGeneric(def_id) => {\n                 tcx.symbol_name(ty::Instance::mono(tcx, def_id))\n@@ -54,10 +52,11 @@ impl<'tcx> ExportedSymbol<'tcx> {\n         }\n     }\n \n-    pub fn compare_stable(&self,\n-                          tcx: TyCtxt<'_, 'tcx, '_>,\n-                          other: &ExportedSymbol<'tcx>)\n-                          -> cmp::Ordering {\n+    pub fn compare_stable(\n+        &self,\n+        tcx: TyCtxt<'tcx, '_>,\n+        other: &ExportedSymbol<'tcx>,\n+    ) -> cmp::Ordering {\n         match *self {\n             ExportedSymbol::NonGeneric(self_def_id) => match *other {\n                 ExportedSymbol::NonGeneric(other_def_id) => {\n@@ -92,7 +91,7 @@ impl<'tcx> ExportedSymbol<'tcx> {\n     }\n }\n \n-pub fn metadata_symbol_name(tcx: TyCtxt<'_, '_, '_>) -> String {\n+pub fn metadata_symbol_name(tcx: TyCtxt<'_, '_>) -> String {\n     format!(\"rust_metadata_{}_{}\",\n             tcx.original_crate_name(LOCAL_CRATE),\n             tcx.crate_disambiguator(LOCAL_CRATE).to_fingerprint().to_hex())"}, {"sha": "3ed926d758264fbda39cd201deb0ebd06a85d638", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -202,7 +202,7 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id(tcx: TyCtxt<'_, '_, '_>, trait_id: DefId) -> OverloadedCallType {\n+    fn from_trait_id(tcx: TyCtxt<'_, '_>, trait_id: DefId) -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items().fn_once_trait(), FnOnceOverloadedCall),\n             (tcx.lang_items().fn_mut_trait(), FnMutOverloadedCall),\n@@ -219,7 +219,7 @@ impl OverloadedCallType {\n         bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id(tcx: TyCtxt<'_, '_, '_>, method_id: DefId) -> OverloadedCallType {\n+    fn from_method_id(tcx: TyCtxt<'_, '_>, method_id: DefId) -> OverloadedCallType {\n         let method = tcx.associated_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container.id())\n     }\n@@ -266,15 +266,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     ///   `None` means that rvalues will be given more conservative lifetimes.\n     ///\n     /// See also `with_infer`, which is used *during* typeck.\n-    pub fn new(delegate: &'a mut (dyn Delegate<'tcx>+'a),\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               body_owner: DefId,\n-               param_env: ty::ParamEnv<'tcx>,\n-               region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>,\n-               rvalue_promotable_map: Option<&'tcx ItemLocalSet>)\n-               -> Self\n-    {\n+    pub fn new(\n+        delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        body_owner: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n+    ) -> Self {\n         ExprUseVisitor {\n             mc: mc::MemCategorizationContext::new(tcx,\n                                                   body_owner,\n@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&body.value);\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.mc.tcx\n     }\n "}, {"sha": "74c50cabab0c451cf601bc7b03c051aaddf3e66c", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -16,7 +16,7 @@ use crate::ty::{self, TyCtxt, Region};\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'gcx, 'tcx>,\n \n     /// The context used to fetch the region maps.\n     pub context: DefId,\n@@ -30,7 +30,7 @@ pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         context: DefId,\n         region_scope_tree: &'a region::ScopeTree,\n         free_regions: &'a FreeRegionMap<'tcx>,"}, {"sha": "d3ed818c4be4568f575349acd0acea1280e6299b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::{Span, sym};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir;\n \n-fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_intrinsics<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ItemVisitor { tcx }.as_deep_visitor()\n@@ -24,21 +24,19 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-struct ItemVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct ItemVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-struct ExprVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ExprVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: &'tcx ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n-fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                ty: Ty<'tcx>)\n-                                -> Ty<'tcx> {\n+fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     let (def, substs) = match ty.sty {\n         ty::Adt(def, substs) => (def, substs),\n         _ => return ty\n@@ -66,7 +64,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty\n }\n \n-impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n+impl ExprVisitor<'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         self.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n         self.tcx.item_name(def_id) == sym::transmute\n@@ -131,7 +129,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for ItemVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n@@ -146,7 +144,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }"}, {"sha": "02163409b3271b3aba95cf04dbfca28aa54690f9", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -104,14 +104,14 @@ impl LanguageItems {\n     )*\n }\n \n-struct LanguageItemCollector<'a, 'tcx: 'a> {\n+struct LanguageItemCollector<'tcx> {\n     items: LanguageItems,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     /// A mapping from the name of the lang item to its order and the form it must be of.\n     item_refs: FxHashMap<&'static str, (usize, Target)>,\n }\n \n-impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some((value, span)) = extract(&item.attrs) {\n             let actual_target = Target::from_item(item);\n@@ -159,8 +159,8 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItemCollector<'a, 'tcx> {\n+impl LanguageItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>) -> LanguageItemCollector<'tcx> {\n         let mut item_refs = FxHashMap::default();\n \n         $( item_refs.insert($name, ($variant as usize, $target)); )*\n@@ -217,7 +217,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n }\n \n /// Traverse and collect all the lang items in all crates.\n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> LanguageItems {\n     // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n \n@@ -402,7 +402,7 @@ language_item_table! {\n     Rc,                          \"rc\",                 rc,                      Target::Struct;\n }\n \n-impl<'a, 'tcx, 'gcx> TyCtxt<'a, 'tcx, 'gcx> {\n+impl<'tcx, 'gcx> TyCtxt<'tcx, 'gcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally abort compilation.\n     pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {"}, {"sha": "b05ede53d1cfd1085b55df406e26e5fe45c62f7f", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -37,13 +37,13 @@ impl LibFeatures {\n     }\n }\n \n-pub struct LibFeatureCollector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct LibFeatureCollector<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     lib_features: LibFeatures,\n }\n \n-impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LibFeatureCollector<'a, 'tcx> {\n+impl LibFeatureCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>) -> LibFeatureCollector<'tcx> {\n         LibFeatureCollector {\n             tcx,\n             lib_features: LibFeatures::new(),\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n+impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LibFeatureCollector<'a, 'tcx> {\n     }\n }\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LibFeatures {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     intravisit::walk_crate(&mut collector, tcx.hir().krate());\n     collector.lib_features"}, {"sha": "92cb407f67d7c47d6f0c45eeabb888bf5b44f723", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -150,7 +150,7 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> String {\n+fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_>) -> String {\n     let cm = tcx.sess.source_map();\n     match lnk {\n         UpvarNode(s) => {\n@@ -166,7 +166,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> Strin\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n-fn check_mod_liveness<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_liveness<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut IrMaps::new(tcx, module_def_id).as_deep_visitor(),\n@@ -256,8 +256,8 @@ enum VarKind {\n     CleanExit\n }\n \n-struct IrMaps<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct IrMaps<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body_owner: DefId,\n     num_live_nodes: usize,\n     num_vars: usize,\n@@ -268,8 +268,8 @@ struct IrMaps<'a, 'tcx: 'a> {\n     lnks: Vec<LiveNodeKind>,\n }\n \n-impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body_owner: DefId) -> IrMaps<'a, 'tcx> {\n+impl IrMaps<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>, body_owner: DefId) -> IrMaps<'tcx> {\n         IrMaps {\n             tcx,\n             body_owner,\n@@ -352,12 +352,14 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n-                          fk: FnKind<'tcx>,\n-                          decl: &'tcx hir::FnDecl,\n-                          body_id: hir::BodyId,\n-                          sp: Span,\n-                          id: hir::HirId) {\n+fn visit_fn<'a, 'tcx: 'a>(\n+    ir: &mut IrMaps<'tcx>,\n+    fk: FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl,\n+    body_id: hir::BodyId,\n+    sp: Span,\n+    id: hir::HirId,\n+) {\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n@@ -374,7 +376,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n         }\n     }\n \n-    debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps<'_, '_>);\n+    debug!(\"creating fn_maps: {:p}\", &fn_maps);\n \n     let body = ir.tcx.hir().body(body_id);\n \n@@ -411,7 +413,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n-fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n+fn add_from_pat<'tcx>(ir: &mut IrMaps<'tcx>, pat: &P<hir::Pat>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n     let mut shorthand_field_ids = HirIdSet::default();\n@@ -457,19 +459,19 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     });\n }\n \n-fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n+fn visit_local<'tcx>(ir: &mut IrMaps<'tcx>, local: &'tcx hir::Local) {\n     add_from_pat(ir, &local.pat);\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+fn visit_arm<'tcx>(ir: &mut IrMaps<'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n         add_from_pat(ir, pat);\n     }\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n+fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n@@ -681,7 +683,7 @@ const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx: 'a> {\n-    ir: &'a mut IrMaps<'a, 'tcx>,\n+    ir: &'a mut IrMaps<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n@@ -695,7 +697,7 @@ struct Liveness<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'a, 'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n         // Special nodes and variables:\n         // - exit_ln represents the end of the fn, either by return or panic\n         // - implicit_ret_var is a pseudo-variable that represents"}, {"sha": "4b5b901f4703e2750aeec4948d24841d862d01f4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -287,8 +287,8 @@ impl HirNode for hir::Pat {\n }\n \n #[derive(Clone)]\n-pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct MemCategorizationContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'gcx, 'tcx>,\n     pub body_owner: DefId,\n     pub upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     pub region_scope_tree: &'a region::ScopeTree,\n@@ -339,8 +339,11 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>,\n-                  id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local(\n+        tcx: TyCtxt<'_, '_>,\n+        tables: &ty::TypeckTables<'_>,\n+        id: ast::NodeId,\n+    ) -> MutabilityCategory {\n         let ret = match tcx.hir().get(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n@@ -400,12 +403,13 @@ impl MutabilityCategory {\n }\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               body_owner: DefId,\n-               region_scope_tree: &'a region::ScopeTree,\n-               tables: &'a ty::TypeckTables<'tcx>,\n-               rvalue_promotable_map: Option<&'tcx ItemLocalSet>)\n-               -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        body_owner: DefId,\n+        region_scope_tree: &'a region::ScopeTree,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+        rvalue_promotable_map: Option<&'tcx ItemLocalSet>,\n+    ) -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n         MemCategorizationContext {\n             tcx,\n             body_owner,\n@@ -1514,7 +1518,7 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    pub fn descriptive_string(&self, tcx: TyCtxt<'_, '_, '_>) -> Cow<'static, str> {\n+    pub fn descriptive_string(&self, tcx: TyCtxt<'_, '_>) -> Cow<'static, str> {\n         match self.cat {\n             Categorization::StaticItem => {\n                 \"static item\".into()"}, {"sha": "b0068a191da4ca8e592c0aecf436cae7a2309b40", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -27,9 +27,7 @@ use crate::hir::intravisit;\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         item: &hir::Item,\n-                         attrs: CodegenFnAttrs) -> bool {\n+fn item_might_be_inlined(tcx: TyCtxt<'tcx, 'tcx>, item: &hir::Item, attrs: CodegenFnAttrs) -> bool {\n     if attrs.requests_inline() {\n         return true\n     }\n@@ -44,9 +42,11 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     impl_item: &hir::ImplItem,\n-                                     impl_src: DefId) -> bool {\n+fn method_might_be_inlined<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_item: &hir::ImplItem,\n+    impl_src: DefId,\n+) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n     let generics = tcx.generics_of(tcx.hir().local_def_id_from_hir_id(impl_item.hir_id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n@@ -67,7 +67,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Information needed while computing reachability.\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: HirIdSet,\n@@ -335,7 +335,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n // trait items are used from inlinable code through method call syntax or UFCS, or their\n // trait is a lang item.\n struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n     worklist: &'a mut Vec<hir::HirId>,\n }\n@@ -391,7 +391,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n #[derive(Clone, HashStable)]\n pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n-fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n+fn reachable_set<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "5968933721de6c3963cfd723734fa9d771237336", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -169,7 +169,7 @@ impl Scope {\n         self.id\n     }\n \n-    pub fn node_id(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> ast::NodeId {\n+    pub fn node_id(&self, tcx: TyCtxt<'_, '_>, scope_tree: &ScopeTree) -> ast::NodeId {\n         match scope_tree.root_body {\n             Some(hir_id) => {\n                 tcx.hir().hir_to_node_id(hir::HirId {\n@@ -184,7 +184,7 @@ impl Scope {\n     /// Returns the span of this `Scope`. Note that in general the\n     /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n-    pub fn span(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> Span {\n+    pub fn span(&self, tcx: TyCtxt<'_, '_>, scope_tree: &ScopeTree) -> Span {\n         let node_id = self.node_id(tcx, scope_tree);\n         if node_id == ast::DUMMY_NODE_ID {\n             return DUMMY_SP;\n@@ -358,8 +358,8 @@ pub struct Context {\n     parent: Option<(Scope, ScopeDepth)>,\n }\n \n-struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct RegionResolutionVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n \n     // The number of expressions and patterns visited in the current body\n     expr_and_pat_count: usize,\n@@ -646,9 +646,11 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      br: &ty::EarlyBoundRegion)\n-                                      -> Scope {\n+    pub fn early_free_scope<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        br: &ty::EarlyBoundRegion,\n+    ) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n@@ -677,8 +679,7 @@ impl<'tcx> ScopeTree {\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n     /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n-                                 -> Scope {\n+    pub fn free_scope<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, fr: &ty::FreeRegion) -> Scope {\n         let param_owner = match fr.bound_region {\n             ty::BoundRegion::BrNamed(def_id, _) => {\n                 tcx.parent(def_id).unwrap()\n@@ -734,9 +735,11 @@ impl<'tcx> ScopeTree {\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n-fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n-                       var_id: hir::ItemLocalId,\n-                       _sp: Span) {\n+fn record_var_lifetime(\n+    visitor: &mut RegionResolutionVisitor<'_>,\n+    var_id: hir::ItemLocalId,\n+    _sp: Span,\n+) {\n     match visitor.cx.var_parent {\n         None => {\n             // this can happen in extern fn declarations like\n@@ -748,7 +751,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n     }\n }\n \n-fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n+fn resolve_block<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n@@ -816,7 +819,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+fn resolve_arm<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, arm: &'tcx hir::Arm) {\n     let prev_cx = visitor.cx;\n \n     visitor.enter_scope(\n@@ -838,7 +841,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n+fn resolve_pat<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, pat: &'tcx hir::Pat) {\n     visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -855,7 +858,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n     debug!(\"resolve_pat - post-increment {} pat = {:?}\", visitor.expr_and_pat_count, pat);\n }\n \n-fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n+fn resolve_stmt<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.hir_id.local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -874,7 +877,7 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr - pre-increment {} expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n     let prev_cx = visitor.cx;\n@@ -977,9 +980,11 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n-                           pat: Option<&'tcx hir::Pat>,\n-                           init: Option<&'tcx hir::Expr>) {\n+fn resolve_local<'tcx>(\n+    visitor: &mut RegionResolutionVisitor<'tcx>,\n+    pat: Option<&'tcx hir::Pat>,\n+    init: Option<&'tcx hir::Expr>,\n+) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n     let blk_scope = visitor.cx.var_parent.map(|(p, _)| p);\n@@ -1127,11 +1132,11 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | box E&\n     ///        | E& as ...\n     ///        | ( E& )\n-    fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n-        visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n+    fn record_rvalue_scope_if_borrow_expr<'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'tcx>,\n         expr: &hir::Expr,\n-        blk_id: Option<Scope>)\n-    {\n+        blk_id: Option<Scope>,\n+    ) {\n         match expr.node {\n             hir::ExprKind::AddrOf(_, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n@@ -1178,9 +1183,11 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | <rvalue>\n     ///\n     /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n-    fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n-                                     expr: &hir::Expr,\n-                                     blk_scope: Option<Scope>) {\n+    fn record_rvalue_scope<'tcx>(\n+        visitor: &mut RegionResolutionVisitor<'tcx>,\n+        expr: &hir::Expr,\n+        blk_scope: Option<Scope>,\n+    ) {\n         let mut expr = expr;\n         loop {\n             // Note: give all the expressions matching `ET` with the\n@@ -1205,7 +1212,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     }\n }\n \n-impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n+impl<'tcx> RegionResolutionVisitor<'tcx> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n     /// Returns the depth of `child_scope`.\n     fn record_child_scope(&mut self, child_scope: Scope) -> ScopeDepth {\n@@ -1235,7 +1242,7 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n@@ -1327,9 +1334,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> &'tcx ScopeTree\n-{\n+fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ScopeTree {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n         return tcx.region_scope_tree(closure_base_def_id);"}, {"sha": "edd5cb4541a96fcb7126f8d8cdc4f5297de05640", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -218,7 +218,7 @@ impl_stable_hash_for!(struct crate::middle::resolve_lifetime::ResolveLifetimes {\n });\n \n struct LifetimeContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n@@ -368,10 +368,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n /// entire crate. You should not read the result of this query\n /// directly, but rather use `named_region_map`, `is_late_bound_map`,\n /// etc.\n-fn resolve_lifetimes<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    for_krate: CrateNum,\n-) -> &'tcx ResolveLifetimes {\n+fn resolve_lifetimes<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, for_krate: CrateNum) -> &'tcx ResolveLifetimes {\n     assert_eq!(for_krate, LOCAL_CRATE);\n \n     let named_region_map = krate(tcx);\n@@ -398,7 +395,7 @@ fn resolve_lifetimes<'tcx>(\n     tcx.arena.alloc(rl)\n }\n \n-fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n+fn krate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> NamedRegionMap {\n     let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {\n         defs: Default::default(),\n@@ -1101,7 +1098,7 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_, '_>, params: &P<[hir::GenericParam]>) {\n+fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_>, params: &P<[hir::GenericParam]>) {\n     let lifetime_params: Vec<_> = params\n         .iter()\n         .filter_map(|param| match param.kind {\n@@ -1129,7 +1126,7 @@ fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_, '_>, params: &P<[hi\n }\n \n fn signal_shadowing_problem(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     name: ast::Name,\n     orig: Original,\n     shadower: Shadower,\n@@ -1169,7 +1166,7 @@ fn signal_shadowing_problem(\n // if one of the label shadows a lifetime or another label.\n fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     struct GatherLabels<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<ast::Ident>,\n     }\n@@ -1218,7 +1215,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n \n     fn check_if_label_shadows_lifetime(\n-        tcx: TyCtxt<'_, '_, '_>,\n+        tcx: TyCtxt<'_, '_>,\n         mut scope: ScopeRef<'_>,\n         label: ast::Ident,\n     ) {\n@@ -1256,9 +1253,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(\n-    tcx: TyCtxt<'_, '_, '_>,\n-) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n+fn compute_object_lifetime_defaults(tcx: TyCtxt<'_, '_>) -> HirIdMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = HirIdMap::default();\n     for item in tcx.hir().krate().items.values() {\n         match item.node {\n@@ -1315,7 +1310,7 @@ fn compute_object_lifetime_defaults(\n /// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n /// for each type parameter.\n fn object_lifetime_defaults_for_item(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     generics: &hir::Generics,\n ) -> Vec<ObjectLifetimeDefault> {\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound]) {"}, {"sha": "dbd008256b0241848ad26cb2b7c173b0978635a4", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -106,7 +106,7 @@ impl_stable_hash_for!(struct self::Index<'tcx> {\n \n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<DeprecationEntry>,\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n }\n \n struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n }\n \n@@ -389,8 +389,8 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Index<'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n+impl<'tcx> Index<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx>) -> Index<'tcx> {\n         let is_staged_api =\n             tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n             tcx.features().staged_api;\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> Index<'tcx> {\n                                AnnotationKind::Required,\n                                |v| intravisit::walk_crate(v, krate));\n         }\n-        return index\n+        return index;\n     }\n \n     pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> Index<'tcx> {\n \n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors.\n-fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_unstable_api_usage<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut Checker { tcx }.as_deep_visitor());\n }\n \n@@ -501,8 +501,8 @@ pub fn deprecation_in_effect(since: &str) -> bool {\n     }\n }\n \n-struct Checker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Checker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n /// Result of `TyCtxt::eval_stability`.\n@@ -521,7 +521,7 @@ pub enum EvalResult {\n     Unmarked,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     // See issue #38412.\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n@@ -752,7 +752,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n+impl Visitor<'tcx> for Checker<'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n@@ -836,7 +836,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// Given the list of enabled features that were not language features (i.e., that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_unused_or_stable_features<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     if tcx.stability().staged_api[&LOCAL_CRATE] {\n@@ -920,11 +920,11 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // don't lint about unused features. We should reenable this one day!\n }\n \n-fn unnecessary_stable_feature_lint<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn unnecessary_stable_feature_lint<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     span: Span,\n     feature: Symbol,\n-    since: Symbol\n+    since: Symbol,\n ) {\n     tcx.lint_hir(lint::builtin::STABLE_FEATURES,\n         hir::CRATE_HIR_ID,"}, {"sha": "45d405df950e9ad9bddbed8b1c0241420b10732f", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,13 +18,13 @@ macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n struct Context<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     items: &'a mut lang_items::LanguageItems,\n }\n \n /// Checks the crate for usage of weak lang items, returning a vector of all the\n /// language items required by this crate, but not defined yet.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n                              items: &mut lang_items::LanguageItems) {\n     // These are never called by user code, they're generated by the compiler.\n     // They will never implicitly be added to the `missing` array unless we do\n@@ -60,7 +60,7 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n /// Not all lang items are always required for each compilation, particularly in\n /// the case of panic=abort. In these situations some lang items are injected by\n /// crates and don't actually need to be defined in libstd.\n-pub fn whitelisted(tcx: TyCtxt<'_, '_, '_>, lang_item: lang_items::LangItem) -> bool {\n+pub fn whitelisted(tcx: TyCtxt<'_, '_>, lang_item: lang_items::LangItem) -> bool {\n     // If we're not compiling with unwinding, we won't actually need these\n     // symbols. Other panic runtimes ensure that the relevant symbols are\n     // available to link things together, but they're never exercised.\n@@ -72,7 +72,7 @@ pub fn whitelisted(tcx: TyCtxt<'_, '_, '_>, lang_item: lang_items::LangItem) ->\n     false\n }\n \n-fn verify<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn verify<'tcx>(tcx: TyCtxt<'tcx, 'tcx>,\n                     items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n@@ -142,7 +142,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'gcx> TyCtxt<'a, 'tcx, 'gcx> {\n+impl<'tcx, 'gcx> TyCtxt<'tcx, 'gcx> {\n     pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n         let lang_items = self.lang_items();\n         let did = Some(item_def_id);"}, {"sha": "009cab3bd0315a234eac7c67766d207b7eaa6559", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -74,19 +74,16 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n-    pub fn struct_error(&self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n-        message: &str)\n-        -> Result<DiagnosticBuilder<'tcx>, ErrorHandled>\n-    {\n+impl<'gcx, 'tcx> ConstEvalErr<'tcx> {\n+    pub fn struct_error(\n+        &self,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n+        message: &str,\n+    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         self.struct_generic(tcx, message, None)\n     }\n \n-    pub fn report_as_error(&self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n-        message: &str\n-    ) -> ErrorHandled {\n+    pub fn report_as_error(&self, tcx: TyCtxtAt<'gcx, 'tcx>, message: &str) -> ErrorHandled {\n         let err = self.struct_error(tcx, message);\n         match err {\n             Ok(mut err) => {\n@@ -97,8 +94,9 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         }\n     }\n \n-    pub fn report_as_lint(&self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+    pub fn report_as_lint(\n+        &self,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str,\n         lint_root: hir::HirId,\n         span: Option<Span>,\n@@ -131,7 +129,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n \n     fn struct_generic(\n         &self,\n-        tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxtAt<'gcx, 'tcx>,\n         message: &str,\n         lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n@@ -172,10 +170,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     }\n }\n \n-pub fn struct_error<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'tcx> {\n+pub fn struct_error<'gcx, 'tcx>(tcx: TyCtxtAt<'gcx, 'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n "}, {"sha": "f68385ec26759d67914bc25024e26327df4e2eef", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -64,12 +64,9 @@ enum AllocDiscriminant {\n     Static,\n }\n \n-pub fn specialized_encode_alloc_id<\n-    'a, 'tcx,\n-    E: Encoder,\n->(\n+pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     encoder: &mut E,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n     let alloc: GlobalAlloc<'tcx> =\n@@ -145,13 +142,10 @@ pub struct AllocDecodingSession<'s> {\n }\n \n impl<'s> AllocDecodingSession<'s> {\n-\n     // Decodes an AllocId in a thread-safe way.\n-    pub fn decode_alloc_id<'a, 'tcx, D>(&self,\n-                                        decoder: &mut D)\n-                                        -> Result<AllocId, D::Error>\n-        where D: TyDecoder<'a, 'tcx>,\n-              'tcx: 'a,\n+    pub fn decode_alloc_id<D>(&self, decoder: &mut D) -> Result<AllocId, D::Error>\n+    where\n+        D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation\n         let idx = decoder.read_u32()? as usize;"}, {"sha": "e73023d9a8cc949229f7b110037a87df42bb56a8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -1240,8 +1240,8 @@ impl<'tcx> Terminator<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    pub fn if_<'a, 'gcx>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn if_<'gcx>(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         cond: Operand<'tcx>,\n         t: BasicBlock,\n         f: BasicBlock,\n@@ -2323,8 +2323,8 @@ impl<'tcx> Operand<'tcx> {\n     /// Convenience helper to make a constant that refers to the fn\n     /// with given `DefId` and substs. Since this is used to synthesize\n     /// MIR, assumes `user_ty` is None.\n-    pub fn function_handle<'a>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn function_handle(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         span: Span,\n@@ -3158,7 +3158,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n \n /*\n  * TypeFoldable implementations for MIR types\n- */\n+*/\n \n CloneTypeFoldableAndLiftImpls! {\n     BlockTailInfo,"}, {"sha": "cf1126efc0f86e5d01caa974c14ed9acdc3e5a00", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -48,7 +48,7 @@ pub enum MonoItem<'tcx> {\n }\n \n impl<'tcx> MonoItem<'tcx> {\n-    pub fn size_estimate<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> usize {\n+    pub fn size_estimate(&self, tcx: TyCtxt<'tcx, 'tcx>) -> usize {\n         match *self {\n             MonoItem::Fn(instance) => {\n                 // Estimate the size of a function based on how many statements\n@@ -72,7 +72,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> SymbolName {\n+    pub fn symbol_name(&self, tcx: TyCtxt<'tcx, 'tcx>) -> SymbolName {\n         match *self {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => {\n@@ -87,9 +87,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> InstantiationMode {\n+    pub fn instantiation_mode(&self, tcx: TyCtxt<'tcx, 'tcx>) -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n                 tcx.sess.opts.optimize != OptLevel::No\n@@ -133,7 +131,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n             MonoItem::Static(def_id) => def_id,\n@@ -169,7 +167,7 @@ impl<'tcx> MonoItem<'tcx> {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    pub fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    pub fn is_instantiable(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n@@ -181,7 +179,7 @@ impl<'tcx> MonoItem<'tcx> {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, debug: bool) -> String {\n+    pub fn to_string(&self, tcx: TyCtxt<'tcx, 'tcx>, debug: bool) -> String {\n         return match *self {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance, debug)\n@@ -195,11 +193,12 @@ impl<'tcx> MonoItem<'tcx> {\n             }\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>,\n-                                        debug: bool)\n-                                        -> String {\n+        fn to_string_internal<'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n+            prefix: &str,\n+            instance: Instance<'tcx>,\n+            debug: bool,\n+        ) -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n             let printer = DefPathBasedNames::new(tcx, false, false);\n@@ -208,7 +207,7 @@ impl<'tcx> MonoItem<'tcx> {\n         }\n     }\n \n-    pub fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+    pub fn local_span(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Span> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir().as_local_hir_id(def.def_id())\n@@ -334,7 +333,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n \n-    pub fn estimate_size<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn estimate_size(&mut self, tcx: TyCtxt<'tcx, 'tcx>) {\n         // Estimate the size of a codegen unit as (approximately) the number of MIR\n         // statements it corresponds to.\n         self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n@@ -360,7 +359,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         WorkProductId::from_cgu_name(&self.name().as_str())\n     }\n \n-    pub fn work_product(&self, tcx: TyCtxt<'_, '_, '_>) -> WorkProduct {\n+    pub fn work_product(&self, tcx: TyCtxt<'_, '_>) -> WorkProduct {\n         let work_product_id = self.work_product_id();\n         tcx.dep_graph\n            .previous_work_product(&work_product_id)\n@@ -369,17 +368,16 @@ impl<'tcx> CodegenUnit<'tcx> {\n             })\n     }\n \n-    pub fn items_in_deterministic_order<'a>(&self,\n-                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                        -> Vec<(MonoItem<'tcx>,\n-                                                (Linkage, Visibility))> {\n+    pub fn items_in_deterministic_order(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> Vec<(MonoItem<'tcx>, (Linkage, Visibility))> {\n         // The codegen tests rely on items being process in the same order as\n         // they appear in the file, so for local items, we sort by node_id first\n         #[derive(PartialEq, Eq, PartialOrd, Ord)]\n         pub struct ItemSortKey(Option<HirId>, SymbolName);\n \n-        fn item_sort_key<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   item: MonoItem<'tcx>) -> ItemSortKey {\n+        fn item_sort_key<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item: MonoItem<'tcx>) -> ItemSortKey {\n             ItemSortKey(match item {\n                 MonoItem::Fn(ref instance) => {\n                     match instance.def {\n@@ -415,7 +413,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n         items\n     }\n \n-    pub fn codegen_dep_node(&self, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> DepNode {\n+    pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx, 'tcx>) -> DepNode {\n         DepNode::new(tcx, DepConstructor::CompileCodegenUnit(self.name().clone()))\n     }\n }\n@@ -445,14 +443,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     }\n }\n \n-pub struct CodegenUnitNameBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct CodegenUnitNameBuilder<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     cache: FxHashMap<CrateNum, String>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n-\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+impl CodegenUnitNameBuilder<'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n         CodegenUnitNameBuilder {\n             tcx,\n             cache: Default::default(),"}, {"sha": "76d7d98b90256b9c5e4ffbaef7e04f6d3a66cc03", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,7 +21,7 @@ pub struct PlaceTy<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PlaceTy<'_>, 16);\n \n-impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n+impl<'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n         PlaceTy { ty, variant_index: None }\n     }\n@@ -33,8 +33,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n-    pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n-    {\n+    pub fn field_ty(self, tcx: TyCtxt<'gcx, 'tcx>, f: &Field) -> Ty<'tcx> {\n         let answer = match self.ty.sty {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n@@ -57,10 +56,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Convenience wrapper around `projection_ty_core` for\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n-    pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         elem: &PlaceElem<'tcx>)\n-                         -> PlaceTy<'tcx>\n-    {\n+    pub fn projection_ty(self, tcx: TyCtxt<'gcx, 'tcx>, elem: &PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n         self.projection_ty_core(tcx, elem, |_, _, ty| ty)\n     }\n \n@@ -71,12 +67,13 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// (which should be trivial when `T` = `Ty`).\n     pub fn projection_ty_core<V, T>(\n         self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         elem: &ProjectionElem<V, T>,\n-        mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n-        -> PlaceTy<'tcx>\n+        mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>,\n+    ) -> PlaceTy<'tcx>\n     where\n-        V: ::std::fmt::Debug, T: ::std::fmt::Debug\n+        V: ::std::fmt::Debug,\n+        T: ::std::fmt::Debug,\n     {\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n@@ -121,8 +118,9 @@ BraceStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PlaceTy<'tcx>\n-        where D: HasLocalDecls<'tcx>\n+    pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> PlaceTy<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n     {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n@@ -141,8 +139,9 @@ pub enum RvalueInitializationState {\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n-        where D: HasLocalDecls<'tcx>\n+    pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n@@ -222,8 +221,9 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl<'tcx> Operand<'tcx> {\n-    pub fn ty<'a, 'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n-        where D: HasLocalDecls<'tcx>\n+    pub fn ty<'gcx, D>(&self, local_decls: &D, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>\n+    where\n+        D: HasLocalDecls<'tcx>,\n     {\n         match self {\n             &Operand::Copy(ref l) |\n@@ -234,10 +234,12 @@ impl<'tcx> Operand<'tcx> {\n }\n \n impl<'tcx> BinOp {\n-      pub fn ty<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                          lhs_ty: Ty<'tcx>,\n-                          rhs_ty: Ty<'tcx>)\n-                          -> Ty<'tcx> {\n+    pub fn ty<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_ty: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n         // FIXME: handle SIMD correctly\n         match self {\n             &BinOp::Add | &BinOp::Sub | &BinOp::Mul | &BinOp::Div | &BinOp::Rem |"}, {"sha": "00a162a31fa561c188a191397ec214fbbc82dadf", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -47,12 +47,12 @@ pub struct AutoTraitInfo<'cx> {\n     pub vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n }\n \n-pub struct AutoTraitFinder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct AutoTraitFinder<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl<'tcx> AutoTraitFinder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n         AutoTraitFinder { tcx }\n     }\n \n@@ -232,7 +232,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n+impl AutoTraitFinder<'tcx> {\n     // The core logic responsible for computing the bounds for our synthesized impl.\n     //\n     // To calculate the bounds, we call SelectionContext.select in a loop. Like FulfillmentContext,\n@@ -834,11 +834,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n // Replaces all ReVars in a type with ty::Region's, using the provided map\n pub struct RegionReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "f2c173230765bb9e4b5afe9321d10499382c759f", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,11 +18,10 @@ use crate::ty::fold::TypeFoldable;\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to.\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n-pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n-                                          (param_env, trait_ref):\n-                                          (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>))\n-                                          -> Vtable<'tcx, ()>\n-{\n+pub fn codegen_fulfill_obligation<'tcx>(\n+    ty: TyCtxt<'tcx, 'tcx>,\n+    (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n+) -> Vtable<'tcx, ()> {\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = ty.erase_regions(&trait_ref);\n \n@@ -74,7 +73,7 @@ pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     /// Monomorphizes a type from the AST by first applying the\n     /// in-scope substitutions and then normalizing any associated\n     /// types."}, {"sha": "83f979636416399eba38c4b9511e52a9e0ff6215", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -49,7 +49,7 @@ pub fn add_placeholder_note(err: &mut errors::DiagnosticBuilder<'_>) {\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, invokes `no_overlap`.\n pub fn overlapping_impls<'gcx, F1, F2, R>(\n-    tcx: TyCtxt<'_, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n@@ -183,10 +183,10 @@ fn overlap_within_probe(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                             trait_ref: ty::TraitRef<'tcx>)\n-                                             -> Option<Conflict>\n-{\n+pub fn trait_ref_is_knowable<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) -> Option<Conflict> {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n     if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n@@ -229,9 +229,10 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n }\n \n-pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                         trait_ref: ty::TraitRef<'tcx>)\n-                                                         -> bool {\n+pub fn trait_ref_is_local_or_fundamental<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) -> bool {\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n@@ -246,10 +247,10 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    impl_def_id: DefId)\n-                                    -> Result<(), OrphanCheckErr<'tcx>>\n-{\n+pub fn orphan_check<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    impl_def_id: DefId,\n+) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n \n     // We only except this routine to be invoked on implementations\n@@ -353,11 +354,11 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///\n /// Note that this function is never called for types that have both type\n /// parameters and inference variables.\n-fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt<'_, '_, '_>,\n-                                trait_ref: ty::TraitRef<'tcx>,\n-                                in_crate: InCrate)\n-                                -> Result<(), OrphanCheckErr<'tcx>>\n-{\n+fn orphan_check_trait_ref<'tcx>(\n+    tcx: TyCtxt<'_, '_>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    in_crate: InCrate,\n+) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\",\n            trait_ref, in_crate);\n \n@@ -430,8 +431,7 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt<'_, '_, '_>,\n     }\n }\n \n-fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>, in_crate: InCrate)\n-                       -> Vec<Ty<'tcx>> {\n+fn uncovered_tys<'tcx>(tcx: TyCtxt<'_, '_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(ty) {\n@@ -450,7 +450,7 @@ fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n     }\n }\n \n-fn ty_is_local(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n+fn ty_is_local(tcx: TyCtxt<'_, '_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     ty_is_local_constructor(ty, in_crate) ||\n         fundamental_ty(ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }"}, {"sha": "e43ca8e7e0acf76b809734756d2c01d3a3179e55", "filename": "src/librustc/traits/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -78,7 +78,7 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n }\n \n impl dyn TraitEngine<'tcx> {\n-    pub fn new(tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+    pub fn new(tcx: TyCtxt<'_, 'tcx>) -> Box<Self> {\n         if tcx.sess.opts.debugging_opts.chalk {\n             Box::new(ChalkFulfillmentContext::new())\n         } else {"}, {"sha": "1fb325ae0566989144c31528594f6bc34ec71f8d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -1242,15 +1242,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn report_closure_arg_mismatch(&self,\n-                           span: Span,\n-                           found_span: Option<Span>,\n-                           expected_ref: ty::PolyTraitRef<'tcx>,\n-                           found: ty::PolyTraitRef<'tcx>)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n-        fn build_fn_sig_string<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                               trait_ref: &ty::TraitRef<'tcx>) -> String {\n+    fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        fn build_fn_sig_string<'gcx, 'tcx>(\n+            tcx: TyCtxt<'gcx, 'tcx>,\n+            trait_ref: &ty::TraitRef<'tcx>,\n+        ) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n@@ -1294,7 +1296,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn recursive_type_with_infinite_size_error(self,\n                                                    type_def_id: DefId)\n                                                    -> DiagnosticBuilder<'tcx>\n@@ -1447,17 +1449,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns `true` if the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n-    fn predicate_can_apply(&self,\n-                           param_env: ty::ParamEnv<'tcx>,\n-                           pred: ty::PolyTraitRef<'tcx>)\n-                           -> bool {\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n         impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n+            fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Param(ty::ParamTy {name, .. }) = ty.sty {"}, {"sha": "01be8de172c2670d0c6eadcbb3879e921b79590c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -140,7 +140,7 @@ pub struct ObligationCause<'tcx> {\n }\n \n impl<'tcx> ObligationCause<'tcx> {\n-    pub fn span<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Span {\n+    pub fn span<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Span {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. } |\n             ObligationCauseCode::MainFunctionType |\n@@ -363,9 +363,9 @@ impl<'tcx> DomainGoal<'tcx> {\n }\n \n impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal<'a, 'gcx>(\n+    pub fn from_poly_domain_goal<'gcx>(\n         domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> GoalKind<'tcx> {\n         match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),\n@@ -710,13 +710,13 @@ pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n     }\n }\n \n-fn do_normalize_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     region_context: DefId,\n-                                     cause: ObligationCause<'tcx>,\n-                                     elaborated_env: ty::ParamEnv<'tcx>,\n-                                     predicates: Vec<ty::Predicate<'tcx>>)\n-                                     -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported>\n-{\n+fn do_normalize_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    region_context: DefId,\n+    cause: ObligationCause<'tcx>,\n+    elaborated_env: ty::ParamEnv<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n     debug!(\n         \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n         predicates,\n@@ -795,12 +795,12 @@ fn do_normalize_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              region_context: DefId,\n-                                              unnormalized_env: ty::ParamEnv<'tcx>,\n-                                              cause: ObligationCause<'tcx>)\n-                                              -> ty::ParamEnv<'tcx>\n-{\n+pub fn normalize_param_env_or_error<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    region_context: DefId,\n+    unnormalized_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+) -> ty::ParamEnv<'tcx> {\n     // I'm not wild about reporting errors here; I'd prefer to\n     // have the errors get reported at a defined place (e.g.,\n     // during typeck). Instead I have all parameter\n@@ -936,10 +936,10 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n /// environment. If this returns false, then either normalize\n /// encountered an error or one of the predicates did not hold. Used\n /// when creating vtables to check for unsatisfiable methods.\n-fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           predicates: Vec<ty::Predicate<'tcx>>)\n-                                           -> bool\n-{\n+fn normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> bool {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n@@ -965,10 +965,10 @@ fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n-fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      key: (DefId, SubstsRef<'tcx>))\n-                                                      -> bool\n-{\n+fn substitute_normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    key: (DefId, SubstsRef<'tcx>),\n+) -> bool {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\",\n            key);\n \n@@ -983,11 +983,10 @@ fn substitute_normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n /// Given a trait `trait_ref`, iterates the vtable entries\n /// that come from `trait_ref`, including its supertraits.\n #[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n-fn vtable_methods<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>]\n-{\n+fn vtable_methods<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n     debug!(\"vtable_methods({:?})\", trait_ref);\n \n     tcx.arena.alloc_from_iter(\n@@ -1205,18 +1204,18 @@ where\n     type LiftedDelayedLiteral: Debug + 'tcx;\n     type LiftedLiteral: Debug + 'tcx;\n \n-    fn lift_ex_clause_to_tcx<'a, 'gcx>(\n+    fn lift_ex_clause_to_tcx<'gcx>(\n         ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedExClause>;\n \n-    fn lift_delayed_literal_to_tcx<'a, 'gcx>(\n+    fn lift_delayed_literal_to_tcx<'gcx>(\n         ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedDelayedLiteral>;\n \n-    fn lift_literal_to_tcx<'a, 'gcx>(\n+    fn lift_literal_to_tcx<'gcx>(\n         ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedLiteral>;\n }"}, {"sha": "01b81b182af9627954b03b424e2e8806978f0723", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -83,8 +83,7 @@ pub enum MethodViolationCode {\n     UndispatchableReceiver,\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     /// Returns the object safety violations that affect\n     /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n@@ -703,7 +702,6 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                trait_def_id: DefId) -> bool {\n+pub(super) fn is_object_safe_provider<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId) -> bool {\n     tcx.object_safety_violations(trait_def_id).is_empty()\n }"}, {"sha": "fe190db5fdbee6cda9ebdfe0fc2a227c7513448c", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -35,12 +35,13 @@ impl OnUnimplementedNote {\n     }\n }\n \n-fn parse_error(tcx: TyCtxt<'_, '_, '_>, span: Span,\n-               message: &str,\n-               label: &str,\n-               note: Option<&str>)\n-               -> ErrorReported\n-{\n+fn parse_error(\n+    tcx: TyCtxt<'_, '_>,\n+    span: Span,\n+    message: &str,\n+    label: &str,\n+    note: Option<&str>,\n+) -> ErrorReported {\n     let mut diag = struct_span_err!(\n         tcx.sess, span, E0232, \"{}\", message);\n     diag.span_label(span, label);\n@@ -51,14 +52,14 @@ fn parse_error(tcx: TyCtxt<'_, '_, '_>, span: Span,\n     ErrorReported\n }\n \n-impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n-    fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                 trait_def_id: DefId,\n-                 items: &[NestedMetaItem],\n-                 span: Span,\n-                 is_root: bool)\n-                 -> Result<Self, ErrorReported>\n-    {\n+impl<'gcx, 'tcx> OnUnimplementedDirective {\n+    fn parse(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        items: &[NestedMetaItem],\n+        span: Span,\n+        is_root: bool,\n+    ) -> Result<Self, ErrorReported> {\n         let mut errored = false;\n         let mut item_iter = items.iter();\n \n@@ -132,12 +133,11 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         }\n     }\n \n-\n-    pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                   trait_def_id: DefId,\n-                   impl_def_id: DefId)\n-                   -> Result<Option<Self>, ErrorReported>\n-    {\n+    pub fn of_item(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        impl_def_id: DefId,\n+    ) -> Result<Option<Self>, ErrorReported> {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n         let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n@@ -164,12 +164,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         result\n     }\n \n-    pub fn evaluate(&self,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    trait_ref: ty::TraitRef<'tcx>,\n-                    options: &[(Symbol, Option<String>)])\n-                    -> OnUnimplementedNote\n-    {\n+    pub fn evaluate(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &[(Symbol, Option<String>)],\n+    ) -> OnUnimplementedNote {\n         let mut message = None;\n         let mut label = None;\n         let mut note = None;\n@@ -214,21 +214,21 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n-    fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     trait_def_id: DefId,\n-                     from: LocalInternedString,\n-                     err_sp: Span)\n-                     -> Result<Self, ErrorReported>\n-    {\n+impl<'gcx, 'tcx> OnUnimplementedFormatString {\n+    fn try_parse(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        from: LocalInternedString,\n+        err_sp: Span,\n+    ) -> Result<Self, ErrorReported> {\n         let result = OnUnimplementedFormatString(from);\n         result.verify(tcx, trait_def_id, err_sp)?;\n         Ok(result)\n     }\n \n     fn verify(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         trait_def_id: DefId,\n         span: Span,\n     ) -> Result<(), ErrorReported> {\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n \n     pub fn format(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n         options: &FxHashMap<Symbol, String>,\n     ) -> String {"}, {"sha": "e997e4d9c31838f7bc3b6fc58fdfa2b4452e13f9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n }\n \n impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'gcx, 'tcx> {\n         self.selcx.tcx()\n     }\n \n@@ -836,7 +836,7 @@ struct Progress<'tcx> {\n }\n \n impl<'tcx> Progress<'tcx> {\n-    fn error<'a,'gcx>(tcx: TyCtxt<'a,'gcx,'tcx>) -> Self {\n+    fn error<'gcx>(tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n         Progress {\n             ty: tcx.types.err,\n             obligations: vec![],"}, {"sha": "90df5ed10d78f1657ba7062629ca4191eaa944f1", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -85,12 +85,7 @@ pub struct DropckOutlivesResult<'tcx> {\n }\n \n impl<'tcx> DropckOutlivesResult<'tcx> {\n-    pub fn report_overflows(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-    ) {\n+    pub fn report_overflows(&self, tcx: TyCtxt<'_, 'tcx>, span: Span, ty: Ty<'tcx>) {\n         if let Some(overflow_ty) = self.overflows.iter().next() {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n@@ -106,7 +101,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n \n     pub fn into_kinds_reporting_overflows(\n         self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> Vec<Kind<'tcx>> {\n@@ -190,7 +185,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n-pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's"}, {"sha": "86067a7c1d801be90dcea730ba0d5f9f1c194716", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -83,7 +83,7 @@ struct QueryNormalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "8b820e22cac0ba44302dca4459b1eccfe89d209c", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -10,7 +10,7 @@\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n \n-impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     /// Erase the regions in `value` and then fully normalize all the\n     /// types found within. The result will also have regions erased.\n     ///\n@@ -62,13 +62,13 @@ impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     }\n }\n \n-struct NormalizeAfterErasingRegionsFolder<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+struct NormalizeAfterErasingRegionsFolder<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'cx, 'tcx> TypeFolder<'tcx, 'tcx> for NormalizeAfterErasingRegionsFolder<'cx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl TypeFolder<'tcx, 'tcx> for NormalizeAfterErasingRegionsFolder<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "c663a65659c55b83c8f29a1f92ef50b7b97be194", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,14 +25,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for AscribeUserType<'tcx>\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _tcx: TyCtxt<'gcx, 'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_ascribe_user_type(canonicalized)"}, {"sha": "c431178bb2a29f5e9417d0b626fbebc8551dd9ec", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,7 +18,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _tcx: TyCtxt<'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Eq<'tcx>>,\n     ) -> Option<Self::QueryResponse> {\n         if key.value.a == key.value.b {\n@@ -29,7 +29,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_eq(canonicalized)"}, {"sha": "762e09b03acad3b873a351c90c66e65a1784ff5f", "filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,14 +18,14 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ImpliedOutlivesBounds<\n     type QueryResponse = Vec<OutlivesBound<'tcx>>;\n \n     fn try_fast_path(\n-        _tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        _tcx: TyCtxt<'gcx, 'tcx>,\n         _key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         None\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         // FIXME this `unchecked_map` is only necessary because the"}, {"sha": "1553d17e684fadceebac0d61f23a7df2eb33847c", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -53,7 +53,7 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     /// actually hits the tcx cache lookup etc. Return `Some(r)` with\n     /// a final result or `None` to do the full path.\n     fn try_fast_path(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse>;\n \n@@ -64,7 +64,7 @@ pub trait QueryTypeOp<'gcx: 'tcx, 'tcx>:\n     /// bad, because it would create subregion relationships that are\n     /// not captured in the return value.\n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>>;\n "}, {"sha": "52a0c6042baf56211705fa47c5f2b81f9d15e6f1", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -24,7 +24,7 @@ where\n {\n     type QueryResponse = T;\n \n-    fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n+    fn try_fast_path(_tcx: TyCtxt<'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<T> {\n         if !key.value.value.has_projections() {\n             Some(key.value.value)\n         } else {\n@@ -33,7 +33,7 @@ where\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         T::type_op_method(tcx, canonicalized)\n@@ -48,7 +48,7 @@ where\n \n pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx> + Copy {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>>;\n \n@@ -64,7 +64,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_ty(canonicalized)\n@@ -82,7 +82,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_predicate(canonicalized)\n@@ -100,7 +100,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n@@ -118,7 +118,7 @@ where\n     'gcx: 'tcx,\n {\n     fn type_op_method(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>> {\n         tcx.type_op_normalize_fn_sig(canonicalized)"}, {"sha": "56a051e08e7165c68d721a5cd4693867e75ffd37", "filename": "src/librustc/traits/query/type_op/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,7 +22,7 @@ where\n     type QueryResponse = DropckOutlivesResult<'tcx>;\n \n     fn try_fast_path(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         if trivial_dropck_outlives(tcx, key.value.dropped_ty) {\n@@ -33,7 +33,7 @@ where\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self::QueryResponse>> {\n         // Subtle: note that we are not invoking"}, {"sha": "64fcc73187cf0324d8813707e57658b6702aa927", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -17,7 +17,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     type QueryResponse = ();\n \n     fn try_fast_path(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         key: &ParamEnvAnd<'tcx, Self>,\n     ) -> Option<Self::QueryResponse> {\n         // Proving Sized, very often on \"obviously sized\" types like\n@@ -38,7 +38,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for ProvePredicate<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_prove_predicate(canonicalized)"}, {"sha": "a2f47211f48288914792fe3678d7b374c022ddeb", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -20,7 +20,7 @@ impl<'tcx> Subtype<'tcx> {\n impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     type QueryResponse = ();\n \n-    fn try_fast_path(_tcx: TyCtxt<'_, 'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n+    fn try_fast_path(_tcx: TyCtxt<'gcx, 'tcx>, key: &ParamEnvAnd<'tcx, Self>) -> Option<()> {\n         if key.value.sub == key.value.sup {\n             Some(())\n         } else {\n@@ -29,7 +29,7 @@ impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Subtype<'tcx> {\n     }\n \n     fn perform_query(\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Self>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, ()>> {\n         tcx.type_op_subtype(canonicalized)"}, {"sha": "57a361d469effc04f54f2ac4e325328492725b43", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -300,7 +300,7 @@ enum SelectionCandidate<'tcx> {\n \n impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n     type Lifted = SelectionCandidate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         Some(match *self {\n             BuiltinCandidate { has_nested } => BuiltinCandidate { has_nested },\n             ImplCandidate(def_id) => ImplCandidate(def_id),\n@@ -568,7 +568,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -3989,7 +3989,7 @@ impl<T: Clone> WithDepNode<T> {\n         }\n     }\n \n-    pub fn get(&self, tcx: TyCtxt<'_, '_, '_>) -> T {\n+    pub fn get(&self, tcx: TyCtxt<'_, '_>) -> T {\n         tcx.dep_graph.read_index(self.dep_node);\n         self.cached_value.clone()\n     }"}, {"sha": "27891bed2b76ed5421c4b9e209f56080948e1ffb", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -109,8 +109,8 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// the kind `kind`, and trait method substitutions `substs`, in\n /// that impl, a less specialized impl, or the trait default,\n /// whichever applies.\n-pub fn find_associated_item<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn find_associated_item<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     item: &ty::AssocItem,\n     substs: SubstsRef<'tcx>,\n@@ -149,10 +149,10 @@ pub fn find_associated_item<'a, 'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n-pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    (impl1_def_id, impl2_def_id): (DefId, DefId))\n-    -> bool\n-{\n+pub(super) fn specializes<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    (impl1_def_id, impl2_def_id): (DefId, DefId),\n+) -> bool {\n     debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n \n     // The feature gate should prevent introducing new specializations, but not\n@@ -285,8 +285,8 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n // Query provider for `specialization_graph_of`.\n-pub(super) fn specialization_graph_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(super) fn specialization_graph_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     trait_id: DefId,\n ) -> &'tcx specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n@@ -390,7 +390,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(\n \n /// Recovers the \"impl X for Y\" signature from `impl_def_id` and returns it as a\n /// string.\n-fn to_pretty_impl_header(tcx: TyCtxt<'_, '_, '_>, impl_def_id: DefId) -> Option<String> {\n+fn to_pretty_impl_header(tcx: TyCtxt<'_, '_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n     let trait_ref = if let Some(tr) = tcx.impl_trait_ref(impl_def_id) {"}, {"sha": "2e86d40a3ad54c1ca4c7adbe98e8c1126f6efb7c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -81,11 +81,9 @@ enum Inserted {\n     ShouldRecurseOn(DefId),\n }\n \n-impl<'a, 'gcx, 'tcx> Children {\n+impl<'gcx, 'tcx> Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n-    fn insert_blindly(&mut self,\n-                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      impl_def_id: DefId) {\n+    fn insert_blindly(&mut self, tcx: TyCtxt<'gcx, 'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n             debug!(\"insert_blindly: impl_def_id={:?} sty={:?}\", impl_def_id, sty);\n@@ -99,9 +97,7 @@ impl<'a, 'gcx, 'tcx> Children {\n     /// Removes an impl from this set of children. Used when replacing\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n-    fn remove_existing(&mut self,\n-                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      impl_def_id: DefId) {\n+    fn remove_existing(&mut self, tcx: TyCtxt<'gcx, 'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let vec: &mut Vec<DefId>;\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n@@ -118,12 +114,12 @@ impl<'a, 'gcx, 'tcx> Children {\n \n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialization relationships.\n-    fn insert(&mut self,\n-              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              impl_def_id: DefId,\n-              simplified_self: Option<SimplifiedType>)\n-              -> Result<Inserted, OverlapError>\n-    {\n+    fn insert(\n+        &mut self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        impl_def_id: DefId,\n+        simplified_self: Option<SimplifiedType>,\n+    ) -> Result<Inserted, OverlapError> {\n         let mut last_lint = None;\n         let mut replace_children = Vec::new();\n \n@@ -282,7 +278,7 @@ impl<I, J> Iterator for PotentialSiblings<I, J>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Graph {\n+impl<'gcx, 'tcx> Graph {\n     pub fn new() -> Graph {\n         Graph {\n             parent: Default::default(),\n@@ -293,10 +289,11 @@ impl<'a, 'gcx, 'tcx> Graph {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n-    pub fn insert(&mut self,\n-                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                  impl_def_id: DefId)\n-                  -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n+    pub fn insert(\n+        &mut self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        impl_def_id: DefId,\n+    ) -> Result<Option<FutureCompatOverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -386,10 +383,12 @@ impl<'a, 'gcx, 'tcx> Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   parent: DefId,\n-                                   child: DefId) {\n+    pub fn record_impl_from_cstore(\n+        &mut self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        parent: DefId,\n+        child: DefId,\n+    ) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n@@ -414,7 +413,7 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl<'a, 'gcx, 'tcx> Node {\n+impl<'gcx, 'tcx> Node {\n     pub fn is_from_trait(&self) -> bool {\n         match *self {\n             Node::Trait(..) => true,\n@@ -423,10 +422,7 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(\n-        &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> ty::AssocItemsIterator<'a, 'gcx, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'gcx, 'tcx>) -> ty::AssocItemsIterator<'gcx, 'tcx> {\n         tcx.associated_items(self.def_id())\n     }\n \n@@ -475,18 +471,18 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'gcx> {\n+impl<'gcx, 'tcx> Ancestors<'gcx> {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n     #[inline]\n     pub fn defs(\n         self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         trait_item_name: Ident,\n         trait_item_kind: ty::AssocKind,\n         trait_def_id: DefId,\n-    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n+    ) -> impl Iterator<Item = NodeItem<ty::AssocItem>> + Captures<'gcx> + 'tcx {\n         self.flat_map(move |node| {\n             use crate::ty::AssocKind::*;\n             node.items(tcx).filter(move |impl_item| match (trait_item_kind, impl_item.kind) {\n@@ -508,10 +504,11 @@ impl<'a, 'gcx, 'tcx> Ancestors<'gcx> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors(tcx: TyCtxt<'_, 'tcx, '_>,\n-                 trait_def_id: DefId,\n-                 start_from_impl: DefId)\n-                 -> Ancestors<'tcx> {\n+pub fn ancestors(\n+    tcx: TyCtxt<'tcx, '_>,\n+    trait_def_id: DefId,\n+    start_from_impl: DefId,\n+) -> Ancestors<'tcx> {\n     let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n     Ancestors {\n         trait_def_id,"}, {"sha": "e919f0ed2b4d6ec8a9f53cb9a4f76048920276a6", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -446,7 +446,7 @@ impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n     type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             super::Unimplemented => Some(super::Unimplemented),\n             super::OutputTypeParameterMismatch(a, b, ref err) => {\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n     type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             super::ReturnNoExpression => Some(super::ReturnNoExpression),\n             super::MiscObligation => Some(super::MiscObligation),\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.parent_trait_ref).and_then(|trait_ref|\n             tcx.lift(&*self.parent_code)\n                .map(|code| traits::DerivedObligationCause {\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.code).map(|code| traits::ObligationCause {\n             span: self.span,\n             body_id: self.body_id,\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n // For codegen only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.clone() {\n             traits::VtableImpl(traits::VtableImplData {\n                 impl_def_id,\n@@ -691,7 +691,7 @@ EnumLiftImpl! {\n \n impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n     type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.clauses).map(|clauses| {\n             traits::Environment {\n                 clauses,\n@@ -702,7 +702,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n \n impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n     type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.environment).and_then(|environment| {\n             tcx.lift(&self.goal).map(|goal| {\n                 traits::InEnvironment {\n@@ -721,7 +721,7 @@ where\n {\n     type Lifted = C::LiftedExClause;\n \n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n     }\n }\n@@ -733,7 +733,7 @@ where\n {\n     type Lifted = C::LiftedDelayedLiteral;\n \n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n     }\n }\n@@ -745,7 +745,7 @@ where\n {\n     type Lifted = C::LiftedLiteral;\n \n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n     }\n }"}, {"sha": "c5ff174e944367c5f3e944c9867b12361ee7527b", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -12,9 +12,10 @@ use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       pred: &ty::Predicate<'tcx>)\n-                                       -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    pred: &ty::Predicate<'tcx>,\n+) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -45,13 +46,13 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n }\n \n-struct PredicateSet<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct PredicateSet<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n }\n \n-impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+impl PredicateSet<'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n         Self { tcx: tcx, set: Default::default() }\n     }\n \n@@ -70,7 +71,7 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'a, 'gcx, 'tcx> {\n+impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'gcx, 'tcx> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         for pred in iter {\n             self.insert(pred.as_ref());\n@@ -88,39 +89,36 @@ impl<'a, 'gcx, 'tcx, T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'\n /// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n /// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n /// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+pub struct Elaborator<'gcx, 'tcx> {\n     stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'a, 'gcx, 'tcx>,\n+    visited: PredicateSet<'gcx, 'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Elaborator<'cx, 'gcx, 'tcx>\n-{\n+pub fn elaborate_trait_ref<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'gcx, 'tcx> {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n-pub fn elaborate_trait_refs<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-    -> Elaborator<'cx, 'gcx, 'tcx>\n-{\n+pub fn elaborate_trait_refs<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'gcx, 'tcx> {\n     let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate()).collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n-pub fn elaborate_predicates<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    mut predicates: Vec<ty::Predicate<'tcx>>)\n-    -> Elaborator<'cx, 'gcx, 'tcx>\n-{\n+pub fn elaborate_predicates<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    mut predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Elaborator<'gcx, 'tcx> {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n     Elaborator { stack: predicates, visited }\n }\n \n-impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n+impl Elaborator<'gcx, 'tcx> {\n     pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n@@ -232,7 +230,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n+impl Iterator for Elaborator<'gcx, 'tcx> {\n     type Item = ty::Predicate<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -254,17 +252,19 @@ impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'cx, 'gcx, 'tcx> = FilterToTraits<Elaborator<'cx, 'gcx, 'tcx>>;\n+pub type Supertraits<'gcx, 'tcx> = FilterToTraits<Elaborator<'gcx, 'tcx>>;\n \n-pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Supertraits<'cx, 'gcx, 'tcx> {\n+pub fn supertraits<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Supertraits<'gcx, 'tcx> {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-                                          bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-                                          -> Supertraits<'cx, 'gcx, 'tcx> {\n+pub fn transitive_bounds<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Supertraits<'gcx, 'tcx> {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n@@ -280,8 +280,8 @@ pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n /// `Read + Write + Sync + Send`.\n /// Expansion is done via a DFS (depth-first search), and the `visited` field\n /// is used to avoid cycles.\n-pub struct TraitAliasExpander<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct TraitAliasExpander<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n }\n \n@@ -337,18 +337,18 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n     }\n }\n \n-pub fn expand_trait_aliases<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>\n-) -> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+pub fn expand_trait_aliases<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n+) -> TraitAliasExpander<'gcx, 'tcx> {\n     let items: Vec<_> = trait_refs\n         .into_iter()\n         .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n         .collect();\n     TraitAliasExpander { tcx, stack: items }\n }\n \n-impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TraitAliasExpander<'gcx, 'tcx> {\n     /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n     /// to the definition, pushes the resulting expansion onto `self.stack`, and returns `false`.\n     /// Otherwise, immediately returns `true` if `item` is a regular trait, or `false` if it is a\n@@ -393,7 +393,7 @@ impl<'cx, 'gcx, 'tcx> TraitAliasExpander<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for TraitAliasExpander<'cx, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> Iterator for TraitAliasExpander<'gcx, 'tcx> {\n     type Item = TraitAliasExpansionInfo<'tcx>;\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -414,24 +414,24 @@ impl<'cx, 'gcx, 'tcx> Iterator for TraitAliasExpander<'cx, 'gcx, 'tcx> {\n // Iterator over def-IDs of supertraits\n ///////////////////////////////////////////////////////////////////////////\n \n-pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct SupertraitDefIds<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     stack: Vec<DefId>,\n     visited: FxHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-                                           trait_def_id: DefId)\n-                                           -> SupertraitDefIds<'cx, 'gcx, 'tcx>\n-{\n+pub fn supertrait_def_ids<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    trait_def_id: DefId,\n+) -> SupertraitDefIds<'gcx, 'tcx> {\n     SupertraitDefIds {\n         tcx,\n         stack: vec![trait_def_id],\n         visited: Some(trait_def_id).into_iter().collect(),\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n+impl Iterator for SupertraitDefIds<'gcx, 'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n@@ -552,7 +552,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn predicate_for_trait_def(self,\n                                    param_env: ty::ParamEnv<'tcx>,\n                                    cause: ObligationCause<'tcx>,"}, {"sha": "213f556f9acac168244fa3d2c6b40ddcb23a59e0", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -19,19 +19,19 @@ use crate::mir::interpret::ConstValue;\n /// Like subtyping, matching is really a binary relation, so the only\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n-pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+pub struct Match<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n+impl Match<'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'gcx, 'tcx>) -> Match<'gcx, 'tcx> {\n         Match { tcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n+impl TypeRelation<'gcx, 'tcx> for Match<'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,"}, {"sha": "e1f86bee4babb4ce7192d7c8d8c6cdd35e085ca4", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -103,9 +103,12 @@ pub struct OverloadedDeref<'tcx> {\n     pub mutbl: hir::Mutability,\n }\n \n-impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n-    pub fn method_call(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, source: Ty<'tcx>)\n-                       -> (DefId, SubstsRef<'tcx>) {\n+impl<'gcx, 'tcx> OverloadedDeref<'tcx> {\n+    pub fn method_call(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        source: Ty<'tcx>,\n+    ) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n             hir::MutImmutable => tcx.lang_items().deref_trait(),\n             hir::MutMutable => tcx.lang_items().deref_mut_trait()"}, {"sha": "ea5d088d540fda50b3b8056fc56fb94cb1f9aa58", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -107,9 +107,8 @@ pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n     Ok(())\n }\n \n-pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n-\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+pub trait TyDecoder<'tcx>: Decoder {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n \n     fn peek_byte(&self) -> u8;\n \n@@ -132,38 +131,38 @@ pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n }\n \n #[inline]\n-pub fn decode_arena_allocable<'a, 'tcx, D, T: ArenaAllocatable + Decodable>(\n-    decoder: &mut D\n+pub fn decode_arena_allocable<D, T: ArenaAllocatable + Decodable>(\n+    decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().arena.alloc(Decodable::decode(decoder)?))\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<'a, 'tcx, D, T: ArenaAllocatable + Decodable>(\n-    decoder: &mut D\n+pub fn decode_arena_allocable_slice<D, T: ArenaAllocatable + Decodable>(\n+    decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable>::decode(decoder)?))\n }\n \n #[inline]\n-pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_cnum<D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n     Ok(decoder.map_encoded_cnum_to_current(cnum))\n }\n \n #[inline]\n-pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     // Handle shorthands first, if we have an usize > 0x80.\n     if decoder.positioned_at_shorthand() {\n@@ -181,10 +180,9 @@ pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n }\n \n #[inline]\n-pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n-                                      -> Result<ty::GenericPredicates<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_predicates<D>(decoder: &mut D) -> Result<ty::GenericPredicates<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(ty::GenericPredicates {\n         parent: Decodable::decode(decoder)?,\n@@ -206,59 +204,57 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n }\n \n #[inline]\n-pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_substs<D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     let tcx = decoder.tcx();\n     Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n #[inline]\n-pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_region<D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n }\n \n #[inline]\n-pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n-                                    -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_ty_slice<D>(decoder: &mut D) -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n #[inline]\n-pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n-                                   -> Result<&'tcx ty::AdtDef, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_adt_def<D>(decoder: &mut D) -> Result<&'tcx ty::AdtDef, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let def_id = DefId::decode(decoder)?;\n     Ok(decoder.tcx().adt_def(def_id))\n }\n \n #[inline]\n-pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n-    -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_existential_predicate_slice<D>(\n+    decoder: &mut D,\n+) -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     Ok(decoder.tcx()\n               .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n #[inline]\n-pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n-    -> Result<CanonicalVarInfos<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_canonical_var_infos<D>(decoder: &mut D) -> Result<CanonicalVarInfos<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     let len = decoder.read_usize()?;\n     let interned: Result<Vec<CanonicalVarInfo>, _> = (0..len).map(|_| Decodable::decode(decoder))\n@@ -268,19 +264,17 @@ pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n }\n \n #[inline]\n-pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n-                                 -> Result<&'tcx ty::Const<'tcx>, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_const<D>(decoder: &mut D) -> Result<&'tcx ty::Const<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n }\n \n #[inline]\n-pub fn decode_allocation<'a, 'tcx, D>(decoder: &mut D)\n-    -> Result<&'tcx Allocation, D::Error>\n-    where D: TyDecoder<'a, 'tcx>,\n-          'tcx: 'a,\n+pub fn decode_allocation<D>(decoder: &mut D) -> Result<&'tcx Allocation, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n {\n     Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n }"}, {"sha": "466cb353c85e4a7981a1f1576b6af6beda9754a2", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,7 +6,7 @@ use syntax_pos::symbol::{sym, Symbol};\n use crate::hir::map::blocks::FnLikeNode;\n use syntax::attr;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n     /// feature gates\n     pub fn is_const_fn(self, def_id: DefId) -> bool {\n@@ -69,7 +69,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n     /// only checks whether the function has a `const` modifier\n-    fn is_const_fn_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn is_const_fn_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n         let hir_id = tcx.hir().as_local_hir_id(def_id)\n                               .expect(\"Non-local call to local provider is_const_fn\");\n \n@@ -83,7 +83,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn is_promotable_const_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn is_promotable_const_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) && match tcx.lookup_stability(def_id) {\n             Some(stab) => {\n                 if cfg!(debug_assertions) && stab.promotable {\n@@ -101,7 +101,7 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n-    fn const_fn_is_allowed_fn_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+    fn const_fn_is_allowed_fn_ptr<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n         tcx.is_const_fn(def_id) &&\n             tcx.lookup_stability(def_id)\n                 .map(|stab| stab.allow_const_fn_ptr).unwrap_or(false)"}, {"sha": "4e255edfe85637164a1c1d80c56cc60fd6e43999", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -1016,13 +1016,13 @@ pub struct FreeRegionInfo {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n-pub struct TyCtxt<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+pub struct TyCtxt<'gcx: 'tcx, 'tcx> {\n     gcx: &'gcx GlobalCtxt<'gcx>,\n     interners: &'gcx CtxtInterners<'gcx>,\n-    dummy: PhantomData<(&'a (), &'tcx ())>,\n+    dummy: PhantomData<&'tcx ()>,\n }\n \n-impl<'gcx> Deref for TyCtxt<'_, 'gcx, '_> {\n+impl<'gcx> Deref for TyCtxt<'gcx, '_> {\n     type Target = &'gcx GlobalCtxt<'gcx>;\n     #[inline(always)]\n     fn deref(&self) -> &Self::Target {\n@@ -1119,10 +1119,10 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Gets the global `TyCtxt`.\n     #[inline]\n-    pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n+    pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx> {\n         TyCtxt {\n             gcx: self.gcx,\n             interners: &self.gcx.global_interners,\n@@ -1131,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn hir(self) -> &'a hir_map::Map<'gcx> {\n+    pub fn hir(self) -> &'tcx hir_map::Map<'gcx> {\n         &self.hir_map\n     }\n \n@@ -1469,7 +1469,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n+    pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n         let krate = self.gcx.hir_map.forest.untracked_krate();\n \n         StableHashingContext::new(self.sess,\n@@ -1666,7 +1666,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     pub fn encode_metadata(self)\n         -> EncodedMetadata\n     {\n@@ -1678,12 +1678,9 @@ impl<'gcx> GlobalCtxt<'gcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n     /// `interners` is a slot passed so we can create a CtxtInterners\n     /// with the same lifetime as `arena`.\n-    pub fn enter_local<'tcx, F, R>(\n-        &'gcx self,\n-        f: F\n-    ) -> R\n+    pub fn enter_local<'tcx, F, R>(&'gcx self, f: F) -> R\n     where\n-        F: FnOnce(TyCtxt<'tcx, 'gcx, 'tcx>) -> R,\n+        F: FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n         'gcx: 'tcx,\n     {\n         let tcx = TyCtxt {\n@@ -1725,48 +1722,48 @@ impl<'gcx> GlobalCtxt<'gcx> {\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n \n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n-            type Lifted = $lifted;\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n-                    return Some(unsafe { mem::transmute(*self) });\n-                }\n-                // Also try in the global tcx if we're not that.\n-                if !tcx.is_global() {\n-                    self.lift_to_tcx(tcx.global_tcx())\n-                } else {\n-                    None\n+                    type Lifted = $lifted;\n+                    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                        if tcx.interners.arena.in_arena(*self as *const _) {\n+                            return Some(unsafe { mem::transmute(*self) });\n+                        }\n+                        // Also try in the global tcx if we're not that.\n+                        if !tcx.is_global() {\n+                            self.lift_to_tcx(tcx.global_tcx())\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n-            }\n-        }\n     };\n }\n \n macro_rules! nop_list_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n-            type Lifted = &'tcx List<$lifted>;\n-            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-                if self.is_empty() {\n-                    return Some(List::empty());\n-                }\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n-                    return Some(unsafe { mem::transmute(*self) });\n-                }\n-                // Also try in the global tcx if we're not that.\n-                if !tcx.is_global() {\n-                    self.lift_to_tcx(tcx.global_tcx())\n-                } else {\n-                    None\n+                    type Lifted = &'tcx List<$lifted>;\n+                    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                        if self.is_empty() {\n+                            return Some(List::empty());\n+                        }\n+                        if tcx.interners.arena.in_arena(*self as *const _) {\n+                            return Some(unsafe { mem::transmute(*self) });\n+                        }\n+                        // Also try in the global tcx if we're not that.\n+                        if !tcx.is_global() {\n+                            self.lift_to_tcx(tcx.global_tcx())\n+                        } else {\n+                            None\n+                        }\n+                    }\n                 }\n-            }\n-        }\n     };\n }\n \n@@ -1815,7 +1812,7 @@ pub mod tls {\n     pub struct ImplicitCtxt<'a, 'gcx: 'tcx, 'tcx> {\n         /// The current TyCtxt. Initially created by `enter_global` and updated\n         /// by `enter_local` with a new local interner\n-        pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n+        pub tcx: TyCtxt<'gcx, 'tcx>,\n \n         /// The current query job, if any. This is updated by JobOwner::start in\n         /// ty::query::plumbing when executing a query\n@@ -1941,7 +1938,8 @@ pub mod tls {\n     /// This happens once per rustc session and TyCtxts only exists\n     /// inside the `f` function.\n     pub fn enter_global<'gcx, F, R>(gcx: &'gcx GlobalCtxt<'gcx>, f: F) -> R\n-        where F: FnOnce(TyCtxt<'gcx, 'gcx, 'gcx>) -> R\n+    where\n+        F: FnOnce(TyCtxt<'gcx, 'gcx>) -> R,\n     {\n         // Update GCX_PTR to indicate there's a GlobalCtxt available\n         GCX_PTR.with(|lock| {\n@@ -1978,7 +1976,8 @@ pub mod tls {\n     /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n     {\n         let gcx = GCX_PTR.with(|lock| *lock.lock());\n         assert!(gcx != 0);\n@@ -2030,8 +2029,9 @@ pub mod tls {\n     /// This will panic if you pass it a TyCtxt which has a different global interner from\n     /// the current ImplicitCtxt's tcx field.\n     #[inline]\n-    pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n-        where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n+    pub fn with_related_context<'gcx, 'tcx1, F, R>(tcx: TyCtxt<'gcx, 'tcx1>, f: F) -> R\n+    where\n+        F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R,\n     {\n         with_context(|context| {\n             unsafe {\n@@ -2048,8 +2048,9 @@ pub mod tls {\n     /// This will panic if you pass it a TyCtxt which has a different global interner or\n     /// a different local interner from the current ImplicitCtxt's tcx field.\n     #[inline]\n-    pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n-        where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n+    pub fn with_fully_related_context<'gcx, 'tcx, F, R>(tcx: TyCtxt<'gcx, 'tcx>, f: F) -> R\n+    where\n+        F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R,\n     {\n         with_context(|context| {\n             unsafe {\n@@ -2065,7 +2066,8 @@ pub mod tls {\n     /// Panics if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'gcx, 'tcx> FnOnce(TyCtxt<'gcx, 'tcx>) -> R,\n     {\n         with_context(|context| f(context.tcx))\n     }\n@@ -2074,7 +2076,8 @@ pub mod tls {\n     /// The closure is passed None if there is no ImplicitCtxt available\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n+    where\n+        F: for<'gcx, 'tcx> FnOnce(Option<TyCtxt<'gcx, 'tcx>>) -> R,\n     {\n         with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n     }\n@@ -2098,7 +2101,7 @@ macro_rules! sty_debug_print {\n                 all_infer: usize,\n             }\n \n-            pub fn go(tcx: TyCtxt<'_, '_, '_>) {\n+            pub fn go(tcx: TyCtxt<'_, '_>) {\n                 let mut total = DebugStat {\n                     total: 0,\n                     lt_infer: 0,\n@@ -2151,7 +2154,7 @@ macro_rules! sty_debug_print {\n     }}\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n@@ -2290,7 +2293,7 @@ macro_rules! intern_method {\n                                             $alloc_method:expr,\n                                             $alloc_to_key:expr,\n                                             $keep_in_local_tcx:expr) -> $ty:ty) => {\n-        impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n+        impl<'gcx, $lt_tcx> TyCtxt<'gcx, $lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n                 let key = ($alloc_to_key)(&v);\n \n@@ -2400,7 +2403,7 @@ intern_method! {\n     ) -> List<CanonicalVarInfo>\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n     /// that is, a `fn` type that is equivalent in every way for being\n     /// unsafe."}, {"sha": "330343c250c66f328c0ad5a9c90943b72d5b60c8", "filename": "src/librustc/ty/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferase_regions.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -8,13 +8,13 @@ pub(super) fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n }\n \n-fn erase_regions_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+fn erase_regions_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     // N.B., use `super_fold_with` here. If we used `fold_with`, it\n     // could invoke the `erase_regions_ty` query recursively.\n     ty.super_fold_with(&mut RegionEraserVisitor { tcx })\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n@@ -32,12 +32,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct RegionEraserVisitor<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct RegionEraserVisitor<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n+impl TypeFolder<'gcx, 'tcx> for RegionEraserVisitor<'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "000e0854f4e974b22c06084edb1966e98d6a76d1", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -183,8 +183,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> Cow<'static, str> {\n+impl<'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n+    pub fn sort_string(&self, tcx: TyCtxt<'gcx, 'lcx>) -> Cow<'static, str> {\n         match self.sty {\n             ty::Bool | ty::Char | ty::Int(_) |\n             ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => self.to_string().into(),\n@@ -249,7 +249,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder<'_>,\n                                      err: &TypeError<'tcx>,"}, {"sha": "d32ad0f5c6d5053fce055a3f53a06233d26f4043", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -55,11 +55,11 @@ pub enum SimplifiedTypeGen<D>\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                     ty: Ty<'_>,\n-                                     can_simplify_params: bool)\n-                                     -> Option<SimplifiedType>\n-{\n+pub fn simplify_type<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    ty: Ty<'_>,\n+    can_simplify_params: bool,\n+) -> Option<SimplifiedType> {\n     match ty.sty {\n         ty::Bool => Some(BoolSimplifiedType),\n         ty::Char => Some(CharSimplifiedType),"}, {"sha": "c79dad04df6244148e74dabb2e5f97ad50e873e8", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -155,8 +155,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+pub trait TypeFolder<'gcx: 'tcx, 'tcx>: Sized {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -198,23 +198,27 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G, H>\n-    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n-          G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n+pub struct BottomUpFolder<'gcx, 'tcx, F, G, H>\n+where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+    G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n+    H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'gcx, 'tcx>,\n     pub ty_op: F,\n     pub lt_op: G,\n     pub ct_op: H,\n }\n \n-impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F, G, H>\n-    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n-          G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n+impl<'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'gcx, 'tcx, F, G, H>\n+where\n+    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+    G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n+    H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t = ty.super_fold_with(self);\n@@ -235,7 +239,7 @@ impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n@@ -361,8 +365,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n \n-pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct RegionFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n \n     /// Stores the index of a binder *just outside* the stuff we have\n@@ -373,16 +377,14 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// Callback invokes for each free region. The `DebruijnIndex`\n     /// points to the binder *just outside* the ones we have passed\n     /// through.\n-    fold_region_fn: &'a mut (dyn FnMut(\n-        ty::Region<'tcx>,\n-        ty::DebruijnIndex,\n-    ) -> ty::Region<'tcx> + 'a),\n+    fold_region_fn:\n+        &'a mut (dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         skipped_regions: &'a mut bool,\n         fold_region_fn: &'a mut dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n     ) -> RegionFolder<'a, 'gcx, 'tcx> {\n@@ -396,7 +398,9 @@ impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -427,7 +431,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n \n /// Replaces the escaping bound vars (late bound regions or bound types) in a type.\n struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n \n     /// As with `RegionFolder`, represents the index of a binder *just outside*\n     /// the ones we have visited.\n@@ -440,14 +444,15 @@ struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n     fn new<F, G, H>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         fld_r: &'a mut F,\n         fld_t: &'a mut G,\n         fld_c: &'a mut H,\n     ) -> Self\n-        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-              G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n+    where\n+        F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+        G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n+        H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n     {\n         BoundVarReplacer {\n             tcx,\n@@ -460,7 +465,9 @@ impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -542,7 +549,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Replaces all regions bound by the given `Binder` with the\n     /// results returned by the closure; the closure is expected to\n     /// return a free region (relative to this binder), and hence the\n@@ -722,15 +729,15 @@ enum Direction {\n     Out,\n }\n \n-struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct Shifter<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     current_index: ty::DebruijnIndex,\n     amount: u32,\n     direction: Direction,\n }\n \n-impl Shifter<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n+impl Shifter<'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'gcx, 'tcx>, amount: u32, direction: Direction) -> Self {\n         Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n@@ -740,8 +747,10 @@ impl Shifter<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+impl TypeFolder<'gcx, 'tcx> for Shifter<'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_index.shift_in(1);\n@@ -817,10 +826,10 @@ impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn shift_region<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn shift_region<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     region: ty::Region<'tcx>,\n-    amount: u32\n+    amount: u32,\n ) -> ty::Region<'tcx> {\n     match region {\n         ty::ReLateBound(debruijn, br) if amount > 0 => {\n@@ -832,22 +841,20 @@ pub fn shift_region<'a, 'gcx, 'tcx>(\n     }\n }\n \n-pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    value: &T,\n-    amount: u32\n-) -> T where T: TypeFoldable<'tcx> {\n+pub fn shift_vars<'gcx, 'tcx, T>(tcx: TyCtxt<'gcx, 'tcx>, value: &T, amount: u32) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n     debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n     value.fold_with(&mut Shifter::new(tcx, amount, Direction::In))\n }\n \n-pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    value: &T,\n-    amount: u32\n-) -> T where T: TypeFoldable<'tcx> {\n+pub fn shift_out_vars<'gcx, 'tcx, T>(tcx: TyCtxt<'gcx, 'tcx>, value: &T, amount: u32) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n     debug!(\"shift_out_vars(value={:?}, amount={})\",\n            value, amount);\n "}, {"sha": "023460096a882438158c10be28a9dbdaca94d184", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,7 +21,7 @@ pub struct DefIdForest {\n     root_ids: SmallVec<[DefId; 1]>,\n }\n \n-impl<'a, 'gcx, 'tcx> DefIdForest {\n+impl<'gcx, 'tcx> DefIdForest {\n     /// Creates an empty forest.\n     pub fn empty() -> DefIdForest {\n         DefIdForest {\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n+    pub fn full(tcx: TyCtxt<'gcx, 'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n@@ -52,17 +52,14 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Tests whether the forest contains a given DefId.\n-    pub fn contains(&self,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    id: DefId) -> bool\n-    {\n+    pub fn contains(&self, tcx: TyCtxt<'gcx, 'tcx>, id: DefId) -> bool {\n         self.root_ids.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n     }\n \n     /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                           iter: I) -> DefIdForest\n-            where I: IntoIterator<Item=DefIdForest>\n+    pub fn intersection<I>(tcx: TyCtxt<'gcx, 'tcx>, iter: I) -> DefIdForest\n+    where\n+        I: IntoIterator<Item = DefIdForest>,\n     {\n         let mut iter = iter.into_iter();\n         let mut ret = if let Some(first) = iter.next() {\n@@ -97,9 +94,9 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n     }\n \n     /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    iter: I) -> DefIdForest\n-            where I: IntoIterator<Item=DefIdForest>\n+    pub fn union<I>(tcx: TyCtxt<'gcx, 'tcx>, iter: I) -> DefIdForest\n+    where\n+        I: IntoIterator<Item = DefIdForest>,\n     {\n         let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();"}, {"sha": "b9e34e0cabc65bb6abfdba305a1b59b7a21028f6", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -51,7 +51,7 @@ mod def_id_forest;\n // This code should only compile in modules where the uninhabitedness of Foo is\n // visible.\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n     /// # Example\n     /// ```rust\n@@ -106,13 +106,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> AdtDef {\n+impl<'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n-    fn uninhabited_from(\n-        &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        substs: SubstsRef<'tcx>) -> DefIdForest\n-    {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n@@ -124,14 +120,14 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> VariantDef {\n+impl<'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,\n-        adt_kind: AdtKind) -> DefIdForest\n-    {\n+        adt_kind: AdtKind,\n+    ) -> DefIdForest {\n         let is_enum = match adt_kind {\n             // For now, `union`s are never considered uninhabited.\n             // The precise semantics of inhabitedness with respect to unions is currently undecided.\n@@ -150,11 +146,11 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> FieldDef {\n+impl<'gcx, 'tcx> FieldDef {\n     /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n     ) -> DefIdForest {\n@@ -180,10 +176,9 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n+impl<'gcx, 'tcx> TyS<'tcx> {\n     /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n-    {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'gcx, 'tcx>) -> DefIdForest {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),\n "}, {"sha": "16df0da88207b232d9f6fef22fd562d30201268a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -42,11 +42,8 @@ pub enum InstanceDef<'tcx> {\n     CloneShim(DefId, Ty<'tcx>),\n }\n \n-impl<'a, 'tcx> Instance<'tcx> {\n-    pub fn ty(&self,\n-              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-              -> Ty<'tcx>\n-    {\n+impl<'tcx> Instance<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n         tcx.subst_and_normalize_erasing_regions(\n             self.substs,\n@@ -55,7 +52,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         )\n     }\n \n-    fn fn_sig_noadjust(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> PolyFnSig<'tcx> {\n+    fn fn_sig_noadjust(&self, tcx: TyCtxt<'tcx, 'tcx>) -> PolyFnSig<'tcx> {\n         let ty = self.ty(tcx);\n         match ty.sty {\n             ty::FnDef(..) |\n@@ -105,7 +102,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         let mut fn_sig = self.fn_sig_noadjust(tcx);\n         if let InstanceDef::VtableShim(..) = self.def {\n             // Modify fn(self, ...) to fn(self: *mut Self, ...)\n@@ -136,14 +133,11 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n+    pub fn attrs(&self, tcx: TyCtxt<'tcx, 'tcx>) -> ty::Attributes<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n \n-    pub fn is_inline<'a>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>\n-    ) -> bool {\n+    pub fn is_inline(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n         use crate::hir::map::DefPathData;\n         let def_id = match *self {\n             ty::InstanceDef::Item(def_id) => def_id,\n@@ -156,10 +150,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         }\n     }\n \n-    pub fn requires_local<'a>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>\n-    ) -> bool {\n+    pub fn requires_local(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n         if self.is_inline(tcx) {\n             return true\n         }\n@@ -209,7 +200,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> Instance<'tcx> {\n+impl<'b, 'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: SubstsRef<'tcx>)\n                -> Instance<'tcx> {\n         assert!(!substs.has_escaping_bound_vars(),\n@@ -218,7 +209,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         Instance { def: InstanceDef::Item(def_id), substs: substs }\n     }\n \n-    pub fn mono(tcx: TyCtxt<'a, 'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n+    pub fn mono(tcx: TyCtxt<'tcx, 'b>, def_id: DefId) -> Instance<'tcx> {\n         Instance::new(def_id, tcx.global_tcx().empty_substs_for_def_id(def_id))\n     }\n \n@@ -245,10 +236,12 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     /// Presuming that coherence and type-check have succeeded, if this method is invoked\n     /// in a monomorphic context (i.e., like during codegen), then it is guaranteed to return\n     /// `Some`.\n-    pub fn resolve(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   param_env: ty::ParamEnv<'tcx>,\n-                   def_id: DefId,\n-                   substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n+    pub fn resolve(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let result = if let Some(trait_def_id) = tcx.trait_of_item(def_id) {\n             debug!(\" => associated item, attempting to find impl in param_env {:#?}\", param_env);\n@@ -297,10 +290,12 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         result\n     }\n \n-    pub fn resolve_for_vtable(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              param_env: ty::ParamEnv<'tcx>,\n-                              def_id: DefId,\n-                              substs: SubstsRef<'tcx>) -> Option<Instance<'tcx>> {\n+    pub fn resolve_for_vtable(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n         let is_vtable_shim =\n@@ -317,12 +312,11 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_closure(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         def_id: DefId,\n         substs: ty::ClosureSubsts<'tcx>,\n-        requested_kind: ty::ClosureKind)\n-        -> Instance<'tcx>\n-    {\n+        requested_kind: ty::ClosureKind,\n+    ) -> Instance<'tcx> {\n         let actual_kind = substs.closure_kind(def_id, tcx);\n \n         match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n@@ -331,22 +325,17 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         }\n     }\n \n-    pub fn resolve_drop_in_place(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        ty: Ty<'tcx>)\n-        -> ty::Instance<'tcx>\n-    {\n+    pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n         let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n         let substs = tcx.intern_substs(&[ty.into()]);\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n     }\n \n     pub fn fn_once_adapter_instance(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         closure_did: DefId,\n-        substs: ty::ClosureSubsts<'tcx>)\n-        -> Instance<'tcx>\n-    {\n+        substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Instance<'tcx> {\n         debug!(\"fn_once_adapter_shim({:?}, {:?})\",\n                closure_did,\n                substs);\n@@ -376,8 +365,8 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n     }\n }\n \n-fn resolve_associated_item<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn resolve_associated_item<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     trait_item: &ty::AssocItem,\n     param_env: ty::ParamEnv<'tcx>,\n     trait_id: DefId,"}, {"sha": "efbae81a5dd524e87c217bb0057b0212e6d04e1a", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -28,21 +28,20 @@ use rustc_target::abi::call::{\n     ArgAttribute, ArgAttributes, ArgType, Conv, FnType, IgnoreMode, PassMode, Reg, RegKind\n };\n \n-\n-\n pub trait IntegerExt {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n-    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            repr: &ReprOptions,\n-                            min: i128,\n-                            max: i128)\n-                            -> (Integer, bool);\n+    fn repr_discr<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> (Integer, bool);\n }\n \n impl IntegerExt for Integer {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n             (I8, false) => tcx.types.u8,\n             (I16, false) => tcx.types.u16,\n@@ -77,12 +76,13 @@ impl IntegerExt for Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            repr: &ReprOptions,\n-                            min: i128,\n-                            max: i128)\n-                            -> (Integer, bool) {\n+    fn repr_discr<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+        repr: &ReprOptions,\n+        min: i128,\n+        max: i128,\n+    ) -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n         // are any negative values, the only valid unsigned representation is u128\n@@ -126,11 +126,11 @@ impl IntegerExt for Integer {\n }\n \n pub trait PrimitiveExt {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl PrimitiveExt for Primitive {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             Float(FloatTy::F32) => tcx.types.f32,\n@@ -171,10 +171,10 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                        -> Result<&'tcx LayoutDetails, LayoutError<'tcx>>\n-{\n+fn layout_raw<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n         let rec_limit = *tcx.sess.recursion_limit.get();\n         let (param_env, ty) = query.into_parts();\n@@ -226,7 +226,7 @@ enum StructKind {\n     Prefixed(Size, Align),\n }\n \n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n     fn scalar_pair(&self, a: Scalar, b: Scalar) -> LayoutDetails {\n         let dl = self.data_layout();\n         let b_align = b.value.align(dl);\n@@ -1221,7 +1221,7 @@ enum SavedLocalEligibility {\n // Also included in the layout are the upvars and the discriminant.\n // These are included as fields on the \"outer\" layout; they are not part\n // of any variant.\n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n     /// Compute the eligibility and assignment of each local.\n     fn generator_saved_local_eligibility(&self, info: &GeneratorLayout<'tcx>)\n     -> (BitSet<GeneratorSavedLocal>, IndexVec<GeneratorSavedLocal, SavedLocalEligibility>) {\n@@ -1442,9 +1442,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n         debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n         Ok(layout)\n     }\n-}\n \n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline(always)]\n@@ -1605,11 +1603,12 @@ pub enum SizeSkeleton<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SizeSkeleton<'tcx> {\n-    pub fn compute(ty: Ty<'tcx>,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   param_env: ty::ParamEnv<'tcx>)\n-                   -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n+impl<'tcx> SizeSkeleton<'tcx> {\n+    pub fn compute(\n+        ty: Ty<'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         debug_assert!(!ty.has_infer_types());\n \n         // First try computing a static layout.\n@@ -1729,21 +1728,21 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n }\n \n pub trait HasTyCtxt<'tcx>: HasDataLayout {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n }\n \n pub trait HasParamEnv<'tcx> {\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n }\n \n-impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> HasDataLayout for TyCtxt<'gcx, 'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.data_layout\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+impl<'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'gcx> {\n         self.global_tcx()\n     }\n }\n@@ -1761,7 +1760,7 @@ impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n }\n \n impl<'gcx, 'tcx, T: HasTyCtxt<'gcx>> HasTyCtxt<'gcx> for LayoutCx<'tcx, T> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'gcx> {\n         self.tcx.tcx()\n     }\n }\n@@ -1798,7 +1797,7 @@ impl<T, E> MaybeResult<T> for Result<T, E> {\n \n pub type TyLayout<'tcx> = ::rustc_target::abi::TyLayout<'tcx, Ty<'tcx>>;\n \n-impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -1825,7 +1824,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     }\n }\n \n-impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>> {\n+impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx, 'tcx>> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -1857,7 +1856,7 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'a, 'tcx, 'tcx>>\n }\n \n // Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n-impl TyCtxt<'a, 'tcx, '_> {\n+impl TyCtxt<'tcx, '_> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n@@ -1871,7 +1870,7 @@ impl TyCtxt<'a, 'tcx, '_> {\n     }\n }\n \n-impl ty::query::TyCtxtAt<'a, 'tcx, '_> {\n+impl ty::query::TyCtxtAt<'tcx, '_> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n@@ -2189,9 +2188,9 @@ struct Niche {\n }\n \n impl Niche {\n-    fn reserve<'a, 'tcx>(\n+    fn reserve<'tcx>(\n         &self,\n-        cx: &LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>>,\n+        cx: &LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>>,\n         count: u128,\n     ) -> Option<(u128, Scalar)> {\n         if count > self.available {\n@@ -2207,7 +2206,7 @@ impl Niche {\n     }\n }\n \n-impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx, 'tcx>> {\n     /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) traverse already optimized enums."}, {"sha": "71955764e100b40aefda439a784c307db88115d5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 101, "deletions": 107, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -213,7 +213,7 @@ impl AssocItem {\n         }\n     }\n \n-    pub fn signature<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+    pub fn signature<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> String {\n         match self.kind {\n             ty::AssocKind::Method => {\n                 // We skip the binder here because the binder would deanonymize all\n@@ -259,14 +259,14 @@ pub trait DefIdTree: Copy {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> DefIdTree for TyCtxt<'gcx, 'tcx> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n         self.def_key(id).parent.map(|index| DefId { index: index, ..id })\n     }\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_, '_, '_>) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_, '_>) -> Self {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n@@ -912,7 +912,7 @@ pub struct Generics {\n     pub has_late_bound_regions: Option<Span>,\n }\n \n-impl<'a, 'gcx, 'tcx> Generics {\n+impl<'gcx, 'tcx> Generics {\n     pub fn count(&self) -> usize {\n         self.parent_count + self.params.len()\n     }\n@@ -934,7 +934,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n         own_counts\n     }\n \n-    pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn requires_monomorphization(&self, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n         if self.own_requires_monomorphization() {\n             return true;\n         }\n@@ -957,11 +957,11 @@ impl<'a, 'gcx, 'tcx> Generics {\n         false\n     }\n \n-    pub fn region_param(&'tcx self,\n-                        param: &EarlyBoundRegion,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                        -> &'tcx GenericParamDef\n-    {\n+    pub fn region_param(\n+        &'tcx self,\n+        param: &EarlyBoundRegion,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -975,10 +975,11 @@ impl<'a, 'gcx, 'tcx> Generics {\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n-    pub fn type_param(&'tcx self,\n-                      param: &ParamTy,\n-                      tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                      -> &'tcx GenericParamDef {\n+    pub fn type_param(\n+        &'tcx self,\n+        param: &ParamTy,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> &'tcx GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -992,10 +993,11 @@ impl<'a, 'gcx, 'tcx> Generics {\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n-    pub fn const_param(&'tcx self,\n-                       param: &ParamConst,\n-                       tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                       -> &GenericParamDef {\n+    pub fn const_param(\n+        &'tcx self,\n+        param: &ParamConst,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> &GenericParamDef {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             let param = &self.params[index as usize];\n             match param.kind {\n@@ -1019,24 +1021,33 @@ pub struct GenericPredicates<'tcx> {\n impl<'tcx> serialize::UseSpecializedEncodable for GenericPredicates<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for GenericPredicates<'tcx> {}\n \n-impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n-    pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n-                       -> InstantiatedPredicates<'tcx> {\n+impl<'gcx, 'tcx> GenericPredicates<'tcx> {\n+    pub fn instantiate(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_into(tcx, &mut instantiated, substs);\n         instantiated\n     }\n \n-    pub fn instantiate_own(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: SubstsRef<'tcx>)\n-                           -> InstantiatedPredicates<'tcx> {\n+    pub fn instantiate_own(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|(p, _)| p.subst(tcx, substs)).collect(),\n         }\n     }\n \n-    fn instantiate_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        instantiated: &mut InstantiatedPredicates<'tcx>,\n-                        substs: SubstsRef<'tcx>) {\n+    fn instantiate_into(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+    ) {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_into(tcx, instantiated, substs);\n         }\n@@ -1045,25 +1056,28 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         );\n     }\n \n-    pub fn instantiate_identity(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                                -> InstantiatedPredicates<'tcx> {\n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'gcx, 'tcx>) -> InstantiatedPredicates<'tcx> {\n         let mut instantiated = InstantiatedPredicates::empty();\n         self.instantiate_identity_into(tcx, &mut instantiated);\n         instantiated\n     }\n \n-    fn instantiate_identity_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                 instantiated: &mut InstantiatedPredicates<'tcx>) {\n+    fn instantiate_identity_into(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        instantiated: &mut InstantiatedPredicates<'tcx>,\n+    ) {\n         if let Some(def_id) = self.parent {\n             tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n         }\n         instantiated.predicates.extend(self.predicates.iter().map(|&(p, _)| p))\n     }\n \n-    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n-                                  -> InstantiatedPredicates<'tcx>\n-    {\n+    pub fn instantiate_supertrait(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        poly_trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) -> InstantiatedPredicates<'tcx> {\n         assert_eq!(self.parent, None);\n         InstantiatedPredicates {\n             predicates: self.predicates.iter().map(|(pred, _)| {\n@@ -1128,16 +1142,17 @@ impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n+impl<'gcx, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                            trait_ref: &ty::PolyTraitRef<'tcx>)\n-                            -> ty::Predicate<'tcx>\n-    {\n+    pub fn subst_supertrait(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) -> ty::Predicate<'tcx> {\n         // The interaction between HRTB and supertraits is not entirely\n         // obvious. Let me walk you (and myself) through an example.\n         //\n@@ -1294,7 +1309,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> PolyTraitRef<'tcx> {\n+    pub fn to_poly_trait_ref(&self, tcx: TyCtxt<'_, '_>) -> PolyTraitRef<'tcx> {\n         // Note: unlike with `TraitRef::to_poly_trait_ref()`,\n         // `self.0.trait_ref` is permitted to have escaping regions.\n         // This is because here `self` has a `Binder` and so does our\n@@ -1838,7 +1853,7 @@ pub struct VariantDef {\n     pub recovered: bool,\n }\n \n-impl<'a, 'gcx, 'tcx> VariantDef {\n+impl<'gcx, 'tcx> VariantDef {\n     /// Creates a new `VariantDef`.\n     ///\n     /// `variant_did` is the `DefId` that identifies the enum variant (if this `VariantDef`\n@@ -1856,7 +1871,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n     /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         ident: Ident,\n         variant_did: Option<DefId>,\n         ctor_def_id: Option<DefId>,\n@@ -2069,7 +2084,7 @@ impl_stable_hash_for!(struct ReprOptions {\n });\n \n impl ReprOptions {\n-    pub fn new(tcx: TyCtxt<'_, '_, '_>, did: DefId) -> ReprOptions {\n+    pub fn new(tcx: TyCtxt<'_, '_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n         let mut max_align = 0;\n@@ -2140,17 +2155,16 @@ impl ReprOptions {\n     pub fn inhibit_union_abi_opt(&self) -> bool {\n         self.c()\n     }\n-\n }\n \n-impl<'a, 'gcx, 'tcx> AdtDef {\n+impl<'gcx, 'tcx> AdtDef {\n     /// Creates a new `AdtDef`.\n     fn new(\n-        tcx: TyCtxt<'_, '_, '_>,\n+        tcx: TyCtxt<'_, '_>,\n         did: DefId,\n         kind: AdtKind,\n         variants: IndexVec<VariantIdx, VariantDef>,\n-        repr: ReprOptions\n+        repr: ReprOptions,\n     ) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -2286,7 +2300,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns `true` if this type has a destructor.\n-    pub fn has_dtor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn has_dtor(&self, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n     }\n \n@@ -2297,7 +2311,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx GenericPredicates<'gcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'gcx, 'tcx>) -> &'tcx GenericPredicates<'gcx> {\n         tcx.predicates_of(self.did)\n     }\n \n@@ -2351,7 +2365,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     #[inline]\n     pub fn eval_explicit_discr(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         expr_did: DefId,\n     ) -> Option<Discr<'tcx>> {\n         let param_env = ParamEnv::empty();\n@@ -2397,9 +2411,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn discriminants(\n-        &'a self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n+        &'tcx self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2427,10 +2441,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// discriminant (the last one before the requested variant),\n     /// assuming there are no constant-evaluation errors there.\n     #[inline]\n-    pub fn discriminant_for_variant(&self,\n-                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    variant_index: VariantIdx)\n-                                    -> Discr<'tcx> {\n+    pub fn discriminant_for_variant(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Discr<'tcx> {\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))\n@@ -2465,7 +2480,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         (expr_did, variant_index.as_u32() - explicit_index)\n     }\n \n-    pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {\n+    pub fn destructor(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Destructor> {\n         tcx.adt_destructor(self.did)\n     }\n \n@@ -2479,14 +2494,11 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer (e.g., issue #31299).\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n \n-    fn sized_constraint_for_ty(&self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               ty: Ty<'tcx>)\n-                               -> Vec<Ty<'tcx>> {\n+    fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             Bool | Char | Int(..) | Uint(..) | Float(..) |\n             RawPtr(..) | Ref(..) | FnDef(..) | FnPtr(_) |\n@@ -2563,8 +2575,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> FieldDef {\n-    pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n+impl<'gcx, 'tcx> FieldDef {\n+    pub fn ty(&self, tcx: TyCtxt<'gcx, 'tcx>, subst: SubstsRef<'tcx>) -> Ty<'tcx> {\n         tcx.type_of(self.did).subst(tcx, subst)\n     }\n }\n@@ -2586,11 +2598,11 @@ pub enum ClosureKind {\n     FnOnce,\n }\n \n-impl<'a, 'tcx> ClosureKind {\n+impl<'tcx> ClosureKind {\n     // This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n-    pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n+    pub fn trait_did(&self, tcx: TyCtxt<'tcx, 'tcx>) -> DefId {\n         match *self {\n             ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n             ClosureKind::FnMut => {\n@@ -2618,7 +2630,7 @@ impl<'a, 'tcx> ClosureKind {\n \n     /// Returns the representative scalar type for this closure kind.\n     /// See `TyS::to_opt_closure_kind` for more details.\n-    pub fn to_ty(self, tcx: TyCtxt<'_, '_, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'_, 'tcx>) -> Ty<'tcx> {\n         match self {\n             ty::ClosureKind::Fn => tcx.types.i8,\n             ty::ClosureKind::FnMut => tcx.types.i16,\n@@ -2755,17 +2767,15 @@ pub enum ImplOverlapKind {\n     Issue33140\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'gcx TypeckTables<'gcx> {\n         self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n     /// Returns an iterator of the `DefId`s for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n-    pub fn body_owners(\n-        self,\n-    ) -> impl Iterator<Item = DefId> + Captures<'tcx> + Captures<'gcx> + 'a {\n+    pub fn body_owners(self) -> impl Iterator<Item = DefId> + Captures<'gcx> + 'tcx {\n         self.hir().krate()\n                   .body_ids\n                   .iter()\n@@ -2889,10 +2899,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn associated_items(\n-        self,\n-        def_id: DefId,\n-    ) -> AssocItemsIterator<'a, 'gcx, 'tcx> {\n+    pub fn associated_items(self, def_id: DefId) -> AssocItemsIterator<'gcx, 'tcx> {\n         // Ideally, we would use `-> impl Iterator` here, but it falls\n         // afoul of the conservative \"capture [restrictions]\" we put\n         // in place, so we use a hand-written iterator.\n@@ -3115,13 +3122,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct AssocItemsIterator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct AssocItemsIterator<'gcx, 'tcx> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     def_ids: &'gcx [DefId],\n     next_index: usize,\n }\n \n-impl Iterator for AssocItemsIterator<'_, '_, '_> {\n+impl Iterator for AssocItemsIterator<'_, '_> {\n     type Item = AssocItem;\n \n     fn next(&mut self) -> Option<AssocItem> {\n@@ -3131,7 +3138,7 @@ impl Iterator for AssocItemsIterator<'_, '_, '_> {\n     }\n }\n \n-fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssocItem {\n+fn associated_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n@@ -3176,9 +3183,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n ///       such.\n ///     - a Error, if a type contained itself. The representability\n ///       check should catch this case.\n-fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def_id: DefId)\n-                                  -> AdtSizedConstraint<'tcx> {\n+fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> AdtSizedConstraint<'tcx> {\n     let def = tcx.adt_def(def_id);\n \n     let result = tcx.mk_type_list(def.variants.iter().flat_map(|v| {\n@@ -3192,9 +3197,7 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     AdtSizedConstraint(result)\n }\n \n-fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> &'tcx [DefId] {\n+fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(id);\n     match item.node {\n@@ -3217,14 +3220,14 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n+fn def_span<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Span {\n     tcx.hir().span_if_local(def_id).unwrap()\n }\n \n /// If the given `DefId` describes an item belonging to a trait,\n /// returns the `DefId` of the trait that the trait item belongs to;\n /// otherwise, returns `None`.\n-fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n+fn trait_of_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     tcx.opt_associated_item(def_id)\n         .and_then(|associated_item| {\n             match associated_item.container {\n@@ -3235,7 +3238,7 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n }\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n-pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefId> {\n+pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         if let Node::Item(item) = tcx.hir().get_by_hir_id(hir_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n@@ -3247,10 +3250,7 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n }\n \n /// See `ParamEnv` struct definition for details.\n-fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       def_id: DefId)\n-                       -> ParamEnv<'tcx>\n-{\n+fn param_env<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n         return param_env(tcx, parent);\n@@ -3285,28 +3285,25 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n-fn crate_disambiguator<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 crate_num: CrateNum) -> CrateDisambiguator {\n+fn crate_disambiguator<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> CrateDisambiguator {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.sess.local_crate_disambiguator()\n }\n \n-fn original_crate_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 crate_num: CrateNum) -> Symbol {\n+fn original_crate_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> Symbol {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.crate_name.clone()\n }\n \n-fn crate_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        crate_num: CrateNum)\n-                        -> Svh {\n+fn crate_hash<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) -> Svh {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.hir().crate_hash\n }\n \n-fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        instance_def: InstanceDef<'tcx>)\n-                                        -> usize {\n+fn instance_def_size_estimate<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance_def: InstanceDef<'tcx>,\n+) -> usize {\n     match instance_def {\n         InstanceDef::Item(..) |\n         InstanceDef::DropGlue(..) => {\n@@ -3321,10 +3318,7 @@ fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n /// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> Option<Ty<'tcx>>\n-{\n+fn issue33140_self_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<Ty<'tcx>> {\n     debug!(\"issue33140_self_ty({:?})\", def_id);\n \n     let trait_ref = tcx.impl_trait_ref(def_id).unwrap_or_else(|| {"}, {"sha": "c24c0541ad71f0be104bea269352f0d587538ce4", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -45,7 +45,7 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(&self, ty0: Ty<'tcx>,"}, {"sha": "d5bca55c2f1b1e6d292380d89f451e4911f8c1f8", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -37,7 +37,7 @@ pub trait Printer<'gcx: 'tcx, 'tcx>: Sized {\n     type DynExistential;\n     type Const;\n \n-    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+    fn tcx(&'a self) -> TyCtxt<'gcx, 'tcx>;\n \n     fn print_def_path(\n         self,"}, {"sha": "a320eb47e6c1c70bbd3cc8aa3adde25dbe3b3b06", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -16,15 +16,15 @@ use syntax::ast;\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub struct DefPathBasedNames<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DefPathBasedNames<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     omit_disambiguators: bool,\n     omit_local_crate_name: bool,\n }\n \n-impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n+impl DefPathBasedNames<'tcx> {\n     pub fn new(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         omit_disambiguators: bool,\n         omit_local_crate_name: bool,\n     ) -> Self {"}, {"sha": "d55f1c8983610594bc254e94f2e00e91050921f1", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -934,7 +934,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n pub struct FmtPrinter<'a, 'gcx, 'tcx, F>(Box<FmtPrinterData<'a, 'gcx, 'tcx, F>>);\n \n pub struct FmtPrinterData<'a, 'gcx, 'tcx, F> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     fmt: F,\n \n     empty_path: bool,\n@@ -963,7 +963,7 @@ impl<F> DerefMut for FmtPrinter<'_, '_, '_, F> {\n }\n \n impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n+    pub fn new(tcx: TyCtxt<'gcx, 'tcx>, fmt: F, ns: Namespace) -> Self {\n         FmtPrinter(Box::new(FmtPrinterData {\n             tcx,\n             fmt,\n@@ -978,7 +978,7 @@ impl<F> FmtPrinter<'a, 'gcx, 'tcx, F> {\n     }\n }\n \n-impl TyCtxt<'_, '_, '_> {\n+impl TyCtxt<'_, '_> {\n     // HACK(eddyb) get rid of `def_path_str` and/or pass `Namespace` explicitly always\n     // (but also some things just print a `DefId` generally so maybe we need this?)\n     fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n@@ -1025,7 +1025,7 @@ impl<F: fmt::Write> Printer<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&'a self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "bd5f33eea7bc529d7f53045545cc954bb3fcc8d9", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -31,38 +31,36 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: TyCtxt<'a, 'tcx, '_>) -> &'a Lock<QueryCache<'tcx, Self>>;\n+    fn query_cache<'a>(tcx: TyCtxt<'tcx, '_>) -> &'a Lock<QueryCache<'tcx, Self>>;\n \n-    fn to_dep_node(tcx: TyCtxt<'_, 'tcx, '_>, key: &Self::Key) -> DepNode;\n+    fn to_dep_node(tcx: TyCtxt<'tcx, '_>, key: &Self::Key) -> DepNode;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value;\n+    fn compute(tcx: TyCtxt<'tcx, '_>, key: Self::Key) -> Self::Value;\n \n     fn hash_result(\n         hcx: &mut StableHashingContext<'_>,\n         result: &Self::Value\n     ) -> Option<Fingerprint>;\n \n-    fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>, error: CycleError<'tcx>) -> Self::Value;\n+    fn handle_cycle_error(tcx: TyCtxt<'tcx, '_>, error: CycleError<'tcx>) -> Self::Value;\n }\n \n pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n-    fn describe(tcx: TyCtxt<'_, '_, '_>, key: Self::Key) -> Cow<'static, str>;\n+    fn describe(tcx: TyCtxt<'_, '_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, _: Self::Key) -> bool {\n+    fn cache_on_disk(_: TyCtxt<'tcx, 'tcx>, _: Self::Key) -> bool {\n         false\n     }\n \n-    fn try_load_from_disk(_: TyCtxt<'_, 'tcx, 'tcx>,\n-                          _: SerializedDepNodeIndex)\n-                          -> Option<Self::Value> {\n+    fn try_load_from_disk(_: TyCtxt<'tcx, 'tcx>, _: SerializedDepNodeIndex) -> Option<Self::Value> {\n         bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n-    default fn describe(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Cow<'static, str> {\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n+    default fn describe(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()\n         } else {\n@@ -73,7 +71,7 @@ impl<'tcx, M: QueryAccessors<'tcx, Key=DefId>> QueryDescription<'tcx> for M {\n }\n \n impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n+    fn describe(_tcx: TyCtxt<'_, '_>, _: CrateNum) -> Cow<'static, str> {\n         \"running analysis passes on this crate\".into()\n     }\n }\n@@ -82,12 +80,12 @@ macro_rules! impl_disk_cacheable_query(\n     ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n         impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n             #[inline]\n-            fn cache_on_disk($tcx: TyCtxt<'_, 'tcx, 'tcx>, $key: Self::Key) -> bool {\n+            fn cache_on_disk($tcx: TyCtxt<'tcx, 'tcx>, $key: Self::Key) -> bool {\n                 $cond\n             }\n \n             #[inline]\n-            fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            fn try_load_from_disk(tcx: TyCtxt<'tcx, 'tcx>,\n                                       id: SerializedDepNodeIndex)\n                                       -> Option<Self::Value> {\n                 tcx.queries.on_disk_cache.try_load_query_result(tcx, id)"}, {"sha": "f300d82e372e9c079c884df879129c4191a79d46", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> QueryJob<'tcx> {\n     #[cfg(parallel_compiler)]\n     pub(super) fn r#await<'lcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        tcx: TyCtxt<'tcx, 'lcx>,\n         span: Span,\n     ) -> Result<(), CycleError<'tcx>> {\n         tls::with_related_context(tcx, move |icx| {\n@@ -102,7 +102,7 @@ impl<'tcx> QueryJob<'tcx> {\n     #[cfg(not(parallel_compiler))]\n     pub(super) fn find_cycle_in_stack<'lcx>(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        tcx: TyCtxt<'tcx, 'lcx>,\n         span: Span,\n     ) -> CycleError<'tcx> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n@@ -338,9 +338,9 @@ fn connected_to_root<'tcx>(\n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n-    tcx: TyCtxt<'_, 'tcx, '_>,\n+    tcx: TyCtxt<'tcx, '_>,\n     queries: &'a [T],\n-    f: F\n+    f: F,\n ) -> &'a T {\n     // Deterministically pick an entry point\n     // FIXME: Sort this instead\n@@ -366,7 +366,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n fn remove_cycle<'tcx>(\n     jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n-    tcx: TyCtxt<'_, 'tcx, '_>\n+    tcx: TyCtxt<'tcx, '_>,\n ) -> bool {\n     let mut visited = FxHashSet::default();\n     let mut stack = Vec::new();\n@@ -505,7 +505,7 @@ pub unsafe fn handle_deadlock() {\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n-fn deadlock(tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n+fn deadlock(tcx: TyCtxt<'_, '_>, registry: &rayon_core::Registry) {\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();"}, {"sha": "af13bbc24efd96099bbdbfd9d7382810972a1c6f", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,15 +22,15 @@ pub(super) trait Key: Clone + Hash + Eq + Debug {\n \n     /// In the event that a cycle occurs, if no explicit span has been\n     /// given for a query with key `self`, what span should we use?\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span;\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span;\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n \n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n@@ -40,7 +40,7 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n         LOCAL_CRATE\n     }\n \n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n@@ -50,7 +50,7 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n         self.instance.query_crate()\n     }\n \n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         self.instance.default_span(tcx)\n     }\n }\n@@ -59,7 +59,7 @@ impl Key for CrateNum {\n     fn query_crate(&self) -> CrateNum {\n         *self\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -68,7 +68,7 @@ impl Key for DefIndex {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _tcx: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -77,7 +77,7 @@ impl Key for DefId {\n     fn query_crate(&self) -> CrateNum {\n         self.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         tcx.def_span(*self)\n     }\n }\n@@ -86,7 +86,7 @@ impl Key for (DefId, DefId) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n@@ -95,7 +95,7 @@ impl Key for (CrateNum, DefId) {\n     fn query_crate(&self) -> CrateNum {\n         self.0\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         self.1.default_span(tcx)\n     }\n }\n@@ -104,7 +104,7 @@ impl Key for (DefId, SimplifiedType) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n@@ -113,7 +113,7 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         self.0.default_span(tcx)\n     }\n }\n@@ -122,7 +122,7 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         tcx.def_span(self.1.def_id())\n     }\n }\n@@ -131,16 +131,16 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n \n-impl<'tcx> Key for ty::PolyTraitRef<'tcx>{\n+impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         tcx.def_span(self.def_id())\n     }\n }\n@@ -149,7 +149,7 @@ impl<'tcx> Key for ty::Const<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -158,7 +158,7 @@ impl<'tcx> Key for Ty<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -167,7 +167,7 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -176,7 +176,7 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n     fn query_crate(&self) -> CrateNum {\n         self.value.query_crate()\n     }\n-    fn default_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         self.value.default_span(tcx)\n     }\n }\n@@ -185,7 +185,7 @@ impl<'tcx> Key for traits::Environment<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -194,7 +194,7 @@ impl Key for InternedString {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n-    fn default_span(&self, _tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _tcx: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }\n@@ -209,7 +209,7 @@ where\n         LOCAL_CRATE\n     }\n \n-    fn default_span(&self, _tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn default_span(&self, _tcx: TyCtxt<'_, '_>) -> Span {\n         DUMMY_SP\n     }\n }"}, {"sha": "bc28396a6f9f89601212977b50bcc2fc3b08d3af", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 117, "deletions": 104, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -156,12 +156,14 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn serialize<'a, 'tcx, E>(&self,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  encoder: &mut E)\n-                                  -> Result<(), E::Error>\n-        where E: ty_codec::TyEncoder\n-     {\n+    pub fn serialize<'tcx, E>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        encoder: &mut E,\n+    ) -> Result<(), E::Error>\n+    where\n+        E: ty_codec::TyEncoder,\n+    {\n         // Serializing the DepGraph should not modify it:\n         tcx.dep_graph.with_ignore(|| {\n             // Allocate SourceFileIndices\n@@ -314,7 +316,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n             return Ok(());\n \n-            fn sorted_cnums_including_local_crate(tcx: TyCtxt<'_, '_, '_>) -> Vec<CrateNum> {\n+            fn sorted_cnums_including_local_crate(tcx: TyCtxt<'_, '_>) -> Vec<CrateNum> {\n                 let mut cnums = vec![LOCAL_CRATE];\n                 cnums.extend_from_slice(&tcx.crates()[..]);\n                 cnums.sort_unstable();\n@@ -326,10 +328,11 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     /// Loads a diagnostic emitted during the previous compilation session.\n-    pub fn load_diagnostics<'a, 'tcx>(&self,\n-                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      dep_node_index: SerializedDepNodeIndex)\n-                                      -> Vec<Diagnostic> {\n+    pub fn load_diagnostics<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        dep_node_index: SerializedDepNodeIndex,\n+    ) -> Vec<Diagnostic> {\n         let diagnostics: Option<EncodedDiagnostics> = self.load_indexed(\n             tcx,\n             dep_node_index,\n@@ -354,11 +357,13 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n-    pub fn try_load_query_result<'tcx, T>(&self,\n-                                          tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                                          dep_node_index: SerializedDepNodeIndex)\n-                                          -> Option<T>\n-        where T: Decodable\n+    pub fn try_load_query_result<'tcx, T>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        dep_node_index: SerializedDepNodeIndex,\n+    ) -> Option<T>\n+    where\n+        T: Decodable,\n     {\n         self.load_indexed(tcx,\n                           dep_node_index,\n@@ -382,14 +387,15 @@ impl<'sess> OnDiskCache<'sess> {\n         x.extend(Into::<Vec<_>>::into(diagnostics));\n     }\n \n-    fn load_indexed<'tcx, T>(&self,\n-                             tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                             dep_node_index: SerializedDepNodeIndex,\n-                             index: &FxHashMap<SerializedDepNodeIndex,\n-                                               AbsoluteBytePos>,\n-                             debug_tag: &'static str)\n-                             -> Option<T>\n-        where T: Decodable\n+    fn load_indexed<'tcx, T>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        dep_node_index: SerializedDepNodeIndex,\n+        index: &FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n+        debug_tag: &'static str,\n+    ) -> Option<T>\n+    where\n+        T: Decodable,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n@@ -423,10 +429,10 @@ impl<'sess> OnDiskCache<'sess> {\n     // current-session-CrateNum. There might be CrateNums from the previous\n     // Session that don't occur in the current one. For these, the mapping\n     // maps to None.\n-    fn compute_cnum_map(tcx: TyCtxt<'_, '_, '_>,\n-                        prev_cnums: &[(u32, String, CrateDisambiguator)])\n-                        -> IndexVec<CrateNum, Option<CrateNum>>\n-    {\n+    fn compute_cnum_map(\n+        tcx: TyCtxt<'_, '_>,\n+        prev_cnums: &[(u32, String, CrateDisambiguator)],\n+    ) -> IndexVec<CrateNum, Option<CrateNum>> {\n         tcx.dep_graph.with_ignore(|| {\n             let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n                 let crate_name = tcx.original_crate_name(cnum)\n@@ -457,18 +463,18 @@ impl<'sess> OnDiskCache<'sess> {\n /// A decoder that can read the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and\n /// eventually will also handle things that contain `Ty` instances.\n-struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    opaque: opaque::Decoder<'x>,\n-    source_map: &'x SourceMap,\n-    cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'x Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n-    file_index_to_file: &'x Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    file_index_to_stable_id: &'x FxHashMap<SourceFileIndex, StableSourceFileId>,\n-    alloc_decoding_session: AllocDecodingSession<'x>,\n+struct CacheDecoder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    opaque: opaque::Decoder<'a>,\n+    source_map: &'a SourceMap,\n+    cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n+    synthetic_expansion_infos: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n+    file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n+    alloc_decoding_session: AllocDecodingSession<'a>,\n }\n \n-impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n     fn file_index_to_file(&self, index: SourceFileIndex) -> Lrc<SourceFile> {\n         let CacheDecoder {\n             ref file_index_to_file,\n@@ -489,13 +495,13 @@ trait DecoderWithPosition: Decoder {\n     fn position(&self) -> usize;\n }\n \n-impl<'enc> DecoderWithPosition for opaque::Decoder<'enc> {\n+impl<'a> DecoderWithPosition for opaque::Decoder<'a> {\n     fn position(&self) -> usize {\n         self.position()\n     }\n }\n \n-impl<'a, 'tcx, 'x> DecoderWithPosition for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n     fn position(&self) -> usize {\n         self.opaque.position()\n     }\n@@ -524,11 +530,9 @@ fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n     Ok(value)\n }\n \n-\n-impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx, 'x> {\n-\n+impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -584,16 +588,16 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n     }\n }\n \n-implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n+implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n         let alloc_decoding_session = self.alloc_decoding_session;\n         alloc_decoding_session.decode_alloc_id(self)\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let tag: u8 = Decodable::decode(self)?;\n \n@@ -656,7 +660,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n // DefIndex that is not contained in a DefId. Such a case would be problematic\n // because we would not know how to transform the DefIndex to the current\n // context.\n-impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n         bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n     }\n@@ -665,7 +669,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n // Both the CrateNum and the DefIndex of a DefId can change in between two\n // compilation sessions. We use the DefPathHash, which is stable across\n // sessions, to map the old DefId to the new one.\n-impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n         // Load the DefPathHash which is was we encoded the DefId as.\n@@ -676,14 +680,14 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n         Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n         // Load the DefPathHash which is was we encoded the DefIndex as.\n         let def_path_hash = DefPathHash::decode(self)?;\n@@ -710,22 +714,23 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x>\n \n // NodeIds are not stable across compilation sessions, so we store them in their\n // HirId representation. This allows use to map them to the current NodeId.\n-impl<'a, 'tcx, 'x> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n         let hir_id = hir::HirId::decode(self)?;\n         Ok(self.tcx().hir().hir_to_node_id(hir_id))\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx, 'x, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n-for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n+    for CacheDecoder<'a, 'tcx>\n+{\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n         let discr = u8::decode(self)?;\n@@ -745,12 +750,9 @@ for CacheDecoder<'a, 'tcx, 'x> {\n \n //- ENCODING -------------------------------------------------------------------\n \n-struct CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder,\n-             'tcx: 'a,\n-{\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    encoder: &'enc mut E,\n+struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n     expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n@@ -760,8 +762,9 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n }\n \n-impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -787,8 +790,9 @@ impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -806,8 +810,9 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n \n@@ -862,26 +867,29 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn position(&self) -> usize {\n         self.encoder.position()\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n         self.emit_u32(cnum.as_u32())\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -890,9 +898,9 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'enc, 'a,\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n-    for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -903,8 +911,9 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -920,9 +929,9 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a\n     }\n }\n \n-\n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n@@ -931,17 +940,19 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'enc, 'a, 'tc\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n         id.to_def_id().encode(self)\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n         bug!(\"Encoding DefIndex without context.\")\n@@ -950,8 +961,9 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'enc, 'a,\n \n // NodeIds are not stable across compilation sessions, so we store them in their\n // HirId representation. This allows use to map them to the current NodeId.\n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n@@ -960,18 +972,16 @@ impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 't\n     }\n }\n \n-impl<'enc, 'a, 'tcx> SpecializedEncoder<Fingerprint>\n-for CacheEncoder<'enc, 'a, 'tcx, opaque::Encoder>\n-{\n+impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque::Encoder> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.encoder)\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>>\n-for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder,\n-          T: Encodable,\n+impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n+    T: Encodable,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -997,8 +1007,9 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'enc, 'a, 'tcx, E> Encoder for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n+impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + ty_codec::TyEncoder,\n {\n     type Error = E::Error;\n \n@@ -1051,7 +1062,7 @@ impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n     }\n }\n \n-impl<'enc> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'enc> {\n+impl<'a> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'a> {\n     fn specialized_decode(&mut self) -> Result<IntEncodedWithFixedSize, Self::Error> {\n         let mut value: u64 = 0;\n         let start_pos = self.position();\n@@ -1068,13 +1079,15 @@ impl<'enc> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'enc>\n     }\n }\n \n-fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n-                                              query_result_index: &mut EncodedQueryResultIndex)\n-                                              -> Result<(), E::Error>\n-    where Q: super::config::QueryDescription<'tcx>,\n-          E: 'enc + TyEncoder,\n-          Q::Value: Encodable,\n+fn encode_query_results<'a, 'tcx, Q, E>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    encoder: &mut CacheEncoder<'a, 'tcx, E>,\n+    query_result_index: &mut EncodedQueryResultIndex,\n+) -> Result<(), E::Error>\n+where\n+    Q: super::config::QueryDescription<'tcx>,\n+    E: 'a + TyEncoder,\n+    Q::Value: Encodable,\n {\n     let desc = &format!(\"encode_query_results for {}\",\n         unsafe { ::std::intrinsics::type_name::<Q>() });"}, {"sha": "662d653b2a173ad2b755a32fd26a3803f2cde79d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n     pub(super) fn try_get(\n-        tcx: TyCtxt<'a, 'tcx, '_>,\n+        tcx: TyCtxt<'tcx, '_>,\n         span: Span,\n         key: &Q::Key,\n     ) -> TryGetJob<'a, 'tcx, Q> {\n@@ -247,7 +247,7 @@ pub(super) enum TryGetJob<'a, 'tcx: 'a, D: QueryDescription<'tcx> + 'a> {\n     Cycle(D::Value),\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     /// Executes a job by changing the ImplicitCtxt to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n@@ -256,10 +256,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         job: Lrc<QueryJob<'gcx>>,\n         diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n-        compute: F)\n-    -> R\n+        compute: F,\n+    ) -> R\n     where\n-        F: for<'b, 'lcx> FnOnce(TyCtxt<'b, 'gcx, 'lcx>) -> R\n+        F: for<'lcx> FnOnce(TyCtxt<'gcx, 'lcx>) -> R,\n     {\n         // The TyCtxt stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'gcx lifetimes\n@@ -285,9 +285,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<'gcx>\n-    ) -> DiagnosticBuilder<'a>\n-    {\n+        CycleError { usage, cycle: stack }: CycleError<'gcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n         let fix_span = |span: Span, query: &Query<'gcx>| {\n@@ -874,7 +873,7 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            pub fn describe(&self, tcx: TyCtxt<'_, '_, '_>) -> Cow<'static, str> {\n+            pub fn describe(&self, tcx: TyCtxt<'_, '_>) -> Cow<'static, str> {\n                 let (r, name) = match *self {\n                     $(Query::$name(key) => {\n                         (queries::$name::describe(tcx, key), stringify!($name))\n@@ -888,7 +887,7 @@ macro_rules! define_queries_inner {\n             }\n \n             // FIXME(eddyb) Get more valid Span's on queries.\n-            pub fn default_span(&self, tcx: TyCtxt<'_, $tcx, '_>, span: Span) -> Span {\n+            pub fn default_span(&self, tcx: TyCtxt<$tcx, '_>, span: Span) -> Span {\n                 if !span.is_dummy() {\n                     return span;\n                 }\n@@ -954,20 +953,20 @@ macro_rules! define_queries_inner {\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<'a, $tcx, '_>) -> &'a Lock<QueryCache<$tcx, Self>> {\n+            fn query_cache<'a>(tcx: TyCtxt<$tcx, '_>) -> &'a Lock<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n             #[allow(unused)]\n             #[inline(always)]\n-            fn to_dep_node(tcx: TyCtxt<'_, $tcx, '_>, key: &Self::Key) -> DepNode {\n+            fn to_dep_node(tcx: TyCtxt<$tcx, '_>, key: &Self::Key) -> DepNode {\n                 use crate::dep_graph::DepConstructor::*;\n \n                 DepNode::new(tcx, $node(*key))\n             }\n \n             #[inline]\n-            fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value {\n+            fn compute(tcx: TyCtxt<'tcx, '_>, key: Self::Key) -> Self::Value {\n                 __query_compute::$name(move || {\n                     let provider = tcx.queries.providers.get(key.query_crate())\n                         // HACK(eddyb) it's possible crates may be loaded after\n@@ -988,19 +987,19 @@ macro_rules! define_queries_inner {\n             }\n \n             fn handle_cycle_error(\n-                tcx: TyCtxt<'_, 'tcx, '_>,\n+                tcx: TyCtxt<'tcx, '_>,\n                 error: CycleError<'tcx>\n             ) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx, error])\n             }\n         })*\n \n         #[derive(Copy, Clone)]\n-        pub struct TyCtxtEnsure<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pub struct TyCtxtEnsure<'gcx, 'tcx> {\n+            pub tcx: TyCtxt<'gcx, 'tcx>,\n         }\n \n-        impl<'a, $tcx, 'lcx> TyCtxtEnsure<'a, $tcx, 'lcx> {\n+        impl TyCtxtEnsure<$tcx, 'lcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) {\n@@ -1009,24 +1008,24 @@ macro_rules! define_queries_inner {\n         }\n \n         #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        pub struct TyCtxtAt<'gcx, 'tcx> {\n+            pub tcx: TyCtxt<'gcx, 'tcx>,\n             pub span: Span,\n         }\n \n-        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n-            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+        impl Deref for TyCtxtAt<'gcx, 'tcx> {\n+            type Target = TyCtxt<'gcx, 'tcx>;\n             #[inline(always)]\n             fn deref(&self) -> &Self::Target {\n                 &self.tcx\n             }\n         }\n \n-        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n+        impl TyCtxt<$tcx, 'lcx> {\n             /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n             /// are executed instead of just returing their results.\n             #[inline(always)]\n-            pub fn ensure(self) -> TyCtxtEnsure<'a, $tcx, 'lcx> {\n+            pub fn ensure(self) -> TyCtxtEnsure<$tcx, 'lcx> {\n                 TyCtxtEnsure {\n                     tcx: self,\n                 }\n@@ -1035,7 +1034,7 @@ macro_rules! define_queries_inner {\n             /// Returns a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n             #[inline(always)]\n-            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n+            pub fn at(self, span: Span) -> TyCtxtAt<$tcx, 'lcx> {\n                 TyCtxtAt {\n                     tcx: self,\n                     span\n@@ -1049,7 +1048,7 @@ macro_rules! define_queries_inner {\n             })*\n         }\n \n-        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n+        impl TyCtxtAt<$tcx, 'lcx> {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: $K) -> $V {\n@@ -1090,12 +1089,12 @@ macro_rules! define_provider_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$name:ident] [$K:ty] [$R:ty]))*)) => {\n         pub struct Providers<$tcx> {\n-            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+            $(pub $name: fn(TyCtxt<$tcx, $tcx>, $K) -> $R,)*\n         }\n \n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n+                $(fn $name<$tcx>(_: TyCtxt<$tcx, $tcx>, key: $K) -> $R {\n                     bug!(\"tcx.{}({:?}) unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n@@ -1148,10 +1147,7 @@ macro_rules! define_provider_struct {\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n-pub fn force_from_dep_node<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    dep_node: &DepNode\n-) -> bool {\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n     // We must avoid ever having to call force_from_dep_node() for a\n@@ -1237,7 +1233,7 @@ macro_rules! impl_load_from_cache {\n         impl DepNode {\n             // Check whether the query invocation corresponding to the given\n             // DepNode is eligible for on-disk-caching.\n-            pub fn cache_on_disk(&self, tcx: TyCtxt<'_, '_, '_>) -> bool {\n+            pub fn cache_on_disk(&self, tcx: TyCtxt<'_, '_>) -> bool {\n                 use crate::ty::query::queries;\n                 use crate::ty::query::QueryDescription;\n \n@@ -1255,7 +1251,7 @@ macro_rules! impl_load_from_cache {\n             // above `cache_on_disk` methods returns true.\n             // Also, as a sanity check, it expects that the corresponding query\n             // invocation has been marked as green already.\n-            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt<'_, '_, '_>) {\n+            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt<'_, '_>) {\n                 match self.kind {\n                     $(DepKind::$dep_kind => {\n                         debug_assert!(tcx.dep_graph"}, {"sha": "5c6b2e172d3c3503d3fffd4b12b1b06b2d96e5d9", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -4,36 +4,36 @@ use crate::ty::util::NeedsDrop;\n use syntax::symbol::InternedString;\n \n pub(super) trait Value<'tcx>: Sized {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n+    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> Self;\n }\n \n impl<'tcx, T> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+    default fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> T {\n         tcx.sess.abort_if_errors();\n         bug!(\"Value::from_cycle_error called without errors\");\n     }\n }\n \n impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n         tcx.types.err\n     }\n }\n \n impl<'tcx> Value<'tcx> for ty::SymbolName {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(_: TyCtxt<'tcx, 'tcx>) -> Self {\n         ty::SymbolName { name: InternedString::intern(\"<error>\") }\n     }\n }\n \n impl<'tcx> Value<'tcx> for NeedsDrop {\n-    fn from_cycle_error(_: TyCtxt<'_, 'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(_: TyCtxt<'tcx, 'tcx>) -> Self {\n         NeedsDrop(false)\n     }\n }\n \n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n-    fn from_cycle_error(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Self {\n+    fn from_cycle_error(tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n         AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))\n     }\n }"}, {"sha": "2bd38ff70d4c57eb56aa5098a383758767668bab", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 275, "deletions": 152, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,8 +22,8 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+pub trait TypeRelation<'gcx: 'tcx, 'tcx>: Sized {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n@@ -94,20 +94,26 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n }\n \n pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self)\n-                           -> RelateResult<'tcx, Self>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a;\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self) -> RelateResult<'tcx, Self>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::TypeAndMut<'tcx>,\n-                           b: &ty::TypeAndMut<'tcx>)\n-                           -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TypeAndMut<'tcx>,\n+        b: &ty::TypeAndMut<'tcx>,\n+    ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n@@ -127,12 +133,16 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     }\n }\n \n-pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                        variances: Option<&[ty::Variance]>,\n-                                        a_subst: SubstsRef<'tcx>,\n-                                        b_subst: SubstsRef<'tcx>)\n-                                        -> RelateResult<'tcx, SubstsRef<'tcx>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn relate_substs<'a, 'gcx, 'tcx, R>(\n+    relation: &mut R,\n+    variances: Option<&[ty::Variance]>,\n+    a_subst: SubstsRef<'tcx>,\n+    b_subst: SubstsRef<'tcx>,\n+) -> RelateResult<'tcx, SubstsRef<'tcx>>\n+where\n+    R: TypeRelation<'gcx, 'tcx>,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     let tcx = relation.tcx();\n \n@@ -145,11 +155,15 @@ pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n }\n \n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::FnSig<'tcx>,\n-                           b: &ty::FnSig<'tcx>)\n-                           -> RelateResult<'tcx, ty::FnSig<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::FnSig<'tcx>,\n+        b: &ty::FnSig<'tcx>,\n+    ) -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let tcx = relation.tcx();\n \n@@ -185,11 +199,15 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ast::Unsafety,\n-                           b: &ast::Unsafety)\n-                           -> RelateResult<'tcx, ast::Unsafety>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ast::Unsafety,\n+        b: &ast::Unsafety,\n+    ) -> RelateResult<'tcx, ast::Unsafety>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a != b {\n             Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n@@ -200,11 +218,15 @@ impl<'tcx> Relate<'tcx> for ast::Unsafety {\n }\n \n impl<'tcx> Relate<'tcx> for abi::Abi {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &abi::Abi,\n-                           b: &abi::Abi)\n-                           -> RelateResult<'tcx, abi::Abi>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &abi::Abi,\n+        b: &abi::Abi,\n+    ) -> RelateResult<'tcx, abi::Abi>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a == b {\n             Ok(*a)\n@@ -215,11 +237,15 @@ impl<'tcx> Relate<'tcx> for abi::Abi {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ProjectionTy<'tcx>,\n-                           b: &ty::ProjectionTy<'tcx>)\n-                           -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ProjectionTy<'tcx>,\n+        b: &ty::ProjectionTy<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n@@ -235,11 +261,15 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ExistentialProjection<'tcx>,\n-                           b: &ty::ExistentialProjection<'tcx>)\n-                           -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ExistentialProjection<'tcx>,\n+        b: &ty::ExistentialProjection<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(\n@@ -257,11 +287,15 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-                           b: &Vec<ty::PolyExistentialProjection<'tcx>>)\n-                           -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n+        b: &Vec<ty::PolyExistentialProjection<'tcx>>,\n+    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n         // same set of traits and item names. We always require that\n@@ -280,11 +314,15 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::TraitRef<'tcx>,\n-                           b: &ty::TraitRef<'tcx>)\n-                           -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::TraitRef<'tcx>,\n+        b: &ty::TraitRef<'tcx>,\n+    ) -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -297,11 +335,15 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ExistentialTraitRef<'tcx>,\n-                           b: &ty::ExistentialTraitRef<'tcx>)\n-                           -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ExistentialTraitRef<'tcx>,\n+        b: &ty::ExistentialTraitRef<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -323,11 +365,15 @@ TupleStructTypeFoldableImpl! {\n }\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &GeneratorWitness<'tcx>,\n-                           b: &GeneratorWitness<'tcx>)\n-                           -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &GeneratorWitness<'tcx>,\n+        b: &GeneratorWitness<'tcx>,\n+    ) -> RelateResult<'tcx, GeneratorWitness<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n@@ -337,11 +383,15 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Ty<'tcx>,\n-                           b: &Ty<'tcx>)\n-                           -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &Ty<'tcx>,\n+        b: &Ty<'tcx>,\n+    ) -> RelateResult<'tcx, Ty<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.tys(a, b)\n     }\n@@ -350,11 +400,15 @@ impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n /// The main \"type relation\" routine. Note that this does not handle\n /// inference artifacts, so you should filter those out before calling\n /// it.\n-pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                           a: Ty<'tcx>,\n-                                           b: Ty<'tcx>)\n-                                           -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(\n+    relation: &mut R,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+) -> RelateResult<'tcx, Ty<'tcx>>\n+where\n+    R: TypeRelation<'gcx, 'tcx>,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     let tcx = relation.tcx();\n     debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n@@ -553,10 +607,12 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n pub fn super_relate_consts<'a, 'gcx, 'tcx, R>(\n     relation: &mut R,\n     a: &'tcx ty::Const<'tcx>,\n-    b: &'tcx ty::Const<'tcx>\n+    b: &'tcx ty::Const<'tcx>,\n ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n where\n-    R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    R: TypeRelation<'gcx, 'tcx>,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     let tcx = relation.tcx();\n \n@@ -632,12 +688,12 @@ where\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Self,\n-                           b: &Self)\n-        -> RelateResult<'tcx, Self>\n-            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n-\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self) -> RelateResult<'tcx, Self>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n+    {\n         if a.len() != b.len() {\n             return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n         }\n@@ -657,79 +713,103 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n }\n \n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::ClosureSubsts<'tcx>,\n-                           b: &ty::ClosureSubsts<'tcx>)\n-                           -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::ClosureSubsts<'tcx>,\n+        b: &ty::ClosureSubsts<'tcx>,\n+    ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::GeneratorSubsts<'tcx>,\n-                           b: &ty::GeneratorSubsts<'tcx>)\n-                           -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::GeneratorSubsts<'tcx>,\n+        b: &ty::GeneratorSubsts<'tcx>,\n+    ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &SubstsRef<'tcx>,\n-                           b: &SubstsRef<'tcx>)\n-                           -> RelateResult<'tcx, SubstsRef<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &SubstsRef<'tcx>,\n+        b: &SubstsRef<'tcx>,\n+    ) -> RelateResult<'tcx, SubstsRef<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relate_substs(relation, None, a, b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::Region<'tcx>,\n-                           b: &ty::Region<'tcx>)\n-                           -> RelateResult<'tcx, ty::Region<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::Region<'tcx>,\n+        b: &ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.regions(*a, *b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx ty::Const<'tcx>,\n-                           b: &&'tcx ty::Const<'tcx>)\n-                           -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &&'tcx ty::Const<'tcx>,\n+        b: &&'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.consts(*a, *b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::Binder<T>,\n-                           b: &ty::Binder<T>)\n-                           -> RelateResult<'tcx, ty::Binder<T>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(\n+        relation: &mut R,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         relation.binders(a, b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Rc<T>,\n-                           b: &Rc<T>)\n-                           -> RelateResult<'tcx, Rc<T>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Rc<T>, b: &Rc<T>) -> RelateResult<'tcx, Rc<T>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -738,11 +818,11 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &Box<T>,\n-                           b: &Box<T>)\n-                           -> RelateResult<'tcx, Box<T>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Box<T>, b: &Box<T>) -> RelateResult<'tcx, Box<T>>\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -754,10 +834,12 @@ impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &Kind<'tcx>,\n-        b: &Kind<'tcx>\n+        b: &Kind<'tcx>,\n     ) -> RelateResult<'tcx, Kind<'tcx>>\n     where\n-        R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a,\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'a + 'tcx,\n+        'tcx: 'a,\n     {\n         match (a.unpack(), b.unpack()) {\n             (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n@@ -786,9 +868,12 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &ty::TraitPredicate<'tcx>,\n-        b: &ty::TraitPredicate<'tcx>\n+        b: &ty::TraitPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(ty::TraitPredicate {\n             trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)?,\n@@ -802,7 +887,10 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n         a: &ty::ProjectionPredicate<'tcx>,\n         b: &ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(ty::ProjectionPredicate {\n             projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n@@ -815,9 +903,12 @@ impl<'tcx> Relate<'tcx> for traits::WhereClause<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::WhereClause<'tcx>,\n-        b: &traits::WhereClause<'tcx>\n+        b: &traits::WhereClause<'tcx>,\n     ) -> RelateResult<'tcx, traits::WhereClause<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::WhereClause::*;\n         match (a, b) {\n@@ -852,9 +943,12 @@ impl<'tcx> Relate<'tcx> for traits::WellFormed<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::WellFormed<'tcx>,\n-        b: &traits::WellFormed<'tcx>\n+        b: &traits::WellFormed<'tcx>,\n     ) -> RelateResult<'tcx, traits::WellFormed<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::WellFormed::*;\n         match (a, b) {\n@@ -869,9 +963,12 @@ impl<'tcx> Relate<'tcx> for traits::FromEnv<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::FromEnv<'tcx>,\n-        b: &traits::FromEnv<'tcx>\n+        b: &traits::FromEnv<'tcx>,\n     ) -> RelateResult<'tcx, traits::FromEnv<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::FromEnv::*;\n         match (a, b) {\n@@ -886,9 +983,12 @@ impl<'tcx> Relate<'tcx> for traits::DomainGoal<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::DomainGoal<'tcx>,\n-        b: &traits::DomainGoal<'tcx>\n+        b: &traits::DomainGoal<'tcx>,\n     ) -> RelateResult<'tcx, traits::DomainGoal<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::DomainGoal::*;\n         match (a, b) {\n@@ -909,9 +1009,12 @@ impl<'tcx> Relate<'tcx> for traits::Goal<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Goal<'tcx>,\n-        b: &traits::Goal<'tcx>\n+        b: &traits::Goal<'tcx>,\n     ) -> RelateResult<'tcx, traits::Goal<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::GoalKind::*;\n         match (a, b) {\n@@ -955,9 +1058,12 @@ impl<'tcx> Relate<'tcx> for traits::Goals<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Goals<'tcx>,\n-        b: &traits::Goals<'tcx>\n+        b: &traits::Goals<'tcx>,\n     ) -> RelateResult<'tcx, traits::Goals<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n@@ -973,9 +1079,12 @@ impl<'tcx> Relate<'tcx> for traits::Clause<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Clause<'tcx>,\n-        b: &traits::Clause<'tcx>\n+        b: &traits::Clause<'tcx>,\n     ) -> RelateResult<'tcx, traits::Clause<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         use crate::traits::Clause::*;\n         match (a, b) {\n@@ -998,9 +1107,12 @@ impl<'tcx> Relate<'tcx> for traits::Clauses<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Clauses<'tcx>,\n-        b: &traits::Clauses<'tcx>\n+        b: &traits::Clauses<'tcx>,\n     ) -> RelateResult<'tcx, traits::Clauses<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         if a.len() != b.len() {\n             return Err(TypeError::Mismatch);\n@@ -1016,9 +1128,12 @@ impl<'tcx> Relate<'tcx> for traits::ProgramClause<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::ProgramClause<'tcx>,\n-        b: &traits::ProgramClause<'tcx>\n+        b: &traits::ProgramClause<'tcx>,\n     ) -> RelateResult<'tcx, traits::ProgramClause<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(traits::ProgramClause {\n             goal: relation.relate(&a.goal, &b.goal)?,\n@@ -1032,9 +1147,12 @@ impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::Environment<'tcx>,\n-        b: &traits::Environment<'tcx>\n+        b: &traits::Environment<'tcx>,\n     ) -> RelateResult<'tcx, traits::Environment<'tcx>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(traits::Environment {\n             clauses: relation.relate(&a.clauses, &b.clauses)?,\n@@ -1043,14 +1161,18 @@ impl<'tcx> Relate<'tcx> for traits::Environment<'tcx> {\n }\n \n impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n-    where G: Relate<'tcx>\n+where\n+    G: Relate<'tcx>,\n {\n     fn relate<'a, 'gcx, R>(\n         relation: &mut R,\n         a: &traits::InEnvironment<'tcx, G>,\n-        b: &traits::InEnvironment<'tcx, G>\n+        b: &traits::InEnvironment<'tcx, G>,\n     ) -> RelateResult<'tcx, traits::InEnvironment<'tcx, G>>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'tcx, 'tcx: 'a\n+    where\n+        R: TypeRelation<'gcx, 'tcx>,\n+        'gcx: 'tcx,\n+        'tcx: 'a,\n     {\n         Ok(traits::InEnvironment {\n             environment: relation.relate(&a.environment, &b.environment)?,\n@@ -1062,11 +1184,12 @@ impl<'tcx, G> Relate<'tcx> for traits::InEnvironment<'tcx, G>\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R,\n-                                            a: &T,\n-                                            b: &T)\n-                                            -> ExpectedFound<T>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, T: Clone, 'gcx: 'a+'tcx, 'tcx: 'a\n+pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R, a: &T, b: &T) -> ExpectedFound<T>\n+where\n+    R: TypeRelation<'gcx, 'tcx>,\n+    T: Clone,\n+    'gcx: 'a + 'tcx,\n+    'tcx: 'a,\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }"}, {"sha": "35c61f83fceb2acc80da43f52affe637be2b14fe", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -337,14 +337,14 @@ CloneTypeFoldableAndLiftImpls! {\n // FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n     type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| {\n             tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n         })\n@@ -353,7 +353,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             Some(ref x) => tcx.lift(x).map(Some),\n             None => Some(None)\n@@ -363,7 +363,7 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n \n impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     type Lifted = Result<T::Lifted, E::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             Ok(ref x) => tcx.lift(x).map(Ok),\n             Err(ref e) => tcx.lift(e).map(Err)\n@@ -373,14 +373,14 @@ impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     type Lifted = Box<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&**self).map(Box::new)\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -397,14 +397,14 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self[..])\n     }\n }\n \n impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     type Lifted = IndexVec<I, T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         self.iter()\n             .map(|e| tcx.lift(e))\n             .collect()\n@@ -413,7 +413,7 @@ impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| ty::TraitRef {\n             def_id: self.def_id,\n             substs,\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef {\n             def_id: self.def_id,\n             substs,\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n     type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::ExistentialPredicate::Trait(x) => {\n                 tcx.lift(x).map(ty::ExistentialPredicate::Trait)\n@@ -450,8 +450,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref,\n         })\n@@ -460,8 +459,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<ty::SubtypePredicate<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n         tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n             a_is_expected: self.a_is_expected,\n             a,\n@@ -470,17 +468,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     }\n }\n \n-impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n+impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<ty::ProjectionTy<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ProjectionTy {\n                 item_def_id: self.item_def_id,\n@@ -492,8 +489,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty, self.ty)).map(|(projection_ty, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty,\n@@ -505,7 +501,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ExistentialProjection {\n                 substs,\n@@ -518,7 +514,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n     type Lifted = ty::Predicate<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::Predicate::Trait(ref binder) => {\n                 tcx.lift(binder).map(ty::Predicate::Trait)\n@@ -558,14 +554,14 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(self.skip_binder()).map(ty::Binder::bind)\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n@@ -578,7 +574,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n \n impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n     type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.param_env).and_then(|param_env| {\n             tcx.lift(&self.value).map(|value| {\n                 ty::ParamEnvAnd {\n@@ -592,7 +588,7 @@ impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::ClosureSubsts { substs }\n         })\n@@ -601,7 +597,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n     type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.substs).map(|substs| {\n             ty::GeneratorSubsts { substs }\n         })\n@@ -610,7 +606,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.kind).and_then(|kind| {\n             tcx.lift(&self.target).map(|target| {\n                 ty::adjustment::Adjustment { kind, target }\n@@ -621,7 +617,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n     type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::adjustment::Adjust::NeverToAny =>\n                 Some(ty::adjustment::Adjust::NeverToAny),\n@@ -639,7 +635,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.region).map(|region| {\n             ty::adjustment::OverloadedDeref {\n                 region,\n@@ -651,7 +647,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::adjustment::AutoBorrow::Ref(r, m) => {\n                 tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n@@ -665,7 +661,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.yield_ty, self.return_ty))\n            .map(|(yield_ty, return_ty)| {\n                ty::GenSig {\n@@ -678,7 +674,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.inputs_and_output).map(|x| {\n             ty::FnSig {\n                 inputs_and_output: x,\n@@ -692,7 +688,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.expected).and_then(|expected| {\n             tcx.lift(&self.found).map(|found| {\n                 ty::error::ExpectedFound {\n@@ -706,7 +702,7 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         use crate::ty::error::TypeError::*;\n \n         Some(match *self {\n@@ -743,7 +739,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::InstanceDef::Item(def_id) =>\n                 Some(ty::InstanceDef::Item(def_id)),"}, {"sha": "dc2d96ee8b946cb9f5e5edfaf3079561aa1a225e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 107, "deletions": 101, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -324,7 +324,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Divides the closure substs into their respective\n     /// components. Single source of truth with respect to the\n     /// ordering.\n-    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> SplitClosureSubsts<'tcx> {\n+    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> SplitClosureSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count;\n         SplitClosureSubsts {\n@@ -335,9 +335,11 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     }\n \n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'tcx\n-    {\n+    pub fn upvar_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'_, '_>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n             if let UnpackedKind::Type(ty) = t.unpack() {\n@@ -351,15 +353,15 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Returns the closure kind for this closure; may return a type\n     /// variable during inference. To get the closure kind during\n     /// inference, use `infcx.closure_kind(def_id, substs)`.\n-    pub fn closure_kind_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+    pub fn closure_kind_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).closure_kind_ty\n     }\n \n     /// Returns the type representing the closure signature for this\n     /// closure; may contain type variables during inference. To get\n     /// the closure signature during inference, use\n     /// `infcx.fn_sig(def_id)`.\n-    pub fn closure_sig_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+    pub fn closure_sig_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).closure_sig_ty\n     }\n \n@@ -368,7 +370,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_kind()`.\n-    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::ClosureKind {\n+    pub fn closure_kind(self, def_id: DefId, tcx: TyCtxt<'tcx, 'tcx>) -> ty::ClosureKind {\n         self.split(def_id, tcx).closure_kind_ty.to_opt_closure_kind().unwrap()\n     }\n \n@@ -377,7 +379,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// there are no type variables.\n     ///\n     /// If you have an inference context, use `infcx.closure_sig()`.\n-    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'_, 'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n+    pub fn closure_sig(self, def_id: DefId, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n@@ -401,7 +403,7 @@ struct SplitGeneratorSubsts<'tcx> {\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n-    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> SplitGeneratorSubsts<'tcx> {\n+    fn split(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> SplitGeneratorSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count;\n         SplitGeneratorSubsts {\n@@ -417,14 +419,16 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// It contains a tuple of all the types that could end up on a generator frame.\n     /// The state transformation MIR pass may only produce layouts which mention types\n     /// in this tuple. Upvars are not counted here.\n-    pub fn witness(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+    pub fn witness(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).witness\n     }\n \n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'tcx\n-    {\n+    pub fn upvar_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'_, '_>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitGeneratorSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n             if let UnpackedKind::Type(ty) = t.unpack() {\n@@ -436,12 +440,12 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     }\n \n     /// Returns the type representing the yield type of the generator.\n-    pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+    pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).yield_ty\n     }\n \n     /// Returns the type representing the return type of the generator.\n-    pub fn return_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> Ty<'tcx> {\n+    pub fn return_ty(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).return_ty\n     }\n \n@@ -451,21 +455,21 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// N.B., some bits of the code prefers to see this wrapped in a\n     /// binder, but it never contains bound regions. Probably this\n     /// function should be removed.\n-    pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> PolyGenSig<'tcx> {\n+    pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> PolyGenSig<'tcx> {\n         ty::Binder::dummy(self.sig(def_id, tcx))\n     }\n \n     /// Returns the \"generator signature\", which consists of its yield\n     /// and return types.\n-    pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> GenSig<'tcx> {\n+    pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_, '_>) -> GenSig<'tcx> {\n         ty::GenSig {\n             yield_ty: self.yield_ty(def_id, tcx),\n             return_ty: self.return_ty(def_id, tcx),\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n+impl<'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// Generator have not been resumed yet\n     pub const UNRESUMED: usize = 0;\n     /// Generator has returned / is completed\n@@ -479,7 +483,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// The valid variant indices of this Generator.\n     #[inline]\n-    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Range<VariantIdx> {\n+    pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'gcx, 'tcx>) -> Range<VariantIdx> {\n         // FIXME requires optimized MIR\n         let num_variants = tcx.generator_layout(def_id).variant_fields.len();\n         (VariantIdx::new(0)..VariantIdx::new(num_variants))\n@@ -489,7 +493,10 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// out of range.\n     #[inline]\n     pub fn discriminant_for_variant(\n-        &self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>, variant_index: VariantIdx\n+        &self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n         // Generators don't support explicit discriminant values, so they are\n         // the same as the variant index.\n@@ -501,8 +508,10 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// variant indices.\n     #[inline]\n     pub fn discriminants(\n-        &'a self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>\n-    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n+        &'tcx self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> {\n         self.variant_range(def_id, tcx).map(move |index| {\n             (index, Discr { val: index.as_usize() as u128, ty: self.discr_ty(tcx) })\n         })\n@@ -522,7 +531,7 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n \n     /// The type of the state discriminant used in the generator type.\n     #[inline]\n-    pub fn discr_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn discr_ty(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.types.u32\n     }\n \n@@ -533,9 +542,11 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// The locals are grouped by their variant number. Note that some locals may\n     /// be repeated in multiple variants.\n     #[inline]\n-    pub fn state_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=impl Iterator<Item=Ty<'tcx>> + Captures<'gcx> + 'a>\n-    {\n+    pub fn state_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = impl Iterator<Item = Ty<'tcx>> + Captures<'gcx>> {\n         let layout = tcx.generator_layout(def_id);\n         layout.variant_fields.iter().map(move |variant| {\n             variant.iter().map(move |field| {\n@@ -547,9 +558,11 @@ impl<'a, 'gcx, 'tcx> GeneratorSubsts<'tcx> {\n     /// This is the types of the fields of a generator which are not stored in a\n     /// variant.\n     #[inline]\n-    pub fn prefix_tys(self, def_id: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'a\n-    {\n+    pub fn prefix_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> {\n         self.upvar_tys(def_id, tcx)\n     }\n }\n@@ -562,9 +575,11 @@ pub enum UpvarSubsts<'tcx> {\n \n impl<'tcx> UpvarSubsts<'tcx> {\n     #[inline]\n-    pub fn upvar_tys(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) ->\n-        impl Iterator<Item=Ty<'tcx>> + 'tcx\n-    {\n+    pub fn upvar_tys(\n+        self,\n+        def_id: DefId,\n+        tcx: TyCtxt<'_, '_>,\n+    ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let upvar_kinds = match self {\n             UpvarSubsts::Closure(substs) => substs.split(def_id, tcx).upvar_kinds,\n             UpvarSubsts::Generator(substs) => substs.split(def_id, tcx).upvar_kinds,\n@@ -590,10 +605,10 @@ pub enum ExistentialPredicate<'tcx> {\n     AutoTrait(DefId),\n }\n \n-impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n+impl<'gcx, 'tcx> ExistentialPredicate<'tcx> {\n     /// Compares via an ordering that will not change if modules are reordered or other changes are\n     /// made to the tree. In particular, this ordering is preserved across incremental compilations.\n-    pub fn stable_cmp(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, other: &Self) -> Ordering {\n+    pub fn stable_cmp(&self, tcx: TyCtxt<'gcx, 'tcx>, other: &Self) -> Ordering {\n         use self::ExistentialPredicate::*;\n         match (*self, *other) {\n             (Trait(_), Trait(_)) => Ordering::Equal,\n@@ -607,12 +622,10 @@ impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n             (AutoTrait(_), _) => Ordering::Greater,\n         }\n     }\n-\n }\n \n-impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n-        -> ty::Predicate<'tcx> {\n+impl<'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match *self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n@@ -744,7 +757,7 @@ impl<'tcx> TraitRef<'tcx> {\n \n     /// Returns a `TraitRef` of the form `P0: Foo<P1..Pn>` where `Pi`\n     /// are the parameters defined on trait.\n-    pub fn identity<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n+    pub fn identity<'gcx>(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> TraitRef<'tcx> {\n         TraitRef {\n             def_id,\n             substs: InternalSubsts::identity_for_item(tcx, def_id),\n@@ -764,10 +777,11 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.types()\n     }\n \n-    pub fn from_method(tcx: TyCtxt<'_, '_, 'tcx>,\n-                       trait_id: DefId,\n-                       substs: SubstsRef<'tcx>)\n-                       -> ty::TraitRef<'tcx> {\n+    pub fn from_method(\n+        tcx: TyCtxt<'_, 'tcx>,\n+        trait_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> ty::TraitRef<'tcx> {\n         let defs = tcx.generics_of(trait_id);\n \n         ty::TraitRef {\n@@ -808,7 +822,7 @@ pub struct ExistentialTraitRef<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n+impl<'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'b {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n@@ -817,9 +831,10 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n         self.substs.types()\n     }\n \n-    pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         trait_ref: ty::TraitRef<'tcx>)\n-                         -> ty::ExistentialTraitRef<'tcx> {\n+    pub fn erase_self_ty(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+    ) -> ty::ExistentialTraitRef<'tcx> {\n         // Assert there is a Self.\n         trait_ref.substs.type_at(0);\n \n@@ -833,8 +848,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n-        -> ty::TraitRef<'tcx>  {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'gcx, 'tcx>, self_ty: Ty<'tcx>) -> ty::TraitRef<'tcx> {\n         // otherwise the escaping vars would be captured by the binder\n         // debug_assert!(!self_ty.has_escaping_bound_vars());\n \n@@ -856,9 +870,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'_, '_, 'tcx>,\n-                        self_ty: Ty<'tcx>)\n-                        -> ty::PolyTraitRef<'tcx>  {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'_, 'tcx>, self_ty: Ty<'tcx>) -> ty::PolyTraitRef<'tcx> {\n         self.map_bound(|trait_ref| trait_ref.with_self_ty(tcx, self_ty))\n     }\n }\n@@ -992,7 +1004,9 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// Construct a `ProjectionTy` by searching the trait from `trait_ref` for the\n     /// associated item named `item_name`.\n     pub fn from_ref_and_name(\n-        tcx: TyCtxt<'_, '_, '_>, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n+        tcx: TyCtxt<'_, '_>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        item_name: Ident,\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx.associated_items(trait_ref.def_id).find(|item| {\n             item.kind == ty::AssocKind::Type &&\n@@ -1008,7 +1022,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     /// Extracts the underlying trait reference from this projection.\n     /// For example, if this is a projection of `<T as Iterator>::Item`,\n     /// then this function would return a `T: Iterator` trait reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> ty::TraitRef<'tcx> {\n+    pub fn trait_ref(&self, tcx: TyCtxt<'_, '_>) -> ty::TraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::TraitRef {\n             def_id,\n@@ -1112,7 +1126,7 @@ pub struct ParamTy {\n     pub name: InternedString,\n }\n \n-impl<'a, 'gcx, 'tcx> ParamTy {\n+impl<'gcx, 'tcx> ParamTy {\n     pub fn new(index: u32, name: InternedString) -> ParamTy {\n         ParamTy { index, name: name }\n     }\n@@ -1125,7 +1139,7 @@ impl<'a, 'gcx, 'tcx> ParamTy {\n         ParamTy::new(def.index, def.name)\n     }\n \n-    pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n \n@@ -1144,7 +1158,7 @@ pub struct ParamConst {\n     pub name: InternedString,\n }\n \n-impl<'a, 'gcx, 'tcx> ParamConst {\n+impl<'gcx, 'tcx> ParamConst {\n     pub fn new(index: u32, name: InternedString) -> ParamConst {\n         ParamConst { index, name }\n     }\n@@ -1153,7 +1167,7 @@ impl<'a, 'gcx, 'tcx> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n \n-    pub fn to_const(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+    pub fn to_const(self, tcx: TyCtxt<'gcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n         tcx.mk_const_param(self.index, self.name, ty)\n     }\n }\n@@ -1408,23 +1422,24 @@ pub struct ExistentialProjection<'tcx> {\n \n pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n \n-impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n+impl<'tcx, 'gcx> ExistentialProjection<'tcx> {\n     /// Extracts the underlying existential trait reference from this projection.\n     /// For example, if this is a projection of `exists T. <T as Iterator>::Item == X`,\n     /// then this function would return a `exists T. T: Iterator` existential trait\n     /// reference.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'_, '_, '_>) -> ty::ExistentialTraitRef<'tcx> {\n+    pub fn trait_ref(&self, tcx: TyCtxt<'_, '_>) -> ty::ExistentialTraitRef<'tcx> {\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::ExistentialTraitRef{\n             def_id,\n             substs: self.substs,\n         }\n     }\n \n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        self_ty: Ty<'tcx>)\n-                        -> ty::ProjectionPredicate<'tcx>\n-    {\n+    pub fn with_self_ty(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        self_ty: Ty<'tcx>,\n+    ) -> ty::ProjectionPredicate<'tcx> {\n         // otherwise the escaping regions would be captured by the binders\n         debug_assert!(!self_ty.has_escaping_bound_vars());\n \n@@ -1438,9 +1453,12 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n-    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n-        -> ty::PolyProjectionPredicate<'tcx> {\n+impl<'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+    pub fn with_self_ty(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        self_ty: Ty<'tcx>,\n+    ) -> ty::PolyProjectionPredicate<'tcx> {\n         self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n \n@@ -1652,7 +1670,7 @@ impl RegionKind {\n     /// of the impl, and for all the other highlighted regions, it\n     /// would return the `DefId` of the function. In other cases (not shown), this\n     /// function might return the `DefId` of a closure.\n-    pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_, '_>) -> DefId {\n+    pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_>) -> DefId {\n         match self {\n             ty::ReEarlyBound(br) => {\n                 tcx.parent(br.def_id).unwrap()\n@@ -1664,7 +1682,7 @@ impl RegionKind {\n }\n \n /// Type utilities\n-impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n+impl<'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_unit(&self) -> bool {\n         match self.sty {\n@@ -1687,7 +1705,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// `ty.conservative_is_privately_uninhabited` implies that any value of type `ty`\n     /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n     /// size, to account for partial initialisation. See #49298 for details.)\n-    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n         // FIXME(varkor): we can make this less conversative by substituting concrete\n         // type arguments.\n         match self.sty {\n@@ -1799,15 +1817,15 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             Array(ty, _) | Slice(ty) => ty,\n             Str => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             Adt(def, substs) => {\n                 def.non_enum_variant().fields[0].ty(tcx, substs)\n@@ -1816,7 +1834,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn simd_size(&self, _cx: TyCtxt<'_, '_, '_>) -> usize {\n+    pub fn simd_size(&self, _cx: TyCtxt<'_, '_>) -> usize {\n         match self.sty {\n             Adt(def, _) => def.non_enum_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")\n@@ -2036,7 +2054,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, tcx: TyCtxt<'gcx, 'tcx>) -> PolyFnSig<'tcx> {\n         match self.sty {\n             FnDef(def_id, substs) => {\n                 tcx.fn_sig(def_id).subst(tcx, substs)\n@@ -2084,7 +2102,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// If the type contains variants, returns the valid range of variant indices.\n     /// FIXME This requires the optimized MIR in the case of generators.\n     #[inline]\n-    pub fn variant_range(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Range<VariantIdx>> {\n+    pub fn variant_range(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Range<VariantIdx>> {\n         match self.sty {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => Some(substs.variant_range(def_id, tcx)),\n@@ -2098,8 +2116,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn discriminant_for_variant(\n         &self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        variant_index: VariantIdx\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.sty {\n             TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n@@ -2189,7 +2207,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     ///\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n-    pub fn is_trivially_sized(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> bool {\n+    pub fn is_trivially_sized(&self, tcx: TyCtxt<'_, 'tcx>) -> bool {\n         match self.sty {\n             ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) |\n             ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n@@ -2239,11 +2257,7 @@ static_assert_size!(Const<'_>, 40);\n \n impl<'tcx> Const<'tcx> {\n     #[inline]\n-    pub fn from_scalar(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: Scalar,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx Self {\n+    pub fn from_scalar(tcx: TyCtxt<'_, 'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n         tcx.mk_const(Self {\n             val: ConstValue::Scalar(val),\n             ty,\n@@ -2252,7 +2266,7 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn from_bits(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         bits: u128,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> &'tcx Self {\n@@ -2264,26 +2278,22 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+    pub fn zero_sized(tcx: TyCtxt<'_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]\n-    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n+    pub fn from_bool(tcx: TyCtxt<'_, 'tcx>, v: bool) -> &'tcx Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n-    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n+    pub fn from_usize(tcx: TyCtxt<'_, 'tcx>, n: u64) -> &'tcx Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n-    pub fn to_bits(\n-        &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> Option<u128> {\n+    pub fn to_bits(&self, tcx: TyCtxt<'_, 'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         if self.ty != ty.value {\n             return None;\n         }\n@@ -2300,7 +2310,7 @@ impl<'tcx> Const<'tcx> {\n     #[inline]\n     pub fn assert_bits(\n         &self,\n-        tcx: TyCtxt<'_, '_, '_>,\n+        tcx: TyCtxt<'_, '_>,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> Option<u128> {\n         assert_eq!(self.ty, ty.value);\n@@ -2310,7 +2320,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bool(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<bool> {\n+    pub fn assert_bool(&self, tcx: TyCtxt<'_, '_>) -> Option<bool> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n@@ -2319,22 +2329,18 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n+    pub fn assert_usize(&self, tcx: TyCtxt<'_, '_>) -> Option<u64> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(\n-        &self,\n-        tcx: TyCtxt<'_, '_, '_>,\n-        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> u128 {\n+    pub fn unwrap_bits(&self, tcx: TyCtxt<'_, '_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n         self.assert_bits(tcx, ty).unwrap_or_else(||\n             bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n     }\n \n     #[inline]\n-    pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n+    pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_>) -> u64 {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }"}, {"sha": "a47217138aa1a631a8081fafb7f19d13ef3b1438", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> Kind<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n     type Lifted = Kind<'tcx>;\n \n-    fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n             UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n             UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n@@ -184,7 +184,7 @@ pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// Creates a `InternalSubsts` that maps each generic parameter to itself.\n-    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+    pub fn identity_for_item(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             tcx.mk_param_from_def(param)\n         })\n@@ -194,10 +194,7 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n     /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n     /// variant (which has a `DefId`).\n-    pub fn bound_vars_for_item(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        def_id: DefId\n-    ) -> SubstsRef<'tcx> {\n+    pub fn bound_vars_for_item(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n         Self::for_item(tcx, def_id, |param, _| {\n             match param.kind {\n                 ty::GenericParamDefKind::Type { .. } => {\n@@ -233,11 +230,9 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// The closures get to observe the `InternalSubsts` as they're\n     /// being built, which can be used to correctly\n     /// substitute defaults of generic parameters.\n-    pub fn for_item<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                       def_id: DefId,\n-                       mut mk_kind: F)\n-                       -> SubstsRef<'tcx>\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    pub fn for_item<F>(tcx: TyCtxt<'gcx, 'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n+    where\n+        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n         let defs = tcx.generics_of(def_id);\n         let count = defs.count();\n@@ -246,12 +241,14 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         tcx.intern_substs(&substs)\n     }\n \n-    pub fn extend_to<F>(&self,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        def_id: DefId,\n-                        mut mk_kind: F)\n-                        -> SubstsRef<'tcx>\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    pub fn extend_to<F>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        def_id: DefId,\n+        mut mk_kind: F,\n+    ) -> SubstsRef<'tcx>\n+    where\n+        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n         Self::for_item(tcx, def_id, |param, substs| {\n             self.get(param.index as usize)\n@@ -260,11 +257,13 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n         })\n     }\n \n-    fn fill_item<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    defs: &ty::Generics,\n-                    mk_kind: &mut F)\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    fn fill_item<F>(\n+        substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        defs: &ty::Generics,\n+        mk_kind: &mut F,\n+    ) where\n+        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n     {\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n@@ -372,16 +371,17 @@ impl<'a, 'gcx, 'tcx> InternalSubsts<'tcx> {\n     /// in a different item, with `target_substs` as the base for\n     /// the target impl/trait, with the source child-specific\n     /// parameters (e.g., method parameters) on top of that base.\n-    pub fn rebase_onto(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                       source_ancestor: DefId,\n-                       target_substs: SubstsRef<'tcx>)\n-                       -> SubstsRef<'tcx> {\n+    pub fn rebase_onto(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        source_ancestor: DefId,\n+        target_substs: SubstsRef<'tcx>,\n+    ) -> SubstsRef<'tcx> {\n         let defs = tcx.generics_of(source_ancestor);\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.params.len()..]).cloned())\n     }\n \n-    pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics)\n-                       -> SubstsRef<'tcx> {\n+    pub fn truncate_to(&self, tcx: TyCtxt<'gcx, 'tcx>, generics: &ty::Generics) -> SubstsRef<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())\n     }\n }\n@@ -414,23 +414,25 @@ impl<'tcx> serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx>: Sized {\n-    fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                       substs: &[Kind<'tcx>]) -> Self {\n+    fn subst<'gcx>(&self, tcx: TyCtxt<'gcx, 'tcx>, substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                               substs: &[Kind<'tcx>],\n-                               span: Option<Span>)\n-                               -> Self;\n+    fn subst_spanned<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: &[Kind<'tcx>],\n+        span: Option<Span>,\n+    ) -> Self;\n }\n \n-impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                               substs: &[Kind<'tcx>],\n-                               span: Option<Span>)\n-                               -> T\n-    {\n+impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n+    fn subst_spanned<'gcx>(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        substs: &[Kind<'tcx>],\n+        span: Option<Span>,\n+    ) -> T {\n         let mut folder = SubstFolder { tcx,\n                                        substs,\n                                        span,\n@@ -444,8 +446,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+struct SubstFolder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     substs: &'a [Kind<'tcx>],\n \n     /// The location for which the substitution is performed, if available.\n@@ -462,7 +464,7 @@ struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.binders_passed += 1;"}, {"sha": "1f99d97605c792327b1088b017bc2aaf3ea75ee2", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -46,7 +46,7 @@ pub struct TraitImpls {\n     non_blanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n }\n \n-impl<'a, 'gcx, 'tcx> TraitDef {\n+impl<'gcx, 'tcx> TraitDef {\n     pub fn new(def_id: DefId,\n                unsafety: hir::Unsafety,\n                paren_sugar: bool,\n@@ -64,14 +64,16 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         }\n     }\n \n-    pub fn ancestors(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     of_impl: DefId)\n-                     -> specialization_graph::Ancestors<'gcx> {\n+    pub fn ancestors(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        of_impl: DefId,\n+    ) -> specialization_graph::Ancestors<'gcx> {\n         specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn for_each_impl<F: FnMut(DefId)>(self, def_id: DefId, mut f: F) {\n         let impls = self.trait_impls_of(def_id);\n \n@@ -148,9 +150,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n // Query provider for `trait_impls_of`.\n-pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                trait_id: DefId)\n-                                                -> &'tcx TraitImpls {\n+pub(super) fn trait_impls_of_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_id: DefId,\n+) -> &'tcx TraitImpls {\n     let mut impls = TraitImpls::default();\n \n     {"}, {"sha": "57319db63404a8619bc331d95ce6e4998bcba73c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 65, "deletions": 74, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -51,10 +51,10 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n \n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n-    pub fn wrap_incr<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn wrap_incr<'gcx>(self, tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n-    pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n+    pub fn checked_add<'gcx>(self, tcx: TyCtxt<'gcx, 'tcx>, n: u128) -> (Self, bool) {\n         let (int, signed) = match self.ty.sty {\n             Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n             Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n@@ -104,14 +104,17 @@ impl<'tcx> Discr<'tcx> {\n }\n \n pub trait IntTypeExt {\n-    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Discr<'tcx>>)\n-                           -> Option<Discr<'tcx>>;\n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx>;\n+    fn to_ty<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        val: Option<Discr<'tcx>>,\n+    ) -> Option<Discr<'tcx>>;\n+    fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Discr<'tcx>;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'gcx, 'tcx>(&self, tcx: TyCtxt<'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             SignedInt(ast::IntTy::I8)       => tcx.types.i8,\n             SignedInt(ast::IntTy::I16)      => tcx.types.i16,\n@@ -128,16 +131,16 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx> {\n+    fn initial_discriminant<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Discr<'tcx> {\n         Discr {\n             val: 0,\n             ty: self.to_ty(tcx)\n         }\n     }\n \n-    fn disr_incr<'a, 'tcx>(\n+    fn disr_incr<'tcx>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         val: Option<Discr<'tcx>>,\n     ) -> Option<Discr<'tcx>> {\n         if let Some(val) = val {\n@@ -178,10 +181,11 @@ pub enum Representability {\n }\n \n impl<'tcx> ty::ParamEnv<'tcx> {\n-    pub fn can_type_implement_copy<'a>(self,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       self_type: Ty<'tcx>)\n-                                       -> Result<(), CopyImplementationError<'tcx>> {\n+    pub fn can_type_implement_copy(\n+        self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        self_type: Ty<'tcx>,\n+    ) -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt().enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n@@ -228,7 +232,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'tcx> TyCtxt<'tcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n@@ -249,7 +253,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> TyCtxt<'gcx, 'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         if let ty::Adt(def, substs) = ty.sty {\n             for field in def.all_fields() {\n@@ -624,18 +628,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ) -> Result<Ty<'tcx>, Ty<'tcx>> {\n         use crate::ty::fold::TypeFolder;\n \n-        struct OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+        struct OpaqueTypeExpander<'gcx, 'tcx> {\n             // Contains the DefIds of the opaque types that are currently being\n             // expanded. When we expand an opaque type we insert the DefId of\n             // that type, and when we finish expanding that type we remove the\n             // its DefId.\n             seen_opaque_tys: FxHashSet<DefId>,\n             primary_def_id: DefId,\n             found_recursion: bool,\n-            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            tcx: TyCtxt<'gcx, 'tcx>,\n         }\n \n-        impl<'a, 'gcx, 'tcx> OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n+        impl<'gcx, 'tcx> OpaqueTypeExpander<'gcx, 'tcx> {\n             fn expand_opaque_ty(\n                 &mut self,\n                 def_id: DefId,\n@@ -658,8 +662,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpaqueTypeExpander<'a, 'gcx, 'tcx> {\n-            fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        impl<'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpaqueTypeExpander<'gcx, 'tcx> {\n+            fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n                 self.tcx\n             }\n \n@@ -687,19 +691,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ty::TyS<'tcx> {\n+impl<'tcx> ty::TyS<'tcx> {\n     /// Checks whether values of this type `T` are *moved* or *copied*\n     /// when referenced -- this amounts to a check for whether `T:\n     /// Copy`, but note that we **don't** consider lifetimes when\n     /// doing this check. This means that we may generate MIR which\n     /// does copies even when the type actually doesn't satisfy the\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n-    pub fn is_copy_modulo_regions(&'tcx self,\n-                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  param_env: ty::ParamEnv<'tcx>,\n-                                  span: Span)\n-                                  -> bool {\n+    pub fn is_copy_modulo_regions(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         tcx.at(span).is_copy_raw(param_env.and(self))\n     }\n \n@@ -709,10 +714,11 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(&'tcx self,\n-                    tcx_at: TyCtxtAt<'a, 'tcx, 'tcx>,\n-                    param_env: ty::ParamEnv<'tcx>)-> bool\n-    {\n+    pub fn is_sized(\n+        &'tcx self,\n+        tcx_at: TyCtxtAt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n         tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n@@ -723,11 +729,12 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(&'tcx self,\n-                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     param_env: ty::ParamEnv<'tcx>,\n-                     span: Span)-> bool\n-    {\n+    pub fn is_freeze(\n+        &'tcx self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         tcx.at(span).is_freeze_raw(param_env.and(self))\n     }\n \n@@ -738,10 +745,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n     #[inline]\n-    pub fn needs_drop(&'tcx self,\n-                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                      param_env: ty::ParamEnv<'tcx>)\n-                      -> bool {\n+    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0\n     }\n \n@@ -760,11 +764,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            sp: Span)\n-                            -> Representability\n-    {\n+    pub fn is_representable(&'tcx self, tcx: TyCtxt<'tcx, 'tcx>, sp: Span) -> Representability {\n         // Iterate until something non-representable is found\n         fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n             iter.fold(Representability::Representable, |r1, r2| {\n@@ -778,13 +778,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             })\n         }\n \n-        fn are_inner_types_recursive<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n+        fn are_inner_types_recursive<'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n+            sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>)\n-            -> Representability\n-        {\n+            ty: Ty<'tcx>,\n+        ) -> Representability {\n             match ty.sty {\n                 Tuple(ref ts) => {\n                     // Find non representable\n@@ -838,13 +838,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        fn is_type_structurally_recursive<'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>) -> Representability\n-        {\n+            ty: Ty<'tcx>,\n+        ) -> Representability {\n             debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n             if let Some(representability) = representable_cache.get(ty) {\n                 debug!(\"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n@@ -859,13 +859,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             representability\n         }\n \n-        fn is_type_structurally_recursive_inner<'a, 'tcx>(\n-            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        fn is_type_structurally_recursive_inner<'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n             sp: Span,\n             seen: &mut Vec<Ty<'tcx>>,\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n-            ty: Ty<'tcx>) -> Representability\n-        {\n+            ty: Ty<'tcx>,\n+        ) -> Representability {\n             match ty.sty {\n                 Adt(def, _) => {\n                     {\n@@ -937,10 +937,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                         -> bool\n-{\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n     tcx.infer_ctxt()\n@@ -953,10 +950,7 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ))\n }\n \n-fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                          -> bool\n-{\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n     tcx.infer_ctxt()\n@@ -969,10 +963,7 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ))\n }\n \n-fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                           -> bool\n-{\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n     tcx.infer_ctxt()\n@@ -988,10 +979,10 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n-                            -> NeedsDrop\n-{\n+fn needs_drop_raw<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> NeedsDrop {\n     let (param_env, ty) = query.into_parts();\n \n     let needs_drop = |ty: Ty<'tcx>| -> bool {"}, {"sha": "1ed88f395a9430d3d7f192c68afda94189bef819", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -508,11 +508,10 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>)\n-    -> Vec<ty::Region<'tcx>>\n-{\n+pub fn object_region_bounds<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n+) -> Vec<ty::Region<'tcx>> {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a placeholder type."}, {"sha": "45a92daab0dfb602101ceefbca6e01c9dfb8cd93", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -80,8 +80,8 @@ fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'\n \n struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n-    move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n+    dfcx_loans: &'a LoanDataFlow<'tcx>,\n+    move_data: &'a move_data::FlowedMoveData<'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n     movable_generator: bool,\n }\n@@ -179,11 +179,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n }\n \n-pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                     dfcx_loans: &LoanDataFlow<'b, 'tcx>,\n-                                     move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n-                                     all_loans: &[Loan<'tcx>],\n-                                     body: &hir::Body) {\n+pub fn check_loans<'a, 'tcx>(\n+    bccx: &BorrowckCtxt<'a, 'tcx>,\n+    dfcx_loans: &LoanDataFlow<'tcx>,\n+    move_data: &move_data::FlowedMoveData<'tcx>,\n+    all_loans: &[Loan<'tcx>],\n+    body: &hir::Body,\n+) {\n     debug!(\"check_loans(body id={})\", body.value.hir_id);\n \n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n@@ -229,7 +231,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n }\n \n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,"}, {"sha": "7a8a62edea1a3d47f3e29ba5e1ad5ad352b0bbed", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -45,7 +45,7 @@ pub enum PatternSource<'tcx> {\n ///\n /// In this latter case, this function will return `PatternSource::LetDecl`\n /// with a reference to the let\n-fn get_pattern_source<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n+fn get_pattern_source<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, pat: &Pat) -> PatternSource<'tcx> {\n \n     let parent = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n "}, {"sha": "8bdfa1352cbe0f51ab12ce870ab427e9720fd4cb", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -251,7 +251,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.bccx.tcx }\n \n     /// Guarantees that `cmt` is assignable, or reports an error.\n     fn guarantee_assignment_valid(&mut self,"}, {"sha": "e8644d2416db7e8f288d391a7a8652907e97d4d6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -51,9 +51,9 @@ pub mod move_data;\n #[derive(Clone, Copy)]\n pub struct LoanDataFlowOperator;\n \n-pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n+pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().borrowck(body_owner_def_id);\n     });\n@@ -67,15 +67,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'a, 'tcx: 'a> {\n+pub struct AnalysisData<'tcx> {\n     pub all_loans: Vec<Loan<'tcx>>,\n-    pub loans: DataFlowContext<'a, 'tcx, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n+    pub loans: DataFlowContext<'tcx, LoanDataFlowOperator>,\n+    pub move_data: move_data::FlowedMoveData<'tcx>,\n }\n \n-fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n-    -> &'tcx BorrowCheckResult\n-{\n+fn borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, owner_def_id: DefId) -> &'tcx BorrowCheckResult {\n     assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n \n     debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n@@ -141,12 +139,14 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     })\n }\n \n-fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                                 force_analysis: bool,\n-                                                 body_id: hir::BodyId,\n-                                                 get_cfg: F)\n-                                                 -> Option<AnalysisData<'a, 'tcx>>\n-    where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n+fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(\n+    this: &mut BorrowckCtxt<'a, 'tcx>,\n+    force_analysis: bool,\n+    body_id: hir::BodyId,\n+    get_cfg: F,\n+) -> Option<AnalysisData<'tcx>>\n+where\n+    F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG,\n {\n     // Check the body of fn items.\n     let (all_loans, move_data) =\n@@ -193,11 +193,10 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body_id: hir::BodyId,\n-    cfg: &cfg::CFG)\n-    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n-{\n+    cfg: &cfg::CFG,\n+) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n     let owner_id = tcx.hir().body_owner(body_id);\n     let owner_def_id = tcx.hir().local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n@@ -220,8 +219,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct BorrowckCtxt<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n \n     // tables for the current thing we are checking; set to\n     // Some in `borrowck_fn` and cleared later\n@@ -238,14 +237,13 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     signalled_any_error: Cell<SignalledError>,\n }\n \n-\n-impl<'a, 'tcx: 'a> BorrowckCtxt<'a, 'tcx> {\n+impl BorrowckCtxt<'_, 'tcx> {\n     fn signal_error(&self) {\n         self.signalled_any_error.set(SignalledError::SawSomeError);\n     }\n }\n \n-impl<'a, 'b, 'tcx: 'b> BorrowckErrors<'a> for &'a BorrowckCtxt<'b, 'tcx> {\n+impl BorrowckErrors<'a> for &'a BorrowckCtxt<'_, 'tcx> {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n                                                      sp: S,\n                                                      msg: &str,\n@@ -390,8 +388,7 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-fn closure_to_block(closure_id: LocalDefId,\n-                    tcx: TyCtxt<'_, '_, '_>) -> HirId {\n+fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_, '_>) -> HirId {\n     let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n     match tcx.hir().get(closure_id) {\n         Node::Expr(expr) => match expr.node {\n@@ -406,8 +403,8 @@ fn closure_to_block(closure_id: LocalDefId,\n     }\n }\n \n-impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n+impl LoanPath<'tcx> {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'_, 'tcx>) -> region::Scope {\n         match self.kind {\n             LpVar(hir_id) => {\n                 bccx.region_scope_tree.var_scope(hir_id.local_id)\n@@ -577,7 +574,7 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n+impl BorrowckCtxt<'_, 'tcx> {\n     pub fn is_subregion_of(&self,\n                            r_sub: ty::Region<'tcx>,\n                            r_sup: ty::Region<'tcx>)"}, {"sha": "38bf590a36fb8e7fbaab6c8dd871be3fb9dfad3e", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -39,15 +39,15 @@ pub struct MoveData<'tcx> {\n     pub path_assignments: RefCell<Vec<Assignment>>,\n }\n \n-pub struct FlowedMoveData<'a, 'tcx: 'a> {\n+pub struct FlowedMoveData<'tcx> {\n     pub move_data: MoveData<'tcx>,\n \n-    pub dfcx_moves: MoveDataFlow<'a, 'tcx>,\n+    pub dfcx_moves: MoveDataFlow<'tcx>,\n \n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'a, 'tcx>\n+    pub dfcx_assign: AssignDataFlow<'tcx>,\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -139,12 +139,12 @@ pub struct Assignment {\n #[derive(Clone, Copy)]\n pub struct MoveDataFlowOperator;\n \n-pub type MoveDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, MoveDataFlowOperator>;\n+pub type MoveDataFlow<'tcx> = DataFlowContext<'tcx, MoveDataFlowOperator>;\n \n #[derive(Clone, Copy)]\n pub struct AssignDataFlowOperator;\n \n-pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;\n+pub type AssignDataFlow<'tcx> = DataFlowContext<'tcx, AssignDataFlowOperator>;\n \n fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n     match loan_path.kind {\n@@ -167,7 +167,7 @@ fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n     }\n }\n \n-impl<'a, 'tcx> MoveData<'tcx> {\n+impl MoveData<'tcx> {\n     /// Returns `true` if there are no trackable assignments or moves\n     /// in this move data -- that means that there is nothing that\n     /// could cause a borrow error.\n@@ -223,8 +223,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                     lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n+    pub fn move_path(&self, tcx: TyCtxt<'tcx, 'tcx>, lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         if let Some(&index) = self.path_map.borrow().get(&lp) {\n             return index;\n         }\n@@ -311,10 +310,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     }\n \n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    orig_lp: Rc<LoanPath<'tcx>>,\n-                    id: hir::ItemLocalId,\n-                    kind: MoveKind) {\n+    pub fn add_move(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        orig_lp: Rc<LoanPath<'tcx>>,\n+        id: hir::ItemLocalId,\n+        kind: MoveKind,\n+    ) {\n         // Moving one union field automatically moves all its fields. Also move siblings of\n         // all parent union fields, moves do not propagate upwards automatically.\n         let mut lp = orig_lp.clone();\n@@ -340,10 +342,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.add_move_helper(tcx, orig_lp, id, kind);\n     }\n \n-    fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       lp: Rc<LoanPath<'tcx>>,\n-                       id: hir::ItemLocalId,\n-                       kind: MoveKind) {\n+    fn add_move_helper(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        lp: Rc<LoanPath<'tcx>>,\n+        id: hir::ItemLocalId,\n+        kind: MoveKind,\n+    ) {\n         debug!(\"add_move(lp={:?}, id={:?}, kind={:?})\",\n                lp,\n                id,\n@@ -365,10 +370,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n     /// `span`.\n-    pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          lp: Rc<LoanPath<'tcx>>,\n-                          assign_id: hir::ItemLocalId,\n-                          span: Span) {\n+    pub fn add_assignment(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        lp: Rc<LoanPath<'tcx>>,\n+        assign_id: hir::ItemLocalId,\n+        span: Span,\n+    ) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n             if let ty::Adt(adt_def, _) = base_lp.ty.sty {\n@@ -395,10 +403,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.add_assignment_helper(tcx, lp, assign_id, span);\n     }\n \n-    fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             lp: Rc<LoanPath<'tcx>>,\n-                             assign_id: hir::ItemLocalId,\n-                             span: Span) {\n+    fn add_assignment_helper(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        lp: Rc<LoanPath<'tcx>>,\n+        assign_id: hir::ItemLocalId,\n+        span: Span,\n+    ) {\n         debug!(\"add_assignment(lp={:?}, assign_id={:?}\", lp, assign_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -427,10 +438,12 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self,\n-                     bccx: &BorrowckCtxt<'a, 'tcx>,\n-                     dfcx_moves: &mut MoveDataFlow<'_, '_>,\n-                     dfcx_assign: &mut AssignDataFlow<'_, '_>) {\n+    fn add_gen_kills(\n+        &self,\n+        bccx: &BorrowckCtxt<'_, 'tcx>,\n+        dfcx_moves: &mut MoveDataFlow<'_>,\n+        dfcx_assign: &mut AssignDataFlow<'_>,\n+    ) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n             dfcx_moves.add_gen(the_move.id, i);\n         }\n@@ -534,11 +547,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         ret\n     }\n \n-    fn kill_moves(&self,\n-                  path: MovePathIndex,\n-                  kill_id: hir::ItemLocalId,\n-                  kill_kind: KillFrom,\n-                  dfcx_moves: &mut MoveDataFlow<'_, '_>) {\n+    fn kill_moves(\n+        &self,\n+        path: MovePathIndex,\n+        kill_id: hir::ItemLocalId,\n+        kill_kind: KillFrom,\n+        dfcx_moves: &mut MoveDataFlow<'_>,\n+    ) {\n         // We can only perform kills for paths that refer to a unique location,\n         // since otherwise we may kill a move from one location with an\n         // assignment referring to another location.\n@@ -555,12 +570,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n-    pub fn new(move_data: MoveData<'tcx>,\n-               bccx: &BorrowckCtxt<'a, 'tcx>,\n-               cfg: &cfg::CFG,\n-               body: &hir::Body)\n-               -> FlowedMoveData<'a, 'tcx> {\n+impl<'tcx> FlowedMoveData<'tcx> {\n+    pub fn new(\n+        move_data: MoveData<'tcx>,\n+        bccx: &BorrowckCtxt<'_, 'tcx>,\n+        cfg: &cfg::CFG,\n+        body: &hir::Body,\n+    ) -> FlowedMoveData<'tcx> {\n         let tcx = bccx.tcx;\n \n         let mut dfcx_moves ="}, {"sha": "a42fbb72c03a81ff2da3ac73eb2aa6e3205b2c19", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -26,8 +26,8 @@ pub enum EntryOrExit {\n }\n \n #[derive(Clone)]\n-pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DataFlowContext<'tcx, O> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -51,7 +51,6 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     // `id_range`, there is a range of words equal to `words_per_id`.\n     // So, to access the bits for any given id, you take a slice of\n     // the full vector (see the method `compute_id_range()`).\n-\n     /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n     gens: Vec<usize>,\n \n@@ -80,9 +79,9 @@ pub trait DataFlowOperator : BitwiseOperator {\n     fn initial_value(&self) -> bool;\n }\n \n-struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O> {\n-    dfcx: &'a mut DataFlowContext<'b, 'tcx, O>,\n-    changed: bool\n+struct PropagationContext<'a, 'tcx, O> {\n+    dfcx: &'a mut DataFlowContext<'tcx, O>,\n+    changed: bool,\n }\n \n fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n@@ -91,14 +90,14 @@ fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n     index.get(&id).map_or(&[], |v| &v[..])\n }\n \n-impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n+impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n     fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n         assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n         self.local_id_to_index.contains_key(&n)\n     }\n }\n \n-impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n+impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n     fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) -> io::Result<()> {\n         pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n@@ -224,13 +223,15 @@ pub enum KillFrom {\n     Execution,\n }\n \n-impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               analysis_name: &'static str,\n-               body: Option<&hir::Body>,\n-               cfg: &cfg::CFG,\n-               oper: O,\n-               bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n+impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        analysis_name: &'static str,\n+        body: Option<&hir::Body>,\n+        cfg: &cfg::CFG,\n+        oper: O,\n+        bits_per_id: usize,\n+    ) -> DataFlowContext<'tcx, O> {\n         let usize_bits = mem::size_of::<usize>() * 8;\n         let words_per_id = (bits_per_id + usize_bits - 1) / usize_bits;\n         let num_nodes = cfg.graph.all_nodes().len();\n@@ -500,7 +501,7 @@ impl<'a, 'tcx, O: DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n }\n \n // N.B. `Clone + 'static` only needed for pretty printing.\n-impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'a, 'tcx, O> {\n+impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n     pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n         //! Performs the data flow analysis.\n \n@@ -537,7 +538,7 @@ impl<'a, 'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'a, 'tcx,\n     }\n }\n \n-impl<'a, 'b, 'tcx, O: DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n+impl<O: DataFlowOperator> PropagationContext<'_, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n                 nodes_po: &[CFGIndex],"}, {"sha": "1f2480666959e17eca3fdae778344c73c15c35ec", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -34,7 +34,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n     pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n     pub variants: Vec<Variant>,\n     pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n-    pub analysis_data: &'a borrowck::AnalysisData<'a, 'tcx>,\n+    pub analysis_data: &'a borrowck::AnalysisData<'tcx>,\n }\n \n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n@@ -61,11 +61,14 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         }\n     }\n \n-    fn build_set<O:DataFlowOperator, F>(&self,\n-                                        e: EntryOrExit,\n-                                        cfgidx: CFGIndex,\n-                                        dfcx: &DataFlowContext<'a, 'tcx, O>,\n-                                        mut to_lp: F) -> String where\n+    fn build_set<O: DataFlowOperator, F>(\n+        &self,\n+        e: EntryOrExit,\n+        cfgidx: CFGIndex,\n+        dfcx: &DataFlowContext<'tcx, O>,\n+        mut to_lp: F,\n+    ) -> String\n+    where\n         F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n     {\n         let mut saw_some = false;"}, {"sha": "98e629ce046bbfd3d62c19d7d8e19c08fbf7df6f", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -5,6 +5,7 @@\n #![deny(internal)]\n #![deny(unused_lifetimes)]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "27ec939dd29336b0b5258e8ce15d01e48f9c7da0", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -9,7 +9,7 @@ use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_, '_, '_>, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_, '_>, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {"}, {"sha": "f68f3de11857495aa046ec9a82ac5b2d35d5131b", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -367,7 +367,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn wasm_import_module(tcx: TyCtxt<'_, '_, '_>, id: DefId) -> Option<CString> {\n+fn wasm_import_module(tcx: TyCtxt<'_, '_>, id: DefId) -> Option<CString> {\n     tcx.wasm_import_module_map(id.krate)\n         .get(&id)\n         .map(|s| CString::new(&s[..]).unwrap())"}, {"sha": "6f3f9d4cb8b55d50dffbdb286af8c204eb2dd421", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -89,7 +89,7 @@ pub fn create_informational_target_machine(\n }\n \n pub fn create_target_machine(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE), find_features)()"}, {"sha": "9d2cd8618872a85b3b0c52b9f416c9bd7a7500c1", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -41,10 +41,10 @@ use rustc::hir::CodegenFnAttrs;\n \n use crate::value::Value;\n \n-pub fn write_compressed_metadata<'a, 'gcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+pub fn write_compressed_metadata<'gcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n     metadata: &EncodedMetadata,\n-    llvm_module: &mut ModuleLlvm\n+    llvm_module: &mut ModuleLlvm,\n ) {\n     use std::io::Write;\n     use flate2::Compression;\n@@ -103,7 +103,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedString) {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'tcx, 'tcx>, cgu_name: InternedString) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n@@ -123,8 +123,8 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedStrin\n \n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n \n-    fn module_codegen<'ll, 'tcx>(\n-        tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n+    fn module_codegen<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         cgu_name: InternedString,\n     ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);"}, {"sha": "2febba6766d539cd7d0a49806e4e1352d5d930f8", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -66,7 +66,7 @@ impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.cx.tcx\n     }\n }\n@@ -1228,9 +1228,7 @@ impl Builder<'a, 'll, 'tcx> {\n         ret.expect(\"LLVM does not have support for catchret\")\n     }\n \n-    fn check_store<'b>(&mut self,\n-                       val: &'ll Value,\n-                       ptr: &'ll Value) -> &'ll Value {\n+    fn check_store(&mut self, val: &'ll Value, ptr: &'ll Value) -> &'ll Value {\n         let dest_ptr_ty = self.cx.val_ty(ptr);\n         let stored_ty = self.cx.val_ty(val);\n         let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);"}, {"sha": "0a780fecf41de768019dfa228b38ac0aec57403b", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -35,7 +35,7 @@ use crate::abi::Abi;\n /// `llvm::Context` so that several compilation units may be optimized in parallel.\n /// All other LLVM data structures in the `CodegenCx` are tied to that `llvm::Context`.\n pub struct CodegenCx<'ll, 'tcx: 'll> {\n-    pub tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n     pub check_overflow: bool,\n     pub use_dll_storage_attrs: bool,\n     pub tls_model: llvm::ThreadLocalMode,\n@@ -47,8 +47,8 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, &'ll Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<\n-            (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>,\n+    pub vtables:\n+        RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), &'ll Value>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'ll Value>>,\n \n@@ -141,7 +141,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n }\n \n pub unsafe fn create_module(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     llcx: &'ll llvm::Context,\n     mod_name: &str,\n ) -> &'ll llvm::Module {\n@@ -207,10 +207,11 @@ pub unsafe fn create_module(\n }\n \n impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n-    crate fn new(tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n-                 codegen_unit: Arc<CodegenUnit<'tcx>>,\n-                 llvm_module: &'ll crate::ModuleLlvm)\n-                 -> Self {\n+    crate fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        codegen_unit: Arc<CodegenUnit<'tcx>>,\n+        llvm_module: &'ll crate::ModuleLlvm,\n+    ) -> Self {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -838,7 +839,7 @@ impl HasTargetSpec for CodegenCx<'ll, 'tcx> {\n }\n \n impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "3c37240b1660c17fe3fc80c154b48a11fe899ddd", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -222,8 +222,7 @@ impl TypeMap<'ll, 'tcx> {\n     // Get the unique type id string for an enum variant part.\n     // Variant parts are not types and shouldn't really have their own id,\n     // but it makes set_members_of_composite_type() simpler.\n-    fn get_unique_type_id_str_of_enum_variant_part<'a>(&mut self,\n-                                                       enum_type_id: UniqueTypeId) -> &str {\n+    fn get_unique_type_id_str_of_enum_variant_part(&mut self, enum_type_id: UniqueTypeId) -> &str {\n         let variant_part_type_id = format!(\"{}_variant_part\",\n                                            self.get_unique_type_id_as_string(enum_type_id));\n         let interner_key = self.unique_id_interner.intern(&variant_part_type_id);\n@@ -894,10 +893,11 @@ fn pointer_type_metadata(\n     }\n }\n \n-pub fn compile_unit_metadata(tcx: TyCtxt<'_, '_, '_>,\n-                             codegen_unit_name: &str,\n-                             debug_context: &CrateDebugContext<'ll, '_>)\n-                             -> &'ll DIDescriptor {\n+pub fn compile_unit_metadata(\n+    tcx: TyCtxt<'_, '_>,\n+    codegen_unit_name: &str,\n+    debug_context: &CrateDebugContext<'ll, '_>,\n+) -> &'ll DIDescriptor {\n     let mut name_in_debuginfo = match tcx.sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n         None => PathBuf::from(&*tcx.crate_name(LOCAL_CRATE).as_str()),\n@@ -2257,11 +2257,7 @@ pub fn create_global_var_metadata(\n /// given type.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_vtable_metadata(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    ty: ty::Ty<'tcx>,\n-    vtable: &'ll Value,\n-) {\n+pub fn create_vtable_metadata(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>, vtable: &'ll Value) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }"}, {"sha": "dc3631e2ee17b3927a4613373a91444d91019833", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -1417,7 +1417,7 @@ fn generic_simd_intrinsic(\n     // FIXME: use:\n     //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Function.h#L182\n     //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n-    fn llvm_vector_str(elem_ty: ty::Ty<'_>, vec_len: usize, no_pointers: usize) -> String {\n+    fn llvm_vector_str(elem_ty: Ty<'_>, vec_len: usize, no_pointers: usize) -> String {\n         let p0s: String = \"p0\".repeat(no_pointers);\n         match elem_ty.sty {\n             ty::Int(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n@@ -1427,7 +1427,7 @@ fn generic_simd_intrinsic(\n         }\n     }\n \n-    fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: ty::Ty<'_>, vec_len: usize,\n+    fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: Ty<'_>, vec_len: usize,\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n@@ -1473,15 +1473,15 @@ fn generic_simd_intrinsic(\n                  in_ty, ret_ty);\n \n         // This counts how many pointers\n-        fn ptr_count(t: ty::Ty<'_>) -> usize {\n+        fn ptr_count(t: Ty<'_>) -> usize {\n             match t.sty {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n-        fn non_ptr(t: ty::Ty<'_>) -> ty::Ty<'_> {\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n             match t.sty {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n@@ -1572,15 +1572,15 @@ fn generic_simd_intrinsic(\n                  arg_tys[2].simd_size(tcx));\n \n         // This counts how many pointers\n-        fn ptr_count(t: ty::Ty<'_>) -> usize {\n+        fn ptr_count(t: Ty<'_>) -> usize {\n             match t.sty {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n-        fn non_ptr(t: ty::Ty<'_>) -> ty::Ty<'_> {\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n             match t.sty {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,"}, {"sha": "9a0860bc4b09fa6ebcad2c72ccbf6ea968e668ea", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,6 +22,8 @@\n #![feature(static_nobundle)]\n #![feature(trusted_len)]\n #![deny(rust_2018_idioms)]\n+#![deny(internal)]\n+#![deny(unused_lifetimes)]\n #![allow(explicit_outlives_requirements)]\n \n use back::write::{create_target_machine, create_informational_target_machine};\n@@ -103,29 +105,29 @@ mod va_arg;\n pub struct LlvmCodegenBackend(());\n \n impl ExtraBackendMethods for LlvmCodegenBackend {\n-    fn new_metadata(&self, tcx: TyCtxt<'_, '_, '_>, mod_name: &str) -> ModuleLlvm {\n+    fn new_metadata(&self, tcx: TyCtxt<'_, '_>, mod_name: &str) -> ModuleLlvm {\n         ModuleLlvm::new_metadata(tcx, mod_name)\n     }\n \n-    fn write_compressed_metadata<'b, 'gcx>(\n+    fn write_compressed_metadata<'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx>,\n         metadata: &EncodedMetadata,\n-        llvm_module: &mut ModuleLlvm\n+        llvm_module: &mut ModuleLlvm,\n     ) {\n         base::write_compressed_metadata(tcx, metadata, llvm_module)\n     }\n-    fn codegen_allocator<'b, 'gcx>(\n+    fn codegen_allocator<'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx>,\n         mods: &mut ModuleLlvm,\n-        kind: AllocatorKind\n+        kind: AllocatorKind,\n     ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n     fn compile_codegen_unit<'a, 'tcx: 'a>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         cgu_name: InternedString,\n     ) {\n         base::compile_codegen_unit(tcx, cgu_name);\n@@ -284,12 +286,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n         attributes::provide_extern(providers);\n     }\n \n-    fn codegen_crate<'b, 'tcx>(\n+    fn codegen_crate<'tcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n-        rx: mpsc::Receiver<Box<dyn Any + Send>>\n+        rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     ) -> Box<dyn Any> {\n         box rustc_codegen_ssa::base::codegen_crate(\n             LlvmCodegenBackend(()), tcx, metadata, need_metadata_module, rx)\n@@ -365,7 +367,7 @@ unsafe impl Send for ModuleLlvm { }\n unsafe impl Sync for ModuleLlvm { }\n \n impl ModuleLlvm {\n-    fn new(tcx: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self {\n+    fn new(tcx: TyCtxt<'_, '_>, mod_name: &str) -> Self {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;\n@@ -377,7 +379,7 @@ impl ModuleLlvm {\n         }\n     }\n \n-    fn new_metadata(tcx: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self {\n+    fn new_metadata(tcx: TyCtxt<'_, '_>, mod_name: &str) -> Self {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;"}, {"sha": "2c167256ad56c5280ff2887cede1e6f6b8a0e1d7", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -327,7 +327,7 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn backend_field_index(&self, layout: TyLayout<'tcx>, index: usize) -> u64 {\n         layout.llvm_field_index(index)\n     }\n-    fn scalar_pair_element_backend_type<'a>(\n+    fn scalar_pair_element_backend_type(\n         &self,\n         layout: TyLayout<'tcx>,\n         index: usize,"}, {"sha": "36a9ff0a2d2e5c0f24d4fe7acd9bd1929f18f9e5", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n \n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n-    fn is_llvm_scalar_pair<'a>(&self) -> bool;\n+    fn is_llvm_scalar_pair(&self) -> bool;\n     fn llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n     fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type;\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n@@ -198,7 +198,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn is_llvm_scalar_pair<'a>(&self) -> bool {\n+    fn is_llvm_scalar_pair(&self) -> bool {\n         match self.abi {\n             layout::Abi::ScalarPair(..) => true,\n             layout::Abi::Uninhabited |"}, {"sha": "260c07a7b6287a786a769f4b71754be671fc0212", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,7 +25,7 @@ pub struct LinkerInfo {\n }\n \n impl LinkerInfo {\n-    pub fn new(tcx: TyCtxt<'_, '_, '_>) -> LinkerInfo {\n+    pub fn new(tcx: TyCtxt<'_, '_>) -> LinkerInfo {\n         LinkerInfo {\n             exports: tcx.sess.crate_types.borrow().iter().map(|&c| {\n                 (c, exported_symbols(tcx, c))\n@@ -1012,7 +1012,7 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n }\n \n-fn exported_symbols(tcx: TyCtxt<'_, '_, '_>, crate_type: CrateType) -> Vec<String> {\n+fn exported_symbols(tcx: TyCtxt<'_, '_>, crate_type: CrateType) -> Vec<String> {\n     if let Some(ref exports) = tcx.sess.target.target.options.override_export_symbols {\n         return exports.clone()\n     }"}, {"sha": "e1693b7c2ef1b16ac01bb4e8d500139405ad975c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,7 +21,7 @@ pub type ExportedSymbols = FxHashMap<\n     Arc<Vec<(String, SymbolExportLevel)>>,\n >;\n \n-pub fn threshold(tcx: TyCtxt<'_, '_, '_>) -> SymbolExportLevel {\n+pub fn threshold(tcx: TyCtxt<'_, '_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n@@ -46,10 +46,10 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExpor\n     }\n }\n \n-fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             cnum: CrateNum)\n-                                             -> &'tcx DefIdMap<SymbolExportLevel>\n-{\n+fn reachable_non_generics_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> &'tcx DefIdMap<SymbolExportLevel> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n@@ -157,9 +157,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.arena.alloc(reachable_non_generics)\n }\n \n-fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                     def_id: DefId)\n-                                                     -> bool {\n+fn is_reachable_non_generic_provider_local<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     let export_threshold = threshold(tcx);\n \n     if let Some(&level) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n@@ -169,17 +167,14 @@ fn is_reachable_non_generic_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     }\n }\n \n-fn is_reachable_non_generic_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                      def_id: DefId)\n-                                                      -> bool {\n+fn is_reachable_non_generic_provider_extern<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     tcx.reachable_non_generics(def_id.krate).contains_key(&def_id)\n }\n \n-fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             cnum: CrateNum)\n-                                             -> Arc<Vec<(ExportedSymbol<'tcx>,\n-                                                         SymbolExportLevel)>>\n-{\n+fn exported_symbols_provider_local<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> Arc<Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)>> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     if !tcx.sess.opts.output_types.should_codegen() {\n@@ -278,11 +273,10 @@ fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Arc::new(symbols)\n }\n \n-fn upstream_monomorphizations_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cnum: CrateNum)\n-    -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>>\n-{\n+fn upstream_monomorphizations_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> &'tcx DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n     debug_assert!(cnum == LOCAL_CRATE);\n \n     let cnums = tcx.all_crate_nums(LOCAL_CRATE);\n@@ -328,16 +322,15 @@ fn upstream_monomorphizations_provider<'a, 'tcx>(\n     tcx.arena.alloc(instances)\n }\n \n-fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId)\n-    -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n-{\n+fn upstream_monomorphizations_for_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n     debug_assert!(!def_id.is_local());\n     tcx.upstream_monomorphizations(LOCAL_CRATE).get(&def_id)\n }\n \n-fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n+fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_, '_>, def_id: DefId) -> bool {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&hir_id)\n     } else {\n@@ -359,7 +352,7 @@ pub fn provide_extern(providers: &mut Providers<'_>) {\n     providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n }\n \n-fn symbol_export_level(tcx: TyCtxt<'_, '_, '_>, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level(tcx: TyCtxt<'_, '_>, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "5a7ca4af4b8678c00703412fd47c34eda7ef894c", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -375,10 +375,10 @@ fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n \n pub fn start_async_codegen<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     metadata: EncodedMetadata,\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-    total_cgus: usize\n+    total_cgus: usize,\n ) -> OngoingCodegen<B> {\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n@@ -996,7 +996,7 @@ enum MainThreadWorkerState {\n \n fn start_executing_work<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     crate_info: &CrateInfo,\n     shared_emitter: SharedEmitter,\n     codegen_worker_send: Sender<Message<B>>,\n@@ -1005,7 +1005,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     jobserver: Client,\n     modules_config: Arc<ModuleConfig>,\n     metadata_config: Arc<ModuleConfig>,\n-    allocator_config: Arc<ModuleConfig>\n+    allocator_config: Arc<ModuleConfig>,\n ) -> thread::JoinHandle<Result<CompiledModules, ()>> {\n     let coordinator_send = tcx.tx_to_llvm_workers.lock().clone();\n     let sess = tcx.sess;\n@@ -1861,9 +1861,11 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         }, work_products)\n     }\n \n-    pub fn submit_pre_codegened_module_to_llvm(&self,\n-                                                       tcx: TyCtxt<'_, '_, '_>,\n-                                                       module: ModuleCodegen<B::Module>) {\n+    pub fn submit_pre_codegened_module_to_llvm(\n+        &self,\n+        tcx: TyCtxt<'_, '_>,\n+        module: ModuleCodegen<B::Module>,\n+    ) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n \n@@ -1872,7 +1874,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         submit_codegened_module_to_llvm(&self.backend, tcx, module, cost);\n     }\n \n-    pub fn codegen_finished(&self, tcx: TyCtxt<'_, '_, '_>) {\n+    pub fn codegen_finished(&self, tcx: TyCtxt<'_, '_>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n         drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n@@ -1911,9 +1913,9 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     module: ModuleCodegen<B::Module>,\n-    cost: u64\n+    cost: u64,\n ) {\n     let llvm_work_item = WorkItem::Optimize(module);\n     drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone::<B> {\n@@ -1924,8 +1926,8 @@ pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n \n pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt<'_, '_, '_>,\n-    module: CachedModuleCodegen\n+    tcx: TyCtxt<'_, '_>,\n+    module: CachedModuleCodegen,\n ) {\n     let llvm_work_item = WorkItem::CopyPostLtoArtifacts(module);\n     drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::CodegenDone::<B> {\n@@ -1936,8 +1938,8 @@ pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n \n pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt<'_, '_, '_>,\n-    module: CachedModuleCodegen\n+    tcx: TyCtxt<'_, '_>,\n+    module: CachedModuleCodegen,\n ) {\n     let filename = pre_lto_bitcode_filename(&module.name);\n     let bc_path = in_incr_comp_dir_sess(tcx.sess, &filename);\n@@ -1961,7 +1963,7 @@ pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n     format!(\"{}.{}\", module_name, PRE_LTO_BC_EXT)\n }\n \n-fn msvc_imps_needed(tcx: TyCtxt<'_, '_, '_>) -> bool {\n+fn msvc_imps_needed(tcx: TyCtxt<'_, '_>) -> bool {\n     // This should never be true (because it's not supported). If it is true,\n     // something is wrong with commandline arg validation.\n     assert!(!(tcx.sess.opts.cg.linker_plugin_lto.enabled() &&"}, {"sha": "9c34b5e4f7927da8954988ef6fe2c40a87f9feeb", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -480,12 +480,11 @@ pub const CODEGEN_WORKER_ID: usize = ::std::usize::MAX;\n \n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-    rx: mpsc::Receiver<Box<dyn Any + Send>>\n+    rx: mpsc::Receiver<Box<dyn Any + Send>>,\n ) -> OngoingCodegen<B> {\n-\n     check_for_rustc_errors_attr(tcx);\n \n     // Skip crate items and just output metadata in -Z no-codegen mode.\n@@ -703,7 +702,7 @@ impl<B: ExtraBackendMethods> Drop for AbortCodegenOnDrop<B> {\n     }\n }\n \n-fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n+fn assert_and_save_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     time(tcx.sess,\n          \"assert dep graph\",\n          || ::rustc_incremental::assert_dep_graph(tcx));\n@@ -714,7 +713,7 @@ fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n }\n \n impl CrateInfo {\n-    pub fn new(tcx: TyCtxt<'_, '_, '_>) -> CrateInfo {\n+    pub fn new(tcx: TyCtxt<'_, '_>) -> CrateInfo {\n         let mut info = CrateInfo {\n             panic_runtime: None,\n             compiler_builtins: None,\n@@ -776,11 +775,11 @@ impl CrateInfo {\n             info.missing_lang_items.insert(cnum, missing);\n         }\n \n-        return info\n+        return info;\n     }\n }\n \n-fn is_codegened_item(tcx: TyCtxt<'_, '_, '_>, id: DefId) -> bool {\n+fn is_codegened_item(tcx: TyCtxt<'_, '_>, id: DefId) -> bool {\n     let (all_mono_items, _) =\n         tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     all_mono_items.contains(&id)\n@@ -850,9 +849,7 @@ pub fn provide_both(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn determine_cgu_reuse<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 cgu: &CodegenUnit<'tcx>)\n-                                 -> CguReuse {\n+fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return CguReuse::No\n     }"}, {"sha": "66baf06bfb46d4372a99495d3633cd7d2270baf7", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -122,11 +122,7 @@ mod temp_stable_hash_impls {\n     }\n }\n \n-pub fn langcall(tcx: TyCtxt<'_, '_, '_>,\n-                span: Option<Span>,\n-                msg: &str,\n-                li: LangItem)\n-                -> DefId {\n+pub fn langcall(tcx: TyCtxt<'_, '_>, span: Option<Span>, msg: &str, li: LangItem) -> DefId {\n     tcx.lang_items().require(li).unwrap_or_else(|s| {\n         let msg = format!(\"{} {}\", msg, s);\n         match span {"}, {"sha": "943fd254030d294ed2615e9d9872c964d5c74fc4", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -8,10 +8,11 @@ use rustc_data_structures::fx::FxHashSet;\n // any caching, i.e., calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e., type parameters) are always fully qualified.\n-pub fn compute_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             t: Ty<'tcx>,\n-                                             qualified: bool)\n-                                             -> String {\n+pub fn compute_debuginfo_type_name<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    t: Ty<'tcx>,\n+    qualified: bool,\n+) -> String {\n     let mut result = String::with_capacity(64);\n     let mut visited = FxHashSet::default();\n     push_debuginfo_type_name(tcx, t, qualified, &mut result, &mut visited);\n@@ -20,12 +21,13 @@ pub fn compute_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                          t: Ty<'tcx>,\n-                                          qualified: bool,\n-                                          output: &mut String,\n-                                          visited: &mut FxHashSet<Ty<'tcx>>) {\n-\n+pub fn push_debuginfo_type_name<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    t: Ty<'tcx>,\n+    qualified: bool,\n+    output: &mut String,\n+    visited: &mut FxHashSet<Ty<'tcx>>,\n+) {\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n@@ -208,10 +210,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                      def_id: DefId,\n-                      qualified: bool,\n-                      output: &mut String) {\n+    fn push_item_name(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        def_id: DefId,\n+        qualified: bool,\n+        output: &mut String,\n+    ) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());\n             for path_element in tcx.def_path(def_id).data {\n@@ -228,10 +232,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  substs: SubstsRef<'tcx>,\n-                                  output: &mut String,\n-                                  visited: &mut FxHashSet<Ty<'tcx>>) {\n+    fn push_type_params<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        substs: SubstsRef<'tcx>,\n+        output: &mut String,\n+        visited: &mut FxHashSet<Ty<'tcx>>,\n+    ) {\n         if substs.types().next().is_none() {\n             return;\n         }"}, {"sha": "160e554f8565c1692ba1d25e9fbd2d5fa6f51b17", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -31,24 +31,20 @@ impl<'tcx, T> Backend<'tcx> for T where\n }\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n-    fn new_metadata(&self, sess: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self::Module;\n-    fn write_compressed_metadata<'b, 'gcx>(\n+    fn new_metadata(&self, sess: TyCtxt<'_, '_>, mod_name: &str) -> Self::Module;\n+    fn write_compressed_metadata<'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx>,\n         metadata: &EncodedMetadata,\n         llvm_module: &mut Self::Module,\n     );\n-    fn codegen_allocator<'b, 'gcx>(\n+    fn codegen_allocator<'gcx>(\n         &self,\n-        tcx: TyCtxt<'b, 'gcx, 'gcx>,\n+        tcx: TyCtxt<'gcx, 'gcx>,\n         mods: &mut Self::Module,\n-        kind: AllocatorKind\n-    );\n-    fn compile_codegen_unit<'a, 'tcx: 'a>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        cgu_name: InternedString,\n+        kind: AllocatorKind,\n     );\n+    fn compile_codegen_unit<'a, 'tcx: 'a>(&self, tcx: TyCtxt<'tcx, 'tcx>, cgu_name: InternedString);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "1bf03c0c45c6dbb0888dff541558cc19958f5e8e", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,7 +6,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n-\n #![feature(box_syntax)]\n \n use std::any::Any;\n@@ -34,12 +33,12 @@ pub trait CodegenBackend {\n     fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n     fn provide(&self, _providers: &mut Providers<'_>);\n     fn provide_extern(&self, _providers: &mut Providers<'_>);\n-    fn codegen_crate<'a, 'tcx>(\n+    fn codegen_crate<'tcx>(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n-        rx: mpsc::Receiver<Box<dyn Any + Send>>\n+        rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     ) -> Box<dyn Any>;\n \n     /// This is called on the returned `Box<dyn Any>` from `codegen_backend`"}, {"sha": "cc6e368f11b3bca9ab524eab2e52c28546012e18", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -36,7 +36,7 @@ pub mod symbol_names_test;\n /// error in codegen. This is used to write compile-fail tests\n /// that actually test that compilation succeeds without\n /// reporting an error.\n-pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_, '_, '_>) {\n+pub fn check_for_rustc_errors_attr(tcx: TyCtxt<'_, '_>) {\n     if let Some((def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n         if tcx.has_attr(def_id, sym::rustc_error) {\n             tcx.sess.span_fatal(tcx.def_span(def_id), \"compilation successful\");"}, {"sha": "89b35b4cc6114e44b429140d9cebde06e150a0d0", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -112,7 +112,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n+fn symbol_name(tcx: TyCtxt<'tcx, 'tcx>, instance: Instance<'tcx>) -> InternedString {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n "}, {"sha": "9645af5309e7868677be4a61d5444211ad2ede17", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -14,7 +14,7 @@ use std::fmt::{self, Write};\n use std::mem::{self, discriminant};\n \n pub(super) fn mangle(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n ) -> String {\n@@ -68,8 +68,8 @@ pub(super) fn mangle(\n     printer.path.finish(hash)\n }\n \n-fn get_symbol_hash<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn get_symbol_hash<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n \n     // instance this name will be for\n     instance: Instance<'tcx>,\n@@ -179,8 +179,8 @@ impl SymbolPath {\n     }\n }\n \n-struct SymbolPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SymbolPrinter<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     path: SymbolPath,\n \n     // When `true`, `finalize_pending_component` isn't used.\n@@ -194,7 +194,7 @@ struct SymbolPrinter<'a, 'tcx> {\n // `PrettyPrinter` aka pretty printing of e.g. types in paths,\n // symbol names should have their own printing machinery.\n \n-impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+impl Printer<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n     type Error = fmt::Error;\n \n     type Path = Self;\n@@ -203,7 +203,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -360,7 +360,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     }\n }\n \n-impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n+impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'tcx> {\n     fn region_should_not_be_omitted(\n         &self,\n         _region: ty::Region<'_>,\n@@ -400,7 +400,7 @@ impl PrettyPrinter<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     }\n }\n \n-impl fmt::Write for SymbolPrinter<'_, '_> {\n+impl fmt::Write for SymbolPrinter<'_> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         // Name sanitation. LLVM will happily accept identifiers with weird names, but\n         // gas doesn't!"}, {"sha": "7e78b9ea88769ad811a0d451d80573d834563862", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -13,7 +13,7 @@ use std::fmt::Write;\n use std::ops::Range;\n \n pub(super) fn mangle(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n ) -> String {\n@@ -75,14 +75,14 @@ struct BinderLevel {\n     lifetime_depths: Range<u32>,\n }\n \n-struct SymbolMangler<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SymbolMangler<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     compress: Option<Box<CompressionCaches<'tcx>>>,\n     binders: Vec<BinderLevel>,\n     out: String,\n }\n \n-impl SymbolMangler<'_, 'tcx> {\n+impl SymbolMangler<'tcx> {\n     fn push(&mut self, s: &str) {\n         self.out.push_str(s);\n     }\n@@ -214,7 +214,7 @@ impl SymbolMangler<'_, 'tcx> {\n     }\n }\n \n-impl Printer<'tcx, 'tcx> for SymbolMangler<'_, 'tcx> {\n+impl Printer<'tcx, 'tcx> for SymbolMangler<'tcx> {\n     type Error = !;\n \n     type Path = Self;\n@@ -223,7 +223,7 @@ impl Printer<'tcx, 'tcx> for SymbolMangler<'_, 'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "93b8a969d0b60025a5cc1581dd2cdefafd38e21e", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -11,7 +11,7 @@ use syntax::symbol::{Symbol, sym};\n const SYMBOL_NAME: Symbol = sym::rustc_symbol_name;\n const DEF_PATH: Symbol = sym::rustc_def_path;\n \n-pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn report_symbol_names<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n@@ -25,11 +25,11 @@ pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     })\n }\n \n-struct SymbolNamesTest<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SymbolNamesTest<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n+impl SymbolNamesTest<'tcx> {\n     fn process_attrs(&mut self,\n                      hir_id: hir::HirId) {\n         let tcx = self.tcx;\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'a, 'tcx> {\n+impl hir::itemlikevisit::ItemLikeVisitor<'tcx> for SymbolNamesTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.hir_id);\n     }"}, {"sha": "4f19a7bbc8b9235f4b853ee2846236e94cc67235", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -154,12 +154,14 @@ pub fn parse_pretty(sess: &Session,\n \n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<'tcx, A, F>(&self,\n-                                        sess: &'tcx Session,\n-                                        tcx: Option<TyCtxt<'tcx, 'tcx, 'tcx>>,\n-                                        f: F)\n-                                        -> A\n-        where F: FnOnce(&dyn PrinterSupport) -> A\n+    fn call_with_pp_support<'tcx, A, F>(\n+        &self,\n+        sess: &'tcx Session,\n+        tcx: Option<TyCtxt<'tcx, 'tcx>>,\n+        f: F,\n+    ) -> A\n+    where\n+        F: FnOnce(&dyn PrinterSupport) -> A,\n     {\n         match *self {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n@@ -186,12 +188,9 @@ impl PpSourceMode {\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, F>(\n-        &self,\n-        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n-        f: F\n-    ) -> A\n-        where F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A\n+    fn call_with_pp_support_hir<'tcx, A, F>(&self, tcx: TyCtxt<'tcx, 'tcx>, f: F) -> A\n+    where\n+        F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate) -> A,\n     {\n         match *self {\n             PpmNormal => {\n@@ -270,7 +269,7 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n \n struct NoAnn<'hir> {\n     sess: &'hir Session,\n-    tcx: Option<TyCtxt<'hir, 'hir, 'hir>>,\n+    tcx: Option<TyCtxt<'hir, 'hir>>,\n }\n \n impl<'hir> PrinterSupport for NoAnn<'hir> {\n@@ -311,7 +310,7 @@ impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n \n struct IdentifiedAnnotation<'hir> {\n     sess: &'hir Session,\n-    tcx: Option<TyCtxt<'hir, 'hir, 'hir>>,\n+    tcx: Option<TyCtxt<'hir, 'hir>>,\n }\n \n impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n@@ -454,9 +453,8 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     }\n }\n \n-\n struct TypedAnnotation<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: Cell<&'a ty::TypeckTables<'tcx>>,\n }\n \n@@ -617,12 +615,13 @@ impl UserIdentifiedItem {\n     }\n }\n \n-fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       code: blocks::Code<'tcx>,\n-                                       mode: PpFlowGraphMode,\n-                                       mut out: W)\n-                                       -> io::Result<()> {\n+fn print_flowgraph<'tcx, W: Write>(\n+    variants: Vec<borrowck_dot::Variant>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    code: blocks::Code<'tcx>,\n+    mode: PpFlowGraphMode,\n+    mut out: W,\n+) -> io::Result<()> {\n     let body_id = match code {\n         blocks::Code::Expr(expr) => {\n             // Find the function this expression is from.\n@@ -755,12 +754,13 @@ pub fn print_after_parsing(sess: &Session,\n }\n \n pub fn print_after_hir_lowering<'tcx>(\n-    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     input: &Input,\n     krate: &ast::Crate,\n     ppm: PpMode,\n     opt_uii: Option<UserIdentifiedItem>,\n-    ofile: Option<&Path>) {\n+    ofile: Option<&Path>,\n+) {\n     if ppm.needs_analysis() {\n         abort_on_err(print_with_analysis(\n             tcx,\n@@ -866,10 +866,10 @@ pub fn print_after_hir_lowering<'tcx>(\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     ppm: PpMode,\n     uii: Option<UserIdentifiedItem>,\n-    ofile: Option<&Path>\n+    ofile: Option<&Path>,\n ) -> Result<(), ErrorReported> {\n     let nodeid = if let Some(uii) = uii {\n         debug!(\"pretty printing for {:?}\", uii);"}, {"sha": "0ddcc42ef123cfd6f0ff8e5d501db921e6b98df0", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -51,7 +51,7 @@ use std::io::Write;\n use syntax::ast;\n use syntax_pos::Span;\n \n-pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn assert_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n             dump_graph(tcx);\n@@ -89,13 +89,13 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n type Sources = Vec<(Span, DefId, DepNode)>;\n type Targets = Vec<(Span, ast::Name, hir::HirId, DepNode)>;\n \n-struct IfThisChanged<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct IfThisChanged<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     if_this_changed: Sources,\n     then_this_would_need: Targets,\n }\n \n-impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n+impl IfThisChanged<'tcx> {\n     fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n@@ -158,7 +158,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl Visitor<'tcx> for IfThisChanged<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -184,10 +184,11 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         if_this_changed: &Sources,\n-                         then_this_would_need: &Targets)\n-{\n+fn check_paths<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    if_this_changed: &Sources,\n+    then_this_would_need: &Targets,\n+) {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n         for &(target_span, _, _, _) in then_this_would_need {\n@@ -217,7 +218,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn dump_graph(tcx: TyCtxt<'_, '_, '_>) {\n+fn dump_graph(tcx: TyCtxt<'_, '_>) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| \"dep_graph\".to_string());\n     let query = tcx.dep_graph.query();\n "}, {"sha": "12f81f337d3565cb97d3bf759fd191044fa33a39", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -35,7 +35,7 @@ const MODULE: Symbol = sym::module;\n const CFG: Symbol = sym::cfg;\n const KIND: Symbol = sym::kind;\n \n-pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn assert_module_sources<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.incremental.is_none() {\n             return;\n@@ -59,12 +59,12 @@ pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     })\n }\n \n-struct AssertModuleSource<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct AssertModuleSource<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     available_cgus: BTreeSet<String>,\n }\n \n-impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n+impl AssertModuleSource<'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n         let (expected_reuse, comp_kind) = if attr.check_name(ATTR_PARTITION_REUSED) {\n             (CguReuse::PreLto, ComparisonKind::AtLeast)"}, {"sha": "ffea495d3ebdb3c0857cf23c2525539fd1127889", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -2,6 +2,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(specialization)]\n "}, {"sha": "e281636e9a1ce272d555f0252dfb0f3feaad3b7a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -206,7 +206,7 @@ impl Assertion {\n     }\n }\n \n-pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_dirty_clean_annotations<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.features().rustc_attrs {\n         return;\n@@ -234,13 +234,12 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     })\n }\n \n-pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct DirtyCleanVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n-impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-\n+impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute)\n         -> Option<Assertion>\n@@ -518,7 +517,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.check_item(item.hir_id, item.span);\n     }\n@@ -538,7 +537,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n ///\n /// Also make sure that the `label` and `except` fields do not\n /// both exist.\n-fn check_config(tcx: TyCtxt<'_, '_, '_>, attr: &Attribute) -> bool {\n+fn check_config(tcx: TyCtxt<'_, '_>, attr: &Attribute) -> bool {\n     debug!(\"check_config(attr={:?})\", attr);\n     let config = &tcx.sess.parse_sess.config;\n     debug!(\"check_config: config={:?}\", config);\n@@ -573,7 +572,7 @@ fn check_config(tcx: TyCtxt<'_, '_, '_>, attr: &Attribute) -> bool {\n     }\n }\n \n-fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> ast::Name {\n+fn expect_associated_value(tcx: TyCtxt<'_, '_>, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n         value\n     } else {\n@@ -590,14 +589,13 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n // A visitor that collects all #[rustc_dirty]/#[rustc_clean] attributes from\n // the HIR. It is used to verfiy that we really ran checks for all annotated\n // nodes.\n-pub struct FindAllAttrs<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct FindAllAttrs<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     attr_names: Vec<Symbol>,\n     found_attrs: Vec<&'tcx Attribute>,\n }\n \n-impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n-\n+impl FindAllAttrs<'tcx> {\n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n         for attr_name in &self.attr_names {\n             if attr.check_name(*attr_name) && check_config(self.tcx, attr) {\n@@ -618,7 +616,7 @@ impl<'a, 'tcx> FindAllAttrs<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for FindAllAttrs<'a, 'tcx> {\n+impl intravisit::Visitor<'tcx> for FindAllAttrs<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }"}, {"sha": "adcd06d719cd97ebb33a58bf60836bf3a72b78d8", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -15,7 +15,7 @@ use super::fs::*;\n use super::file_format;\n use super::work_product;\n \n-pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn dep_graph_tcx_init<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     if !tcx.dep_graph.is_fully_enabled() {\n         return\n     }"}, {"sha": "f31718fe50776050c669a0accf4b436ee7b96193", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -15,7 +15,7 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n-pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn save_dep_graph<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n         let sess = tcx.sess;\n@@ -129,8 +129,7 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_, '_, '_>,\n-                    encoder: &mut Encoder) {\n+fn encode_dep_graph(tcx: TyCtxt<'_, '_>, encoder: &mut Encoder) {\n     // First encode the commandline arguments hash\n     tcx.sess.opts.dep_tracking_hash().encode(encoder).unwrap();\n \n@@ -234,8 +233,7 @@ fn encode_work_product_index(work_products: &FxHashMap<WorkProductId, WorkProduc\n     serialized_products.encode(encoder).unwrap();\n }\n \n-fn encode_query_cache(tcx: TyCtxt<'_, '_, '_>,\n-                      encoder: &mut Encoder) {\n+fn encode_query_cache(tcx: TyCtxt<'_, '_>, encoder: &mut Encoder) {\n     time(tcx.sess, \"serialize query result cache\", || {\n         tcx.serialize_query_result_cache(encoder).unwrap();\n     })"}, {"sha": "d76ae187412133063405ecfda9a816d004fba834", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -798,7 +798,7 @@ declare_box_region_type!(\n impl BoxedGlobalCtxt {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx, 'tcx, 'tcx>) -> R\n+        F: for<'tcx> FnOnce(TyCtxt<'tcx, 'tcx>) -> R,\n     {\n         self.access(|gcx| ty::tls::enter_global(gcx, |tcx| f(tcx)))\n     }\n@@ -878,10 +878,7 @@ pub fn create_global_ctxt(\n \n /// Runs the resolution, type-checking, region checking and other\n /// miscellaneous analysis passes on the crate.\n-fn analysis<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> Result<()> {\n+fn analysis<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Result<()> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let sess = tcx.sess;\n@@ -999,7 +996,7 @@ fn analysis<'tcx>(\n }\n \n fn encode_and_write_metadata<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     outputs: &OutputFilenames,\n ) -> (middle::cstore::EncodedMetadata, bool) {\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -1062,7 +1059,7 @@ fn encode_and_write_metadata<'tcx>(\n /// be discarded.\n pub fn start_codegen<'tcx>(\n     codegen_backend: &dyn CodegenBackend,\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     rx: mpsc::Receiver<Box<dyn Any + Send>>,\n     outputs: &OutputFilenames,\n ) -> Box<dyn Any> {"}, {"sha": "49f892ac299f4015e64fd559feec64efbdbae3cd", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,14 +6,11 @@ use rustc::ty::query::Providers;\n use syntax::attr;\n use syntax::symbol::sym;\n \n-pub fn find<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n+pub fn find<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DefId> {\n     tcx.proc_macro_decls_static(LOCAL_CRATE)\n }\n \n-fn proc_macro_decls_static<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> Option<DefId> {\n+fn proc_macro_decls_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = Finder { decls: None };"}, {"sha": "5eff28b194b98d1897ec692ef01cb14a7c6c273f", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -75,7 +75,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn lint_mod<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n "}, {"sha": "edaacf7749407f79fc27af35b1f886a75c60dd99", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -519,11 +519,11 @@ enum FfiResult<'tcx> {\n     },\n }\n \n-fn is_zst<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n+fn is_zst<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, did: DefId, ty: Ty<'tcx>) -> bool {\n     tcx.layout_of(tcx.param_env(did).and(ty)).map(|layout| layout.is_zst()).unwrap_or(false)\n }\n \n-fn ty_is_known_nonnull<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n+fn ty_is_known_nonnull<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n@@ -555,11 +555,12 @@ fn ty_is_known_nonnull<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> b\n /// to function pointers, references, core::num::NonZero*,\n /// core::ptr::NonNull, and #[repr(transparent)] newtypes.\n /// FIXME: This duplicates code in codegen.\n-fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  ty_def: &'tcx ty::AdtDef,\n-                                  substs: SubstsRef<'tcx>)\n-                                  -> bool {\n+fn is_repr_nullable_ptr<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    ty_def: &'tcx ty::AdtDef,\n+    substs: SubstsRef<'tcx>,\n+) -> bool {\n     if ty_def.variants.len() != 2 {\n         return false;\n     }"}, {"sha": "8b7dc557c59ca46a160e69241036585c93d56363", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -314,7 +314,7 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n fn add_query_description_impl(\n     query: &Query,\n     modifiers: QueryModifiers,\n-    impls: &mut proc_macro2::TokenStream\n+    impls: &mut proc_macro2::TokenStream,\n ) {\n     let name = &query.name;\n     let arg = &query.arg;\n@@ -327,7 +327,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    #tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                    #tcx: TyCtxt<'tcx, 'tcx>,\n                     #id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     #block\n@@ -338,7 +338,7 @@ fn add_query_description_impl(\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n-                    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                    tcx: TyCtxt<'tcx, 'tcx>,\n                     id: SerializedDepNodeIndex\n                 ) -> Option<Self::Value> {\n                     tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n@@ -350,7 +350,7 @@ fn add_query_description_impl(\n         quote! {\n             #[inline]\n             #[allow(unused_variables)]\n-            fn cache_on_disk(#tcx: TyCtxt<'_, 'tcx, 'tcx>, #key: Self::Key) -> bool {\n+            fn cache_on_disk(#tcx: TyCtxt<'tcx, 'tcx>, #key: Self::Key) -> bool {\n                 #expr\n             }\n \n@@ -367,7 +367,7 @@ fn add_query_description_impl(\n         quote! {\n             #[allow(unused_variables)]\n             fn describe(\n-                #tcx: TyCtxt<'_, '_, '_>,\n+                #tcx: TyCtxt<'_, '_>,\n                 #key: #arg,\n             ) -> Cow<'static, str> {\n                 format!(#desc).into()"}, {"sha": "7d07331cfff70ebc2efc0b15e8493677322533dc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -40,7 +40,7 @@ macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n       $($name:ident => $compute:block)*) => {\n         pub fn provide_extern<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $name<'a, $lt:$lt, T>($tcx: TyCtxt<'a, $lt, $lt>, def_id_arg: T)\n+            $(fn $name<$lt:$lt, T>($tcx: TyCtxt<$lt, $lt>, def_id_arg: T)\n                                     -> <ty::queries::$name<$lt> as\n                                         QueryConfig<$lt>>::Value\n                 where T: IntoArgs,\n@@ -550,10 +550,7 @@ impl CrateStore for cstore::CStore {\n         self.do_postorder_cnums_untracked()\n     }\n \n-    fn encode_metadata<'a, 'tcx>(&self,\n-                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                 -> EncodedMetadata\n-    {\n+    fn encode_metadata<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n         encoder::encode_metadata(tcx)\n     }\n "}, {"sha": "9ec31e33f9e0652853432e312c54baea3cc5405d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -39,7 +39,7 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n     cdata: Option<&'a CrateMetadata>,\n     sess: Option<&'a Session>,\n-    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    tcx: Option<TyCtxt<'tcx, 'tcx>>,\n \n     // Cache the last used source_file for translating spans as an optimization.\n     last_source_file_index: usize,\n@@ -55,7 +55,9 @@ pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n     fn cdata(self) -> Option<&'a CrateMetadata> { None }\n     fn sess(self) -> Option<&'a Session> { None }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n+    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx>> {\n+        None\n+        }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let tcx = self.tcx();\n@@ -114,14 +116,14 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'a Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx, 'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n     fn cdata(self) -> Option<&'a CrateMetadata> {\n         Some(self.0)\n     }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+    fn tcx(self) -> Option<TyCtxt<'tcx, 'tcx>> {\n         Some(self.1)\n     }\n }\n@@ -146,7 +148,7 @@ impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n@@ -169,10 +171,9 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n-\n+impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n@@ -547,11 +548,11 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn get_variant(\n         &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         item: &Entry<'_>,\n         index: DefIndex,\n         parent_did: DefId,\n-        adt_kind: ty::AdtKind\n+        adt_kind: ty::AdtKind,\n     ) -> ty::VariantDef {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n@@ -588,10 +589,7 @@ impl<'a, 'tcx> CrateMetadata {\n         )\n     }\n \n-    pub fn get_adt_def(&self,\n-                       item_id: DefIndex,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                       -> &'tcx ty::AdtDef {\n+    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n \n@@ -616,24 +614,27 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, kind, variants, repr)\n     }\n \n-    pub fn get_predicates(&self,\n-                          item_id: DefIndex,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> ty::GenericPredicates<'tcx> {\n+    pub fn get_predicates(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_predicates_defined_on(&self,\n-                                   item_id: DefIndex,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                   -> ty::GenericPredicates<'tcx> {\n+    pub fn get_predicates_defined_on(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates_defined_on.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(&self,\n-                                item_id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                -> ty::GenericPredicates<'tcx> {\n+    pub fn get_super_predicates(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> ty::GenericPredicates<'tcx> {\n         let super_predicates = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self).super_predicates,\n             EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n@@ -650,7 +651,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n-    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> Ty<'tcx> {\n         self.entry(id).ty.unwrap().decode((self, tcx))\n     }\n \n@@ -700,17 +701,18 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).coerce_unsized_info\n     }\n \n-    pub fn get_impl_trait(&self,\n-                          id: DefIndex,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> Option<ty::TraitRef<'tcx>> {\n+    pub fn get_impl_trait(\n+        &self,\n+        id: DefIndex,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> Option<ty::TraitRef<'tcx>> {\n         self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n     pub fn get_lib_features(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n+        tcx: TyCtxt<'tcx, '_>,\n     ) -> &'tcx [(ast::Name, Option<ast::Name>)] {\n         // FIXME: For a proc macro crate, not sure whether we should return the \"host\"\n         // features or an empty Vec. Both don't cause ICEs.\n@@ -720,10 +722,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n-    ) -> &'tcx [(DefId, usize)] {\n+    pub fn get_lang_items(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [(DefId, usize)] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n@@ -884,10 +883,11 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_optimized_mir(&self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   id: DefIndex)\n-                                   -> Option<Body<'tcx>> {\n+    pub fn maybe_get_optimized_mir(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        id: DefIndex,\n+    ) -> Option<Body<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),\n@@ -1019,8 +1019,8 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_inherent_implementations_for_type(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n-        id: DefIndex\n+        tcx: TyCtxt<'tcx, '_>,\n+        id: DefIndex,\n     ) -> &'tcx [DefId] {\n         tcx.arena.alloc_from_iter(self.entry(id)\n                                       .inherent_impls\n@@ -1030,7 +1030,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_implementations_for_trait(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n+        tcx: TyCtxt<'tcx, '_>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n         if self.proc_macros.is_some() {\n@@ -1085,10 +1085,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_foreign_modules(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n-    ) -> &'tcx [ForeignModule] {\n+    pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [ForeignModule] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n@@ -1099,7 +1096,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_dylib_dependency_formats(\n         &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n+        tcx: TyCtxt<'tcx, '_>,\n     ) -> &'tcx [(CrateNum, LinkagePreference)] {\n         tcx.arena.alloc_from_iter(self.root\n             .dylib_dependency_formats\n@@ -1111,10 +1108,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }))\n     }\n \n-    pub fn get_missing_lang_items(\n-        &self,\n-        tcx: TyCtxt<'_, 'tcx, '_>,\n-    ) -> &'tcx [lang_items::LangItem] {\n+    pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx, '_>) -> &'tcx [lang_items::LangItem] {\n         if self.proc_macros.is_some() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n@@ -1135,9 +1129,10 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn exported_symbols(&self,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                            -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n+    pub fn exported_symbols(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+    ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n         if self.proc_macros.is_some() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n@@ -1192,10 +1187,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn fn_sig(&self,\n-                  id: DefIndex,\n-                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                  -> ty::PolyFnSig<'tcx> {\n+    pub fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx, 'tcx>) -> ty::PolyFnSig<'tcx> {\n         let sig = match self.entry(id).kind {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).sig,"}, {"sha": "5c73ee43c059c42af3b38837163c558fedd26db3", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -40,9 +40,9 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-pub struct EncodeContext<'a, 'tcx: 'a> {\n+pub struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n \n     entries_index: Index<'tcx>,\n \n@@ -65,7 +65,7 @@ macro_rules! encoder_methods {\n     }\n }\n \n-impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n+impl<'tcx> Encoder for EncodeContext<'tcx> {\n     type Error = <opaque::Encoder as Encoder>::Error;\n \n     fn emit_unit(&mut self) -> Result<(), Self::Error> {\n@@ -95,13 +95,13 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n         self.emit_lazy_distance(lazy.position, Lazy::<T>::min_size())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n         self.emit_usize(seq.len)?;\n         if seq.len == 0 {\n@@ -111,14 +111,14 @@ impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n         self.emit_u32(cnum.as_u32())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<DefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &DefId) -> Result<(), Self::Error> {\n         let DefId {\n@@ -131,14 +131,14 @@ impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_index: &DefIndex) -> Result<(), Self::Error> {\n         self.emit_u32(def_index.as_u32())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n         if span.is_dummy() {\n             return TAG_INVALID_SPAN.encode(self)\n@@ -173,20 +173,20 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n         self.specialized_encode(&def_id.to_def_id())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n         let index = match self.interpret_allocs.entry(*alloc_id) {\n@@ -203,37 +203,35 @@ impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self,\n                           predicates: &ty::GenericPredicates<'tcx>)\n                           -> Result<(), Self::Error> {\n         ty_codec::encode_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'a, 'tcx> {\n+impl<'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n         f.encode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>>\n-for EncodeContext<'a, 'tcx> {\n+impl<'tcx, T: Encodable> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'tcx> {\n     fn specialized_encode(&mut self,\n                           _: &mir::ClearCrossCrate<T>)\n                           -> Result<(), Self::Error> {\n         Ok(())\n     }\n }\n \n-impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n+impl<'tcx> TyEncoder for EncodeContext<'tcx> {\n     fn position(&self) -> usize {\n         self.opaque.position()\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-\n+impl<'tcx> EncodeContext<'tcx> {\n     fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n         assert_eq!(self.lazy_state, LazyState::NoNode);\n         let pos = self.position();\n@@ -544,7 +542,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl EncodeContext<'_, 'tcx> {\n+impl EncodeContext<'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1648,7 +1646,7 @@ impl EncodeContext<'_, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for EncodeContext<'_, 'tcx> {\n+impl Visitor<'tcx> for EncodeContext<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -1698,7 +1696,7 @@ impl Visitor<'tcx> for EncodeContext<'_, 'tcx> {\n     }\n }\n \n-impl EncodeContext<'_, 'tcx> {\n+impl EncodeContext<'tcx> {\n     fn encode_fields(&mut self, adt_def_id: DefId) {\n         let def = self.tcx.adt_def(adt_def_id);\n         for (variant_index, variant) in def.variants.iter_enumerated() {\n@@ -1817,12 +1815,12 @@ impl EncodeContext<'_, 'tcx> {\n     }\n }\n \n-struct ImplVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ImplVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n+impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemKind::Impl(..) = item.node {\n             let impl_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -1865,9 +1863,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n // will allow us to slice the metadata to the precise length that we just\n // generated regardless of trailing bytes that end up in it.\n \n-pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                 -> EncodedMetadata\n-{\n+pub fn encode_metadata<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n     encoder.emit_raw_bytes(METADATA_HEADER);\n \n@@ -1909,7 +1905,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     EncodedMetadata { raw_data: result }\n }\n \n-pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n+pub fn get_repr_options<'tcx, 'gcx>(tcx: TyCtxt<'tcx, 'gcx>, did: DefId) -> ReprOptions {\n     let ty = tcx.type_of(did);\n     match ty.sty {\n         ty::Adt(ref def, _) => return def.repr,"}, {"sha": "63260312fa6dec6005cc2676b5753d24ff0e0d8f", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -3,21 +3,21 @@ use rustc::hir;\n use rustc::middle::cstore::ForeignModule;\n use rustc::ty::TyCtxt;\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<ForeignModule> {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<ForeignModule> {\n     let mut collector = Collector {\n         tcx,\n         modules: Vec::new(),\n     };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n-    return collector.modules\n+    return collector.modules;\n }\n \n-struct Collector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Collector<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     modules: Vec<ForeignModule>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n             hir::ItemKind::ForeignMod(ref fm) => fm,"}, {"sha": "576b0da1fd8e24c4d3c1b6af6193c5f3e2770eb5", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::TyCtxt;\n use rustc_target::spec::abi::Abi;\n use syntax::symbol::sym;\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<String> {\n     let mut collector = Collector {\n         args: Vec::new(),\n     };\n@@ -18,7 +18,7 @@ pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<String> {\n         }\n     }\n \n-    return collector.args\n+    return collector.args;\n }\n \n struct Collector {"}, {"sha": "ef74fdf8a9e540fa62c0d5a93bb4ff203f304fef", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -11,14 +11,14 @@ use syntax::feature_gate::{self, GateIssue};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, struct_span_err};\n \n-pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Vec<NativeLibrary> {\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Vec<NativeLibrary> {\n     let mut collector = Collector {\n         tcx,\n         libs: Vec::new(),\n     };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n     collector.process_command_line();\n-    return collector.libs\n+    return collector.libs;\n }\n \n pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n@@ -28,12 +28,12 @@ pub fn relevant_lib(sess: &Session, lib: &NativeLibrary) -> bool {\n     }\n }\n \n-struct Collector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Collector<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     libs: Vec<NativeLibrary>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem) {}\n }\n \n-impl<'a, 'tcx> Collector<'a, 'tcx> {\n+impl Collector<'tcx> {\n     fn register_native_lib(&mut self, span: Option<Span>, lib: NativeLibrary) {\n         if lib.name.as_ref().map(|s| s.as_str().is_empty()).unwrap_or(false) {\n             match span {"}, {"sha": "5accf2abdadbfd65907fa529f86950d0dbaecc75", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -122,12 +122,11 @@ impl LocalsStateAtExit {\n \n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n-        move_data: &MoveData<'tcx>\n+        move_data: &MoveData<'tcx>,\n     ) -> Self {\n-\n         let mut visitor = GatherBorrows {\n             tcx,\n             body,\n@@ -162,7 +161,7 @@ impl<'tcx> BorrowSet<'tcx> {\n }\n \n struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,"}, {"sha": "60ad8921c0b3d439ca9cbf20880074037ca694c1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -87,7 +87,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n+fn mir_borrowck<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n     let input_body = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n "}, {"sha": "a010338a08d12033737192f07ca8f48ae563f5f9", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -96,7 +96,7 @@ impl BorrowedContentSource<'tcx> {\n         }\n     }\n \n-    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'_, '_, 'tcx>) -> Option<Self> {\n+    fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'_, 'tcx>) -> Option<Self> {\n         match func.sty {\n             ty::FnDef(def_id, substs) => {\n                 let trait_id = tcx.trait_of_item(def_id)?;"}, {"sha": "ccdde320df06e8a201c590499d289be0d5354732", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -522,8 +522,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+fn suggest_ampmut_self<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     local_decl: &mir::LocalDecl<'tcx>,\n ) -> (Span, String) {\n     let sp = local_decl.source_info.span;\n@@ -555,8 +555,8 @@ fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n //\n // This implementation attempts to emulate AST-borrowck prioritization\n // by trying (3.), then (2.) and finally falling back on (1.).\n-fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+fn suggest_ampmut<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n@@ -623,7 +623,7 @@ fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n ///    |        ---------- use `&'a mut String` here to make mutable\n /// ```\n fn annotate_struct_field(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     field: &mir::Field,\n ) -> Option<(Span, String)> {"}, {"sha": "5563bdcaebf2725eb35a0bf7b49750f2c8c129f3", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashSet;\n crate fn find<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n ) -> Option<Cause> {\n@@ -30,7 +30,7 @@ crate fn find<'tcx>(\n struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n     regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n }\n@@ -101,7 +101,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n \n struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     region_vid: RegionVid,\n     def_use_result: Option<DefUseResult>,\n }"}, {"sha": "a8b197135b0a0d38399d2d5cfa26306910591b59", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -51,9 +51,9 @@ impl BorrowExplanation {\n             _ => true,\n         }\n     }\n-    pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'cx, 'gcx, 'tcx>(\n+    pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'gcx, 'tcx>(\n         &self,\n-        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,"}, {"sha": "fdeec036ad0430576a61e5a2dd3383608f028e6f", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -15,7 +15,7 @@ crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex>;\n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n     /// current `-Z` flags.\n-    fn enabled(tcx: TyCtxt<'_, '_, '_>) -> bool;\n+    fn enabled(tcx: TyCtxt<'_, '_>) -> bool;\n \n     fn write_to_dir(\n         &self,\n@@ -26,7 +26,7 @@ crate trait AllFactsExt {\n \n impl AllFactsExt for AllFacts {\n     /// Return\n-    fn enabled(tcx: TyCtxt<'_, '_, '_>) -> bool {\n+    fn enabled(tcx: TyCtxt<'_, '_>) -> bool {\n         tcx.sess.opts.debugging_opts.nll_facts\n             || tcx.sess.opts.debugging_opts.polonius\n     }"}, {"sha": "12433ca365d68338ce4c1b96a673f2869286a083", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -17,8 +17,8 @@ use rustc::mir::TerminatorKind;\n use rustc::mir::{Operand, BorrowKind};\n use rustc_data_structures::graph::dominators::Dominators;\n \n-pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+pub(super) fn generate_invalidates<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     body: &Body<'tcx>,\n@@ -44,7 +44,7 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n }\n \n struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,"}, {"sha": "a263d3be3a54715f208acf2b857af07656b86141", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// named variants.\n     fn give_name_from_error_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -303,7 +303,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn get_named_span(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         error_region: &RegionKind,\n         name: InternedString,\n     ) -> Span {\n@@ -461,7 +461,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to highlighting that closest type instead.\n     fn give_name_if_we_can_match_hir_ty(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty,\n@@ -653,7 +653,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n         counter: &mut usize,"}, {"sha": "882a52a0c45653c4b8cfae207710b2a80a3be7ff", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -10,7 +10,7 @@ use syntax_pos::symbol::Symbol;\n impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_var_name_and_span_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n@@ -35,7 +35,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the upvars (if any) to find one that references fr. Return its index.\n     crate fn get_upvar_index_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n         let upvar_index = self\n@@ -69,7 +69,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// declared.\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         upvars: &[Upvar],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n@@ -91,7 +91,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// user - in particular, index 0 is not the implicit self parameter.\n     crate fn get_argument_index_for_region(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();"}, {"sha": "13606f61a689c0cb2436d6c18e4c572f6ab6883e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -370,7 +370,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'_, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n@@ -943,7 +943,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -976,7 +976,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn eval_if_eq(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1022,7 +1022,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// higher-ranked things and so forth, and right now the inference\n     /// context is not permitted to make more inference variables. So\n     /// we use this kind of hacky solution.\n-    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: T) -> T\n+    fn normalize_to_scc_representatives<T>(&self, tcx: TyCtxt<'_, 'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -1368,14 +1368,14 @@ impl<'tcx> RegionDefinition<'tcx> {\n pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n     fn apply_requirements(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>>;\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T\n@@ -1398,7 +1398,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n     /// requirements.\n     fn apply_requirements(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryRegionConstraint<'tcx>> {\n@@ -1453,7 +1453,7 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n \n     fn subst_closure_mapping<T>(\n         &self,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n         value: &T,\n     ) -> T"}, {"sha": "01dd60cc4891c092279a79dff00c126ad1f58e5c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -15,7 +15,7 @@ use syntax_pos::DUMMY_SP;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,"}, {"sha": "240588b1c88d3a768cf3246fcdf8e0aceb822488", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -75,7 +75,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n // some region `R` in its type where `R` is not known to outlive a free\n // region (i.e., where `R` may be valid for just a subset of the fn body).\n fn compute_live_locals(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     free_regions: &FxHashSet<RegionVid>,\n     body: &Body<'tcx>,\n ) -> Vec<Local> {"}, {"sha": "bbfffc68b9692d10dc4e6839f36ab2455007bdef", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -235,7 +235,7 @@ fn translate_outlives_facts(cx: &mut BorrowCheckContext<'_, '_>) {\n     }\n }\n \n-fn mirbug(tcx: TyCtxt<'_, '_, '_>, span: Span, msg: &str) {\n+fn mirbug(tcx: TyCtxt<'_, '_>, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n     // to avoid reporting bugs in those cases.\n@@ -391,7 +391,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n@@ -1313,7 +1313,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -2504,7 +2504,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn prove_closure_bounds(\n         &mut self,\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n         location: Location,"}, {"sha": "6e64a6fae58d610110b5edf8e8d9395ea4a0d760", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> DefiningTy<'tcx> {\n     /// not a closure or generator, there are no upvars, and hence it\n     /// will be an empty list. The order of types in this list will\n     /// match up with the upvar order in the HIR, typesystem, and MIR.\n-    pub fn upvar_tys(self, tcx: TyCtxt<'_, '_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n+    pub fn upvar_tys(self, tcx: TyCtxt<'_, 'tcx>) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         match self {\n             DefiningTy::Closure(def_id, substs) => Either::Left(substs.upvar_tys(def_id, tcx)),\n             DefiningTy::Generator(def_id, substs, _) => {\n@@ -218,7 +218,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// `'1: '2`, then the caller would impose the constraint that\n     /// `V[1]: V[2]`.\n     pub fn closure_mapping(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         closure_substs: SubstsRef<'tcx>,\n         expected_num_vars: usize,\n         closure_base_def_id: DefId,\n@@ -305,7 +305,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// that this region imposes on others. The methods in this file\n     /// handle the part about dumping the inference context internal\n     /// state.\n-    crate fn annotate(&self, tcx: TyCtxt<'_, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n+    crate fn annotate(&self, tcx: TyCtxt<'_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!(\n@@ -744,7 +744,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n \n     /// Replaces all free regions in `value` with region vids, as\n     /// returned by `to_region_vid`.\n-    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: &T) -> T\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, 'tcx>, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -757,7 +757,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n /// Iterates over the late-bound regions defined on fn_def_id and\n /// invokes `f` with the liberated form of each one.\n fn for_each_late_bound_region_defined_on<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {"}, {"sha": "978f12af9a1ad366a6102ec85851674c60006ebd", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,9 +22,9 @@ pub(super) enum Control {\n }\n \n /// Encapsulates the idea of iterating over every borrow that involves a particular path\n-pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n+pub(super) fn each_borrow_involving_path<'tcx, 'gcx: 'tcx, F, I, S>(\n     s: &mut S,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n@@ -33,7 +33,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     mut op: F,\n ) where\n     F: FnMut(&mut S, BorrowIndex, &BorrowData<'tcx>) -> Control,\n-    I: Iterator<Item=BorrowIndex>\n+    I: Iterator<Item = BorrowIndex>,\n {\n     let (access, place) = access_place;\n "}, {"sha": "542cdf273695d8cfac34b29bc68c78f5636edfc9", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -12,16 +12,16 @@ crate trait PlaceExt<'tcx> {\n     /// for borrows of raw pointer dereferents as well as shared references.\n     fn ignore_borrow(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n-        ) -> bool;\n+    ) -> bool;\n }\n \n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n     fn ignore_borrow(\n         &self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n+        tcx: TyCtxt<'_, 'tcx>,\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {"}, {"sha": "c1cbfd9e3c0bacbf12eed79f09991ca66eede10e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,7 +25,7 @@ crate enum PlaceConflictBias {\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n crate fn places_conflict<'gcx, 'tcx>(\n-    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n@@ -47,7 +47,7 @@ crate fn places_conflict<'gcx, 'tcx>(\n /// array indices, for example) should be interpreted - this depends on what the caller wants in\n /// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n-    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n@@ -84,7 +84,7 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n }\n \n fn place_components_conflict<'gcx, 'tcx>(\n-    tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n@@ -298,8 +298,8 @@ fn place_components_conflict<'gcx, 'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn place_base_conflict<'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     elem1: &PlaceBase<'tcx>,\n     elem2: &PlaceBase<'tcx>,\n ) -> Overlap {\n@@ -365,8 +365,8 @@ fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_projection_conflict<'a, 'gcx: 'tcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn place_projection_conflict<'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     pi1: &Projection<'tcx>,\n     pi2: &Projection<'tcx>,"}, {"sha": "dd4aac0330c1ece65de357e09fd894fbe480dbab", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -39,7 +39,7 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n \n pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     body: &'cx Body<'tcx>,\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     kind: PrefixSet,\n     next: Option<&'cx Place<'tcx>>,\n }"}, {"sha": "579a403f3aca7962808007b5b639290b0c9bfd0c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,7 +25,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n+pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -184,12 +184,12 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n /// A pass to lift all the types and substitutions in a MIR\n /// to the global tcx. Sadly, we don't have a \"folder\" that\n /// can change `'tcx` so we have to transmute afterwards.\n-struct GlobalizeMir<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    span: Span\n+struct GlobalizeMir<'gcx> {\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    span: Span,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+impl<'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'gcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         if let Some(lifted) = self.tcx.lift(ty) {\n             *ty = lifted;\n@@ -234,10 +234,11 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            closure_expr_id: hir::HirId,\n-                                            body_id: hir::BodyId)\n-                                            -> Ty<'tcx> {\n+fn liberated_closure_env_ty<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    closure_expr_id: hir::HirId,\n+    body_id: hir::BodyId,\n+) -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_type(closure_expr_id);\n \n     let (closure_def_id, closure_substs) = match closure_ty.sty {\n@@ -551,10 +552,7 @@ macro_rules! unpack {\n     };\n }\n \n-fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         fn_def_id: DefId,\n-                                         abi: Abi)\n-                                         -> bool {\n+fn should_abort_on_panic<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>, fn_def_id: DefId, abi: Abi) -> bool {\n     // Not callable from C, so we can safely unwind through these\n     if abi == Abi::Rust || abi == Abi::RustCall { return false; }\n "}, {"sha": "fb031f9e7ec164ae59f57d59d733bccb60499887", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 36, "deletions": 43, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -43,17 +43,17 @@ const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n /// that inform us about the generic bounds of the constant. E.g., using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> CompileTimeEvalContext<'a, 'mir, 'tcx> {\n+) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n     InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n-pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub(crate) fn eval_promoted<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -64,7 +64,7 @@ pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n }\n \n fn mplace_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     mplace: MPlaceTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     let MemPlace { ptr, align, meta } = *mplace;\n@@ -84,7 +84,7 @@ fn mplace_to_const<'tcx>(\n }\n \n fn op_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     // We do not normalize just any data.  Only non-union scalars and slices.\n@@ -137,7 +137,7 @@ fn op_to_const<'tcx>(\n \n // Returns a pointer to where the result lives\n fn eval_body_using_ecx<'mir, 'tcx>(\n-    ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -216,18 +216,18 @@ impl Error for ConstEvalError {\n }\n \n // Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter<'a, 'mir, 'tcx: 'a+'mir> {\n+pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// When this value is negative, it indicates the number of interpreter\n     /// steps *until* the loop detector is enabled. When it is positive, it is\n     /// the number of steps after the detector has been enabled modulo the loop\n     /// detector period.\n     pub(super) steps_since_detector_enabled: isize,\n \n     /// Extra state to detect loops.\n-    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'a, 'mir, 'tcx>,\n+    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx> CompileTimeInterpreter<'a, 'mir, 'tcx> {\n+impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     fn new() -> Self {\n         CompileTimeInterpreter {\n             loop_detector: Default::default(),\n@@ -297,8 +297,8 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n-    InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n+type CompileTimeEvalContext<'mir, 'tcx> =\n+    InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -308,9 +308,7 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n-    for CompileTimeInterpreter<'a, 'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKinds = !;\n     type PointerTag = ();\n \n@@ -323,12 +321,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n \n     fn find_fn(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n@@ -368,7 +366,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n@@ -384,7 +382,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn ptr_op(\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &InterpretCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n@@ -396,7 +394,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     fn find_foreign_static(\n         _def_id: DefId,\n-        _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        _tcx: TyCtxtAt<'tcx, 'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n@@ -421,15 +419,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn box_alloc(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -454,27 +452,22 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn stack_push(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx> {\n+    fn stack_push(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n-    fn stack_pop(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        _extra: (),\n-    ) -> InterpResult<'tcx> {\n+    fn stack_pop(_ecx: &mut InterpretCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n         Ok(())\n     }\n }\n \n /// Extracts a field of a (variant of a) const.\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n-pub fn const_field<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_field<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n@@ -498,8 +491,8 @@ pub fn const_field<'a, 'tcx>(\n \n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n-pub fn const_variant_index<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_variant_index<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n ) -> VariantIdx {\n@@ -509,17 +502,17 @@ pub fn const_variant_index<'a, 'tcx>(\n     ecx.read_discriminant(op).unwrap().1\n }\n \n-pub fn error_to_const_error<'a, 'mir, 'tcx>(\n-    ecx: &InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-    mut error: InterpErrorInfo<'tcx>\n+pub fn error_to_const_error<'mir, 'tcx>(\n+    ecx: &InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n     let stacktrace = ecx.generate_stacktrace(None);\n     ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n }\n \n-fn validate_and_turn_into_const<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn validate_and_turn_into_const<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     constant: RawConst<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n@@ -561,8 +554,8 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n     })\n }\n \n-pub fn const_eval_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_eval_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     // see comment in const_eval_provider for what we're doing here\n@@ -585,8 +578,8 @@ pub fn const_eval_provider<'a, 'tcx>(\n     })\n }\n \n-pub fn const_eval_raw_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn const_eval_raw_provider<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n     // Because the constant is computed twice (once per value of `Reveal`), we are at risk of"}, {"sha": "dc2893cb3303d16267af74eaf546939af0d9649e", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -46,9 +46,11 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// is no need to maintain separate drop flags to track such state.\n //\n // FIXME: we have to do something for moving slice patterns.\n-fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                            body: &Body<'tcx>,\n-                                                            place: &mir::Place<'tcx>) -> bool {\n+fn place_contents_drop_state_cannot_differ<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    body: &Body<'tcx>,\n+    place: &mir::Place<'tcx>,\n+) -> bool {\n     let ty = place.ty(body, tcx).ty;\n     match ty.sty {\n         ty::Array(..) => {\n@@ -72,13 +74,14 @@ fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n     }\n }\n \n-pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn on_lookup_result_bits<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n-    each_child: F)\n-    where F: FnMut(MovePathIndex)\n+    each_child: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     match lookup_result {\n         LookupResult::Parent(..) => {\n@@ -90,31 +93,33 @@ pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn on_all_children_bits<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n-    mut each_child: F)\n-    where F: FnMut(MovePathIndex)\n+    mut each_child: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n-    fn is_terminal_path<'a, 'gcx, 'tcx>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn is_terminal_path<'gcx, 'tcx>(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n-        path: MovePathIndex) -> bool\n-    {\n+        path: MovePathIndex,\n+    ) -> bool {\n         place_contents_drop_state_cannot_differ(\n             tcx, body, &move_data.move_paths[path].place)\n     }\n \n-    fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn on_all_children_bits<'gcx, 'tcx, F>(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n-        each_child: &mut F)\n-        where F: FnMut(MovePathIndex)\n+        each_child: &mut F,\n+    ) where\n+        F: FnMut(MovePathIndex),\n     {\n         each_child(move_path_index);\n \n@@ -131,13 +136,14 @@ pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n     on_all_children_bits(tcx, body, move_data, move_path_index, &mut each_child);\n }\n \n-pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn on_all_drop_children_bits<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n-    mut each_child: F)\n-    where F: FnMut(MovePathIndex)\n+    mut each_child: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     on_all_children_bits(tcx, body, &ctxt.move_data, path, |child| {\n         let place = &ctxt.move_data.move_paths[path].place;\n@@ -154,12 +160,13 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n     })\n }\n \n-pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_function_entry<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n-    mut callback: F)\n-    where F: FnMut(MovePathIndex, DropFlagState)\n+    mut callback: F,\n+) where\n+    F: FnMut(MovePathIndex, DropFlagState),\n {\n     let move_data = &ctxt.move_data;\n     for arg in body.args_iter() {\n@@ -171,13 +178,14 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n     }\n }\n \n-pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn drop_flag_effects_for_location<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n-    mut callback: F)\n-    where F: FnMut(MovePathIndex, DropFlagState)\n+    mut callback: F,\n+) where\n+    F: FnMut(MovePathIndex, DropFlagState),\n {\n     let move_data = &ctxt.move_data;\n     debug!(\"drop_flag_effects_for_location({:?})\", loc);\n@@ -203,13 +211,14 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n     );\n }\n \n-pub(crate) fn for_location_inits<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn for_location_inits<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     loc: Location,\n-    mut callback: F)\n-    where F: FnMut(MovePathIndex)\n+    mut callback: F,\n+) where\n+    F: FnMut(MovePathIndex),\n {\n     for ii in &move_data.init_loc_map[loc] {\n         let init = move_data.inits[*ii];"}, {"sha": "ba38ef91ebe4627a6a4271d7aa3590c28a421273", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -30,7 +30,7 @@ newtype_index! {\n /// describing the borrow. These indexes are used for representing the\n /// borrows in compact bitvectors.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n@@ -135,7 +135,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n \n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     crate fn new(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,"}, {"sha": "4148ffc465cf46d02740691f6a0e125c642b0d86", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -64,17 +64,17 @@ pub(super) mod borrows;\n /// between this data and `MaybeUninitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -119,17 +119,17 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx\n /// between this data and `MaybeInitializedPlaces` yields the set of\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -173,17 +173,17 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 't\n /// this data and `MaybeInitializedPlaces` yields the set of places\n /// that would require a dynamic drop-flag at that statement.\n pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n@@ -222,17 +222,17 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n /// }\n /// ```\n pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               body: &'a Body<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n-               -> Self\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        body: &'a Body<'tcx>,\n+        mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+    ) -> Self {\n         EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }"}, {"sha": "10e46507d5a26306250bfbcefbb0bfb8b474492a", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -121,29 +121,36 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'gcx>,\n }\n \n-pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 body: &'a Body<'tcx>,\n-                                                 def_id: DefId,\n-                                                 attributes: &[ast::Attribute],\n-                                                 dead_unwinds: &BitSet<BasicBlock>,\n-                                                 bd: BD,\n-                                                 p: P)\n-                                                 -> DataflowResults<'tcx, BD>\n-    where BD: BitDenotation<'tcx> + InitialFlow,\n-          P: Fn(&BD, BD::Idx) -> DebugFormatted\n+pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    body: &'a Body<'tcx>,\n+    def_id: DefId,\n+    attributes: &[ast::Attribute],\n+    dead_unwinds: &BitSet<BasicBlock>,\n+    bd: BD,\n+    p: P,\n+) -> DataflowResults<'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx> + InitialFlow,\n+    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n {\n     let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n     flow_state.run(tcx, def_id, attributes, p)\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'tcx>\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n+where\n+    BD: BitDenotation<'tcx>,\n {\n-    pub(crate) fn run<P>(self,\n-                         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         def_id: DefId,\n-                         attributes: &[ast::Attribute],\n-                         p: P) -> DataflowResults<'tcx, BD>\n-        where P: Fn(&BD, BD::Idx) -> DebugFormatted\n+    pub(crate) fn run<P>(\n+        self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        def_id: DefId,\n+        attributes: &[ast::Attribute],\n+        p: P,\n+    ) -> DataflowResults<'tcx, BD>\n+    where\n+        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n     {\n         let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n             if let Some(item) = has_rustc_mir_with(attrs, name) {"}, {"sha": "3acbf2a2f6987e7fe0d4edb672395f3e6a30940b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -14,13 +14,13 @@ use super::IllegalMoveOriginKind::*;\n \n struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n-    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'gcx, 'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n@@ -202,9 +202,9 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub(super) fn gather_moves<'a, 'gcx, 'tcx>(\n+pub(super) fn gather_moves<'gcx, 'tcx>(\n     body: &Body<'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    tcx: TyCtxt<'gcx, 'tcx>,\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n     let mut builder = MoveDataBuilder::new(body, tcx);\n "}, {"sha": "33b8134eec91805752590a78ed1167a3e16a951e", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -305,9 +305,11 @@ impl<'tcx> MoveError<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(body: &Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                        -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n+impl<'gcx, 'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(\n+        body: &Body<'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+    ) -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         builder::gather_moves(body, tcx)\n     }\n "}, {"sha": "934baa55a90438869782a2364edb5f3b8633771f", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -9,9 +9,9 @@ crate enum LitToConstError {\n     Reported,\n }\n \n-crate fn lit_to_const<'a, 'gcx, 'tcx>(\n+crate fn lit_to_const<'gcx, 'tcx>(\n     lit: &'tcx ast::LitKind,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     neg: bool,\n ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {"}, {"sha": "ff3383f6e14c09325d5d182aa08fe879c1775933", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -22,7 +22,7 @@ use crate::hair::constant::{lit_to_const, LitToConstError};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n \n     pub root_lint_level: hir::HirId,\n@@ -200,7 +200,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -218,7 +218,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n }\n \n impl UserAnnotatedTyHelpers<'gcx, 'tcx> for Cx<'_, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx()\n     }\n "}, {"sha": "71a274f456a0e2caa28b538add393c68b31f5322", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -194,11 +194,11 @@ pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx\n     cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n }\n \n-struct LiteralExpander<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct LiteralExpander<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n+impl LiteralExpander<'tcx> {\n     /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n     ///\n     /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n@@ -239,7 +239,7 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> PatternFolder<'tcx> for LiteralExpander<'a, 'tcx> {\n+impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.sty, pat.kind);\n         match (&pat.ty.sty, &*pat.kind) {\n@@ -350,7 +350,7 @@ impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pattern<'tcx>; 2]>> for Matrix<'p, 'tc\n }\n \n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n@@ -365,11 +365,13 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n-        f: F) -> R\n-        where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n+        f: F,\n+    ) -> R\n+    where\n+        F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R,\n     {\n         let pattern_arena = TypedArena::default();\n \n@@ -827,9 +829,7 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n-    fn from_ctor(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                 ctor: &Constructor<'tcx>)\n-                 -> Option<IntRange<'tcx>> {\n+    fn from_ctor(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         fn is_integral<'tcx>(ty: Ty<'tcx>) -> bool {\n@@ -867,9 +867,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    fn from_pat(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                mut pat: &Pattern<'tcx>)\n-                -> Option<IntRange<'tcx>> {\n+    fn from_pat(tcx: TyCtxt<'tcx, 'tcx>, mut pat: &Pattern<'tcx>) -> Option<IntRange<'tcx>> {\n         let range = loop {\n             match pat.kind {\n                 box PatternKind::Constant { value } => break ConstantValue(value),\n@@ -889,7 +887,7 @@ impl<'tcx> IntRange<'tcx> {\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n-    fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n+    fn signed_bias(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n@@ -901,7 +899,7 @@ impl<'tcx> IntRange<'tcx> {\n \n     /// Converts a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n     fn range_to_ctor(\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         ty: Ty<'tcx>,\n         r: RangeInclusive<u128>,\n     ) -> Constructor<'tcx> {\n@@ -917,10 +915,11 @@ impl<'tcx> IntRange<'tcx> {\n \n     /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n-    fn subtract_from(self,\n-                     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                     ranges: Vec<Constructor<'tcx>>)\n-                     -> Vec<Constructor<'tcx>> {\n+    fn subtract_from(\n+        self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        ranges: Vec<Constructor<'tcx>>,\n+    ) -> Vec<Constructor<'tcx>> {\n         let ranges = ranges.into_iter().filter_map(|r| {\n             IntRange::from_ctor(tcx, &r).map(|i| i.range)\n         });\n@@ -988,7 +987,7 @@ enum MissingCtors<'tcx> {\n // to compute the full set.)\n fn compute_missing_ctors<'a, 'tcx: 'a>(\n     info: MissingCtorsInfo,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     all_ctors: &Vec<Constructor<'tcx>>,\n     used_ctors: &Vec<Constructor<'tcx>>,\n ) -> MissingCtors<'tcx> {\n@@ -1424,12 +1423,12 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n // meaning all other types will compare unequal and thus equal patterns often do not cause the\n // second pattern to lint about unreachable match arms.\n fn slice_pat_covered_by_const<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, '_>,\n+    tcx: TyCtxt<'tcx, '_>,\n     _span: Span,\n     const_val: &'tcx ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n-    suffix: &[Pattern<'tcx>]\n+    suffix: &[Pattern<'tcx>],\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n         (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n@@ -1476,7 +1475,7 @@ fn slice_pat_covered_by_const<'tcx>(\n \n // Whether to evaluate a constructor using exhaustive integer matching. This is true if the\n // constructor is a range or constant with an integer type.\n-fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n+fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     let ty = match ctor {\n         ConstantValue(value) => value.ty,\n         ConstantRange(_, _, ty, _) => ty,\n@@ -1522,7 +1521,7 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Construct\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -1600,7 +1599,7 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n \n /// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &'p Pattern<'tcx>,\n ) -> Option<SmallVec<[&'p Pattern<'tcx>; 2]>> {\n@@ -1627,8 +1626,8 @@ fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n     }\n }\n \n-fn constructor_covered_by_range<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn constructor_covered_by_range<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,\n     pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {"}, {"sha": "0a60ed19b9a471735aa4ed88456f2b88e4965bc0", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -26,7 +26,7 @@ use std::slice;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n \n-pub(crate) fn check_match<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub(crate) fn check_match<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     let body_id = if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n         tcx.hir().body_owned_by(id)\n     } else {\n@@ -48,7 +48,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n }\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body_owner: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "4b6be426e5178c0ffb8d62caab55d872dbeede16", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -327,18 +327,20 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n }\n \n pub struct PatternContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub tables: &'a ty::TypeckTables<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n     pub errors: Vec<PatternError>,\n }\n \n impl<'a, 'tcx> Pattern<'tcx> {\n-    pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n-                    tables: &'a ty::TypeckTables<'tcx>,\n-                    pat: &'tcx hir::Pat) -> Self {\n+    pub fn from_hir(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+        pat: &'tcx hir::Pat,\n+    ) -> Self {\n         let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n@@ -351,9 +353,11 @@ impl<'a, 'tcx> Pattern<'tcx> {\n }\n \n impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n-               tables: &'a ty::TypeckTables<'tcx>) -> Self {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n+        tables: &'a ty::TypeckTables<'tcx>,\n+    ) -> Self {\n         PatternContext {\n             tcx,\n             param_env: param_env_and_substs.param_env,\n@@ -1055,7 +1059,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n }\n \n impl UserAnnotatedTyHelpers<'tcx, 'tcx> for PatternContext<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -1242,8 +1246,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n     }\n }\n \n-pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn compare_const_vals<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,"}, {"sha": "3b52f455190307f0ba1026beac892c96f9b8cd4d", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::ty::{self, CanonicalUserType, TyCtxt, UserType};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx>;\n \n     fn tables(&self) -> &ty::TypeckTables<'tcx>;\n "}, {"sha": "fbacdf6cd93bbf80629c9206df2a9db05788a85b", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::CastKind;\n \n use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "45c1f71e95043a2ae6d777e64b4b72f513904eb7", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -26,27 +26,25 @@ use super::{\n     Memory, Machine\n };\n \n-pub struct InterpretCx<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n+pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n-    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxtAt<'tcx, 'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n \n     /// The virtual memory system.\n-    pub(crate) memory: Memory<'a, 'mir, 'tcx, M>,\n+    pub(crate) memory: Memory<'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>>,\n \n     /// A cache for deduplicating vtables\n-    pub(super) vtables: FxHashMap<\n-        (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n-        Pointer<M::PointerTag>\n-    >,\n+    pub(super) vtables:\n+        FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n }\n \n /// A stack frame.\n@@ -160,35 +158,33 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for InterpretCx<'a, 'mir, 'tcx, M>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpretCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n-    where M: Machine<'a, 'mir, 'tcx>\n+impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'mir, 'tcx, M>\n+where\n+    M: Machine<'mir, 'tcx>,\n {\n     #[inline]\n-    fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         *self.tcx\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n-    where M: Machine<'a, 'mir, 'tcx>\n+impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'mir, 'tcx, M>\n+where\n+    M: Machine<'mir, 'tcx>,\n {\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n-    for InterpretCx<'a, 'mir, 'tcx, M>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n \n@@ -199,12 +195,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n-    pub fn new(\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        machine: M,\n-    ) -> Self {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+    pub fn new(tcx: TyCtxtAt<'tcx, 'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n         InterpretCx {\n             machine,\n             tcx,\n@@ -216,12 +208,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n+    pub fn memory(&self) -> &Memory<'mir, 'tcx, M> {\n         &self.memory\n     }\n \n     #[inline(always)]\n-    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'mir, 'tcx, M> {\n         &mut self.memory\n     }\n "}, {"sha": "beb5049307117c0325145a7adefde39426d8916d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -39,7 +39,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "a44a20adbca0e6b2700533361507fa24b5f152a7", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -9,12 +9,12 @@ use rustc::hir::def_id::CrateNum;\n use std::fmt::Write;\n use rustc::mir::interpret::{Allocation, ConstValue};\n \n-struct AbsolutePathPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct AbsolutePathPrinter<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     path: String,\n }\n \n-impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n     type Error = std::fmt::Error;\n \n     type Path = Self;\n@@ -23,7 +23,7 @@ impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n     type DynExistential = Self;\n     type Const = Self;\n \n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -167,7 +167,7 @@ impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n         }\n     }\n }\n-impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'tcx> {\n     fn region_should_not_be_omitted(\n         &self,\n         _region: ty::Region<'_>,\n@@ -204,15 +204,15 @@ impl PrettyPrinter<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n     }\n }\n \n-impl Write for AbsolutePathPrinter<'_, '_> {\n+impl Write for AbsolutePathPrinter<'_> {\n     fn write_str(&mut self, s: &str) -> std::fmt::Result {\n         Ok(self.path.push_str(s))\n     }\n }\n \n /// Produces an absolute path representation of the given type. See also the documentation on\n /// `std::any::type_name`\n-pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n+pub fn type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n     let alloc = alloc_type_name(tcx, ty);\n     tcx.mk_const(ty::Const {\n         val: ConstValue::Slice {\n@@ -225,10 +225,7 @@ pub fn type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx t\n }\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-pub(super) fn alloc_type_name<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ty: Ty<'tcx>\n-) -> &'tcx Allocation {\n+pub(super) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>) -> &'tcx Allocation {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_byte_aligned_bytes(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "97e65733bd4094ba1f657133c55eb6d9d3db04e6", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -58,7 +58,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied.\n-pub trait Machine<'a, 'mir, 'tcx>: Sized {\n+pub trait Machine<'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + MayLeak + Eq + 'static;\n \n@@ -95,11 +95,11 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool;\n+    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -112,7 +112,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n     fn find_fn(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n@@ -122,7 +122,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n@@ -137,23 +137,23 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n         def_id: DefId,\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx, 'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn ptr_op(\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &InterpretCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n@@ -193,21 +193,19 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a new stack frame got pushed\n-    fn stack_push(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, Self::FrameExtra>;\n+    fn stack_push(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n }"}, {"sha": "d9f522ab12f24f671254f2735a13f3ff9255f24f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -45,7 +45,7 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n \n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n-pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n+pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Allocations local to this instance of the miri engine. The kind\n     /// helps ensure that the same mechanism is used for allocation and\n     /// deallocation. When an allocation is not found here, it is a\n@@ -66,12 +66,10 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    pub(super) tcx: TyCtxtAt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for Memory<'a, 'mir, 'tcx, M>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n@@ -80,12 +78,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n \n // FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n // carefully copy only the reachable parts.\n-impl<'a, 'mir, 'tcx, M>\n-    Clone\n-for\n-    Memory<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> Clone for Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     fn clone(&self) -> Self {\n@@ -98,8 +93,8 @@ where\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>) -> Self {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    pub fn new(tcx: TyCtxtAt<'tcx, 'tcx>) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n@@ -312,7 +307,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Helper function to obtain the global (tcx) allocation for a static.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n@@ -329,7 +324,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n         id: AllocId,\n-        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxtAt<'tcx, 'tcx>,\n         memory_extra: &M::MemoryExtra,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n@@ -623,7 +618,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Byte Accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn read_bytes(\n         &self,\n         ptr: Scalar<M::PointerTag>,\n@@ -639,9 +634,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Interning (for CTFE)\n-impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n@@ -689,7 +684,7 @@ where\n }\n \n /// Reading and writing.\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn copy(\n         &mut self,\n         src: Scalar<M::PointerTag>,\n@@ -806,7 +801,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Undefined bytes\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     // FIXME: Add a fast version for the common, nonoverlapping case\n     fn copy_undef_mask(\n         &mut self,"}, {"sha": "87537ba57ae556f0f82acb0b20819b9dea9f83f6", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -211,7 +211,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace("}, {"sha": "e8a691733791a70f9ce17f544110a1e0c2ca7bfb", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -7,7 +7,7 @@ use rustc::mir::interpret::{InterpResult, Scalar};\n use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -36,7 +36,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "b8bb54815d8bf66ef81e1eb7d48d6ff2eb98538f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -290,11 +290,11 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'a, 'mir, 'tcx, Tag, M> InterpretCx<'a, 'mir, 'tcx, M>\n+impl<'mir, 'tcx, Tag, M> InterpretCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n+    M: Machine<'mir, 'tcx, PointerTag = Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n     M::AllocExtra: AllocationExtra<Tag>,\n@@ -396,8 +396,7 @@ where\n     pub fn mplace_array_fields(\n         &self,\n         base: MPlaceTy<'tcx, Tag>,\n-    ) ->\n-        InterpResult<'tcx, impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'a>\n+    ) -> InterpResult<'tcx, impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>> + 'tcx>\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {"}, {"sha": "f52fa0cd482725dbae3ad4bc01d7e6a8c81f8a1b", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -28,7 +28,7 @@ use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef\n use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n-pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n+pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n     /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n@@ -40,16 +40,15 @@ pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n     /// An `InterpSnapshot` will only be fully cloned once it has caused a\n     /// collision in `hashes`. As a result, the detector must observe at least\n     /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<InterpSnapshot<'a, 'mir, 'tcx>>,\n+    snapshots: FxHashSet<InterpSnapshot<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n-{\n-    pub fn observe_and_analyze<'b>(\n+impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n+    pub fn observe_and_analyze(\n         &mut self,\n-        tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         span: Span,\n-        memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>],\n     ) -> InterpResult<'tcx, ()> {\n         // Compute stack's hash before copying anything\n@@ -373,8 +372,8 @@ impl_stable_hash_for!(struct LocalState<'tcx> {\n     layout -> _,\n });\n \n-impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n-    for Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>\n+impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n+    for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n {\n     fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n         self.get(*id).ok()\n@@ -384,16 +383,15 @@ impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n /// The virtual machine state during const-evaluation at a given point in time.\n /// We assume the `CompileTimeInterpreter` has no interesting extra state that\n /// is worth considering here.\n-struct InterpSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n-    memory: Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+struct InterpSnapshot<'mir, 'tcx> {\n+    memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx: 'a + 'mir> InterpSnapshot<'a, 'mir, 'tcx>\n-{\n+impl InterpSnapshot<'mir, 'tcx> {\n     fn new(\n-        memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>]\n+        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+        stack: &[Frame<'mir, 'tcx>],\n     ) -> Self {\n         InterpSnapshot {\n             memory: memory.clone(),\n@@ -408,11 +406,9 @@ impl<'a, 'mir, 'tcx: 'a + 'mir> InterpSnapshot<'a, 'mir, 'tcx>\n         // Start with the stack, iterate and recursively snapshot\n         self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n     }\n-\n }\n \n-impl<'a, 'mir, 'tcx> Hash for InterpSnapshot<'a, 'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n         let mut hcx = self.memory.tcx.get_stable_hashing_context();\n@@ -422,17 +418,15 @@ impl<'a, 'mir, 'tcx> Hash for InterpSnapshot<'a, 'mir, 'tcx>\n     }\n }\n \n-impl_stable_hash_for!(impl<> for struct InterpSnapshot<'_, 'mir, 'tcx> {\n+impl_stable_hash_for!(impl<> for struct InterpSnapshot<'mir, 'tcx> {\n     // Not hashing memory: Avoid hashing memory all the time during execution\n     memory -> _,\n     stack,\n });\n \n-impl<'a, 'mir, 'tcx> Eq for InterpSnapshot<'a, 'mir, 'tcx>\n-{}\n+impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n \n-impl<'a, 'mir, 'tcx> PartialEq for InterpSnapshot<'a, 'mir, 'tcx>\n-{\n+impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         // FIXME: This looks to be a *ridiculously expensive* comparison operation.\n         // Doesn't this make tons of copies?  Either `snapshot` is very badly named,"}, {"sha": "2f99973b90d4a784331004d697de927a9a9c1a02", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -35,7 +35,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())"}, {"sha": "316a95e9400b45b10a341a2520a043bf1bf916a4", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -11,7 +11,7 @@ use super::{\n     InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "4ae0ee530553c0fe56a3b132800af053cab9916c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -4,7 +4,7 @@ use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n use super::{InterpretCx, InterpError, Machine, MemoryKind};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "8a8cc0fe1d174a3c2da6ad8fb569d53af91a5b24", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -149,17 +149,17 @@ fn wrapping_range_format(r: &RangeInclusive<u128>, max_hi: u128) -> String {\n     }\n }\n \n-struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a, 'mir, 'tcx>+'rt> {\n+struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// The `path` may be pushed to, but the part that is present when a function\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n     ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n     const_mode: bool,\n-    ecx: &'rt InterpretCx<'a, 'mir, 'tcx, M>,\n+    ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n }\n \n-impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(\n         &mut self,\n         layout: TyLayout<'tcx>,\n@@ -235,13 +235,13 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n     }\n }\n \n-impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n-    ValueVisitor<'a, 'mir, 'tcx, M> for ValidityVisitor<'rt, 'a, 'mir, 'tcx, M>\n+impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n+    for ValidityVisitor<'rt, 'mir, 'tcx, M>\n {\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&self) -> &InterpretCx<'a, 'mir, 'tcx, M> {\n+    fn ecx(&self) -> &InterpretCx<'mir, 'tcx, M> {\n         &self.ecx\n     }\n \n@@ -607,7 +607,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout."}, {"sha": "9150f16526ba7ee7c7b6551279c874862eebe4fe", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -14,15 +14,14 @@ use super::{\n // A thing that we can project into, and that has a layout.\n // This wouldn't have to depend on `Machine` but with the current type inference,\n // that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n-{\n+pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyLayout<'tcx>;\n \n     /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n@@ -31,23 +30,21 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self>;\n }\n \n // Operands and memory-places are both values.\n // Places in general are not due to `place_field` having to do `force_allocation`.\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n-    for OpTy<'tcx, M::PointerTag>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyLayout<'tcx> {\n         self.layout\n@@ -56,7 +53,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n@@ -69,7 +66,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n@@ -78,15 +75,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n     }\n }\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n-    for MPlaceTy<'tcx, M::PointerTag>\n-{\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyLayout<'tcx> {\n         self.layout\n@@ -95,7 +90,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n@@ -108,7 +103,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n@@ -117,7 +112,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n@@ -127,12 +122,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n macro_rules! make_value_visitor {\n     ($visitor_trait_name:ident, $($mutability:ident)?) => {\n         // How to traverse a value and what to do when we are at the leaves.\n-        pub trait $visitor_trait_name<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n-            type V: Value<'a, 'mir, 'tcx, M>;\n+        pub trait $visitor_trait_name<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n+            type V: Value<'mir, 'tcx, M>;\n \n             /// The visitor must have an `InterpretCx` in it.\n             fn ecx(&$($mutability)? self)\n-                -> &$($mutability)? InterpretCx<'a, 'mir, 'tcx, M>;\n+                -> &$($mutability)? InterpretCx<'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors."}, {"sha": "621fb8a4b22b360dc4a4ab973de59cf7c6ce117a", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -7,20 +7,20 @@ use rustc::mir::{self, Body, TerminatorKind};\n use rustc::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n-pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-             body: &Body<'tcx>,\n-             def_id: DefId) {\n+pub fn check(tcx: TyCtxt<'tcx, 'tcx>, body: &Body<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n         check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n     }\n }\n \n-fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        fn_kind: FnKind<'_>,\n-                                        body: &Body<'tcx>,\n-                                        def_id: DefId) {\n+fn check_fn_for_unconditional_recursion(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    fn_kind: FnKind<'_>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+) {\n     if let FnKind::Closure(_) = fn_kind {\n         // closures can't recur, so they don't matter.\n         return;"}, {"sha": "0b7dbfeacda594c215ef76dbeba919645965203c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 84, "deletions": 73, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -281,10 +281,10 @@ impl<'tcx> InliningMap<'tcx> {\n     }\n }\n \n-pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                          mode: MonoItemCollectionMode)\n-                                          -> (FxHashSet<MonoItem<'tcx>>,\n-                                                     InliningMap<'tcx>) {\n+pub fn collect_crate_mono_items<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mode: MonoItemCollectionMode,\n+) -> (FxHashSet<MonoItem<'tcx>>, InliningMap<'tcx>) {\n     let roots = time(tcx.sess, \"collecting roots\", || {\n         collect_roots(tcx, mode)\n     });\n@@ -315,9 +315,10 @@ pub fn collect_crate_mono_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n // Find all non-generic items by walking the HIR. These items serve as roots to\n // start monomorphizing from.\n-fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           mode: MonoItemCollectionMode)\n-                           -> Vec<MonoItem<'tcx>> {\n+fn collect_roots<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mode: MonoItemCollectionMode,\n+) -> Vec<MonoItem<'tcx>> {\n     debug!(\"Collecting roots\");\n     let mut roots = Vec::new();\n \n@@ -347,11 +348,13 @@ fn collect_roots<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n // Collect all monomorphized items reachable from `starting_point`\n-fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   starting_point: MonoItem<'tcx>,\n-                                   visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n-                                   recursion_depths: &mut DefIdMap<usize>,\n-                                   inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>) {\n+fn collect_items_rec<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    starting_point: MonoItem<'tcx>,\n+    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n+    recursion_depths: &mut DefIdMap<usize>,\n+    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+) {\n     if !visited.lock_mut().insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -413,10 +416,12 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(tcx, true));\n }\n \n-fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             caller: MonoItem<'tcx>,\n-                             callees: &[MonoItem<'tcx>],\n-                             inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>) {\n+fn record_accesses<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    caller: MonoItem<'tcx>,\n+    callees: &[MonoItem<'tcx>],\n+    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+) {\n     let is_inlining_candidate = |mono_item: &MonoItem<'tcx>| {\n         mono_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n@@ -429,10 +434,11 @@ fn record_accesses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     inlining_map.lock_mut().record_accesses(caller, accesses);\n }\n \n-fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   instance: Instance<'tcx>,\n-                                   recursion_depths: &mut DefIdMap<usize>)\n-                                   -> (DefId, usize) {\n+fn check_recursion_limit<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    recursion_depths: &mut DefIdMap<usize>,\n+) -> (DefId, usize) {\n     let def_id = instance.def_id();\n     let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n@@ -463,9 +469,7 @@ fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (def_id, recursion_depth)\n }\n \n-fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>)\n-{\n+fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: Instance<'tcx>) {\n     let type_length = instance.substs.types().flat_map(|ty| ty.walk()).count();\n     let const_length = instance.substs.consts().flat_map(|ct| ct.ty.walk()).count();\n     debug!(\" => type length={}, const length={}\", type_length, const_length);\n@@ -515,7 +519,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: SubstsRef<'tcx>,\n@@ -679,20 +683,22 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn visit_drop_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: Ty<'tcx>,\n-                            is_direct_call: bool,\n-                            output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn visit_drop_use<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    is_direct_call: bool,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     let instance = Instance::resolve_drop_in_place(tcx, ty);\n     visit_instance_use(tcx, instance, is_direct_call, output);\n }\n \n-fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          is_direct_call: bool,\n-                          output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn visit_fn_use<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    is_direct_call: bool,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     if let ty::FnDef(def_id, substs) = ty.sty {\n         let instance = ty::Instance::resolve(tcx,\n                                              ty::ParamEnv::reveal_all(),\n@@ -702,11 +708,12 @@ fn visit_fn_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                instance: ty::Instance<'tcx>,\n-                                is_direct_call: bool,\n-                                output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn visit_instance_use<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    is_direct_call: bool,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     debug!(\"visit_item_use({:?}, is_direct_call={:?})\", instance, is_direct_call);\n     if !should_monomorphize_locally(tcx, &instance) {\n         return\n@@ -741,8 +748,7 @@ fn visit_instance_use<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Returns true if we should codegen an instance in the local crate.\n // Returns false if we can just link to the upstream crate and therefore don't\n // need a mono item.\n-fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n-                                         -> bool {\n+fn should_monomorphize_locally<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: &Instance<'tcx>) -> bool {\n     let def_id = match instance.def {\n         ty::InstanceDef::Item(def_id) => def_id,\n         ty::InstanceDef::VtableShim(..) |\n@@ -776,10 +782,11 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n     }\n     return true;\n \n-    fn is_available_upstream_generic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               def_id: DefId,\n-                                               substs: SubstsRef<'tcx>)\n-                                               -> bool {\n+    fn is_available_upstream_generic<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+    ) -> bool {\n         debug_assert!(!def_id.is_local());\n \n         // If we are not in share generics mode, we don't link to upstream\n@@ -841,10 +848,11 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n ///\n /// Finally, there is also the case of custom unsizing coercions, e.g., for\n /// smart pointers such as `Rc` and `Arc`.\n-fn find_vtable_types_for_unsizing<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                            source_ty: Ty<'tcx>,\n-                                            target_ty: Ty<'tcx>)\n-                                            -> (Ty<'tcx>, Ty<'tcx>) {\n+fn find_vtable_types_for_unsizing<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    source_ty: Ty<'tcx>,\n+    target_ty: Ty<'tcx>,\n+) -> (Ty<'tcx>, Ty<'tcx>) {\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n             use syntax_pos::DUMMY_SP;\n@@ -914,10 +922,12 @@ fn create_fn_mono_item<'tcx>(instance: Instance<'tcx>) -> MonoItem<'tcx> {\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n /// the given trait/impl pair.\n-fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                  trait_ty: Ty<'tcx>,\n-                                                  impl_ty: Ty<'tcx>,\n-                                                  output: &mut Vec<MonoItem<'tcx>>) {\n+fn create_mono_items_for_vtable_methods<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_ty: Ty<'tcx>,\n+    impl_ty: Ty<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_bound_vars() &&\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_bound_vars());\n \n@@ -948,14 +958,14 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n // Root Collection\n //=-----------------------------------------------------------------------------\n \n-struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct RootCollector<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     mode: MonoItemCollectionMode,\n-    output: &'b mut Vec<MonoItem<'tcx>>,\n+    output: &'a mut Vec<MonoItem<'tcx>>,\n     entry_fn: Option<(DefId, EntryFnType)>,\n }\n \n-impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n+impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemKind::ExternCrate(..) |\n@@ -1044,7 +1054,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n+impl RootCollector<'_, 'v> {\n     fn is_root(&self, def_id: DefId) -> bool {\n         !item_requires_monomorphization(self.tcx, def_id) && match self.mode {\n             MonoItemCollectionMode::Eager => {\n@@ -1107,14 +1117,16 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn item_requires_monomorphization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn item_requires_monomorphization<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n     generics.requires_monomorphization(tcx)\n }\n \n-fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 item: &'tcx hir::Item,\n-                                                 output: &mut Vec<MonoItem<'tcx>>) {\n+fn create_mono_items_for_default_impls<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &'tcx hir::Item,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     match item.node {\n         hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n             for param in &generics.params {\n@@ -1176,8 +1188,8 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Scan the miri alloc in order to find function calls, closures, and drop-glue\n-fn collect_miri<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn collect_miri<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n@@ -1207,10 +1219,11 @@ fn collect_miri<'a, 'tcx>(\n }\n \n /// Scan the MIR in order to find function calls, closures, and drop-glue\n-fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                instance: Instance<'tcx>,\n-                                output: &mut Vec<MonoItem<'tcx>>)\n-{\n+fn collect_neighbours<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n     let body = tcx.instance_mir(instance.def);\n \n     MirNeighborCollector {\n@@ -1237,17 +1250,15 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> String {\n+fn def_id_to_string<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> String {\n     let mut output = String::new();\n     let printer = DefPathBasedNames::new(tcx, false, false);\n     printer.push_def_path(def_id, &mut output);\n     output\n }\n \n-fn collect_const<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn collect_const<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     constant: &'tcx ty::Const<'tcx>,\n     param_substs: SubstsRef<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,"}, {"sha": "1450534af5e5625c49e7c1c0d5b2f769f29a38ae", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -35,7 +35,7 @@ pub enum InstantiationMode {\n     LocalCopy,\n }\n \n-pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n+pub trait MonoItemExt<'tcx>: fmt::Debug {\n     fn as_mono_item(&self) -> &MonoItem<'tcx>;\n \n     fn is_generic_fn(&self) -> bool {\n@@ -48,7 +48,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n+    fn symbol_name(&self, tcx: TyCtxt<'tcx, 'tcx>) -> ty::SymbolName {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => {\n@@ -62,9 +62,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             }\n         }\n     }\n-    fn instantiation_mode(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                          -> InstantiationMode {\n+    fn instantiation_mode(&self, tcx: TyCtxt<'tcx, 'tcx>) -> InstantiationMode {\n         let inline_in_all_cgus =\n             tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n                 tcx.sess.opts.optimize != OptLevel::No\n@@ -108,7 +106,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n+    fn explicit_linkage(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n             MonoItem::Static(def_id) => def_id,\n@@ -144,7 +142,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     /// Similarly, if a vtable method has such a signature, and therefore can't\n     /// be used, we can just not emit it and have a placeholder (a null pointer,\n     /// which will never be accessed) in its place.\n-    fn is_instantiable(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+    fn is_instantiable(&self, tcx: TyCtxt<'tcx, 'tcx>) -> bool {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n@@ -156,7 +154,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n-    fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, debug: bool) -> String {\n+    fn to_string(&self, tcx: TyCtxt<'tcx, 'tcx>, debug: bool) -> String {\n         return match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance, debug)\n@@ -170,11 +168,12 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             }\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>,\n-                                        debug: bool)\n-                                        -> String {\n+        fn to_string_internal<'a, 'tcx>(\n+            tcx: TyCtxt<'tcx, 'tcx>,\n+            prefix: &str,\n+            instance: Instance<'tcx>,\n+            debug: bool,\n+        ) -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n             let printer = DefPathBasedNames::new(tcx, false, false);\n@@ -183,7 +182,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         }\n     }\n \n-    fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+    fn local_span(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Span> {\n         match *self.as_mono_item() {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir().as_local_hir_id(def.def_id())\n@@ -198,7 +197,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     }\n }\n \n-impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n+impl MonoItemExt<'tcx> for MonoItem<'tcx> {\n     fn as_mono_item(&self) -> &MonoItem<'tcx> {\n         self\n     }"}, {"sha": "667c0d7b29c5e0ee7eb61ba449ba3fcc451b888c", "filename": "src/librustc_mir/monomorphize/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -5,10 +5,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n pub mod collector;\n pub mod partitioning;\n \n-pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           source_ty: Ty<'tcx>,\n-                                           target_ty: Ty<'tcx>)\n-                                           -> CustomCoerceUnsized {\n+pub fn custom_coerce_unsize_info<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    source_ty: Ty<'tcx>,\n+    target_ty: Ty<'tcx>,\n+) -> CustomCoerceUnsized {\n     let def_id = tcx.lang_items().coerce_unsized_trait().unwrap();\n \n     let trait_ref = ty::Binder::bind(ty::TraitRef {"}, {"sha": "f05ccc45c9c4ccb555bf7af3199138d8317a6419", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -121,16 +121,18 @@ pub enum PartitioningStrategy {\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_, '_>) -> InternedString {\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_>) -> InternedString {\n     name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n-pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              mono_items: I,\n-                              strategy: PartitioningStrategy,\n-                              inlining_map: &InliningMap<'tcx>)\n-                              -> Vec<CodegenUnit<'tcx>>\n-    where I: Iterator<Item = MonoItem<'tcx>>\n+pub fn partition<'tcx, I>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mono_items: I,\n+    strategy: PartitioningStrategy,\n+    inlining_map: &InliningMap<'tcx>,\n+) -> Vec<CodegenUnit<'tcx>>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n {\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n@@ -201,10 +203,12 @@ struct PostInliningPartitioning<'tcx> {\n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n }\n \n-fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             mono_items: I)\n-                                             -> PreInliningPartitioning<'tcx>\n-    where I: Iterator<Item = MonoItem<'tcx>>\n+fn place_root_mono_items<'tcx, I>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mono_items: I,\n+) -> PreInliningPartitioning<'tcx>\n+where\n+    I: Iterator<Item = MonoItem<'tcx>>,\n {\n     let mut roots = FxHashSet::default();\n     let mut codegen_units = FxHashMap::default();\n@@ -276,7 +280,7 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn mono_item_linkage_and_visibility(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n     export_generics: bool,\n@@ -294,7 +298,7 @@ fn mono_item_linkage_and_visibility(\n }\n \n fn mono_item_visibility(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     mono_item: &MonoItem<'tcx>,\n     can_be_internalized: &mut bool,\n     export_generics: bool,\n@@ -439,7 +443,7 @@ fn mono_item_visibility(\n     }\n }\n \n-fn default_visibility(tcx: TyCtxt<'_, '_, '_>, id: DefId, is_generic: bool) -> Visibility {\n+fn default_visibility(tcx: TyCtxt<'_, '_>, id: DefId, is_generic: bool) -> Visibility {\n     if !tcx.sess.target.target.options.default_hidden_visibility {\n         return Visibility::Default\n     }\n@@ -463,9 +467,11 @@ fn default_visibility(tcx: TyCtxt<'_, '_, '_>, id: DefId, is_generic: bool) -> V\n     }\n }\n \n-fn merge_codegen_units<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                             initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-                             target_cgu_count: usize) {\n+fn merge_codegen_units<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+    target_cgu_count: usize,\n+) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n@@ -585,9 +591,11 @@ fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<\n     }\n }\n \n-fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 partitioning: &mut PostInliningPartitioning<'tcx>,\n-                                 inlining_map: &InliningMap<'tcx>) {\n+fn internalize_symbols<'tcx>(\n+    _tcx: TyCtxt<'tcx, 'tcx>,\n+    partitioning: &mut PostInliningPartitioning<'tcx>,\n+    inlining_map: &InliningMap<'tcx>,\n+) {\n     if partitioning.codegen_units.len() == 1 {\n         // Fast path for when there is only one codegen unit. In this case we\n         // can internalize all candidates, since there is nowhere else they\n@@ -650,9 +658,10 @@ fn internalize_symbols<'a, 'tcx>(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                mono_item: MonoItem<'tcx>)\n-                                                -> Option<DefId> {\n+fn characteristic_def_id_of_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mono_item: MonoItem<'tcx>,\n+) -> Option<DefId> {\n     match mono_item {\n         MonoItem::Fn(instance) => {\n             let def_id = match instance.def {\n@@ -698,12 +707,13 @@ fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n \n-fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_, '_>,\n-                             name_builder: &mut CodegenUnitNameBuilder<'_, '_, '_>,\n-                             def_id: DefId,\n-                             volatile: bool,\n-                             cache: &mut CguNameCache)\n-                             -> InternedString {\n+fn compute_codegen_unit_name(\n+    tcx: TyCtxt<'_, '_>,\n+    name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n+    def_id: DefId,\n+    volatile: bool,\n+    cache: &mut CguNameCache,\n+) -> InternedString {\n     // Find the innermost module that is not nested within a function.\n     let mut current_def_id = def_id;\n     let mut cgu_def_id = None;\n@@ -752,17 +762,17 @@ fn compute_codegen_unit_name(tcx: TyCtxt<'_, '_, '_>,\n     }).clone()\n }\n \n-fn numbered_codegen_unit_name(name_builder: &mut CodegenUnitNameBuilder<'_, '_, '_>,\n-                              index: usize)\n-                              -> InternedString {\n+fn numbered_codegen_unit_name(\n+    name_builder: &mut CodegenUnitNameBuilder<'_, '_>,\n+    index: usize,\n+) -> InternedString {\n     name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               label: &str,\n-                               cgus: I)\n-    where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n-          'tcx: 'a + 'b\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'tcx, 'tcx>, label: &str, cgus: I)\n+where\n+    I: Iterator<Item = &'b CodegenUnit<'tcx>>,\n+    'tcx: 'a + 'b,\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n@@ -787,8 +797,9 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n #[inline(never)] // give this a place in the profiler\n-fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mono_items: I)\n-    where I: Iterator<Item=&'a MonoItem<'tcx>>\n+fn assert_symbols_are_distinct<'a, 'tcx: 'a, I>(tcx: TyCtxt<'tcx, 'tcx>, mono_items: I)\n+where\n+    I: Iterator<Item = &'a MonoItem<'tcx>>,\n {\n     let mut symbols: Vec<_> = mono_items.map(|mono_item| {\n         (mono_item, mono_item.symbol_name(tcx))\n@@ -830,11 +841,10 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mono_it\n     }\n }\n \n-fn collect_and_partition_mono_items<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn collect_and_partition_mono_items<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     cnum: CrateNum,\n-) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n-{\n+) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>) {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {"}, {"sha": "ea11901672a23369bb9fbad7ae73ffa899876b43", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -26,10 +26,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     providers.mir_shims = make_shim;\n }\n \n-fn make_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       instance: ty::InstanceDef<'tcx>)\n-                       -> &'tcx Body<'tcx>\n-{\n+fn make_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx Body<'tcx> {\n     debug!(\"make_shim({:?})\", instance);\n \n     let mut result = match instance {\n@@ -166,11 +163,11 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n         .collect()\n }\n \n-fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             ty: Option<Ty<'tcx>>)\n-                             -> Body<'tcx>\n-{\n+fn build_drop_shim<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    ty: Option<Ty<'tcx>>,\n+) -> Body<'tcx> {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n@@ -258,7 +255,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n     pub body: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub tcx: TyCtxt<'tcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -273,7 +270,9 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n     fn body(&self) -> &'a Body<'tcx> { self.body }\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n+        self.tcx\n+        }\n     fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n     fn drop_style(&self, _path: Self::Path, mode: DropFlagMode) -> DropStyle {\n@@ -306,11 +305,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n }\n \n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n-fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId,\n-                              self_ty: Ty<'tcx>)\n-                              -> Body<'tcx>\n-{\n+fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n@@ -340,19 +335,17 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     builder.into_mir()\n }\n \n-struct CloneShimBuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CloneShimBuilder<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     span: Span,\n     sig: ty::FnSig<'tcx>,\n }\n \n-impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           def_id: DefId,\n-           self_ty: Ty<'tcx>) -> Self {\n+impl CloneShimBuilder<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Self {\n         // we must subst the self_ty because it's\n         // otherwise going to be TySelf and we can't index\n         // or access fields of a Place of type TySelf.\n@@ -691,13 +684,13 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n ///\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n-fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             def_id: DefId,\n-                             rcvr_adjustment: Adjustment,\n-                             call_kind: CallKind,\n-                             untuple_args: Option<&[Ty<'tcx>]>)\n-                             -> Body<'tcx>\n-{\n+fn build_call_shim<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    rcvr_adjustment: Adjustment,\n+    call_kind: CallKind,\n+    untuple_args: Option<&[Ty<'tcx>]>,\n+) -> Body<'tcx> {\n     debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n@@ -842,7 +835,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     body\n }\n \n-pub fn build_adt_ctor<'gcx>(tcx: TyCtxt<'_, 'gcx, 'gcx>, ctor_id: DefId) -> &'gcx Body<'gcx> {\n+pub fn build_adt_ctor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ctor_id: DefId) -> &'tcx Body<'tcx> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n     let span = tcx.hir().span_if_local(ctor_id)"}, {"sha": "56c824167e185bfaa9bec1e9a6a9046f17842611", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -31,10 +31,12 @@ pub use self::AddCallGuards::*;\n  */\n \n impl MirPass for AddCallGuards {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         self.add_call_guards(body);\n     }\n }"}, {"sha": "673b13a22d3d72aef2e93bdf9269ef5933745c2d", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -40,31 +40,26 @@ use crate::util;\n pub struct AddMovesForPackedDrops;\n \n impl MirPass for AddMovesForPackedDrops {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n         add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n }\n \n-pub fn add_moves_for_packed_drops<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn add_moves_for_packed_drops<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &mut Body<'tcx>,\n-    def_id: DefId)\n-{\n+    def_id: DefId,\n+) {\n     let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n     patch.apply(body);\n }\n \n-fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn add_moves_for_packed_drops_patch<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &Body<'tcx>,\n-    def_id: DefId)\n-    -> MirPatch<'tcx>\n-{\n+    def_id: DefId,\n+) -> MirPatch<'tcx> {\n     let mut patch = MirPatch::new(body);\n     let param_env = tcx.param_env(def_id);\n \n@@ -90,14 +85,14 @@ fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n     patch\n }\n \n-fn add_move_for_packed_drop<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn add_move_for_packed_drop<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     patch: &mut MirPatch<'tcx>,\n     terminator: &Terminator<'tcx>,\n     loc: Location,\n-    is_cleanup: bool)\n-{\n+    is_cleanup: bool,\n+) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n     let (location, target, unwind) = match terminator.kind {\n         TerminatorKind::Drop { ref location, target, unwind } =>"}, {"sha": "a67fce9028a324e1983db49d79400780717bdabd", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -48,7 +48,7 @@ fn is_stable<'tcx>(\n \n /// Determine whether this type may have a reference in it, recursing below compound types but\n /// not below references.\n-fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+fn may_have_reference<'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'gcx, 'tcx>) -> bool {\n     match ty.sty {\n         // Primitive types that are not references\n         ty::Bool | ty::Char |\n@@ -74,11 +74,12 @@ fn may_have_reference<'a, 'gcx, 'tcx>(ty: Ty<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n }\n \n impl MirPass for AddRetag {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }"}, {"sha": "0adb37b8722a34bb03475365acb9fe7c13ec9e14", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,7 +25,7 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n     violations: Vec<UnsafetyViolation>,\n     source_info: SourceInfo,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     /// Mark an `unsafe` block as used, so we don't lint it.\n     used_unsafe: FxHashSet<hir::HirId>,\n@@ -38,7 +38,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         min_const_fn: bool,\n         body: &'a Body<'tcx>,\n         source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         // sanity check\n@@ -480,11 +480,12 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n     }\n }\n \n-fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 def_id: DefId,\n-                                 used_unsafe: &FxHashSet<hir::HirId>,\n-                                 unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>)\n-{\n+fn check_unused_unsafe<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    used_unsafe: &FxHashSet<hir::HirId>,\n+    unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>,\n+) {\n     let body_id =\n         tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n             tcx.hir().maybe_body_owned_by_by_hir_id(hir_id)\n@@ -505,9 +506,7 @@ fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hir::intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> UnsafetyCheckResult\n-{\n+fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def_id);\n \n     // N.B., this borrow is valid because all the consumers of\n@@ -546,7 +545,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n }\n \n-fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn unsafe_derive_on_repr_packed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     let lint_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap_or_else(||\n         bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n@@ -566,9 +565,11 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n }\n \n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n-fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n-               used_unsafe: &FxHashSet<hir::HirId>,\n-               id: hir::HirId) -> Option<(String, hir::HirId)> {\n+fn is_enclosed(\n+    tcx: TyCtxt<'_, '_>,\n+    used_unsafe: &FxHashSet<hir::HirId>,\n+    id: hir::HirId,\n+) -> Option<(String, hir::HirId)> {\n     let parent_id = tcx.hir().get_parent_node_by_hir_id(id);\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n@@ -589,9 +590,7 @@ fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n     }\n }\n \n-fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n-                        used_unsafe: &FxHashSet<hir::HirId>,\n-                        id: hir::HirId) {\n+fn report_unused_unsafe(tcx: TyCtxt<'_, '_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n     let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n@@ -603,7 +602,7 @@ fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n     db.emit();\n }\n \n-fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n+fn builtin_derive_def_id<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     debug!(\"builtin_derive_def_id({:?})\", def_id);\n     if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n         if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n@@ -619,7 +618,7 @@ fn builtin_derive_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -\n     }\n }\n \n-pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     debug!(\"check_unsafety({:?})\", def_id);\n \n     // closures are handled by their parent fn."}, {"sha": "fb4fdf73a9389b1a05e763e2071493a8b8487337", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -27,10 +27,12 @@ pub struct CleanupNonCodegenStatements;\n pub struct DeleteNonCodegenStatements;\n \n impl MirPass for CleanupNonCodegenStatements {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let mut delete = DeleteNonCodegenStatements;\n         delete.visit_body(body);\n     }"}, {"sha": "dfc2e7e7c9d86b118d943bacdadd39bcd0e43a49", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -31,10 +31,12 @@ use crate::transform::{MirPass, MirSource};\n pub struct ConstProp;\n \n impl MirPass for ConstProp {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -83,9 +85,9 @@ impl MirPass for ConstProp {\n type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n-struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n-    ecx: InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ConstPropagator<'mir, 'tcx> {\n+    ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     source: MirSource<'tcx>,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -95,7 +97,7 @@ struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     promoted: IndexVec<Promoted, Body<'tcx>>,\n }\n \n-impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n+impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n \n@@ -104,26 +106,26 @@ impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> HasDataLayout for ConstPropagator<'a, 'b, 'tcx> {\n+impl<'mir, 'tcx> HasDataLayout for ConstPropagator<'mir, 'tcx> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n+impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n     #[inline]\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n+impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n         body: &mut Body<'tcx>,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         source: MirSource<'tcx>,\n-    ) -> ConstPropagator<'a, 'mir, 'tcx> {\n+    ) -> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id());\n         let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n         let can_const_prop = CanConstProp::check(body);\n@@ -599,9 +601,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     }\n }\n \n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>) -> Option<u64> {\n+fn type_size_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<u64> {\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n@@ -668,7 +672,7 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n     }\n }\n \n-impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n+impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_constant(\n         &mut self,\n         constant: &mut Constant<'tcx>,"}, {"sha": "aeb3ed5a2eca85170db79f3b9bea5b0d6ec6fba3", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -30,10 +30,12 @@ use crate::util::def_use::DefUseAnalysis;\n pub struct CopyPropagation;\n \n impl MirPass for CopyPropagation {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {"}, {"sha": "87704f12216560463a8989d352eef02848ebd114", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,10 +6,12 @@ use crate::util::expand_aggregate;\n pub struct Deaggregator;\n \n impl MirPass for Deaggregator {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "96be0e6f6a9d7cd942ff8ab72446c342210ec1cb", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,11 +18,12 @@ impl MirPass for Marker {\n         Cow::Borrowed(self.0)\n     }\n \n-    fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _source: MirSource<'tcx>,\n-                          _body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _source: MirSource<'tcx>,\n+        _body: &mut Body<'tcx>,\n+    ) {\n     }\n }\n \n@@ -37,13 +38,14 @@ impl fmt::Display for Disambiguator {\n     }\n }\n \n-\n-pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             pass_num: &dyn fmt::Display,\n-                             pass_name: &str,\n-                             source: MirSource<'tcx>,\n-                             body: &Body<'tcx>,\n-                             is_after: bool) {\n+pub fn on_mir_pass<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    pass_num: &dyn fmt::Display,\n+    pass_name: &str,\n+    source: MirSource<'tcx>,\n+    body: &Body<'tcx>,\n+    is_after: bool,\n+) {\n     if mir_util::dump_enabled(tcx, pass_name, source) {\n         mir_util::dump_mir(tcx,\n                            Some(pass_num),\n@@ -55,11 +57,7 @@ pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn emit_mir<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    outputs: &OutputFilenames)\n-    -> io::Result<()>\n-{\n+pub fn emit_mir<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, outputs: &OutputFilenames) -> io::Result<()> {\n     let path = outputs.path(OutputType::Mir);\n     let mut f = File::create(&path)?;\n     mir_util::write_mir_pretty(tcx, None, &mut f)?;"}, {"sha": "bf6237fa91acfe4683a57f89ee4a64bc57132813", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,11 +21,7 @@ use syntax_pos::Span;\n pub struct ElaborateDrops;\n \n impl MirPass for ElaborateDrops {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>)\n-    {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();\n@@ -77,13 +73,12 @@ impl MirPass for ElaborateDrops {\n /// Returns the set of basic blocks whose unwind edges are known\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything.\n-fn find_dead_unwinds<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn find_dead_unwinds<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     def_id: hir::def_id::DefId,\n-    env: &MoveDataParamEnv<'tcx, 'tcx>)\n-    -> BitSet<BasicBlock>\n-{\n+    env: &MoveDataParamEnv<'tcx, 'tcx>,\n+) -> BitSet<BasicBlock> {\n     debug!(\"find_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n@@ -141,12 +136,13 @@ struct InitializationData {\n }\n \n impl InitializationData {\n-    fn apply_location<'a,'tcx>(&mut self,\n-                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               body: &Body<'tcx>,\n-                               env: &MoveDataParamEnv<'tcx, 'tcx>,\n-                               loc: Location)\n-    {\n+    fn apply_location<'tcx>(\n+        &mut self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        body: &Body<'tcx>,\n+        env: &MoveDataParamEnv<'tcx, 'tcx>,\n+        loc: Location,\n+    ) {\n         drop_flag_effects_for_location(tcx, body, env, loc, |path, df| {\n             debug!(\"at location {:?}: setting {:?} to {:?}\",\n                    loc, path, df);\n@@ -190,7 +186,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         self.ctxt.body\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.ctxt.tcx\n     }\n \n@@ -290,11 +286,11 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n }\n \n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n     flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n-    flow_uninits:  DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n+    flow_uninits: DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "39d5770ee9a091ece623992fed352c0dfecfb7c6", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -10,19 +10,19 @@ use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, TyContext};\n use crate::transform::{MirPass, MirSource};\n \n-struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct EraseRegionsVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl EraseRegionsVisitor<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx,\n         }\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n+impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         *ty = self.tcx.erase_regions(ty);\n         self.super_ty(ty);\n@@ -50,10 +50,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n pub struct EraseRegions;\n \n impl MirPass for EraseRegions {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "d369fec8c1e67133454a5be1d01f4ac32265a965", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 65, "deletions": 54, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -168,8 +168,8 @@ struct SuspensionPoint {\n     storage_liveness: liveness::LiveVarSet,\n }\n \n-struct TransformVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct TransformVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: SubstsRef<'tcx>,\n \n@@ -191,7 +191,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     new_ret_local: Local,\n }\n \n-impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n+impl TransformVisitor<'tcx> {\n     // Make a GeneratorState rvalue\n     fn make_state(&self, idx: VariantIdx, val: Operand<'tcx>) -> Rvalue<'tcx> {\n         let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None, None);\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -310,10 +310,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n     }\n }\n \n-fn make_generator_state_argument_indirect<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                def_id: DefId,\n-                body: &mut Body<'tcx>) {\n+fn make_generator_state_argument_indirect<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    body: &mut Body<'tcx>,\n+) {\n     let gen_ty = body.local_decls.raw[1].ty;\n \n     let region = ty::ReFree(ty::FreeRegion {\n@@ -335,9 +336,7 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n     DerefArgVisitor.visit_body(body);\n }\n \n-fn make_generator_state_argument_pinned<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                body: &mut Body<'tcx>) {\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n@@ -416,7 +415,7 @@ struct LivenessInfo {\n }\n \n fn locals_live_across_suspend_points(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n@@ -678,16 +677,18 @@ impl<'body, 'tcx: 'body, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     }\n }\n \n-fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            source: MirSource<'tcx>,\n-                            upvars: &Vec<Ty<'tcx>>,\n-                            interior: Ty<'tcx>,\n-                            movable: bool,\n-                            body: &mut Body<'tcx>)\n-    -> (FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n-        GeneratorLayout<'tcx>,\n-        FxHashMap<BasicBlock, liveness::LiveVarSet>)\n-{\n+fn compute_layout<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    source: MirSource<'tcx>,\n+    upvars: &Vec<Ty<'tcx>>,\n+    interior: Ty<'tcx>,\n+    movable: bool,\n+    body: &mut Body<'tcx>,\n+) -> (\n+    FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n+    GeneratorLayout<'tcx>,\n+    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n         live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n@@ -767,10 +768,12 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx>(body: &mut Body<'tcx>,\n-                           cases: Vec<(usize, BasicBlock)>,\n-                           transform: &TransformVisitor<'a, 'tcx>,\n-                           default: TerminatorKind<'tcx>) {\n+fn insert_switch<'tcx>(\n+    body: &mut Body<'tcx>,\n+    cases: Vec<(usize, BasicBlock)>,\n+    transform: &TransformVisitor<'tcx>,\n+    default: TerminatorKind<'tcx>,\n+) {\n     let default_block = insert_term_block(body, default);\n     let (assign, discr) = transform.get_discr(body);\n     let switch = TerminatorKind::SwitchInt {\n@@ -797,9 +800,7 @@ fn insert_switch<'a, 'tcx>(body: &mut Body<'tcx>,\n     }\n }\n \n-fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       def_id: DefId,\n-                                       body: &mut Body<'tcx>) {\n+fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &mut Body<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -848,14 +849,15 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     elaborator.patch.apply(body);\n }\n \n-fn create_generator_drop_shim<'a, 'tcx>(\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                transform: &TransformVisitor<'a, 'tcx>,\n-                def_id: DefId,\n-                source: MirSource<'tcx>,\n-                gen_ty: Ty<'tcx>,\n-                body: &Body<'tcx>,\n-                drop_clean: BasicBlock) -> Body<'tcx> {\n+fn create_generator_drop_shim<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    transform: &TransformVisitor<'tcx>,\n+    def_id: DefId,\n+    source: MirSource<'tcx>,\n+    gen_ty: Ty<'tcx>,\n+    body: &Body<'tcx>,\n+    drop_clean: BasicBlock,\n+) -> Body<'tcx> {\n     let mut body = body.clone();\n \n     let source_info = source_info(&body);\n@@ -939,9 +941,11 @@ fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n     term_block\n }\n \n-fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                body: &mut Body<'tcx>,\n-                                message: AssertMessage<'tcx>) -> BasicBlock {\n+fn insert_panic_block<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    body: &mut Body<'tcx>,\n+    message: AssertMessage<'tcx>,\n+) -> BasicBlock {\n     let assert_block = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n@@ -969,12 +973,13 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_block\n }\n \n-fn create_generator_resume_function<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        transform: TransformVisitor<'a, 'tcx>,\n-        def_id: DefId,\n-        source: MirSource<'tcx>,\n-        body: &mut Body<'tcx>) {\n+fn create_generator_resume_function<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    transform: TransformVisitor<'tcx>,\n+    def_id: DefId,\n+    source: MirSource<'tcx>,\n+    body: &mut Body<'tcx>,\n+) {\n     // Poison the generator when it unwinds\n     for block in body.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n@@ -1042,10 +1047,14 @@ fn insert_clean_drop<'tcx>(body: &mut Body<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'a, 'tcx, F>(body: &mut Body<'tcx>,\n-                          transform: &TransformVisitor<'a, 'tcx>,\n-                          target: F) -> Vec<(usize, BasicBlock)>\n-    where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n+fn create_cases<'tcx, F>(\n+    body: &mut Body<'tcx>,\n+    transform: &TransformVisitor<'tcx>,\n+    target: F,\n+) -> Vec<(usize, BasicBlock)>\n+where\n+    F: Fn(&SuspensionPoint) -> Option<BasicBlock>,\n+{\n     let source_info = source_info(body);\n \n     transform.suspension_points.iter().filter_map(|point| {\n@@ -1083,10 +1092,12 @@ fn create_cases<'a, 'tcx, F>(body: &mut Body<'tcx>,\n }\n \n impl MirPass for StateTransform {\n-    fn run_pass<'a, 'tcx>(&self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    source: MirSource<'tcx>,\n-                    body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {"}, {"sha": "55c035f2858a28aef8d1612398d896b687be4c37", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -38,22 +38,24 @@ struct CallSite<'tcx> {\n }\n \n impl MirPass for Inline {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(body);\n         }\n     }\n }\n \n-struct Inliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Inliner<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     source: MirSource<'tcx>,\n }\n \n-impl<'a, 'tcx> Inliner<'a, 'tcx> {\n+impl Inliner<'tcx> {\n     fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n@@ -631,9 +633,11 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     }\n }\n \n-fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>) -> Option<u64> {\n+fn type_size_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<u64> {\n     tcx.layout_of(param_env.and(ty)).ok().map(|layout| layout.size.bytes())\n }\n \n@@ -643,7 +647,7 @@ fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n  * Integrates blocks from the callee function into the calling function.\n  * Updates block indices, references to locals and other control flow\n  * stuff.\n- */\n+*/\n struct Integrator<'a, 'tcx: 'a> {\n     block_idx: usize,\n     args: &'a [Local],"}, {"sha": "2194b780ab967d12a6e2463725d828a25edc874c", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -12,10 +12,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct InstCombine;\n \n impl MirPass for InstCombine {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -63,14 +60,14 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n }\n \n /// Finds optimization opportunities on the MIR.\n-struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n+struct OptimizationFinder<'b, 'tcx> {\n     body: &'b Body<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     optimizations: OptimizationList<'tcx>,\n }\n \n-impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n-    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n+impl OptimizationFinder<'b, 'tcx> {\n+    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'tcx, 'tcx>) -> OptimizationFinder<'b, 'tcx> {\n         OptimizationFinder {\n             body,\n             tcx,\n@@ -79,7 +76,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n+impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {"}, {"sha": "34a982f72761fc982c38a74d7ae804927fa6c936", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -10,22 +10,24 @@ use crate::transform::{MirPass, MirSource};\n pub struct Lower128Bit;\n \n impl MirPass for Lower128Bit {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n         let target_default = tcx.sess.host.options.i128_lowering;\n         if !debugging_override.unwrap_or(target_default) {\n             return\n         }\n \n         self.lower_128bit_ops(tcx, body);\n-    }\n+}\n }\n \n impl Lower128Bit {\n-    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+    fn lower_128bit_ops<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n         let mut new_blocks = Vec::new();\n         let cur_len = body.basic_blocks().len();\n \n@@ -120,15 +122,16 @@ impl Lower128Bit {\n     }\n }\n \n-fn check_lang_item_type<'a, 'tcx, D>(\n+fn check_lang_item_type<'tcx, D>(\n     lang_item: LangItem,\n     place: &Place<'tcx>,\n     lhs: &Operand<'tcx>,\n     rhs: &Operand<'tcx>,\n     local_decls: &D,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>)\n--> DefId\n-    where D: HasLocalDecls<'tcx>\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+) -> DefId\n+where\n+    D: HasLocalDecls<'tcx>,\n {\n     let did = tcx.require_lang_item(lang_item);\n     let poly_sig = tcx.fn_sig(did);\n@@ -142,9 +145,13 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     did\n }\n \n-fn lower_to<'a, 'tcx, D>(statement: &Statement<'tcx>, local_decls: &D, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-    -> Option<(LangItem, RhsKind)>\n-    where D: HasLocalDecls<'tcx>\n+fn lower_to<'tcx, D>(\n+    statement: &Statement<'tcx>,\n+    local_decls: &D,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+) -> Option<(LangItem, RhsKind)>\n+where\n+    D: HasLocalDecls<'tcx>,\n {\n     match statement.kind {\n         StatementKind::Assign(_, box Rvalue::BinaryOp(bin_op, ref lhs, _)) => {\n@@ -172,7 +179,7 @@ enum RhsKind {\n }\n \n impl RhsKind {\n-    fn ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn ty<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match *self {\n             RhsKind::Unchanged => None,\n             RhsKind::ForceU128 => Some(tcx.types.u128),"}, {"sha": "6f369acec64402466d78825f842f2aea1cb9b116", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -50,14 +50,13 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_mir_available<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     tcx.mir_keys(def_id.krate).contains(&def_id)\n }\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n-                      -> &'tcx DefIdSet {\n+fn mir_keys<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx DefIdSet {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let mut set = DefIdSet::default();\n@@ -68,7 +67,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n     // Additionally, tuple struct/variant constructors have MIR, but\n     // they don't have a BodyId, so we need to build them separately.\n     struct GatherCtors<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         set: &'a mut DefIdSet,\n     }\n     impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n@@ -95,7 +94,7 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_built<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n@@ -142,14 +141,16 @@ pub trait MirPass {\n         default_name::<Self>()\n     }\n \n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          source: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>);\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        source: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    );\n }\n \n pub fn run_passes(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n     mir_phase: MirPhase,\n@@ -196,7 +197,7 @@ pub fn run_passes(\n     }\n }\n \n-fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_const<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -210,7 +211,7 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     tcx.alloc_steal_mir(body)\n }\n \n-fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n+fn mir_validated(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n@@ -227,7 +228,7 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     tcx.alloc_steal_mir(body)\n }\n \n-fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n+fn optimized_mir<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n     if tcx.is_constructor(def_id) {\n         // There's no reason to run all of the MIR passes on constructors when\n         // we can just output the MIR we want directly. This also saves const"}, {"sha": "6f3f2269d44d2df0200c2e47ff44ce7a2c1c44f6", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -9,15 +9,12 @@ use crate::transform::{MirPass, MirSource};\n pub struct NoLandingPads;\n \n impl MirPass for NoLandingPads {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n+pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         NoLandingPads.visit_body(body);\n     }"}, {"sha": "f3d05f065ce73470761d49ffa4fe90ff5d16d585", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -148,14 +148,14 @@ pub fn collect_temps(body: &Body<'_>,\n }\n \n struct Promoter<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     source: &'a mut Body<'tcx>,\n     promoted: Body<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n-    keep_original: bool\n+    keep_original: bool,\n }\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n@@ -369,10 +369,12 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     }\n }\n \n-pub fn promote_candidates<'a, 'tcx>(body: &mut Body<'tcx>,\n-                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    mut temps: IndexVec<Local, TempState>,\n-                                    candidates: Vec<Candidate>) {\n+pub fn promote_candidates<'tcx>(\n+    body: &mut Body<'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    mut temps: IndexVec<Local, TempState>,\n+    candidates: Vec<Candidate>,\n+) {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n "}, {"sha": "125411a717d1ef2dcb5250aed0e936fa5505fa25", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -124,7 +124,7 @@ impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n }\n \n struct ConstCx<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n     body: &'a Body<'tcx>,\n@@ -652,11 +652,7 @@ impl Deref for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           def_id: DefId,\n-           body: &'a Body<'tcx>,\n-           mode: Mode)\n-           -> Self {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(body);\n         let temps = promote_consts::collect_temps(body, &mut rpo);\n@@ -1472,9 +1468,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> (u8, &'tcx BitSet<Local>) {\n+fn mir_const_qualif<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> (u8, &'tcx BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1492,10 +1486,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub struct QualifyAndPromoteConstants;\n \n impl MirPass for QualifyAndPromoteConstants {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         if body.return_ty().references_error() {\n             tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");\n@@ -1668,7 +1659,7 @@ impl MirPass for QualifyAndPromoteConstants {\n     }\n }\n \n-fn args_required_const(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n+fn args_required_const(tcx: TyCtxt<'_, '_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n     let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n     let mut ret = FxHashSet::default();"}, {"sha": "7f5afb2394a469a65704ce8ff027dd9436d566e8", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -8,11 +8,7 @@ use syntax_pos::Span;\n \n type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n-pub fn is_min_const_fn(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-    body: &'a Body<'tcx>,\n-) -> McfResult {\n+pub fn is_min_const_fn(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     let mut current = def_id;\n     loop {\n         let predicates = tcx.predicates_of(current);\n@@ -79,12 +75,7 @@ pub fn is_min_const_fn(\n     Ok(())\n }\n \n-fn check_ty(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ty: Ty<'tcx>,\n-    span: Span,\n-    fn_def_id: DefId,\n-) -> McfResult {\n+fn check_ty(tcx: TyCtxt<'tcx, 'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.sty {\n             ty::Ref(_, _, hir::Mutability::MutMutable) => return Err((\n@@ -129,7 +120,7 @@ fn check_ty(\n }\n \n fn check_rvalue(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     rvalue: &Rvalue<'tcx>,\n     span: Span,\n@@ -209,7 +200,7 @@ fn check_rvalue(\n }\n \n fn check_statement(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     statement: &Statement<'tcx>,\n ) -> McfResult {\n@@ -279,7 +270,7 @@ fn check_place(\n }\n \n fn check_terminator(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     body: &'a Body<'tcx>,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n@@ -375,7 +366,7 @@ fn check_terminator(\n /// for being called from stable `const fn`s (`min_const_fn`).\n ///\n /// Adding more intrinsics requires sign-off from @rust-lang/lang.\n-fn is_intrinsic_whitelisted(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_intrinsic_whitelisted(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     match &tcx.item_name(def_id).as_str()[..] {\n         | \"size_of\"\n         | \"min_align_of\""}, {"sha": "1a23fdce050b0d373e64dfbe10c57a64c544f028", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -9,10 +9,7 @@ use crate::util::patch::MirPatch;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    body: &mut Body<'tcx>)\n-{\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n@@ -22,10 +19,12 @@ pub fn remove_noop_landing_pads<'a, 'tcx>(\n }\n \n impl MirPass for RemoveNoopLandingPads {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         remove_noop_landing_pads(tcx, body);\n     }\n }"}, {"sha": "1d57f5e27164d76a58614017bfcce0c5b6e2148f", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,8 +25,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl MirPass for SanityCheck {\n-    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -84,12 +83,14 @@ impl MirPass for SanityCheck {\n /// (If there are any calls to `rustc_peek` that do not match the\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n-pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                body: &Body<'tcx>,\n-                                                def_id: DefId,\n-                                                _attributes: &[ast::Attribute],\n-                                                results: &DataflowResults<'tcx, O>)\n-    where O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n+pub fn sanity_check_via_rustc_peek<'tcx, O>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    _attributes: &[ast::Attribute],\n+    results: &DataflowResults<'tcx, O>,\n+) where\n+    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n {\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n     // FIXME: this is not DRY. Figure out way to abstract this and\n@@ -101,11 +102,13 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           body: &Body<'tcx>,\n-                           results: &DataflowResults<'tcx, O>,\n-                           bb: mir::BasicBlock) where\n-    O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n+fn each_block<'tcx, O>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    body: &Body<'tcx>,\n+    results: &DataflowResults<'tcx, O>,\n+    bb: mir::BasicBlock,\n+) where\n+    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n {\n     let move_data = results.0.operator.move_data();\n     let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = body[bb];\n@@ -214,9 +217,10 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       form `&expr`\"));\n }\n \n-fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           terminator: &'a Option<mir::Terminator<'tcx>>)\n-                           -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n+fn is_rustc_peek<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    terminator: &'a Option<mir::Terminator<'tcx>>,\n+) -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n     if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n         if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n             if let mir::Operand::Constant(ref func) = *oper {"}, {"sha": "ba3a00517ffb036b9cc4de4a6cae58465e24c5ac", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -57,10 +57,12 @@ impl MirPass for SimplifyCfg {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'a, 'tcx>(&self,\n-                          _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        _tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n         simplify_cfg(body);\n     }\n@@ -296,10 +298,7 @@ pub fn remove_dead_blocks(body: &mut Body<'_>) {\n pub struct SimplifyLocals;\n \n impl MirPass for SimplifyLocals {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(&self, tcx: TyCtxt<'tcx, 'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };\n         marker.visit_body(body);\n         // Return pointer and arguments are always live"}, {"sha": "a1c3fec32fcf1b202c03f363fdae9d4e1f2565bd", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -19,10 +19,12 @@ impl MirPass for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "4e961d80f4c826fcb9bdc4416f474901aa1006a6", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -37,10 +37,12 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl MirPass for UniformArrayMoveOut {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx};\n@@ -53,7 +55,7 @@ impl MirPass for UniformArrayMoveOut {\n struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n     body: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n@@ -162,10 +164,12 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n pub struct RestoreSubsliceArrayMoveOut;\n \n impl MirPass for RestoreSubsliceArrayMoveOut {\n-    fn run_pass<'a, 'tcx>(&self,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          _src: MirSource<'tcx>,\n-                          body: &mut Body<'tcx>) {\n+    fn run_pass<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        _src: MirSource<'tcx>,\n+        body: &mut Body<'tcx>,\n+    ) {\n         let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = RestoreDataCollector {"}, {"sha": "b23ce28f30120f8f32fa9a2e68182193c810afb7", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -4,12 +4,14 @@ use rustc::mir::*;\n /// Returns `true` if this place is allowed to be less aligned\n /// than its containing struct (because it is within a packed\n /// struct).\n-pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  local_decls: &L,\n-                                  param_env: ty::ParamEnv<'tcx>,\n-                                  place: &Place<'tcx>)\n-                                  -> bool\n-    where L: HasLocalDecls<'tcx>\n+pub fn is_disaligned<'tcx, L>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    local_decls: &L,\n+    param_env: ty::ParamEnv<'tcx>,\n+    place: &Place<'tcx>,\n+) -> bool\n+where\n+    L: HasLocalDecls<'tcx>,\n {\n     debug!(\"is_disaligned({:?})\", place);\n     if !is_within_packed(tcx, local_decls, place) {\n@@ -32,11 +34,9 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 local_decls: &L,\n-                                 place: &Place<'tcx>)\n-                                 -> bool\n-    where L: HasLocalDecls<'tcx>\n+fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx, 'tcx>, local_decls: &L, place: &Place<'tcx>) -> bool\n+where\n+    L: HasLocalDecls<'tcx>,\n {\n     let mut place = place;\n     while let &Place::Projection(box Projection {"}, {"sha": "551cccf3d7d7f271e7ff4cf4bfce6c6b4653432c", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -788,25 +788,25 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n+impl BorrowckErrors<'tcx> for TyCtxt<'gcx, 'tcx> {\n     fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         self,\n         sp: S,\n         msg: &str,\n         code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'cx> {\n+    fn struct_span_err<S: Into<MultiSpan>>(self, sp: S, msg: &str) -> DiagnosticBuilder<'tcx> {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n     fn cancel_if_wrong_origin(\n         self,\n-        mut diag: DiagnosticBuilder<'cx>,\n+        mut diag: DiagnosticBuilder<'tcx>,\n         o: Origin,\n-    ) -> DiagnosticBuilder<'cx> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);\n         }"}, {"sha": "f6cc1033b777cccc88529e1758c793c198129c91", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -70,12 +70,12 @@ impl Unwind {\n     }\n }\n \n-pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n+pub trait DropElaborator<'a, 'tcx: 'a>: fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n     fn body(&self) -> &'a Body<'tcx>;\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     fn drop_style(&self, path: Self::Path, mode: DropFlagMode) -> DropStyle;\n@@ -126,7 +126,7 @@ where\n         place.ty(self.elaborator.body(), self.tcx()).ty\n     }\n \n-    fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.elaborator.tcx()\n     }\n "}, {"sha": "0746434c184b541c4929d5c996433158545062fb", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -8,11 +8,13 @@ use std::io::{self, Write};\n use super::pretty::dump_mir_def_ids;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n-                                   single: Option<DefId>,\n-                                   w: &mut W)\n-                                   -> io::Result<()>\n-    where W: Write\n+pub fn write_mir_graphviz<'tcx, W>(\n+    tcx: TyCtxt<'_, 'tcx>,\n+    single: Option<DefId>,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n {\n     for def_id in dump_mir_def_ids(tcx, single) {\n         let body = &tcx.optimized_mir(def_id);\n@@ -32,11 +34,14 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n }\n \n /// Write a graphviz DOT graph of the MIR.\n-pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n-                                      def_id: DefId,\n-                                      body: &Body<'_>,\n-                                      w: &mut W) -> io::Result<()>\n-    where W: Write\n+pub fn write_mir_fn_graphviz<'tcx, W>(\n+    tcx: TyCtxt<'_, 'tcx>,\n+    def_id: DefId,\n+    body: &Body<'_>,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n {\n     writeln!(w, \"digraph Mir_{} {{\", graphviz_safe_def_name(def_id))?;\n \n@@ -133,11 +138,12 @@ fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                               def_id: DefId,\n-                                               body: &Body<'_>,\n-                                               w: &mut W)\n-                                               -> io::Result<()> {\n+fn write_graph_label<'gcx, 'tcx, W: Write>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    def_id: DefId,\n+    body: &Body<'_>,\n+    w: &mut W,\n+) -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types."}, {"sha": "39840432c690e3525bf0ba88997b6cde55441a34", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -254,8 +254,8 @@ fn block<'tcx>(\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn dump_mir<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n     body: &Body<'tcx>,\n@@ -271,8 +271,8 @@ pub fn dump_mir<'a, 'tcx>(\n     dump_matched_mir_node(tcx, pass_name, &node_path, source, body, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn dump_matched_mir_node<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n@@ -294,8 +294,8 @@ fn dump_matched_mir_node<'a, 'tcx>(\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn write_mir_fn<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     w: &mut dyn Write,"}, {"sha": "3563ad43051dceb7070fcc8c5c1c37d3895b02f2", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -21,8 +21,8 @@ pub use self::graphviz::{graphviz_safe_def_name, write_mir_graphviz};\n pub use self::graphviz::write_node_label as write_graphviz_node_label;\n \n /// If possible, suggest replacing `ref` with `ref mut`.\n-pub fn suggest_ref_mut<'cx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+pub fn suggest_ref_mut<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     binding_span: Span,\n ) -> Option<(String)> {\n     let hi_src = tcx.sess.source_map().span_to_snippet(binding_span).unwrap();"}, {"sha": "8bf491acc26d9542ba0f29803f5b21f3d0b4ceca", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -62,8 +62,8 @@ pub enum PassWhere {\n ///   or `typeck` appears in the name.\n /// - `foo & nll | bar & typeck` == match if `foo` and `nll` both appear in the name\n ///   or `typeck` and `bar` both appear in the name.\n-pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn dump_mir<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     disambiguator: &dyn Display,\n@@ -93,8 +93,8 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n     );\n }\n \n-pub fn dump_enabled<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn dump_enabled<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n ) -> bool {\n@@ -117,8 +117,8 @@ pub fn dump_enabled<'a, 'gcx, 'tcx>(\n // `def_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn dump_matched_mir_node<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n     node_path: &str,\n@@ -158,7 +158,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n /// Also used by other bits of code (e.g., NLL inference) that dump\n /// graphviz data or other things.\n fn dump_path(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     extension: &str,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n@@ -225,7 +225,7 @@ fn dump_path(\n /// bits of code (e.g., NLL inference) that dump graphviz data or\n /// other things, and hence takes the extension as an argument.\n pub(crate) fn create_dump_file(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     extension: &str,\n     pass_num: Option<&dyn Display>,\n     pass_name: &str,\n@@ -240,8 +240,8 @@ pub(crate) fn create_dump_file(\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn write_mir_pretty<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     single: Option<DefId>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n@@ -279,8 +279,8 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn write_mir_fn<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n@@ -303,8 +303,8 @@ where\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+pub fn write_basic_block<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     block: BasicBlock,\n     body: &Body<'tcx>,\n     extra_data: &mut F,\n@@ -370,13 +370,13 @@ where\n /// After we print the main statement, we sometimes dump extra\n /// information. There's often a lot of little things \"nuzzled up\" in\n /// a statement.\n-fn write_extra<'cx, 'gcx, 'tcx, F>(\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+fn write_extra<'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     write: &mut dyn Write,\n     mut visit_op: F,\n ) -> io::Result<()>\n where\n-    F: FnMut(&mut ExtraComments<'cx, 'gcx, 'tcx>),\n+    F: FnMut(&mut ExtraComments<'gcx, 'tcx>),\n {\n     let mut extra_comments = ExtraComments {\n         _tcx: tcx,\n@@ -389,20 +389,20 @@ where\n     Ok(())\n }\n \n-struct ExtraComments<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    _tcx: TyCtxt<'cx, 'gcx, 'tcx>, // don't need it now, but bet we will soon\n+struct ExtraComments<'gcx, 'tcx> {\n+    _tcx: TyCtxt<'gcx, 'tcx>, // don't need it now, but bet we will soon\n     comments: Vec<String>,\n }\n \n-impl<'cx, 'gcx, 'tcx> ExtraComments<'cx, 'gcx, 'tcx> {\n+impl ExtraComments<'gcx, 'tcx> {\n     fn push(&mut self, lines: &str) {\n         for line in lines.split('\\n') {\n             self.comments.push(line.to_string());\n         }\n     }\n }\n \n-impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n+impl Visitor<'tcx> for ExtraComments<'gcx, 'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, ty, user_ty, literal } = constant;\n@@ -453,7 +453,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-fn comment(tcx: TyCtxt<'_, '_, '_>, SourceInfo { span, scope }: SourceInfo) -> String {\n+fn comment(tcx: TyCtxt<'_, '_>, SourceInfo { span, scope }: SourceInfo) -> String {\n     format!(\n         \"scope {} at {}\",\n         scope.index(),\n@@ -463,7 +463,7 @@ fn comment(tcx: TyCtxt<'_, '_, '_>, SourceInfo { span, scope }: SourceInfo) -> S\n \n /// Prints local variables in a scope tree.\n fn write_scope_tree(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     body: &Body<'_>,\n     scope_tree: &FxHashMap<SourceScope, Vec<SourceScope>>,\n     w: &mut dyn Write,\n@@ -538,8 +538,8 @@ fn write_scope_tree(\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub fn write_mir_intro<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n     body: &Body<'_>,\n     w: &mut dyn Write,\n@@ -570,7 +570,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n }\n \n fn write_mir_sig(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     src: MirSource<'tcx>,\n     body: &Body<'_>,\n     w: &mut dyn Write,\n@@ -642,7 +642,7 @@ fn write_user_type_annotations(body: &Body<'_>, w: &mut dyn Write) -> io::Result\n     Ok(())\n }\n \n-pub fn dump_mir_def_ids(tcx: TyCtxt<'_, '_, '_>, single: Option<DefId>) -> Vec<DefId> {\n+pub fn dump_mir_def_ids(tcx: TyCtxt<'_, '_>, single: Option<DefId>) -> Vec<DefId> {\n     if let Some(i) = single {\n         vec![i]\n     } else {"}, {"sha": "5ed731347bb139c4f4b0dc37e717e71ddeed2fd9", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TyCtxt;\n use syntax::ast::Attribute;\n use syntax::symbol::sym;\n \n-pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn test_layout<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     if tcx.features().rustc_attrs {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n         tcx.hir()\n@@ -23,11 +23,11 @@ pub fn test_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-struct VarianceTest<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct VarianceTest<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for VarianceTest<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n \n@@ -44,7 +44,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for VarianceTest<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {}\n }\n \n-impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n+impl VarianceTest<'tcx> {\n     fn dump_layout_of(&self, item_def_id: DefId, item: &hir::Item, attr: &Attribute) {\n         let tcx = self.tcx;\n         let param_env = self.tcx.param_env(item_def_id);\n@@ -104,12 +104,12 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n     }\n }\n \n-struct UnwrapLayoutCx<'me, 'tcx> {\n-    tcx: TyCtxt<'me, 'tcx, 'tcx>,\n+struct UnwrapLayoutCx<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n }\n \n-impl<'me, 'tcx> LayoutOf for UnwrapLayoutCx<'me, 'tcx> {\n+impl LayoutOf for UnwrapLayoutCx<'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = TyLayout<'tcx>;\n \n@@ -118,19 +118,19 @@ impl<'me, 'tcx> LayoutOf for UnwrapLayoutCx<'me, 'tcx> {\n     }\n }\n \n-impl<'me, 'tcx> HasTyCtxt<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl HasTyCtxt<'tcx> for UnwrapLayoutCx<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'me, 'tcx> HasParamEnv<'tcx> for UnwrapLayoutCx<'me, 'tcx> {\n+impl HasParamEnv<'tcx> for UnwrapLayoutCx<'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         self.param_env\n     }\n }\n \n-impl<'me, 'tcx> HasDataLayout for UnwrapLayoutCx<'me, 'tcx> {\n+impl HasDataLayout for UnwrapLayoutCx<'tcx> {\n     fn data_layout(&self) -> &TargetDataLayout {\n         self.tcx.data_layout()\n     }"}, {"sha": "bf2f7634e55a1e38e6ce9633a14a92c11d463b65", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n "}, {"sha": "4c361e975b2e00da8eae887ba04a38a8ac78e7eb", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -45,7 +45,7 @@ struct CheckLoopVisitor<'a, 'hir: 'a> {\n     cx: Context,\n }\n \n-fn check_mod_loops<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_loops<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckLoopVisitor {\n         sess: &tcx.sess,\n         hir_map: &tcx.hir(),"}, {"sha": "845290467b91e5391a879f59b5e6afa5cc8d0cc0", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -39,10 +39,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                  def_id: DefId)\n-                                                  -> bool\n-{\n+fn const_is_rvalue_promotable_to_static<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     assert!(def_id.is_local());\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id)\n@@ -51,10 +48,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.rvalue_promotable_map(def_id).contains(&body_id.hir_id.local_id)\n }\n \n-fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   def_id: DefId)\n-                                   -> &'tcx ItemLocalSet\n-{\n+fn rvalue_promotable_map<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ItemLocalSet {\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n     if outer_def_id != def_id {\n         return tcx.rvalue_promotable_map(outer_def_id);\n@@ -81,7 +75,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     in_fn: bool,\n     in_static: bool,\n     mut_rvalue_borrows: HirIdSet,"}, {"sha": "f5cb04c743250c781ee3f69c65de29d38b490b76", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -30,14 +30,11 @@ impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n }\n \n /// Finds the function marked with `#[plugin_registrar]`, if any.\n-pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> Option<DefId> {\n+pub fn find_plugin_registrar<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Option<DefId> {\n     tcx.plugin_registrar_fn(LOCAL_CRATE)\n }\n \n-fn plugin_registrar_fn<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> Option<DefId> {\n+fn plugin_registrar_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let mut finder = RegistrarFinder { registrars: Vec::new() };"}, {"sha": "a2da014c912d1d8392fcaeca4db09c1222a2f5b2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -4,6 +4,7 @@\n #![deny(internal)]\n #![deny(unused_lifetimes)]\n \n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n \n@@ -47,14 +48,14 @@ mod error_codes;\n /// First, it doesn't have overridable `fn visit_trait_ref`, so we have to catch trait `DefId`s\n /// manually. Second, it doesn't visit some type components like signatures of fn types, or traits\n /// in `impl Trait`, see individual comments in `DefIdVisitorSkeleton::visit_ty`.\n-trait DefIdVisitor<'a, 'tcx: 'a> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+trait DefIdVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx>;\n     fn shallow(&self) -> bool { false }\n     fn skip_assoc_tys(&self) -> bool { false }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n \n     /// Not overridden, but used to actually visit types and traits.\n-    fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'a, 'tcx, Self> {\n+    fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'tcx, Self> {\n         DefIdVisitorSkeleton {\n             def_id_visitor: self,\n             visited_opaque_tys: Default::default(),\n@@ -72,16 +73,18 @@ trait DefIdVisitor<'a, 'tcx: 'a> {\n     }\n }\n \n-struct DefIdVisitorSkeleton<'v, 'a, 'tcx, V>\n-    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+struct DefIdVisitorSkeleton<'v, 'tcx, V>\n+where\n+    V: DefIdVisitor<'tcx> + ?Sized,\n {\n     def_id_visitor: &'v mut V,\n     visited_opaque_tys: FxHashSet<DefId>,\n-    dummy: PhantomData<TyCtxt<'a, 'tcx, 'tcx>>,\n+    dummy: PhantomData<TyCtxt<'tcx, 'tcx>>,\n }\n \n-impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n-    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+impl<'tcx, V> DefIdVisitorSkeleton<'_, 'tcx, V>\n+where\n+    V: DefIdVisitor<'tcx> + ?Sized,\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         let TraitRef { def_id, substs } = trait_ref;\n@@ -123,8 +126,9 @@ impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n     }\n }\n \n-impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n-    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+impl<'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'tcx, V>\n+where\n+    V: DefIdVisitor<'tcx> + ?Sized,\n {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let tcx = self.def_id_visitor.tcx();\n@@ -219,8 +223,10 @@ impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n     }\n }\n \n-fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                               -> (ty::Visibility, Span, &'static str) {\n+fn def_id_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> (ty::Visibility, Span, &'static str) {\n     match tcx.hir().as_local_hir_id(def_id) {\n         Some(hir_id) => {\n             let vis = match tcx.hir().get_by_hir_id(hir_id) {\n@@ -322,16 +328,20 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n // Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n // there is no `TypeckTables` for the item).\n-fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         hir_id: hir::HirId,\n-                         empty_tables: &'a ty::TypeckTables<'tcx>)\n-                         -> &'a ty::TypeckTables<'tcx> {\n+fn item_tables<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    hir_id: hir::HirId,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n+) -> &'a ty::TypeckTables<'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n }\n \n-fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                 -> ty::Visibility {\n+fn min<'tcx>(\n+    vis1: ty::Visibility,\n+    vis2: ty::Visibility,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n \n@@ -341,12 +351,12 @@ fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tc\n /// This is done so that `private_in_public` warnings can be turned into hard errors\n /// in crates that have been updated to use pub(restricted).\n ////////////////////////////////////////////////////////////////////////////////\n-struct PubRestrictedVisitor<'a, 'tcx: 'a> {\n-    tcx:  TyCtxt<'a, 'tcx, 'tcx>,\n+struct PubRestrictedVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     has_pub_restricted: bool,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for PubRestrictedVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir())\n     }\n@@ -360,13 +370,13 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     min: VL,\n }\n \n-impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n     fn shallow(&self) -> bool { VL::SHALLOW }\n     fn skip_assoc_tys(&self) -> bool { true }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n@@ -382,8 +392,11 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl<'a, 'tcx>(hir_id: hir::HirId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         access_levels: &'a AccessLevels) -> Self {\n+    fn of_impl<'a, 'tcx>(\n+        hir_id: hir::HirId,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n+        access_levels: &'a AccessLevels,\n+    ) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n         let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n@@ -424,8 +437,8 @@ impl VisibilityLike for Option<AccessLevel> {\n /// The embargo visitor, used to determine the exports of the AST.\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct EmbargoVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct EmbargoVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n \n     // Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n@@ -435,13 +448,13 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     changed: bool,\n }\n \n-struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n+struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n     access_level: Option<AccessLevel>,\n     item_def_id: DefId,\n-    ev: &'b mut EmbargoVisitor<'a, 'tcx>,\n+    ev: &'a mut EmbargoVisitor<'tcx>,\n }\n \n-impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n+impl EmbargoVisitor<'tcx> {\n     fn get(&self, id: hir::HirId) -> Option<AccessLevel> {\n         self.access_levels.map.get(&id).cloned()\n     }\n@@ -459,8 +472,11 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn reach(&mut self, item_id: hir::HirId, access_level: Option<AccessLevel>)\n-             -> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n+    fn reach(\n+        &mut self,\n+        item_id: hir::HirId,\n+        access_level: Option<AccessLevel>,\n+    ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n             item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n@@ -506,7 +522,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -777,7 +793,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n+impl ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.ev.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n@@ -813,8 +829,8 @@ impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.ev.tcx }\n+impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n             self.ev.update(hir_id, self.access_level);\n@@ -831,7 +847,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'\n //////////////////////////////////////////////////////////////////////////////////////\n \n struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n@@ -958,7 +974,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////////////////\n \n struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n     in_body: bool,\n@@ -1176,8 +1192,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         self.check_def_id(def_id, kind, descr)\n     }\n@@ -1191,7 +1207,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n@@ -1534,8 +1550,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n /// and traits in public interfaces.\n ///////////////////////////////////////////////////////////////////////////////\n \n-struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct SearchInterfaceForPrivateItemsVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     item_id: hir::HirId,\n     item_def_id: DefId,\n     span: Span,\n@@ -1546,7 +1562,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     in_assoc_ty: bool,\n }\n \n-impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n@@ -1632,22 +1648,25 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+impl DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> { self.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         self.check_def_id(def_id, kind, descr)\n     }\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a HirIdSet,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n-    fn check(&self, item_id: hir::HirId, required_visibility: ty::Visibility)\n-             -> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn check(\n+        &self,\n+        item_id: hir::HirId,\n+        required_visibility: ty::Visibility,\n+    ) -> SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         let mut has_old_errors = false;\n \n         // Slow path taken only if there any errors in the crate.\n@@ -1813,7 +1832,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_privacy<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n@@ -1840,10 +1859,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n \n-fn privacy_access_levels<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    krate: CrateNum,\n-) -> &'tcx AccessLevels {\n+fn privacy_access_levels<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) -> &'tcx AccessLevels {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     // Build up a set of all exported items in the AST. This is a set of all\n@@ -1867,7 +1883,7 @@ fn privacy_access_levels<'tcx>(\n     tcx.arena.alloc(visitor.access_levels)\n }\n \n-fn check_private_in_public<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, krate: CrateNum) {\n+fn check_private_in_public<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, krate: CrateNum) {\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);"}, {"sha": "3b4ea384a09a32914f9a5b50e56ae961bbbdaf10", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -77,7 +77,7 @@ macro_rules! access_from_vis {\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n-    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     dumper: &'ll mut JsonDumper<O>,\n \n     span: SpanUtils<'l>,"}, {"sha": "139fd640d628c44bbf7095f062d9318e6a3dfeab", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -52,7 +52,7 @@ use log::{debug, error, info};\n \n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     tables: &'l ty::TypeckTables<'tcx>,\n     access_levels: &'l AccessLevels,\n     span_utils: SpanUtils<'tcx>,\n@@ -1115,7 +1115,7 @@ impl<'b> SaveHandler for CallbackHandler<'b> {\n }\n \n pub fn process_crate<'l, 'tcx, H: SaveHandler>(\n-    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     krate: &ast::Crate,\n     cratename: &str,\n     input: &'l Input,"}, {"sha": "7a519ac2ebea8dad6ecb1cf5fcad74855307bf57", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -50,9 +50,9 @@ crate struct ChalkArenas<'gcx> {\n }\n \n #[derive(Copy, Clone)]\n-crate struct ChalkContext<'cx, 'gcx: 'cx> {\n+crate struct ChalkContext<'gcx> {\n     _arenas: ChalkArenas<'gcx>,\n-    tcx: TyCtxt<'cx, 'gcx, 'gcx>,\n+    tcx: TyCtxt<'gcx, 'gcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -126,7 +126,7 @@ impl context::Context for ChalkArenas<'tcx> {\n     }\n }\n \n-impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     fn make_solution(\n         &self,\n         root_goal: &Canonical<'gcx, InEnvironment<'gcx, Goal<'gcx>>>,\n@@ -176,7 +176,7 @@ impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n     }\n }\n \n-impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'gcx> {\n     /// Returns `true` if this is a coinductive goal: basically proving that an auto trait\n     /// is implemented or proving that a trait reference is well-formed.\n     fn is_coinductive(\n@@ -508,7 +508,7 @@ type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n \n type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;\n \n-impl Debug for ChalkContext<'cx, 'gcx> {\n+impl Debug for ChalkContext<'gcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"ChalkContext\")\n     }\n@@ -527,7 +527,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_ex_clause_to_tcx(\n         ex_clause: &ChalkExClause<'a>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedExClause> {\n         Some(ChalkExClause {\n             subst: tcx.lift(&ex_clause.subst)?,\n@@ -539,7 +539,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_delayed_literal_to_tcx(\n         literal: &DelayedLiteral<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedDelayedLiteral> {\n         Some(match literal {\n             DelayedLiteral::CannotProve(()) => DelayedLiteral::CannotProve(()),\n@@ -553,7 +553,7 @@ impl ChalkContextLift<'tcx> for ChalkArenas<'a> {\n \n     fn lift_literal_to_tcx(\n         literal: &Literal<ChalkArenas<'a>>,\n-        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n     ) -> Option<Self::LiftedLiteral> {\n         Some(match literal {\n             Literal::Negative(goal) => Literal::Negative(tcx.lift(goal)?),\n@@ -672,13 +672,10 @@ crate fn provide(p: &mut Providers<'_>) {\n     };\n }\n \n-crate fn evaluate_goal<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    goal: ChalkCanonicalGoal<'tcx>\n-) -> Result<\n-    &'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>,\n-    traits::query::NoSolution\n-> {\n+crate fn evaluate_goal<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    goal: ChalkCanonicalGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {\n     use crate::lowering::Lower;\n     use rustc::traits::WellFormed;\n "}, {"sha": "3c9b335e77769528f65cb5255f505d2a185511e9", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -15,10 +15,10 @@ use crate::generic_types;\n /// `Implemented(ty: Trait) :- Implemented(nested: Trait)...`\n /// where `Trait` is specified by `trait_def_id`.\n fn builtin_impl_clause(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     nested: &[Kind<'tcx>],\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n ) -> ProgramClause<'tcx> {\n     ProgramClause {\n         goal: ty::TraitPredicate {\n@@ -43,11 +43,11 @@ fn builtin_impl_clause(\n }\n \n crate fn assemble_builtin_unsize_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     unsize_def_id: DefId,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     match (&source.sty, &target.sty) {\n         (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n@@ -119,10 +119,10 @@ crate fn assemble_builtin_unsize_impls<'tcx>(\n }\n \n crate fn assemble_builtin_sized_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     sized_def_id: DefId,\n     ty: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[Kind<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, sized_def_id);\n@@ -223,10 +223,10 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n }\n \n crate fn assemble_builtin_copy_clone_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     trait_def_id: DefId,\n     ty: Ty<'tcx>,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[Kind<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, trait_def_id);"}, {"sha": "ae2283c3672e7c01e0827c2b1f81f5fb3830b97b", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -19,9 +19,9 @@ use self::primitive::*;\n use self::builtin::*;\n \n fn assemble_clauses_from_impls<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     tcx.for_each_impl(trait_def_id, |impl_def_id| {\n         clauses.extend(\n@@ -33,9 +33,9 @@ fn assemble_clauses_from_impls<'tcx>(\n }\n \n fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     trait_def_id: DefId,\n-    clauses: &mut Vec<Clause<'tcx>>\n+    clauses: &mut Vec<Clause<'tcx>>,\n ) {\n     tcx.for_each_impl(trait_def_id, |impl_def_id| {\n         for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {"}, {"sha": "fd7b5ec55b08bc233789af32aa066b00c4df24e2", "filename": "src/librustc_traits/chalk_context/program_clauses/primitive.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fprimitive.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -16,8 +16,8 @@ use crate::generic_types;\n use std::iter;\n \n crate fn wf_clause_for_raw_ptr<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    mutbl: hir::Mutability\n+    tcx: TyCtxt<'_, 'tcx>,\n+    mutbl: hir::Mutability,\n ) -> Clauses<'tcx> {\n     let ptr_ty = generic_types::raw_ptr(tcx, mutbl);\n \n@@ -33,11 +33,11 @@ crate fn wf_clause_for_raw_ptr<'tcx>(\n }\n \n crate fn wf_clause_for_fn_ptr<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     arity_and_output: usize,\n     variadic: bool,\n     unsafety: hir::Unsafety,\n-    abi: abi::Abi\n+    abi: abi::Abi,\n ) -> Clauses<'tcx> {\n     let fn_ptr = generic_types::fn_ptr(tcx, arity_and_output, variadic, unsafety, abi);\n \n@@ -53,7 +53,7 @@ crate fn wf_clause_for_fn_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, 'tcx>) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let slice_ty = tcx.mk_slice(ty);\n \n@@ -83,8 +83,8 @@ crate fn wf_clause_for_slice<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n }\n \n crate fn wf_clause_for_array<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    length: &'tcx ty::Const<'tcx>\n+    tcx: TyCtxt<'_, 'tcx>,\n+    length: &'tcx ty::Const<'tcx>,\n ) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let array_ty = tcx.mk_ty(ty::Array(ty, length));\n@@ -114,10 +114,7 @@ crate fn wf_clause_for_array<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_tuple<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    arity: usize\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_tuple<'tcx>(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> Clauses<'tcx> {\n     let type_list = generic_types::type_list(tcx, arity);\n     let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n \n@@ -158,10 +155,7 @@ crate fn wf_clause_for_tuple<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_ref<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    mutbl: hir::Mutability\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_ref<'tcx>(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Clauses<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -185,10 +179,7 @@ crate fn wf_clause_for_ref<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-crate fn wf_clause_for_fn_def<'tcx>(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n-    def_id: DefId\n-) -> Clauses<'tcx> {\n+crate fn wf_clause_for_fn_def<'tcx>(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     let fn_def = generic_types::fn_def(tcx, def_id);\n \n     let wf_clause = ProgramClause {"}, {"sha": "ff2cfc87297de912648fbd546a81cfdd72eccb90", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -169,8 +169,8 @@ impl AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+impl TypeRelation<'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "02b9b078fca912bad579091f42562644d17a0dd8", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,7 +18,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn dropck_outlives<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonical_goal: CanonicalTyGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n@@ -146,8 +146,8 @@ fn dropck_outlives<'tcx>(\n \n /// Returns a set of constraints that needs to be satisfied in\n /// order for `ty` to be valid for destruction.\n-fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn dtorck_constraint_for_ty<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     span: Span,\n     for_ty: Ty<'tcx>,\n     depth: usize,\n@@ -279,8 +279,8 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n }\n \n /// Calculates the dtorck constraint for a type.\n-crate fn adt_dtorck_constraint<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+crate fn adt_dtorck_constraint<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n ) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n     let def = tcx.adt_def(def_id);"}, {"sha": "be3a8340e6006d2591b7eb45951253f9cf1669b2", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -14,7 +14,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn evaluate_obligation<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n     tcx.infer_ctxt().enter_with_canonical("}, {"sha": "dca7fb0dae3d40aa86113ceb5839d3e852fd26b4", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,27 +6,27 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n \n-crate fn bound(tcx: TyCtxt<'_, '_, 'tcx>, index: u32) -> Ty<'tcx> {\n+crate fn bound(tcx: TyCtxt<'_, 'tcx>, index: u32) -> Ty<'tcx> {\n     let ty = ty::Bound(\n         ty::INNERMOST,\n         ty::BoundVar::from_u32(index).into()\n     );\n     tcx.mk_ty(ty)\n }\n \n-crate fn raw_ptr(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn raw_ptr(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     tcx.mk_ptr(ty::TypeAndMut {\n         ty: bound(tcx, 0),\n         mutbl,\n     })\n }\n \n crate fn fn_ptr(\n-    tcx: TyCtxt<'_, '_, 'tcx>,\n+    tcx: TyCtxt<'_, 'tcx>,\n     arity_and_output: usize,\n     c_variadic: bool,\n     unsafety: hir::Unsafety,\n-    abi: abi::Abi\n+    abi: abi::Abi,\n ) -> Ty<'tcx> {\n     let inputs_and_output = tcx.mk_type_list(\n         (0..arity_and_output).into_iter()\n@@ -44,7 +44,7 @@ crate fn fn_ptr(\n     tcx.mk_fn_ptr(fn_sig)\n }\n \n-crate fn type_list(tcx: TyCtxt<'_, '_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n+crate fn type_list(tcx: TyCtxt<'_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n     tcx.mk_substs(\n         (0..arity).into_iter()\n             .map(|i| ty::BoundVar::from(i))\n@@ -53,7 +53,7 @@ crate fn type_list(tcx: TyCtxt<'_, '_, 'tcx>, arity: usize) -> SubstsRef<'tcx> {\n     )\n }\n \n-crate fn ref_ty(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n+crate fn ref_ty(tcx: TyCtxt<'_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     let region = tcx.mk_region(\n         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n     );\n@@ -64,17 +64,17 @@ crate fn ref_ty(tcx: TyCtxt<'_, '_, 'tcx>, mutbl: hir::Mutability) -> Ty<'tcx> {\n     })\n }\n \n-crate fn fn_def(tcx: TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn fn_def(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_ty(ty::FnDef(def_id, InternalSubsts::bound_vars_for_item(tcx, def_id)))\n }\n \n-crate fn closure(tcx: TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn closure(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_closure(def_id, ty::ClosureSubsts {\n         substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n     })\n }\n \n-crate fn generator(tcx: TyCtxt<'_, '_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+crate fn generator(tcx: TyCtxt<'_, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     tcx.mk_generator(def_id, ty::GeneratorSubsts {\n         substs: InternalSubsts::bound_vars_for_item(tcx, def_id),\n     }, hir::GeneratorMovability::Movable)"}, {"sha": "1bb04eab4c4bb90c67c872d5c09cef750117b98d", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -23,11 +23,11 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn implied_outlives_bounds<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     goal: CanonicalTyGoal<'tcx>,\n ) -> Result<\n-        &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n-        NoSolution,\n+    &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n+    NoSolution,\n > {\n     tcx.infer_ctxt()\n        .enter_canonical_trait_query(&goal, |infcx, _fulfill_cx, key| {"}, {"sha": "bab74e80ea6e900b95e6fa8344db751205b511e6", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -11,13 +11,13 @@ use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n \n-struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    round: &'set mut FxHashSet<Clause<'tcx>>,\n+struct ClauseVisitor<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    round: &'a mut FxHashSet<Clause<'tcx>>,\n }\n \n-impl ClauseVisitor<'set, 'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, round: &'set mut FxHashSet<Clause<'tcx>>) -> Self {\n+impl ClauseVisitor<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx, 'tcx>, round: &'a mut FxHashSet<Clause<'tcx>>) -> Self {\n         ClauseVisitor {\n             tcx,\n             round,\n@@ -127,8 +127,8 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n     }\n }\n \n-crate fn program_clauses_for_env<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+crate fn program_clauses_for_env<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     environment: Environment<'tcx>,\n ) -> Clauses<'tcx> {\n     debug!(\"program_clauses_for_env(environment={:?})\", environment);\n@@ -160,10 +160,7 @@ crate fn program_clauses_for_env<'a, 'tcx>(\n     );\n }\n \n-crate fn environment<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId\n-) -> Environment<'tcx> {\n+crate fn environment<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n "}, {"sha": "59cd58ea23d14bc92d1f46f8f0c3dc64603f8766", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -155,10 +155,7 @@ impl<'tcx> IntoWellFormedGoal for DomainGoal<'tcx> {\n     }\n }\n \n-crate fn program_clauses_for<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Clauses<'tcx> {\n+crate fn program_clauses_for<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // FIXME(eddyb) this should only be using `def_kind`.\n     match tcx.def_key(def_id).disambiguated_data.data {\n         DefPathData::TypeNs(..) => match tcx.def_kind(def_id) {\n@@ -184,10 +181,7 @@ crate fn program_clauses_for<'a, 'tcx>(\n     }\n }\n \n-fn program_clauses_for_trait<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Clauses<'tcx> {\n+fn program_clauses_for_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // `trait Trait<P1..Pn> where WC { .. } // P0 == Self`\n \n     // Rule Implemented-From-Env (see rustc guide)\n@@ -300,7 +294,7 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     )\n }\n \n-fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n+fn program_clauses_for_impl(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     if let ImplPolarity::Negative = tcx.impl_polarity(def_id) {\n         return List::empty();\n     }\n@@ -343,10 +337,7 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n }\n \n-pub fn program_clauses_for_type_def<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Clauses<'tcx> {\n+pub fn program_clauses_for_type_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Clauses<'tcx> {\n     // Rule WellFormed-Type\n     //\n     // `struct Ty<P1..Pn> where WC1, ..., WCm`\n@@ -420,8 +411,8 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     tcx.mk_clauses(iter::once(well_formed_clause).chain(from_env_clauses))\n }\n \n-pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn program_clauses_for_associated_type_def<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule ProjectionEq-Placeholder\n@@ -558,8 +549,8 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     tcx.mk_clauses(clauses)\n }\n \n-pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn program_clauses_for_associated_type_value<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n     // Rule Normalize-From-Impl (see rustc guide)\n@@ -620,7 +611,7 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     tcx.mk_clauses(iter::once(normalize_clause))\n }\n \n-pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn dump_program_clauses<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     if !tcx.features().rustc_attrs {\n         return;\n     }\n@@ -631,11 +622,11 @@ pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         .visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n-struct ClauseDumper<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ClauseDumper<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n+impl ClauseDumper<'tcx> {\n     fn process_attrs(&mut self, hir_id: hir::HirId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(hir_id);\n         for attr in attrs {\n@@ -673,7 +664,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for ClauseDumper<'a, 'tcx> {\n+impl Visitor<'tcx> for ClauseDumper<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }"}, {"sha": "5dec1613f1e950d06598e7dc0683fdc473f5a5a3", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -12,7 +12,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn normalize_ty_after_erasing_regions<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Ty<'tcx> {\n     debug!(\"normalize_ty_after_erasing_regions(goal={:#?})\", goal);"}, {"sha": "448d42dc9b051e5e2b537eda82af84f7d66b35d7", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -15,7 +15,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn normalize_projection_ty<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     goal: CanonicalProjectionGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n     debug!(\"normalize_provider(goal={:#?})\", goal);"}, {"sha": "f2ceff6185e92c73adcd2b0ea50476a6f11d68a5", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -35,7 +35,7 @@ crate fn provide(p: &mut Providers<'_>) {\n }\n \n fn type_op_ascribe_user_type<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, AscribeUserType<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -94,7 +94,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         );\n     }\n \n-    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -167,7 +167,7 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n }\n \n fn type_op_eq<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -197,39 +197,39 @@ where\n }\n \n fn type_op_normalize_ty(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Ty<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_predicate(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Predicate<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, Predicate<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_fn_sig(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<FnSig<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, FnSig<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_normalize_poly_fn_sig(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<PolyFnSig<'tcx>>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, PolyFnSig<'tcx>>>, NoSolution> {\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, type_op_normalize)\n }\n \n fn type_op_subtype<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Subtype<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()\n@@ -243,7 +243,7 @@ fn type_op_subtype<'tcx>(\n }\n \n fn type_op_prove_predicate<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, ProvePredicate<'tcx>>>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, NoSolution> {\n     tcx.infer_ctxt()"}, {"sha": "2c9309a1696cfd65210643a491bcb1470caffac1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -41,7 +41,7 @@ use rustc_data_structures::fx::FxHashSet;\n pub struct PathSeg(pub DefId, pub usize);\n \n pub trait AstConv<'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx>;\n \n     /// Returns the set of bounds in scope for the type parameter with\n     /// the given id.\n@@ -208,7 +208,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n     fn check_impl_trait(\n-        tcx: TyCtxt<'_, '_, '_>,\n+        tcx: TyCtxt<'_, '_>,\n         span: Span,\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n@@ -239,7 +239,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// Used specifically for function calls.\n     pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt<'_, '_, '_>,\n+        tcx: TyCtxt<'_, '_>,\n         span: Span,\n         def: &ty::Generics,\n         seg: &hir::PathSegment,\n@@ -271,7 +271,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// This is used both for datatypes and function calls.\n     fn check_generic_arg_count(\n-        tcx: TyCtxt<'_, '_, '_>,\n+        tcx: TyCtxt<'_, '_>,\n         span: Span,\n         def: &ty::Generics,\n         args: &hir::GenericArgs,\n@@ -461,8 +461,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     ///   instantiate a `Kind`.\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n-    pub fn create_substs_for_generic_args<'a, 'b>(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pub fn create_substs_for_generic_args<'b>(\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         def_id: DefId,\n         parent_substs: &[Kind<'tcx>],\n         has_self: bool,\n@@ -1810,7 +1810,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         has_err\n     }\n \n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_, '_, '_>, span: Span) {\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_, '_>, span: Span) {\n         let mut err = struct_span_err!(tcx.sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n         err.span_label(span, \"associated type not allowed here\").emit();\n@@ -2415,14 +2415,16 @@ pub struct Bounds<'tcx> {\n     pub implicitly_sized: Option<Span>,\n }\n \n-impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n+impl<'gcx, 'tcx> Bounds<'tcx> {\n     /// Converts a bounds list into a flat set of predicates (like\n     /// where-clauses). Because some of our bounds listings (e.g.,\n     /// regions) don't include the self-type, you must supply the\n     /// self-type here (the `param_ty` parameter).\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n-                      -> Vec<(ty::Predicate<'tcx>, Span)>\n-    {\n+    pub fn predicates(\n+        &self,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n+        param_ty: Ty<'tcx>,\n+    ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {"}, {"sha": "ce92551c0133fab6a569d8e67aab5b495d05f179", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -239,9 +239,11 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn report_autoderef_recursion_limit_error<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>, span: Span, ty: Ty<'tcx>)\n-{\n+pub fn report_autoderef_recursion_limit_error<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    span: Span,\n+    ty: Ty<'tcx>,\n+) {\n     // We've reached the recursion limit, error gracefully.\n     let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n     let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\","}, {"sha": "8e13bbed89e782218315984b1bafeba889c18d60", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called).\n-pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_, '_, '_>, span: Span, trait_id: DefId) {\n+pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_, '_>, span: Span, trait_id: DefId) {\n     if tcx.lang_items().drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, \"explicit destructor calls not allowed\")"}, {"sha": "32ac7cd69e2e324968a6da49ffafebfeb4693486", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 52, "deletions": 44, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -23,12 +23,14 @@ use super::{Inherited, FnCtxt, potentially_plural_count};\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     impl_m: &ty::AssocItem,\n-                                     impl_m_span: Span,\n-                                     trait_m: &ty::AssocItem,\n-                                     impl_trait_ref: ty::TraitRef<'tcx>,\n-                                     trait_item_span: Option<Span>) {\n+pub fn compare_impl_method<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    trait_item_span: Option<Span>,\n+) {\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n@@ -73,12 +75,13 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                          impl_m: &ty::AssocItem,\n-                                          impl_m_span: Span,\n-                                          trait_m: &ty::AssocItem,\n-                                          impl_trait_ref: ty::TraitRef<'tcx>)\n-                                          -> Result<(), ErrorReported> {\n+fn compare_predicate_entailment<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     // This node-id should be used for the `body_id` field on each\n@@ -355,14 +358,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                span: Span,\n-                                                impl_m: &ty::AssocItem,\n-                                                trait_m: &ty::AssocItem,\n-                                                trait_generics: &ty::Generics,\n-                                                impl_generics: &ty::Generics,\n-                                                trait_to_skol_substs: SubstsRef<'tcx>)\n-                                                -> Result<(), ErrorReported> {\n+fn check_region_bounds_on_impl_method<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    span: Span,\n+    impl_m: &ty::AssocItem,\n+    trait_m: &ty::AssocItem,\n+    trait_generics: &ty::Generics,\n+    impl_generics: &ty::Generics,\n+    trait_to_skol_substs: SubstsRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n     let trait_params = trait_generics.own_counts().lifetimes;\n     let impl_params = impl_generics.own_counts().lifetimes;\n \n@@ -495,13 +499,13 @@ fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a\n     }\n }\n \n-fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               impl_m: &ty::AssocItem,\n-                               impl_m_span: Span,\n-                               trait_m: &ty::AssocItem,\n-                               impl_trait_ref: ty::TraitRef<'tcx>)\n-                               -> Result<(), ErrorReported>\n-{\n+fn compare_self_type<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -580,8 +584,8 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n-fn compare_number_of_generics<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compare_number_of_generics<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     impl_: &ty::AssocItem,\n     _impl_span: Span,\n     trait_: &ty::AssocItem,\n@@ -695,12 +699,13 @@ fn compare_number_of_generics<'a, 'tcx>(\n     }\n }\n \n-fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                impl_m: &ty::AssocItem,\n-                                                impl_m_span: Span,\n-                                                trait_m: &ty::AssocItem,\n-                                                trait_item_span: Option<Span>)\n-                                                -> Result<(), ErrorReported> {\n+fn compare_number_of_method_arguments<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    impl_m_span: Span,\n+    trait_m: &ty::AssocItem,\n+    trait_item_span: Option<Span>,\n+) -> Result<(), ErrorReported> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n@@ -779,10 +784,11 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n-fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        impl_m: &ty::AssocItem,\n-                                        trait_m: &ty::AssocItem)\n-                                        -> Result<(), ErrorReported> {\n+fn compare_synthetic_generics<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_m: &ty::AssocItem,\n+    trait_m: &ty::AssocItem,\n+) -> Result<(), ErrorReported> {\n     // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n     //     1. Better messages for the span labels\n     //     2. Explanation as to what is going on\n@@ -951,11 +957,13 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    impl_c: &ty::AssocItem,\n-                                    impl_c_span: Span,\n-                                    trait_c: &ty::AssocItem,\n-                                    impl_trait_ref: ty::TraitRef<'tcx>) {\n+pub fn compare_const_impl<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_c: &ty::AssocItem,\n+    impl_c_span: Span,\n+    trait_c: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "1e6ae1e03091224f6888e27b6332a24516d82171", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -29,8 +29,8 @@ use syntax_pos::Span;\n ///    struct/enum definition for the nominal type itself (i.e.\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n-pub fn check_drop_impl<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn check_drop_impl<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     drop_impl_did: DefId,\n ) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n@@ -64,8 +64,8 @@ pub fn check_drop_impl<'a, 'tcx>(\n     }\n }\n \n-fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn ensure_drop_params_and_item_params_correspond<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n@@ -140,8 +140,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n /// Confirms that every predicate imposed by dtor_predicates is\n /// implied by assuming the predicates attached to self_type_did.\n-fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     drop_impl_did: DefId,\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,"}, {"sha": "0b800fe8247c70b9f345ff240c1477060766a307", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -13,8 +13,8 @@ use rustc::hir;\n \n use std::iter;\n \n-fn equate_intrinsic_type<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn equate_intrinsic_type<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     it: &hir::ForeignItem,\n     n_tps: usize,\n     abi: Abi,\n@@ -79,8 +79,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n \n /// Remember to add all intrinsics here, in librustc_codegen_llvm/intrinsic.rs,\n /// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      it: &hir::ForeignItem) {\n+pub fn check_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, InternedString::intern(&format!(\"P{}\", n)));\n     let name = it.ident.as_str();\n \n@@ -400,8 +399,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n-pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               it: &hir::ForeignItem) {\n+pub fn check_platform_intrinsic_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, it: &hir::ForeignItem) {\n     let param = |n| {\n         let name = InternedString::intern(&format!(\"P{}\", n));\n         tcx.mk_ty_param(n, name)"}, {"sha": "5aab440dc16d094aae1f641c769b196a1aea8cdb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -395,10 +395,10 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.method_autoderef_steps = method_autoderef_steps;\n }\n \n-fn method_autoderef_steps<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                          goal: CanonicalTyGoal<'tcx>)\n-                                          -> MethodAutoderefStepsResult<'gcx>\n-{\n+fn method_autoderef_steps<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    goal: CanonicalTyGoal<'tcx>,\n+) -> MethodAutoderefStepsResult<'gcx> {\n     debug!(\"method_autoderef_steps({:?})\", goal);\n \n     tcx.infer_ctxt().enter_with_canonical(DUMMY_SP, &goal, |ref infcx, goal, inference_vars| {"}, {"sha": "c4157bb60e9da8383d54121775608e275b4716cb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -775,12 +775,12 @@ impl Ord for TraitInfo {\n }\n \n /// Retrieves all traits in this crate and any dependent crates.\n-pub fn all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<TraitInfo> {\n+pub fn all_traits<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>) -> Vec<TraitInfo> {\n     tcx.all_traits(LOCAL_CRATE).iter().map(|&def_id| TraitInfo { def_id }).collect()\n }\n \n /// Computes all traits in this crate and any dependent crates.\n-fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId> {\n+fn compute_all_traits<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>) -> Vec<DefId> {\n     use hir::itemlikevisit;\n \n     let mut traits = vec![];\n@@ -817,10 +817,12 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     // Cross-crate:\n \n     let mut external_mods = FxHashSet::default();\n-    fn handle_external_res(tcx: TyCtxt<'_, '_, '_>,\n-                           traits: &mut Vec<DefId>,\n-                           external_mods: &mut FxHashSet<DefId>,\n-                           res: Res) {\n+    fn handle_external_res(\n+        tcx: TyCtxt<'_, '_>,\n+        traits: &mut Vec<DefId>,\n+        external_mods: &mut FxHashSet<DefId>,\n+        res: Res,\n+    ) {\n         match res {\n             Res::Def(DefKind::Trait, def_id) |\n             Res::Def(DefKind::TraitAlias, def_id) => {\n@@ -855,16 +857,16 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     }\n }\n \n-struct UsePlacementFinder<'a, 'tcx: 'a, 'gcx: 'tcx> {\n+struct UsePlacementFinder<'tcx, 'gcx> {\n     target_module: hir::HirId,\n     span: Option<Span>,\n     found_use: bool,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>\n+    tcx: TyCtxt<'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'gcx> UsePlacementFinder<'a, 'tcx, 'gcx> {\n+impl UsePlacementFinder<'tcx, 'gcx> {\n     fn check(\n-        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        tcx: TyCtxt<'gcx, 'tcx>,\n         krate: &'tcx hir::Crate,\n         target_module: hir::HirId,\n     ) -> (Option<Span>, bool) {\n@@ -879,7 +881,7 @@ impl<'a, 'tcx, 'gcx> UsePlacementFinder<'a, 'tcx, 'gcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, 'tcx, 'gcx> {\n+impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx, 'gcx> {\n     fn visit_mod(\n         &mut self,\n         module: &'tcx hir::Mod,"}, {"sha": "d62536ccb46696e1c06239667222e037c8e86e5c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 78, "deletions": 88, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -588,14 +588,13 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n /// Helper type of a temporary returned by `Inherited::build(...)`.\n /// Necessary because we can't write the following bound:\n /// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>)`.\n-pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>,\n+pub struct InheritedBuilder<'gcx, 'tcx> {\n+    infcx: infer::InferCtxtBuilder<'gcx, 'tcx>,\n     def_id: DefId,\n }\n \n-impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n-                 -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+impl Inherited<'_, 'gcx, 'tcx> {\n+    pub fn build(tcx: TyCtxt<'gcx, 'gcx>, def_id: DefId) -> InheritedBuilder<'gcx, 'tcx> {\n         let hir_id_root = if def_id.is_local() {\n             let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n             DefId::local(hir_id.owner)\n@@ -610,16 +609,17 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n+impl<'gcx, 'tcx> InheritedBuilder<'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n-        where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'a> FnOnce(Inherited<'a, 'gcx, 'tcx>) -> R,\n     {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n+impl Inherited<'a, 'gcx, 'tcx> {\n     fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().as_local_hir_id(def_id);\n@@ -685,43 +685,45 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n+struct CheckItemTypesVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+}\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_type(self.tcx, i);\n     }\n     fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n     fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n }\n \n-pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Result<(), ErrorReported> {\n+pub fn check_wf_new<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(tcx);\n         tcx.hir().krate().par_visit_all_item_likes(&mut visit);\n     })\n }\n \n-fn check_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_item_types<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckItemTypesVisitor { tcx });\n }\n \n-fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) {\n+fn typeck_item_bodies<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {\n         tcx.ensure().typeck_tables_of(body_owner_def_id);\n     });\n }\n \n-fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     wfcheck::check_item_well_formed(tcx, def_id);\n }\n \n-fn check_trait_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn check_trait_item_well_formed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     wfcheck::check_trait_item(tcx, def_id);\n }\n \n-fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn check_impl_item_well_formed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     wfcheck::check_impl_item(tcx, def_id);\n }\n \n@@ -741,9 +743,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId)\n-                            -> Option<ty::Destructor> {\n+fn adt_destructor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<ty::Destructor> {\n     tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n }\n \n@@ -756,10 +756,10 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// may not succeed. In some cases where this function returns `None`\n /// (notably closures), `typeck_tables(def_id)` would wind up\n /// redirecting to the owning function.\n-fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             id: hir::HirId)\n-                             -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n-{\n+fn primary_body_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    id: hir::HirId,\n+) -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)> {\n     match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => {\n             match item.node {\n@@ -797,9 +797,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               def_id: DefId)\n-                               -> bool {\n+fn has_typeck_tables<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -811,15 +809,11 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     primary_body_of(tcx, id).is_some()\n }\n \n-fn used_trait_imports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                def_id: DefId)\n-                                -> &'tcx DefIdSet {\n+fn used_trait_imports<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n-fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> &'tcx ty::TypeckTables<'tcx> {\n+fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);\n@@ -919,7 +913,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables\n }\n \n-fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n+fn check_abi<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, span: Span, abi: Abi) {\n     if !tcx.sess.target.target.is_abi_supported(abi) {\n         struct_span_err!(tcx.sess, span, E0570,\n             \"The ABI `{}` is not supported for the current target\", abi).emit()\n@@ -1287,9 +1281,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     (fcx, gen_ty)\n }\n \n-fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          id: hir::HirId,\n-                          span: Span) {\n+fn check_struct<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1303,9 +1295,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         id: hir::HirId,\n-                         span: Span) {\n+fn check_union<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, id: hir::HirId, span: Span) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1314,12 +1304,7 @@ fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-fn check_opaque<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-    substs: SubstsRef<'tcx>,\n-    span: Span,\n-) {\n+fn check_opaque<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, substs: SubstsRef<'tcx>, span: Span) {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id, substs) {\n         let mut err = struct_span_err!(\n             tcx.sess, span, E0720,\n@@ -1335,7 +1320,7 @@ fn check_opaque<'a, 'tcx>(\n     }\n }\n \n-pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n+pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, it: &'tcx hir::Item) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n         it.hir_id,\n@@ -1434,7 +1419,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n     }\n }\n \n-fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_, '_>, id: DefId, span: Span) {\n+fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_>, id: DefId, span: Span) {\n     // Only restricted on wasm32 target for now\n     if !tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n         return\n@@ -1472,18 +1457,17 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_, '_>, id: DefId, span\n     }\n }\n \n-fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    trait_def_id: DefId,\n-                                    item: &hir::Item) {\n+fn check_on_unimplemented<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId, item: &hir::Item) {\n     let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     // an error would be reported if this fails.\n     let _ = traits::OnUnimplementedDirective::of_item(tcx, trait_def_id, item_def_id);\n }\n \n-fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             impl_item: &hir::ImplItem,\n-                                             parent_impl: DefId)\n-{\n+fn report_forbidden_specialization<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_item: &hir::ImplItem,\n+    parent_impl: DefId,\n+) {\n     let mut err = struct_span_err!(\n         tcx.sess, impl_item.span, E0520,\n         \"`{}` specializes an item from a parent `impl`, but \\\n@@ -1506,12 +1490,13 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           trait_def: &ty::TraitDef,\n-                                           trait_item: &ty::AssocItem,\n-                                           impl_id: DefId,\n-                                           impl_item: &hir::ImplItem)\n-{\n+fn check_specialization_validity<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_def: &ty::TraitDef,\n+    trait_item: &ty::AssocItem,\n+    impl_id: DefId,\n+    impl_item: &hir::ImplItem,\n+) {\n     let ancestors = trait_def.ancestors(tcx, impl_id);\n \n     let kind = match impl_item.node {\n@@ -1532,11 +1517,13 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n }\n \n-fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                            impl_span: Span,\n-                                            impl_id: DefId,\n-                                            impl_trait_ref: ty::TraitRef<'tcx>,\n-                                            impl_item_refs: &[hir::ImplItemRef]) {\n+fn check_impl_items_against_trait<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_span: Span,\n+    impl_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item_refs: &[hir::ImplItemRef],\n+) {\n     let impl_span = tcx.sess.source_map().def_span(impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n@@ -1693,10 +1680,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 sp: Span,\n-                                 item_def_id: DefId)\n-                                 -> bool {\n+fn check_representable<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, item_def_id: DefId) -> bool {\n     let rty = tcx.type_of(item_def_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -1715,10 +1699,10 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),\n     }\n-    return true\n+    return true;\n }\n \n-pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+pub fn check_simd<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.sty {\n         if def.is_struct() {\n@@ -1747,7 +1731,7 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n     }\n }\n \n-fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+fn check_packed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let repr = tcx.adt_def(def_id).repr;\n     if repr.packed() {\n         for attr in tcx.get_attrs(def_id).iter() {\n@@ -1771,9 +1755,11 @@ fn check_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId)\n     }\n }\n \n-fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                def_id: DefId,\n-                                stack: &mut Vec<DefId>) -> bool {\n+fn check_packed_inner<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    def_id: DefId,\n+    stack: &mut Vec<DefId>,\n+) -> bool {\n     let t = tcx.type_of(def_id);\n     if stack.contains(&def_id) {\n         debug!(\"check_packed_inner: {:?} is recursive\", t);\n@@ -1801,7 +1787,7 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     false\n }\n \n-fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+fn check_transparent<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, sp: Span, def_id: DefId) {\n     let adt = tcx.adt_def(def_id);\n     if !adt.repr.transparent() {\n         return;\n@@ -1881,10 +1867,12 @@ fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: De\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            sp: Span,\n-                            vs: &'tcx [hir::Variant],\n-                            id: hir::HirId) {\n+pub fn check_enum<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    sp: Span,\n+    vs: &'tcx [hir::Variant],\n+    id: hir::HirId,\n+) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     let def = tcx.adt_def(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n@@ -1945,18 +1933,22 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 res: Res,\n-                                                 span: Span,\n-                                                 qpath: &QPath) {\n+fn report_unexpected_variant_res<'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'tcx>,\n+    res: Res,\n+    span: Span,\n+    qpath: &QPath,\n+) {\n     span_err!(tcx.sess, span, E0533,\n               \"expected unit struct/variant or constant, found {} `{}`\",\n               res.descr(),\n               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'gcx, 'tcx> {\n+        self.tcx\n+        }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>\n@@ -5700,9 +5692,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       generics: &ty::Generics,\n-                                       ty: Ty<'tcx>) {\n+pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, generics: &ty::Generics, ty: Ty<'tcx>) {\n     let own_counts = generics.own_counts();\n     debug!(\n         \"check_bounds_are_used(n_tys={}, n_cts={}, ty={:?})\","}, {"sha": "2f3861b8d3478245e0d7c4a8df87055ef63a1210", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -651,6 +651,6 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn var_name(tcx: TyCtxt<'_, '_, '_>, var_hir_id: hir::HirId) -> ast::Name {\n+fn var_name(tcx: TyCtxt<'_, '_>, var_hir_id: hir::HirId) -> ast::Name {\n     tcx.hir().name_by_hir_id(var_hir_id)\n }"}, {"sha": "83711a32e23a549a536c447d8b23c07b2f071daf", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -25,17 +25,17 @@ use rustc::hir;\n /// ```rust\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)\n /// ```\n-struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n+struct CheckWfFcxBuilder<'gcx, 'tcx> {\n+    inherited: super::InheritedBuilder<'gcx, 'tcx>,\n     id: hir::HirId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-    fn with_fcx<F>(&'tcx mut self, f: F) where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>,\n-                         TyCtxt<'b, 'gcx, 'gcx>) -> Vec<Ty<'tcx>>\n+impl<'gcx, 'tcx> CheckWfFcxBuilder<'gcx, 'tcx> {\n+    fn with_fcx<F>(&'tcx mut self, f: F)\n+    where\n+        F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>, TyCtxt<'gcx, 'gcx>) -> Vec<Ty<'tcx>>,\n     {\n         let id = self.id;\n         let span = self.span;\n@@ -68,7 +68,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n-pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(hir_id);\n \n@@ -156,7 +156,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n     }\n }\n \n-pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n@@ -167,7 +167,7 @@ pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     check_associated_item(tcx, trait_item.hir_id, trait_item.span, method_sig);\n }\n \n-pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+pub fn check_impl_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n@@ -178,10 +178,12 @@ pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n-fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   item_id: hir::HirId,\n-                                   span: Span,\n-                                   sig_if_method: Option<&hir::MethodSig>) {\n+fn check_associated_item<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item_id: hir::HirId,\n+    span: Span,\n+    sig_if_method: Option<&hir::MethodSig>,\n+) {\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n     let code = ObligationCauseCode::MiscObligation;\n@@ -225,13 +227,18 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n-                            -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+fn for_item<'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    item: &hir::Item,\n+) -> CheckWfFcxBuilder<'gcx, 'tcx> {\n     for_id(tcx, item.hir_id, item.span)\n }\n \n-fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: hir::HirId, span: Span)\n-                          -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+fn for_id<'gcx: 'tcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    id: hir::HirId,\n+    span: Span,\n+) -> CheckWfFcxBuilder<'gcx, 'tcx> {\n     let def_id = tcx.hir().local_def_id_from_hir_id(id);\n     CheckWfFcxBuilder {\n         inherited: Inherited::build(tcx, def_id),\n@@ -242,9 +249,13 @@ fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: hir::HirId, span: Spa\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n-    where F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>\n+fn check_type_defn<'tcx, F>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &hir::Item,\n+    all_sized: bool,\n+    mut lookup_fields: F,\n+) where\n+    F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>,\n {\n     for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n         let variants = lookup_fields(fcx);\n@@ -312,7 +323,7 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n }\n \n-fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+fn check_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item: &hir::Item) {\n     debug!(\"check_trait: {:?}\", item.hir_id);\n \n     let trait_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -335,7 +346,7 @@ fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     });\n }\n \n-fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+fn check_item_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item: &hir::Item) {\n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n         let def_id = fcx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let sig = fcx.tcx.fn_sig(def_id);\n@@ -347,8 +358,8 @@ fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n     })\n }\n \n-fn check_item_type<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn check_item_type<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     item_id: hir::HirId,\n     ty_span: Span,\n     allow_foreign_ty: bool,\n@@ -380,11 +391,12 @@ fn check_item_type<'a, 'tcx>(\n     });\n }\n \n-fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        item: &hir::Item,\n-                        ast_self_ty: &hir::Ty,\n-                        ast_trait_ref: &Option<hir::TraitRef>)\n-{\n+fn check_impl<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &hir::Item,\n+    ast_self_ty: &hir::Ty,\n+    ast_trait_ref: &Option<hir::TraitRef>,\n+) {\n     debug!(\"check_impl: {:?}\", item);\n \n     for_item(tcx, item).with_fcx(|fcx, tcx| {\n@@ -421,8 +433,8 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n-fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+fn check_where_clauses<'gcx, 'fcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n     fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     span: Span,\n     def_id: DefId,\n@@ -574,13 +586,14 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     }\n }\n \n-fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                            fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                            span: Span,\n-                                            sig: ty::PolyFnSig<'tcx>,\n-                                            def_id: DefId,\n-                                            implied_bounds: &mut Vec<Ty<'tcx>>)\n-{\n+fn check_fn_or_method<'fcx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n+    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+    span: Span,\n+    sig: ty::PolyFnSig<'tcx>,\n+    def_id: DefId,\n+    implied_bounds: &mut Vec<Ty<'tcx>>,\n+) {\n     let sig = fcx.normalize_associated_types_in(span, &sig);\n     let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n \n@@ -616,8 +629,8 @@ fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n /// fn b<T>() -> Foo<T, u32> { .. }\n /// ```\n ///\n-fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+fn check_existential_types<'fcx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'gcx, 'gcx>,\n     fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     fn_def_id: DefId,\n     span: Span,\n@@ -930,10 +943,11 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n     true\n }\n \n-fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           item: &hir::Item,\n-                                           hir_generics: &hir::Generics)\n-{\n+fn check_variances_for_type_defn<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    item: &hir::Item,\n+    hir_generics: &hir::Generics,\n+) {\n     let item_def_id = tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     let ty = tcx.type_of(item_def_id);\n     if tcx.has_error_field(ty) {\n@@ -971,10 +985,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               span: Span,\n-                               param_name: ast::Name)\n-{\n+fn report_bivariance<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, span: Span, param_name: ast::Name) {\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n@@ -987,7 +998,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n+fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_>, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n@@ -1052,20 +1063,19 @@ fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n     fcx.select_all_obligations_or_error();\n }\n \n-pub struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct CheckTypeWellFormedVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n-               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+impl CheckTypeWellFormedVisitor<'gcx> {\n+    pub fn new(tcx: TyCtxt<'gcx, 'gcx>) -> CheckTypeWellFormedVisitor<'gcx> {\n         CheckTypeWellFormedVisitor {\n             tcx,\n         }\n     }\n }\n \n-impl<'a, 'tcx> ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n+impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n     fn visit_item(&self, i: &'tcx hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(i.hir_id);\n@@ -1134,15 +1144,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast::Name)\n-                       -> DiagnosticBuilder<'tcx> {\n+fn error_392<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    span: Span,\n+    param_name: ast::Name,\n+) -> DiagnosticBuilder<'tcx> {\n     let mut err = struct_span_err!(tcx.sess, span, E0392,\n                   \"parameter `{}` is never used\", param_name);\n     err.span_label(span, \"unused parameter\");\n     err\n }\n \n-fn error_194(tcx: TyCtxt<'_, '_, '_>, span: Span, trait_decl_span: Span, name: &str) {\n+fn error_194(tcx: TyCtxt<'_, '_>, span: Span, trait_decl_span: Span, name: &str) {\n     struct_span_err!(tcx.sess, span, E0194,\n                      \"type parameter `{}` shadows another type parameter of the same name\",\n                      name)"}, {"sha": "cc9097ea8c83b608c1d906e5e7e60734996835a7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -123,7 +123,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n@@ -762,24 +762,24 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n }\n \n trait Locatable {\n-    fn to_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span;\n+    fn to_span(&self, tcx: TyCtxt<'_, '_>) -> Span;\n }\n \n impl Locatable for Span {\n-    fn to_span(&self, _: TyCtxt<'_, '_, '_>) -> Span {\n+    fn to_span(&self, _: TyCtxt<'_, '_>) -> Span {\n         *self\n     }\n }\n \n impl Locatable for DefIndex {\n-    fn to_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn to_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         let hir_id = tcx.hir().def_index_to_hir_id(*self);\n         tcx.hir().span_by_hir_id(hir_id)\n     }\n }\n \n impl Locatable for hir::HirId {\n-    fn to_span(&self, tcx: TyCtxt<'_, '_, '_>) -> Span {\n+    fn to_span(&self, tcx: TyCtxt<'_, '_>) -> Span {\n         tcx.hir().span_by_hir_id(*self)\n     }\n }\n@@ -789,7 +789,7 @@ impl Locatable for hir::HirId {\n // unresolved types and so forth.\n \n struct Resolver<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: &'cx dyn Locatable,\n     body: &'gcx hir::Body,\n@@ -819,7 +819,7 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'gcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "5f4f88d954490c74d1a0443e0cbe6482a2d06519", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -13,7 +13,7 @@ use rustc::util::nodemap::DefIdSet;\n \n use rustc_data_structures::fx::FxHashMap;\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let mut used_trait_imports = DefIdSet::default();\n     for &body_id in tcx.hir().krate().bodies.keys() {\n         let item_def_id = tcx.hir().body_owner_def_id(body_id);\n@@ -28,7 +28,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     unused_crates_lint(tcx);\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n@@ -45,12 +45,12 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     }\n }\n \n-struct CheckVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CheckVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     used_trait_imports: DefIdSet,\n }\n \n-impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n+impl CheckVisitor<'tcx> {\n     fn check_import(&self, id: hir::HirId, span: Span) {\n         let def_id = self.tcx.hir().local_def_id_from_hir_id(id);\n         if !self.tcx.maybe_unused_trait_import(def_id) {\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> CheckVisitor<'a, 'tcx> {\n     }\n }\n \n-fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n+fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n \n     // Collect first the crates that are completely unused.  These we\n@@ -195,7 +195,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) {\n }\n \n struct CollectExternCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     crates_to_lint: &'a mut Vec<ExternCrateToLint>,\n }\n "}, {"sha": "1eb3d108f786cf00d2b860db055cbb324e153733", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::DefId;\n use hir::Node;\n use rustc::hir::{self, ItemKind};\n \n-pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n+pub fn check_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n         .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n@@ -26,14 +26,15 @@ pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n             visit_implementation_of_dispatch_from_dyn);\n }\n \n-struct Checker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    trait_def_id: DefId\n+struct Checker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    trait_def_id: DefId,\n }\n \n-impl<'a, 'tcx> Checker<'a, 'tcx> {\n+impl<'tcx> Checker<'tcx> {\n     fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n-        where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId)\n+    where\n+        F: FnMut(TyCtxt<'tcx, 'tcx>, DefId),\n     {\n         if Some(self.trait_def_id) == trait_def_id {\n             for &impl_id in self.tcx.hir().trait_impls(self.trait_def_id) {\n@@ -45,7 +46,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_drop<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, impl_did: DefId) {\n     if let ty::Adt(..) = tcx.type_of(impl_did).sty {\n         /* do nothing */\n     } else {\n@@ -73,7 +74,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     }\n }\n \n-fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n     let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n@@ -140,7 +141,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n     }\n }\n \n-fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n            impl_did);\n \n@@ -153,10 +154,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impl_did: DefId,\n-) {\n+fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\",\n            impl_did);\n     if impl_did.is_local() {\n@@ -324,9 +322,7 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n     }\n }\n \n-pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n-                                     impl_did: DefId)\n-                                     -> CoerceUnsizedInfo {\n+pub fn coerce_unsized_info<'gcx>(gcx: TyCtxt<'gcx, 'gcx>, impl_did: DefId) -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n     let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n "}, {"sha": "d6c2d56a9adf78ef8f10a8720a190703c7217787", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -17,9 +17,10 @@ use syntax::ast;\n use syntax_pos::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n-pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      crate_num: CrateNum)\n-                                      -> &'tcx CrateInherentImpls {\n+pub fn crate_inherent_impls<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    crate_num: CrateNum,\n+) -> &'tcx CrateInherentImpls {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n@@ -32,9 +33,7 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type.\n-pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                ty_def_id: DefId)\n-                                -> &'tcx [DefId] {\n+pub fn inherent_impls<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ty_def_id: DefId) -> &'tcx [DefId] {\n     assert!(ty_def_id.is_local());\n \n     // NB. Until we adopt the red-green dep-tracking algorithm (see\n@@ -68,12 +67,12 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n-struct InherentCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct InherentCollect<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     impls_map: CrateInherentImpls,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let ty = match item.node {\n             hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n@@ -277,7 +276,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n+impl InherentCollect<'tcx> {\n     fn check_def_id(&mut self, item: &hir::Item, def_id: DefId) {\n         if def_id.is_local() {\n             // Add the implementation to the mapping from implementation to base"}, {"sha": "d557a9c871b121602530b0be9d274b24f2552149", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -5,18 +5,17 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n-pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                    crate_num: CrateNum) {\n+pub fn crate_inherent_impls_overlap_check<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     let krate = tcx.hir().krate();\n     krate.visit_all_item_likes(&mut InherentOverlapChecker { tcx });\n }\n \n-struct InherentOverlapChecker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+struct InherentOverlapChecker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+impl InherentOverlapChecker<'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n                                        overlap: traits::OverlapResult<'_>) {\n \n@@ -83,7 +82,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemKind::Enum(..) |"}, {"sha": "3be46722ecccda80faaaba02f235b6fc5aa53bcc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,7 +18,7 @@ mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_id: HirId) {\n+fn check_impl<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: HirId) {\n     let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n \n     // If there are no traits, then this implementation must have a\n@@ -41,9 +41,9 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_id: HirId) {\n }\n \n fn enforce_trait_manually_implementable(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     impl_def_id: DefId,\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n ) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n@@ -97,9 +97,9 @@ fn enforce_trait_manually_implementable(\n /// We allow impls of marker traits to overlap, so they can't override impls\n /// as that could make it ambiguous which associated item to use.\n fn enforce_empty_impls_for_marker_traits(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     impl_def_id: DefId,\n-    trait_def_id: DefId\n+    trait_def_id: DefId,\n ) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;\n@@ -132,7 +132,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn coherent_trait<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) {\n     let impls = tcx.hir().trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);\n@@ -143,7 +143,7 @@ fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     builtin::check_trait(tcx, def_id);\n }\n \n-pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check_coherence<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     for &trait_def_id in tcx.hir().krate().trait_impls.keys() {\n         tcx.ensure().coherent_trait(trait_def_id);\n     }\n@@ -159,7 +159,7 @@ pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n /// Overlap: no two impls for the same trait are implemented for the\n /// same type. Likewise, no two inherent impls for a given type\n /// constructor provide a method with the same name.\n-fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_id: HirId) {\n+fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_id: HirId) {\n     let impl_def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n     let trait_def_id = trait_ref.def_id;"}, {"sha": "4e81102fd3b8472bcca8df4a6a4bd424a83f2658", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -6,16 +6,16 @@ use rustc::ty::{self, TyCtxt};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let mut orphan = OrphanChecker { tcx };\n     tcx.hir().krate().visit_all_item_likes(&mut orphan);\n }\n \n-struct OrphanChecker<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+struct OrphanChecker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     /// Checks exactly one impl for orphan rules and other such\n     /// restrictions. In this fn, it can happen that multiple errors\n     /// apply to a specific impl, so just return after reporting one"}, {"sha": "c3a97bc538941d29dd1149989be67e4404c58135", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -5,16 +5,16 @@ use rustc::ty::TyCtxt;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, Unsafety};\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn check<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     let mut unsafety = UnsafetyChecker { tcx };\n     tcx.hir().krate().visit_all_item_likes(&mut unsafety);\n }\n \n-struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+struct UnsafetyChecker<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n+impl UnsafetyChecker<'tcx> {\n     fn check_unsafety_coherence(&mut self,\n                                 item: &'v hir::Item,\n                                 impl_generics: Option<&hir::Generics>,\n@@ -69,7 +69,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.node {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);"}, {"sha": "e1af8d8f46f7071bb4b93ee64492a6577e6c9c32", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 61, "deletions": 79, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -56,7 +56,7 @@ struct OnlySelfBounds(bool);\n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn collect_mod_item_types<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut CollectItemTypesVisitor { tcx }.as_deep_visitor()\n@@ -96,18 +96,18 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// `ItemCtxt` is parameterized by a `DefId` that it uses to satisfy\n /// `get_type_parameter_bounds` requests, drawing the information from\n /// the AST (`hir::Generics`), recursively.\n-pub struct ItemCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub struct ItemCtxt<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     item_def_id: DefId,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n \n-struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct CollectItemTypesVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n+impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n@@ -160,20 +160,18 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId) -> ItemCtxt<'a, 'tcx> {\n+impl ItemCtxt<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx, 'tcx>, item_def_id: DefId) -> ItemCtxt<'tcx> {\n         ItemCtxt { tcx, item_def_id }\n     }\n-}\n \n-impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     pub fn to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n }\n \n-impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+impl AstConv<'tcx, 'tcx> for ItemCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -255,8 +253,8 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-fn type_param_predicates<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn type_param_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     (item_def_id, def_id): (DefId, DefId),\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     use rustc::hir::*;\n@@ -333,7 +331,7 @@ fn type_param_predicates<'a, 'tcx>(\n     tcx.arena.alloc(result)\n }\n \n-impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n+impl ItemCtxt<'tcx> {\n     /// Finds bounds from `hir::Generics`. This requires scanning through the\n     /// AST. We do this to avoid having to convert *all* the bounds, which\n     /// would create artificial cycles. Instead we can only convert the\n@@ -383,11 +381,7 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n /// parameter with ID `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    ast_ty: &hir::Ty,\n-    param_id: hir::HirId,\n-) -> bool {\n+fn is_param<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ast_ty: &hir::Ty, param_id: hir::HirId) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n@@ -400,7 +394,7 @@ fn is_param<'a, 'tcx>(\n     }\n }\n \n-fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n+fn convert_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item_by_hir_id(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n@@ -482,7 +476,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: hir::HirId) {\n     }\n }\n \n-fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir::HirId) {\n+fn convert_trait_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, trait_item_id: hir::HirId) {\n     let trait_item = tcx.hir().expect_trait_item(trait_item_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(trait_item.hir_id);\n     tcx.generics_of(def_id);\n@@ -503,7 +497,7 @@ fn convert_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_item_id: hir:\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::HirId) {\n+fn convert_impl_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, impl_item_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(impl_item_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n@@ -513,15 +507,15 @@ fn convert_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_item_id: hir::H\n     }\n }\n \n-fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ctor_id: hir::HirId) {\n+fn convert_variant_ctor<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, ctor_id: hir::HirId) {\n     let def_id = tcx.hir().local_def_id_from_hir_id(ctor_id);\n     tcx.generics_of(def_id);\n     tcx.type_of(def_id);\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn convert_enum_variant_types<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n     variants: &[hir::Variant],\n ) {\n@@ -572,15 +566,15 @@ fn convert_enum_variant_types<'a, 'tcx>(\n     }\n }\n \n-fn convert_variant<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn convert_variant<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     variant_did: Option<DefId>,\n     ctor_did: Option<DefId>,\n     ident: Ident,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n     adt_kind: ty::AdtKind,\n-    parent_did: DefId\n+    parent_did: DefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n     let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n@@ -629,7 +623,7 @@ fn convert_variant<'a, 'tcx>(\n     )\n }\n \n-fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n+fn adt_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -696,8 +690,8 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n-fn super_predicates_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn super_predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     trait_def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n@@ -750,7 +744,7 @@ fn super_predicates_of<'a, 'tcx>(\n     })\n }\n \n-fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n+fn trait_def<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item_by_hir_id(hir_id);\n \n@@ -781,17 +775,14 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n     tcx.arena.alloc(def)\n }\n \n-fn has_late_bound_regions<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    node: Node<'tcx>,\n-) -> Option<Span> {\n-    struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, node: Node<'tcx>) -> Option<Span> {\n+    struct LateBoundRegionsDetector<'tcx> {\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         outer_index: ty::DebruijnIndex,\n         has_late_bound_regions: Option<Span>,\n     }\n \n-    impl<'a, 'tcx> Visitor<'tcx> for LateBoundRegionsDetector<'a, 'tcx> {\n+    impl Visitor<'tcx> for LateBoundRegionsDetector<'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n             NestedVisitorMap::None\n         }\n@@ -842,8 +833,8 @@ fn has_late_bound_regions<'a, 'tcx>(\n         }\n     }\n \n-    fn has_late_bound_regions<'a, 'tcx>(\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn has_late_bound_regions<'tcx>(\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         generics: &'tcx hir::Generics,\n         decl: &'tcx hir::FnDecl,\n     ) -> Option<Span> {\n@@ -892,7 +883,7 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n }\n \n-fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n+fn generics_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Generics {\n     use rustc::hir::*;\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1135,7 +1126,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n     })\n }\n \n-fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) {\n+fn report_assoc_ty_on_inherent_impl<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, span: Span) {\n     span_err!(\n         tcx.sess,\n         span,\n@@ -1144,16 +1135,16 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n     );\n }\n \n-fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+fn type_of<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     checked_type_of(tcx, def_id, true).unwrap()\n }\n \n /// Same as [`type_of`] but returns [`Option`] instead of failing.\n ///\n /// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n /// you'd better just call [`type_of`] directly.\n-pub fn checked_type_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn checked_type_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n     fail: bool,\n ) -> Option<Ty<'tcx>> {\n@@ -1481,16 +1472,13 @@ pub fn checked_type_of<'a, 'tcx>(\n     })\n }\n \n-fn find_existential_constraints<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Ty<'tcx> {\n+fn find_existential_constraints<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n     use rustc::hir::{ImplItem, Item, TraitItem};\n \n     debug!(\"find_existential_constraints({:?})\", def_id);\n \n-    struct ConstraintLocator<'a, 'tcx: 'a> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    struct ConstraintLocator<'tcx> {\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         def_id: DefId,\n         // (first found type span, actual type, mapping from the existential type's generic\n         // parameters to the concrete type's generic parameters)\n@@ -1501,7 +1489,7 @@ fn find_existential_constraints<'a, 'tcx>(\n         found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n     }\n \n-    impl<'a, 'tcx> ConstraintLocator<'a, 'tcx> {\n+    impl ConstraintLocator<'tcx> {\n         fn check(&mut self, def_id: DefId) {\n             // Don't try to check items that cannot possibly constrain the type.\n             if !self.tcx.has_typeck_tables(def_id) {\n@@ -1638,7 +1626,7 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n     }\n \n-    impl<'a, 'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'a, 'tcx> {\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n             intravisit::NestedVisitorMap::All(&self.tcx.hir())\n         }\n@@ -1702,7 +1690,7 @@ fn find_existential_constraints<'a, 'tcx>(\n     }\n }\n \n-fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n+fn fn_sig<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n     use rustc::hir::*;\n     use rustc::hir::Node::*;\n \n@@ -1778,10 +1766,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n     }\n }\n \n-fn impl_trait_ref<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Option<ty::TraitRef<'tcx>> {\n+fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<ty::TraitRef<'tcx>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -1796,7 +1781,7 @@ fn impl_trait_ref<'a, 'tcx>(\n     }\n }\n \n-fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::ImplPolarity {\n+fn impl_polarity<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> hir::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     match tcx.hir().expect_item_by_hir_id(hir_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n@@ -1809,8 +1794,8 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> hir::I\n /// the lifetimes that are declared. For fns or methods, we have to\n /// screen out those that do not appear in any where-clauses etc using\n /// `resolve_lifetime::early_bound_lifetimes`.\n-fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     generics: &'a hir::Generics,\n ) -> impl Iterator<Item = &'a hir::GenericParam> + Captures<'tcx> {\n     generics\n@@ -1827,8 +1812,8 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n /// Returns a list of type predicates for the definition with ID `def_id`, including inferred\n /// lifetime constraints. This includes all predicates returned by `explicit_predicates_of`, plus\n /// inferred constraints concerning which regions outlive other regions.\n-fn predicates_defined_on<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn predicates_defined_on<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     debug!(\"predicates_defined_on({:?})\", def_id);\n@@ -1857,8 +1842,8 @@ fn predicates_defined_on<'a, 'tcx>(\n /// Returns a list of all type predicates (explicit and implicit) for the definition with\n /// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n /// `Self: Trait` predicates for traits.\n-fn predicates_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     let mut result = tcx.predicates_defined_on(def_id);\n@@ -1887,8 +1872,8 @@ fn predicates_of<'a, 'tcx>(\n \n /// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n /// N.B., this does not include any implied/inferred constraints.\n-fn explicit_predicates_of<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn explicit_predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n ) -> &'tcx ty::GenericPredicates<'tcx> {\n     use rustc::hir::*;\n@@ -2250,8 +2235,8 @@ fn predicates_from_bound<'tcx>(\n     }\n }\n \n-fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compute_sig_of_foreign_fn_decl<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n     def_id: DefId,\n     decl: &hir::FnDecl,\n     abi: abi::Abi,\n@@ -2295,18 +2280,15 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n     fty\n }\n \n-fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n+fn is_foreign_item<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }\n }\n \n-fn static_mutability<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    def_id: DefId,\n-) -> Option<hir::Mutability> {\n+fn static_mutability<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId) -> Option<hir::Mutability> {\n     match tcx.hir().get_if_local(def_id) {\n         Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Static(_, mutbl, _), ..\n@@ -2320,7 +2302,7 @@ fn static_mutability<'a, 'tcx>(\n }\n \n fn from_target_feature(\n-    tcx: TyCtxt<'_, '_, '_>,\n+    tcx: TyCtxt<'_, '_>,\n     id: DefId,\n     attr: &ast::Attribute,\n     whitelist: &FxHashMap<String, Option<Symbol>>,\n@@ -2414,7 +2396,7 @@ fn from_target_feature(\n     }\n }\n \n-fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &str) -> Linkage {\n+fn linkage_by_name<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, def_id: DefId, name: &str) -> Linkage {\n     use rustc::mir::mono::Linkage::*;\n \n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n@@ -2449,7 +2431,7 @@ fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &\n     }\n }\n \n-fn codegen_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> CodegenFnAttrs {\n+fn codegen_fn_attrs<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, id: DefId) -> CodegenFnAttrs {\n     let attrs = tcx.get_attrs(id);\n \n     let mut codegen_fn_attrs = CodegenFnAttrs::new();"}, {"sha": "3d424ce89dbc5c5134bc3670ea6c94c212ef9689", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -86,11 +86,12 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     }\n }\n \n-pub fn identify_constrained_generic_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                                              predicates: &ty::GenericPredicates<'tcx>,\n-                                              impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                              input_parameters: &mut FxHashSet<Parameter>)\n-{\n+pub fn identify_constrained_generic_params<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    predicates: &ty::GenericPredicates<'tcx>,\n+    impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    input_parameters: &mut FxHashSet<Parameter>,\n+) {\n     let mut predicates = predicates.predicates.clone();\n     setup_constraining_predicates(tcx, &mut predicates, impl_trait_ref, input_parameters);\n }\n@@ -136,11 +137,12 @@ pub fn identify_constrained_generic_params<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n /// which is determined by 1, which requires `U`, that is determined\n /// by 0. I should probably pick a less tangled example, but I can't\n /// think of any.\n-pub fn setup_constraining_predicates<'tcx>(tcx: TyCtxt<'_, '_, '_>,\n-                                           predicates: &mut [(ty::Predicate<'tcx>, Span)],\n-                                           impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-                                           input_parameters: &mut FxHashSet<Parameter>)\n-{\n+pub fn setup_constraining_predicates<'tcx>(\n+    tcx: TyCtxt<'_, '_>,\n+    predicates: &mut [(ty::Predicate<'tcx>, Span)],\n+    impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n+    input_parameters: &mut FxHashSet<Parameter>,\n+) {\n     // The canonical way of doing the needed topological sort\n     // would be a DFS, but getting the graph and its ownership\n     // right is annoying, so I am using an in-place fixed-point iteration,"}, {"sha": "e13a664be05644b261f4f9581920b4b907cb2352", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -49,7 +49,7 @@ use syntax_pos::Span;\n /// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n /// //   ^ 'a is unused and appears in assoc type, error\n /// ```\n-pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn impl_wf_check<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     // We will tag this as part of the WF check -- logically, it is,\n     // but it's one that we must perform earlier than the rest of\n     // WfCheck.\n@@ -58,7 +58,7 @@ pub fn impl_wf_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn check_mod_impl_wf<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+fn check_mod_impl_wf<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, module_def_id: DefId) {\n     tcx.hir().visit_item_likes_in_module(\n         module_def_id,\n         &mut ImplWfCheck { tcx }\n@@ -72,11 +72,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-struct ImplWfCheck<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct ImplWfCheck<'tcx> {\n+    tcx: TyCtxt<'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n+impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.node {\n             let impl_def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n@@ -92,10 +92,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n }\n \n-fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 impl_def_id: DefId,\n-                                                 impl_item_refs: &[hir::ImplItemRef])\n-{\n+fn enforce_impl_params_are_constrained<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_def_id: DefId,\n+    impl_item_refs: &[hir::ImplItemRef],\n+) {\n     // Every lifetime used in an associated type must be constrained.\n     let impl_self_ty = tcx.type_of(impl_def_id);\n     let impl_generics = tcx.generics_of(impl_def_id);\n@@ -171,11 +172,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(tcx: TyCtxt<'_, '_, '_>,\n-                           span: Span,\n-                           kind: &str,\n-                           name: &str)\n-{\n+fn report_unused_parameter(tcx: TyCtxt<'_, '_>, span: Span, kind: &str, name: &str) {\n     struct_span_err!(\n         tcx.sess, span, E0207,\n         \"the {} parameter `{}` is not constrained by the \\\n@@ -186,9 +183,10 @@ fn report_unused_parameter(tcx: TyCtxt<'_, '_, '_>,\n }\n \n /// Enforce that we do not have two items in an impl with the same name.\n-fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             impl_item_refs: &[hir::ImplItemRef])\n-{\n+fn enforce_impl_items_are_distinct<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    impl_item_refs: &[hir::ImplItemRef],\n+) {\n     let mut seen_type_items = FxHashMap::default();\n     let mut seen_value_items = FxHashMap::default();\n     for impl_item_ref in impl_item_refs {"}, {"sha": "ce8bb975f986687b252f17e5c95ce999d75070cd", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -63,6 +63,7 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(exhaustive_patterns)]\n+#![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n@@ -123,8 +124,7 @@ pub struct TypeAndSubsts<'tcx> {\n     ty: Ty<'tcx>,\n }\n \n-fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                          span: Span) {\n+fn check_type_alias_enum_variants_enabled<'gcx, 'tcx>(tcx: TyCtxt<'gcx, 'tcx>, span: Span) {\n     if !tcx.features().type_alias_enum_variants {\n         let mut err = tcx.sess.struct_span_err(\n             span,\n@@ -139,22 +139,20 @@ fn check_type_alias_enum_variants_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n     }\n }\n \n-fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_, '_, '_>,\n-                               decl: &hir::FnDecl,\n-                               abi: Abi,\n-                               span: Span) {\n+fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_, '_>, decl: &hir::FnDecl, abi: Abi, span: Span) {\n     if decl.c_variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n             \"C-variadic function must have C or cdecl calling convention\");\n         err.span_label(span, \"C-variadics require C or cdecl calling convention\").emit();\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                cause: &ObligationCause<'tcx>,\n-                                expected: Ty<'tcx>,\n-                                actual: Ty<'tcx>)\n-                                -> bool {\n+fn require_same_types<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    cause: &ObligationCause<'tcx>,\n+    expected: Ty<'tcx>,\n+    actual: Ty<'tcx>,\n+) -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n         let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n@@ -178,7 +176,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n+fn check_main_fn_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, main_def_id: DefId) {\n     let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n@@ -243,7 +241,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, main_def_id: DefId) {\n     }\n }\n \n-fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, start_def_id: DefId) {\n+fn check_start_fn_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, start_def_id: DefId) {\n     let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n@@ -300,7 +298,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, start_def_id: DefId)\n     }\n }\n \n-fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn check_for_entry_fn<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) {\n     match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id),\n         Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id),\n@@ -317,9 +315,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     impl_wf_check::provide(providers);\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                             -> Result<(), ErrorReported>\n-{\n+pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx, 'tcx>) -> Result<(), ErrorReported> {\n     tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n \n     // this ensures that later parts of type checking can assume that items\n@@ -380,7 +376,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n /// A quasi-deprecated helper used in rustdoc and clippy to get\n /// the type from a HIR node.\n-pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n+pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx, 'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n@@ -391,8 +387,10 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n-pub fn hir_trait_to_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_trait: &hir::TraitRef)\n-        -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n+pub fn hir_trait_to_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx>,\n+    hir_trait: &hir::TraitRef,\n+) -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing."}, {"sha": "9d621407caf5f6167538958d97c9f049d949b553", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddd1615419be89828fb5628e3c14af86c08b01/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=24ddd1615419be89828fb5628e3c14af86c08b01", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n     pub fn explicit_predicates_of(\n         &mut self,\n-        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        tcx: TyCtxt<'tcx, 'tcx>,\n         def_id: DefId,\n     ) -> &RequiredPredicates<'tcx> {\n         self.map.entry(def_id).or_insert_with(|| {"}]}