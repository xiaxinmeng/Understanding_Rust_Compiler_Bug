{"sha": "5fa9de16df87ab844452821acff1b6c74e948327", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYTlkZTE2ZGY4N2FiODQ0NDUyODIxYWNmZjFiNmM3NGU5NDgzMjc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-18T07:44:55Z"}, "committer": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-18T19:01:46Z"}, "message": "Implement RFC 580\n\nThis commit implements RFC 580 by renaming:\n\n* DList -> LinkedList\n* Bitv -> BitVec\n* BitvSet -> BitSet\n* RingBuf -> VecDeque\n\nMore details are in [the\nRFC](https://github.com/rust-lang/rfcs/pull/580)\n\n[breaking-change]", "tree": {"sha": "c4f4c06960f557277c07457b14bf61f8861ba8e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4f4c06960f557277c07457b14bf61f8861ba8e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fa9de16df87ab844452821acff1b6c74e948327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa9de16df87ab844452821acff1b6c74e948327", "html_url": "https://github.com/rust-lang/rust/commit/5fa9de16df87ab844452821acff1b6c74e948327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fa9de16df87ab844452821acff1b6c74e948327/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "html_url": "https://github.com/rust-lang/rust/commit/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5"}], "stats": {"total": 1793, "additions": 917, "deletions": 876}, "files": [{"sha": "a2e36155933c9880e3a8d55d284f78b5d8d1e191", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 527, "deletions": 519, "changes": 1046, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for\n-// maintenance), they should be in separate files/modules, with BitvSet only\n-// using Bitv's public API. This will be hard for performance though, because\n-// `Bitv` will not want to leak its internal representation while its internal\n+// FIXME(Gankro): BitVec and BitSet are very tightly coupled. Ideally (for\n+// maintenance), they should be in separate files/modules, with BitSet only\n+// using BitVec's public API. This will be hard for performance though, because\n+// `BitVec` will not want to leak its internal representation while its internal\n // representation as `u32`s must be assumed for best performance.\n \n-// FIXME(tbu-): `Bitv`'s methods shouldn't be `union`, `intersection`, but\n+// FIXME(tbu-): `BitVec`'s methods shouldn't be `union`, `intersection`, but\n // rather `or` and `and`.\n \n // (1) Be careful, most things can overflow here because the amount of bits in\n@@ -25,8 +25,8 @@\n //     methods rely on it (for *CORRECTNESS*).\n // (3) Make sure that the unused bits in the last word are zeroed out, again\n //     other methods rely on it for *CORRECTNESS*.\n-// (4) `BitvSet` is tightly coupled with `Bitv`, so any changes you make in\n-// `Bitv` will need to be reflected in `BitvSet`.\n+// (4) `BitSet` is tightly coupled with `BitVec`, so any changes you make in\n+// `BitVec` will need to be reflected in `BitSet`.\n \n //! Collections implemented with bit vectors.\n //!\n@@ -38,17 +38,17 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n-//! use std::collections::{BitvSet, Bitv};\n+//! use std::collections::{BitSet, BitVec};\n //! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;\n //!\n-//! // Store the primes as a BitvSet\n+//! // Store the primes as a BitSet\n //! let primes = {\n //!     // Assume all numbers are prime to begin, and then we\n //!     // cross off non-primes progressively\n-//!     let mut bv = Bitv::from_elem(max_prime, true);\n+//!     let mut bv = BitVec::from_elem(max_prime, true);\n //!\n //!     // Neither 0 nor 1 are prime\n //!     bv.set(0, false);\n@@ -62,7 +62,7 @@\n //!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n //!         }\n //!     }\n-//!     BitvSet::from_bitv(bv)\n+//!     BitSet::from_bit_vec(bv)\n //! };\n //!\n //! // Simple primality tests below our max bound\n@@ -75,7 +75,7 @@\n //! }\n //! println!(\"\");\n //!\n-//! // We can manipulate the internal Bitv\n+//! // We can manipulate the internal BitVec\n //! let num_primes = primes.get_ref().iter().filter(|x| *x).count();\n //! println!(\"There are {} primes below {}\", num_primes, max_prime);\n //! ```\n@@ -94,7 +94,7 @@ use core::num::Int;\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};\n-use bitv_set; //so meta\n+use bit_set; //so meta\n \n use Vec;\n \n@@ -112,7 +112,7 @@ fn reverse_bits(byte: u8) -> u8 {\n \n // Take two BitV's, and return iterators of their words, where the shorter one\n // has been padded with 0's\n-fn match_words <'a,'b>(a: &'a Bitv, b: &'b Bitv) -> (MatchWords<'a>, MatchWords<'b>) {\n+fn match_words <'a,'b>(a: &'a BitVec, b: &'b BitVec) -> (MatchWords<'a>, MatchWords<'b>) {\n     let a_len = a.storage.len();\n     let b_len = b.storage.len();\n \n@@ -134,9 +134,9 @@ static FALSE: bool = false;\n /// # Examples\n ///\n /// ```rust\n-/// use std::collections::Bitv;\n+/// use std::collections::BitVec;\n ///\n-/// let mut bv = Bitv::from_elem(10, false);\n+/// let mut bv = BitVec::from_elem(10, false);\n ///\n /// // insert all primes less than 10\n /// bv.set(2, true);\n@@ -158,15 +158,15 @@ static FALSE: bool = false;\n /// ```\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub struct Bitv {\n+pub struct BitVec {\n     /// Internal representation of the bit vector\n     storage: Vec<u32>,\n     /// The number of valid bits in the internal representation\n     nbits: usize\n }\n \n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n-impl Index<usize> for Bitv {\n+impl Index<usize> for BitVec {\n     type Output = bool;\n \n     #[inline]\n@@ -202,12 +202,12 @@ fn mask_for_bits(bits: usize) -> u32 {\n     !0u32 >> (u32::BITS - bits % u32::BITS) % u32::BITS\n }\n \n-impl Bitv {\n+impl BitVec {\n     /// Applies the given operation to the blocks of self and other, and sets\n     /// self to be the result. This relies on the caller not to corrupt the\n     /// last word.\n     #[inline]\n-    fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n+    fn process<F>(&mut self, other: &BitVec, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n         assert_eq!(self.len(), other.len());\n         // This could theoretically be a `debug_assert!`.\n         assert_eq!(self.storage.len(), other.storage.len());\n@@ -235,7 +235,7 @@ impl Bitv {\n     }\n \n     /// An operation might screw up the unused bits in the last block of the\n-    /// `Bitv`. As per (3), it's assumed to be all 0s. This method fixes it up.\n+    /// `BitVec`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n         let extra_bits = self.len() % u32::BITS;\n         if extra_bits > 0 {\n@@ -245,83 +245,83 @@ impl Bitv {\n         }\n     }\n \n-    /// Creates an empty `Bitv`.\n+    /// Creates an empty `BitVec`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n-    /// let mut bv = Bitv::new();\n+    /// use std::collections::BitVec;\n+    /// let mut bv = BitVec::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Bitv {\n-        Bitv { storage: Vec::new(), nbits: 0 }\n+    pub fn new() -> BitVec {\n+        BitVec { storage: Vec::new(), nbits: 0 }\n     }\n \n-    /// Creates a `Bitv` that holds `nbits` elements, setting each element\n+    /// Creates a `BitVec` that holds `nbits` elements, setting each element\n     /// to `bit`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.len(), 10);\n     /// for x in bv.iter() {\n     ///     assert_eq!(x, false);\n     /// }\n     /// ```\n-    pub fn from_elem(nbits: usize, bit: bool) -> Bitv {\n+    pub fn from_elem(nbits: usize, bit: bool) -> BitVec {\n         let nblocks = blocks_for_bits(nbits);\n-        let mut bitv = Bitv {\n+        let mut bit_vec = BitVec {\n             storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n             nbits: nbits\n         };\n-        bitv.fix_last_block();\n-        bitv\n+        bit_vec.fix_last_block();\n+        bit_vec\n     }\n \n-    /// Constructs a new, empty `Bitv` with the specified capacity.\n+    /// Constructs a new, empty `BitVec` with the specified capacity.\n     ///\n     /// The bitvector will be able to hold at least `capacity` bits without\n     /// reallocating. If `capacity` is 0, it will not allocate.\n     ///\n     /// It is important to note that this function does not specify the\n     /// *length* of the returned bitvector, but only the *capacity*.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> Bitv {\n-        Bitv {\n+    pub fn with_capacity(nbits: usize) -> BitVec {\n+        BitVec {\n             storage: Vec::with_capacity(blocks_for_bits(nbits)),\n             nbits: 0,\n         }\n     }\n \n-    /// Transforms a byte-vector into a `Bitv`. Each byte becomes eight bits,\n+    /// Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\n     /// with the most significant bits of each byte coming first. Each\n     /// bit becomes `true` if equal to 1 or `false` if equal to 0.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b10100000, 0b00010010]);\n+    /// let bv = BitVec::from_bytes(&[0b10100000, 0b00010010]);\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false,\n     ///                     false, false, false, true,\n     ///                     false, false, true, false]));\n     /// ```\n-    pub fn from_bytes(bytes: &[u8]) -> Bitv {\n+    pub fn from_bytes(bytes: &[u8]) -> BitVec {\n         let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n-        let mut bitv = Bitv::with_capacity(len);\n+        let mut bit_vec = BitVec::with_capacity(len);\n         let complete_words = bytes.len() / 4;\n         let extra_bytes = bytes.len() % 4;\n \n-        bitv.nbits = len;\n+        bit_vec.nbits = len;\n \n         for i in 0..complete_words {\n-            bitv.storage.push(\n+            bit_vec.storage.push(\n                 ((reverse_bits(bytes[i * 4 + 0]) as u32) << 0) |\n                 ((reverse_bits(bytes[i * 4 + 1]) as u32) << 8) |\n                 ((reverse_bits(bytes[i * 4 + 2]) as u32) << 16) |\n@@ -334,39 +334,39 @@ impl Bitv {\n             for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n-            bitv.storage.push(last_word);\n+            bit_vec.storage.push(last_word);\n         }\n \n-        bitv\n+        bit_vec\n     }\n \n-    /// Creates a `Bitv` of the specified length where the value at each index\n+    /// Creates a `BitVec` of the specified length where the value at each index\n     /// is `f(index)`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_fn(5, |i| { i % 2 == 0 });\n+    /// let bv = BitVec::from_fn(5, |i| { i % 2 == 0 });\n     /// assert!(bv.eq_vec(&[true, false, true, false, true]));\n     /// ```\n-    pub fn from_fn<F>(len: usize, mut f: F) -> Bitv where F: FnMut(usize) -> bool {\n-        let mut bitv = Bitv::from_elem(len, false);\n+    pub fn from_fn<F>(len: usize, mut f: F) -> BitVec where F: FnMut(usize) -> bool {\n+        let mut bit_vec = BitVec::from_elem(len, false);\n         for i in 0..len {\n-            bitv.set(i, f(i));\n+            bit_vec.set(i, f(i));\n         }\n-        bitv\n+        bit_vec\n     }\n \n     /// Retrieves the value at index `i`, or `None` if the index is out of bounds.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01100000]);\n+    /// let bv = BitVec::from_bytes(&[0b01100000]);\n     /// assert_eq!(bv.get(0), Some(false));\n     /// assert_eq!(bv.get(1), Some(true));\n     /// assert_eq!(bv.get(100), None);\n@@ -396,9 +396,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(5, false);\n+    /// let mut bv = BitVec::from_elem(5, false);\n     /// bv.set(3, true);\n     /// assert_eq!(bv[3], true);\n     /// ```\n@@ -420,14 +420,14 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b11111111;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[before]);\n+    /// let mut bv = BitVec::from_bytes(&[before]);\n     /// bv.set_all();\n-    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n@@ -440,14 +440,14 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n     /// let after  = 0b10011111;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[before]);\n+    /// let mut bv = BitVec::from_bytes(&[before]);\n     /// bv.negate();\n-    /// assert_eq!(bv, Bitv::from_bytes(&[after]));\n+    /// assert_eq!(bv, BitVec::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n@@ -468,20 +468,20 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01111110;\n     ///\n-    /// let mut a = Bitv::from_bytes(&[a]);\n-    /// let b = Bitv::from_bytes(&[b]);\n+    /// let mut a = BitVec::from_bytes(&[a]);\n+    /// let b = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(a.union(&b));\n-    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n     /// ```\n     #[inline]\n-    pub fn union(&mut self, other: &Bitv) -> bool {\n+    pub fn union(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 | w2)\n     }\n \n@@ -498,20 +498,20 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let res = 0b01000000;\n     ///\n-    /// let mut a = Bitv::from_bytes(&[a]);\n-    /// let b = Bitv::from_bytes(&[b]);\n+    /// let mut a = BitVec::from_bytes(&[a]);\n+    /// let b = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, Bitv::from_bytes(&[res]));\n+    /// assert_eq!(a, BitVec::from_bytes(&[res]));\n     /// ```\n     #[inline]\n-    pub fn intersect(&mut self, other: &Bitv) -> bool {\n+    pub fn intersect(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 & w2)\n     }\n \n@@ -528,27 +528,27 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n     /// let b   = 0b01011010;\n     /// let a_b = 0b00100100; // a - b\n     /// let b_a = 0b00011010; // b - a\n     ///\n-    /// let mut bva = Bitv::from_bytes(&[a]);\n-    /// let bvb = Bitv::from_bytes(&[b]);\n+    /// let mut bva = BitVec::from_bytes(&[a]);\n+    /// let bvb = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, Bitv::from_bytes(&[a_b]));\n+    /// assert_eq!(bva, BitVec::from_bytes(&[a_b]));\n     ///\n-    /// let bva = Bitv::from_bytes(&[a]);\n-    /// let mut bvb = Bitv::from_bytes(&[b]);\n+    /// let bva = BitVec::from_bytes(&[a]);\n+    /// let mut bvb = BitVec::from_bytes(&[b]);\n     ///\n     /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, Bitv::from_bytes(&[b_a]));\n+    /// assert_eq!(bvb, BitVec::from_bytes(&[b_a]));\n     /// ```\n     #[inline]\n-    pub fn difference(&mut self, other: &Bitv) -> bool {\n+    pub fn difference(&mut self, other: &BitVec) -> bool {\n         self.process(other, |w1, w2| w1 & !w2)\n     }\n \n@@ -557,9 +557,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(5, true);\n+    /// let mut bv = BitVec::from_elem(5, true);\n     /// assert_eq!(bv.all(), true);\n     ///\n     /// bv.set(1, false);\n@@ -581,25 +581,25 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01110100, 0b10010010]);\n+    /// let bv = BitVec::from_bytes(&[0b01110100, 0b10010010]);\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n-        Iter { bitv: self, next_idx: 0, end_idx: self.nbits }\n+        Iter { bit_vec: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n     /// Returns `true` if all bits are 0.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.none(), true);\n     ///\n     /// bv.set(3, true);\n@@ -614,9 +614,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(10, false);\n+    /// let mut bv = BitVec::from_elem(10, false);\n     /// assert_eq!(bv.any(), false);\n     ///\n     /// bv.set(3, true);\n@@ -628,33 +628,33 @@ impl Bitv {\n     }\n \n     /// Organises the bits into bytes, such that the first bit in the\n-    /// `Bitv` becomes the high-order bit of the first byte. If the\n-    /// size of the `Bitv` is not a multiple of eight then trailing bits\n+    /// `BitVec` becomes the high-order bit of the first byte. If the\n+    /// size of the `BitVec` is not a multiple of eight then trailing bits\n     /// will be filled-in with `false`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, true);\n+    /// let mut bv = BitVec::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n     ///\n-    /// let mut bv = Bitv::from_elem(9, false);\n+    /// let mut bv = BitVec::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit(bitv: &Bitv, byte: usize, bit: usize) -> u8 {\n+        fn bit(bit_vec: &BitVec, byte: usize, bit: usize) -> u8 {\n             let offset = byte * 8 + bit;\n-            if offset >= bitv.nbits {\n+            if offset >= bit_vec.nbits {\n                 0\n             } else {\n-                (bitv[offset] as u8) << (7 - bit)\n+                (bit_vec[offset] as u8) << (7 - bit)\n             }\n         }\n \n@@ -672,19 +672,19 @@ impl Bitv {\n         ).collect()\n     }\n \n-    /// Compares a `Bitv` to a slice of `bool`s.\n-    /// Both the `Bitv` and slice must have the same length.\n+    /// Compares a `BitVec` to a slice of `bool`s.\n+    /// Both the `BitVec` and slice must have the same length.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the `Bitv` and slice are of different length.\n+    /// Panics if the `BitVec` and slice are of different length.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b10100000]);\n+    /// let bv = BitVec::from_bytes(&[0b10100000]);\n     ///\n     /// assert!(bv.eq_vec(&[true, false, true, false,\n     ///                     false, false, false, false]));\n@@ -694,17 +694,17 @@ impl Bitv {\n         iter::order::eq(self.iter(), v.iter().cloned())\n     }\n \n-    /// Shortens a `Bitv`, dropping excess elements.\n+    /// Shortens a `BitVec`, dropping excess elements.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n     /// effect.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.truncate(2);\n     /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n@@ -719,7 +719,7 @@ impl Bitv {\n     }\n \n     /// Reserves capacity for at least `additional` more bits to be inserted in the given\n-    /// `Bitv`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `BitVec`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -728,9 +728,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, false);\n+    /// let mut bv = BitVec::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n@@ -745,7 +745,7 @@ impl Bitv {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\n-    /// given `Bitv`. Does nothing if the capacity is already sufficient.\n+    /// given `BitVec`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -758,9 +758,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_elem(3, false);\n+    /// let mut bv = BitVec::from_elem(3, false);\n     /// bv.reserve(10);\n     /// assert_eq!(bv.len(), 3);\n     /// assert!(bv.capacity() >= 13);\n@@ -780,9 +780,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::new();\n+    /// let mut bv = BitVec::new();\n     /// bv.reserve(10);\n     /// assert!(bv.capacity() >= 10);\n     /// ```\n@@ -792,7 +792,7 @@ impl Bitv {\n         self.storage.capacity().checked_mul(u32::BITS).unwrap_or(usize::MAX)\n     }\n \n-    /// Grows the `Bitv` in-place, adding `n` copies of `value` to the `Bitv`.\n+    /// Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.\n     ///\n     /// # Panics\n     ///\n@@ -801,9 +801,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001011]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n@@ -846,14 +846,14 @@ impl Bitv {\n         self.fix_last_block();\n     }\n \n-    /// Removes the last bit from the Bitv, and returns it. Returns None if the Bitv is empty.\n+    /// Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::from_bytes(&[0b01001001]);\n+    /// let mut bv = BitVec::from_bytes(&[0b01001001]);\n     /// assert_eq!(bv.pop(), Some(true));\n     /// assert_eq!(bv.pop(), Some(false));\n     /// assert_eq!(bv.len(), 6);\n@@ -881,9 +881,9 @@ impl Bitv {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::Bitv;\n+    /// use std::collections::BitVec;\n     ///\n-    /// let mut bv = Bitv::new();\n+    /// let mut bv = BitVec::new();\n     /// bv.push(true);\n     /// bv.push(false);\n     /// assert!(bv.eq_vec(&[true, false]));\n@@ -917,22 +917,22 @@ impl Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for Bitv {\n+impl Default for BitVec {\n     #[inline]\n-    fn default() -> Bitv { Bitv::new() }\n+    fn default() -> BitVec { BitVec::new() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<bool> for Bitv {\n-    fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n-        let mut ret = Bitv::new();\n+impl FromIterator<bool> for BitVec {\n+    fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> BitVec {\n+        let mut ret = BitVec::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<bool> for Bitv {\n+impl Extend<bool> for BitVec {\n     #[inline]\n     fn extend<I: Iterator<Item=bool>>(&mut self, iterator: I) {\n         let (min, _) = iterator.size_hint();\n@@ -944,37 +944,37 @@ impl Extend<bool> for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for Bitv {\n+impl Clone for BitVec {\n     #[inline]\n-    fn clone(&self) -> Bitv {\n-        Bitv { storage: self.storage.clone(), nbits: self.nbits }\n+    fn clone(&self) -> BitVec {\n+        BitVec { storage: self.storage.clone(), nbits: self.nbits }\n     }\n \n     #[inline]\n-    fn clone_from(&mut self, source: &Bitv) {\n+    fn clone_from(&mut self, source: &BitVec) {\n         self.nbits = source.nbits;\n         self.storage.clone_from(&source.storage);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for Bitv {\n+impl PartialOrd for BitVec {\n     #[inline]\n-    fn partial_cmp(&self, other: &Bitv) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BitVec) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for Bitv {\n+impl Ord for BitVec {\n     #[inline]\n-    fn cmp(&self, other: &Bitv) -> Ordering {\n+    fn cmp(&self, other: &BitVec) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Bitv {\n+impl fmt::Debug for BitVec {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n@@ -984,7 +984,7 @@ impl fmt::Debug for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitVec {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n         for elem in self.blocks() {\n@@ -994,9 +994,9 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for Bitv {\n+impl cmp::PartialEq for BitVec {\n     #[inline]\n-    fn eq(&self, other: &Bitv) -> bool {\n+    fn eq(&self, other: &BitVec) -> bool {\n         if self.nbits != other.nbits {\n             return false;\n         }\n@@ -1005,13 +1005,13 @@ impl cmp::PartialEq for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for Bitv {}\n+impl cmp::Eq for BitVec {}\n \n-/// An iterator for `Bitv`.\n+/// An iterator for `BitVec`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Iter<'a> {\n-    bitv: &'a Bitv,\n+    bit_vec: &'a BitVec,\n     next_idx: usize,\n     end_idx: usize,\n }\n@@ -1025,7 +1025,7 @@ impl<'a> Iterator for Iter<'a> {\n         if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n-            Some(self.bitv[idx])\n+            Some(self.bit_vec[idx])\n         } else {\n             None\n         }\n@@ -1043,7 +1043,7 @@ impl<'a> DoubleEndedIterator for Iter<'a> {\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n             self.end_idx -= 1;\n-            Some(self.bitv[self.end_idx])\n+            Some(self.bit_vec[self.end_idx])\n         } else {\n             None\n         }\n@@ -1065,13 +1065,13 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n         if index >= self.indexable() {\n             None\n         } else {\n-            Some(self.bitv[index])\n+            Some(self.bit_vec[index])\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a Bitv {\n+impl<'a> IntoIterator for &'a BitVec {\n     type Item = bool;\n     type IntoIter = Iter<'a>;\n \n@@ -1090,10 +1090,10 @@ impl<'a> IntoIterator for &'a Bitv {\n /// # Examples\n ///\n /// ```\n-/// use std::collections::{BitvSet, Bitv};\n+/// use std::collections::{BitSet, BitVec};\n ///\n /// // It's a regular set\n-/// let mut s = BitvSet::new();\n+/// let mut s = BitSet::new();\n /// s.insert(0);\n /// s.insert(3);\n /// s.insert(7);\n@@ -1104,8 +1104,8 @@ impl<'a> IntoIterator for &'a Bitv {\n ///     println!(\"There is no 7\");\n /// }\n ///\n-/// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(Bitv::from_bytes(&[0b11010000]));\n+/// // Can initialize from a `BitVec`\n+/// let other = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1114,34 +1114,34 @@ impl<'a> IntoIterator for &'a Bitv {\n ///     println!(\"{}\", x);\n /// }\n ///\n-/// // Can convert back to a `Bitv`\n-/// let bv: Bitv = s.into_bitv();\n+/// // Can convert back to a `BitVec`\n+/// let bv: BitVec = s.into_bit_vec();\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub struct BitvSet {\n-    bitv: Bitv,\n+pub struct BitSet {\n+    bit_vec: BitVec,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for BitvSet {\n+impl Default for BitSet {\n     #[inline]\n-    fn default() -> BitvSet { BitvSet::new() }\n+    fn default() -> BitSet { BitSet::new() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl FromIterator<usize> for BitvSet {\n-    fn from_iter<I:Iterator<Item=usize>>(iterator: I) -> BitvSet {\n-        let mut ret = BitvSet::new();\n+impl FromIterator<usize> for BitSet {\n+    fn from_iter<I:Iterator<Item=usize>>(iterator: I) -> BitSet {\n+        let mut ret = BitSet::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Extend<usize> for BitvSet {\n+impl Extend<usize> for BitSet {\n     #[inline]\n     fn extend<I: Iterator<Item=usize>>(&mut self, iterator: I) {\n         for i in iterator {\n@@ -1151,87 +1151,95 @@ impl Extend<usize> for BitvSet {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for BitvSet {\n+impl PartialOrd for BitSet {\n     #[inline]\n-    fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n+    fn partial_cmp(&self, other: &BitSet) -> Option<Ordering> {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::partial_cmp(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for BitvSet {\n+impl Ord for BitSet {\n     #[inline]\n-    fn cmp(&self, other: &BitvSet) -> Ordering {\n+    fn cmp(&self, other: &BitSet) -> Ordering {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::cmp(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::PartialEq for BitvSet {\n+impl cmp::PartialEq for BitSet {\n     #[inline]\n-    fn eq(&self, other: &BitvSet) -> bool {\n+    fn eq(&self, other: &BitSet) -> bool {\n         let (a_iter, b_iter) = match_words(self.get_ref(), other.get_ref());\n         iter::order::eq(a_iter, b_iter)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl cmp::Eq for BitvSet {}\n+impl cmp::Eq for BitSet {}\n \n-impl BitvSet {\n-    /// Creates a new empty `BitvSet`.\n+impl BitSet {\n+    /// Creates a new empty `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BitvSet {\n-        BitvSet { bitv: Bitv::new() }\n+    pub fn new() -> BitSet {\n+        BitSet { bit_vec: BitVec::new() }\n     }\n \n-    /// Creates a new `BitvSet` with initially no contents, able to\n+    /// Creates a new `BitSet` with initially no contents, able to\n     /// hold `nbits` elements without resizing.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::with_capacity(100);\n+    /// let mut s = BitSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(nbits: usize) -> BitvSet {\n-        let bitv = Bitv::from_elem(nbits, false);\n-        BitvSet::from_bitv(bitv)\n+    pub fn with_capacity(nbits: usize) -> BitSet {\n+        let bit_vec = BitVec::from_elem(nbits, false);\n+        BitSet::from_bit_vec(bit_vec)\n     }\n \n-    /// Creates a new `BitvSet` from the given bit vector.\n+    /// Creates a new `BitSet` from the given bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let bv = Bitv::from_bytes(&[0b01100000]);\n-    /// let s = BitvSet::from_bitv(bv);\n+    /// let bv = BitVec::from_bytes(&[0b01100000]);\n+    /// let s = BitSet::from_bit_vec(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n     /// for x in s.iter() {\n     ///     println!(\"{}\", x);\n     /// }\n     /// ```\n     #[inline]\n-    pub fn from_bitv(bitv: Bitv) -> BitvSet {\n-        BitvSet { bitv: bitv }\n+    pub fn from_bit_vec(bit_vec: BitVec) -> BitSet {\n+        BitSet { bit_vec: bit_vec }\n+    }\n+\n+    /// Deprecated: use `from_bit_vec`.\n+    #[inline]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_bit_vec\")]\n+    #[unstable(feature = \"collections\")]\n+    pub fn from_bitv(bit_vec: BitVec) -> BitSet {\n+        BitSet { bit_vec: bit_vec }\n     }\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n@@ -1240,19 +1248,19 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::with_capacity(100);\n+    /// let mut s = BitSet::with_capacity(100);\n     /// assert!(s.capacity() >= 100);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.bitv.capacity()\n+        self.bit_vec.capacity()\n     }\n \n-    /// Reserves capacity for the given `BitvSet` to contain `len` distinct elements. In the case\n-    /// of `BitvSet` this means reallocations will not occur as long as all inserted elements\n+    /// Reserves capacity for the given `BitSet` to contain `len` distinct elements. In the case\n+    /// of `BitSet` this means reallocations will not occur as long as all inserted elements\n     /// are less than `len`.\n     ///\n     /// The collection may reserve more space to avoid frequent reallocations.\n@@ -1261,22 +1269,22 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.reserve_len(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len(&mut self, len: usize) {\n-        let cur_len = self.bitv.len();\n+        let cur_len = self.bit_vec.len();\n         if len >= cur_len {\n-            self.bitv.reserve(len - cur_len);\n+            self.bit_vec.reserve(len - cur_len);\n         }\n     }\n \n-    /// Reserves the minimum capacity for the given `BitvSet` to contain `len` distinct elements.\n-    /// In the case of `BitvSet` this means reallocations will not occur as long as all inserted\n+    /// Reserves the minimum capacity for the given `BitSet` to contain `len` distinct elements.\n+    /// In the case of `BitSet` this means reallocations will not occur as long as all inserted\n     /// elements are less than `len`.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n@@ -1287,17 +1295,17 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.reserve_len_exact(10);\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_len_exact(&mut self, len: usize) {\n-        let cur_len = self.bitv.len();\n+        let cur_len = self.bit_vec.len();\n         if len >= cur_len {\n-            self.bitv.reserve_exact(len - cur_len);\n+            self.bit_vec.reserve_exact(len - cur_len);\n         }\n     }\n \n@@ -1307,64 +1315,64 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(0);\n     /// s.insert(3);\n     ///\n-    /// let bv = s.into_bitv();\n+    /// let bv = s.into_bit_vec();\n     /// assert!(bv[0]);\n     /// assert!(bv[3]);\n     /// ```\n     #[inline]\n-    pub fn into_bitv(self) -> Bitv {\n-        self.bitv\n+    pub fn into_bit_vec(self) -> BitVec {\n+        self.bit_vec\n     }\n \n     /// Returns a reference to the underlying bit vector.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(0);\n     ///\n     /// let bv = s.get_ref();\n     /// assert_eq!(bv[0], true);\n     /// ```\n     #[inline]\n-    pub fn get_ref(&self) -> &Bitv {\n-        &self.bitv\n+    pub fn get_ref(&self) -> &BitVec {\n+        &self.bit_vec\n     }\n \n     #[inline]\n-    fn other_op<F>(&mut self, other: &BitvSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n-        // Unwrap Bitvs\n-        let self_bitv = &mut self.bitv;\n-        let other_bitv = &other.bitv;\n+    fn other_op<F>(&mut self, other: &BitSet, mut f: F) where F: FnMut(u32, u32) -> u32 {\n+        // Unwrap BitVecs\n+        let self_bit_vec = &mut self.bit_vec;\n+        let other_bit_vec = &other.bit_vec;\n \n-        let self_len = self_bitv.len();\n-        let other_len = other_bitv.len();\n+        let self_len = self_bit_vec.len();\n+        let other_len = other_bit_vec.len();\n \n         // Expand the vector if necessary\n         if self_len < other_len {\n-            self_bitv.grow(other_len - self_len, false);\n+            self_bit_vec.grow(other_len - self_len, false);\n         }\n \n         // virtually pad other with 0's for equal lengths\n         let other_words = {\n-            let (_, result) = match_words(self_bitv, other_bitv);\n+            let (_, result) = match_words(self_bit_vec, other_bit_vec);\n             result\n         };\n \n         // Apply values found in other\n         for (i, w) in other_words {\n-            let old = self_bitv.storage[i];\n+            let old = self_bit_vec.storage[i];\n             let new = f(old, w);\n-            self_bitv.storage[i] = new;\n+            self_bit_vec.storage[i] = new;\n         }\n     }\n \n@@ -1373,9 +1381,9 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::BitvSet;\n+    /// use std::collections::BitSet;\n     ///\n-    /// let mut s = BitvSet::new();\n+    /// let mut s = BitSet::new();\n     /// s.insert(32183231);\n     /// s.remove(&32183231);\n     ///\n@@ -1389,25 +1397,25 @@ impl BitvSet {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n-        let bitv = &mut self.bitv;\n+        let bit_vec = &mut self.bit_vec;\n         // Obtain original length\n-        let old_len = bitv.storage.len();\n+        let old_len = bit_vec.storage.len();\n         // Obtain coarse trailing zero length\n-        let n = bitv.storage.iter().rev().take_while(|&&n| n == 0).count();\n+        let n = bit_vec.storage.iter().rev().take_while(|&&n| n == 0).count();\n         // Truncate\n         let trunc_len = cmp::max(old_len - n, 1);\n-        bitv.storage.truncate(trunc_len);\n-        bitv.nbits = trunc_len * u32::BITS;\n+        bit_vec.storage.truncate(trunc_len);\n+        bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n-    /// Iterator over each u32 stored in the `BitvSet`.\n+    /// Iterator over each u32 stored in the `BitSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let s = BitvSet::from_bitv(Bitv::from_bytes(&[0b01001010]));\n+    /// let s = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1416,7 +1424,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> bitv_set::Iter {\n+    pub fn iter(&self) -> bit_set::Iter {\n         SetIter {set: self, next_idx: 0}\n     }\n \n@@ -1426,10 +1434,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1438,7 +1446,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BitvSet) -> Union<'a> {\n+    pub fn union<'a>(&'a self, other: &'a BitSet) -> Union<'a> {\n         fn or(w1: u32, w2: u32) -> u32 { w1 | w2 }\n \n         Union(TwoBitPositions {\n@@ -1456,10 +1464,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{Bitv, BitvSet};\n+    /// use std::collections::{BitVec, BitSet};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1468,9 +1476,9 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BitvSet) -> Intersection<'a> {\n+    pub fn intersection<'a>(&'a self, other: &'a BitSet) -> Intersection<'a> {\n         fn bitand(w1: u32, w2: u32) -> u32 { w1 & w2 }\n-        let min = cmp::min(self.bitv.len(), other.bitv.len());\n+        let min = cmp::min(self.bit_vec.len(), other.bit_vec.len());\n         Intersection(TwoBitPositions {\n             set: self,\n             other: other,\n@@ -1486,10 +1494,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 1, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1505,7 +1513,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BitvSet) -> Difference<'a> {\n+    pub fn difference<'a>(&'a self, other: &'a BitSet) -> Difference<'a> {\n         fn diff(w1: u32, w2: u32) -> u32 { w1 & !w2 }\n \n         Difference(TwoBitPositions {\n@@ -1524,10 +1532,10 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n-    /// let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101000]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100000]));\n+    /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1536,7 +1544,7 @@ impl BitvSet {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a BitvSet) -> SymmetricDifference<'a> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BitSet) -> SymmetricDifference<'a> {\n         fn bitxor(w1: u32, w2: u32) -> u32 { w1 ^ w2 }\n \n         SymmetricDifference(TwoBitPositions {\n@@ -1553,21 +1561,21 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11101000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.union_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn union_with(&mut self, other: &BitvSet) {\n+    pub fn union_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 | w2);\n     }\n \n@@ -1576,21 +1584,21 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b00100000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.intersect_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn intersect_with(&mut self, other: &BitvSet) {\n+    pub fn intersect_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 & w2);\n     }\n \n@@ -1600,29 +1608,29 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let a_b = 0b01001000; // a - b\n     /// let b_a = 0b10000000; // b - a\n     ///\n-    /// let mut bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let bva_b = BitvSet::from_bitv(Bitv::from_bytes(&[a_b]));\n-    /// let bvb_a = BitvSet::from_bitv(Bitv::from_bytes(&[b_a]));\n+    /// let mut bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let bva_b = BitSet::from_bit_vec(BitVec::from_bytes(&[a_b]));\n+    /// let bvb_a = BitSet::from_bit_vec(BitVec::from_bytes(&[b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n     /// assert_eq!(bva, bva_b);\n     ///\n-    /// let bva = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let mut bvb = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n+    /// let bva = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let mut bvb = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n     ///\n     /// bvb.difference_with(&bva);\n     /// assert_eq!(bvb, bvb_a);\n     /// ```\n     #[inline]\n-    pub fn difference_with(&mut self, other: &BitvSet) {\n+    pub fn difference_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 & !w2);\n     }\n \n@@ -1632,79 +1640,79 @@ impl BitvSet {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::{BitvSet, Bitv};\n+    /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n     /// let b   = 0b10100000;\n     /// let res = 0b11001000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[a]));\n-    /// let b = BitvSet::from_bitv(Bitv::from_bytes(&[b]));\n-    /// let res = BitvSet::from_bitv(Bitv::from_bytes(&[res]));\n+    /// let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[a]));\n+    /// let b = BitSet::from_bit_vec(BitVec::from_bytes(&[b]));\n+    /// let res = BitSet::from_bit_vec(BitVec::from_bytes(&[res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n     /// assert_eq!(a, res);\n     /// ```\n     #[inline]\n-    pub fn symmetric_difference_with(&mut self, other: &BitvSet) {\n+    pub fn symmetric_difference_with(&mut self, other: &BitSet) {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n     /// Return the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize  {\n-        self.bitv.blocks().fold(0, |acc, n| acc + n.count_ones())\n+        self.bit_vec.blocks().fold(0, |acc, n| acc + n.count_ones())\n     }\n \n     /// Returns whether there are no bits set in this set\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.bitv.none()\n+        self.bit_vec.none()\n     }\n \n     /// Clears all bits in this set\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        self.bitv.clear();\n+        self.bit_vec.clear();\n     }\n \n     /// Returns `true` if this set contains the specified integer.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains(&self, value: &usize) -> bool {\n-        let bitv = &self.bitv;\n-        *value < bitv.nbits && bitv[*value]\n+        let bit_vec = &self.bit_vec;\n+        *value < bit_vec.nbits && bit_vec[*value]\n     }\n \n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BitvSet) -> bool {\n+    pub fn is_disjoint(&self, other: &BitSet) -> bool {\n         self.intersection(other).next().is_none()\n     }\n \n     /// Returns `true` if the set is a subset of another.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BitvSet) -> bool {\n-        let self_bitv = &self.bitv;\n-        let other_bitv = &other.bitv;\n-        let other_blocks = blocks_for_bits(other_bitv.len());\n+    pub fn is_subset(&self, other: &BitSet) -> bool {\n+        let self_bit_vec = &self.bit_vec;\n+        let other_bit_vec = &other.bit_vec;\n+        let other_blocks = blocks_for_bits(other_bit_vec.len());\n \n         // Check that `self` intersect `other` is self\n-        self_bitv.blocks().zip(other_bitv.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n+        self_bit_vec.blocks().zip(other_bit_vec.blocks()).all(|(w1, w2)| w1 & w2 == w1) &&\n         // Make sure if `self` has any more blocks than `other`, they're all 0\n-        self_bitv.blocks().skip(other_blocks).all(|w| w == 0)\n+        self_bit_vec.blocks().skip(other_blocks).all(|w| w == 0)\n     }\n \n     /// Returns `true` if the set is a superset of another.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BitvSet) -> bool {\n+    pub fn is_superset(&self, other: &BitSet) -> bool {\n         other.is_subset(self)\n     }\n \n@@ -1717,12 +1725,12 @@ impl BitvSet {\n         }\n \n         // Ensure we have enough space to hold the new element\n-        let len = self.bitv.len();\n+        let len = self.bit_vec.len();\n         if value >= len {\n-            self.bitv.grow(value - len + 1, false)\n+            self.bit_vec.grow(value - len + 1, false)\n         }\n \n-        self.bitv.set(value, true);\n+        self.bit_vec.set(value, true);\n         return true;\n     }\n \n@@ -1734,16 +1742,16 @@ impl BitvSet {\n             return false;\n         }\n \n-        self.bitv.set(*value, false);\n+        self.bit_vec.set(*value, false);\n \n         return true;\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for BitvSet {\n+impl fmt::Debug for BitSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"BitvSet {{\"));\n+        try!(write!(fmt, \"BitSet {{\"));\n         let mut first = true;\n         for n in self {\n             if !first {\n@@ -1756,27 +1764,27 @@ impl fmt::Debug for BitvSet {\n     }\n }\n \n-impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitSet {\n     fn hash(&self, state: &mut S) {\n         for pos in self {\n             pos.hash(state);\n         }\n     }\n }\n \n-/// An iterator for `BitvSet`.\n+/// An iterator for `BitSet`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SetIter<'a> {\n-    set: &'a BitvSet,\n+    set: &'a BitSet,\n     next_idx: usize\n }\n \n-/// An iterator combining two `BitvSet` iterators.\n+/// An iterator combining two `BitSet` iterators.\n #[derive(Clone)]\n struct TwoBitPositions<'a> {\n-    set: &'a BitvSet,\n-    other: &'a BitvSet,\n+    set: &'a BitSet,\n+    other: &'a BitSet,\n     merge: fn(u32, u32) -> u32,\n     current_word: u32,\n     next_idx: usize\n@@ -1796,7 +1804,7 @@ impl<'a> Iterator for SetIter<'a> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bitv.len() {\n+        while self.next_idx < self.set.bit_vec.len() {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n \n@@ -1810,7 +1818,7 @@ impl<'a> Iterator for SetIter<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.set.bitv.len() - self.next_idx))\n+        (0, Some(self.set.bit_vec.len() - self.next_idx))\n     }\n }\n \n@@ -1819,20 +1827,20 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n     type Item = usize;\n \n     fn next(&mut self) -> Option<usize> {\n-        while self.next_idx < self.set.bitv.len() ||\n-              self.next_idx < self.other.bitv.len() {\n+        while self.next_idx < self.set.bit_vec.len() ||\n+              self.next_idx < self.other.bit_vec.len() {\n             let bit_idx = self.next_idx % u32::BITS;\n             if bit_idx == 0 {\n-                let s_bitv = &self.set.bitv;\n-                let o_bitv = &self.other.bitv;\n+                let s_bit_vec = &self.set.bit_vec;\n+                let o_bit_vec = &self.other.bit_vec;\n                 // Merging the two words is a bit of an awkward dance since\n-                // one Bitv might be longer than the other\n+                // one BitVec might be longer than the other\n                 let word_idx = self.next_idx / u32::BITS;\n-                let w1 = if word_idx < s_bitv.storage.len() {\n-                             s_bitv.storage[word_idx]\n+                let w1 = if word_idx < s_bit_vec.storage.len() {\n+                             s_bit_vec.storage[word_idx]\n                          } else { 0 };\n-                let w2 = if word_idx < o_bitv.storage.len() {\n-                             o_bitv.storage[word_idx]\n+                let w2 = if word_idx < o_bit_vec.storage.len() {\n+                             o_bit_vec.storage[word_idx]\n                          } else { 0 };\n                 self.current_word = (self.merge)(w1, w2);\n             }\n@@ -1847,7 +1855,7 @@ impl<'a> Iterator for TwoBitPositions<'a> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let cap = cmp::max(self.set.bitv.len(), self.other.bitv.len());\n+        let cap = cmp::max(self.set.bit_vec.len(), self.other.bit_vec.len());\n         (0, Some(cap - self.next_idx))\n     }\n }\n@@ -1885,7 +1893,7 @@ impl<'a> Iterator for SymmetricDifference<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> IntoIterator for &'a BitvSet {\n+impl<'a> IntoIterator for &'a BitSet {\n     type Item = usize;\n     type IntoIter = SetIter<'a>;\n \n@@ -1899,38 +1907,38 @@ mod tests {\n     use prelude::*;\n     use core::u32;\n \n-    use super::Bitv;\n+    use super::BitVec;\n \n     #[test]\n     fn test_to_str() {\n-        let zerolen = Bitv::new();\n+        let zerolen = BitVec::new();\n         assert_eq!(format!(\"{:?}\", zerolen), \"\");\n \n-        let eightbits = Bitv::from_elem(8, false);\n+        let eightbits = BitVec::from_elem(8, false);\n         assert_eq!(format!(\"{:?}\", eightbits), \"00000000\")\n     }\n \n     #[test]\n     fn test_0_elements() {\n-        let act = Bitv::new();\n+        let act = BitVec::new();\n         let exp = Vec::new();\n         assert!(act.eq_vec(&exp));\n         assert!(act.none() && act.all());\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act = Bitv::from_elem(1, false);\n+        let mut act = BitVec::from_elem(1, false);\n         assert!(act.eq_vec(&[false]));\n         assert!(act.none() && !act.all());\n-        act = Bitv::from_elem(1, true);\n+        act = BitVec::from_elem(1, true);\n         assert!(act.eq_vec(&[true]));\n         assert!(!act.none() && act.all());\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let mut b = Bitv::from_elem(2, false);\n+        let mut b = BitVec::from_elem(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert_eq!(format!(\"{:?}\", b), \"10\");\n@@ -1942,18 +1950,18 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         assert!((act.eq_vec(\n                     &[false, false, false, false, false, false, false, false, false, false])));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(10, true);\n+        act = BitVec::from_elem(10, true);\n         assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -1963,7 +1971,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(5, true);\n         act.set(6, true);\n         act.set(7, true);\n@@ -1973,7 +1981,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(10, false);\n+        act = BitVec::from_elem(10, false);\n         act.set(0, true);\n         act.set(3, true);\n         act.set(6, true);\n@@ -1987,23 +1995,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(31, true);\n+        act = BitVec::from_elem(31, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2019,7 +2027,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2035,7 +2043,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2050,7 +2058,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(31, false);\n+        act = BitVec::from_elem(31, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2066,23 +2074,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(32, true);\n+        act = BitVec::from_elem(32, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2098,7 +2106,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2114,7 +2122,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2130,7 +2138,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(32, false);\n+        act = BitVec::from_elem(32, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2147,23 +2155,23 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         assert!(act.eq_vec(\n                 &[false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false,\n                   false, false, false, false, false, false, false, false, false, false, false]));\n         assert!(act.none() && !act.all());\n         // all 1\n \n-        act = Bitv::from_elem(33, true);\n+        act = BitVec::from_elem(33, true);\n         assert!(act.eq_vec(\n                 &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true, true, true, true, true, true, true,\n                   true, true, true, true, true, true, true]));\n         assert!(!act.none() && act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(0, true);\n         act.set(1, true);\n         act.set(2, true);\n@@ -2179,7 +2187,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(16, true);\n         act.set(17, true);\n         act.set(18, true);\n@@ -2195,7 +2203,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(24, true);\n         act.set(25, true);\n         act.set(26, true);\n@@ -2211,7 +2219,7 @@ mod tests {\n         assert!(!act.none() && !act.all());\n         // mixed\n \n-        act = Bitv::from_elem(33, false);\n+        act = BitVec::from_elem(33, false);\n         act.set(3, true);\n         act.set(17, true);\n         act.set(30, true);\n@@ -2226,37 +2234,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = Bitv::from_elem(10, false);\n-        let v1 = Bitv::from_elem(11, false);\n+        let v0 = BitVec::from_elem(10, false);\n+        let v1 = BitVec::from_elem(11, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv::from_elem(10, false);\n-        let v1 = Bitv::from_elem(110, false);\n+        let v0 = BitVec::from_elem(10, false);\n+        let v1 = BitVec::from_elem(110, false);\n         assert!(v0 != v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let mut a = Bitv::from_elem(1, false);\n+        let mut a = BitVec::from_elem(1, false);\n         a.set(0, true);\n \n-        let mut b = Bitv::from_elem(1, true);\n+        let mut b = BitVec::from_elem(1, true);\n         b.set(0, true);\n \n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let mut a = Bitv::from_elem(100, false);\n+        let mut a = BitVec::from_elem(100, false);\n         for i in 0..100 {\n             a.set(i, true);\n         }\n \n-        let mut b = Bitv::from_elem(100, true);\n+        let mut b = BitVec::from_elem(100, true);\n         for i in 0..100 {\n             b.set(i, true);\n         }\n@@ -2266,18 +2274,18 @@ mod tests {\n \n     #[test]\n     fn test_from_bytes() {\n-        let bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = concat!(\"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(format!(\"{:?}\", bitv), str);\n+        assert_eq!(format!(\"{:?}\", bit_vec), str);\n     }\n \n     #[test]\n     fn test_to_bytes() {\n-        let mut bv = Bitv::from_elem(3, true);\n+        let mut bv = BitVec::from_elem(3, true);\n         bv.set(1, false);\n         assert_eq!(bv.to_bytes(), vec!(0b10100000));\n \n-        let mut bv = Bitv::from_elem(9, false);\n+        let mut bv = BitVec::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n@@ -2286,32 +2294,32 @@ mod tests {\n     #[test]\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n-        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n-        assert_eq!(format!(\"{:?}\", bitv), \"1011\");\n+        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n+        assert_eq!(format!(\"{:?}\", bit_vec), \"1011\");\n     }\n \n     #[test]\n     fn test_to_bools() {\n         let bools = vec![false, false, true, false, false, true, true, false];\n-        assert_eq!(Bitv::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(BitVec::from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n-    fn test_bitv_iterator() {\n+    fn test_bit_vec_iterator() {\n         let bools = vec![true, false, true, true];\n-        let bitv: Bitv = bools.iter().map(|n| *n).collect();\n+        let bit_vec: BitVec = bools.iter().map(|n| *n).collect();\n \n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), bools);\n \n         let long: Vec<_> = (0i32..10000).map(|i| i % 2 == 0).collect();\n-        let bitv: Bitv = long.iter().map(|n| *n).collect();\n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n+        let bit_vec: BitVec = long.iter().map(|n| *n).collect();\n+        assert_eq!(bit_vec.iter().collect::<Vec<bool>>(), long)\n     }\n \n     #[test]\n     fn test_small_difference() {\n-        let mut b1 = Bitv::from_elem(3, false);\n-        let mut b2 = Bitv::from_elem(3, false);\n+        let mut b1 = BitVec::from_elem(3, false);\n+        let mut b2 = BitVec::from_elem(3, false);\n         b1.set(0, true);\n         b1.set(1, true);\n         b2.set(1, true);\n@@ -2324,8 +2332,8 @@ mod tests {\n \n     #[test]\n     fn test_big_difference() {\n-        let mut b1 = Bitv::from_elem(100, false);\n-        let mut b2 = Bitv::from_elem(100, false);\n+        let mut b1 = BitVec::from_elem(100, false);\n+        let mut b2 = BitVec::from_elem(100, false);\n         b1.set(0, true);\n         b1.set(40, true);\n         b2.set(40, true);\n@@ -2338,24 +2346,24 @@ mod tests {\n \n     #[test]\n     fn test_small_clear() {\n-        let mut b = Bitv::from_elem(14, true);\n+        let mut b = BitVec::from_elem(14, true);\n         assert!(!b.none() && b.all());\n         b.clear();\n         assert!(b.none() && !b.all());\n     }\n \n     #[test]\n     fn test_big_clear() {\n-        let mut b = Bitv::from_elem(140, true);\n+        let mut b = BitVec::from_elem(140, true);\n         assert!(!b.none() && b.all());\n         b.clear();\n         assert!(b.none() && !b.all());\n     }\n \n     #[test]\n-    fn test_bitv_lt() {\n-        let mut a = Bitv::from_elem(5, false);\n-        let mut b = Bitv::from_elem(5, false);\n+    fn test_bit_vec_lt() {\n+        let mut a = BitVec::from_elem(5, false);\n+        let mut b = BitVec::from_elem(5, false);\n \n         assert!(!(a < b) && !(b < a));\n         b.set(2, true);\n@@ -2370,8 +2378,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let mut a = Bitv::from_elem(5, false);\n-        let mut b = Bitv::from_elem(5, false);\n+        let mut a = BitVec::from_elem(5, false);\n+        let mut b = BitVec::from_elem(5, false);\n \n         assert!(a <= b && a >= b);\n         a.set(1, true);\n@@ -2385,42 +2393,42 @@ mod tests {\n \n \n     #[test]\n-    fn test_small_bitv_tests() {\n-        let v = Bitv::from_bytes(&[0]);\n+    fn test_small_bit_vec_tests() {\n+        let v = BitVec::from_bytes(&[0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = Bitv::from_bytes(&[0b00010100]);\n+        let v = BitVec::from_bytes(&[0b00010100]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = Bitv::from_bytes(&[0xFF]);\n+        let v = BitVec::from_bytes(&[0xFF]);\n         assert!(v.all());\n         assert!(v.any());\n         assert!(!v.none());\n     }\n \n     #[test]\n-    fn test_big_bitv_tests() {\n-        let v = Bitv::from_bytes(&[ // 88 bits\n+    fn test_big_bit_vec_tests() {\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0, 0, 0, 0,\n             0, 0, 0, 0,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = Bitv::from_bytes(&[ // 88 bits\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0, 0, 0b00010100, 0,\n             0, 0, 0, 0b00110100,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = Bitv::from_bytes(&[ // 88 bits\n+        let v = BitVec::from_bytes(&[ // 88 bits\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF]);\n@@ -2430,8 +2438,8 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_push_pop() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS - 2, false);\n+    fn test_bit_vec_push_pop() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS - 2, false);\n         assert_eq!(s.len(), 5 * u32::BITS - 2);\n         assert_eq!(s[5 * u32::BITS - 3], false);\n         s.push(true);\n@@ -2453,29 +2461,29 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_truncate() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+    fn test_bit_vec_truncate() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n \n-        assert_eq!(s, Bitv::from_elem(5 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(5 * u32::BITS, true));\n         assert_eq!(s.len(), 5 * u32::BITS);\n         s.truncate(4 * u32::BITS);\n-        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n         assert_eq!(s.len(), 4 * u32::BITS);\n         // Truncating to a size > s.len() should be a noop\n         s.truncate(5 * u32::BITS);\n-        assert_eq!(s, Bitv::from_elem(4 * u32::BITS, true));\n+        assert_eq!(s, BitVec::from_elem(4 * u32::BITS, true));\n         assert_eq!(s.len(), 4 * u32::BITS);\n         s.truncate(3 * u32::BITS - 10);\n-        assert_eq!(s, Bitv::from_elem(3 * u32::BITS - 10, true));\n+        assert_eq!(s, BitVec::from_elem(3 * u32::BITS - 10, true));\n         assert_eq!(s.len(), 3 * u32::BITS - 10);\n         s.truncate(0);\n-        assert_eq!(s, Bitv::from_elem(0, true));\n+        assert_eq!(s, BitVec::from_elem(0, true));\n         assert_eq!(s.len(), 0);\n     }\n \n     #[test]\n-    fn test_bitv_reserve() {\n-        let mut s = Bitv::from_elem(5 * u32::BITS, true);\n+    fn test_bit_vec_reserve() {\n+        let mut s = BitVec::from_elem(5 * u32::BITS, true);\n         // Check capacity\n         assert!(s.capacity() >= 5 * u32::BITS);\n         s.reserve(2 * u32::BITS);\n@@ -2498,25 +2506,25 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitv_grow() {\n-        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n-        bitv.grow(32, true);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+    fn test_bit_vec_grow() {\n+        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n+        bit_vec.grow(32, true);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF]));\n-        bitv.grow(64, false);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+        bit_vec.grow(64, false);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n-        bitv.grow(16, true);\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n+        bit_vec.grow(16, true);\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n     }\n \n     #[test]\n-    fn test_bitv_extend() {\n-        let mut bitv = Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n-        let ext = Bitv::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n-        bitv.extend(ext.iter());\n-        assert_eq!(bitv, Bitv::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n+    fn test_bit_vec_extend() {\n+        let mut bit_vec = BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let ext = BitVec::from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n+        bit_vec.extend(ext.iter());\n+        assert_eq!(bit_vec, BitVec::from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n                                      0b01001001, 0b10010010, 0b10111101]));\n     }\n }\n@@ -2525,14 +2533,14 @@ mod tests {\n \n \n #[cfg(test)]\n-mod bitv_bench {\n+mod bit_vec_bench {\n     use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n     use test::{Bencher, black_box};\n \n-    use super::Bitv;\n+    use super::BitVec;\n \n     static BENCH_BITS : usize = 1 << 14;\n \n@@ -2544,67 +2552,67 @@ mod bitv_bench {\n     #[bench]\n     fn bench_usize_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = 0 as usize;\n+        let mut bit_vec = 0 as usize;\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv |= 1 << ((r.next_u32() as usize) % u32::BITS);\n+                bit_vec |= 1 << ((r.next_u32() as usize) % u32::BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_big_fixed(b: &mut Bencher) {\n+    fn bench_bit_set_big_fixed(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % BENCH_BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, true);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_big_variable(b: &mut Bencher) {\n+    fn bench_bit_set_big_variable(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n+        let mut bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n+                bit_vec.set((r.next_u32() as usize) % BENCH_BITS, r.gen());\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_set_small(b: &mut Bencher) {\n+    fn bench_bit_set_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = Bitv::from_elem(u32::BITS, false);\n+        let mut bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.set((r.next_u32() as usize) % u32::BITS, true);\n+                bit_vec.set((r.next_u32() as usize) % u32::BITS, true);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitv_big_union(b: &mut Bencher) {\n-        let mut b1 = Bitv::from_elem(BENCH_BITS, false);\n-        let b2 = Bitv::from_elem(BENCH_BITS, false);\n+    fn bench_bit_vec_big_union(b: &mut Bencher) {\n+        let mut b1 = BitVec::from_elem(BENCH_BITS, false);\n+        let b2 = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             b1.union(&b2)\n         })\n     }\n \n     #[bench]\n-    fn bench_bitv_small_iter(b: &mut Bencher) {\n-        let bitv = Bitv::from_elem(u32::BITS, false);\n+    fn bench_bit_vec_small_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(u32::BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n             for _ in 0..10 {\n-                for pres in &bitv {\n+                for pres in &bit_vec {\n                     sum += pres as usize;\n                 }\n             }\n@@ -2613,11 +2621,11 @@ mod bitv_bench {\n     }\n \n     #[bench]\n-    fn bench_bitv_big_iter(b: &mut Bencher) {\n-        let bitv = Bitv::from_elem(BENCH_BITS, false);\n+    fn bench_bit_vec_big_iter(b: &mut Bencher) {\n+        let bit_vec = BitVec::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n             let mut sum = 0;\n-            for pres in &bitv {\n+            for pres in &bit_vec {\n                 sum += pres as usize;\n             }\n             sum\n@@ -2632,55 +2640,55 @@ mod bitv_bench {\n \n \n #[cfg(test)]\n-mod bitv_set_test {\n+mod bit_set_test {\n     use prelude::*;\n     use std::iter::range_step;\n \n-    use super::{Bitv, BitvSet};\n+    use super::{BitVec, BitSet};\n \n     #[test]\n-    fn test_bitv_set_show() {\n-        let mut s = BitvSet::new();\n+    fn test_bit_set_show() {\n+        let mut s = BitSet::new();\n         s.insert(1);\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"BitvSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n+        assert_eq!(\"BitSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n     }\n \n     #[test]\n-    fn test_bitv_set_from_usizes() {\n+    fn test_bit_set_from_usizes() {\n         let usizes = vec![0, 2, 2, 3];\n-        let a: BitvSet = usizes.into_iter().collect();\n-        let mut b = BitvSet::new();\n+        let a: BitSet = usizes.into_iter().collect();\n+        let mut b = BitSet::new();\n         b.insert(0);\n         b.insert(2);\n         b.insert(3);\n         assert_eq!(a, b);\n     }\n \n     #[test]\n-    fn test_bitv_set_iterator() {\n+    fn test_bit_set_iterator() {\n         let usizes = vec![0, 2, 2, 3];\n-        let bitv: BitvSet = usizes.into_iter().collect();\n+        let bit_vec: BitSet = usizes.into_iter().collect();\n \n-        let idxs: Vec<_> = bitv.iter().collect();\n+        let idxs: Vec<_> = bit_vec.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n+        let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n         let real: Vec<_> = range_step(0, 10000, 2).collect();\n \n         let idxs: Vec<_> = long.iter().collect();\n         assert_eq!(idxs, real);\n     }\n \n     #[test]\n-    fn test_bitv_set_frombitv_init() {\n+    fn test_bit_set_frombit_vec_init() {\n         let bools = [true, false];\n         let lengths = [10, 64, 100];\n         for &b in &bools {\n             for &l in &lengths {\n-                let bitset = BitvSet::from_bitv(Bitv::from_elem(l, b));\n+                let bitset = BitSet::from_bit_vec(BitVec::from_elem(l, b));\n                 assert_eq!(bitset.contains(&1), b);\n                 assert_eq!(bitset.contains(&(l-1)), b);\n                 assert!(!bitset.contains(&l));\n@@ -2689,9 +2697,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_masking() {\n-        let b = Bitv::from_elem(140, true);\n-        let mut bs = BitvSet::from_bitv(b);\n+    fn test_bit_vec_masking() {\n+        let b = BitVec::from_elem(140, true);\n+        let mut bs = BitSet::from_bit_vec(b);\n         assert!(bs.contains(&139));\n         assert!(!bs.contains(&140));\n         assert!(bs.insert(150));\n@@ -2702,8 +2710,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_basic() {\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_basic() {\n+        let mut b = BitSet::new();\n         assert!(b.insert(3));\n         assert!(!b.insert(3));\n         assert!(b.contains(&3));\n@@ -2717,9 +2725,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_intersection() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_intersection() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(11));\n         assert!(a.insert(1));\n@@ -2740,9 +2748,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_difference() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_difference() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -2759,9 +2767,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_symmetric_difference() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_symmetric_difference() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n@@ -2780,9 +2788,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_union() {\n-        let mut a = BitvSet::new();\n-        let mut b = BitvSet::new();\n+    fn test_bit_set_union() {\n+        let mut a = BitSet::new();\n+        let mut b = BitSet::new();\n         assert!(a.insert(1));\n         assert!(a.insert(3));\n         assert!(a.insert(5));\n@@ -2805,9 +2813,9 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_subset() {\n-        let mut set1 = BitvSet::new();\n-        let mut set2 = BitvSet::new();\n+    fn test_bit_set_subset() {\n+        let mut set1 = BitSet::new();\n+        let mut set2 = BitSet::new();\n \n         assert!(set1.is_subset(&set2)); //  {}  {}\n         set2.insert(100);\n@@ -2831,11 +2839,11 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_is_disjoint() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01000000]));\n-        let c = BitvSet::new();\n-        let d = BitvSet::from_bitv(Bitv::from_bytes(&[0b00110000]));\n+    fn test_bit_set_is_disjoint() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01000000]));\n+        let c = BitSet::new();\n+        let d = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00110000]));\n \n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n@@ -2849,19 +2857,19 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_union_with() {\n+    fn test_bit_set_union_with() {\n         //a should grow to include larger elements\n-        let mut a = BitvSet::new();\n+        let mut a = BitSet::new();\n         a.insert(0);\n-        let mut b = BitvSet::new();\n+        let mut b = BitSet::new();\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n+        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n         a.union_with(&b);\n         assert_eq!(a, expected);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.union_with(&b);\n         b.union_with(&c);\n@@ -2870,28 +2878,28 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_intersect_with() {\n+    fn test_bit_set_intersect_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::new();\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::new();\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n@@ -2900,22 +2908,22 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_difference_with() {\n+    fn test_bit_set_difference_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::new();\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b11111111]));\n+        let mut a = BitSet::new();\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11111111]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01100010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.difference_with(&b);\n         b.difference_with(&c);\n@@ -2924,27 +2932,27 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_symmetric_difference_with() {\n+    fn test_bit_set_symmetric_difference_with() {\n         //a should grow to include larger elements\n-        let mut a = BitvSet::new();\n+        let mut a = BitSet::new();\n         a.insert(0);\n         a.insert(1);\n-        let mut b = BitvSet::new();\n+        let mut b = BitSet::new();\n         b.insert(1);\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(Bitv::from_bytes(&[0b10000100]));\n+        let expected = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10000100]));\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, expected);\n \n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::new();\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::new();\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, c);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(Bitv::from_bytes(&[0b11100010]));\n-        let mut b = BitvSet::from_bitv(Bitv::from_bytes(&[0b01101010]));\n+        let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b11100010]));\n+        let mut b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101010]));\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         b.symmetric_difference_with(&c);\n@@ -2953,10 +2961,10 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_eq() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let c = BitvSet::new();\n+    fn test_bit_set_eq() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let c = BitSet::new();\n \n         assert!(a == a);\n         assert!(a != b);\n@@ -2967,10 +2975,10 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_set_cmp() {\n-        let a = BitvSet::from_bitv(Bitv::from_bytes(&[0b10100010]));\n-        let b = BitvSet::from_bitv(Bitv::from_bytes(&[0b00000000]));\n-        let c = BitvSet::new();\n+    fn test_bit_set_cmp() {\n+        let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100010]));\n+        let b = BitSet::from_bit_vec(BitVec::from_bytes(&[0b00000000]));\n+        let c = BitSet::new();\n \n         assert_eq!(a.cmp(&b), Greater);\n         assert_eq!(a.cmp(&c), Greater);\n@@ -2981,8 +2989,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_remove() {\n-        let mut a = BitvSet::new();\n+    fn test_bit_vec_remove() {\n+        let mut a = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.remove(&1));\n@@ -2996,8 +3004,8 @@ mod bitv_set_test {\n     }\n \n     #[test]\n-    fn test_bitv_clone() {\n-        let mut a = BitvSet::new();\n+    fn test_bit_vec_clone() {\n+        let mut a = BitSet::new();\n \n         assert!(a.insert(1));\n         assert!(a.insert(100));\n@@ -3020,14 +3028,14 @@ mod bitv_set_test {\n \n \n #[cfg(test)]\n-mod bitv_set_bench {\n+mod bit_set_bench {\n     use std::prelude::v1::*;\n     use std::rand;\n     use std::rand::Rng;\n     use std::u32;\n     use test::{Bencher, black_box};\n \n-    use super::{Bitv, BitvSet};\n+    use super::{BitVec, BitSet};\n \n     static BENCH_BITS : usize = 1 << 14;\n \n@@ -3037,36 +3045,36 @@ mod bitv_set_bench {\n     }\n \n     #[bench]\n-    fn bench_bitvset_small(b: &mut Bencher) {\n+    fn bench_bit_vecset_small(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = BitvSet::new();\n+        let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.insert((r.next_u32() as usize) % u32::BITS);\n+                bit_vec.insert((r.next_u32() as usize) % u32::BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitvset_big(b: &mut Bencher) {\n+    fn bench_bit_vecset_big(b: &mut Bencher) {\n         let mut r = rng();\n-        let mut bitv = BitvSet::new();\n+        let mut bit_vec = BitSet::new();\n         b.iter(|| {\n             for _ in 0..100 {\n-                bitv.insert((r.next_u32() as usize) % BENCH_BITS);\n+                bit_vec.insert((r.next_u32() as usize) % BENCH_BITS);\n             }\n-            black_box(&bitv);\n+            black_box(&bit_vec);\n         });\n     }\n \n     #[bench]\n-    fn bench_bitvset_iter(b: &mut Bencher) {\n-        let bitv = BitvSet::from_bitv(Bitv::from_fn(BENCH_BITS,\n+    fn bench_bit_vecset_iter(b: &mut Bencher) {\n+        let bit_vec = BitSet::from_bit_vec(BitVec::from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n         b.iter(|| {\n             let mut sum = 0;\n-            for idx in &bitv {\n+            for idx in &bit_vec {\n                 sum += idx as usize;\n             }\n             sum"}, {"sha": "96052156df03e75236941b593c535e0e0e813119", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -29,7 +29,7 @@ use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n use Bound::{self, Included, Excluded, Unbounded};\n \n-use ring_buf::RingBuf;\n+use vec_deque::VecDeque;\n \n use self::Continuation::{Continue, Finished};\n use self::StackOp::*;\n@@ -75,7 +75,7 @@ pub struct BTreeMap<K, V> {\n \n /// An abstract base over-which all other BTree iterators are built.\n struct AbsIter<T> {\n-    traversals: RingBuf<T>,\n+    traversals: VecDeque<T>,\n     size: usize,\n }\n \n@@ -1189,7 +1189,7 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n         // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(&self.root));\n         Iter {\n             inner: AbsIter {\n@@ -1221,7 +1221,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(&mut self.root));\n         IterMut {\n             inner: AbsIter {\n@@ -1250,7 +1250,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n-        let mut lca = RingBuf::new();\n+        let mut lca = VecDeque::new();\n         lca.push_back(Traverse::traverse(self.root));\n         IntoIter {\n             inner: AbsIter {\n@@ -1342,7 +1342,7 @@ macro_rules! range_impl {\n             // A deque that encodes two search paths containing (left-to-right):\n             // a series of truncated-from-the-left iterators, the LCA's doubly-truncated iterator,\n             // and a series of truncated-from-the-right iterators.\n-            let mut traversals = RingBuf::new();\n+            let mut traversals = VecDeque::new();\n             let (root, min, max) = ($root, $min, $max);\n \n             let mut leftmost = None;"}, {"sha": "b9f50fc385b5377f31e2a9dc29d10927b9fca0ff", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -49,17 +49,33 @@ extern crate alloc;\n #[cfg(test)] #[macro_use] extern crate log;\n \n pub use binary_heap::BinaryHeap;\n-pub use bitv::Bitv;\n-pub use bitv_set::BitvSet;\n+pub use bit_vec::BitVec;\n+pub use bit_set::BitSet;\n pub use btree_map::BTreeMap;\n pub use btree_set::BTreeSet;\n-pub use dlist::DList;\n+pub use linked_list::LinkedList;\n pub use enum_set::EnumSet;\n-pub use ring_buf::RingBuf;\n+pub use vec_deque::VecDeque;\n pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to vec_deque\")]\n+#[unstable(feature = \"collections\")]\n+pub use vec_deque as ring_buf;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to linked_list\")]\n+#[unstable(feature = \"collections\")]\n+pub use linked_list as dlist;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_vec\")]\n+#[unstable(feature = \"collections\")]\n+pub use bit_vec as bitv;\n+\n+#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_set\")]\n+#[unstable(feature = \"collections\")]\n+pub use bit_set as bitv_set;\n+\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n@@ -71,10 +87,10 @@ mod macros;\n pub mod binary_heap;\n mod bit;\n mod btree;\n-pub mod dlist;\n+pub mod linked_list;\n pub mod enum_set;\n pub mod fmt;\n-pub mod ring_buf;\n+pub mod vec_deque;\n pub mod slice;\n pub mod str;\n pub mod string;\n@@ -83,15 +99,23 @@ pub mod vec_map;\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub mod bitv {\n-    pub use bit::{Bitv, Iter};\n+pub mod bit_vec {\n+    pub use bit::{BitVec, Iter};\n+\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitVec\")]\n+    #[unstable(feature = \"collections\")]\n+    pub use bit::BitVec as Bitv;\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n-pub mod bitv_set {\n-    pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};\n+pub mod bit_set {\n+    pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n+\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitSet\")]\n+    #[unstable(feature = \"collections\")]\n+    pub use bit::BitSet as BitvSet;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "550c1450b93afe34012e7e06f6c6870e65df5044", "filename": "src/libcollections/linked_list.rs", "status": "renamed", "additions": 119, "deletions": 115, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -10,13 +10,13 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The `DList` allows pushing and popping elements at either end and is thus\n+//! The `LinkedList` allows pushing and popping elements at either end and is thus\n //! efficiently usable as a double-ended queue.\n \n-// DList is constructed like a singly-linked list over the field `next`.\n+// LinkedList is constructed like a singly-linked list over the field `next`.\n // including the last link being None; each Node owns its `next` field.\n //\n-// Backlinks over DList::prev are raw pointers that form a full chain in\n+// Backlinks over LinkedList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -32,9 +32,13 @@ use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to LinkedList\")]\n+#[unstable(feature = \"collections\")]\n+pub use LinkedList as DList;\n+\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct DList<T> {\n+pub struct LinkedList<T> {\n     length: usize,\n     list_head: Link<T>,\n     list_tail: Rawlink<Node<T>>,\n@@ -56,7 +60,7 @@ struct Node<T> {\n     value: T,\n }\n \n-/// An iterator over references to the items of a `DList`.\n+/// An iterator over references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     head: &'a Link<T>,\n@@ -76,20 +80,20 @@ impl<'a, T> Clone for Iter<'a, T> {\n     }\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// An iterator over mutable references to the items of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n-    list: &'a mut DList<T>,\n+    list: &'a mut LinkedList<T>,\n     head: Rawlink<Node<T>>,\n     tail: Rawlink<Node<T>>,\n     nelem: usize,\n }\n \n-/// An iterator over mutable references to the items of a `DList`.\n+/// An iterator over mutable references to the items of a `LinkedList`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    list: DList<T>\n+    list: LinkedList<T>\n }\n \n /// Rawlink is a type like Option<T> but for holding a raw pointer\n@@ -147,7 +151,7 @@ fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)\n }\n \n // private methods\n-impl<T> DList<T> {\n+impl<T> LinkedList<T> {\n     /// Add a Node first in the list\n     #[inline]\n     fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n@@ -207,18 +211,18 @@ impl<T> DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Default for DList<T> {\n+impl<T> Default for LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn default() -> DList<T> { DList::new() }\n+    fn default() -> LinkedList<T> { LinkedList::new() }\n }\n \n-impl<T> DList<T> {\n-    /// Creates an empty `DList`.\n+impl<T> LinkedList<T> {\n+    /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> DList<T> {\n-        DList{list_head: None, list_tail: Rawlink::none(), length: 0}\n+    pub fn new() -> LinkedList<T> {\n+        LinkedList{list_head: None, list_tail: Rawlink::none(), length: 0}\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -231,10 +235,10 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut a = DList::new();\n-    /// let mut b = DList::new();\n+    /// let mut a = LinkedList::new();\n+    /// let mut b = LinkedList::new();\n     /// a.push_back(1);\n     /// a.push_back(2);\n     /// b.push_back(3);\n@@ -247,7 +251,7 @@ impl<T> DList<T> {\n     /// }\n     /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n-    pub fn append(&mut self, other: &mut DList<T>) {\n+    pub fn append(&mut self, other: &mut LinkedList<T>) {\n         match self.list_tail.resolve() {\n             None => {\n                 self.length = other.length;\n@@ -301,16 +305,16 @@ impl<T> DList<T> {\n         IntoIter{list: self}\n     }\n \n-    /// Returns `true` if the `DList` is empty.\n+    /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert!(dl.is_empty());\n     ///\n     /// dl.push_front(\"foo\");\n@@ -322,16 +326,16 @@ impl<T> DList<T> {\n         self.list_head.is_none()\n     }\n \n-    /// Returns the length of the `DList`.\n+    /// Returns the length of the `LinkedList`.\n     ///\n     /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// assert_eq!(dl.len(), 1);\n@@ -349,16 +353,16 @@ impl<T> DList<T> {\n         self.length\n     }\n \n-    /// Removes all elements from the `DList`.\n+    /// Removes all elements from the `LinkedList`.\n     ///\n     /// This operation should compute in O(n) time.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// dl.push_front(1);\n@@ -373,7 +377,7 @@ impl<T> DList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = DList::new()\n+        *self = LinkedList::new()\n     }\n \n     /// Provides a reference to the front element, or `None` if the list is\n@@ -382,9 +386,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.front(), None);\n     ///\n     /// dl.push_front(1);\n@@ -403,9 +407,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.front(), None);\n     ///\n     /// dl.push_front(1);\n@@ -430,9 +434,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.back(), None);\n     ///\n     /// dl.push_back(1);\n@@ -451,9 +455,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     /// assert_eq!(dl.back(), None);\n     ///\n     /// dl.push_back(1);\n@@ -479,9 +483,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut dl = DList::new();\n+    /// let mut dl = LinkedList::new();\n     ///\n     /// dl.push_front(2);\n     /// assert_eq!(dl.front().unwrap(), &2);\n@@ -503,9 +507,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// assert_eq!(d.pop_front(), None);\n     ///\n     /// d.push_front(1);\n@@ -526,9 +530,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n@@ -544,9 +548,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     /// assert_eq!(d.pop_back(), None);\n     /// d.push_back(1);\n     /// d.push_back(3);\n@@ -569,9 +573,9 @@ impl<T> DList<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut d = DList::new();\n+    /// let mut d = LinkedList::new();\n     ///\n     /// d.push_front(1);\n     /// d.push_front(2);\n@@ -583,13 +587,13 @@ impl<T> DList<T> {\n     /// assert_eq!(splitted.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_off(&mut self, at: usize) -> DList<T> {\n+    pub fn split_off(&mut self, at: usize) -> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, DList::new());\n+            return mem::replace(self, LinkedList::new());\n         } else if at == len {\n-            return DList::new();\n+            return LinkedList::new();\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n@@ -612,7 +616,7 @@ impl<T> DList<T> {\n             iter.tail\n         };\n \n-        let mut splitted_list = DList {\n+        let mut splitted_list = LinkedList {\n             list_head: None,\n             list_tail: self.list_tail,\n             length: len - at\n@@ -628,9 +632,9 @@ impl<T> DList<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for DList<T> {\n+impl<T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n-        // Dissolve the dlist in backwards direction\n+        // Dissolve the linked_list in backwards direction\n         // Just dropping the list_head can lead to stack exhaustion\n         // when length is >> 1_000_000\n         let mut tail = self.list_tail;\n@@ -761,9 +765,9 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut list: DList<_> = vec![1, 3, 4].into_iter().collect();\n+    /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n     ///\n     /// {\n     ///     let mut it = list.iter_mut();\n@@ -788,9 +792,9 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::DList;\n+    /// use std::collections::LinkedList;\n     ///\n-    /// let mut list: DList<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n     ///\n     /// let mut it = list.iter_mut();\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -829,16 +833,16 @@ impl<A> DoubleEndedIterator for IntoIter<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for DList<A> {\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n-        let mut ret = DList::new();\n+impl<A> FromIterator<A> for LinkedList<A> {\n+    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> LinkedList<A> {\n+        let mut ret = LinkedList::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for DList<T> {\n+impl<T> IntoIterator for LinkedList<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -848,7 +852,7 @@ impl<T> IntoIterator for DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a DList<T> {\n+impl<'a, T> IntoIterator for &'a LinkedList<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -857,7 +861,7 @@ impl<'a, T> IntoIterator for &'a DList<T> {\n     }\n }\n \n-impl<'a, T> IntoIterator for &'a mut DList<T> {\n+impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -867,54 +871,54 @@ impl<'a, T> IntoIterator for &'a mut DList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for DList<A> {\n+impl<A> Extend<A> for LinkedList<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for DList<A> {\n-    fn eq(&self, other: &DList<A>) -> bool {\n+impl<A: PartialEq> PartialEq for LinkedList<A> {\n+    fn eq(&self, other: &LinkedList<A>) -> bool {\n         self.len() == other.len() &&\n             iter::order::eq(self.iter(), other.iter())\n     }\n \n-    fn ne(&self, other: &DList<A>) -> bool {\n+    fn ne(&self, other: &LinkedList<A>) -> bool {\n         self.len() != other.len() ||\n             iter::order::ne(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for DList<A> {}\n+impl<A: Eq> Eq for LinkedList<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for DList<A> {\n-    fn partial_cmp(&self, other: &DList<A>) -> Option<Ordering> {\n+impl<A: PartialOrd> PartialOrd for LinkedList<A> {\n+    fn partial_cmp(&self, other: &LinkedList<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for DList<A> {\n+impl<A: Ord> Ord for LinkedList<A> {\n     #[inline]\n-    fn cmp(&self, other: &DList<A>) -> Ordering {\n+    fn cmp(&self, other: &LinkedList<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Clone for DList<A> {\n-    fn clone(&self) -> DList<A> {\n+impl<A: Clone> Clone for LinkedList<A> {\n+    fn clone(&self) -> LinkedList<A> {\n         self.iter().map(|x| x.clone()).collect()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: fmt::Debug> fmt::Debug for DList<A> {\n+impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"DList [\"));\n+        try!(write!(f, \"LinkedList [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -926,7 +930,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for LinkedList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self {\n@@ -944,9 +948,9 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use super::{DList, Node};\n+    use super::{LinkedList, Node};\n \n-    pub fn check_links<T>(list: &DList<T>) {\n+    pub fn check_links<T>(list: &LinkedList<T>) {\n         let mut len = 0;\n         let mut last_ptr: Option<&Node<T>> = None;\n         let mut node_ptr: &Node<T>;\n@@ -980,7 +984,7 @@ mod tests {\n \n     #[test]\n     fn test_basic() {\n-        let mut m = DList::new();\n+        let mut m = LinkedList::new();\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n@@ -999,7 +1003,7 @@ mod tests {\n         m.push_back(box 7);\n         assert_eq!(m.pop_front(), Some(box 1));\n \n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         n.push_front(2);\n         n.push_front(3);\n         {\n@@ -1019,30 +1023,30 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn generate_test() -> DList<i32> {\n+    fn generate_test() -> LinkedList<i32> {\n         list_from(&[0,1,2,3,4,5,6])\n     }\n \n     #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> DList<T> {\n+    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n         v.iter().map(|x| (*x).clone()).collect()\n     }\n \n     #[test]\n     fn test_append() {\n         // Empty to empty\n         {\n-            let mut m = DList::<i32>::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::<i32>::new();\n+            let mut n = LinkedList::new();\n             m.append(&mut n);\n             check_links(&m);\n             assert_eq!(m.len(), 0);\n             assert_eq!(n.len(), 0);\n         }\n         // Non-empty to empty\n         {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n             n.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n@@ -1053,8 +1057,8 @@ mod tests {\n         }\n         // Empty to non-empty\n         {\n-            let mut m = DList::new();\n-            let mut n = DList::new();\n+            let mut m = LinkedList::new();\n+            let mut n = LinkedList::new();\n             m.push_back(2);\n             m.append(&mut n);\n             check_links(&m);\n@@ -1089,7 +1093,7 @@ mod tests {\n     fn test_split_off() {\n         // singleton\n         {\n-            let mut m = DList::new();\n+            let mut m = LinkedList::new();\n             m.push_back(1);\n \n             let p = m.split_off(0);\n@@ -1130,7 +1134,7 @@ mod tests {\n \n         // no-op on the last index\n         {\n-            let mut m = DList::new();\n+            let mut m = LinkedList::new();\n             m.push_back(1);\n \n             let p = m.split_off(1);\n@@ -1148,7 +1152,7 @@ mod tests {\n         for (i, elt) in m.iter().enumerate() {\n             assert_eq!(i as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         let mut it = n.iter();\n@@ -1160,7 +1164,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_clone() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         n.push_back(2);\n         n.push_back(3);\n         n.push_back(4);\n@@ -1174,7 +1178,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_double_end() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().next(), None);\n         n.push_front(4);\n         n.push_front(5);\n@@ -1196,7 +1200,7 @@ mod tests {\n         for (i, elt) in m.iter().rev().enumerate() {\n             assert_eq!((6 - i) as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert_eq!(n.iter().rev().next(), None);\n         n.push_front(4);\n         let mut it = n.iter().rev();\n@@ -1215,7 +1219,7 @@ mod tests {\n             len -= 1;\n         }\n         assert_eq!(len, 0);\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().next().is_none());\n         n.push_front(4);\n         n.push_back(5);\n@@ -1229,7 +1233,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_mut_double_end() {\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().next_back().is_none());\n         n.push_front(4);\n         n.push_front(5);\n@@ -1278,7 +1282,7 @@ mod tests {\n         for (i, elt) in m.iter_mut().rev().enumerate() {\n             assert_eq!((6 - i) as i32, *elt);\n         }\n-        let mut n = DList::new();\n+        let mut n = LinkedList::new();\n         assert!(n.iter_mut().rev().next().is_none());\n         n.push_front(4);\n         let mut it = n.iter_mut().rev();\n@@ -1313,8 +1317,8 @@ mod tests {\n \n     #[test]\n     fn test_hash() {\n-      let mut x = DList::new();\n-      let mut y = DList::new();\n+      let mut x = LinkedList::new();\n+      let mut y = LinkedList::new();\n \n       assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n \n@@ -1382,16 +1386,16 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        let list: LinkedList<_> = (0..10).collect();\n+        assert_eq!(format!(\"{:?}\", list), \"LinkedList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let list: DList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+        assert_eq!(format!(\"{:?}\", list), \"LinkedList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]\n     fn fuzz_test(sz: i32) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n@@ -1432,29 +1436,29 @@ mod tests {\n     fn bench_collect_into(b: &mut test::Bencher) {\n         let v = &[0; 64];\n         b.iter(|| {\n-            let _: DList<_> = v.iter().cloned().collect();\n+            let _: LinkedList<_> = v.iter().cloned().collect();\n         })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_front(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_back(0);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n@@ -1463,7 +1467,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::Bencher) {\n-        let mut m: DList<_> = DList::new();\n+        let mut m: LinkedList<_> = LinkedList::new();\n         b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n@@ -1473,31 +1477,31 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<_> = v.iter().cloned().collect();\n+        let m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<_> = v.iter().cloned().collect();\n+        let mut m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let m: DList<_> = v.iter().cloned().collect();\n+        let m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter().rev().count() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0; 128];\n-        let mut m: DList<_> = v.iter().cloned().collect();\n+        let mut m: LinkedList<_> = v.iter().cloned().collect();\n         b.iter(|| {\n             assert!(m.iter_mut().rev().count() == 128);\n         })", "previous_filename": "src/libcollections/dlist.rs"}, {"sha": "94d81c74cd36ac409dd8bb3e3727f95c21ded225", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -68,7 +68,7 @@ use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n-use ring_buf::RingBuf;\n+use vec_deque::VecDeque;\n use slice::SliceExt;\n use string::String;\n use unicode;\n@@ -261,7 +261,7 @@ enum RecompositionState {\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n-    buffer: RingBuf<char>,\n+    buffer: VecDeque<char>,\n     composee: Option<char>,\n     last_ccc: Option<u8>\n }\n@@ -496,7 +496,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Recompositions {\n             iter: self.nfd_chars(),\n             state: Composing,\n-            buffer: RingBuf::new(),\n+            buffer: VecDeque::new(),\n             composee: None,\n             last_ccc: None\n         }\n@@ -511,7 +511,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Recompositions {\n             iter: self.nfkd_chars(),\n             state: Composing,\n-            buffer: RingBuf::new(),\n+            buffer: VecDeque::new(),\n             composee: None,\n             last_ccc: None\n         }"}, {"sha": "76b2d5b968ef2f309bbdd5a75cd61a5f4f4d006d", "filename": "src/libcollections/vec_deque.rs", "status": "renamed", "additions": 186, "deletions": 181, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! RingBuf is a double-ended queue, which is implemented with the help of a\n-//! growing circular buffer.\n+//! VecDeque is a double-ended queue, which is implemented with the help of a\n+//! growing ring buffer.\n //!\n //! This queue has `O(1)` amortized inserts and removals from both ends of the\n //! container. It also has `O(1)` indexing like a vector. The contained elements\n@@ -36,12 +36,17 @@ use core::cmp;\n \n use alloc::heap;\n \n+#[deprecated(since = \"1.0.0\", reason = \"renamed to VecDeque\")]\n+#[unstable(feature = \"collections\")]\n+pub use VecDeque as RingBuf;\n+\n static INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n static MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n-/// `RingBuf` is a circular buffer, which can be used as a double-ended queue efficiently.\n+/// `VecDeque` is a growable ring buffer, which can be used as a\n+/// double-ended queue efficiently.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RingBuf<T> {\n+pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n     // to the first element that could be read, Head always points\n     // to where data should be written.\n@@ -55,21 +60,21 @@ pub struct RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for RingBuf<T> {}\n+unsafe impl<T: Send> Send for VecDeque<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for RingBuf<T> {}\n+unsafe impl<T: Sync> Sync for VecDeque<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for RingBuf<T> {\n-    fn clone(&self) -> RingBuf<T> {\n+impl<T: Clone> Clone for VecDeque<T> {\n+    fn clone(&self) -> VecDeque<T> {\n         self.iter().cloned().collect()\n     }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for RingBuf<T> {\n+impl<T> Drop for VecDeque<T> {\n     fn drop(&mut self) {\n         self.clear();\n         unsafe {\n@@ -83,12 +88,12 @@ impl<T> Drop for RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Default for RingBuf<T> {\n+impl<T> Default for VecDeque<T> {\n     #[inline]\n-    fn default() -> RingBuf<T> { RingBuf::new() }\n+    fn default() -> VecDeque<T> { VecDeque::new() }\n }\n \n-impl<T> RingBuf<T> {\n+impl<T> VecDeque<T> {\n     /// Turn ptr into a slice\n     #[inline]\n     unsafe fn buffer_as_slice(&self) -> &[T] {\n@@ -149,16 +154,16 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-impl<T> RingBuf<T> {\n-    /// Creates an empty `RingBuf`.\n+impl<T> VecDeque<T> {\n+    /// Creates an empty `VecDeque`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> RingBuf<T> {\n-        RingBuf::with_capacity(INITIAL_CAPACITY)\n+    pub fn new() -> VecDeque<T> {\n+        VecDeque::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Creates an empty `RingBuf` with space for at least `n` elements.\n+    /// Creates an empty `VecDeque` with space for at least `n` elements.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(n: usize) -> RingBuf<T> {\n+    pub fn with_capacity(n: usize) -> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n         let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n         assert!(cap > n, \"capacity overflow\");\n@@ -175,22 +180,22 @@ impl<T> RingBuf<T> {\n             heap::EMPTY as *mut T\n         };\n \n-        RingBuf {\n+        VecDeque {\n             tail: 0,\n             head: 0,\n             cap: cap,\n             ptr: ptr\n         }\n     }\n \n-    /// Retrieves an element in the `RingBuf` by index.\n+    /// Retrieves an element in the `VecDeque` by index.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -206,14 +211,14 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Retrieves an element in the `RingBuf` mutably by index.\n+    /// Retrieves an element in the `VecDeque` mutably by index.\n     ///\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -245,9 +250,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n@@ -266,23 +271,23 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns the number of elements the `RingBuf` can hold without\n+    /// Returns the number of elements the `VecDeque` can hold without\n     /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let buf: RingBuf<i32> = RingBuf::with_capacity(10);\n+    /// let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n     /// assert!(buf.capacity() >= 10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize { self.cap - 1 }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `RingBuf`. Does nothing if the capacity is already sufficient.\n+    /// given `VecDeque`. Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it requests. Therefore\n     /// capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future\n@@ -295,9 +300,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n     /// buf.reserve_exact(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -316,9 +321,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<i32> = vec![1].into_iter().collect();\n+    /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n     /// buf.reserve(10);\n     /// assert!(buf.capacity() >= 11);\n     /// ```\n@@ -390,9 +395,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::with_capacity(15);\n+    /// let mut buf = VecDeque::with_capacity(15);\n     /// buf.extend(0..4);\n     /// assert_eq!(buf.capacity(), 15);\n     /// buf.shrink_to_fit();\n@@ -475,9 +480,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n@@ -498,9 +503,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n@@ -521,9 +526,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n@@ -553,7 +558,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `RingBuf`.\n+    /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -573,7 +578,7 @@ impl<T> RingBuf<T> {\n     }\n \n     /// Returns a pair of slices which contain, in order, the contents of the\n-    /// `RingBuf`.\n+    /// `VecDeque`.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -596,14 +601,14 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Returns the number of elements in the `RingBuf`.\n+    /// Returns the number of elements in the `VecDeque`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// assert_eq!(v.len(), 0);\n     /// v.push_back(1);\n     /// assert_eq!(v.len(), 1);\n@@ -616,25 +621,25 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// assert!(v.is_empty());\n     /// v.push_front(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n-    /// Creates a draining iterator that clears the `RingBuf` and iterates over\n+    /// Creates a draining iterator that clears the `VecDeque` and iterates over\n     /// the removed items from start to end.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n     /// assert_eq!(v.drain().next(), Some(1));\n     /// assert!(v.is_empty());\n@@ -653,9 +658,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut v = RingBuf::new();\n+    /// let mut v = VecDeque::new();\n     /// v.push_back(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n@@ -672,9 +677,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.front(), None);\n     ///\n     /// d.push_back(1);\n@@ -692,9 +697,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n     /// d.push_back(1);\n@@ -716,9 +721,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.back(), None);\n     ///\n     /// d.push_back(1);\n@@ -736,9 +741,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// assert_eq!(d.back(), None);\n     ///\n     /// d.push_back(1);\n@@ -761,9 +766,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// d.push_back(1);\n     /// d.push_back(2);\n     ///\n@@ -787,9 +792,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut d = RingBuf::new();\n+    /// let mut d = VecDeque::new();\n     /// d.push_front(1);\n     /// d.push_front(2);\n     /// assert_eq!(d.front(), Some(&2));\n@@ -811,9 +816,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n@@ -836,9 +841,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.pop_back(), None);\n     /// buf.push_back(1);\n     /// buf.push_back(3);\n@@ -870,9 +875,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.swap_back_remove(0), None);\n     /// buf.push_back(5);\n     /// buf.push_back(99);\n@@ -903,9 +908,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// assert_eq!(buf.swap_front_remove(0), None);\n     /// buf.push_back(15);\n     /// buf.push_back(5);\n@@ -936,9 +941,9 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Examples\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n     /// buf.insert(1,11);\n@@ -1138,9 +1143,9 @@ impl<T> RingBuf<T> {\n     ///\n     /// # Examples\n     /// ```rust\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(12);\n@@ -1309,9 +1314,9 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<_> = vec![1,2,3].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n     /// let buf2 = buf.split_off(1);\n     /// // buf = [1], buf2 = [2, 3]\n     /// assert_eq!(buf.len(), 1);\n@@ -1325,7 +1330,7 @@ impl<T> RingBuf<T> {\n         assert!(at <= len, \"`at` out of bounds\");\n \n         let other_len = len - at;\n-        let mut other = RingBuf::with_capacity(other_len);\n+        let mut other = VecDeque::with_capacity(other_len);\n \n         unsafe {\n             let (first_half, second_half) = self.as_slices();\n@@ -1371,10 +1376,10 @@ impl<T> RingBuf<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf: RingBuf<_> = vec![1, 2, 3].into_iter().collect();\n-    /// let mut buf2: RingBuf<_> = vec![4, 5, 6].into_iter().collect();\n+    /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let mut buf2: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n     /// buf.append(&mut buf2);\n     /// assert_eq!(buf.len(), 6);\n     /// assert_eq!(buf2.len(), 0);\n@@ -1388,16 +1393,16 @@ impl<T> RingBuf<T> {\n     }\n }\n \n-impl<T: Clone> RingBuf<T> {\n+impl<T: Clone> VecDeque<T> {\n     /// Modifies the ringbuf in-place so that `len()` is equal to new_len,\n     /// either by removing excess elements or by appending copies of a value to the back.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::collections::RingBuf;\n+    /// use std::collections::VecDeque;\n     ///\n-    /// let mut buf = RingBuf::new();\n+    /// let mut buf = VecDeque::new();\n     /// buf.push_back(5);\n     /// buf.push_back(10);\n     /// buf.push_back(15);\n@@ -1434,7 +1439,7 @@ fn count(tail: usize, head: usize, size: usize) -> usize {\n     (head - tail) & (size - 1)\n }\n \n-/// `RingBuf` iterator.\n+/// `VecDeque` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T:'a> {\n     ring: &'a [T],\n@@ -1511,7 +1516,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n // FIXME This was implemented differently from Iter because of a problem\n //       with returning the mutable reference. I couldn't find a way to\n //       make the lifetime checker happy so, but there should be a way.\n-/// `RingBuf` mutable iterator.\n+/// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n     ptr: *mut T,\n@@ -1563,10 +1568,10 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-/// A by-value RingBuf iterator\n+/// A by-value VecDeque iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    inner: RingBuf<T>,\n+    inner: VecDeque<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1596,11 +1601,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n-/// A draining RingBuf iterator\n+/// A draining VecDeque iterator\n #[unstable(feature = \"collections\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n-    inner: &'a mut RingBuf<T>,\n+    inner: &'a mut VecDeque<T>,\n }\n \n #[unsafe_destructor]\n@@ -1641,33 +1646,33 @@ impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for RingBuf<A> {\n-    fn eq(&self, other: &RingBuf<A>) -> bool {\n+impl<A: PartialEq> PartialEq for VecDeque<A> {\n+    fn eq(&self, other: &VecDeque<A>) -> bool {\n         self.len() == other.len() &&\n             self.iter().zip(other.iter()).all(|(a, b)| a.eq(b))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for RingBuf<A> {}\n+impl<A: Eq> Eq for VecDeque<A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for RingBuf<A> {\n-    fn partial_cmp(&self, other: &RingBuf<A>) -> Option<Ordering> {\n+impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n+    fn partial_cmp(&self, other: &VecDeque<A>) -> Option<Ordering> {\n         iter::order::partial_cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for RingBuf<A> {\n+impl<A: Ord> Ord for VecDeque<A> {\n     #[inline]\n-    fn cmp(&self, other: &RingBuf<A>) -> Ordering {\n+    fn cmp(&self, other: &VecDeque<A>) -> Ordering {\n         iter::order::cmp(self.iter(), other.iter())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for VecDeque<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self {\n@@ -1677,7 +1682,7 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Index<usize> for RingBuf<A> {\n+impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n     #[inline]\n@@ -1687,25 +1692,25 @@ impl<A> Index<usize> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> IndexMut<usize> for RingBuf<A> {\n+impl<A> IndexMut<usize> for VecDeque<A> {\n     #[inline]\n     fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for RingBuf<A> {\n-    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n+impl<A> FromIterator<A> for VecDeque<A> {\n+    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> VecDeque<A> {\n         let (lower, _) = iterator.size_hint();\n-        let mut deq = RingBuf::with_capacity(lower);\n+        let mut deq = VecDeque::with_capacity(lower);\n         deq.extend(iterator);\n         deq\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for RingBuf<T> {\n+impl<T> IntoIterator for VecDeque<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1715,7 +1720,7 @@ impl<T> IntoIterator for RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a RingBuf<T> {\n+impl<'a, T> IntoIterator for &'a VecDeque<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1725,7 +1730,7 @@ impl<'a, T> IntoIterator for &'a RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n+impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -1735,7 +1740,7 @@ impl<'a, T> IntoIterator for &'a mut RingBuf<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for RingBuf<A> {\n+impl<A> Extend<A> for VecDeque<A> {\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T) {\n         for elt in iterator {\n             self.push_back(elt);\n@@ -1744,9 +1749,9 @@ impl<A> Extend<A> for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n+impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"RingBuf [\"));\n+        try!(write!(f, \"VecDeque [\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1768,12 +1773,12 @@ mod tests {\n     use test::Bencher;\n     use test;\n \n-    use super::RingBuf;\n+    use super::VecDeque;\n \n     #[test]\n     #[allow(deprecated)]\n     fn test_simple() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.len(), 0);\n         d.push_front(17);\n         d.push_front(42);\n@@ -1812,7 +1817,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n         deq.push_front(b.clone());\n@@ -1843,7 +1848,7 @@ mod tests {\n \n     #[test]\n     fn test_push_front_grow() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 0..66 {\n             deq.push_front(i);\n         }\n@@ -1853,7 +1858,7 @@ mod tests {\n             assert_eq!(deq[i], 65 - i);\n         }\n \n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 0..66 {\n             deq.push_back(i);\n         }\n@@ -1865,7 +1870,7 @@ mod tests {\n \n     #[test]\n     fn test_index() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 1..4 {\n             deq.push_front(i);\n         }\n@@ -1875,7 +1880,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n-        let mut deq = RingBuf::new();\n+        let mut deq = VecDeque::new();\n         for i in 1..4 {\n             deq.push_front(i);\n         }\n@@ -1885,14 +1890,14 @@ mod tests {\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let ring: RingBuf<i32> = RingBuf::new();\n+            let ring: VecDeque<i32> = VecDeque::new();\n             test::black_box(ring);\n         })\n     }\n \n     #[bench]\n     fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::with_capacity(101);\n+        let mut deq = VecDeque::with_capacity(101);\n         b.iter(|| {\n             for i in 0..100 {\n                 deq.push_back(i);\n@@ -1904,7 +1909,7 @@ mod tests {\n \n     #[bench]\n     fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::with_capacity(101);\n+        let mut deq = VecDeque::with_capacity(101);\n         b.iter(|| {\n             for i in 0..100 {\n                 deq.push_front(i);\n@@ -1916,7 +1921,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq= RingBuf::<i32>::with_capacity(101);\n+        let mut deq= VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1929,7 +1934,7 @@ mod tests {\n \n     #[bench]\n     fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = RingBuf::<i32>::with_capacity(101);\n+        let mut deq = VecDeque::<i32>::with_capacity(101);\n \n         b.iter(|| {\n             deq.head = 100;\n@@ -1943,7 +1948,7 @@ mod tests {\n     #[bench]\n     fn bench_grow_1025(b: &mut test::Bencher) {\n         b.iter(|| {\n-            let mut deq = RingBuf::new();\n+            let mut deq = VecDeque::new();\n             for i in 0..1025 {\n                 deq.push_front(i);\n             }\n@@ -1953,7 +1958,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<_> = (0..1000).collect();\n+        let ring: VecDeque<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1966,7 +1971,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<_> = (0..1000).collect();\n+        let mut ring: VecDeque<_> = (0..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2027,17 +2032,17 @@ mod tests {\n \n     #[test]\n     fn test_with_capacity() {\n-        let mut d = RingBuf::with_capacity(0);\n+        let mut d = VecDeque::with_capacity(0);\n         d.push_back(1);\n         assert_eq!(d.len(), 1);\n-        let mut d = RingBuf::with_capacity(50);\n+        let mut d = VecDeque::with_capacity(50);\n         d.push_back(1);\n         assert_eq!(d.len(), 1);\n     }\n \n     #[test]\n     fn test_with_capacity_non_power_two() {\n-        let mut d3 = RingBuf::with_capacity(3);\n+        let mut d3 = VecDeque::with_capacity(3);\n         d3.push_back(1);\n \n         // X = None, | = lo\n@@ -2062,7 +2067,7 @@ mod tests {\n \n         d3.push_back(15);\n         // There used to be a bug here about how the\n-        // RingBuf made growth assumptions about the\n+        // VecDeque made growth assumptions about the\n         // underlying Vec which didn't hold and lead\n         // to corruption.\n         // (Vec grows to next power of two)\n@@ -2078,31 +2083,31 @@ mod tests {\n \n     #[test]\n     fn test_reserve_exact() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_back(0);\n         d.reserve_exact(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_reserve() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_back(0);\n         d.reserve(50);\n         assert!(d.capacity() >= 51);\n     }\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<_> = (0..5).collect();\n+        let mut d: VecDeque<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n         assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n     }\n \n     #[test]\n     fn test_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n@@ -2134,7 +2139,7 @@ mod tests {\n \n     #[test]\n     fn test_rev_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert_eq!(d.iter().rev().next(), None);\n \n         for i in 0..5 {\n@@ -2154,7 +2159,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter_wrap() {\n-        let mut d = RingBuf::with_capacity(3);\n+        let mut d = VecDeque::with_capacity(3);\n         assert!(d.iter_mut().rev().next().is_none());\n \n         d.push_back(1);\n@@ -2169,7 +2174,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert!(d.iter_mut().next().is_none());\n \n         for i in 0..3 {\n@@ -2192,7 +2197,7 @@ mod tests {\n \n     #[test]\n     fn test_mut_rev_iter() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         assert!(d.iter_mut().rev().next().is_none());\n \n         for i in 0..3 {\n@@ -2218,7 +2223,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let d: RingBuf<i32> = RingBuf::new();\n+            let d: VecDeque<i32> = VecDeque::new();\n             let mut iter = d.into_iter();\n \n             assert_eq!(iter.size_hint(), (0, Some(0)));\n@@ -2228,7 +2233,7 @@ mod tests {\n \n         // simple iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2239,7 +2244,7 @@ mod tests {\n \n         // wrapped iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2253,7 +2258,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2277,7 +2282,7 @@ mod tests {\n \n         // Empty iter\n         {\n-            let mut d: RingBuf<i32> = RingBuf::new();\n+            let mut d: VecDeque<i32> = VecDeque::new();\n \n             {\n                 let mut iter = d.drain();\n@@ -2292,7 +2297,7 @@ mod tests {\n \n         // simple iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2303,7 +2308,7 @@ mod tests {\n \n         // wrapped iter\n         {\n-            let mut d = RingBuf::new();\n+            let mut d = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2317,7 +2322,7 @@ mod tests {\n \n         // partially used\n         {\n-            let mut d: RingBuf<_> = RingBuf::new();\n+            let mut d: VecDeque<_> = VecDeque::new();\n             for i in 0..5 {\n                 d.push_back(i);\n             }\n@@ -2343,12 +2348,12 @@ mod tests {\n     fn test_from_iter() {\n         use core::iter;\n         let v = vec!(1,2,3,4,5,6,7);\n-        let deq: RingBuf<_> = v.iter().cloned().collect();\n+        let deq: VecDeque<_> = v.iter().cloned().collect();\n         let u: Vec<_> = deq.iter().cloned().collect();\n         assert_eq!(u, v);\n \n         let seq = iter::count(0, 2).take(256);\n-        let deq: RingBuf<_> = seq.collect();\n+        let deq: VecDeque<_> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);\n         }\n@@ -2357,7 +2362,7 @@ mod tests {\n \n     #[test]\n     fn test_clone() {\n-        let mut d = RingBuf::new();\n+        let mut d = VecDeque::new();\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n@@ -2374,13 +2379,13 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut d = RingBuf::new();\n-        assert!(d == RingBuf::with_capacity(0));\n+        let mut d = VecDeque::new();\n+        assert!(d == VecDeque::with_capacity(0));\n         d.push_front(137);\n         d.push_front(17);\n         d.push_front(42);\n         d.push_back(137);\n-        let mut e = RingBuf::with_capacity(0);\n+        let mut e = VecDeque::with_capacity(0);\n         e.push_back(42);\n         e.push_back(17);\n         e.push_back(137);\n@@ -2390,13 +2395,13 @@ mod tests {\n         e.push_back(0);\n         assert!(e != d);\n         e.clear();\n-        assert!(e == RingBuf::new());\n+        assert!(e == VecDeque::new());\n     }\n \n     #[test]\n     fn test_hash() {\n-      let mut x = RingBuf::new();\n-      let mut y = RingBuf::new();\n+      let mut x = VecDeque::new();\n+      let mut y = VecDeque::new();\n \n       x.push_back(1);\n       x.push_back(2);\n@@ -2413,8 +2418,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let x = RingBuf::new();\n-        let mut y = RingBuf::new();\n+        let x = VecDeque::new();\n+        let mut y = VecDeque::new();\n         y.push_back(1);\n         y.push_back(2);\n         y.push_back(3);\n@@ -2426,13 +2431,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        let ringbuf: VecDeque<_> = (0..10).collect();\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-        let ringbuf: RingBuf<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n+        let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .cloned()\n                                                                         .collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]\n@@ -2445,7 +2450,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2465,7 +2470,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2489,7 +2494,7 @@ mod tests {\n             }\n         }\n \n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(Elem);\n         ring.push_front(Elem);\n         ring.push_back(Elem);\n@@ -2505,7 +2510,7 @@ mod tests {\n     fn test_reserve_grow() {\n         // test growth path A\n         // [T o o H] -> [T o o H . . . . ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..3 {\n             ring.push_back(i);\n         }\n@@ -2516,7 +2521,7 @@ mod tests {\n \n         // test growth path B\n         // [H T o o] -> [. T o o H . . . ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..1 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n@@ -2531,7 +2536,7 @@ mod tests {\n \n         // test growth path C\n         // [o o H T] -> [o o H . . . . T ]\n-        let mut ring = RingBuf::with_capacity(4);\n+        let mut ring = VecDeque::with_capacity(4);\n         for i in 0..3 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n@@ -2547,7 +2552,7 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(0);\n         assert_eq!(ring.get(0), Some(&0));\n         assert_eq!(ring.get(1), None);\n@@ -2579,7 +2584,7 @@ mod tests {\n \n     #[test]\n     fn test_get_mut() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         for i in 0..3 {\n             ring.push_back(i);\n         }\n@@ -2605,7 +2610,7 @@ mod tests {\n         fn test(back: bool) {\n             // This test checks that every single combination of tail position and length is tested.\n             // Capacity 15 should be large enough to cover every case.\n-            let mut tester = RingBuf::with_capacity(15);\n+            let mut tester = VecDeque::with_capacity(15);\n             let usable_cap = tester.capacity();\n             let final_len = usable_cap / 2;\n \n@@ -2649,7 +2654,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // insertion position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2683,7 +2688,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // removal position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2720,7 +2725,7 @@ mod tests {\n         // This test checks that every single combination of head and tail position,\n         // is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2749,7 +2754,7 @@ mod tests {\n \n     #[test]\n     fn test_front() {\n-        let mut ring = RingBuf::new();\n+        let mut ring = VecDeque::new();\n         ring.push_back(10);\n         ring.push_back(20);\n         assert_eq!(ring.front(), Some(&10));\n@@ -2761,7 +2766,7 @@ mod tests {\n \n     #[test]\n     fn test_as_slices() {\n-        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n         let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n@@ -2789,7 +2794,7 @@ mod tests {\n \n     #[test]\n     fn test_as_mut_slices() {\n-        let mut ring: RingBuf<i32> = RingBuf::with_capacity(127);\n+        let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n         let cap = ring.capacity() as i32;\n         let first = cap/2;\n         let last  = cap - first;\n@@ -2820,7 +2825,7 @@ mod tests {\n         // This test checks that every single combination of tail position, length, and\n         // split position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(15);\n+        let mut tester = VecDeque::with_capacity(15);\n         // can't guarantee we got 15, so have to get what we got.\n         // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n@@ -2855,8 +2860,8 @@ mod tests {\n \n     #[test]\n     fn test_append() {\n-        let mut a: RingBuf<_> = vec![1, 2, 3].into_iter().collect();\n-        let mut b: RingBuf<_> = vec![4, 5, 6].into_iter().collect();\n+        let mut a: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n+        let mut b: VecDeque<_> = vec![4, 5, 6].into_iter().collect();\n \n         // normal append\n         a.append(&mut b);", "previous_filename": "src/libcollections/ring_buf.rs"}, {"sha": "582cd4f384f317b904a72185bb9c66c5df4b85a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -37,7 +37,7 @@ use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n use lint::{Level, Context, LintPass, LintArray, Lint};\n \n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n use std::{cmp, slice};\n@@ -1792,7 +1792,7 @@ impl LintPass for UnconditionalRecursion {\n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;\n         let mut self_call_spans = vec![];\n-        let mut visited = BitvSet::new();\n+        let mut visited = BitSet::new();\n \n         while let Some(idx) = work_queue.pop() {\n             let cfg_id = idx.node_id();"}, {"sha": "436f04fc9e9cf9744f7d484757c9022146e47883", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -34,7 +34,7 @@\n \n use std::fmt::{Formatter, Error, Debug};\n use std::usize;\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n \n pub struct Graph<N,E> {\n     nodes: Vec<Node<N>> ,\n@@ -292,15 +292,15 @@ impl<N,E> Graph<N,E> {\n         DepthFirstTraversal {\n             graph: self,\n             stack: vec![start],\n-            visited: BitvSet::new()\n+            visited: BitSet::new()\n         }\n     }\n }\n \n pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitvSet\n+    visited: BitSet\n }\n \n impl<'g, N, E> Iterator for DepthFirstTraversal<'g, N, E> {"}, {"sha": "ac56cc37506588693cda58600c7d91c45a22a863", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -16,12 +16,12 @@ use std::hash::{Hash, Hasher};\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n-use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n+use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n use collections::enum_set::{EnumSet, CLike};\n \n impl<\n     T: Encodable\n-> Encodable for DList<T> {\n+> Encodable for LinkedList<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -32,10 +32,10 @@ impl<\n     }\n }\n \n-impl<T:Decodable> Decodable for DList<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<DList<T>, D::Error> {\n+impl<T:Decodable> Decodable for LinkedList<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut list = DList::new();\n+            let mut list = LinkedList::new();\n             for i in 0..len {\n                 list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n@@ -44,7 +44,7 @@ impl<T:Decodable> Decodable for DList<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for RingBuf<T> {\n+impl<T: Encodable> Encodable for VecDeque<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -55,10 +55,10 @@ impl<T: Encodable> Encodable for RingBuf<T> {\n     }\n }\n \n-impl<T:Decodable> Decodable for RingBuf<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<RingBuf<T>, D::Error> {\n+impl<T:Decodable> Decodable for VecDeque<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut deque: RingBuf<T> = RingBuf::new();\n+            let mut deque: VecDeque<T> = VecDeque::new();\n             for i in 0..len {\n                 deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }"}, {"sha": "0e64370df60ecbdc8b24ff51abc1a506ba83b8a2", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -23,7 +23,7 @@\n //!\n //! Rust's collections can be grouped into four major categories:\n //!\n-//! * Sequences: `Vec`, `RingBuf`, `DList`, `BitV`\n+//! * Sequences: `Vec`, `VecDeque`, `LinkedList`, `BitV`\n //! * Maps: `HashMap`, `BTreeMap`, `VecMap`\n //! * Sets: `HashSet`, `BTreeSet`, `BitVSet`\n //! * Misc: `BinaryHeap`\n@@ -43,13 +43,13 @@\n //! * You want a resizable array.\n //! * You want a heap-allocated array.\n //!\n-//! ### Use a `RingBuf` when:\n+//! ### Use a `VecDeque` when:\n //! * You want a `Vec` that supports efficient insertion at both ends of the sequence.\n //! * You want a queue.\n //! * You want a double-ended queue (deque).\n //!\n-//! ### Use a `DList` when:\n-//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate amortization.\n+//! ### Use a `LinkedList` when:\n+//! * You want a `Vec` or `VecDeque` of unknown size, and can't tolerate amortization.\n //! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n //!\n@@ -75,7 +75,7 @@\n //!\n //! ### Use a `BitV` when:\n //! * You want to store an unbounded number of booleans in a small space.\n-//! * You want a bitvector.\n+//! * You want a bit vector.\n //!\n //! ### Use a `BitVSet` when:\n //! * You want a `VecSet`.\n@@ -106,20 +106,20 @@\n //!\n //! ## Sequences\n //!\n-//! |         | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n-//! |---------|----------------|-----------------|----------------|--------|----------------|\n-//! | Vec     | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n-//! | RingBuf | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n-//! | DList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n-//! | Bitv    | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! |              | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |--------------|----------------|-----------------|----------------|--------|----------------|\n+//! | Vec          | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | VecDeque     | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | LinkedList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! | BitVec       | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n //!\n-//! Note that where ties occur, Vec is generally going to be faster than RingBuf, and RingBuf\n-//! is generally going to be faster than DList. Bitv is not a general purpose collection, and\n+//! Note that where ties occur, Vec is generally going to be faster than VecDeque, and VecDeque\n+//! is generally going to be faster than LinkedList. BitVec is not a general purpose collection, and\n //! therefore cannot reasonably be compared.\n //!\n //! ## Maps\n //!\n-//! For Sets, all operations have the cost of the equivalent Map operation. For BitvSet,\n+//! For Sets, all operations have the cost of the equivalent Map operation. For BitSet,\n //! refer to VecMap.\n //!\n //! |          | get       | insert   | remove   | predecessor |\n@@ -166,7 +166,7 @@\n //!\n //! Any `with_capacity` constructor will instruct the collection to allocate enough space\n //! for the specified number of elements. Ideally this will be for exactly that many\n-//! elements, but some implementation details may prevent this. `Vec` and `RingBuf` can\n+//! elements, but some implementation details may prevent this. `Vec` and `VecDeque` can\n //! be relied on to allocate exactly the requested amount, though. Use `with_capacity`\n //! when you know exactly how many elements will be inserted, or at least have a\n //! reasonable upper-bound on that number.\n@@ -240,10 +240,10 @@\n //! ```\n //!\n //! ```\n-//! use std::collections::RingBuf;\n+//! use std::collections::VecDeque;\n //!\n //! let vec = vec![1, 2, 3, 4];\n-//! let buf: RingBuf<_> = vec.into_iter().collect();\n+//! let buf: VecDeque<_> = vec.into_iter().collect();\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common tasks to\n@@ -362,11 +362,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core_collections::Bound;\n-pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n-pub use core_collections::{DList, RingBuf, VecMap};\n+pub use core_collections::{BinaryHeap, BitVec, BitSet, BTreeMap, BTreeSet};\n+pub use core_collections::{LinkedList, VecDeque, VecMap};\n \n-pub use core_collections::{binary_heap, bitv, bitv_set, btree_map, btree_set};\n-pub use core_collections::{dlist, ring_buf, vec_map};\n+pub use core_collections::{binary_heap, bit_vec, bit_set, btree_map, btree_set};\n+pub use core_collections::{linked_list, vec_deque, vec_map};\n \n pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;"}, {"sha": "56efa5e0c935d49ce7624293361796037946ca15", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -26,11 +26,11 @@ use parse::token;\n use ptr::P;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::HashSet;\n use std::fmt;\n \n-thread_local! { static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()) }\n+thread_local! { static USED_ATTRS: RefCell<BitSet> = RefCell::new(BitSet::new()) }\n \n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;"}, {"sha": "8bddd655e23c3ba8263991c1cd44fc8a17032ce4", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fa9de16df87ab844452821acff1b6c74e948327/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa9de16df87ab844452821acff1b6c74e948327/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=5fa9de16df87ab844452821acff1b6c74e948327", "patch": "@@ -16,7 +16,7 @@ extern crate collections;\n extern crate rand;\n \n use std::collections::BTreeSet;\n-use std::collections::BitvSet;\n+use std::collections::BitSet;\n use std::collections::HashSet;\n use std::collections::hash_map::Hasher;\n use std::hash::Hash;\n@@ -53,7 +53,7 @@ impl<T: Ord> MutableSet<T> for BTreeSet<T> {\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }\n }\n-impl MutableSet<usize> for BitvSet {\n+impl MutableSet<usize> for BitSet {\n     fn insert(&mut self, k: usize) { self.insert(k); }\n     fn remove(&mut self, k: &usize) -> bool { self.remove(k) }\n     fn contains(&self, k: &usize) -> bool { self.contains(k) }\n@@ -222,7 +222,7 @@ fn main() {\n     {\n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n-        results.bench_int(&mut rng, num_keys, max, || BitvSet::new());\n-        write_results(\"collections::bitv::BitvSet\", &results);\n+        results.bench_int(&mut rng, num_keys, max, || BitSet::new());\n+        write_results(\"collections::bit_vec::BitSet\", &results);\n     }\n }"}]}