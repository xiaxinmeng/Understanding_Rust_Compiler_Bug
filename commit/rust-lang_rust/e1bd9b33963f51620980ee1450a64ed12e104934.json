{"sha": "e1bd9b33963f51620980ee1450a64ed12e104934", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYmQ5YjMzOTYzZjUxNjIwOTgwZWUxNDUwYTY0ZWQxMmUxMDQ5MzQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-20T22:32:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-20T22:32:40Z"}, "message": "Rollup merge of #67795 - Mark-Simulacrum:fmt-argument, r=dtolnay\n\nCleanup formatting code\n\nThis removes a few leftover positional enum variants that were no longer used.\n\nAll details that are changed are unstable (and `#[doc(hidden)]`), so this should\nnot impact downstream code.", "tree": {"sha": "18bc3e93d227f96192ac3ebfbdaa2a469c1f75b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18bc3e93d227f96192ac3ebfbdaa2a469c1f75b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1bd9b33963f51620980ee1450a64ed12e104934", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeJiqICRBK7hj4Ov3rIwAAdHIIAJv7/RrbqN+ENgjOXozu0+vq\nfEUhGIMmHd9b9RuJ3D1xAZ7qrAo/kN798QrXkTGsgicwqMAYIBnkOIcHdRQ36gxL\nndeeMoF1T3AE1clhGxu/ararMYIxrrM9wQWae+eULhjWkD/QFCNouN1jGGSOCU9o\nlLVbakbsyGKhDeTqi+6PT4/VTpDBqnu8uphCT3VbtLxBiQwYjoc7mori4YSWcoq1\nuM+eiTOpnioRfoSAfJQb1UmNrmUHw5RTH35HEVp3wqRRI9pScPYTWEPejzUiy1a8\nV+zdztwxKW+D/syQCylQAsUVE9x0F3rvaLXzaKQaVx35/qMFTnm2ALFRnJHshCQ=\n=vyQq\n-----END PGP SIGNATURE-----\n", "payload": "tree 18bc3e93d227f96192ac3ebfbdaa2a469c1f75b3\nparent ec7f209ad426208c9bc40f4e49c870d5364b47b2\nparent a804a455289cfa6d39ec92903959c4614c48d080\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1579559560 +0900\ncommitter GitHub <noreply@github.com> 1579559560 +0900\n\nRollup merge of #67795 - Mark-Simulacrum:fmt-argument, r=dtolnay\n\nCleanup formatting code\n\nThis removes a few leftover positional enum variants that were no longer used.\n\nAll details that are changed are unstable (and `#[doc(hidden)]`), so this should\nnot impact downstream code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1bd9b33963f51620980ee1450a64ed12e104934", "html_url": "https://github.com/rust-lang/rust/commit/e1bd9b33963f51620980ee1450a64ed12e104934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1bd9b33963f51620980ee1450a64ed12e104934/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec7f209ad426208c9bc40f4e49c870d5364b47b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7f209ad426208c9bc40f4e49c870d5364b47b2", "html_url": "https://github.com/rust-lang/rust/commit/ec7f209ad426208c9bc40f4e49c870d5364b47b2"}, {"sha": "a804a455289cfa6d39ec92903959c4614c48d080", "url": "https://api.github.com/repos/rust-lang/rust/commits/a804a455289cfa6d39ec92903959c4614c48d080", "html_url": "https://github.com/rust-lang/rust/commit/a804a455289cfa6d39ec92903959c4614c48d080"}], "stats": {"total": 133, "additions": 47, "deletions": 86}, "files": [{"sha": "900ef63f1dfcc3a3b2b263b463779307c26f3c3f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e1bd9b33963f51620980ee1450a64ed12e104934", "patch": "@@ -10,7 +10,6 @@ use crate::mem;\n use crate::num::flt2dec;\n use crate::ops::Deref;\n use crate::result;\n-use crate::slice;\n use crate::str;\n \n mod builders;\n@@ -234,8 +233,6 @@ pub struct Formatter<'a> {\n     precision: Option<usize>,\n \n     buf: &'a mut (dyn Write + 'a),\n-    curarg: slice::Iter<'a, ArgumentV1<'a>>,\n-    args: &'a [ArgumentV1<'a>],\n }\n \n // NB. Argument is essentially an optimized partially applied formatting function,\n@@ -1043,8 +1040,6 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n         buf: output,\n         align: rt::v1::Alignment::Unknown,\n         fill: ' ',\n-        args: args.args,\n-        curarg: args.args.iter(),\n     };\n \n     let mut idx = 0;\n@@ -1063,7 +1058,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n             // a string piece.\n             for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n                 formatter.buf.write_str(*piece)?;\n-                formatter.run(arg)?;\n+                run(&mut formatter, arg, &args.args)?;\n                 idx += 1;\n             }\n         }\n@@ -1077,6 +1072,39 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n     Ok(())\n }\n \n+fn run(fmt: &mut Formatter<'_>, arg: &rt::v1::Argument, args: &[ArgumentV1<'_>]) -> Result {\n+    fmt.fill = arg.format.fill;\n+    fmt.align = arg.format.align;\n+    fmt.flags = arg.format.flags;\n+    fmt.width = getcount(args, &arg.format.width);\n+    fmt.precision = getcount(args, &arg.format.precision);\n+\n+    // Extract the correct argument\n+    let value = {\n+        #[cfg(bootstrap)]\n+        {\n+            match arg.position {\n+                rt::v1::Position::At(i) => args[i],\n+            }\n+        }\n+        #[cfg(not(bootstrap))]\n+        {\n+            args[arg.position]\n+        }\n+    };\n+\n+    // Then actually do some printing\n+    (value.formatter)(value.value, fmt)\n+}\n+\n+fn getcount(args: &[ArgumentV1<'_>], cnt: &rt::v1::Count) -> Option<usize> {\n+    match *cnt {\n+        rt::v1::Count::Is(n) => Some(n),\n+        rt::v1::Count::Implied => None,\n+        rt::v1::Count::Param(i) => args[i].as_usize(),\n+    }\n+}\n+\n /// Padding after the end of something. Returned by `Formatter::padding`.\n #[must_use = \"don't forget to write the post padding\"]\n struct PostPadding {\n@@ -1114,41 +1142,6 @@ impl<'a> Formatter<'a> {\n             align: self.align,\n             width: self.width,\n             precision: self.precision,\n-\n-            // These only exist in the struct for the `run` method,\n-            // which won\u2019t be used together with this method.\n-            curarg: self.curarg.clone(),\n-            args: self.args,\n-        }\n-    }\n-\n-    // First up is the collection of functions used to execute a format string\n-    // at runtime. This consumes all of the compile-time statics generated by\n-    // the format! syntax extension.\n-    fn run(&mut self, arg: &rt::v1::Argument) -> Result {\n-        // Fill in the format parameters into the formatter\n-        self.fill = arg.format.fill;\n-        self.align = arg.format.align;\n-        self.flags = arg.format.flags;\n-        self.width = self.getcount(&arg.format.width);\n-        self.precision = self.getcount(&arg.format.precision);\n-\n-        // Extract the correct argument\n-        let value = match arg.position {\n-            rt::v1::Position::Next => *self.curarg.next().unwrap(),\n-            rt::v1::Position::At(i) => self.args[i],\n-        };\n-\n-        // Then actually do some printing\n-        (value.formatter)(value.value, self)\n-    }\n-\n-    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n-        match *cnt {\n-            rt::v1::Count::Is(n) => Some(n),\n-            rt::v1::Count::Implied => None,\n-            rt::v1::Count::Param(i) => self.args[i].as_usize(),\n-            rt::v1::Count::NextParam => self.curarg.next()?.as_usize(),\n         }\n     }\n "}, {"sha": "fd81f93242b89e5cc8a31c8d547012424ce48697", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=e1bd9b33963f51620980ee1450a64ed12e104934", "patch": "@@ -7,7 +7,10 @@\n \n #[derive(Copy, Clone)]\n pub struct Argument {\n+    #[cfg(bootstrap)]\n     pub position: Position,\n+    #[cfg(not(bootstrap))]\n+    pub position: usize,\n     pub format: FormatSpec,\n }\n \n@@ -37,12 +40,11 @@ pub enum Alignment {\n pub enum Count {\n     Is(usize),\n     Param(usize),\n-    NextParam,\n     Implied,\n }\n \n+#[cfg(bootstrap)]\n #[derive(Copy, Clone)]\n pub enum Position {\n-    Next,\n     At(usize),\n }"}, {"sha": "3f4e24ca993db4a14c5c619ba9b215c655400875", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=e1bd9b33963f51620980ee1450a64ed12e104934", "patch": "@@ -590,17 +590,6 @@ impl<'a, 'b> Context<'a, 'b> {\n             parse::NextArgument(ref arg) => {\n                 // Build the position\n                 let pos = {\n-                    let pos = |c, arg| {\n-                        let mut path = Context::rtpath(self.ecx, \"Position\");\n-                        path.push(self.ecx.ident_of(c, sp));\n-                        match arg {\n-                            Some(i) => {\n-                                let arg = self.ecx.expr_usize(sp, i);\n-                                self.ecx.expr_call_global(sp, path, vec![arg])\n-                            }\n-                            None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n-                        }\n-                    };\n                     match arg.position {\n                         parse::ArgumentIs(i) | parse::ArgumentImplicitlyIs(i) => {\n                             // Map to index in final generated argument array\n@@ -615,7 +604,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                     arg_idx\n                                 }\n                             };\n-                            pos(\"At\", Some(arg_idx))\n+                            self.ecx.expr_usize(sp, arg_idx)\n                         }\n \n                         // should never be the case, because names are already"}, {"sha": "ceeebbca5195a3584af408e1ee3502588e542479", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=e1bd9b33963f51620980ee1450a64ed12e104934", "patch": "@@ -2,15 +2,15 @@\n // edition:2018\n // compile-flags: --crate-type lib\n \n-use std::{\n-    cell::RefCell,\n-    fmt::Debug,\n-    rc::Rc,\n-};\n+use std::{cell::RefCell, fmt::Debug, rc::Rc};\n \n-fn non_sync() -> impl Debug { RefCell::new(()) }\n+fn non_sync() -> impl Debug {\n+    RefCell::new(())\n+}\n \n-fn non_send() -> impl Debug { Rc::new(()) }\n+fn non_send() -> impl Debug {\n+    Rc::new(())\n+}\n \n fn take_ref<T>(_: &T) {}\n \n@@ -53,5 +53,4 @@ pub fn pass_assert() {\n     //~^ ERROR future cannot be sent between threads safely\n     assert_send(non_sync_with_method_call());\n     //~^ ERROR future cannot be sent between threads safely\n-    //~^^ ERROR future cannot be sent between threads safely\n }"}, {"sha": "105fd23ecfb6639d5ea5cdcc28da7d3490fde923", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1bd9b33963f51620980ee1450a64ed12e104934/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=e1bd9b33963f51620980ee1450a64ed12e104934", "patch": "@@ -62,27 +62,5 @@ LL |     }\n LL | }\n    | - `f` is later dropped here\n \n-error: future cannot be sent between threads safely\n-  --> $DIR/async-fn-nonsend.rs:54:5\n-   |\n-LL | fn assert_send(_: impl Send) {}\n-   |    -----------         ---- required by this bound in `assert_send`\n-...\n-LL |     assert_send(non_sync_with_method_call());\n-   |     ^^^^^^^^^^^ future returned by `non_sync_with_method_call` is not `Send`\n-   |\n-   = help: within `std::fmt::ArgumentV1<'_>`, the trait `std::marker::Sync` is not implemented for `*mut (dyn std::ops::Fn() + 'static)`\n-note: future is not `Send` as this value is used across an await\n-  --> $DIR/async-fn-nonsend.rs:43:9\n-   |\n-LL |     let f: &mut std::fmt::Formatter = panic!();\n-   |         - has type `&mut std::fmt::Formatter<'_>`\n-LL |     if non_sync().fmt(f).unwrap() == () {\n-LL |         fut().await;\n-   |         ^^^^^^^^^^^ await occurs here, with `f` maybe used later\n-LL |     }\n-LL | }\n-   | - `f` is later dropped here\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}]}