{"sha": "73f8adcbc830b3099026832eadb1ee5f876e041b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZjhhZGNiYzgzMGIzMDk5MDI2ODMyZWFkYjFlZTVmODc2ZTA0MWI=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-08-01T19:27:12Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@mozilla.com", "date": "2014-09-05T16:18:57Z"}, "message": "make separate compilation respect #[inline] attributes\n\nAdjust the handling of `#[inline]` items so that they get translated into every\ncompilation unit that uses them.  This is necessary to preserve the semantics\nof `#[inline(always)]`.\n\nCrate-local `#[inline]` functions and statics are blindly translated into every\ncompilation unit.  Cross-crate inlined items and monomorphizations of\n`#[inline]` functions are translated the first time a reference is seen in each\ncompilation unit.  When using multiple compilation units, inlined items are\ngiven `available_externally` linkage whenever possible to avoid duplicating\nobject code.", "tree": {"sha": "874582eb457b438645cbef6c8ce4e3cda57817dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/874582eb457b438645cbef6c8ce4e3cda57817dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73f8adcbc830b3099026832eadb1ee5f876e041b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73f8adcbc830b3099026832eadb1ee5f876e041b", "html_url": "https://github.com/rust-lang/rust/commit/73f8adcbc830b3099026832eadb1ee5f876e041b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73f8adcbc830b3099026832eadb1ee5f876e041b/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edc5cdcba2c217d3a4d75801190cc34096ee80c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/edc5cdcba2c217d3a4d75801190cc34096ee80c2", "html_url": "https://github.com/rust-lang/rust/commit/edc5cdcba2c217d3a4d75801190cc34096ee80c2"}], "stats": {"total": 248, "additions": 190, "deletions": 58}, "files": [{"sha": "49e058333e523212c068aede51b0559f1209dd20", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 74, "deletions": 24, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=73f8adcbc830b3099026832eadb1ee5f876e041b", "patch": "@@ -2125,12 +2125,43 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n     }\n }\n \n+/// Enum describing the origin of an LLVM `Value`, for linkage purposes.\n+pub enum ValueOrigin {\n+    /// The LLVM `Value` is in this context because the corresponding item was\n+    /// assigned to the current compilation unit.\n+    OriginalTranslation,\n+    /// The `Value`'s corresponding item was assigned to some other compilation\n+    /// unit, but the `Value` was translated in this context anyway because the\n+    /// item is marked `#[inline]`.\n+    InlinedCopy,\n+}\n+\n /// Set the appropriate linkage for an LLVM `ValueRef` (function or global).\n /// If the `llval` is the direct translation of a specific Rust item, `id`\n /// should be set to the `NodeId` of that item.  (This mapping should be\n /// 1-to-1, so monomorphizations and drop/visit glue should have `id` set to\n-/// `None`.)\n-pub fn update_linkage(ccx: &CrateContext, llval: ValueRef, id: Option<ast::NodeId>) {\n+/// `None`.)  `llval_origin` indicates whether `llval` is the translation of an\n+/// item assigned to `ccx`'s compilation unit or an inlined copy of an item\n+/// assigned to a different compilation unit.\n+pub fn update_linkage(ccx: &CrateContext,\n+                      llval: ValueRef,\n+                      id: Option<ast::NodeId>,\n+                      llval_origin: ValueOrigin) {\n+    match llval_origin {\n+        InlinedCopy => {\n+            // `llval` is a translation of an item defined in a separate\n+            // compilation unit.  This only makes sense if there are at least\n+            // two compilation units.\n+            assert!(ccx.sess().opts.cg.codegen_units > 1);\n+            // `llval` is a copy of something defined elsewhere, so use\n+            // `AvailableExternallyLinkage` to avoid duplicating code in the\n+            // output.\n+            llvm::SetLinkage(llval, llvm::AvailableExternallyLinkage);\n+            return;\n+        },\n+        OriginalTranslation => {},\n+    }\n+\n     match id {\n         Some(id) if ccx.reachable().contains(&id) => {\n             llvm::SetLinkage(llval, llvm::ExternalLinkage);\n@@ -2149,29 +2180,41 @@ pub fn update_linkage(ccx: &CrateContext, llval: ValueRef, id: Option<ast::NodeI\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n \n+    let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n+\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let llfn = get_item_val(ccx, item.id);\n-            if abi != Rust {\n-                foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                        &**decl,\n-                                                        &**body,\n-                                                        item.attrs.as_slice(),\n-                                                        llfn,\n-                                                        &param_substs::empty(),\n-                                                        item.id,\n-                                                        None);\n-            } else {\n-                trans_fn(ccx,\n-                         &**decl,\n-                         &**body,\n-                         llfn,\n-                         &param_substs::empty(),\n-                         item.id,\n-                         item.attrs.as_slice());\n+            let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n+            // Ignore `trans_everywhere` for cross-crate inlined items\n+            // (`from_external`).  `trans_item` will be called once for each\n+            // compilation unit that references the item, so it will still get\n+            // translated everywhere it's needed.\n+            for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n+                let llfn = get_item_val(ccx, item.id);\n+                if abi != Rust {\n+                    foreign::trans_rust_fn_with_foreign_abi(ccx,\n+                                                            &**decl,\n+                                                            &**body,\n+                                                            item.attrs.as_slice(),\n+                                                            llfn,\n+                                                            &param_substs::empty(),\n+                                                            item.id,\n+                                                            None);\n+                } else {\n+                    trans_fn(ccx,\n+                             &**decl,\n+                             &**body,\n+                             llfn,\n+                             &param_substs::empty(),\n+                             item.id,\n+                             item.attrs.as_slice());\n+                }\n+                update_linkage(ccx,\n+                               llfn,\n+                               Some(item.id),\n+                               if is_origin { OriginalTranslation } else { InlinedCopy });\n             }\n-            update_linkage(ccx, llfn, Some(item.id));\n         }\n \n         // Be sure to travel more than just one layer deep to catch nested\n@@ -2196,10 +2239,17 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr, ());\n-          consts::trans_const(ccx, m, item.id);\n \n-          let g = get_item_val(ccx, item.id);\n-          update_linkage(ccx, g, Some(item.id));\n+          let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n+          for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n+              consts::trans_const(ccx, m, item.id);\n+\n+              let g = get_item_val(ccx, item.id);\n+              update_linkage(ccx,\n+                             g,\n+                             Some(item.id),\n+                             if is_origin { OriginalTranslation } else { InlinedCopy });\n+          }\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM"}, {"sha": "5bdd5f6739d61428516782da7e8acbbed27eafc5", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=73f8adcbc830b3099026832eadb1ee5f876e041b", "patch": "@@ -155,6 +155,9 @@ pub struct LocalCrateContext {\n pub struct CrateContext<'a> {\n     shared: &'a SharedCrateContext,\n     local: &'a LocalCrateContext,\n+    /// The index of `local` in `shared.local_ccxs`.  This is used in\n+    /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n+    index: uint,\n }\n \n pub struct CrateContextIterator<'a> {\n@@ -174,10 +177,41 @@ impl<'a> Iterator<CrateContext<'a>> for CrateContextIterator<'a> {\n         Some(CrateContext {\n             shared: self.shared,\n             local: &self.shared.local_ccxs[index],\n+            index: index,\n         })\n     }\n }\n \n+/// The iterator produced by `CrateContext::maybe_iter`.\n+pub struct CrateContextMaybeIterator<'a> {\n+    shared: &'a SharedCrateContext,\n+    index: uint,\n+    single: bool,\n+    origin: uint,\n+}\n+\n+impl<'a> Iterator<(CrateContext<'a>, bool)> for CrateContextMaybeIterator<'a> {\n+    fn next(&mut self) -> Option<(CrateContext<'a>, bool)> {\n+        if self.index >= self.shared.local_ccxs.len() {\n+            return None;\n+        }\n+\n+        let index = self.index;\n+        self.index += 1;\n+        if self.single {\n+            self.index = self.shared.local_ccxs.len();\n+        }\n+\n+        let ccx = CrateContext {\n+            shared: self.shared,\n+            local: &self.shared.local_ccxs[index],\n+            index: index,\n+        };\n+        Some((ccx, index == self.origin))\n+    }\n+}\n+\n+\n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let llmod = mod_name.with_c_str(|buf| {\n@@ -270,18 +304,21 @@ impl SharedCrateContext {\n         CrateContext {\n             shared: self,\n             local: &self.local_ccxs[index],\n+            index: index,\n         }\n     }\n \n     fn get_smallest_ccx<'a>(&'a self) -> CrateContext<'a> {\n-        let local_ccx =\n+        let (local_ccx, index) =\n             self.local_ccxs\n                 .iter()\n-                .min_by(|&local_ccx| local_ccx.n_llvm_insns.get())\n+                .zip(range(0, self.local_ccxs.len()))\n+                .min_by(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n                 .unwrap();\n         CrateContext {\n             shared: self,\n             local: local_ccx,\n+            index: index,\n         }\n     }\n \n@@ -426,6 +463,7 @@ impl LocalCrateContext {\n         CrateContext {\n             shared: shared,\n             local: self,\n+            index: -1 as uint,\n         }\n     }\n }\n@@ -446,6 +484,22 @@ impl<'b> CrateContext<'b> {\n         self.shared.get_smallest_ccx()\n     }\n \n+    /// Either iterate over only `self`, or iterate over all `CrateContext`s in\n+    /// the `SharedCrateContext`.  The iterator produces `(ccx, is_origin)`\n+    /// pairs, where `is_origin` is `true` if `ccx` is `self` and `false`\n+    /// otherwise.  This method is useful for avoiding code duplication in\n+    /// cases where it may or may not be necessary to translate code into every\n+    /// context.\n+    pub fn maybe_iter(&self, iter_all: bool) -> CrateContextMaybeIterator<'b> {\n+        CrateContextMaybeIterator {\n+            shared: self.shared,\n+            index: if iter_all { 0 } else { self.index },\n+            single: !iter_all,\n+            origin: self.index,\n+        }\n+    }\n+\n+\n     pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         &self.shared.tcx\n     }"}, {"sha": "c8a47532a923ac8cb412a96d2dd79a3f054ba2d6", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=73f8adcbc830b3099026832eadb1ee5f876e041b", "patch": "@@ -669,7 +669,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let bcx = init_function(&fcx, false, ty::mk_nil());\n \n-    update_linkage(ccx, llfn, None);\n+    update_linkage(ccx, llfn, None, OriginalTranslation);\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1u);\n     // All glue functions take values passed *by alias*; this is a"}, {"sha": "c002f3e72c89f753ef4b4a9c82176541e2109324", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=73f8adcbc830b3099026832eadb1ee5f876e041b", "patch": "@@ -38,7 +38,7 @@ use util::ppaux::Repr;\n use std::c_str::ToCStr;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n-use syntax::{ast, ast_map, visit};\n+use syntax::{ast, ast_map, attr, visit};\n use syntax::ast_util::PostExpansionMethod;\n \n // drop_glue pointer, size, align.\n@@ -77,15 +77,21 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let llfn = get_item_val(ccx, method.id);\n-                    trans_fn(ccx,\n-                             &*method.pe_fn_decl(),\n-                             &*method.pe_body(),\n-                             llfn,\n-                             &param_substs::empty(),\n-                             method.id,\n-                             []);\n-                    update_linkage(ccx, llfn, Some(method.id));\n+                    let trans_everywhere = attr::requests_inline(method.attrs.as_slice());\n+                    for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n+                        let llfn = get_item_val(ccx, method.id);\n+                        trans_fn(ccx,\n+                                 &*method.pe_fn_decl(),\n+                                 &*method.pe_body(),\n+                                 llfn,\n+                                 &param_substs::empty(),\n+                                 method.id,\n+                                 []);\n+                        update_linkage(ccx,\n+                                       llfn,\n+                                       Some(method.id),\n+                                       if is_origin { OriginalTranslation } else { InlinedCopy });\n+                    }\n                 }\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,"}, {"sha": "1cf3e55967d4e5b65013f040a5772b74e18818d2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=73f8adcbc830b3099026832eadb1ee5f876e041b", "patch": "@@ -11,6 +11,7 @@\n use back::link::exported_name;\n use driver::session;\n use llvm::ValueRef;\n+use llvm;\n use middle::subst;\n use middle::subst::Subst;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n@@ -27,6 +28,7 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n+use syntax::attr;\n use std::hash::{sip, Hash};\n \n pub fn monomorphic_fn(ccx: &CrateContext,\n@@ -150,6 +152,25 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n+    let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n+        base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n+        set_llvm_fn_attrs(attrs, lldecl);\n+\n+        let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n+        if is_first {\n+            ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+        }\n+\n+        let trans_everywhere = attr::requests_inline(attrs);\n+        if trans_everywhere && !is_first {\n+            llvm::SetLinkage(lldecl, llvm::AvailableExternallyLinkage);\n+        }\n+\n+        // If `true`, then `lldecl` should be given a function body.\n+        // Otherwise, it should be left as a declaration of an external\n+        // function, with no definition in the current compilation unit.\n+        trans_everywhere || is_first\n+    };\n \n     let lldecl = match map_node {\n         ast_map::NodeItem(i) => {\n@@ -159,11 +180,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  base::update_linkage(ccx, d, None);\n-                  set_llvm_fn_attrs(i.attrs.as_slice(), d);\n-\n-                  if !ccx.available_monomorphizations().borrow().contains(&s) {\n-                      ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+                  let needs_body = setup_lldecl(d, i.attrs.as_slice());\n+                  if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, [], d, &psubsts, fn_id.node,\n@@ -205,17 +223,15 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             match *ii {\n                 ast::MethodImplItem(mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    base::update_linkage(ccx, d, None);\n-                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    if !ccx.available_monomorphizations().borrow().contains(&s) {\n-                        ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n-                            trans_fn(ccx,\n-                                     &*mth.pe_fn_decl(),\n-                                     &*mth.pe_body(),\n-                                     d,\n-                                     &psubsts,\n-                                     mth.id,\n-                                     []);\n+                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    if needs_body {\n+                        trans_fn(ccx,\n+                                 &*mth.pe_fn_decl(),\n+                                 &*mth.pe_body(),\n+                                 d,\n+                                 &psubsts,\n+                                 mth.id,\n+                                 []);\n                     }\n                     d\n                 }\n@@ -225,10 +241,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             match *method {\n                 ast::ProvidedMethod(mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    base::update_linkage(ccx, d, None);\n-                    set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    if !ccx.available_monomorphizations().borrow().contains(&s) {\n-                        ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+                    let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n+                    if needs_body {\n                         trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,\n                                  &psubsts, mth.id, []);\n                     }"}, {"sha": "dd422d021493fdd4d802681779d5987137822853", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73f8adcbc830b3099026832eadb1ee5f876e041b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=73f8adcbc830b3099026832eadb1ee5f876e041b", "patch": "@@ -280,7 +280,7 @@ pub enum InlineAttr {\n     InlineNever,\n }\n \n-/// True if something like #[inline] is found in the list of attrs.\n+/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n@@ -304,6 +304,14 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     })\n }\n \n+/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n+pub fn requests_inline(attrs: &[Attribute]) -> bool {\n+    match find_inline_attr(attrs) {\n+        InlineHint | InlineAlways => true,\n+        InlineNone | InlineNever => false,\n+    }\n+}\n+\n /// Tests if any `cfg(...)` meta items in `metas` match `cfg`. e.g.\n ///\n /// test_cfg(`[foo=\"a\", bar]`, `[cfg(foo), cfg(bar)]`) == true"}]}