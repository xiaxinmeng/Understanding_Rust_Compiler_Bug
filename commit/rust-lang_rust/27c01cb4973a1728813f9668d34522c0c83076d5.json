{"sha": "27c01cb4973a1728813f9668d34522c0c83076d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YzAxY2I0OTczYTE3Mjg4MTNmOTY2OGQzNDUyMmMwYzgzMDc2ZDU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-04-28T10:42:42Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-04-30T23:04:45Z"}, "message": "Add process types documentation", "tree": {"sha": "ef0e007fc82693a12bff07431fb52cb0be812b31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef0e007fc82693a12bff07431fb52cb0be812b31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27c01cb4973a1728813f9668d34522c0c83076d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27c01cb4973a1728813f9668d34522c0c83076d5", "html_url": "https://github.com/rust-lang/rust/commit/27c01cb4973a1728813f9668d34522c0c83076d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27c01cb4973a1728813f9668d34522c0c83076d5/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e07e34c4b0ccdc0feecd49091682e6cc365b279a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e07e34c4b0ccdc0feecd49091682e6cc365b279a", "html_url": "https://github.com/rust-lang/rust/commit/e07e34c4b0ccdc0feecd49091682e6cc365b279a"}], "stats": {"total": 200, "additions": 196, "deletions": 4}, "files": [{"sha": "7a86e726b3a6ae3a33f6aac26519fdac33146e41", "filename": "src/libstd/process.rs", "status": "modified", "additions": 196, "deletions": 4, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/27c01cb4973a1728813f9668d34522c0c83076d5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c01cb4973a1728813f9668d34522c0c83076d5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=27c01cb4973a1728813f9668d34522c0c83076d5", "patch": "@@ -215,19 +215,58 @@ impl Command {\n     ///\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"sh\")\n+    ///         .spawn()\n+    ///         .expect(\"sh command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n         Command { inner: imp::Command::new(program.as_ref()) }\n     }\n \n     /// Add an argument to pass to the program.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .arg(\"-l\")\n+    ///         .arg(\"-a\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {\n         self.inner.arg(arg.as_ref());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .args(&[\"-l\", \"-a\"])\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {\n         for arg in args {\n@@ -240,6 +279,19 @@ impl Command {\n     ///\n     /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n     /// and case-sensitive on all other platforms.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .env(\"PATH\", \"/bin\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n         where K: AsRef<OsStr>, V: AsRef<OsStr>\n@@ -249,41 +301,119 @@ impl Command {\n     }\n \n     /// Removes an environment variable mapping.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .env_remove(\"PATH\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n         self.inner.env_remove(key.as_ref());\n         self\n     }\n \n     /// Clears the entire environment map for the child process.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .env_clear()\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env_clear(&mut self) -> &mut Command {\n         self.inner.env_clear();\n         self\n     }\n \n     /// Sets the working directory for the child process.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .current_dir(\"/bin\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsRef<Path>>(&mut self, dir: P) -> &mut Command {\n         self.inner.cwd(dir.as_ref().as_ref());\n         self\n     }\n \n     /// Configuration for the child process's stdin handle (file descriptor 0).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .stdin(Stdio::null())\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n         self.inner.stdin(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .stdout(Stdio::null())\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n         self.inner.stdout(cfg.0);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::{Command, Stdio};\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .stderr(Stdio::null())\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n         self.inner.stderr(cfg.0);\n@@ -293,6 +423,18 @@ impl Command {\n     /// Executes the command as a child process, returning a handle to it.\n     ///\n     /// By default, stdin, stdout and stderr are inherited from the parent.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// Command::new(\"ls\")\n+    ///         .spawn()\n+    ///         .expect(\"ls command failed to start\");\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n         self.inner.spawn(imp::Stdio::Inherit, true).map(Child::from_inner)\n@@ -308,8 +450,10 @@ impl Command {\n     ///\n     /// ```should_panic\n     /// use std::process::Command;\n-    /// let output = Command::new(\"/bin/cat\").arg(\"file.txt\").output()\n-    ///     .expect(\"failed to execute process\");\n+    /// let output = Command::new(\"/bin/cat\")\n+    ///                      .arg(\"file.txt\")\n+    ///                      .output()\n+    ///                      .expect(\"failed to execute process\");\n     ///\n     /// println!(\"status: {}\", output.status);\n     /// println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n@@ -333,8 +477,10 @@ impl Command {\n     /// ```should_panic\n     /// use std::process::Command;\n     ///\n-    /// let status = Command::new(\"/bin/cat\").arg(\"file.txt\").status()\n-    ///     .expect(\"failed to execute process\");\n+    /// let status = Command::new(\"/bin/cat\")\n+    ///                      .arg(\"file.txt\")\n+    ///                      .status()\n+    ///                      .expect(\"failed to execute process\");\n     ///\n     /// println!(\"process exited with: {}\", status);\n     ///\n@@ -469,12 +615,42 @@ impl fmt::Display for ExitStatus {\n impl Child {\n     /// Forces the child to exit. This is equivalent to sending a\n     /// SIGKILL on unix platforms.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let mut command = Command::new(\"yes\");\n+    /// if let Ok(mut child) = command.spawn() {\n+    ///     child.kill().expect(\"command wasn't running\");\n+    /// } else {\n+    ///     println!(\"yes command didn't start\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn kill(&mut self) -> io::Result<()> {\n         self.handle.kill()\n     }\n \n     /// Returns the OS-assigned process identifier associated with this child.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let mut command = Command::new(\"ls\");\n+    /// if let Ok(child) = command.spawn() {\n+    ///     println!(\"Child's id is {}\", child.id());\n+    /// } else {\n+    ///     println!(\"ls command didn't start\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process_id\", since = \"1.3.0\")]\n     pub fn id(&self) -> u32 {\n         self.handle.id()\n@@ -488,6 +664,22 @@ impl Child {\n     /// before waiting. This helps avoid deadlock: it ensures that the\n     /// child does not block waiting for input from the parent, while\n     /// the parent waits for the child to exit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let mut command = Command::new(\"ls\");\n+    /// if let Ok(mut child) = command.spawn() {\n+    ///     child.wait().expect(\"command wasn't running\");\n+    ///     println!(\"Child has finished its execution!\");\n+    /// } else {\n+    ///     println!(\"ls command didn't start\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         drop(self.stdin.take());"}]}