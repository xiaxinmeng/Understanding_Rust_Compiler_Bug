{"sha": "c7ad3ad99128b904fafb17ee8ee8889bfcaf5170", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YWQzYWQ5OTEyOGI5MDRmYWZiMTdlZThlZTg4ODliZmNhZjUxNzA=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-14T12:53:36Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-06-14T12:53:36Z"}, "message": "_match.rs: fix module doc comment\n\nIt was applied to a `use` item, not to the module", "tree": {"sha": "31a9bbf1d278729f70e0f56355bcc715a8c6d3a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31a9bbf1d278729f70e0f56355bcc715a8c6d3a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ad3ad99128b904fafb17ee8ee8889bfcaf5170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ad3ad99128b904fafb17ee8ee8889bfcaf5170", "html_url": "https://github.com/rust-lang/rust/commit/c7ad3ad99128b904fafb17ee8ee8889bfcaf5170", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ad3ad99128b904fafb17ee8ee8889bfcaf5170/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06e47688bf15d0215edbe05b21603062f6d2eb5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/06e47688bf15d0215edbe05b21603062f6d2eb5d", "html_url": "https://github.com/rust-lang/rust/commit/06e47688bf15d0215edbe05b21603062f6d2eb5d"}], "stats": {"total": 542, "additions": 271, "deletions": 271}, "files": [{"sha": "4a4de6c420bd80d86b472f26dcb40af7ef533e13", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 271, "deletions": 271, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/c7ad3ad99128b904fafb17ee8ee8889bfcaf5170/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ad3ad99128b904fafb17ee8ee8889bfcaf5170/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=c7ad3ad99128b904fafb17ee8ee8889bfcaf5170", "patch": "@@ -1,274 +1,274 @@\n-/// Note: most of the tests relevant to this file can be found (at the time of writing) in\n-/// src/tests/ui/pattern/usefulness.\n-///\n-/// This file includes the logic for exhaustiveness and usefulness checking for\n-/// pattern-matching. Specifically, given a list of patterns for a type, we can\n-/// tell whether:\n-/// (a) the patterns cover every possible constructor for the type [exhaustiveness]\n-/// (b) each pattern is necessary [usefulness]\n-///\n-/// The algorithm implemented here is a modified version of the one described in:\n-/// http://moscova.inria.fr/~maranget/papers/warn/index.html\n-/// However, to save future implementors from reading the original paper, we\n-/// summarise the algorithm here to hopefully save time and be a little clearer\n-/// (without being so rigorous).\n-///\n-/// # Premise\n-///\n-/// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-/// are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-/// a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-/// `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-/// uncovered values of the type).\n-///\n-/// If we have this predicate, then we can easily compute both exhaustiveness of an\n-/// entire set of patterns and the individual usefulness of each one.\n-/// (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-/// match doesn't increase the number of values we're matching)\n-/// (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-/// pattern to those that have come before it doesn't increase the number of values\n-/// we're matching).\n-///\n-/// # Core concept\n-///\n-/// The idea that powers everything that is done in this file is the following: a value is made\n-/// from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n-/// (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n-/// constructor for the number `2`). Fields are just a (possibly empty) list of values.\n-///\n-/// Some of the constructors listed above might feel weird: `None` and `2` don't take any\n-/// arguments. This is part of what makes constructors so general: we will consider plain values\n-/// like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n-/// constructors\"; they are the simplest case of constructors. This allows us to see any value as\n-/// made up from a tree of constructors, each having a given number of children. For example:\n-/// `(None, Ok(0))` is made from 4 different constructors.\n-///\n-/// This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n-/// describe this set using constructors. For example, `Err(_)` captures all values of the type\n-/// `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n-/// wildcard `_` captures all values of the given type starting with any of the constructors for\n-/// that type.\n-///\n-/// We use this to compute whether different patterns might capture a same value. Do the patterns\n-/// `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n-/// captures only values starting with the `Ok` constructor and the second only values starting\n-/// with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n-/// since they both capture values starting with `Some`. To be certain, we need to dig under the\n-/// `Some` constructor and continue asking the question. This is the main idea behind the\n-/// exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n-/// figure out if some new pattern might capture a value that hadn't been captured by previous\n-/// patterns.\n-///\n-/// Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n-/// Most of the complexity of this file resides in transforming between patterns and\n-/// (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n-///\n-/// Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n-/// a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n-/// However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n-///\n-///\n-/// # Algorithm\n-///\n-/// Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n-/// adding a new pattern `p` will cover previously-uncovered values of the type.\n-/// During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-/// but rather partially-deconstructed patterns in the form of a list of fields. The paper\n-/// calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-/// new pattern `p`.\n-///\n-/// For example, say we have the following:\n-/// ```\n-///     // x: (Option<bool>, Result<()>)\n-///     match x {\n-///         (Some(true), _) => {}\n-///         (None, Err(())) => {}\n-///         (None, Err(_)) => {}\n-///     }\n-/// ```\n-/// Here, the matrix `P` starts as:\n-/// [\n-///     [(Some(true), _)],\n-///     [(None, Err(()))],\n-///     [(None, Err(_))],\n-/// ]\n-/// We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-/// `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-/// all the values it covers are already covered by row 2.\n-///\n-/// A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-/// the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-/// To match the paper, the top of the stack is at the beginning / on the left.\n-///\n-/// There are two important operations on pattern-stacks necessary to understand the algorithm:\n-///     1. We can pop a given constructor off the top of a stack. This operation is called\n-///        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-///        `None`) and `p` a pattern-stack.\n-///        If the pattern on top of the stack can cover `c`, this removes the constructor and\n-///        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-///        Otherwise the pattern-stack is discarded.\n-///        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-///        discards the others.\n-///\n-///        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-///        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-///        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-///        nothing back.\n-///\n-///        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-///        on top of the stack, and we have four cases:\n-///             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n-///                  push onto the stack the arguments of this constructor, and return the result:\n-///                     r_1, .., r_a, p_2, .., p_n\n-///             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n-///                  return nothing.\n-///             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-///                  arguments (its arity), and return the resulting stack:\n-///                     _, .., _, p_2, .., p_n\n-///             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-///                  stack:\n-///                     S(c, (r_1, p_2, .., p_n))\n-///                     S(c, (r_2, p_2, .., p_n))\n-///\n-///     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-///        a pattern-stack.\n-///        This is used when we know there are missing constructor cases, but there might be\n-///        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-///        all its *other* components.\n-///\n-///        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-///        and we have three cases:\n-///             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-///             1.2. `p_1 = _`. We return the rest of the stack:\n-///                     p_2, .., p_n\n-///             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n-///               stack.\n-///                     D((r_1, p_2, .., p_n))\n-///                     D((r_2, p_2, .., p_n))\n-///\n-///     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-///     exhaustive integer matching rules, so they're written here for posterity.\n-///\n-/// Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-/// working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-/// the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n-///\n-///\n-/// The algorithm for computing `U`\n-/// -------------------------------\n-/// The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-/// That means we're going to check the components from left-to-right, so the algorithm\n-/// operates principally on the first component of the matrix and new pattern-stack `p`.\n-/// This algorithm is realised in the `is_useful` function.\n-///\n-/// Base case. (`n = 0`, i.e., an empty tuple pattern)\n-///     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n-///       then `U(P, p)` is false.\n-///     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n-///\n-/// Inductive step. (`n > 0`, i.e., whether there's at least one column\n-///                  [which may then be expanded into further columns later])\n-///     We're going to match on the top of the new pattern-stack, `p_1`.\n-///         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-///           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-///           we ignore all the patterns in the first column of `P` that involve other constructors.\n-///           This is where `S(c, P)` comes in:\n-///           `U(P, p) := U(S(c, P), S(c, p))`\n-///           This special case is handled in `is_useful_specialized`.\n-///\n-///           For example, if `P` is:\n-///           [\n-///               [Some(true), _],\n-///               [None, 0],\n-///           ]\n-///           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n-///           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-///           arguments of `Some` to know whether some new value is covered. So we compute\n-///           `U([[true, _]], [false, 0])`.\n-///\n-///         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n-///               component of the rows of `P`:\n-///             + If there are some constructors that aren't present, then we might think that the\n-///               wildcard `_` is useful, since it covers those constructors that weren't covered\n-///               before.\n-///               That's almost correct, but only works if there were no wildcards in those first\n-///               components. So we need to check that `p` is useful with respect to the rows that\n-///               start with a wildcard, if there are any. This is where `D` comes in:\n-///               `U(P, p) := U(D(P), D(p))`\n-///\n-///               For example, if `P` is:\n-///               [\n-///                   [_, true, _],\n-///                   [None, false, 1],\n-///               ]\n-///               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n-///               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-///               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n-///\n-///             + Otherwise, all possible constructors (for the relevant type) are present. In this\n-///               case we must check whether the wildcard pattern covers any unmatched value. For\n-///               that, we can think of the `_` pattern as a big OR-pattern that covers all\n-///               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-///               example. The wildcard pattern is useful in this case if it is useful when\n-///               specialized to one of the possible constructors. So we compute:\n-///               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n-///\n-///               For example, if `P` is:\n-///               [\n-///                   [Some(true), _],\n-///                   [None, false],\n-///               ]\n-///               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n-///               components of `P`. We will therefore try popping both constructors in turn: we\n-///               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n-///               [false]) for the `None` constructor. The first case returns true, so we know that\n-///               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-///               before.\n-///\n-///         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-///           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n-///                    || U(P, (r_2, p_2, .., p_n))`\n-///\n-/// Modifications to the algorithm\n-/// ------------------------------\n-/// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n-/// example uninhabited types and variable-length slice patterns. These are drawn attention to\n-/// throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n-/// accounted for, though.\n-///\n-/// Exhaustive integer matching\n-/// ---------------------------\n-/// An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n-/// So to support exhaustive integer matching, we can make use of the logic in the paper for\n-/// OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n-/// they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n-/// that we have a constructor *of* constructors (the integers themselves). We then need to work\n-/// through all the inductive step rules above, deriving how the ranges would be treated as\n-/// OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n-/// There are really only four special cases here:\n-/// - When we match on a constructor that's actually a range, we have to treat it as if we would\n-///   an OR-pattern.\n-///     + It turns out that we can simply extend the case for single-value patterns in\n-///      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n-///      constructor.\n-///     + When the pattern itself is a range, you just want to tell whether any of the values in\n-///       the pattern range coincide with values in the constructor range, which is precisely\n-///       intersection.\n-///   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n-///   means that whenever the constructor is a value/range and the pattern is also a value/range,\n-///   we can simply use intersection to test usefulness.\n-/// - When we're testing for usefulness of a pattern and the pattern's first component is a\n-///   wildcard.\n-///     + If all the constructors appear in the matrix, we have a slight complication. By default,\n-///       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n-///       invalid, because we want a disjunction over every *integer* in each range, not just a\n-///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n-///       to form equivalence classes of subranges of the constructor range for which the behaviour\n-///       of the matrix `P` and new pattern `p` are the same. This is described in more\n-///       detail in `split_grouped_constructors`.\n-///     + If some constructors are missing from the matrix, it turns out we don't need to do\n-///       anything special (because we know none of the integers are actually wildcards: i.e., we\n-///       can't span wildcards using ranges).\n+//! Note: most of the tests relevant to this file can be found (at the time of writing) in\n+//! src/tests/ui/pattern/usefulness.\n+//!\n+//! This file includes the logic for exhaustiveness and usefulness checking for\n+//! pattern-matching. Specifically, given a list of patterns for a type, we can\n+//! tell whether:\n+//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+//! (b) each pattern is necessary [usefulness]\n+//!\n+//! The algorithm implemented here is a modified version of the one described in:\n+//! http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//! However, to save future implementors from reading the original paper, we\n+//! summarise the algorithm here to hopefully save time and be a little clearer\n+//! (without being so rigorous).\n+//!\n+//! # Premise\n+//!\n+//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n+//! uncovered values of the type).\n+//!\n+//! If we have this predicate, then we can easily compute both exhaustiveness of an\n+//! entire set of patterns and the individual usefulness of each one.\n+//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n+//! match doesn't increase the number of values we're matching)\n+//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n+//! pattern to those that have come before it doesn't increase the number of values\n+//! we're matching).\n+//!\n+//! # Core concept\n+//!\n+//! The idea that powers everything that is done in this file is the following: a value is made\n+//! from a constructor applied to some fields. Examples of constructors are `Some`, `None`, `(,)`\n+//! (the 2-tuple constructor), `Foo {..}` (the constructor for a struct `Foo`), and `2` (the\n+//! constructor for the number `2`). Fields are just a (possibly empty) list of values.\n+//!\n+//! Some of the constructors listed above might feel weird: `None` and `2` don't take any\n+//! arguments. This is part of what makes constructors so general: we will consider plain values\n+//! like numbers and string literals to be constructors that take no arguments, also called \"0-ary\n+//! constructors\"; they are the simplest case of constructors. This allows us to see any value as\n+//! made up from a tree of constructors, each having a given number of children. For example:\n+//! `(None, Ok(0))` is made from 4 different constructors.\n+//!\n+//! This idea can be extended to patterns: a pattern captures a set of possible values, and we can\n+//! describe this set using constructors. For example, `Err(_)` captures all values of the type\n+//! `Result<T, E>` that start with the `Err` constructor (for some choice of `T` and `E`). The\n+//! wildcard `_` captures all values of the given type starting with any of the constructors for\n+//! that type.\n+//!\n+//! We use this to compute whether different patterns might capture a same value. Do the patterns\n+//! `Ok(\"foo\")` and `Err(_)` capture a common value? The answer is no, because the first pattern\n+//! captures only values starting with the `Ok` constructor and the second only values starting\n+//! with the `Err` constructor. Do the patterns `Some(42)` and `Some(1..10)` intersect? They might,\n+//! since they both capture values starting with `Some`. To be certain, we need to dig under the\n+//! `Some` constructor and continue asking the question. This is the main idea behind the\n+//! exhaustiveness algorithm: by looking at patterns constructor-by-constructor, we can efficiently\n+//! figure out if some new pattern might capture a value that hadn't been captured by previous\n+//! patterns.\n+//!\n+//! Constructors are represented by the `Constructor` enum, and its fields by the `Fields` enum.\n+//! Most of the complexity of this file resides in transforming between patterns and\n+//! (`Constructor`, `Fields`) pairs, handling all the special cases correctly.\n+//!\n+//! Caveat: this constructors/fields distinction doesn't quite cover every Rust value. For example\n+//! a value of type `Rc<u64>` doesn't fit this idea very well, nor do various other things.\n+//! However, this idea covers most of the cases that are relevant to exhaustiveness checking.\n+//!\n+//!\n+//! # Algorithm\n+//!\n+//! Recall that `U(P, p)` represents whether, given an existing list of patterns (aka matrix) `P`,\n+//! adding a new pattern `p` will cover previously-uncovered values of the type.\n+//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+//! but rather partially-deconstructed patterns in the form of a list of fields. The paper\n+//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+//! new pattern `p`.\n+//!\n+//! For example, say we have the following:\n+//! ```\n+//!     // x: (Option<bool>, Result<()>)\n+//!     match x {\n+//!         (Some(true), _) => {}\n+//!         (None, Err(())) => {}\n+//!         (None, Err(_)) => {}\n+//!     }\n+//! ```\n+//! Here, the matrix `P` starts as:\n+//! [\n+//!     [(Some(true), _)],\n+//!     [(None, Err(()))],\n+//!     [(None, Err(_))],\n+//! ]\n+//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n+//! all the values it covers are already covered by row 2.\n+//!\n+//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+//! To match the paper, the top of the stack is at the beginning / on the left.\n+//!\n+//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//!     1. We can pop a given constructor off the top of a stack. This operation is called\n+//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!        `None`) and `p` a pattern-stack.\n+//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!        Otherwise the pattern-stack is discarded.\n+//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!        discards the others.\n+//!\n+//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!        nothing back.\n+//!\n+//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!        on top of the stack, and we have four cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!                  push onto the stack the arguments of this constructor, and return the result:\n+//!                     r_1, .., r_a, p_2, .., p_n\n+//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!                  return nothing.\n+//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!                  arguments (its arity), and return the resulting stack:\n+//!                     _, .., _, p_2, .., p_n\n+//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!                  stack:\n+//!                     S(c, (r_1, p_2, .., p_n))\n+//!                     S(c, (r_2, p_2, .., p_n))\n+//!\n+//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!        a pattern-stack.\n+//!        This is used when we know there are missing constructor cases, but there might be\n+//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!        all its *other* components.\n+//!\n+//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!        and we have three cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!             1.2. `p_1 = _`. We return the rest of the stack:\n+//!                     p_2, .., p_n\n+//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!               stack.\n+//!                     D((r_1, p_2, .., p_n))\n+//!                     D((r_2, p_2, .., p_n))\n+//!\n+//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!\n+//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!\n+//!\n+//! The algorithm for computing `U`\n+//! -------------------------------\n+//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n+//! That means we're going to check the components from left-to-right, so the algorithm\n+//! operates principally on the first component of the matrix and new pattern-stack `p`.\n+//! This algorithm is realised in the `is_useful` function.\n+//!\n+//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n+//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n+//!       then `U(P, p)` is false.\n+//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n+//!                  [which may then be expanded into further columns later])\n+//!     We're going to match on the top of the new pattern-stack, `p_1`.\n+//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n+//!           This is where `S(c, P)` comes in:\n+//!           `U(P, p) := U(S(c, P), S(c, p))`\n+//!           This special case is handled in `is_useful_specialized`.\n+//!\n+//!           For example, if `P` is:\n+//!           [\n+//!               [Some(true), _],\n+//!               [None, 0],\n+//!           ]\n+//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//!           arguments of `Some` to know whether some new value is covered. So we compute\n+//!           `U([[true, _]], [false, 0])`.\n+//!\n+//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//!               component of the rows of `P`:\n+//!             + If there are some constructors that aren't present, then we might think that the\n+//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n+//!               before.\n+//!               That's almost correct, but only works if there were no wildcards in those first\n+//!               components. So we need to check that `p` is useful with respect to the rows that\n+//!               start with a wildcard, if there are any. This is where `D` comes in:\n+//!               `U(P, p) := U(D(P), D(p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [_, true, _],\n+//!                   [None, false, 1],\n+//!               ]\n+//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!\n+//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//!               case we must check whether the wildcard pattern covers any unmatched value. For\n+//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//!               example. The wildcard pattern is useful in this case if it is useful when\n+//!               specialized to one of the possible constructors. So we compute:\n+//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [Some(true), _],\n+//!                   [None, false],\n+//!               ]\n+//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//!               components of `P`. We will therefore try popping both constructors in turn: we\n+//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+//!               [false]) for the `None` constructor. The first case returns true, so we know that\n+//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//!               before.\n+//!\n+//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!                    || U(P, (r_2, p_2, .., p_n))`\n+//!\n+//! Modifications to the algorithm\n+//! ------------------------------\n+//! The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n+//! example uninhabited types and variable-length slice patterns. These are drawn attention to\n+//! throughout the code below. I'll make a quick note here about how exhaustive integer matching is\n+//! accounted for, though.\n+//!\n+//! Exhaustive integer matching\n+//! ---------------------------\n+//! An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n+//! So to support exhaustive integer matching, we can make use of the logic in the paper for\n+//! OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n+//! they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n+//! that we have a constructor *of* constructors (the integers themselves). We then need to work\n+//! through all the inductive step rules above, deriving how the ranges would be treated as\n+//! OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n+//! There are really only four special cases here:\n+//! - When we match on a constructor that's actually a range, we have to treat it as if we would\n+//!   an OR-pattern.\n+//!     + It turns out that we can simply extend the case for single-value patterns in\n+//!      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n+//!      constructor.\n+//!     + When the pattern itself is a range, you just want to tell whether any of the values in\n+//!       the pattern range coincide with values in the constructor range, which is precisely\n+//!       intersection.\n+//!   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n+//!   means that whenever the constructor is a value/range and the pattern is also a value/range,\n+//!   we can simply use intersection to test usefulness.\n+//! - When we're testing for usefulness of a pattern and the pattern's first component is a\n+//!   wildcard.\n+//!     + If all the constructors appear in the matrix, we have a slight complication. By default,\n+//!       the behaviour (i.e., a disjunction over specialised matrices for each constructor) is\n+//!       invalid, because we want a disjunction over every *integer* in each range, not just a\n+//!       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n+//!       to form equivalence classes of subranges of the constructor range for which the behaviour\n+//!       of the matrix `P` and new pattern `p` are the same. This is described in more\n+//!       detail in `split_grouped_constructors`.\n+//!     + If some constructors are missing from the matrix, it turns out we don't need to do\n+//!       anything special (because we know none of the integers are actually wildcards: i.e., we\n+//!       can't span wildcards using ranges).\n use self::Constructor::*;\n use self::SliceKind::*;\n use self::Usefulness::*;"}]}