{"sha": "3831a254905873af4da996ab21c6f9f3d4050051", "node_id": "C_kwDOAAsO6NoAKDM4MzFhMjU0OTA1ODczYWY0ZGE5OTZhYjIxYzZmOWYzZDQwNTAwNTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T23:05:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T23:05:57Z"}, "message": "Auto merge of #2817 - saethlin:rustup, r=saethlin\n\nrustup\n\nDoing a sync just before I do a rustc-push", "tree": {"sha": "d82a4ce76a940fc631c0d2ef7e1cc6497e5746b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d82a4ce76a940fc631c0d2ef7e1cc6497e5746b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3831a254905873af4da996ab21c6f9f3d4050051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3831a254905873af4da996ab21c6f9f3d4050051", "html_url": "https://github.com/rust-lang/rust/commit/3831a254905873af4da996ab21c6f9f3d4050051", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3831a254905873af4da996ab21c6f9f3d4050051/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b024de1673487c3de0ce7dc4c3c9ec470746006a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b024de1673487c3de0ce7dc4c3c9ec470746006a", "html_url": "https://github.com/rust-lang/rust/commit/b024de1673487c3de0ce7dc4c3c9ec470746006a"}, {"sha": "ba1c09429e5ad091d524c975f1383d1992f7f17a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1c09429e5ad091d524c975f1383d1992f7f17a", "html_url": "https://github.com/rust-lang/rust/commit/ba1c09429e5ad091d524c975f1383d1992f7f17a"}], "stats": {"total": 5752, "additions": 3713, "deletions": 2039}, "files": [{"sha": "49b89c71994a87f23b643f9f5d459c47d0352277", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -353,7 +353,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.70.0\"\n+version = \"0.71.0\"\n dependencies = [\n  \"anyhow\",\n  \"base64\",\n@@ -1001,7 +1001,7 @@ dependencies = [\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.35.1\"\n+version = \"0.36.0\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n@@ -5139,6 +5139,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"tracing\",\n ]\n \n@@ -5457,13 +5458,13 @@ dependencies = [\n  \"itertools\",\n  \"minifier\",\n  \"once_cell\",\n- \"rayon\",\n  \"regex\",\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n+ \"threadpool\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -6208,6 +6209,15 @@ dependencies = [\n  \"once_cell\",\n ]\n \n+[[package]]\n+name = \"threadpool\"\n+version = \"1.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n+dependencies = [\n+ \"num_cpus\",\n+]\n+\n [[package]]\n name = \"tidy\"\n version = \"0.1.0\""}, {"sha": "a26dbbfa4f5ec98c1844c97edfb2c695b50df46e", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -125,12 +125,13 @@ Compiler\n - [Optimize field ordering by grouping m\\*2^n-sized fields with equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n - [Stabilize native library modifier `verbatim`.](https://github.com/rust-lang/rust/pull/104360/)\n \n-Added and removed targets:\n+Added, updated, and removed targets:\n \n - [Add a tier 3 target for PowerPC on AIX](https://github.com/rust-lang/rust/pull/102293/), `powerpc64-ibm-aix`.\n - [Add a tier 3 target for the Sony PlayStation 1](https://github.com/rust-lang/rust/pull/102689/), `mipsel-sony-psx`.\n - [Add tier 3 `no_std` targets for the QNX Neutrino RTOS](https://github.com/rust-lang/rust/pull/102701/),\n   `aarch64-unknown-nto-qnx710` and `x86_64-pc-nto-qnx710`.\n+- [Promote UEFI targets to tier 2](https://github.com/rust-lang/rust/pull/103933/), `aarch64-unknown-uefi`, `i686-unknown-uefi`, and `x86_64-unknown-uefi`.\n - [Remove tier 3 `linuxkernel` targets](https://github.com/rust-lang/rust/pull/104015/) (not used by the actual kernel).\n \n Refer to Rust's [platform support page][platform-support-doc]"}, {"sha": "5d164bc4b3cf5052603e0c3ee8b5fc9103a19744", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1184,6 +1184,15 @@ impl Expr {\n         expr\n     }\n \n+    pub fn peel_parens_and_refs(&self) -> &Expr {\n+        let mut expr = self;\n+        while let ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) = &expr.kind\n+        {\n+            expr = inner;\n+        }\n+        expr\n+    }\n+\n     /// Attempts to reparse as `Ty` (for diagnostic purposes).\n     pub fn to_ty(&self) -> Option<P<Ty>> {\n         let kind = match &self.kind {"}, {"sha": "356b9bb6371e22b3227c09fa3caf43aa40b036d2", "filename": "compiler/rustc_ast/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -131,8 +131,8 @@ impl FormatArguments {\n         &self.arguments[..]\n     }\n \n-    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n-        &mut self.arguments[..]\n+    pub fn all_args_mut(&mut self) -> &mut Vec<FormatArgument> {\n+        &mut self.arguments\n     }\n }\n "}, {"sha": "72352b138cbf47117cf738e78e4ce8bc95193bda", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 216, "deletions": 22, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -7,13 +7,172 @@ use rustc_hir as hir;\n use rustc_span::{\n     sym,\n     symbol::{kw, Ident},\n-    Span,\n+    Span, Symbol,\n };\n+use std::borrow::Cow;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n-        expand_format_args(self, sp, fmt)\n+        // Never call the const constructor of `fmt::Arguments` if the\n+        // format_args!() had any arguments _before_ flattening/inlining.\n+        let allow_const = fmt.arguments.all_args().is_empty();\n+        let mut fmt = Cow::Borrowed(fmt);\n+        if self.tcx.sess.opts.unstable_opts.flatten_format_args {\n+            fmt = flatten_format_args(fmt);\n+            fmt = inline_literals(fmt);\n+        }\n+        expand_format_args(self, sp, &fmt, allow_const)\n+    }\n+}\n+\n+/// Flattens nested `format_args!()` into one.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"a {} {} {}.\", 1, format_args!(\"b{}!\", 2), 3)`\n+///\n+/// into\n+///\n+/// `format_args!(\"a {} b{}! {}.\", 1, 2, 3)`.\n+fn flatten_format_args(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut i = 0;\n+    while i < fmt.template.len() {\n+        if let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i]\n+            && let FormatTrait::Display | FormatTrait::Debug = &placeholder.format_trait\n+            && let Ok(arg_index) = placeholder.argument.index\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::FormatArgs(_) = &arg.kind\n+            // Check that this argument is not used by any other placeholders.\n+            && fmt.template.iter().enumerate().all(|(j, p)|\n+                i == j ||\n+                !matches!(p, FormatArgsPiece::Placeholder(placeholder)\n+                    if placeholder.argument.index == Ok(arg_index))\n+            )\n+        {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+\n+            // Take the inner FormatArgs out of the outer arguments, and\n+            // replace it by the inner arguments. (We can't just put those at\n+            // the end, because we need to preserve the order of evaluation.)\n+\n+            let args = fmt.arguments.all_args_mut();\n+            let remaining_args = args.split_off(arg_index + 1);\n+            let old_arg_offset = args.len();\n+            let mut fmt2 = &mut args.pop().unwrap().expr; // The inner FormatArgs.\n+            let fmt2 = loop { // Unwrap the Expr to get to the FormatArgs.\n+                match &mut fmt2.kind {\n+                    ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) => fmt2 = inner,\n+                    ExprKind::FormatArgs(fmt2) => break fmt2,\n+                    _ => unreachable!(),\n+                }\n+            };\n+\n+            args.append(fmt2.arguments.all_args_mut());\n+            let new_arg_offset = args.len();\n+            args.extend(remaining_args);\n+\n+            // Correct the indexes that refer to the arguments after the newly inserted arguments.\n+            for_all_argument_indexes(&mut fmt.template, |index| {\n+                if *index >= old_arg_offset {\n+                    *index -= old_arg_offset;\n+                    *index += new_arg_offset;\n+                }\n+            });\n+\n+            // Now merge the placeholders:\n+\n+            let rest = fmt.template.split_off(i + 1);\n+            fmt.template.pop(); // remove the placeholder for the nested fmt args.\n+            // Insert the pieces from the nested format args, but correct any\n+            // placeholders to point to the correct argument index.\n+            for_all_argument_indexes(&mut fmt2.template, |index| *index += arg_index);\n+            fmt.template.append(&mut fmt2.template);\n+            fmt.template.extend(rest);\n+\n+            // Don't increment `i` here, so we recurse into the newly added pieces.\n+        } else {\n+            i += 1;\n+        }\n     }\n+    fmt\n+}\n+\n+/// Inline literals into the format string.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"Hello, {}! {} {}\", \"World\", 123, x)`\n+///\n+/// into\n+///\n+/// `format_args!(\"Hello, World! 123 {}\", x)`.\n+fn inline_literals(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut was_inlined = vec![false; fmt.arguments.all_args().len()];\n+    let mut inlined_anything = false;\n+\n+    for i in 0..fmt.template.len() {\n+        let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i] else { continue };\n+        let Ok(arg_index) = placeholder.argument.index else { continue };\n+\n+        let mut literal = None;\n+\n+        if let FormatTrait::Display = placeholder.format_trait\n+            && placeholder.format_options == Default::default()\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::Lit(lit) = arg.kind\n+        {\n+            if let token::LitKind::Str | token::LitKind::StrRaw(_) = lit.kind\n+                && let Ok(LitKind::Str(s, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(s);\n+            } else if let token::LitKind::Integer = lit.kind\n+                && let Ok(LitKind::Int(n, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(Symbol::intern(&n.to_string()));\n+            }\n+        }\n+\n+        if let Some(literal) = literal {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+            // Replace the placeholder with the literal.\n+            fmt.template[i] = FormatArgsPiece::Literal(literal);\n+            was_inlined[arg_index] = true;\n+            inlined_anything = true;\n+        }\n+    }\n+\n+    // Remove the arguments that were inlined.\n+    if inlined_anything {\n+        let fmt = fmt.to_mut();\n+\n+        let mut remove = was_inlined;\n+\n+        // Don't remove anything that's still used.\n+        for_all_argument_indexes(&mut fmt.template, |index| remove[*index] = false);\n+\n+        // Drop all the arguments that are marked for removal.\n+        let mut remove_it = remove.iter();\n+        fmt.arguments.all_args_mut().retain(|_| remove_it.next() != Some(&true));\n+\n+        // Calculate the mapping of old to new indexes for the remaining arguments.\n+        let index_map: Vec<usize> = remove\n+            .into_iter()\n+            .scan(0, |i, remove| {\n+                let mapped = *i;\n+                *i += !remove as usize;\n+                Some(mapped)\n+            })\n+            .collect();\n+\n+        // Correct the indexes that refer to arguments that have shifted position.\n+        for_all_argument_indexes(&mut fmt.template, |index| *index = index_map[*index]);\n+    }\n+\n+    fmt\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -189,11 +348,26 @@ fn expand_format_args<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     macsp: Span,\n     fmt: &FormatArgs,\n+    allow_const: bool,\n ) -> hir::ExprKind<'hir> {\n+    let mut incomplete_lit = String::new();\n     let lit_pieces =\n         ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n             match piece {\n-                &FormatArgsPiece::Literal(s) => Some(ctx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Literal(s) => {\n+                    // Coalesce adjacent literal pieces.\n+                    if let Some(FormatArgsPiece::Literal(_)) = fmt.template.get(i + 1) {\n+                        incomplete_lit.push_str(s.as_str());\n+                        None\n+                    } else if !incomplete_lit.is_empty() {\n+                        incomplete_lit.push_str(s.as_str());\n+                        let s = Symbol::intern(&incomplete_lit);\n+                        incomplete_lit.clear();\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    } else {\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    }\n+                }\n                 &FormatArgsPiece::Placeholder(_) => {\n                     // Inject empty string before placeholders when not already preceded by a literal piece.\n                     if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n@@ -244,6 +418,18 @@ fn expand_format_args<'hir>(\n \n     let arguments = fmt.arguments.all_args();\n \n+    if allow_const && arguments.is_empty() && argmap.is_empty() {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_const(lit_pieces)\n+        let new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_const,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces]);\n+        return hir::ExprKind::Call(new, new_args);\n+    }\n+\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n@@ -290,25 +476,14 @@ fn expand_format_args<'hir>(\n         let args_ident = Ident::new(sym::args, macsp);\n         let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n         let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n-            if let Some(arg) = arguments.get(arg_index) {\n-                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n-                let arg = ctx.arena.alloc(ctx.expr(\n-                    sp,\n-                    hir::ExprKind::Field(\n-                        args_ident_expr,\n-                        Ident::new(sym::integer(arg_index), macsp),\n-                    ),\n-                ));\n-                make_argument(ctx, sp, arg, ty)\n-            } else {\n-                ctx.expr(\n-                    macsp,\n-                    hir::ExprKind::Err(\n-                        ctx.tcx.sess.delay_span_bug(macsp, format!(\"no arg at {arg_index}\")),\n-                    ),\n-                )\n-            }\n+            let arg = &arguments[arg_index];\n+            let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+            let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+            let arg = ctx.arena.alloc(ctx.expr(\n+                sp,\n+                hir::ExprKind::Field(args_ident_expr, Ident::new(sym::integer(arg_index), macsp)),\n+            ));\n+            make_argument(ctx, sp, arg, ty)\n         }));\n         let elements: Vec<_> = arguments\n             .iter()\n@@ -409,3 +584,22 @@ fn may_contain_yield_point(e: &ast::Expr) -> bool {\n     visitor.visit_expr(e);\n     visitor.0\n }\n+\n+fn for_all_argument_indexes(template: &mut [FormatArgsPiece], mut f: impl FnMut(&mut usize)) {\n+    for piece in template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if let Ok(index) = &mut placeholder.argument.index {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.width\n+        {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.precision\n+        {\n+            f(index);\n+        }\n+    }\n+}"}, {"sha": "2cbd2e3bc0d86547ba9834ffcc1a439c9f424cdd", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n \n         // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n-        // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+        // pair of array indices are not equal, so that when `places_conflict` returns true, we\n         // will be assured that two places being compared definitely denotes the same sets of\n         // locations.\n         let definitely_conflicting_borrows = other_borrows_of_local.filter(|&i| {"}, {"sha": "5f5510a579654afa30a0260b128800fd0018ad61", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/abi-cafe.yml", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,64 @@\n+name: Abi-cafe\n+\n+on:\n+  - push\n+\n+jobs:\n+  abi_cafe:\n+    runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n+    concurrency:\n+      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.os }}-${{ matrix.env.TARGET_TRIPLE }}\n+      cancel-in-progress: true\n+\n+    defaults:\n+      run:\n+        shell: bash\n+\n+    strategy:\n+      fail-fast: true\n+      matrix:\n+        include:\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n+          - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: build/cg_clif\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n+\n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n+\n+    - name: Build\n+      run: ./y.rs build --sysroot none\n+\n+    - name: Test abi-cafe\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      run: ./y.rs abi-cafe"}, {"sha": "98b34c65dea591284f9d30e7fb7c541891578fd3", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -22,7 +22,7 @@ jobs:\n         rustfmt --check build_system/mod.rs\n \n \n-  build:\n+  test:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n@@ -114,63 +114,6 @@ jobs:\n       run: ./y.rs test\n \n \n-  abi_cafe:\n-    runs-on: ${{ matrix.os }}\n-    timeout-minutes: 60\n-\n-    defaults:\n-      run:\n-        shell: bash\n-\n-    strategy:\n-      fail-fast: true\n-      matrix:\n-        include:\n-          - os: ubuntu-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n-          - os: macos-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-apple-darwin\n-          - os: windows-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-pc-windows-msvc\n-          - os: windows-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-pc-windows-gnu\n-\n-    steps:\n-    - uses: actions/checkout@v3\n-\n-    - name: Cache cargo target dir\n-      uses: actions/cache@v3\n-      with:\n-        path: build/cg_clif\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n-\n-    - name: Set MinGW as the default toolchain\n-      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n-      run: rustup set default-host x86_64-pc-windows-gnu\n-\n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n-    - name: Prepare dependencies\n-      run: ./y.rs prepare\n-\n-    - name: Build\n-      run: ./y.rs build --sysroot none\n-\n-    - name: Test abi-cafe\n-      env:\n-        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      run: ./y.rs abi-cafe\n-\n-\n   bench:\n     runs-on: ubuntu-latest\n     timeout-minutes: 60"}, {"sha": "e5d10a937ae2497a7deb53af1554123c846cce8e", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -14,3 +14,4 @@ perf.data.old\n /dist\n /rust\n /download\n+/git-fixed-subtree.sh"}, {"sha": "157ef4bf3892ecb9ddaba4e22cedad0baf3f9a4b", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -57,18 +57,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f3d54eab028f5805ae3b26fd60eca3f3a9cfb76b989d9bab173be3f61356cc3\"\n+checksum = \"a7379abaacee0f14abf3204a7606118f0465785252169d186337bcb75030815a\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2be1d5f2c3cca1efb691844bc1988b89c77291f13f778499a3f3c0cf49c0ed61\"\n+checksum = \"9489fa336927df749631f1008007ced2871068544f40a202ce6d93fbf2366a7b\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n@@ -87,30 +87,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f9b1b1089750ce4005893af7ee00bb08a2cf1c9779999c0f7164cbc8ad2e0d2\"\n+checksum = \"05bbb67da91ec721ed57cef2f7c5ef7728e1cd9bde9ffd3ef8601022e73e3239\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc5fbaec51de47297fd7304986fd53c8c0030abbe69728a60d72e1c63559318d\"\n+checksum = \"418ecb2f36032f6665dc1a5e2060a143dbab41d83b784882e97710e890a7a16d\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab984c94593f876090fae92e984bdcc74d9b1acf740ab5f79036001c65cba13\"\n+checksum = \"7cf583f7b093f291005f9fb1323e2c37f6ee4c7909e39ce016b2e8360d461705\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6e0cb3102d21a2fe5f3210af608748ddd0cd09825ac12d42dc56ed5ed8725fe0\"\n+checksum = \"7d361ed0373cf5f086b49c499aa72227b646a64f899f32e34312f97c0fadff75\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -120,15 +120,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72101dd1f441d629735143c41e00b3428f9267738176983ef588ff43382af0a0\"\n+checksum = \"649782a39ce99798dd6b4029e2bb318a2fbeaade1b4fa25330763c10c65bc358\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6557f8ce44d498777f2495aa58d9692a4a37d6f84aa445750d666cef770b6a5c\"\n+checksum = \"9c9909222db472fcc98d9e4e7192fa9d064dac63a3fa657df8c6daae86fb2604\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -145,19 +145,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88807e1c0c47ec02fe433333ccbe56b480425418b1470e333205e11650697d72\"\n+checksum = \"68689b83e52e605ba48652882d3fccc2e2e136abf139eb64ae667888ba0d52f8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c22b0d9fcbe3fc5a1af9e7021b44ce42b930bcefac446ce22e02e8f9a0d67120\"\n+checksum = \"f98e4e99a353703475d5acb402b9c13482d41d8a4008b352559bd560afb90363\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -166,9 +166,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"341375758d7c3fedc0b5315f552e6f0feac46baf87c450a15e9455ef47c2b261\"\n+checksum = \"b7a006ce1d8dd11df67567d8673e5920f3a56441812aed52a007ffce8f1b20e9\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -333,6 +333,7 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n+ \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -381,9 +382,9 @@ checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"wasmtime-jit-icache-coherence\"\n-version = \"5.0.0\"\n+version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08fcba5ebd96da2a9f0747ab6337fe9788adfb3f63fa2c180520d665562d257e\"\n+checksum = \"ec1fd0f0dd79e7cc0f55b102e320d7c77ab76cd272008a8fd98e25b5777e2636\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\","}, {"sha": "0e64fba6bec8db017c3b5f85d2918404a4fc96d1", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -15,14 +15,12 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.92\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = { version = \"0.92\" }\n-cranelift-module = { version = \"0.92\" }\n-# NOTE vendored as src/cranelift_native.rs\n-# FIXME revert back to the external crate with Cranelift 0.93\n-#cranelift-native = { version = \"0.92\" }\n-cranelift-jit = { version = \"0.92\", optional = true }\n-cranelift-object = { version = \"0.92\" }\n+cranelift-codegen = { version = \"0.93\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { version = \"0.93\" }\n+cranelift-module = { version = \"0.93\" }\n+cranelift-native = { version = \"0.93\" }\n+cranelift-jit = { version = \"0.93\", optional = true }\n+cranelift-object = { version = \"0.93\" }\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }"}, {"sha": "f21507629911ad01d0864bd1f169fe548ba4109e", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.86\"\n+version = \"0.1.89\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5dae98c88e576098d7ab13ebcb40cc43e5114b2beafe61a87cda9200649ff205\"\n+checksum = \"9fc9c2080d347a2c316518840ac9194644a9993dfa1e9778ef38979a339f5d8b\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -117,21 +117,20 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.6\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n+checksum = \"fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286\"\n dependencies = [\n  \"compiler_builtins\",\n- \"libc\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.139\"\n+version = \"0.2.140\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n+checksum = \"99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -282,10 +281,8 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n  \"core\",\n  \"getopts\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"proc_macro\","}, {"sha": "8219e6b6ccf3bca19d613a2b7331639a30a8d7e1", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,7 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n+compiler_builtins = { version = \"0.1.87\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }"}, {"sha": "76b602fe7196326f9949430b549669862e9a0766", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -46,13 +46,15 @@ pub(crate) fn build_sysroot(\n         let wrapper_name = wrapper_base_name.replace(\"____\", wrapper);\n \n         let mut build_cargo_wrapper_cmd = Command::new(&bootstrap_host_compiler.rustc);\n+        let wrapper_path = DIST_DIR.to_path(dirs).join(&wrapper_name);\n         build_cargo_wrapper_cmd\n             .env(\"TOOLCHAIN_NAME\", toolchain_name.clone())\n             .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n+            .arg(&wrapper_path)\n             .arg(\"-Cstrip=debuginfo\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n+        try_hard_link(wrapper_path, BIN_DIR.to_path(dirs).join(wrapper_name));\n     }\n \n     let host = build_sysroot_for_triple(\n@@ -247,6 +249,7 @@ fn build_clif_sysroot_for_triple(\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n     }\n+    build_cmd.arg(\"--locked\");\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     if compiler.triple.contains(\"apple\") {\n         build_cmd.env(\"CARGO_PROFILE_RELEASE_SPLIT_DEBUGINFO\", \"packed\");"}, {"sha": "6769e42d44b94181f427210c803616f2e2b8f31e", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -6,15 +6,18 @@ use std::process::Command;\n use super::build_sysroot::{BUILD_SYSROOT, ORIG_BUILD_SYSROOT, SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_default_sysroot, get_rustc_version};\n+use super::tests::LIBCORE_TESTS_SRC;\n use super::utils::{copy_dir_recursively, git_command, retry_spawn_and_wait, spawn_and_wait};\n \n pub(crate) fn prepare(dirs: &Dirs) {\n     RelPath::DOWNLOAD.ensure_fresh(dirs);\n \n     spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", \"rustc\", dirs));\n \n-    prepare_sysroot(dirs);\n+    prepare_stdlib(dirs);\n     spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", \"rustc\", dirs));\n+\n+    prepare_coretests(dirs);\n     spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", \"rustc\", dirs));\n \n     super::tests::RAND_REPO.fetch(dirs);\n@@ -25,11 +28,11 @@ pub(crate) fn prepare(dirs: &Dirs) {\n     spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", \"rustc\", dirs));\n }\n \n-fn prepare_sysroot(dirs: &Dirs) {\n+fn prepare_stdlib(dirs: &Dirs) {\n     let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n     assert!(sysroot_src_orig.exists());\n \n-    eprintln!(\"[COPY] sysroot src\");\n+    eprintln!(\"[COPY] stdlib src\");\n \n     // FIXME ensure builds error out or update the copy if any of the files copied here change\n     BUILD_SYSROOT.ensure_fresh(dirs);\n@@ -47,7 +50,25 @@ fn prepare_sysroot(dirs: &Dirs) {\n     eprintln!(\"[GIT] init\");\n     init_git_repo(&SYSROOT_SRC.to_path(dirs));\n \n-    apply_patches(dirs, \"sysroot\", &SYSROOT_SRC.to_path(dirs));\n+    apply_patches(dirs, \"stdlib\", &SYSROOT_SRC.to_path(dirs));\n+}\n+\n+fn prepare_coretests(dirs: &Dirs) {\n+    let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n+    assert!(sysroot_src_orig.exists());\n+\n+    eprintln!(\"[COPY] coretests src\");\n+\n+    fs::create_dir_all(LIBCORE_TESTS_SRC.to_path(dirs)).unwrap();\n+    copy_dir_recursively(\n+        &sysroot_src_orig.join(\"library/core/tests\"),\n+        &LIBCORE_TESTS_SRC.to_path(dirs),\n+    );\n+\n+    eprintln!(\"[GIT] init\");\n+    init_git_repo(&LIBCORE_TESTS_SRC.to_path(dirs));\n+\n+    apply_patches(dirs, \"coretests\", &LIBCORE_TESTS_SRC.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {"}, {"sha": "261948a6971375f534935991d7f27d27e1209639", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,4 @@\n-use super::build_sysroot::{self, SYSROOT_SRC};\n+use super::build_sysroot;\n use super::config;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n@@ -94,40 +94,42 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::build_bin_and_run(\"aot.issue-72793\", \"example/issue-72793.rs\", &[]),\n ];\n \n+// FIXME(rust-random/rand#1293): Newer rand versions fail to test on Windows. Update once this is\n+// fixed.\n pub(crate) static RAND_REPO: GitRepo =\n-    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+    GitRepo::github(\"rust-random\", \"rand\", \"50b9a447410860af8d6db9a208c3576886955874\", \"rand\");\n \n pub(crate) static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+    GitRepo::github(\"rust-lang\", \"regex\", \"a9b2e02352db92ce1f6e5b7ecd41b8bbffbe161a\", \"regex\");\n \n pub(crate) static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n     \"portable-simd\",\n-    \"582239ac3b32007613df04d7ffa78dc30f4c5645\",\n+    \"9bd30e77b3a3c699af102ebb3df0f6110f8aa02e\",\n     \"portable-simd\",\n );\n \n pub(crate) static PORTABLE_SIMD: CargoProject =\n     CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n \n-pub(crate) static LIBCORE_TESTS: CargoProject =\n-    CargoProject::new(&SYSROOT_SRC.join(\"library/core/tests\"), \"core_tests\");\n+pub(crate) static LIBCORE_TESTS_SRC: RelPath = RelPath::DOWNLOAD.join(\"coretests_src\");\n+\n+pub(crate) static LIBCORE_TESTS: CargoProject = CargoProject::new(&LIBCORE_TESTS_SRC, \"core_tests\");\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.rust-random/rand\", &|runner| {\n         RAND.clean(&runner.dirs);\n \n         if runner.is_native {\n-            eprintln!(\"[TEST] rust-random/rand\");\n             let mut test_cmd = RAND.test(&runner.target_compiler, &runner.dirs);\n-            test_cmd.arg(\"--workspace\");\n+            test_cmd.arg(\"--workspace\").arg(\"--\").arg(\"-q\");\n             spawn_and_wait(test_cmd);\n         } else {\n-            eprintln!(\"[AOT] rust-random/rand\");\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = RAND.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--workspace\").arg(\"--tests\");\n             spawn_and_wait(build_cmd);\n@@ -137,7 +139,9 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n         LIBCORE_TESTS.clean(&runner.dirs);\n \n         if runner.is_native {\n-            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n+            let mut test_cmd = LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"--\").arg(\"-q\");\n+            spawn_and_wait(test_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler, &runner.dirs);\n@@ -148,18 +152,13 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.regex-shootout-regex-dna\", &|runner| {\n         REGEX.clean(&runner.dirs);\n \n-        // newer aho_corasick versions throw a deprecation warning\n-        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n-\n         let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n-        build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n         spawn_and_wait(build_cmd);\n \n         if runner.is_native {\n             let mut run_cmd = REGEX.run(&runner.target_compiler, &runner.dirs);\n             run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n-            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n             let input = fs::read_to_string(\n                 REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n@@ -171,13 +170,6 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             .unwrap();\n \n             let output = spawn_and_wait_with_input(run_cmd, input);\n-            // Make sure `[codegen mono items] start` doesn't poison the diff\n-            let output = output\n-                .lines()\n-                .filter(|line| !line.contains(\"codegen mono items\"))\n-                .chain(Some(\"\")) // This just adds the trailing newline\n-                .collect::<Vec<&str>>()\n-                .join(\"\\r\\n\");\n \n             let output_matches = expected.lines().eq(output.lines());\n             if !output_matches {\n@@ -192,27 +184,14 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.regex\", &|runner| {\n         REGEX.clean(&runner.dirs);\n \n-        // newer aho_corasick versions throw a deprecation warning\n-        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n-\n         if runner.is_native {\n             let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n-            run_cmd.args([\n-                \"--tests\",\n-                \"--\",\n-                \"--exclude-should-panic\",\n-                \"--test-threads\",\n-                \"1\",\n-                \"-Zunstable-options\",\n-                \"-q\",\n-            ]);\n-            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+            run_cmd.args([\"--workspace\", \"--\", \"-q\"]);\n             spawn_and_wait(run_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--tests\");\n-            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n             spawn_and_wait(build_cmd);\n         }\n     }),"}, {"sha": "73b83b89f6d91ea3358c15a5e8cc49354ac62d4a", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -518,6 +518,17 @@ pub struct Box<T: ?Sized>(Unique<T>, ());\n \n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n+impl<T> Box<T> {\n+    pub fn new(val: T) -> Box<T> {\n+        unsafe {\n+            let size = intrinsics::size_of::<T>();\n+            let ptr = libc::malloc(size);\n+            intrinsics::copy(&val as *const T as *const u8, ptr, size);\n+            Box(Unique { pointer: NonNull(ptr as *const T), _marker: PhantomData }, ())\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Drop for Box<T> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler."}, {"sha": "6ad3268e70dd229278b33c6b7e66e2697ace038e", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 300, "deletions": 81, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,16 +1,16 @@\n-#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local)]\n+#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local, repr_simd)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n extern crate mini_core;\n \n-use mini_core::*;\n use mini_core::libc::*;\n+use mini_core::*;\n \n macro_rules! assert {\n     ($e:expr) => {\n         if !$e {\n-            panic(stringify!(! $e));\n+            panic(stringify!(!$e));\n         }\n     };\n }\n@@ -20,7 +20,7 @@ macro_rules! assert_eq {\n         if $l != $r {\n             panic(stringify!($l != $r));\n         }\n-    }\n+    };\n }\n \n #[lang = \"termination\"]\n@@ -96,9 +96,15 @@ fn start<T: Termination + 'static>(\n     _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n-        unsafe { puts(*argv as *const i8); }\n-        unsafe { puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n-        unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n+        unsafe {\n+            puts(*argv as *const i8);\n+        }\n+        unsafe {\n+            puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8));\n+        }\n+        unsafe {\n+            puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8));\n+        }\n     }\n \n     main().report() as isize\n@@ -107,7 +113,6 @@ fn start<T: Termination + 'static>(\n static mut NUM: u8 = 6 * 7;\n static NUM_REF: &'static u8 = unsafe { &NUM };\n \n-\n unsafe fn zeroed<T>() -> T {\n     let mut uninit = MaybeUninit { uninit: () };\n     intrinsics::write_bytes(&mut uninit.value.value as *mut T, 0, 1);\n@@ -144,10 +149,7 @@ extern \"C\" fn bool_struct_in_11(_arg0: bool_11) {}\n \n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n-    take_unique(Unique {\n-        pointer: unsafe { NonNull(1 as *mut ()) },\n-        _marker: PhantomData,\n-    });\n+    take_unique(Unique { pointer: unsafe { NonNull(1 as *mut ()) }, _marker: PhantomData });\n     take_f32(0.1);\n \n     call_return_u128_pair();\n@@ -202,17 +204,17 @@ fn main() {\n         assert_eq!(intrinsics::size_of_val(&0u32) as u8, 4);\n \n         assert_eq!(intrinsics::min_align_of::<u16>() as u8, 2);\n-        assert_eq!(intrinsics::min_align_of_val(&a) as u8, intrinsics::min_align_of::<&str>() as u8);\n+        assert_eq!(\n+            intrinsics::min_align_of_val(&a) as u8,\n+            intrinsics::min_align_of::<&str>() as u8\n+        );\n \n         assert!(!intrinsics::needs_drop::<u8>());\n         assert!(!intrinsics::needs_drop::<[u8]>());\n         assert!(intrinsics::needs_drop::<NoisyDrop>());\n         assert!(intrinsics::needs_drop::<NoisyDropUnsized>());\n \n-        Unique {\n-            pointer: NonNull(1 as *mut &str),\n-            _marker: PhantomData,\n-        } as Unique<dyn SomeTrait>;\n+        Unique { pointer: NonNull(1 as *mut &str), _marker: PhantomData } as Unique<dyn SomeTrait>;\n \n         struct MyDst<T: ?Sized>(T);\n \n@@ -238,19 +240,17 @@ fn main() {\n         }\n     }\n \n-    let _ = Box::new(NoisyDrop {\n-        text: \"Boxed outer got dropped!\\0\",\n-        inner: NoisyDropInner,\n-    }) as Box<dyn SomeTrait>;\n+    let _ = Box::new(NoisyDrop { text: \"Boxed outer got dropped!\\0\", inner: NoisyDropInner })\n+        as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n     match FUNC_REF {\n-        Some(_) => {},\n+        Some(_) => {}\n         None => assert!(false),\n     }\n \n     match Ordering::Less {\n-        Ordering::Less => {},\n+        Ordering::Less => {}\n         _ => assert!(false),\n     }\n \n@@ -266,19 +266,21 @@ fn main() {\n \n     #[cfg(not(any(jit, windows)))]\n     {\n-        extern {\n+        extern \"C\" {\n             #[linkage = \"extern_weak\"]\n             static ABC: *const u8;\n         }\n \n         {\n-            extern {\n+            extern \"C\" {\n                 #[linkage = \"extern_weak\"]\n                 static ABC: *const u8;\n             }\n         }\n \n-        unsafe { assert_eq!(ABC as usize, 0); }\n+        unsafe {\n+            assert_eq!(ABC as usize, 0);\n+        }\n     }\n \n     &mut (|| Some(0 as *const ())) as &mut dyn FnMut() -> Option<*const ()>;\n@@ -339,7 +341,13 @@ fn main() {\n \n         assert_eq!(unsafe { intrinsics::size_of_val(x) }, 0);\n         assert_eq!(unsafe { intrinsics::min_align_of_val(x) }, 1);\n-}\n+    }\n+\n+    #[repr(simd)]\n+    struct V([f64; 2]);\n+\n+    let f = V([0.0, 1.0]);\n+    let _a = f.0[0];\n }\n \n #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n@@ -392,13 +400,10 @@ extern \"C\" {\n         native: *mut pthread_t,\n         attr: *const pthread_attr_t,\n         f: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n-        value: *mut c_void\n+        value: *mut c_void,\n     ) -> c_int;\n \n-    fn pthread_join(\n-        native: pthread_t,\n-        value: *mut *mut c_void\n-    ) -> c_int;\n+    fn pthread_join(native: pthread_t, value: *mut *mut c_void) -> c_int;\n }\n \n type DWORD = u32;\n@@ -410,18 +415,15 @@ type HANDLE = *mut c_void;\n #[link(name = \"msvcrt\")]\n #[cfg(windows)]\n extern \"C\" {\n-    fn WaitForSingleObject(\n-        hHandle: LPVOID,\n-        dwMilliseconds: DWORD\n-    ) -> DWORD;\n+    fn WaitForSingleObject(hHandle: LPVOID, dwMilliseconds: DWORD) -> DWORD;\n \n     fn CreateThread(\n         lpThreadAttributes: LPVOID, // Technically LPSECURITY_ATTRIBUTES, but we don't use it anyway\n         dwStackSize: usize,\n         lpStartAddress: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n         lpParameter: LPVOID,\n         dwCreationFlags: DWORD,\n-        lpThreadId: LPDWORD\n+        lpThreadId: LPDWORD,\n     ) -> HANDLE;\n }\n \n@@ -447,9 +449,7 @@ impl Thread {\n                 assert!(false);\n             }\n \n-            Thread {\n-                handle: thread,\n-            }\n+            Thread { handle: thread }\n         }\n \n         #[cfg(windows)]\n@@ -460,13 +460,10 @@ impl Thread {\n                 assert!(false);\n             }\n \n-            Thread {\n-                handle,\n-            }\n+            Thread { handle }\n         }\n     }\n \n-\n     unsafe fn join(self) {\n         #[cfg(unix)]\n         {\n@@ -483,16 +480,15 @@ impl Thread {\n     }\n }\n \n-\n-\n-\n #[thread_local]\n #[cfg(not(jit))]\n static mut TLS: u8 = 42;\n \n #[cfg(not(jit))]\n extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n-    unsafe { TLS = 0; }\n+    unsafe {\n+        TLS = 0;\n+    }\n     0 as *mut c_void\n }\n \n@@ -531,44 +527,267 @@ pub enum E1 {\n pub enum E2<X> {\n     V1 { f: bool },\n \n-    /*_00*/ _01(X), _02(X), _03(X), _04(X), _05(X), _06(X), _07(X),\n-    _08(X), _09(X), _0A(X), _0B(X), _0C(X), _0D(X), _0E(X), _0F(X),\n-    _10(X), _11(X), _12(X), _13(X), _14(X), _15(X), _16(X), _17(X),\n-    _18(X), _19(X), _1A(X), _1B(X), _1C(X), _1D(X), _1E(X), _1F(X),\n-    _20(X), _21(X), _22(X), _23(X), _24(X), _25(X), _26(X), _27(X),\n-    _28(X), _29(X), _2A(X), _2B(X), _2C(X), _2D(X), _2E(X), _2F(X),\n-    _30(X), _31(X), _32(X), _33(X), _34(X), _35(X), _36(X), _37(X),\n-    _38(X), _39(X), _3A(X), _3B(X), _3C(X), _3D(X), _3E(X), _3F(X),\n-    _40(X), _41(X), _42(X), _43(X), _44(X), _45(X), _46(X), _47(X),\n-    _48(X), _49(X), _4A(X), _4B(X), _4C(X), _4D(X), _4E(X), _4F(X),\n-    _50(X), _51(X), _52(X), _53(X), _54(X), _55(X), _56(X), _57(X),\n-    _58(X), _59(X), _5A(X), _5B(X), _5C(X), _5D(X), _5E(X), _5F(X),\n-    _60(X), _61(X), _62(X), _63(X), _64(X), _65(X), _66(X), _67(X),\n-    _68(X), _69(X), _6A(X), _6B(X), _6C(X), _6D(X), _6E(X), _6F(X),\n-    _70(X), _71(X), _72(X), _73(X), _74(X), _75(X), _76(X), _77(X),\n-    _78(X), _79(X), _7A(X), _7B(X), _7C(X), _7D(X), _7E(X), _7F(X),\n-    _80(X), _81(X), _82(X), _83(X), _84(X), _85(X), _86(X), _87(X),\n-    _88(X), _89(X), _8A(X), _8B(X), _8C(X), _8D(X), _8E(X), _8F(X),\n-    _90(X), _91(X), _92(X), _93(X), _94(X), _95(X), _96(X), _97(X),\n-    _98(X), _99(X), _9A(X), _9B(X), _9C(X), _9D(X), _9E(X), _9F(X),\n-    _A0(X), _A1(X), _A2(X), _A3(X), _A4(X), _A5(X), _A6(X), _A7(X),\n-    _A8(X), _A9(X), _AA(X), _AB(X), _AC(X), _AD(X), _AE(X), _AF(X),\n-    _B0(X), _B1(X), _B2(X), _B3(X), _B4(X), _B5(X), _B6(X), _B7(X),\n-    _B8(X), _B9(X), _BA(X), _BB(X), _BC(X), _BD(X), _BE(X), _BF(X),\n-    _C0(X), _C1(X), _C2(X), _C3(X), _C4(X), _C5(X), _C6(X), _C7(X),\n-    _C8(X), _C9(X), _CA(X), _CB(X), _CC(X), _CD(X), _CE(X), _CF(X),\n-    _D0(X), _D1(X), _D2(X), _D3(X), _D4(X), _D5(X), _D6(X), _D7(X),\n-    _D8(X), _D9(X), _DA(X), _DB(X), _DC(X), _DD(X), _DE(X), _DF(X),\n-    _E0(X), _E1(X), _E2(X), _E3(X), _E4(X), _E5(X), _E6(X), _E7(X),\n-    _E8(X), _E9(X), _EA(X), _EB(X), _EC(X), _ED(X), _EE(X), _EF(X),\n-    _F0(X), _F1(X), _F2(X), _F3(X), _F4(X), _F5(X), _F6(X), _F7(X),\n-    _F8(X), _F9(X), _FA(X), _FB(X), _FC(X), _FD(X), _FE(X), _FF(X),\n+    /*_00*/ _01(X),\n+    _02(X),\n+    _03(X),\n+    _04(X),\n+    _05(X),\n+    _06(X),\n+    _07(X),\n+    _08(X),\n+    _09(X),\n+    _0A(X),\n+    _0B(X),\n+    _0C(X),\n+    _0D(X),\n+    _0E(X),\n+    _0F(X),\n+    _10(X),\n+    _11(X),\n+    _12(X),\n+    _13(X),\n+    _14(X),\n+    _15(X),\n+    _16(X),\n+    _17(X),\n+    _18(X),\n+    _19(X),\n+    _1A(X),\n+    _1B(X),\n+    _1C(X),\n+    _1D(X),\n+    _1E(X),\n+    _1F(X),\n+    _20(X),\n+    _21(X),\n+    _22(X),\n+    _23(X),\n+    _24(X),\n+    _25(X),\n+    _26(X),\n+    _27(X),\n+    _28(X),\n+    _29(X),\n+    _2A(X),\n+    _2B(X),\n+    _2C(X),\n+    _2D(X),\n+    _2E(X),\n+    _2F(X),\n+    _30(X),\n+    _31(X),\n+    _32(X),\n+    _33(X),\n+    _34(X),\n+    _35(X),\n+    _36(X),\n+    _37(X),\n+    _38(X),\n+    _39(X),\n+    _3A(X),\n+    _3B(X),\n+    _3C(X),\n+    _3D(X),\n+    _3E(X),\n+    _3F(X),\n+    _40(X),\n+    _41(X),\n+    _42(X),\n+    _43(X),\n+    _44(X),\n+    _45(X),\n+    _46(X),\n+    _47(X),\n+    _48(X),\n+    _49(X),\n+    _4A(X),\n+    _4B(X),\n+    _4C(X),\n+    _4D(X),\n+    _4E(X),\n+    _4F(X),\n+    _50(X),\n+    _51(X),\n+    _52(X),\n+    _53(X),\n+    _54(X),\n+    _55(X),\n+    _56(X),\n+    _57(X),\n+    _58(X),\n+    _59(X),\n+    _5A(X),\n+    _5B(X),\n+    _5C(X),\n+    _5D(X),\n+    _5E(X),\n+    _5F(X),\n+    _60(X),\n+    _61(X),\n+    _62(X),\n+    _63(X),\n+    _64(X),\n+    _65(X),\n+    _66(X),\n+    _67(X),\n+    _68(X),\n+    _69(X),\n+    _6A(X),\n+    _6B(X),\n+    _6C(X),\n+    _6D(X),\n+    _6E(X),\n+    _6F(X),\n+    _70(X),\n+    _71(X),\n+    _72(X),\n+    _73(X),\n+    _74(X),\n+    _75(X),\n+    _76(X),\n+    _77(X),\n+    _78(X),\n+    _79(X),\n+    _7A(X),\n+    _7B(X),\n+    _7C(X),\n+    _7D(X),\n+    _7E(X),\n+    _7F(X),\n+    _80(X),\n+    _81(X),\n+    _82(X),\n+    _83(X),\n+    _84(X),\n+    _85(X),\n+    _86(X),\n+    _87(X),\n+    _88(X),\n+    _89(X),\n+    _8A(X),\n+    _8B(X),\n+    _8C(X),\n+    _8D(X),\n+    _8E(X),\n+    _8F(X),\n+    _90(X),\n+    _91(X),\n+    _92(X),\n+    _93(X),\n+    _94(X),\n+    _95(X),\n+    _96(X),\n+    _97(X),\n+    _98(X),\n+    _99(X),\n+    _9A(X),\n+    _9B(X),\n+    _9C(X),\n+    _9D(X),\n+    _9E(X),\n+    _9F(X),\n+    _A0(X),\n+    _A1(X),\n+    _A2(X),\n+    _A3(X),\n+    _A4(X),\n+    _A5(X),\n+    _A6(X),\n+    _A7(X),\n+    _A8(X),\n+    _A9(X),\n+    _AA(X),\n+    _AB(X),\n+    _AC(X),\n+    _AD(X),\n+    _AE(X),\n+    _AF(X),\n+    _B0(X),\n+    _B1(X),\n+    _B2(X),\n+    _B3(X),\n+    _B4(X),\n+    _B5(X),\n+    _B6(X),\n+    _B7(X),\n+    _B8(X),\n+    _B9(X),\n+    _BA(X),\n+    _BB(X),\n+    _BC(X),\n+    _BD(X),\n+    _BE(X),\n+    _BF(X),\n+    _C0(X),\n+    _C1(X),\n+    _C2(X),\n+    _C3(X),\n+    _C4(X),\n+    _C5(X),\n+    _C6(X),\n+    _C7(X),\n+    _C8(X),\n+    _C9(X),\n+    _CA(X),\n+    _CB(X),\n+    _CC(X),\n+    _CD(X),\n+    _CE(X),\n+    _CF(X),\n+    _D0(X),\n+    _D1(X),\n+    _D2(X),\n+    _D3(X),\n+    _D4(X),\n+    _D5(X),\n+    _D6(X),\n+    _D7(X),\n+    _D8(X),\n+    _D9(X),\n+    _DA(X),\n+    _DB(X),\n+    _DC(X),\n+    _DD(X),\n+    _DE(X),\n+    _DF(X),\n+    _E0(X),\n+    _E1(X),\n+    _E2(X),\n+    _E3(X),\n+    _E4(X),\n+    _E5(X),\n+    _E6(X),\n+    _E7(X),\n+    _E8(X),\n+    _E9(X),\n+    _EA(X),\n+    _EB(X),\n+    _EC(X),\n+    _ED(X),\n+    _EE(X),\n+    _EF(X),\n+    _F0(X),\n+    _F1(X),\n+    _F2(X),\n+    _F3(X),\n+    _F4(X),\n+    _F5(X),\n+    _F6(X),\n+    _F7(X),\n+    _F8(X),\n+    _F9(X),\n+    _FA(X),\n+    _FB(X),\n+    _FC(X),\n+    _FD(X),\n+    _FE(X),\n+    _FF(X),\n \n     V3,\n     V4,\n }\n \n-fn check_niche_behavior () {\n+fn check_niche_behavior() {\n     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n         intrinsics::abort();\n     }"}, {"sha": "e34b35d5c4a8c481253e4b51764fdaaf72babc79", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -58,8 +58,9 @@ fn main() {\n     assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n     assert_eq!(core::intrinsics::saturating_sub(0, -170141183460469231731687303715884105728i128), 170141183460469231731687303715884105727i128);\n \n-    let _d = 0i128.checked_div(2i128);\n-    let _d = 0u128.checked_div(2u128);\n+    std::hint::black_box(std::hint::black_box(7571400400375753350092698930310845914i128) * 10);\n+    assert!(0i128.checked_div(2i128).is_some());\n+    assert!(0u128.checked_div(2u128).is_some());\n     assert_eq!(1u128 + 2, 3);\n \n     assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);"}, {"sha": "eb452c5cd377268b031cee0a3890c3b625333ef5", "filename": "compiler/rustc_codegen_cranelift/patches/0003-rand-Disable-rand-tests-on-mingw.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -19,8 +19,8 @@ index 217899e..9cedeb7 100644\n +    // This is broken on x86_64-pc-windows-gnu presumably due to a broken powf implementation\n +    #[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n      fn value_stability() {\n-         fn test_samples<F: Float + core::fmt::Debug, D: Distribution<F>>(\n-             distr: D, zero: F, expected: &[F],\n+         fn test_samples<F: Float + Debug + Display + LowerExp, D: Distribution<F>>(\n+             distr: D, thresh: F, expected: &[F],\n diff --git a/rand_distr/tests/value_stability.rs b/rand_distr/tests/value_stability.rs\n index 192ba74..0101ace 100644\n --- a/rand_distr/tests/value_stability.rs"}, {"sha": "6afa5c71fe51fa8cb16c78ff116d07292e35acef", "filename": "compiler/rustc_codegen_cranelift/patches/0022-coretests-Disable-not-compiling-tests.patch", "status": "renamed", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -13,14 +13,14 @@ Subject: [PATCH] [core] Disable not compiling tests\n  6 files changed, 16 insertions(+), 1 deletion(-)\n  create mode 100644 library/core/tests/Cargo.toml\n \n-diff --git a/library/core/tests/Cargo.toml b/library/core/tests/Cargo.toml\n+diff --git a/Cargo.toml b/Cargo.toml\n new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n-+++ b/library/core/tests/Cargo.toml\n++++ b/Cargo.toml\n @@ -0,0 +1,12 @@\n +[package]\n-+name = \"core\"\n++name = \"coretests\"\n +version = \"0.0.0\"\n +edition = \"2021\"\n +\n@@ -31,5 +31,14 @@ index 0000000..46fd999\n +[dependencies]\n +rand = { version = \"0.8.5\", default-features = false }\n +rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/lib.rs b/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/lib.rs\n++++ b/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch"}, {"sha": "f2cb82751f0821ff857fe2ae0f229d5aca450501", "filename": "compiler/rustc_codegen_cranelift/patches/0023-coretests-Ignore-failing-tests.patch", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -10,10 +10,10 @@ Subject: [PATCH] [core] Ignore failing tests\n  library/core/tests/time.rs       |  1 +\n  4 files changed, 18 insertions(+), 2 deletions(-)\n \n-diff --git a/library/core/tests/array.rs b/library/core/tests/array.rs\n+diff --git a/array.rs b/array.rs\n index 4bc44e9..8e3c7a4 100644\n---- a/library/core/tests/array.rs\n-+++ b/library/core/tests/array.rs\n+--- a/array.rs\n++++ b/array.rs\n @@ -242,6 +242,7 @@ fn iterator_drops() {\n      assert_eq!(i.get(), 5);\n  }\n@@ -46,10 +46,10 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n-diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+diff --git a/atomic.rs b/atomic.rs\n index 13b12db..96fe4b9 100644\n---- a/library/core/tests/atomic.rs\n-+++ b/library/core/tests/atomic.rs\n+--- a/atomic.rs\n++++ b/atomic.rs\n @@ -185,6 +185,7 @@ fn ptr_bitops() {\n  }\n  ", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch"}, {"sha": "1d5479beddee915871f801c0892a4c2c25baf73d", "filename": "compiler/rustc_codegen_cranelift/patches/0027-coretests-128bit-atomic-operations.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,30 @@\n+From ad7ffe71baba46865f2e65266ab025920dfdc20b Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/panic/unwind_safe.rs |  6 -----\n+ library/core/src/sync/atomic.rs       | 38 ---------------------------\n+ library/core/tests/atomic.rs          |  4 ---\n+ 4 files changed, 4 insertions(+), 50 deletions(-)\n+\n+diff --git a/atomic.rs b/atomic.rs\n+index b735957..ea728b6 100644\n+--- a/atomic.rs\n++++ b/atomic.rs\n+@@ -185,10 +185,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+--\n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "45f73f36b93171ddd2b32b2571666fd25674ced6", "filename": "compiler/rustc_codegen_cranelift/patches/0027-stdlib-128bit-atomic-operations.patch", "status": "renamed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -85,21 +85,6 @@ index d9de37e..8293fce 100644\n  \n  macro_rules! atomic_int_ptr_sized {\n      ( $($target_pointer_width:literal $align:literal)* ) => { $(\n-diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n-index b735957..ea728b6 100644\n---- a/library/core/tests/atomic.rs\n-+++ b/library/core/tests/atomic.rs\n-@@ -185,10 +185,6 @@ fn atomic_alignment() {\n-     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n-     #[cfg(target_has_atomic = \"64\")]\n-     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n--    #[cfg(target_has_atomic = \"128\")]\n--    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n--    #[cfg(target_has_atomic = \"128\")]\n--    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n-     #[cfg(target_has_atomic = \"ptr\")]\n-     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n-     #[cfg(target_has_atomic = \"ptr\")]\n --\n 2.26.2.7.g19db9cfb68\n ", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch"}, {"sha": "440177018f428e66a124963332c13a9f328e3c9c", "filename": "compiler/rustc_codegen_cranelift/patches/0028-coretests-Disable-long-running-tests.patch", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -7,10 +7,10 @@ Subject: [PATCH] Disable long running tests\n  library/core/tests/slice.rs | 2 ++\n  1 file changed, 2 insertions(+)\n \n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+diff --git a/slice.rs b/slice.rs\n index 8402833..84592e0 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n+--- a/slice.rs\n++++ b/slice.rs\n @@ -1809,6 +1809,7 @@ fn sort_unstable() {\n      assert!(v == [0xDEADBEEF]);\n  }", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0028-sysroot-Disable-long-running-tests.patch"}, {"sha": "2236a6ca15521cf1deb6ee9bb69bf07f92c346df", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-02-06\"\n+channel = \"nightly-2023-03-15\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "939a1f1ca59001a39feb12e643716b45cf704c5c", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,11 +1,14 @@\n use std::env;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let mut rustflags = String::new();\n     rustflags.push_str(\" -Cpanic=abort -Zpanic-abort-tests -Zcodegen-backend=\");"}, {"sha": "b9bba7f2e084c8d50a43d5e1a760ee5bdb62b65c", "filename": "compiler/rustc_codegen_cranelift/scripts/rustc-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,11 +2,14 @@ use std::env;\n use std::ffi::OsString;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,"}, {"sha": "167631eaf7ee49d5a8121760a9d686a71aa9186c", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,11 +2,14 @@ use std::env;\n use std::ffi::OsString;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,"}, {"sha": "3cbeb6375de109011fb29e3847f40173b188cae2", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,10 +2,24 @@\n \n set -e\n \n+TOOLCHAIN=${TOOLCHAIN:-$(date +%Y-%m-%d)}\n+\n+function check_git_fixed_subtree() {\n+    if [[ ! -e ./git-fixed-subtree.sh ]]; then\n+        echo \"Missing git-fixed-subtree.sh. Please run the following commands to download it:\"\n+        echo \"curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/bjorn3/git/tqc-subtree-portable/contrib/subtree/git-subtree.sh -o git-fixed-subtree.sh\"\n+        echo \"chmod u+x git-fixed-subtree.sh\"\n+        exit 1\n+    fi\n+    if [[ ! -x ./git-fixed-subtree.sh ]]; then\n+        echo \"git-fixed-subtree.sh is not executable. Please run the following command to make it executable:\"\n+        echo \"chmod u+x git-fixed-subtree.sh\"\n+        exit 1\n+    fi\n+}\n+\n case $1 in\n     \"prepare\")\n-        TOOLCHAIN=$(date +%Y-%m-%d)\n-\n         echo \"=> Installing new nightly\"\n         rustup toolchain install --profile minimal \"nightly-${TOOLCHAIN}\" # Sanity check to see if the nightly exists\n         sed -i \"s/\\\"nightly-.*\\\"/\\\"nightly-${TOOLCHAIN}\\\"/\" rust-toolchain\n@@ -27,28 +41,35 @@ case $1 in\n         git commit -m \"Rustup to $(rustc -V)\"\n         ;;\n     \"push\")\n+        check_git_fixed_subtree\n+\n         cg_clif=$(pwd)\n         pushd ../rust\n         git pull origin master\n         branch=sync_cg_clif-$(date +%Y-%m-%d)\n         git checkout -b \"$branch\"\n-        git subtree pull --prefix=compiler/rustc_codegen_cranelift/ https://github.com/bjorn3/rustc_codegen_cranelift.git master\n+        \"$cg_clif/git-fixed-subtree.sh\" pull --prefix=compiler/rustc_codegen_cranelift/ https://github.com/bjorn3/rustc_codegen_cranelift.git master\n         git push -u my \"$branch\"\n \n         # immediately merge the merge commit into cg_clif to prevent merge conflicts when syncing\n         # from rust-lang/rust later\n-        git subtree push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n+        \"$cg_clif/git-fixed-subtree.sh\" push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n         popd\n         git merge sync_from_rust\n \t;;\n     \"pull\")\n+        check_git_fixed_subtree\n+\n+        RUST_VERS=$(curl \"https://static.rust-lang.org/dist/$TOOLCHAIN/channel-rust-nightly-git-commit-hash.txt\")\n+        echo \"Pulling $RUST_VERS ($TOOLCHAIN)\"\n+\n         cg_clif=$(pwd)\n         pushd ../rust\n-        git pull origin master\n-        rust_vers=\"$(git rev-parse HEAD)\"\n-        git subtree push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n+        git fetch origin master\n+        git checkout \"$RUST_VERS\"\n+        \"$cg_clif/git-fixed-subtree.sh\" push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n         popd\n-        git merge sync_from_rust -m \"Sync from rust $rust_vers\"\n+        git merge sync_from_rust -m \"Sync from rust $RUST_VERS\"\n         git branch -d sync_from_rust\n         ;;\n     *)"}, {"sha": "abb09775d213511041756911473c75632643ef2a", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -10,7 +10,7 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n-git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-sysroot-*.patch\n+git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-stdlib-*.patch\n \n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n@@ -36,7 +36,7 @@ changelog-seen = 2\n ninja = false\n \n [build]\n-rustc = \"$(pwd)/../dist/rustc-clif\"\n+rustc = \"$(pwd)/../dist/bin/rustc-clif\"\n cargo = \"$(rustup which cargo)\"\n full-bootstrap = true\n local-rebuild = true"}, {"sha": "20dcb4cf34d2f8a4e6d2c61f08fda116fa85ce90", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -21,6 +21,7 @@ done\n \n git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n git checkout -- tests/ui/proc-macro/pretty-print-hack/\n+rm tests/ui/parser/unclosed-delimiter-in-dep.rs # submodule contains //~ERROR\n \n # missing features\n # ================\n@@ -80,6 +81,7 @@ rm tests/ui/layout/valid_range_oob.rs # different ICE message\n \n rm tests/ui/consts/issue-miri-1910.rs # different error message\n rm tests/ui/consts/offset_ub.rs # same\n+rm tests/ui/consts/const-eval/ub-slice-get-unchecked.rs # same\n rm tests/ui/intrinsics/panic-uninitialized-zeroed.rs # same\n rm tests/ui/lint/lint-const-item-mutation.rs # same\n rm tests/ui/pattern/usefulness/doc-hidden-non-exhaustive.rs # same\n@@ -110,12 +112,9 @@ rm tests/incremental/spike-neg2.rs # same\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type filed (#1318)\n+rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type field (#1318)\n rm tests/ui/simd/simd-bitmask.rs # crash\n \n-rm tests/ui/dyn-star/dyn-star-to-dyn.rs\n-rm tests/ui/dyn-star/dispatch-on-pin-mut.rs\n-\n # bugs in the test suite\n # ======================\n rm tests/ui/backtrace.rs # TODO warning"}, {"sha": "3bc64c44524ed9c3e76e21df025d6a91541944ab", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -4,6 +4,8 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use std::borrow::Cow;\n+\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n@@ -25,7 +27,7 @@ fn clif_sig_from_fn_abi<'tcx>(\n ) -> Signature {\n     let call_conv = conv_to_call_conv(tcx.sess, fn_abi.conv, default_call_conv);\n \n-    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n+    let inputs = fn_abi.args.iter().flat_map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter());\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n@@ -116,7 +118,52 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         params: Vec<AbiParam>,\n         returns: Vec<AbiParam>,\n         args: &[Value],\n-    ) -> &[Value] {\n+    ) -> Cow<'_, [Value]> {\n+        if self.tcx.sess.target.is_like_windows {\n+            let (mut params, mut args): (Vec<_>, Vec<_>) =\n+                params\n+                    .into_iter()\n+                    .zip(args)\n+                    .map(|(param, &arg)| {\n+                        if param.value_type == types::I128 {\n+                            let arg_ptr = Pointer::stack_slot(self.bcx.create_sized_stack_slot(\n+                                StackSlotData { kind: StackSlotKind::ExplicitSlot, size: 16 },\n+                            ));\n+                            arg_ptr.store(self, arg, MemFlags::trusted());\n+                            (AbiParam::new(self.pointer_type), arg_ptr.get_addr(self))\n+                        } else {\n+                            (param, arg)\n+                        }\n+                    })\n+                    .unzip();\n+\n+            let indirect_ret_val = returns.len() == 1 && returns[0].value_type == types::I128;\n+\n+            if indirect_ret_val {\n+                params.insert(0, AbiParam::new(self.pointer_type));\n+                let ret_ptr =\n+                    Pointer::stack_slot(self.bcx.create_sized_stack_slot(StackSlotData {\n+                        kind: StackSlotKind::ExplicitSlot,\n+                        size: 16,\n+                    }));\n+                args.insert(0, ret_ptr.get_addr(self));\n+                self.lib_call_unadjusted(name, params, vec![], &args);\n+                return Cow::Owned(vec![ret_ptr.load(self, types::I128, MemFlags::trusted())]);\n+            } else {\n+                return self.lib_call_unadjusted(name, params, returns, &args);\n+            }\n+        }\n+\n+        self.lib_call_unadjusted(name, params, returns, args)\n+    }\n+\n+    pub(crate) fn lib_call_unadjusted(\n+        &mut self,\n+        name: &str,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n+        args: &[Value],\n+    ) -> Cow<'_, [Value]> {\n         let sig = Signature { params, returns, call_conv: self.target_config.default_call_conv };\n         let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n@@ -125,41 +172,11 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         }\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n-            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+            self.add_comment(call_inst, format!(\"lib_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n-        results\n-    }\n-\n-    pub(crate) fn easy_call(\n-        &mut self,\n-        name: &str,\n-        args: &[CValue<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> CValue<'tcx> {\n-        let (input_tys, args): (Vec<_>, Vec<_>) = args\n-            .iter()\n-            .map(|arg| {\n-                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n-            })\n-            .unzip();\n-        let return_layout = self.layout_of(return_ty);\n-        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.iter().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n-        } else {\n-            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n-        };\n-        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n-        match *ret_vals {\n-            [] => CValue::by_ref(\n-                Pointer::const_addr(self, i64::from(self.pointer_type.bytes())),\n-                return_layout,\n-            ),\n-            [val] => CValue::by_val(val, return_layout),\n-            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n-            _ => unreachable!(),\n-        }\n+        Cow::Borrowed(results)\n     }\n }\n \n@@ -275,10 +292,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n-        let layout = fx.layout_of(ty);\n-\n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n-\n         // While this is normally an optimization to prevent an unnecessary copy when an argument is\n         // not mutated by the current function, this is necessary to support unsized arguments.\n         if let ArgKind::Normal(Some(val)) = arg_kind {\n@@ -300,6 +313,8 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n             }\n         }\n \n+        let layout = fx.layout_of(ty);\n+        let is_ssa = ssa_analyzed[local].is_ssa(fx, ty);\n         let place = make_local_place(fx, local, layout, is_ssa);\n         assert_eq!(fx.local_map.push(place), local);\n \n@@ -323,7 +338,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n         let ty = fx.monomorphize(fx.mir.local_decls[local].ty);\n         let layout = fx.layout_of(ty);\n \n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n+        let is_ssa = ssa_analyzed[local].is_ssa(fx, ty);\n \n         let place = make_local_place(fx, local, layout, is_ssa);\n         assert_eq!(fx.local_map.push(place), local);\n@@ -515,10 +530,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 args.into_iter()\n                     .enumerate()\n                     .skip(if first_arg_override.is_some() { 1 } else { 0 })\n-                    .map(|(i, arg)| {\n+                    .flat_map(|(i, arg)| {\n                         adjust_arg_for_abi(fx, arg.value, &fn_abi.args[i], arg.is_owned).into_iter()\n-                    })\n-                    .flatten(),\n+                    }),\n             )\n             .collect::<Vec<Value>>();\n "}, {"sha": "6d3e8eda276a4e29127a9ac988fa35ba0105cd73", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -14,7 +14,8 @@ pub(super) fn codegen_return_param<'tcx>(\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n-            let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n+            let is_ssa =\n+                ssa_analyzed[RETURN_PLACE].is_ssa(fx, fx.fn_abi.as_ref().unwrap().ret.layout.ty);\n             (\n                 super::make_local_place(\n                     fx,"}, {"sha": "54d5c1c2ae9e9169f7c841e0d8bc5fa675d4573c", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -4,34 +4,30 @@ use crate::prelude::*;\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::StatementKind::*;\n+use rustc_middle::ty::Ty;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum SsaKind {\n     NotSsa,\n-    Ssa,\n+    MaybeSsa,\n+}\n+\n+impl SsaKind {\n+    pub(crate) fn is_ssa<'tcx>(self, fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        self == SsaKind::MaybeSsa && (fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some())\n+    }\n }\n \n pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n-    let mut flag_map = fx\n-        .mir\n-        .local_decls\n-        .iter()\n-        .map(|local_decl| {\n-            let ty = fx.monomorphize(local_decl.ty);\n-            if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n-                SsaKind::Ssa\n-            } else {\n-                SsaKind::NotSsa\n-            }\n-        })\n-        .collect::<IndexVec<Local, SsaKind>>();\n+    let mut flag_map =\n+        fx.mir.local_decls.iter().map(|_| SsaKind::MaybeSsa).collect::<IndexVec<Local, SsaKind>>();\n \n     for bb in fx.mir.basic_blocks.iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {\n                     Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-                        not_ssa(&mut flag_map, place.local)\n+                        flag_map[place.local] = SsaKind::NotSsa;\n                     }\n                     _ => {}\n                 },\n@@ -42,7 +38,3 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n \n     flag_map\n }\n-\n-fn not_ssa(flag_map: &mut IndexVec<Local, SsaKind>, local: Local) {\n-    flag_map[local] = SsaKind::NotSsa;\n-}"}, {"sha": "d0af3729b237c1cf93e927281b4159680a0aa33c", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -192,7 +192,7 @@ pub(crate) fn compile_fn(\n                         let pass_times = cranelift_codegen::timing::take_current();\n                         // Replace newlines with | as measureme doesn't allow control characters like\n                         // newlines inside strings.\n-                        recorder.record_arg(format!(\"{}\", pass_times).replace(\"\\n\", \" | \"));\n+                        recorder.record_arg(format!(\"{}\", pass_times).replace('\\n', \" | \"));\n                         recording_args = true;\n                     },\n                 )\n@@ -365,11 +365,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 fx.bcx.set_cold_block(failure);\n \n                 if *expected {\n-                    fx.bcx.ins().brz(cond, failure, &[]);\n+                    fx.bcx.ins().brif(cond, target, &[], failure, &[]);\n                 } else {\n-                    fx.bcx.ins().brnz(cond, failure, &[]);\n+                    fx.bcx.ins().brif(cond, failure, &[], target, &[]);\n                 };\n-                fx.bcx.ins().jump(target, &[]);\n \n                 fx.bcx.switch_to_block(failure);\n                 fx.bcx.ins().nop();\n@@ -425,11 +424,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                         }\n                     } else {\n                         if test_zero {\n-                            fx.bcx.ins().brz(discr, then_block, &[]);\n-                            fx.bcx.ins().jump(else_block, &[]);\n+                            fx.bcx.ins().brif(discr, else_block, &[], then_block, &[]);\n                         } else {\n-                            fx.bcx.ins().brnz(discr, then_block, &[]);\n-                            fx.bcx.ins().jump(else_block, &[]);\n+                            fx.bcx.ins().brif(discr, then_block, &[], else_block, &[]);\n                         }\n                     }\n                 } else {\n@@ -750,8 +747,7 @@ fn codegen_stmt<'tcx>(\n \n                         fx.bcx.switch_to_block(loop_block);\n                         let done = fx.bcx.ins().icmp_imm(IntCC::Equal, index, times as i64);\n-                        fx.bcx.ins().brnz(done, done_block, &[]);\n-                        fx.bcx.ins().jump(loop_block2, &[]);\n+                        fx.bcx.ins().brif(done, done_block, &[], loop_block2, &[]);\n \n                         fx.bcx.switch_to_block(loop_block2);\n                         let to = lval.place_index(fx, index);\n@@ -997,7 +993,7 @@ fn codegen_panic_inner<'tcx>(\n     let symbol_name = fx.tcx.symbol_name(instance).name;\n \n     fx.lib_call(\n-        &*symbol_name,\n+        symbol_name,\n         args.iter().map(|&arg| AbiParam::new(fx.bcx.func.dfg.value_type(arg))).collect(),\n         vec![],\n         args,"}, {"sha": "032d1151041dbb45b28442075d464a7edae1bb6f", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -64,17 +64,12 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            let to_rust_ty = match to_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            return fx\n-                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx);\n+            return fx.lib_call(\n+                &name,\n+                vec![AbiParam::new(types::I128)],\n+                vec![AbiParam::new(to_ty)],\n+                &[from],\n+            )[0];\n         }\n \n         // int-like -> float\n@@ -101,16 +96,29 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = match from_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            fx.easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx)\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret = fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &[from],\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: 16,\n+                });\n+                let ret_ptr = Pointer::stack_slot(stack_slot);\n+                ret_ptr.store(fx, ret, MemFlags::trusted());\n+                ret_ptr.load(fx, types::I128, MemFlags::trusted())\n+            } else {\n+                fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &[from],\n+                )[0]\n+            }\n         } else if to_ty == types::I8 || to_ty == types::I16 {\n             // FIXME implement fcvt_to_*int_sat.i8/i16\n             let val = if to_signed {"}, {"sha": "f674ce776a68697da60a5de8e30413bc373e38df", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -29,39 +29,24 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked || is_signed => {\n             if !checked {\n-                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-                if fx.tcx.sess.target.is_like_windows {\n-                    let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n-                    let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                    let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                    assert!(lhs_extra.is_none());\n-                    assert!(rhs_extra.is_none());\n-                    let args = [\n-                        ret_place.to_ptr().get_addr(fx),\n-                        lhs_ptr.get_addr(fx),\n-                        rhs_ptr.get_addr(fx),\n-                    ];\n-                    fx.lib_call(\n-                        \"__multi3\",\n-                        vec![\n-                            AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                            AbiParam::new(fx.pointer_type),\n-                            AbiParam::new(fx.pointer_type),\n-                        ],\n-                        vec![],\n-                        &args,\n-                    );\n-                    Some(ret_place.to_cvalue(fx))\n-                } else {\n-                    Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n-                }\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    \"__multi3\",\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(\n+                    ret_val,\n+                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+                ))\n             } else {\n                 let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n                 let lhs = lhs.load_scalar(fx);\n                 let rhs = rhs.load_scalar(fx);\n                 let oflow_ptr = oflow.to_ptr().get_addr(fx);\n-                let res = fx.lib_call(\n+                let res = fx.lib_call_unadjusted(\n                     \"__muloti4\",\n                     vec![\n                         AbiParam::new(types::I128),\n@@ -80,29 +65,12 @@ pub(crate) fn maybe_codegen<'tcx>(\n             assert!(checked);\n             let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(fx.pointer_type),\n-                        AbiParam::new(fx.pointer_type),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n-                )\n-            } else {\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(types::I128),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n-                )\n-            };\n+            let param_types = vec![\n+                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -125,14 +93,10 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 _ => unreachable!(),\n             };\n             if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n                 let ret = fx.lib_call(\n                     name,\n-                    vec![AbiParam::new(fx.pointer_type), AbiParam::new(fx.pointer_type)],\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n                     vec![AbiParam::new(types::I64X2)],\n                     &args,\n                 )[0];\n@@ -141,7 +105,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "d39bf700035f97e0a4ddc79c554ae3ac7f5c7656", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -75,7 +75,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n         ty::Adt(adt_def, _) if adt_def.repr().simd() => {\n             let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n             {\n-                Abi::Vector { element, count } => (element.clone(), *count),\n+                Abi::Vector { element, count } => (*element, *count),\n                 _ => unreachable!(),\n             };\n "}, {"sha": "f3b963200a0fb022f34bc48a2307b9c114830ace", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -39,6 +39,7 @@ builtin_functions! {\n \n     // integers\n     fn __multi3(a: i128, b: i128) -> i128;\n+    fn __muloti4(n: i128, d: i128, oflow: &mut i32) -> i128;\n     fn __udivti3(n: u128, d: u128) -> u128;\n     fn __divti3(n: i128, d: i128) -> i128;\n     fn __umodti3(n: u128, d: u128) -> u128;"}, {"sha": "203219a8a754a6dbc6e548112d876324a750970d", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -32,7 +32,7 @@ impl ConcurrencyLimiter {\n         ConcurrencyLimiter {\n             helper_thread: Some(helper_thread),\n             state,\n-            available_token_condvar: Arc::new(Condvar::new()),\n+            available_token_condvar,\n             finished: false,\n         }\n     }"}, {"sha": "31278f810e911b3d5cc11a512643fd762979559e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -290,7 +290,7 @@ fn data_id_for_static(\n         };\n \n         let data_id = match module.declare_data(\n-            &*symbol_name,\n+            symbol_name,\n             linkage,\n             is_mutable,\n             attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n@@ -338,7 +338,7 @@ fn data_id_for_static(\n     };\n \n     let data_id = match module.declare_data(\n-        &*symbol_name,\n+        symbol_name,\n         linkage,\n         is_mutable,\n         attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),"}, {"sha": "6c4efca442448a700d77e946edb926ab02e8ced9", "filename": "compiler/rustc_codegen_cranelift/src/cranelift_native.rs", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,248 +0,0 @@\n-// Vendored from https://github.com/bytecodealliance/wasmtime/blob/b58a197d33f044193c3d608010f5e6ec394ac07e/cranelift/native/src/lib.rs\n-// which is licensed as\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-// unlike rustc_codegen_cranelift itself. Also applies a small change to remove #![cfg_attr] that\n-// rust's CI complains about and to fix formatting to match rustc.\n-// FIXME revert back to the external crate with Cranelift 0.93\n-#![allow(warnings)]\n-\n-//! Performs autodetection of the host for the purposes of running\n-//! Cranelift to generate code to run on the same machine.\n-\n-#![deny(missing_docs, trivial_numeric_casts, unused_extern_crates, unstable_features)]\n-#![warn(unused_import_braces)]\n-\n-use cranelift_codegen::isa;\n-use target_lexicon::Triple;\n-\n-/// Return an `isa` builder configured for the current host\n-/// machine, or `Err(())` if the host machine is not supported\n-/// in the current configuration.\n-pub fn builder() -> Result<isa::Builder, &'static str> {\n-    builder_with_options(true)\n-}\n-\n-/// Return an `isa` builder configured for the current host\n-/// machine, or `Err(())` if the host machine is not supported\n-/// in the current configuration.\n-///\n-/// Selects the given backend variant specifically; this is\n-/// useful when more than oen backend exists for a given target\n-/// (e.g., on x86-64).\n-pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {\n-    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {\n-        isa::LookupError::SupportDisabled => \"support for architecture disabled at compile time\",\n-        isa::LookupError::Unsupported => \"unsupported architecture\",\n-    })?;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !std::is_x86_feature_detected!(\"sse2\") {\n-            return Err(\"x86 support requires SSE2\");\n-        }\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        // These are temporarily enabled by default (see #3810 for\n-        // more) so that a default-constructed `Flags` can work with\n-        // default Wasmtime features. Otherwise, the user must\n-        // explicitly use native flags or turn these on when on x86-64\n-        // platforms to avoid a configuration panic. In order for the\n-        // \"enable if detected\" logic below to work, we must turn them\n-        // *off* (differing from the default) and then re-enable below\n-        // if present.\n-        isa_builder.set(\"has_sse3\", \"false\").unwrap();\n-        isa_builder.set(\"has_ssse3\", \"false\").unwrap();\n-        isa_builder.set(\"has_sse41\", \"false\").unwrap();\n-        isa_builder.set(\"has_sse42\", \"false\").unwrap();\n-\n-        if std::is_x86_feature_detected!(\"sse3\") {\n-            isa_builder.enable(\"has_sse3\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"ssse3\") {\n-            isa_builder.enable(\"has_ssse3\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"sse4.1\") {\n-            isa_builder.enable(\"has_sse41\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"sse4.2\") {\n-            isa_builder.enable(\"has_sse42\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"popcnt\") {\n-            isa_builder.enable(\"has_popcnt\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx\") {\n-            isa_builder.enable(\"has_avx\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx2\") {\n-            isa_builder.enable(\"has_avx2\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"fma\") {\n-            isa_builder.enable(\"has_fma\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"bmi1\") {\n-            isa_builder.enable(\"has_bmi1\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"bmi2\") {\n-            isa_builder.enable(\"has_bmi2\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512bitalg\") {\n-            isa_builder.enable(\"has_avx512bitalg\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512dq\") {\n-            isa_builder.enable(\"has_avx512dq\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512f\") {\n-            isa_builder.enable(\"has_avx512f\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512vl\") {\n-            isa_builder.enable(\"has_avx512vl\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512vbmi\") {\n-            isa_builder.enable(\"has_avx512vbmi\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"lzcnt\") {\n-            isa_builder.enable(\"has_lzcnt\").unwrap();\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"aarch64\")]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        if std::arch::is_aarch64_feature_detected!(\"lse\") {\n-            isa_builder.enable(\"has_lse\").unwrap();\n-        }\n-\n-        if std::arch::is_aarch64_feature_detected!(\"paca\") {\n-            isa_builder.enable(\"has_pauth\").unwrap();\n-        }\n-\n-        if cfg!(target_os = \"macos\") {\n-            // Pointer authentication is always available on Apple Silicon.\n-            isa_builder.enable(\"sign_return_address\").unwrap();\n-            // macOS enforces the use of the B key for return addresses.\n-            isa_builder.enable(\"sign_return_address_with_bkey\").unwrap();\n-        }\n-    }\n-\n-    // There is no is_s390x_feature_detected macro yet, so for now\n-    // we use getauxval from the libc crate directly.\n-    #[cfg(all(target_arch = \"s390x\", target_os = \"linux\"))]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n-        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;\n-        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {\n-            isa_builder.enable(\"has_vxrs_ext2\").unwrap();\n-            // There is no separate HWCAP bit for mie2, so assume\n-            // that any machine with vxrs_ext2 also has mie2.\n-            isa_builder.enable(\"has_mie2\").unwrap();\n-        }\n-    }\n-\n-    // `is_riscv_feature_detected` is nightly only for now, use\n-    // getauxval from the libc crate directly as a temporary measure.\n-    #[cfg(all(target_arch = \"riscv64\", target_os = \"linux\"))]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n-\n-        const HWCAP_RISCV_EXT_A: libc::c_ulong = 1 << (b'a' - b'a');\n-        const HWCAP_RISCV_EXT_C: libc::c_ulong = 1 << (b'c' - b'a');\n-        const HWCAP_RISCV_EXT_D: libc::c_ulong = 1 << (b'd' - b'a');\n-        const HWCAP_RISCV_EXT_F: libc::c_ulong = 1 << (b'f' - b'a');\n-        const HWCAP_RISCV_EXT_M: libc::c_ulong = 1 << (b'm' - b'a');\n-        const HWCAP_RISCV_EXT_V: libc::c_ulong = 1 << (b'v' - b'a');\n-\n-        if (v & HWCAP_RISCV_EXT_A) != 0 {\n-            isa_builder.enable(\"has_a\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_C) != 0 {\n-            isa_builder.enable(\"has_c\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_D) != 0 {\n-            isa_builder.enable(\"has_d\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_F) != 0 {\n-            isa_builder.enable(\"has_f\").unwrap();\n-\n-            // TODO: There doesn't seem to be a bit associated with this extension\n-            // rust enables it with the `f` extension:\n-            // https://github.com/rust-lang/stdarch/blob/790411f93c4b5eada3c23abb4c9a063fb0b24d99/crates/std_detect/src/detect/os/linux/riscv.rs#L43\n-            isa_builder.enable(\"has_zicsr\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_M) != 0 {\n-            isa_builder.enable(\"has_m\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_V) != 0 {\n-            isa_builder.enable(\"has_v\").unwrap();\n-        }\n-\n-        // TODO: ZiFencei does not have a bit associated with it\n-        // TODO: Zbkb does not have a bit associated with it\n-    }\n-\n-    // squelch warnings about unused mut/variables on some platforms.\n-    drop(&mut isa_builder);\n-    drop(infer_native_flags);\n-\n-    Ok(isa_builder)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::builder;\n-    use cranelift_codegen::isa::CallConv;\n-    use cranelift_codegen::settings;\n-\n-    #[test]\n-    fn test() {\n-        if let Ok(isa_builder) = builder() {\n-            let flag_builder = settings::builder();\n-            let isa = isa_builder.finish(settings::Flags::new(flag_builder)).unwrap();\n-\n-            if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n-                assert_eq!(isa.default_call_conv(), CallConv::AppleAarch64);\n-            } else if cfg!(any(unix, target_os = \"nebulet\")) {\n-                assert_eq!(isa.default_call_conv(), CallConv::SystemV);\n-            } else if cfg!(windows) {\n-                assert_eq!(isa.default_call_conv(), CallConv::WindowsFastcall);\n-            }\n-\n-            if cfg!(target_pointer_width = \"64\") {\n-                assert_eq!(isa.pointer_bits(), 64);\n-            } else if cfg!(target_pointer_width = \"32\") {\n-                assert_eq!(isa.pointer_bits(), 32);\n-            } else if cfg!(target_pointer_width = \"16\") {\n-                assert_eq!(isa.pointer_bits(), 16);\n-            }\n-        }\n-    }\n-}\n-\n-/// Version number of this crate.\n-pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");"}, {"sha": "c4a5627e662f1d06907855640591c6cb985153c2", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -113,7 +113,7 @@ impl Writer for WriterRelocate {\n                     offset: offset as u32,\n                     size,\n                     name: DebugRelocName::Symbol(symbol),\n-                    addend: addend as i64,\n+                    addend,\n                     kind: object::RelocationKind::Absolute,\n                 });\n                 self.write_udata(0, size)"}, {"sha": "3e2e2af968860978c8655162c58660d31d40dcf0", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -377,7 +377,7 @@ pub(crate) fn run_aot(\n     };\n \n     if tcx.dep_graph.is_fully_enabled() {\n-        for cgu in &*cgus {\n+        for cgu in cgus {\n             tcx.ensure().codegen_unit(cgu.name());\n         }\n     }\n@@ -417,7 +417,7 @@ pub(crate) fn run_aot(\n                     CguReuse::PreLto => unreachable!(),\n                     CguReuse::PostLto => {\n                         concurrency_limiter.job_already_done();\n-                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, cgu))\n                     }\n                 }\n             })"}, {"sha": "f6a48e3257bc246f8731b40fc9142f54c65fb585", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -311,7 +311,11 @@ fn dep_symbol_lookup_fn(\n         .find(|(crate_type, _data)| *crate_type == rustc_session::config::CrateType::Executable)\n         .unwrap()\n         .1;\n-    for &cnum in &crate_info.used_crates {\n+    // `used_crates` is in reverse postorder in terms of dependencies. Reverse the order here to\n+    // get a postorder which ensures that all dependencies of a dylib are loaded before the dylib\n+    // itself. This helps the dynamic linker to find dylibs not in the regular dynamic library\n+    // search path.\n+    for &cnum in crate_info.used_crates.iter().rev() {\n         let src = &crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}"}, {"sha": "a74f8ffa23d43546acd606b4af8fdb356a8d5d51", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -125,7 +125,7 @@ pub(crate) fn compile_global_asm(\n     let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file, \".asm\");\n     let mut child = Command::new(&config.assembler)\n         .arg(\"-o\")\n         .arg(&global_asm_object_file)"}, {"sha": "3ba530c040f7f9236df19902f083896f6074dcc8", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -242,7 +242,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 }\n             }\n             InlineAsmOperand::Const { ref value } => {\n-                let (const_value, ty) = crate::constant::eval_mir_constant(fx, &*value)\n+                let (const_value, ty) = crate::constant::eval_mir_constant(fx, value)\n                     .unwrap_or_else(|| span_bug!(span, \"asm const cannot be resolved\"));\n                 let value = rustc_codegen_ssa::common::asm_const_to_str(\n                     fx.tcx,\n@@ -334,13 +334,13 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             }\n             CInlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n-                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), place.clone()));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), *place));\n                 }\n             }\n             CInlineAsmOperand::InOut { reg: _, _late: _, in_value, out_place } => {\n                 inputs.push((asm_gen.stack_slots_input[i].unwrap(), in_value.load_scalar(fx)));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), out_place.clone()));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), *out_place));\n                 }\n             }\n             CInlineAsmOperand::Const { value: _ } | CInlineAsmOperand::Symbol { symbol: _ } => {}"}, {"sha": "fe48cac4faf1a14001cfac2e53a13c252bd94db7", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -23,7 +23,7 @@ pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use rustc_middle::ty;\n use rustc_middle::ty::layout::{HasParamEnv, ValidityRequirement};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n@@ -252,45 +252,45 @@ fn codegen_float_intrinsic_call<'tcx>(\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n ) -> bool {\n-    let (name, arg_count, ty) = match intrinsic {\n-        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32),\n-        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64),\n-        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32),\n-        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64),\n-        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32),\n-        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64),\n-        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32), // compiler-builtins\n-        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64), // compiler-builtins\n-        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32),\n-        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64),\n-        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32),\n-        sym::logf64 => (\"log\", 1, fx.tcx.types.f64),\n-        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32),\n-        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64),\n-        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32),\n-        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64),\n-        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32),\n-        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64),\n-        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32),\n-        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64),\n-        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32),\n-        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64),\n-        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32),\n-        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64),\n-        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32),\n-        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n-        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n-        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n-        sym::rintf32 => (\"rintf\", 1, fx.tcx.types.f32),\n-        sym::rintf64 => (\"rint\", 1, fx.tcx.types.f64),\n-        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n-        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n-        sym::roundevenf32 => (\"roundevenf\", 1, fx.tcx.types.f32),\n-        sym::roundevenf64 => (\"roundeven\", 1, fx.tcx.types.f64),\n-        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n-        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n-        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),\n-        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64),\n+    let (name, arg_count, ty, clif_ty) = match intrinsic {\n+        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64, types::F64),\n+        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64, types::F64),\n+        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32, types::F32), // compiler-builtins\n+        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64, types::F64), // compiler-builtins\n+        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64, types::F64),\n+        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::logf64 => (\"log\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32, types::F32),\n+        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64, types::F64),\n+        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64, types::F64),\n+        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64, types::F64),\n+        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64, types::F64),\n+        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64, types::F64),\n+        sym::rintf32 => (\"rintf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::rintf64 => (\"rint\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundevenf32 => (\"roundevenf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundevenf64 => (\"roundeven\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64, types::F64),\n+        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64, types::F64),\n         _ => return false,\n     };\n \n@@ -301,15 +301,19 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let (a, b, c);\n     let args = match args {\n         [x] => {\n-            a = [codegen_operand(fx, x)];\n+            a = [codegen_operand(fx, x).load_scalar(fx)];\n             &a as &[_]\n         }\n         [x, y] => {\n-            b = [codegen_operand(fx, x), codegen_operand(fx, y)];\n+            b = [codegen_operand(fx, x).load_scalar(fx), codegen_operand(fx, y).load_scalar(fx)];\n             &b\n         }\n         [x, y, z] => {\n-            c = [codegen_operand(fx, x), codegen_operand(fx, y), codegen_operand(fx, z)];\n+            c = [\n+                codegen_operand(fx, x).load_scalar(fx),\n+                codegen_operand(fx, y).load_scalar(fx),\n+                codegen_operand(fx, z).load_scalar(fx),\n+            ];\n             &c\n         }\n         _ => unreachable!(),\n@@ -318,15 +322,10 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let layout = fx.layout_of(ty);\n     let res = match intrinsic {\n         sym::fmaf32 | sym::fmaf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            let c = args[2].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+            CValue::by_val(fx.bcx.ins().fma(args[0], args[1], args[2]), layout)\n         }\n         sym::copysignf32 | sym::copysignf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+            CValue::by_val(fx.bcx.ins().fcopysign(args[0], args[1]), layout)\n         }\n         sym::fabsf32\n         | sym::fabsf64\n@@ -336,21 +335,29 @@ fn codegen_float_intrinsic_call<'tcx>(\n         | sym::ceilf64\n         | sym::truncf32\n         | sym::truncf64 => {\n-            let a = args[0].load_scalar(fx);\n-\n             let val = match intrinsic {\n-                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n-                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n-                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n-                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(args[0]),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(args[0]),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(args[0]),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(args[0]),\n                 _ => unreachable!(),\n             };\n \n             CValue::by_val(val, layout)\n         }\n+\n         // These intrinsics aren't supported natively by Cranelift.\n         // Lower them to a libcall.\n-        _ => fx.easy_call(name, &args, ty),\n+        sym::powif32 | sym::powif64 => {\n+            let input_tys: Vec<_> = vec![AbiParam::new(clif_ty), AbiParam::new(types::I32)];\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n+        _ => {\n+            let input_tys: Vec<_> = args.iter().map(|_| AbiParam::new(clif_ty)).collect();\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n     };\n \n     ret.write_cvalue(fx, res);\n@@ -385,7 +392,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n             fx.bcx.ins().debugtrap();\n         }\n-        sym::copy | sym::copy_nonoverlapping => {\n+        sym::copy => {\n             intrinsic_args!(fx, args => (src, dst, count); intrinsic);\n             let src = src.load_scalar(fx);\n             let dst = dst.load_scalar(fx);\n@@ -397,13 +404,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let byte_amount =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n \n-            if intrinsic == sym::copy_nonoverlapping {\n-                // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.target_config, dst, src, byte_amount);\n-            } else {\n-                // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n-            }\n+            // FIXME emit_small_memmove\n+            fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n         }\n         sym::volatile_copy_memory | sym::volatile_copy_nonoverlapping_memory => {\n             // NOTE: the volatile variants have src and dst swapped\n@@ -643,26 +645,25 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n                 if do_panic {\n                     let layout = fx.layout_of(ty);\n-\n-                    with_no_trimmed_paths!({\n-                        crate::base::codegen_panic_nounwind(\n-                            fx,\n-                            &if layout.abi.is_uninhabited() {\n-                                format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty)\n-                            } else if requirement == ValidityRequirement::Zero {\n+                    let msg_str = with_no_visible_paths!({\n+                        with_no_trimmed_paths!({\n+                            if layout.abi.is_uninhabited() {\n+                                // Use this error even for the other intrinsics as it is more precise.\n+                                format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n+                            } else if intrinsic == sym::assert_zero_valid {\n                                 format!(\n                                     \"attempted to zero-initialize type `{}`, which is invalid\",\n-                                    layout.ty\n+                                    ty\n                                 )\n                             } else {\n                                 format!(\n                                     \"attempted to leave type `{}` uninitialized, which is invalid\",\n-                                    layout.ty\n+                                    ty\n                                 )\n-                            },\n-                            source_info,\n-                        )\n+                            }\n+                        })\n                     });\n+                    crate::base::codegen_panic_nounwind(fx, &msg_str, source_info);\n                     return;\n                 }\n             }"}, {"sha": "034b4e8072cc588787b76fcfc5add316217c747f", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -279,9 +279,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n                 let trap_block = fx.bcx.create_block();\n                 let true_ = fx.bcx.ins().iconst(types::I8, 1);\n-                fx.bcx.ins().brnz(true_, trap_block, &[]);\n                 let ret_block = fx.get_block(target);\n-                fx.bcx.ins().jump(ret_block, &[]);\n+                fx.bcx.ins().brif(true_, trap_block, &[], ret_block, &[]);\n                 fx.bcx.switch_to_block(trap_block);\n                 crate::trap::trap_unimplemented(\n                     fx,\n@@ -825,8 +824,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let next = fx.bcx.create_block();\n                 let res_lane = fx.bcx.append_block_param(next, lane_clif_ty);\n \n-                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n-                fx.bcx.ins().jump(if_disabled, &[]);\n+                fx.bcx.ins().brif(mask_lane, if_enabled, &[], if_disabled, &[]);\n                 fx.bcx.seal_block(if_enabled);\n                 fx.bcx.seal_block(if_disabled);\n \n@@ -864,8 +862,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let if_enabled = fx.bcx.create_block();\n                 let next = fx.bcx.create_block();\n \n-                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n-                fx.bcx.ins().jump(next, &[]);\n+                fx.bcx.ins().brif(mask_lane, if_enabled, &[], next, &[]);\n                 fx.bcx.seal_block(if_enabled);\n \n                 fx.bcx.switch_to_block(if_enabled);"}, {"sha": "bed79859f51ffbb19003aade8a14ae8e2339209a", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -57,8 +57,6 @@ mod compiler_builtins;\n mod concurrency_limiter;\n mod config;\n mod constant;\n-// FIXME revert back to the external crate with Cranelift 0.93\n-mod cranelift_native;\n mod debuginfo;\n mod discriminant;\n mod driver;\n@@ -251,7 +249,7 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     }\n }\n \n-fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Arc<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n@@ -285,14 +283,17 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n-    if let target_lexicon::Architecture::Aarch64(_) | target_lexicon::Architecture::X86_64 =\n-        target_triple.architecture\n+    if let target_lexicon::Architecture::Aarch64(_)\n+    | target_lexicon::Architecture::Riscv64(_)\n+    | target_lexicon::Architecture::X86_64 = target_triple.architecture\n     {\n-        // Windows depends on stack probes to grow the committed part of the stack\n+        // Windows depends on stack probes to grow the committed part of the stack.\n+        // On other platforms it helps prevents stack smashing.\n         flags_builder.enable(\"enable_probestack\").unwrap();\n         flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n     } else {\n-        // __cranelift_probestack is not provided and inline stack probes are only supported on AArch64 and x86_64\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on\n+        // AArch64, Riscv64 and x86_64.\n         flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n     }\n "}, {"sha": "205411e8c27be3ab312331bb57158e3479b07736", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n     if main_def_id.is_local() {\n         let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-        if !is_jit && module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+        if !is_jit && module.get_name(tcx.symbol_name(instance).name).is_none() {\n             return;\n         }\n     } else if !is_primary_cgu {"}, {"sha": "1357b7be1e0959f5348833fe4b11ce18a71ca883", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -170,14 +170,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n-        assert_eq!(\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty,\n-            \"checked int binop requires lhs and rhs of same type\"\n-        );\n-    }\n-\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n@@ -271,21 +263,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                 _ => unreachable!(\"invalid non-integer type {}\", ty),\n             }\n         }\n-        BinOp::Shl => {\n-            let val = fx.bcx.ins().ishl(lhs, rhs);\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n-        BinOp::Shr => {\n-            let val =\n-                if !signed { fx.bcx.ins().ushr(lhs, rhs) } else { fx.bcx.ins().sshr(lhs, rhs) };\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n@@ -347,12 +324,20 @@ pub(crate) fn codegen_float_binop<'tcx>(\n         BinOp::Mul => b.fmul(lhs, rhs),\n         BinOp::Div => b.fdiv(lhs, rhs),\n         BinOp::Rem => {\n-            let name = match in_lhs.layout().ty.kind() {\n-                ty::Float(FloatTy::F32) => \"fmodf\",\n-                ty::Float(FloatTy::F64) => \"fmod\",\n+            let (name, ty) = match in_lhs.layout().ty.kind() {\n+                ty::Float(FloatTy::F32) => (\"fmodf\", types::F32),\n+                ty::Float(FloatTy::F64) => (\"fmod\", types::F64),\n                 _ => bug!(),\n             };\n-            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+\n+            let ret_val = fx.lib_call(\n+                name,\n+                vec![AbiParam::new(ty), AbiParam::new(ty)],\n+                vec![AbiParam::new(ty)],\n+                &[lhs, rhs],\n+            )[0];\n+\n+            return CValue::by_val(ret_val, in_lhs.layout());\n         }\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n             let fltcc = match bin_op {"}, {"sha": "b60e56720ed5ed7c1f9cbe989c98dc9e10a608ce", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -30,11 +30,6 @@ impl Pointer {\n         Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n-        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n-    }\n-\n     pub(crate) fn dangling(align: Align) -> Self {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }"}, {"sha": "e0a081c9d498bb41207ebf3c93aaa2ec060e6332", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -245,7 +245,7 @@ pub(crate) fn write_clif_file(\n         for flag in isa.flags().iter() {\n             writeln!(file, \"set {}\", flag)?;\n         }\n-        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        write!(file, \"target {}\", isa.triple().architecture)?;\n         for isa_flag in isa.isa_flags().iter() {\n             write!(file, \" {}\", isa_flag)?;\n         }"}, {"sha": "ecf187a0b0fe6f4b903054860997c7bd449331e9", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -28,9 +28,7 @@ pub(crate) fn unsized_info<'tcx>(\n         (\n             &ty::Dynamic(ref data_a, _, src_dyn_kind),\n             &ty::Dynamic(ref data_b, _, target_dyn_kind),\n-        ) => {\n-            assert_eq!(src_dyn_kind, target_dyn_kind);\n-\n+        ) if src_dyn_kind == target_dyn_kind => {\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -55,7 +53,7 @@ pub(crate) fn unsized_info<'tcx>(\n                 old_info\n             }\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n+        (_, ty::Dynamic(data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }"}, {"sha": "58e0a498292d4498637b447f58f54ff50fc82adb", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -3,6 +3,7 @@\n use crate::prelude::*;\n \n use cranelift_codegen::ir::immediates::Offset32;\n+use cranelift_codegen::ir::{InstructionData, Opcode};\n \n fn codegen_field<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -457,13 +458,15 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    #[track_caller]\n     pub(crate) fn to_ptr(self) -> Pointer {\n         match self.to_ptr_maybe_unsized() {\n             (ptr, None) => ptr,\n             (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n         }\n     }\n \n+    #[track_caller]\n     pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n@@ -787,7 +790,36 @@ impl<'tcx> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n-            ty::Array(elem_ty, _) => (fx.layout_of(*elem_ty), self.to_ptr()),\n+            ty::Array(elem_ty, _) => {\n+                let elem_layout = fx.layout_of(*elem_ty);\n+                match self.inner {\n+                    CPlaceInner::Var(local, var) => {\n+                        // This is a hack to handle `vector_val.0[1]`. It doesn't allow dynamic\n+                        // indexing.\n+                        let lane_idx = match fx.bcx.func.dfg.insts\n+                            [fx.bcx.func.dfg.value_def(index).unwrap_inst()]\n+                        {\n+                            InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => imm,\n+                            _ => bug!(\n+                                \"Dynamic indexing into a vector type is not supported: {self:?}[{index}]\"\n+                            ),\n+                        };\n+                        return CPlace {\n+                            inner: CPlaceInner::VarLane(\n+                                local,\n+                                var,\n+                                lane_idx.bits().try_into().unwrap(),\n+                            ),\n+                            layout: elem_layout,\n+                        };\n+                    }\n+                    CPlaceInner::Addr(addr, None) => (elem_layout, addr),\n+                    CPlaceInner::Addr(_, Some(_))\n+                    | CPlaceInner::VarPair(_, _, _)\n+                    | CPlaceInner::VarLane(_, _, _) => bug!(\"Can't index into {self:?}\"),\n+                }\n+                // FIXME use VarLane in case of Var with simd type\n+            }\n             ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };"}, {"sha": "b7bfd8fd395264352a56413706579ffac91a393b", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -43,10 +43,29 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    arg: CValue<'tcx>,\n+    mut arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Pointer, Value) {\n     let (ptr, vtable) = 'block: {\n+        if let Abi::Scalar(_) = arg.layout().abi {\n+            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr()\n+                && !arg.layout().ty.is_region_ptr()\n+            {\n+                for i in 0..arg.layout().fields.count() {\n+                    let field = arg.value_field(fx, mir::Field::new(i));\n+                    if !field.layout().is_zst() {\n+                        // we found the one non-zero-sized field that is allowed\n+                        // now find *its* non-zero-sized field, or stop if it's a\n+                        // pointer\n+                        arg = field;\n+                        continue 'descend_newtypes;\n+                    }\n+                }\n+\n+                bug!(\"receiver has no non-zero-sized fields {:?}\", arg);\n+            }\n+        }\n+\n         if let ty::Ref(_, ty, _) = arg.layout().ty.kind() {\n             if ty.is_dyn_star() {\n                 let inner_layout = fx.layout_of(arg.layout().ty.builtin_deref(true).unwrap().ty);"}, {"sha": "13c4fa132d877ffa98f2b2e1b64b8409126755c8", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -663,17 +663,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 bx.checked_binop(oop, input_ty, lhs, rhs)\n             }\n-            mir::BinOp::Shl | mir::BinOp::Shr => {\n-                let lhs_llty = bx.cx().val_ty(lhs);\n-                let rhs_llty = bx.cx().val_ty(rhs);\n-                let invert_mask = common::shift_mask_val(bx, lhs_llty, rhs_llty, true);\n-                let outer_bits = bx.and(rhs, invert_mask);\n-\n-                let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().const_null(rhs_llty));\n-                let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-\n-                (val, of)\n-            }\n             _ => bug!(\"Operator `{:?}` is not a checkable operator\", op),\n         };\n "}, {"sha": "e0939d1d1ba9d5a38aaf0d23fa286eb775a0312d", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -564,15 +564,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    Shl | Shr => {\n-                        for x in [a, b] {\n-                            check_kinds!(\n-                                x,\n-                                \"Cannot perform checked shift on non-integer type {:?}\",\n-                                ty::Uint(..) | ty::Int(..)\n-                            )\n-                        }\n-                    }\n                     _ => self.fail(location, format!(\"There is no checked version of {:?}\", op)),\n                 }\n             }"}, {"sha": "8c0edcee52147bd176139af3accbf478ef7d49e4", "filename": "compiler/rustc_error_codes/src/error_codes/E0416.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -23,6 +23,6 @@ Or maybe did you mean to unify? Consider using a guard:\n # let (A, B, C) = (1, 2, 3);\n match (A, B, C) {\n     (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n-    (y, z, see) => { /* A and B unequal; do another thing */ }\n+    (y, z, see) => { /* A and B not equal; do another thing */ }\n }\n ```"}, {"sha": "a07cb65170dcae4fdacdee20f4f13c769f73447a", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -367,7 +367,7 @@ impl LockstepIterSize {\n ///\n /// Example: `$($($x $y)+*);+` -- we need to make sure that `x` and `y` repeat the same amount as\n /// each other at the given depth when the macro was invoked. If they don't it might mean they were\n-/// declared at unequal depths or there was a compile bug. For example, if we have 3 repetitions of\n+/// declared at depths which weren't equal or there was a compiler bug. For example, if we have 3 repetitions of\n /// the outer sequence and 4 repetitions of the inner sequence for `x`, we should have the same for\n /// `y`; otherwise, we can't transcribe them both at the given depth.\n fn lockstep_iter_size("}, {"sha": "3c4fc9cb530a453f620ac042ce7274884514cbfc", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -404,8 +404,12 @@ impl DefPathData {\n         match *self {\n             TypeNs(name) | ValueNs(name) | MacroNs(name) | LifetimeNs(name) => Some(name),\n \n+            // We use this name when collecting `ModChild`s.\n+            // FIXME this could probably be removed with some refactoring to the name resolver.\n+            ImplTraitAssocTy => Some(kw::Empty),\n+\n             Impl | ForeignMod | CrateRoot | Use | GlobalAsm | ClosureExpr | Ctor | AnonConst\n-            | ImplTrait | ImplTraitAssocTy => None,\n+            | ImplTrait => None,\n         }\n     }\n "}, {"sha": "f830269b45daedef9a1d45c48f9cbc756a1a99f3", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1440,6 +1440,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n+                                .filter(|item| tcx.opt_rpitit_info(item.def_id).is_none())\n                                 .map(|item| item.def_id),\n                         );\n                     }"}, {"sha": "8c364a4f3b2b833cb83f93acf0bdbaae0ba949c6", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -363,6 +363,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::likely => (0, vec![tcx.types.bool], tcx.types.bool),\n             sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n+            sym::read_via_copy => (1, vec![tcx.mk_imm_ptr(param(0))], param(0)),\n+\n             sym::discriminant_value => {\n                 let assoc_items = tcx.associated_item_def_ids(\n                     tcx.require_lang_item(hir::LangItem::DiscriminantKind, None),"}, {"sha": "0e1cf3e6c6a7d7cc02eba28a2c1593da74c3227f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::infer::{self, RegionResolutionError};\n+use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -235,7 +235,8 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     use rustc_type_ir::sty::TyKind::*;\n     match (source.kind(), target.kind()) {\n         (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-            if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+            if infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, r_a, *r_b).is_ok()\n+                && mutbl_a == *mutbl_b => {}\n         (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n         (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n             if def_a.is_struct() && def_b.is_struct() =>\n@@ -278,7 +279,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                         }\n                     }\n \n-                    if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                    if let Ok(ok) =\n+                        infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, ty_a, ty_b)\n+                    {\n                         if ok.obligations.is_empty() {\n                             create_err(\n                                 \"the trait `DispatchFromDyn` may only be implemented \\\n@@ -504,7 +507,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     // we may have to evaluate constraint\n                     // expressions in the course of execution.)\n                     // See e.g., #41936.\n-                    if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, a, b) {\n                         if ok.obligations.is_empty() {\n                             return None;\n                         }"}, {"sha": "465ae047de3735babcfabc9788853200bba2e741", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1427,25 +1427,25 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n             if let ResolvedArg::LateBound(..) = def && crossed_anon_const {\n                 let use_span = self.tcx.hir().span(hir_id);\n                 let def_span = self.tcx.def_span(param_def_id);\n-                match self.tcx.def_kind(param_def_id) {\n+                let guar = match self.tcx.def_kind(param_def_id) {\n                     DefKind::ConstParam => {\n                         self.tcx.sess.emit_err(errors::CannotCaptureLateBoundInAnonConst::Const {\n                             use_span,\n                             def_span,\n-                        });\n+                        })\n                     }\n                     DefKind::TyParam => {\n                         self.tcx.sess.emit_err(errors::CannotCaptureLateBoundInAnonConst::Type {\n                             use_span,\n                             def_span,\n-                        });\n+                        })\n                     }\n                     _ => unreachable!(),\n-                }\n-                return;\n+                };\n+                self.map.defs.insert(hir_id, ResolvedArg::Error(guar));\n+            } else {\n+                self.map.defs.insert(hir_id, def);\n             }\n-\n-            self.map.defs.insert(hir_id, def);\n             return;\n         }\n "}, {"sha": "08786fe9b1ef90d6bdbf421208398f5ba48dbc2a", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -102,7 +102,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n-use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n@@ -165,7 +165,7 @@ fn require_same_types<'tcx>(\n ) -> bool {\n     let infcx = &tcx.infer_ctxt().build();\n     let param_env = ty::ParamEnv::empty();\n-    let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+    let errors = match infcx.at(cause, param_env).eq(DefineOpaqueTypes::No, expected, actual) {\n         Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n         Err(err) => {\n             infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();"}, {"sha": "6becf4892acb20562d3911987f7f87be4ec21782", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::infer::{DefineOpaqueTypes, LateBoundRegionConversionTime};\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -563,10 +563,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) {\n                 // Check that E' = S'.\n                 let cause = self.misc(hir_ty.span);\n-                let InferOk { value: (), obligations } = self\n-                    .at(&cause, self.param_env)\n-                    .define_opaque_types(true)\n-                    .eq(*expected_ty, supplied_ty)?;\n+                let InferOk { value: (), obligations } = self.at(&cause, self.param_env).eq(\n+                    DefineOpaqueTypes::Yes,\n+                    *expected_ty,\n+                    supplied_ty,\n+                )?;\n                 all_obligations.extend(obligations);\n             }\n \n@@ -576,10 +577,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 supplied_sig.output(),\n             );\n             let cause = &self.misc(decl.output.span());\n-            let InferOk { value: (), obligations } = self\n-                .at(cause, self.param_env)\n-                .define_opaque_types(true)\n-                .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n+            let InferOk { value: (), obligations } = self.at(cause, self.param_env).eq(\n+                DefineOpaqueTypes::Yes,\n+                expected_sigs.liberated_sig.output(),\n+                supplied_output_ty,\n+            )?;\n             all_obligations.extend(obligations);\n \n             let inputs = inputs.into_iter().map(|ty| self.resolve_vars_if_possible(ty));"}, {"sha": "3d6274ede81466fe3fd6a71e65e465290f809d61", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -45,7 +45,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{Coercion, InferOk, InferResult};\n+use rustc_infer::infer::{Coercion, DefineOpaqueTypes, InferOk, InferResult};\n use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n@@ -143,11 +143,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n-            let at = self.at(&self.cause, self.fcx.param_env).define_opaque_types(true);\n+            let at = self.at(&self.cause, self.fcx.param_env);\n             if self.use_lub {\n-                at.lub(b, a)\n+                at.lub(DefineOpaqueTypes::Yes, b, a)\n             } else {\n-                at.sup(b, a)\n+                at.sup(DefineOpaqueTypes::Yes, b, a)\n                     .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n             }\n         })\n@@ -175,7 +175,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // so this will have the side-effect of making sure we have no ambiguities\n             // due to `[type error]` and `_` not coercing together.\n             let _ = self.commit_if_ok(|_| {\n-                self.at(&self.cause, self.param_env).define_opaque_types(true).eq(a, b)\n+                self.at(&self.cause, self.param_env).eq(DefineOpaqueTypes::Yes, a, b)\n             });\n             return success(vec![], self.fcx.tcx.ty_error(guar), vec![]);\n         }\n@@ -1101,9 +1101,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (ty::FnDef(..), ty::FnDef(..)) => {\n                         // Don't reify if the function types have a LUB, i.e., they\n                         // are the same function and their parameters have a LUB.\n-                        match self\n-                            .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                        {\n+                        match self.commit_if_ok(|_| {\n+                            self.at(cause, self.param_env).lub(\n+                                DefineOpaqueTypes::No,\n+                                prev_ty,\n+                                new_ty,\n+                            )\n+                        }) {\n                             // We have a LUB of prev_ty and new_ty, just return it.\n                             Ok(ok) => return Ok(self.register_infer_ok_obligations(ok)),\n                             Err(_) => {\n@@ -1153,7 +1157,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n-                .lub(a_sig, b_sig)\n+                .lub(DefineOpaqueTypes::No, a_sig, b_sig)\n                 .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n             // Reify both sides and return the reified fn pointer type.\n@@ -1237,7 +1241,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n \n                 return self\n-                    .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n+                    .commit_if_ok(|_| {\n+                        self.at(cause, self.param_env).lub(DefineOpaqueTypes::No, prev_ty, new_ty)\n+                    })\n                     .map(|ok| self.register_infer_ok_obligations(ok));\n             }\n         }\n@@ -1248,8 +1254,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Some(e) = first_error {\n                     Err(e)\n                 } else {\n-                    self.commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                        .map(|ok| self.register_infer_ok_obligations(ok))\n+                    self.commit_if_ok(|_| {\n+                        self.at(cause, self.param_env).lub(DefineOpaqueTypes::No, prev_ty, new_ty)\n+                    })\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n                 }\n             }\n             Ok(ok) => {\n@@ -1487,8 +1495,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             assert!(expression_ty.is_unit(), \"if let hack without unit type\");\n             fcx.at(cause, fcx.param_env)\n                 // needed for tests/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs\n-                .define_opaque_types(true)\n-                .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n+                .eq_exp(\n+                    DefineOpaqueTypes::Yes,\n+                    label_expression_as_expected,\n+                    expression_ty,\n+                    self.merged_ty(),\n+                )\n                 .map(|infer_ok| {\n                     fcx.register_infer_ok_obligations(infer_ok);\n                     expression_ty"}, {"sha": "f65f16e317d4977d2f56847eedbf5f243a5f3411", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n-use rustc_infer::infer::InferOk;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n         self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n-        self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n+        self.note_internal_mutation_in_method(err, expr, Some(expected), expr_ty);\n         self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n         self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n         self.check_wrong_return_type_due_to_generic_arg(err, expr, expr_ty);\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).define_opaque_types(true).sup(expected, actual) {\n+        match self.at(cause, self.param_env).sup(DefineOpaqueTypes::Yes, expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).define_opaque_types(true).eq(expected, actual) {\n+        match self.at(cause, self.param_env).eq(DefineOpaqueTypes::Yes, expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "afef331ec1d93ae61ba373f5fe3918028c22c077", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -36,6 +36,7 @@ use rustc_hir_analysis::astconv::AstConv as _;\n use rustc_hir_analysis::check::ty_kind_suggestion;\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::InferOk;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::middle::stability;\n@@ -1683,7 +1684,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let Some(_) = remaining_fields.remove(&ident) {\n                                 let target_ty = self.field_ty(base_expr.span, f, substs);\n                                 let cause = self.misc(base_expr.span);\n-                                match self.at(&cause, self.param_env).sup(target_ty, fru_ty) {\n+                                match self.at(&cause, self.param_env).sup(\n+                                    DefineOpaqueTypes::No,\n+                                    target_ty,\n+                                    fru_ty,\n+                                ) {\n                                     Ok(InferOk { obligations, value: () }) => {\n                                         self.register_predicates(obligations)\n                                     }"}, {"sha": "e539693402af9419e5db1b19e5177988a210826e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 63, "deletions": 28, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -19,7 +19,7 @@ use rustc_hir_analysis::astconv::{\n };\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::InferResult;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -558,7 +558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let span = self.tcx.hir().body(body_id).value.span;\n             let ok = self\n                 .at(&self.misc(span), self.param_env)\n-                .eq(interior, witness)\n+                .eq(DefineOpaqueTypes::No, interior, witness)\n                 .expect(\"Failed to unify generator interior type\");\n             let mut obligations = ok.obligations;\n \n@@ -950,44 +950,75 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n+        expected: Option<Ty<'tcx>>,\n         found: Ty<'tcx>,\n     ) {\n         if found != self.tcx.types.unit {\n             return;\n         }\n-        if let ExprKind::MethodCall(path_segment, rcvr, ..) = expr.kind {\n-            if self\n-                .typeck_results\n+\n+        let ExprKind::MethodCall(path_segment, rcvr, ..) = expr.kind else {\n+            return;\n+        };\n+\n+        let rcvr_has_the_expected_type = self\n+            .typeck_results\n+            .borrow()\n+            .expr_ty_adjusted_opt(rcvr)\n+            .and_then(|ty| expected.map(|expected_ty| expected_ty.peel_refs() == ty.peel_refs()))\n+            .unwrap_or(false);\n+\n+        let prev_call_mutates_and_returns_unit = || {\n+            self.typeck_results\n                 .borrow()\n-                .expr_ty_adjusted_opt(rcvr)\n-                .map_or(true, |ty| expected.peel_refs() != ty.peel_refs())\n-            {\n-                return;\n-            }\n-            let mut sp = MultiSpan::from_span(path_segment.ident.span);\n-            sp.push_span_label(\n-                path_segment.ident.span,\n-                format!(\n-                    \"this call modifies {} in-place\",\n-                    match rcvr.kind {\n-                        ExprKind::Path(QPath::Resolved(\n-                            None,\n-                            hir::Path { segments: [segment], .. },\n-                        )) => format!(\"`{}`\", segment.ident),\n-                        _ => \"its receiver\".to_string(),\n-                    }\n-                ),\n-            );\n+                .type_dependent_def_id(expr.hir_id)\n+                .map(|def_id| self.tcx.fn_sig(def_id).skip_binder().skip_binder())\n+                .and_then(|sig| sig.inputs_and_output.split_last())\n+                .map(|(output, inputs)| {\n+                    output.is_unit()\n+                        && inputs\n+                            .get(0)\n+                            .and_then(|self_ty| self_ty.ref_mutability())\n+                            .map_or(false, rustc_ast::Mutability::is_mut)\n+                })\n+                .unwrap_or(false)\n+        };\n+\n+        if !(rcvr_has_the_expected_type || prev_call_mutates_and_returns_unit()) {\n+            return;\n+        }\n+\n+        let mut sp = MultiSpan::from_span(path_segment.ident.span);\n+        sp.push_span_label(\n+            path_segment.ident.span,\n+            format!(\n+                \"this call modifies {} in-place\",\n+                match rcvr.kind {\n+                    ExprKind::Path(QPath::Resolved(\n+                        None,\n+                        hir::Path { segments: [segment], .. },\n+                    )) => format!(\"`{}`\", segment.ident),\n+                    _ => \"its receiver\".to_string(),\n+                }\n+            ),\n+        );\n+\n+        let modifies_rcvr_note =\n+            format!(\"method `{}` modifies its receiver in-place\", path_segment.ident);\n+        if rcvr_has_the_expected_type {\n             sp.push_span_label(\n                 rcvr.span,\n                 \"you probably want to use this value after calling the method...\",\n             );\n+            err.span_note(sp, &modifies_rcvr_note);\n+            err.note(&format!(\"...instead of the `()` output of method `{}`\", path_segment.ident));\n+        } else if let ExprKind::MethodCall(..) = rcvr.kind {\n             err.span_note(\n                 sp,\n-                &format!(\"method `{}` modifies its receiver in-place\", path_segment.ident),\n+                modifies_rcvr_note.clone() + \", it is not meant to be used in method chains.\",\n             );\n-            err.note(&format!(\"...instead of the `()` output of method `{}`\", path_segment.ident));\n+        } else {\n+            err.span_note(sp, &modifies_rcvr_note);\n         }\n     }\n \n@@ -1310,7 +1341,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // This also occurs for an enum variant on a type alias.\n             let impl_ty = self.normalize(span, tcx.type_of(impl_def_id).subst(tcx, substs));\n             let self_ty = self.normalize(span, self_ty);\n-            match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n+            match self.at(&self.misc(span), self.param_env).eq(\n+                DefineOpaqueTypes::No,\n+                impl_ty,\n+                self_ty,\n+            ) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     self.tcx.sess.delay_span_bug("}, {"sha": "7064ff6538487585b6628981bade14d47d786aa1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -24,8 +24,8 @@ use rustc_hir_analysis::structured_errors::StructuredDiagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, IsSuggestable, Ty};\n@@ -301,9 +301,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // 3. Check if the formal type is a supertype of the checked one\n             //    and register any such obligations for future type checks\n-            let supertype_error = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n+            let supertype_error = self.at(&self.misc(provided_arg.span), self.param_env).sup(\n+                DefineOpaqueTypes::No,\n+                formal_input_ty,\n+                coerced_ty,\n+            );\n             let subtyping_error = match supertype_error {\n                 Ok(InferOk { obligations, value: () }) => {\n                     self.register_predicates(obligations);\n@@ -585,7 +587,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Using probe here, since we don't want this subtyping to affect inference.\n             let subtyping_error = self.probe(|_| {\n-                self.at(&self.misc(arg_span), self.param_env).sup(formal_input_ty, coerced_ty).err()\n+                self.at(&self.misc(arg_span), self.param_env)\n+                    .sup(DefineOpaqueTypes::No, formal_input_ty, coerced_ty)\n+                    .err()\n             });\n \n             // Same as above: if either the coerce type or the checked type is an error type,"}, {"sha": "9ecc870a70dbd949033a05b2900df13bc4a3500c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n-use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_infer::infer::{DefineOpaqueTypes, RegionVariableOrigin};\n use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::{self, BoundVariableKind, RvalueScopes, Ty, TyCtxt, TypeVisitableExt};\n@@ -327,7 +327,11 @@ pub fn resolve_interior<'a, 'tcx>(\n     );\n \n     // Unify the type variable inside the generator with the new witness\n-    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(interior, witness) {\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(\n+        DefineOpaqueTypes::No,\n+        interior,\n+        witness,\n+    ) {\n         Ok(ok) => fcx.register_infer_ok_obligations(ok),\n         _ => bug!(\"failed to relate {interior} and {witness}\"),\n     }"}, {"sha": "a0aa43deadcfd2a2cd0ac3a3f468f41f9790ad4c", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,7 @@ use rustc_hir_analysis::astconv::generics::{\n     check_generic_arg_count_for_call, create_substs_for_generic_args,\n };\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n-use rustc_infer::infer::{self, InferOk};\n+use rustc_infer::infer::{self, DefineOpaqueTypes, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 substs,\n             })),\n         );\n-        match self.at(&cause, self.param_env).sup(method_self_ty, self_ty) {\n+        match self.at(&cause, self.param_env).sup(DefineOpaqueTypes::No, method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "8f31a79e7b39310141b7b0b11b3da41d775d056e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -13,6 +13,7 @@ use rustc_hir_analysis::astconv::InferCtxtExt as _;\n use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::TreatProjections;\n@@ -930,7 +931,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let Some(self_ty) = self_ty {\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n-                        .sup(fty.inputs()[0], self_ty)\n+                        .sup(DefineOpaqueTypes::No, fty.inputs()[0], self_ty)\n                         .is_err()\n                     {\n                         return false;\n@@ -1436,9 +1437,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 CandidateSource::Trait(candidate.item.container_id(self.tcx))\n             }\n             TraitCandidate(trait_ref) => self.probe(|_| {\n-                let _ = self\n-                    .at(&ObligationCause::dummy(), self.param_env)\n-                    .sup(candidate.xform_self_ty, self_ty);\n+                let _ = self.at(&ObligationCause::dummy(), self.param_env).sup(\n+                    DefineOpaqueTypes::No,\n+                    candidate.xform_self_ty,\n+                    self_ty,\n+                );\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n@@ -1465,10 +1468,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            let sub_obligations = match self\n-                .at(&ObligationCause::dummy(), self.param_env)\n-                .sup(probe.xform_self_ty, self_ty)\n-            {\n+            let sub_obligations = match self.at(&ObligationCause::dummy(), self.param_env).sup(\n+                DefineOpaqueTypes::No,\n+                probe.xform_self_ty,\n+                self_ty,\n+            ) {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(err) => {\n                     debug!(\"--> cannot relate self-types {:?}\", err);\n@@ -1683,7 +1687,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let ProbeResult::Match = result\n                     && self\n                     .at(&ObligationCause::dummy(), self.param_env)\n-                    .sup(return_ty, xform_ret_ty)\n+                    .sup(DefineOpaqueTypes::No, return_ty, xform_ret_ty)\n                     .is_err()\n                 {\n                     result = ProbeResult::BadReturnType;"}, {"sha": "50f2b71250c015c3894f06131e158f31d8f20d92", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -416,6 +416,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n                 probe.is_ok()\n             });\n+\n+            self.note_internal_mutation_in_method(\n+                &mut err,\n+                rcvr_expr,\n+                expected.to_option(&self),\n+                rcvr_ty,\n+            );\n         }\n \n         let mut custom_span_label = false;"}, {"sha": "0c8854e962abb85a8f55bb743156b8959dd11ba3", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 84, "deletions": 71, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -30,16 +30,20 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n+/// Whether we should define opaque types or just treat them opaquely.\n+///\n+/// Currently only used to prevent predicate matching from matching anything\n+/// against opaque types.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum DefineOpaqueTypes {\n+    Yes,\n+    No,\n+}\n+\n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -55,7 +59,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env, define_opaque_types: false }\n+        At { infcx: self, cause, param_env }\n     }\n \n     /// Forks the inference context, creating a new inference context with the same inference\n@@ -84,7 +88,6 @@ impl<'tcx> InferCtxt<'tcx> {\n \n pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -93,33 +96,21 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n-    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n-        Self { define_opaque_types, ..self }\n-    }\n-\n-    /// Hacky routine for equating two impl headers in coherence.\n-    pub fn eq_impl_headers(\n-        self,\n-        expected: &ty::ImplHeader<'tcx>,\n-        actual: &ty::ImplHeader<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        debug!(\"eq_impl_header({:?} = {:?})\", expected, actual);\n-        match (expected.trait_ref, actual.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq(a_ref, b_ref),\n-            (None, None) => self.eq(expected.self_ty, actual.self_ty),\n-            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n-        }\n-    }\n-\n     /// Makes `a <: b`, where `a` may or may not be expected.\n     ///\n     /// See [`At::trace_exp`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sub_exp<T>(self, a_is_expected: bool, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn sub_exp<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).sub(a, b)\n+        self.trace_exp(a_is_expected, a, b).sub(define_opaque_types, a, b)\n     }\n \n     /// Makes `actual <: expected`. For example, if type-checking a\n@@ -129,54 +120,81 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sup<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn sup<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.sub_exp(false, actual, expected)\n+        self.sub_exp(define_opaque_types, false, actual, expected)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sub<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.sub_exp(true, expected, actual)\n+        self.sub_exp(define_opaque_types, true, expected, actual)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace_exp`] and [`Trace::eq`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn eq_exp<T>(self, a_is_expected: bool, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn eq_exp<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).eq(a, b)\n+        self.trace_exp(a_is_expected, a, b).eq(define_opaque_types, a, b)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace`] and [`Trace::eq`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).eq(expected, actual)\n+        self.trace(expected, actual).eq(define_opaque_types, expected, actual)\n     }\n \n-    pub fn relate<T>(self, expected: T, variance: ty::Variance, actual: T) -> InferResult<'tcx, ()>\n+    pub fn relate<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        variance: ty::Variance,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n         match variance {\n-            ty::Variance::Covariant => self.sub(expected, actual),\n-            ty::Variance::Invariant => self.eq(expected, actual),\n-            ty::Variance::Contravariant => self.sup(expected, actual),\n+            ty::Variance::Covariant => self.sub(define_opaque_types, expected, actual),\n+            ty::Variance::Invariant => self.eq(define_opaque_types, expected, actual),\n+            ty::Variance::Contravariant => self.sup(define_opaque_types, expected, actual),\n \n             // We could make this make sense but it's not readily\n             // exposed and I don't feel like dealing with it. Note\n@@ -195,11 +213,16 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::lub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn lub<T>(self, expected: T, actual: T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, T>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).lub(expected, actual)\n+        self.trace(expected, actual).lub(define_opaque_types, expected, actual)\n     }\n \n     /// Computes the greatest-lower-bound, or mutual subtype, of two\n@@ -208,11 +231,16 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::glb`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn glb<T>(self, expected: T, actual: T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, T>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).glb(expected, actual)\n+        self.trace(expected, actual).glb(define_opaque_types, expected, actual)\n     }\n \n     /// Sets the \"trace\" values that will be used for\n@@ -233,7 +261,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        let trace = ToTrace::to_trace(self.infcx.tcx, self.cause, a_is_expected, a, b);\n+        let trace = ToTrace::to_trace(self.cause, a_is_expected, a, b);\n         Trace { at: self, trace, a_is_expected }\n     }\n }\n@@ -242,13 +270,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -259,13 +287,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -274,13 +302,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -289,13 +317,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)\n@@ -306,18 +334,17 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n         match (a, b) {\n             (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {\n-                ToTrace::to_trace(tcx, cause, a_is_expected, trait_ref_a, trait_ref_b)\n+                ToTrace::to_trace(cause, a_is_expected, trait_ref_a, trait_ref_b)\n             }\n             (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {\n-                ToTrace::to_trace(tcx, cause, a_is_expected, ty_a, ty_b)\n+                ToTrace::to_trace(cause, a_is_expected, ty_a, ty_b)\n             }\n             (ImplSubject::Trait(_), ImplSubject::Inherent(_))\n             | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {\n@@ -329,7 +356,6 @@ impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -344,7 +370,6 @@ impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -356,7 +381,6 @@ impl<'tcx> ToTrace<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -371,7 +395,6 @@ impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -399,7 +422,6 @@ impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -411,7 +433,6 @@ impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -426,7 +447,6 @@ impl<'tcx> ToTrace<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n@@ -441,24 +461,17 @@ impl<'tcx> ToTrace<'tcx> for ty::PolyTraitRef<'tcx> {\n \n impl<'tcx> ToTrace<'tcx> for ty::AliasTy<'tcx> {\n     fn to_trace(\n-        tcx: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,\n         b: Self,\n     ) -> TypeTrace<'tcx> {\n-        let a_ty = tcx.mk_projection(a.def_id, a.substs);\n-        let b_ty = tcx.mk_projection(b.def_id, b.substs);\n-        TypeTrace {\n-            cause: cause.clone(),\n-            values: Terms(ExpectedFound::new(a_is_expected, a_ty.into(), b_ty.into())),\n-        }\n+        TypeTrace { cause: cause.clone(), values: Aliases(ExpectedFound::new(a_is_expected, a, b)) }\n     }\n }\n \n impl<'tcx> ToTrace<'tcx> for ty::FnSig<'tcx> {\n     fn to_trace(\n-        _: TyCtxt<'tcx>,\n         cause: &ObligationCause<'tcx>,\n         a_is_expected: bool,\n         a: Self,"}, {"sha": "156a7e68ed1a0c8de4effd0668d3497a5c1bd0ee", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -14,7 +14,7 @@ use crate::infer::canonical::{\n };\n use crate::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n-use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n+use crate::infer::{DefineOpaqueTypes, InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::traits::{PredicateObligations, TraitEngine, TraitEngineExt};\n@@ -510,7 +510,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             let b = substitute_value(self.tcx, &result_subst, b);\n             debug!(?a, ?b, \"constrain opaque type\");\n             obligations\n-                .extend(self.at(cause, param_env).define_opaque_types(true).eq(a, b)?.obligations);\n+                .extend(self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })\n@@ -603,20 +603,26 @@ impl<'tcx> InferCtxt<'tcx> {\n \n                 match (value1.unpack(), value2.unpack()) {\n                     (GenericArgKind::Type(v1), GenericArgKind::Type(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                        obligations.extend(\n+                            self.at(cause, param_env)\n+                                .eq(DefineOpaqueTypes::Yes, v1, v2)?\n+                                .into_obligations(),\n+                        );\n                     }\n                     (GenericArgKind::Lifetime(re1), GenericArgKind::Lifetime(re2))\n                         if re1.is_erased() && re2.is_erased() =>\n                     {\n                         // no action needed\n                     }\n                     (GenericArgKind::Lifetime(v1), GenericArgKind::Lifetime(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                        obligations.extend(\n+                            self.at(cause, param_env)\n+                                .eq(DefineOpaqueTypes::Yes, v1, v2)?\n+                                .into_obligations(),\n+                        );\n                     }\n                     (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n-                        let ok = self.at(cause, param_env).eq(v1, v2)?;\n+                        let ok = self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, v1, v2)?;\n                         obligations.extend(ok.into_obligations());\n                     }\n                     _ => {"}, {"sha": "bb6fdd2ffc2c9a092d06a664ca7fa36a88a7d53f", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -27,7 +27,7 @@ use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n-use super::{InferCtxt, MiscVariable, TypeTrace};\n+use super::{DefineOpaqueTypes, InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n@@ -52,12 +52,7 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n+    pub define_opaque_types: DefineOpaqueTypes,\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "c92a74b6241a6758f0c8e2ee0a50709d6b339029", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::DefineOpaqueTypes;\n use crate::traits::PredicateObligations;\n \n use super::combine::{CombineFields, ObligationEmittingRelation, RelationDir};\n@@ -110,7 +111,8 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if self.fields.define_opaque_types && def_id.is_local() =>\n+                if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n+                    && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "ac4986a577c6db75933aa3464661303d313f766e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1568,6 +1568,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     ValuePairs::TraitRefs(_) | ValuePairs::PolyTraitRefs(_) => {\n                         (false, Mismatch::Fixed(\"trait\"))\n                     }\n+                    ValuePairs::Aliases(infer::ExpectedFound { expected, .. }) => {\n+                        (false, Mismatch::Fixed(self.tcx.def_descr(expected.def_id)))\n+                    }\n                     ValuePairs::Regions(_) => (false, Mismatch::Fixed(\"lifetime\")),\n                 };\n                 let Some(vals) = self.values_str(values) else {\n@@ -2124,6 +2127,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         match values {\n             infer::Regions(exp_found) => self.expected_found_str(exp_found),\n             infer::Terms(exp_found) => self.expected_found_str_term(exp_found),\n+            infer::Aliases(exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(exp_found) => {\n                 let pretty_exp_found = ty::error::ExpectedFound {\n                     expected: exp_found.expected.print_only_trait_path(),"}, {"sha": "5c12351226aa592684d1344708fa092cdf530022", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,8 +2,8 @@\n \n use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n-use super::InferCtxt;\n use super::Subtype;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -142,7 +142,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         Ok(())\n     }\n \n-    fn define_opaque_types(&self) -> bool {\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes {\n         self.fields.define_opaque_types\n     }\n }"}, {"sha": "7f4c141b97af2fcac6b88f29fd39bdd5186e1b97", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -19,7 +19,7 @@\n \n use super::combine::ObligationEmittingRelation;\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use super::InferCtxt;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::RelateResult;\n@@ -36,7 +36,7 @@ pub trait LatticeDir<'f, 'tcx>: ObligationEmittingRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n-    fn define_opaque_types(&self) -> bool;\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n@@ -110,7 +110,7 @@ where\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n         (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-            if this.define_opaque_types() && def_id.is_local() =>\n+            if this.define_opaque_types() == DefineOpaqueTypes::Yes && def_id.is_local() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "dbef42db8f1bfe4af6d9870392c2f6b8a1d69c81", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,8 +2,8 @@\n \n use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n-use super::InferCtxt;\n use super::Subtype;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -142,7 +142,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         Ok(())\n     }\n \n-    fn define_opaque_types(&self) -> bool {\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes {\n         self.fields.define_opaque_types\n     }\n }"}, {"sha": "96e7c095d341c2fb6c37c77bb7fbd383db58795b", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,4 @@\n+pub use self::at::DefineOpaqueTypes;\n pub use self::freshen::TypeFreshener;\n pub use self::lexical_region_resolve::RegionResolutionError;\n pub use self::LateBoundRegionConversionTime::*;\n@@ -338,6 +339,7 @@ pub struct InferCtxt<'tcx> {\n pub enum ValuePairs<'tcx> {\n     Regions(ExpectedFound<ty::Region<'tcx>>),\n     Terms(ExpectedFound<ty::Term<'tcx>>),\n+    Aliases(ExpectedFound<ty::AliasTy<'tcx>>),\n     TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n     Sigs(ExpectedFound<ty::FnSig<'tcx>>),\n@@ -729,7 +731,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        define_opaque_types: bool,\n+        define_opaque_types: DefineOpaqueTypes,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n@@ -864,15 +866,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| self.at(origin, param_env).sub(a, b).is_ok())\n+        self.probe(|_| self.at(origin, param_env).sub(DefineOpaqueTypes::No, a, b).is_ok())\n     }\n \n     pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| self.at(origin, param_env).eq(a, b).is_ok())\n+        self.probe(|_| self.at(origin, param_env).eq(DefineOpaqueTypes::No, a, b).is_ok())\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -967,7 +969,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n                 self.instantiate_binder_with_placeholders(predicate);\n \n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n+            let ok =\n+                self.at(cause, param_env).sub_exp(DefineOpaqueTypes::No, a_is_expected, a, b)?;\n \n             Ok(ok.unit())\n         }))"}, {"sha": "ed4bc594d1a54d57348d0e7f70a5d509301efdf7", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,5 @@\n+use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n@@ -16,18 +18,13 @@ use rustc_middle::ty::{\n     TypeVisitable, TypeVisitableExt, TypeVisitor,\n };\n use rustc_span::Span;\n-\n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n-\n mod table;\n \n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n \n-use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use super::InferResult;\n-\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n@@ -547,8 +544,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         if let Some(prev) = prev {\n             obligations = self\n                 .at(&cause, param_env)\n-                .define_opaque_types(true)\n-                .eq_exp(a_is_expected, prev, hidden_ty)?\n+                .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n                 .obligations;\n         }\n "}, {"sha": "230cadb11842e506a0ca4ff735d3db754c9a1604", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n use super::combine::{CombineFields, RelationDir};\n-use super::{ObligationEmittingRelation, SubregionOrigin};\n+use super::{DefineOpaqueTypes, ObligationEmittingRelation, SubregionOrigin};\n \n use crate::traits::{Obligation, PredicateObligations};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -138,7 +138,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if self.fields.define_opaque_types && def_id.is_local() =>\n+                if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n+                    && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "014810dba9cce060cdb2eb87970cae6f352cc58e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -744,6 +744,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(emit_thin_lto, false);\n     tracked!(export_executable_symbols, true);\n     tracked!(fewer_names, Some(true));\n+    tracked!(flatten_format_args, true);\n     tracked!(force_unstable_if_unmarked, true);\n     tracked!(fuel, Some((\"abc\".to_string(), 99)));\n     tracked!(function_sections, Some(false));"}, {"sha": "308c02929ca42b2e469d5c01caf5a3ff55b3c086", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1390,7 +1390,7 @@ pub struct UnusedOp<'a> {\n     pub op: &'a str,\n     #[label]\n     pub label: Span,\n-    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"machine-applicable\")]\n+    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"maybe-incorrect\")]\n     pub suggestion: Span,\n }\n \n@@ -1434,17 +1434,15 @@ pub struct UnusedDef<'a, 'b> {\n }\n \n #[derive(Subdiagnostic)]\n-pub enum UnusedDefSuggestion {\n-    #[suggestion(\n-        lint_suggestion,\n-        style = \"verbose\",\n-        code = \"let _ = \",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Default {\n-        #[primary_span]\n-        span: Span,\n-    },\n+#[suggestion(\n+    lint_suggestion,\n+    style = \"verbose\",\n+    code = \"let _ = \",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct UnusedDefSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n }\n \n // Needed because of def_path_str"}, {"sha": "7c692fee33389666f0a364c7ce9b98986eaff6a6", "filename": "compiler/rustc_lint/src/map_unit_fn.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmap_unit_fn.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -56,6 +56,7 @@ impl<'tcx> LateLintPass<'tcx> for MapUnitFn {\n                         return;\n                     }\n                     let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+                    let default_span = args[0].span;\n                     if let ty::FnDef(id, _) = arg_ty.kind() {\n                         let fn_ty = cx.tcx.fn_sig(id).skip_binder();\n                         let ret_ty = fn_ty.output().skip_binder();\n@@ -64,7 +65,10 @@ impl<'tcx> LateLintPass<'tcx> for MapUnitFn {\n                                 MAP_UNIT_FN,\n                                 span,\n                                 MappingToUnit {\n-                                    function_label: cx.tcx.span_of_impl(*id).unwrap(),\n+                                    function_label: cx\n+                                        .tcx\n+                                        .span_of_impl(*id)\n+                                        .unwrap_or(default_span),\n                                     argument_label: args[0].span,\n                                     map_label: arg_ty.default_span(cx.tcx),\n                                     suggestion: path.ident.span,\n@@ -80,7 +84,10 @@ impl<'tcx> LateLintPass<'tcx> for MapUnitFn {\n                                 MAP_UNIT_FN,\n                                 span,\n                                 MappingToUnit {\n-                                    function_label: cx.tcx.span_of_impl(*id).unwrap(),\n+                                    function_label: cx\n+                                        .tcx\n+                                        .span_of_impl(*id)\n+                                        .unwrap_or(default_span),\n                                     argument_label: args[0].span,\n                                     map_label: arg_ty.default_span(cx.tcx),\n                                     suggestion: path.ident.span,"}, {"sha": "faca61fc29bf97bcfc5b75380415b8753ea2376e", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -123,7 +123,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         let must_use_result = is_ty_must_use(cx, ty, &expr, expr.span);\n         let type_lint_emitted_or_suppressed = match must_use_result {\n             Some(path) => {\n-                emit_must_use_untranslated(cx, &path, \"\", \"\", 1);\n+                emit_must_use_untranslated(cx, &path, \"\", \"\", 1, false);\n                 true\n             }\n             None => false,\n@@ -358,6 +358,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         descr_pre_path,\n                         descr_post_path,\n                         1,\n+                        false,\n                     )\n                 })\n                 .is_some()\n@@ -370,27 +371,30 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_pre: &str,\n             descr_post: &str,\n             plural_len: usize,\n+            is_inner: bool,\n         ) {\n             let plural_suffix = pluralize!(plural_len);\n \n             match path {\n                 MustUsePath::Suppressed => {}\n                 MustUsePath::Boxed(path) => {\n                     let descr_pre = &format!(\"{}boxed \", descr_pre);\n-                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len, true);\n                 }\n                 MustUsePath::Opaque(path) => {\n                     let descr_pre = &format!(\"{}implementer{} of \", descr_pre, plural_suffix);\n-                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len, true);\n                 }\n                 MustUsePath::TraitObject(path) => {\n                     let descr_post = &format!(\" trait object{}{}\", plural_suffix, descr_post);\n-                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                    emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len, true);\n                 }\n                 MustUsePath::TupleElement(elems) => {\n                     for (index, path) in elems {\n                         let descr_post = &format!(\" in tuple element {}\", index);\n-                        emit_must_use_untranslated(cx, path, descr_pre, descr_post, plural_len);\n+                        emit_must_use_untranslated(\n+                            cx, path, descr_pre, descr_post, plural_len, true,\n+                        );\n                     }\n                 }\n                 MustUsePath::Array(path, len) => {\n@@ -401,6 +405,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         descr_pre,\n                         descr_post,\n                         plural_len.saturating_add(usize::try_from(*len).unwrap_or(usize::MAX)),\n+                        true,\n                     );\n                 }\n                 MustUsePath::Closure(span) => {\n@@ -418,19 +423,6 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     );\n                 }\n                 MustUsePath::Def(span, def_id, reason) => {\n-                    let suggestion = if matches!(\n-                        cx.tcx.get_diagnostic_name(*def_id),\n-                        Some(sym::add)\n-                            | Some(sym::sub)\n-                            | Some(sym::mul)\n-                            | Some(sym::div)\n-                            | Some(sym::rem)\n-                            | Some(sym::neg),\n-                    ) {\n-                        Some(UnusedDefSuggestion::Default { span: span.shrink_to_lo() })\n-                    } else {\n-                        None\n-                    };\n                     cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n@@ -440,7 +432,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                             cx,\n                             def_id: *def_id,\n                             note: *reason,\n-                            suggestion,\n+                            suggestion: (!is_inner)\n+                                .then_some(UnusedDefSuggestion { span: span.shrink_to_lo() }),\n                         },\n                     );\n                 }"}, {"sha": "91966e75b5fa2e05bd9e94ac32a7e0cb21532599", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1026,12 +1026,13 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust,compile_fail\n-    /// #![feature(const_ptr_read)]\n+    /// #![feature(const_mut_refs)]\n     /// const FOO: () = unsafe {\n     ///     let x = &[0_u8; 4];\n     ///     let y = x.as_ptr().cast::<u32>();\n-    ///     y.read(); // the address of a `u8` array is unknown and thus we don't know if\n-    ///     // it is aligned enough for reading a `u32`.\n+    ///     let mut z = 123;\n+    ///     y.copy_to_nonoverlapping(&mut z, 1); // the address of a `u8` array is unknown\n+    ///     // and thus we don't know if it is aligned enough for copying a `u32`.\n     /// };\n     /// ```\n     ///"}, {"sha": "0070e46ffdf02cf2060427f1f86377bb3bf331e5", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1087,6 +1087,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             _ => bug!(\"cannot get associated-item of `{:?}`\", self.def_key(id)),\n         };\n         let container = self.root.tables.assoc_container.get(self, id).unwrap();\n+        let opt_rpitit_info =\n+            self.root.tables.opt_rpitit_info.get(self, id).map(|d| d.decode(self));\n \n         ty::AssocItem {\n             name,\n@@ -1095,8 +1097,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             trait_item_def_id: self.get_trait_item_def_id(id),\n             container,\n             fn_has_self_parameter: has_self,\n-            // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): We need to encode this\n-            opt_rpitit_info: None,\n+            opt_rpitit_info,\n         }\n     }\n "}, {"sha": "a98433953367b8e295c4c6fc8e9f036608384c06", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -226,7 +226,15 @@ provide! { tcx, def_id, other, cdata,\n     lookup_default_body_stability => { table }\n     lookup_deprecation_entry => { table }\n     params_in_repr => { table }\n-    unused_generic_params => { table }\n+    // FIXME: Could be defaulted, but `LazyValue<UnusedGenericParams>` is not `FixedSizeEncoding`..\n+    unused_generic_params => {\n+        cdata\n+            .root\n+            .tables\n+            .unused_generic_params\n+            .get(cdata, def_id.index)\n+            .map_or_else(|| ty::UnusedGenericParams::new_all_used(), |lazy| lazy.decode((cdata, tcx)))\n+    }\n     opt_def_kind => { table_direct }\n     impl_parent => { table }\n     impl_polarity => { table_direct }"}, {"sha": "9649ce2c5a77161c14db6828ee52d2baaccd7412", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1350,19 +1350,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if trait_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n+        if let Some(rpitit_info) = trait_item.opt_rpitit_info {\n+            let rpitit_info = self.lazy(rpitit_info);\n+            self.tables.opt_rpitit_info.set_some(def_id.index, rpitit_info);\n+        }\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let ast_item = self.tcx.hir().expect_impl_item(def_id.expect_local());\n-        self.tables.impl_defaultness.set_some(def_id.index, ast_item.defaultness);\n+        let defaultness = self.tcx.impl_defaultness(def_id.expect_local());\n+        self.tables.impl_defaultness.set_some(def_id.index, defaultness);\n         let impl_item = self.tcx.associated_item(def_id);\n         self.tables.assoc_container.set_some(def_id.index, impl_item.container);\n \n         match impl_item.kind {\n             ty::AssocKind::Fn => {\n+                let ast_item = self.tcx.hir().expect_impl_item(def_id.expect_local());\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n                 self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n@@ -1383,6 +1388,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n+        if let Some(rpitit_info) = impl_item.opt_rpitit_info {\n+            let rpitit_info = self.lazy(rpitit_info);\n+            self.tables.opt_rpitit_info.set_some(def_id.index, rpitit_info);\n+        }\n     }\n \n     fn encode_mir(&mut self) {"}, {"sha": "e71a1c9810249c4b8846f1903da5159f524e7dd8", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -355,6 +355,7 @@ define_tables! {\n     inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     associated_items_for_impl_trait_in_trait: Table<DefIndex, LazyArray<DefId>>,\n+    opt_rpitit_info: Table<DefIndex, Option<LazyValue<ty::ImplTraitInTraitData>>>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,"}, {"sha": "8a4c10cd71c03c5b31a882e0c550199eaee69900", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -316,7 +316,7 @@ impl<'hir> Map<'hir> {\n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     #[inline]\n     pub fn find_by_def_id(self, id: LocalDefId) -> Option<Node<'hir>> {\n-        self.find(self.local_def_id_to_hir_id(id))\n+        self.find(self.tcx.opt_local_def_id_to_hir_id(id)?)\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n@@ -333,7 +333,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_if_local(self, id: DefId) -> Option<Node<'hir>> {\n-        id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n+        id.as_local().and_then(|id| self.find(self.tcx.opt_local_def_id_to_hir_id(id)?))\n     }\n \n     pub fn get_generics(self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {"}, {"sha": "a28ecfa9bdc47dc85adcefc03048facfc1551912", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1081,11 +1081,7 @@ pub enum Rvalue<'tcx> {\n     /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n     ///\n     /// For addition, subtraction, and multiplication on integers the error condition is set when\n-    /// the infinite precision result would be unequal to the actual result.\n-    ///\n-    /// For shift operations on integers the error condition is set when the value of right-hand\n-    /// side is greater than or equal to the number of bits in the type of the left-hand side, or\n-    /// when the value of right-hand side is negative.\n+    /// the infinite precision result would not be equal to the actual result.\n     ///\n     /// Other combinations of types and operators are unsupported.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),"}, {"sha": "6e961a775c1ff88addffac1ca20c5a233e1af5d5", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n \n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n-        true\n+        self.def_id().is_local()\n     }\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n@@ -76,7 +76,7 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n \n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n-        true\n+        self.def_id().is_local()\n     }\n \n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {"}, {"sha": "2cd791574417a89dc5ff57ee897d524688139c49", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2215,7 +2215,7 @@ rustc_queries! {\n     }\n \n     /// Used in `super_combine_consts` to ICE if the type of the two consts are definitely not going to end up being\n-    /// equal to eachother. This might return `Ok` even if the types are unequal, but will never return `Err` if\n+    /// equal to eachother. This might return `Ok` even if the types are not equal, but will never return `Err` if\n     /// the types might be equal.\n     query check_tys_might_be_eq(arg: Canonical<'tcx, (ty::ParamEnv<'tcx>, Ty<'tcx>, Ty<'tcx>)>) -> Result<(), NoSolution> {\n         desc { \"check whether two const param are definitely not equal to eachother\"}"}, {"sha": "a7f38884ebcc4390b3f6df681feb92e0085e80ef", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -237,7 +237,7 @@ impl ScalarInt {\n     }\n \n     /// Tries to convert the `ScalarInt` to an unsigned integer of the given size.\n-    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// Fails if the size of the `ScalarInt` is not equal to `size` and returns the\n     /// `ScalarInt`s size in that case.\n     #[inline]\n     pub fn try_to_uint(self, size: Size) -> Result<u128, Size> {\n@@ -297,7 +297,7 @@ impl ScalarInt {\n     }\n \n     /// Tries to convert the `ScalarInt` to a signed integer of the given size.\n-    /// Fails if the size of the `ScalarInt` is unequal to `size` and returns the\n+    /// Fails if the size of the `ScalarInt` is not equal to `size` and returns the\n     /// `ScalarInt`s size in that case.\n     #[inline]\n     pub fn try_to_int(self, size: Size) -> Result<i128, Size> {\n@@ -306,35 +306,35 @@ impl ScalarInt {\n     }\n \n     /// Tries to convert the `ScalarInt` to i8.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 1 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 1 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i8(self) -> Result<i8, Size> {\n         self.try_to_int(Size::from_bits(8)).map(|v| i8::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i16.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 2 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 2 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i16(self) -> Result<i16, Size> {\n         self.try_to_int(Size::from_bits(16)).map(|v| i16::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i32.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 4 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 4 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i32(self) -> Result<i32, Size> {\n         self.try_to_int(Size::from_bits(32)).map(|v| i32::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i64.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 8 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 8 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i64(self) -> Result<i64, Size> {\n         self.try_to_int(Size::from_bits(64)).map(|v| i64::try_from(v).unwrap())\n     }\n \n     /// Tries to convert the `ScalarInt` to i128.\n-    /// Fails if the size of the `ScalarInt` is unequal to `Size { raw: 16 }`\n+    /// Fails if the size of the `ScalarInt` is not equal to `Size { raw: 16 }`\n     /// and returns the `ScalarInt`s size in that case.\n     pub fn try_to_i128(self) -> Result<i128, Size> {\n         self.try_to_int(Size::from_bits(128)).map(|v| i128::try_from(v).unwrap())"}, {"sha": "e4694809cd1a2c90ec60978c9b73a7b30248e205", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -71,6 +71,7 @@ use rustc_type_ir::WithCachedTypeInfo;\n use rustc_type_ir::{CollectAndApply, DynKind, Interner, TypeFlags};\n \n use std::any::Any;\n+use std::assert_matches::debug_assert_matches;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n use std::fmt;\n@@ -2049,6 +2050,12 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_alias(self, kind: ty::AliasKind, alias_ty: ty::AliasTy<'tcx>) -> Ty<'tcx> {\n+        debug_assert_matches!(\n+            (kind, self.def_kind(alias_ty.def_id)),\n+            (ty::Opaque, DefKind::OpaqueTy)\n+                | (ty::Projection, DefKind::AssocTy)\n+                | (ty::Opaque | ty::Projection, DefKind::ImplTraitPlaceholder)\n+        );\n         self.mk_ty_from_kind(Alias(kind, alias_ty))\n     }\n "}, {"sha": "42fb5d031bbc9d17104b454b2d959c640e88f6db", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -730,7 +730,11 @@ where\n                         */\n                     };\n \n-                    let metadata = if let Some(metadata_def_id) = tcx.lang_items().metadata_type() {\n+                    let metadata = if let Some(metadata_def_id) = tcx.lang_items().metadata_type()\n+                        // Projection eagerly bails out when the pointee references errors,\n+                        // fall back to structurally deducing metadata.\n+                        && !pointee.references_error()\n+                    {\n                         let metadata = tcx.normalize_erasing_regions(\n                             cx.param_env(),\n                             tcx.mk_projection(metadata_def_id, [pointee]),"}, {"sha": "7534d06ae91f1e3575c818363d232da849179d66", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -63,6 +63,7 @@ trivially_parameterized_over_tcx! {\n     ty::DeducedParamAttrs,\n     ty::Generics,\n     ty::ImplPolarity,\n+    ty::ImplTraitInTraitData,\n     ty::ReprOptions,\n     ty::TraitDef,\n     ty::UnusedGenericParams,"}, {"sha": "dc585f438f4cdcefd33720ed752a6cb5248f8bf3", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -60,22 +60,13 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n     }\n }\n \n-fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n-    let (int, signed) = match *ty.kind() {\n-        ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n-        ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n-        _ => bug!(\"non integer discriminant\"),\n-    };\n-    (int.size(), signed)\n-}\n-\n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n     pub fn wrap_incr(self, tcx: TyCtxt<'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n     pub fn checked_add(self, tcx: TyCtxt<'tcx>, n: u128) -> (Self, bool) {\n-        let (size, signed) = int_size_and_signed(tcx, self.ty);\n+        let (size, signed) = self.ty.int_size_and_signed(tcx);\n         let (val, oflo) = if signed {\n             let min = size.signed_int_min();\n             let max = size.signed_int_max();\n@@ -929,12 +920,21 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for OpaqueTypeExpander<'tcx> {\n }\n \n impl<'tcx> Ty<'tcx> {\n+    pub fn int_size_and_signed(self, tcx: TyCtxt<'tcx>) -> (Size, bool) {\n+        let (int, signed) = match *self.kind() {\n+            ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n+            ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n+            _ => bug!(\"non integer discriminant\"),\n+        };\n+        (int.size(), signed)\n+    }\n+\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n     pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n-                let (size, signed) = int_size_and_signed(tcx, self);\n+                let (size, signed) = self.int_size_and_signed(tcx);\n                 let val =\n                     if signed { size.signed_int_max() as u128 } else { size.unsigned_int_max() };\n                 Some(val)\n@@ -955,7 +955,7 @@ impl<'tcx> Ty<'tcx> {\n     pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n-                let (size, signed) = int_size_and_signed(tcx, self);\n+                let (size, signed) = self.int_size_and_signed(tcx);\n                 let val = if signed { size.truncate(size.signed_int_min() as u128) } else { 0 };\n                 Some(val)\n             }"}, {"sha": "9f48986b1ad804c000befac8dfed79798a6aa425", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -9,6 +9,7 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n@@ -519,30 +520,68 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let source_info = self.source_info(span);\n         let bool_ty = self.tcx.types.bool;\n-        if self.check_overflow && op.is_checkable() && ty.is_integral() {\n-            let result_tup = self.tcx.mk_tup(&[ty, bool_ty]);\n-            let result_value = self.temp(result_tup, span);\n+        let rvalue = match op {\n+            BinOp::Add | BinOp::Sub | BinOp::Mul if self.check_overflow && ty.is_integral() => {\n+                let result_tup = self.tcx.mk_tup(&[ty, bool_ty]);\n+                let result_value = self.temp(result_tup, span);\n \n-            self.cfg.push_assign(\n-                block,\n-                source_info,\n-                result_value,\n-                Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n-            );\n-            let val_fld = Field::new(0);\n-            let of_fld = Field::new(1);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    result_value,\n+                    Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n+                );\n+                let val_fld = Field::new(0);\n+                let of_fld = Field::new(1);\n+\n+                let tcx = self.tcx;\n+                let val = tcx.mk_place_field(result_value, val_fld, ty);\n+                let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n-            let tcx = self.tcx;\n-            let val = tcx.mk_place_field(result_value, val_fld, ty);\n-            let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n+                let err = AssertKind::Overflow(op, lhs, rhs);\n+                block = self.assert(block, Operand::Move(of), false, err, span);\n \n-            let err = AssertKind::Overflow(op, lhs, rhs);\n+                Rvalue::Use(Operand::Move(val))\n+            }\n+            BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n+                // Consider that the shift overflows if `rhs < 0` or `rhs >= bits`.\n+                // This can be encoded as a single operation as `(rhs & -bits) != 0`.\n+                let (size, _) = ty.int_size_and_signed(self.tcx);\n+                let bits = size.bits();\n+                debug_assert!(bits.is_power_of_two());\n+                let mask = !((bits - 1) as u128);\n+\n+                let rhs_ty = rhs.ty(&self.local_decls, self.tcx);\n+                let (rhs_size, _) = rhs_ty.int_size_and_signed(self.tcx);\n+                let mask = Operand::const_from_scalar(\n+                    self.tcx,\n+                    rhs_ty,\n+                    Scalar::from_uint(rhs_size.truncate(mask), rhs_size),\n+                    span,\n+                );\n \n-            block = self.assert(block, Operand::Move(of), false, err, span);\n+                let outer_bits = self.temp(rhs_ty, span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    outer_bits,\n+                    Rvalue::BinaryOp(BinOp::BitAnd, Box::new((rhs.to_copy(), mask))),\n+                );\n \n-            block.and(Rvalue::Use(Operand::Move(val)))\n-        } else {\n-            if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n+                let overflows = self.temp(bool_ty, span);\n+                let zero = self.zero_literal(span, rhs_ty);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    overflows,\n+                    Rvalue::BinaryOp(BinOp::Ne, Box::new((Operand::Move(outer_bits), zero))),\n+                );\n+\n+                let overflow_err = AssertKind::Overflow(op, lhs.to_copy(), rhs.to_copy());\n+                block = self.assert(block, Operand::Move(overflows), false, overflow_err, span);\n+                Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n+            }\n+            BinOp::Div | BinOp::Rem if ty.is_integral() => {\n                 // Checking division and remainder is more complex, since we 1. always check\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n@@ -601,10 +640,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     block = self.assert(block, Operand::Move(of), false, overflow_err, span);\n                 }\n-            }\n \n-            block.and(Rvalue::BinaryOp(op, Box::new((lhs, rhs))))\n-        }\n+                Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n+            }\n+            _ => Rvalue::BinaryOp(op, Box::new((lhs, rhs))),\n+        };\n+        block.and(rvalue)\n     }\n \n     fn build_zero_repeat("}, {"sha": "5d7382305ae14e2bd0a5eb48d54e518351f2e786", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -149,6 +149,35 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::read_via_copy => {\n+                        let [arg] = args.as_slice() else {\n+                            span_bug!(terminator.source_info.span, \"Wrong number of arguments\");\n+                        };\n+                        let derefed_place =\n+                            if let Some(place) = arg.place() && let Some(local) = place.as_local() {\n+                                tcx.mk_place_deref(local.into())\n+                            } else {\n+                                span_bug!(terminator.source_info.span, \"Only passing a local is supported\");\n+                            };\n+                        terminator.kind = match *target {\n+                            None => {\n+                                // No target means this read something uninhabited,\n+                                // so it must be unreachable, and we don't need to\n+                                // preserve the assignment either.\n+                                TerminatorKind::Unreachable\n+                            }\n+                            Some(target) => {\n+                                block.statements.push(Statement {\n+                                    source_info: terminator.source_info,\n+                                    kind: StatementKind::Assign(Box::new((\n+                                        *destination,\n+                                        Rvalue::Use(Operand::Copy(derefed_place)),\n+                                    ))),\n+                                });\n+                                TerminatorKind::Goto { target }\n+                            }\n+                        }\n+                    }\n                     sym::discriminant_value => {\n                         if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n                             let arg = tcx.mk_place_deref(arg);"}, {"sha": "1f37f03cff1ca9c022e3a853e17fb7f35eb842f9", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 107, "deletions": 29, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,7 +1,9 @@\n-//! Removes assignments to ZST places.\n+//! Removes operations on ZST places, and convert ZST operands to constants.\n \n use crate::MirPass;\n-use rustc_middle::mir::{Body, StatementKind};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::mir::visit::*;\n+use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub struct RemoveZsts;\n@@ -16,38 +18,24 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n         if tcx.type_of(body.source.def_id()).subst_identity().is_generator() {\n             return;\n         }\n-        let param_env = tcx.param_env(body.source.def_id());\n-        let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n+        let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         let local_decls = &body.local_decls;\n-        for block in basic_blocks {\n-            for statement in block.statements.iter_mut() {\n-                if let StatementKind::Assign(box (place, _)) | StatementKind::Deinit(box place) =\n-                    statement.kind\n-                {\n-                    let place_ty = place.ty(local_decls, tcx).ty;\n-                    if !maybe_zst(place_ty) {\n-                        continue;\n-                    }\n-                    let Ok(layout) = tcx.layout_of(param_env.and(place_ty)) else {\n-                        continue;\n-                    };\n-                    if !layout.is_zst() {\n-                        continue;\n-                    }\n-                    if tcx.consider_optimizing(|| {\n-                        format!(\n-                            \"RemoveZsts - Place: {:?} SourceInfo: {:?}\",\n-                            place, statement.source_info\n-                        )\n-                    }) {\n-                        statement.make_nop();\n-                    }\n-                }\n-            }\n+        let mut replacer = Replacer { tcx, param_env, local_decls };\n+        for var_debug_info in &mut body.var_debug_info {\n+            replacer.visit_var_debug_info(var_debug_info);\n+        }\n+        for (bb, data) in body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut() {\n+            replacer.visit_basic_block_data(bb, data);\n         }\n     }\n }\n \n+struct Replacer<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    local_decls: &'a LocalDecls<'tcx>,\n+}\n+\n /// A cheap, approximate check to avoid unnecessary `layout_of` calls.\n fn maybe_zst(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n@@ -63,3 +51,93 @@ fn maybe_zst(ty: Ty<'_>) -> bool {\n         _ => false,\n     }\n }\n+\n+impl<'tcx> Replacer<'_, 'tcx> {\n+    fn known_to_be_zst(&self, ty: Ty<'tcx>) -> bool {\n+        if !maybe_zst(ty) {\n+            return false;\n+        }\n+        let Ok(layout) = self.tcx.layout_of(self.param_env.and(ty)) else {\n+            return false;\n+        };\n+        layout.is_zst()\n+    }\n+\n+    fn make_zst(&self, ty: Ty<'tcx>) -> Constant<'tcx> {\n+        debug_assert!(self.known_to_be_zst(ty));\n+        Constant {\n+            span: rustc_span::DUMMY_SP,\n+            user_ty: None,\n+            literal: ConstantKind::Val(ConstValue::ZeroSized, ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_var_debug_info(&mut self, var_debug_info: &mut VarDebugInfo<'tcx>) {\n+        match var_debug_info.value {\n+            VarDebugInfoContents::Const(_) => {}\n+            VarDebugInfoContents::Place(place) => {\n+                let place_ty = place.ty(self.local_decls, self.tcx).ty;\n+                if self.known_to_be_zst(place_ty) {\n+                    var_debug_info.value = VarDebugInfoContents::Const(self.make_zst(place_ty))\n+                }\n+            }\n+            VarDebugInfoContents::Composite { ty, fragments: _ } => {\n+                if self.known_to_be_zst(ty) {\n+                    var_debug_info.value = VarDebugInfoContents::Const(self.make_zst(ty))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, loc: Location) {\n+        if let Operand::Constant(_) = operand {\n+            return;\n+        }\n+        let op_ty = operand.ty(self.local_decls, self.tcx);\n+        if self.known_to_be_zst(op_ty)\n+            && self.tcx.consider_optimizing(|| {\n+                format!(\"RemoveZsts - Operand: {:?} Location: {:?}\", operand, loc)\n+            })\n+        {\n+            *operand = Operand::Constant(Box::new(self.make_zst(op_ty)))\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, loc: Location) {\n+        let place_for_ty = match statement.kind {\n+            StatementKind::Assign(box (place, ref rvalue)) => {\n+                rvalue.is_safe_to_remove().then_some(place)\n+            }\n+            StatementKind::Deinit(box place)\n+            | StatementKind::SetDiscriminant { box place, variant_index: _ }\n+            | StatementKind::AscribeUserType(box (place, _), _)\n+            | StatementKind::Retag(_, box place)\n+            | StatementKind::PlaceMention(box place)\n+            | StatementKind::FakeRead(box (_, place)) => Some(place),\n+            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+                Some(local.into())\n+            }\n+            StatementKind::Coverage(_)\n+            | StatementKind::Intrinsic(_)\n+            | StatementKind::Nop\n+            | StatementKind::ConstEvalCounter => None,\n+        };\n+        if let Some(place_for_ty) = place_for_ty\n+            && let ty = place_for_ty.ty(self.local_decls, self.tcx).ty\n+            && self.known_to_be_zst(ty)\n+            && self.tcx.consider_optimizing(|| {\n+                format!(\"RemoveZsts - Place: {:?} SourceInfo: {:?}\", place_for_ty, statement.source_info)\n+            })\n+        {\n+            statement.make_nop();\n+        } else {\n+            self.super_statement(statement, loc);\n+        }\n+    }\n+}"}, {"sha": "aff27e5664b75127fe1542d8b662d7ef45dfadb9", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1326,6 +1326,21 @@ fn create_mono_items_for_default_impls<'tcx>(\n         return;\n     }\n \n+    // Unlike 'lazy' monomorphization that begins by collecting items transitively\n+    // called by `main` or other global items, when eagerly monomorphizing impl\n+    // items, we never actually check that the predicates of this impl are satisfied\n+    // in a empty reveal-all param env (i.e. with no assumptions).\n+    //\n+    // Even though this impl has no substitutions, because we don't consider higher-\n+    // ranked predicates such as `for<'a> &'a mut [u8]: Copy` to be trivially false,\n+    // we must now check that the impl has no impossible-to-satisfy predicates.\n+    if tcx.subst_and_check_impossible_predicates((\n+        item.owner_id.to_def_id(),\n+        &InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id()),\n+    )) {\n+        return;\n+    }\n+\n     let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n         return;\n     };"}, {"sha": "63263a642acc14bf8d9ceda4467f96cd3202124a", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -36,6 +36,8 @@ fn unused_generic_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n ) -> UnusedGenericParams {\n+    assert!(instance.def_id().is_local());\n+\n     if !tcx.sess.opts.unstable_opts.polymorphize {\n         // If polymorphization disabled, then all parameters are used.\n         return UnusedGenericParams::new_all_used();\n@@ -100,13 +102,6 @@ fn should_polymorphize<'tcx>(\n         return false;\n     }\n \n-    // Polymorphization results are stored in cross-crate metadata only when there are unused\n-    // parameters, so assume that non-local items must have only used parameters (else this query\n-    // would not be invoked, and the cross-crate metadata used instead).\n-    if !def_id.is_local() {\n-        return false;\n-    }\n-\n     // Foreign items have no bodies to analyze.\n     if tcx.is_foreign_item(def_id) {\n         return false;"}, {"sha": "44f991f8c15b553684b87cfb03d3d74e14f3e343", "filename": "compiler/rustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2FCargo.toml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -22,3 +22,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "d063b51c8b8622c0e138be85a3a55259185c1541", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -720,26 +720,7 @@ passes_ignored_derived_impls =\n      *[other] traits {$trait_list}, but these are\n     } intentionally ignored during dead code analysis\n \n-passes_proc_macro_typeerror = mismatched {$kind} signature\n-    .label = found {$found}, expected type `proc_macro::TokenStream`\n-    .note = {$kind}s must have a signature of `{$expected_signature}`\n-\n-passes_proc_macro_diff_arg_count = mismatched {$kind} signature\n-    .label = found unexpected {$count ->\n-      [one] argument\n-     *[other] arguments\n-    }\n-    .note = {$kind}s must have a signature of `{$expected_signature}`\n-\n-passes_proc_macro_missing_args = mismatched {$kind} signature\n-    .label = {$kind} must have {$expected_input_count ->\n-      [one] one argument\n-     *[other] two arguments\n-    } of type `proc_macro::TokenStream`\n-\n-passes_proc_macro_invalid_abi = proc macro functions may not be `extern \"{$abi}\"`\n-\n-passes_proc_macro_unsafe = proc macro functions may not be `unsafe`\n+passes_proc_macro_bad_sig = {$kind} has incorrect signature\n \n passes_skipping_const_checks = skipping const checks\n "}, {"sha": "8bed7888142096a62c2a4d9b356ade72c4cbb1ea", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 88, "deletions": 85, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -19,9 +19,10 @@ use rustc_hir::{\n use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n-use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::{\n     CONFLICTING_REPR_HINTS, INVALID_DOC_ATTRIBUTES, INVALID_MACRO_EXPORT_ARGUMENTS,\n     UNUSED_ATTRIBUTES,\n@@ -30,6 +31,9 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::infer::{TyCtxtInferExt, ValuePairs};\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n \n@@ -2188,100 +2192,99 @@ impl CheckAttrVisitor<'_> {\n     ///\n     /// If this best effort goes wrong, it will just emit a worse error later (see #102923)\n     fn check_proc_macro(&self, hir_id: HirId, target: Target, kind: ProcMacroKind) {\n-        let expected_input_count = match kind {\n-            ProcMacroKind::Attribute => 2,\n-            ProcMacroKind::Derive | ProcMacroKind::FunctionLike => 1,\n-        };\n-\n-        let expected_signature = match kind {\n-            ProcMacroKind::Attribute => \"fn(TokenStream, TokenStream) -> TokenStream\",\n-            ProcMacroKind::Derive | ProcMacroKind::FunctionLike => \"fn(TokenStream) -> TokenStream\",\n-        };\n+        if target != Target::Fn {\n+            return;\n+        }\n \n         let tcx = self.tcx;\n-        if target == Target::Fn {\n-            let Some(tokenstream) = tcx.get_diagnostic_item(sym::TokenStream) else {return};\n-            let tokenstream = tcx.type_of(tokenstream).subst_identity();\n-\n-            let id = hir_id.expect_owner();\n-            let hir_sig = tcx.hir().fn_sig_by_hir_id(hir_id).unwrap();\n-\n-            let sig =\n-                tcx.liberate_late_bound_regions(id.to_def_id(), tcx.fn_sig(id).subst_identity());\n-            let sig = tcx.normalize_erasing_regions(ParamEnv::empty(), sig);\n-\n-            // We don't currently require that the function signature is equal to\n-            // `fn(TokenStream) -> TokenStream`, but instead monomorphizes to\n-            // `fn(TokenStream) -> TokenStream` after some substitution of generic arguments.\n-            //\n-            // Properly checking this means pulling in additional `rustc` crates, so we don't.\n-            let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsCandidateKey };\n-\n-            if sig.abi != Abi::Rust {\n-                tcx.sess.emit_err(errors::ProcMacroInvalidAbi {\n-                    span: hir_sig.span,\n-                    abi: sig.abi.name(),\n-                });\n-                self.abort.set(true);\n-            }\n+        let Some(token_stream_def_id) = tcx.get_diagnostic_item(sym::TokenStream) else { return; };\n+        let Some(token_stream) = tcx.type_of(token_stream_def_id).no_bound_vars() else { return; };\n \n-            if sig.unsafety == Unsafety::Unsafe {\n-                tcx.sess.emit_err(errors::ProcMacroUnsafe { span: hir_sig.span });\n-                self.abort.set(true);\n-            }\n+        let def_id = hir_id.expect_owner().def_id;\n+        let param_env = ty::ParamEnv::empty();\n \n-            let output = sig.output();\n+        let infcx = tcx.infer_ctxt().build();\n+        let ocx = ObligationCtxt::new(&infcx);\n \n-            // Typecheck the output\n-            if !drcx.types_may_unify(output, tokenstream) {\n-                tcx.sess.emit_err(errors::ProcMacroTypeError {\n-                    span: hir_sig.decl.output.span(),\n-                    found: output,\n-                    kind,\n-                    expected_signature,\n-                });\n-                self.abort.set(true);\n-            }\n+        let span = tcx.def_span(def_id);\n+        let fresh_substs = infcx.fresh_substs_for_item(span, def_id.to_def_id());\n+        let sig = tcx.liberate_late_bound_regions(\n+            def_id.to_def_id(),\n+            tcx.fn_sig(def_id).subst(tcx, fresh_substs),\n+        );\n \n-            if sig.inputs().len() < expected_input_count {\n-                tcx.sess.emit_err(errors::ProcMacroMissingArguments {\n-                    expected_input_count,\n-                    span: hir_sig.span,\n-                    kind,\n-                    expected_signature,\n-                });\n-                self.abort.set(true);\n-            }\n+        let mut cause = ObligationCause::misc(span, def_id);\n+        let sig = ocx.normalize(&cause, param_env, sig);\n \n-            // Check that the inputs are correct, if there are enough.\n-            if sig.inputs().len() >= expected_input_count {\n-                for (arg, input) in\n-                    sig.inputs().iter().zip(hir_sig.decl.inputs).take(expected_input_count)\n-                {\n-                    if !drcx.types_may_unify(*arg, tokenstream) {\n-                        tcx.sess.emit_err(errors::ProcMacroTypeError {\n-                            span: input.span,\n-                            found: *arg,\n-                            kind,\n-                            expected_signature,\n-                        });\n-                        self.abort.set(true);\n+        // proc macro is not WF.\n+        let errors = ocx.select_where_possible();\n+        if !errors.is_empty() {\n+            return;\n+        }\n+\n+        let expected_sig = tcx.mk_fn_sig(\n+            std::iter::repeat(token_stream).take(match kind {\n+                ProcMacroKind::Attribute => 2,\n+                ProcMacroKind::Derive | ProcMacroKind::FunctionLike => 1,\n+            }),\n+            token_stream,\n+            false,\n+            Unsafety::Normal,\n+            Abi::Rust,\n+        );\n+\n+        if let Err(terr) = ocx.eq(&cause, param_env, expected_sig, sig) {\n+            let mut diag = tcx.sess.create_err(errors::ProcMacroBadSig { span, kind });\n+\n+            let hir_sig = tcx.hir().fn_sig_by_hir_id(hir_id);\n+            if let Some(hir_sig) = hir_sig {\n+                match terr {\n+                    TypeError::ArgumentMutability(idx) | TypeError::ArgumentSorts(_, idx) => {\n+                        if let Some(ty) = hir_sig.decl.inputs.get(idx) {\n+                            diag.set_span(ty.span);\n+                            cause.span = ty.span;\n+                        } else if idx == hir_sig.decl.inputs.len() {\n+                            let span = hir_sig.decl.output.span();\n+                            diag.set_span(span);\n+                            cause.span = span;\n+                        }\n+                    }\n+                    TypeError::ArgCount => {\n+                        if let Some(ty) = hir_sig.decl.inputs.get(expected_sig.inputs().len()) {\n+                            diag.set_span(ty.span);\n+                            cause.span = ty.span;\n+                        }\n                     }\n+                    TypeError::UnsafetyMismatch(_) => {\n+                        // FIXME: Would be nice if we had a span here..\n+                    }\n+                    TypeError::AbiMismatch(_) => {\n+                        // FIXME: Would be nice if we had a span here..\n+                    }\n+                    TypeError::VariadicMismatch(_) => {\n+                        // FIXME: Would be nice if we had a span here..\n+                    }\n+                    _ => {}\n                 }\n             }\n \n-            // Check that there are not too many arguments\n-            let body_id = tcx.hir().body_owned_by(id.def_id);\n-            let excess = tcx.hir().body(body_id).params.get(expected_input_count..);\n-            if let Some(excess @ [begin @ end] | excess @ [begin, .., end]) = excess {\n-                tcx.sess.emit_err(errors::ProcMacroDiffArguments {\n-                    span: begin.span.to(end.span),\n-                    count: excess.len(),\n-                    kind,\n-                    expected_signature,\n-                });\n-                self.abort.set(true);\n-            }\n+            infcx.err_ctxt().note_type_err(\n+                &mut diag,\n+                &cause,\n+                None,\n+                Some(ValuePairs::Sigs(ExpectedFound { expected: expected_sig, found: sig })),\n+                terr,\n+                false,\n+                false,\n+            );\n+            diag.emit();\n+            self.abort.set(true);\n+        }\n+\n+        let errors = ocx.select_all_or_error();\n+        if !errors.is_empty() {\n+            infcx.err_ctxt().report_fulfillment_errors(&errors);\n+            self.abort.set(true);\n         }\n     }\n }"}, {"sha": "1b0cd5d91ab5359e30c4afee84cf8e76f0a9c476", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1546,52 +1546,11 @@ pub struct ChangeFieldsToBeOfUnitType {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes_proc_macro_typeerror)]\n-#[note]\n-pub(crate) struct ProcMacroTypeError<'tcx> {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub found: Ty<'tcx>,\n-    pub kind: ProcMacroKind,\n-    pub expected_signature: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(passes_proc_macro_diff_arg_count)]\n-pub(crate) struct ProcMacroDiffArguments {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    pub count: usize,\n-    pub kind: ProcMacroKind,\n-    pub expected_signature: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(passes_proc_macro_missing_args)]\n-pub(crate) struct ProcMacroMissingArguments {\n+#[diag(passes_proc_macro_bad_sig)]\n+pub(crate) struct ProcMacroBadSig {\n     #[primary_span]\n-    #[label]\n     pub span: Span,\n-    pub expected_input_count: usize,\n     pub kind: ProcMacroKind,\n-    pub expected_signature: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(passes_proc_macro_invalid_abi)]\n-pub(crate) struct ProcMacroInvalidAbi {\n-    #[primary_span]\n-    pub span: Span,\n-    pub abi: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(passes_proc_macro_unsafe)]\n-pub(crate) struct ProcMacroUnsafe {\n-    #[primary_span]\n-    pub span: Span,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "df7681dc4267b5d1d3ff4976b1f2797cdb078427", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1289,25 +1289,41 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 PathSource::Expr(_) | PathSource::TupleStruct(..) | PathSource::Pat => {\n                     let span = find_span(&source, err);\n                     err.span_label(self.r.def_span(def_id), &format!(\"`{path_str}` defined here\"));\n-                    let (tail, descr, applicability) = match source {\n-                        PathSource::Pat | PathSource::TupleStruct(..) => {\n-                            (\"\", \"pattern\", Applicability::MachineApplicable)\n-                        }\n-                        _ => (\": val\", \"literal\", Applicability::HasPlaceholders),\n-                    };\n \n+                    let (tail, descr, applicability, old_fields) = match source {\n+                        PathSource::Pat => (\"\", \"pattern\", Applicability::MachineApplicable, None),\n+                        PathSource::TupleStruct(_, args) => (\n+                            \"\",\n+                            \"pattern\",\n+                            Applicability::MachineApplicable,\n+                            Some(\n+                                args.iter()\n+                                    .map(|a| self.r.tcx.sess.source_map().span_to_snippet(*a).ok())\n+                                    .collect::<Vec<Option<String>>>(),\n+                            ),\n+                        ),\n+                        _ => (\": val\", \"literal\", Applicability::HasPlaceholders, None),\n+                    };\n                     let field_ids = self.r.field_def_ids(def_id);\n                     let (fields, applicability) = match field_ids {\n-                        Some(field_ids) => (\n-                            field_ids\n-                                .iter()\n-                                .map(|&field_id| {\n-                                    format!(\"{}{tail}\", self.r.tcx.item_name(field_id))\n-                                })\n-                                .collect::<Vec<String>>()\n-                                .join(\", \"),\n-                            applicability,\n-                        ),\n+                        Some(field_ids) => {\n+                            let fields = field_ids.iter().map(|&id| self.r.tcx.item_name(id));\n+\n+                            let fields = if let Some(old_fields) = old_fields {\n+                                fields\n+                                    .enumerate()\n+                                    .map(|(idx, new)| (new, old_fields.get(idx)))\n+                                    .map(|(new, old)| {\n+                                        let new = new.to_ident_string();\n+                                        if let Some(Some(old)) = old && new != *old { format!(\"{}: {}\", new, old) } else { new }\n+                                    })\n+                                    .collect::<Vec<String>>()\n+                            } else {\n+                                fields.map(|f| format!(\"{f}{tail}\")).collect::<Vec<String>>()\n+                            };\n+\n+                            (fields.join(\", \"), applicability)\n+                        }\n                         None => (\"/* fields */\".to_string(), Applicability::HasPlaceholders),\n                     };\n                     let pad = match field_ids {"}, {"sha": "0548379dc2fc17ebaa53dfeeb8045c8684233657", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1422,6 +1422,9 @@ options! {\n     fewer_names: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) \\\n         (default: no)\"),\n+    flatten_format_args: bool = (false, parse_bool, [TRACKED],\n+        \"flatten nested format_args!() and literals into a simplified format_args!() call \\\n+        (default: no)\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable (default: no)\"),\n     fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],"}, {"sha": "abe5af8f9e0cf137bd7ea26a7745f6b2d3591258", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -984,6 +984,7 @@ symbols! {\n         never_type_fallback,\n         new,\n         new_binary,\n+        new_const,\n         new_debug,\n         new_display,\n         new_lower_exp,\n@@ -1153,6 +1154,7 @@ symbols! {\n         read_enum_variant_arg,\n         read_struct,\n         read_struct_field,\n+        read_via_copy,\n         readonly,\n         realloc,\n         reason,"}, {"sha": "f3304e9142920cf79f731476ad606069e6148514", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1115,6 +1115,7 @@ supported_targets! {\n     // FIXME(#106649): Remove aarch64-fuchsia in favor of aarch64-unknown-fuchsia\n     (\"aarch64-fuchsia\", aarch64_fuchsia),\n     (\"aarch64-unknown-fuchsia\", aarch64_unknown_fuchsia),\n+    (\"riscv64gc-unknown-fuchsia\", riscv64gc_unknown_fuchsia),\n     // FIXME(#106649): Remove x86_64-fuchsia in favor of x86_64-unknown-fuchsia\n     (\"x86_64-fuchsia\", x86_64_fuchsia),\n     (\"x86_64-unknown-fuchsia\", x86_64_unknown_fuchsia),"}, {"sha": "ab7c08958fa8868e95a99cdc295aa3449ee201f5", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_fuchsia.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_fuchsia.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,19 @@\n+use crate::spec::{CodeModel, SanitizerSet, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"riscv64gc-unknown-fuchsia\".into(),\n+        pointer_width: 64,\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n+        arch: \"riscv64\".into(),\n+        options: TargetOptions {\n+            code_model: Some(CodeModel::Medium),\n+            cpu: \"generic-rv64\".into(),\n+            features: \"+m,+a,+f,+d,+c\".into(),\n+            llvm_abiname: \"lp64d\".into(),\n+            max_atomic_width: Some(64),\n+            supported_sanitizers: SanitizerSet::SHADOWCALLSTACK,\n+            ..super::fuchsia_base::opts()\n+        },\n+    }\n+}"}, {"sha": "856f1eec4433bb1c49435e7b169aca28fbab8df3", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n@@ -144,7 +144,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n         self.infcx\n             .at(&ObligationCause::dummy(), param_env)\n-            .eq(lhs, rhs)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n             .map(|InferOk { value: (), obligations }| {\n                 obligations.into_iter().map(|o| o.into()).collect()\n             })"}, {"sha": "a873060687d359a1a808a0752ad02b931022976e", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(goal.predicate.a, goal.predicate.b)?;\n+                .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n             self.evaluate_all_and_make_canonical_response(\n                 obligations.into_iter().map(|pred| pred.into()).collect(),\n             )"}, {"sha": "1870d3a2daf3235c2c31bdce5d231b1c2bc7b9ab", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -7,6 +7,7 @@ use crate::errors::UnableToConstructConstantValue;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitableExt;\n@@ -814,7 +815,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(DefineOpaqueTypes::No,c1, c2)\n                             {\n                                 Ok(_) => (),\n                                 Err(_) => return false,"}, {"sha": "f4cfe4ec0b0ce65eb37b2a4a3dd9f3bb305d1b69", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -17,7 +17,7 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -181,7 +181,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    let obligations = equate_impl_headers(selcx, &impl1_header, &impl2_header)?;\n+    let obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n     debug!(\"overlap: unification check succeeded\");\n \n     if overlap_mode.use_implicit_negative() {\n@@ -207,20 +207,25 @@ fn overlap_within_probe<'cx, 'tcx>(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-fn equate_impl_headers<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_header: &ty::ImplHeader<'tcx>,\n-    impl2_header: &ty::ImplHeader<'tcx>,\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn equate_impl_headers<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    impl1: &ty::ImplHeader<'tcx>,\n+    impl2: &ty::ImplHeader<'tcx>,\n ) -> Option<PredicateObligations<'tcx>> {\n-    // Do `a` and `b` unify? If not, no overlap.\n-    debug!(\"equate_impl_headers(impl1_header={:?}, impl2_header={:?}\", impl1_header, impl2_header);\n-    selcx\n-        .infcx\n-        .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-        .define_opaque_types(true)\n-        .eq_impl_headers(impl1_header, impl2_header)\n-        .map(|infer_ok| infer_ok.obligations)\n-        .ok()\n+    let result = match (impl1.trait_ref, impl2.trait_ref) {\n+        (Some(impl1_ref), Some(impl2_ref)) => infcx\n+            .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+            .eq(DefineOpaqueTypes::Yes, impl1_ref, impl2_ref),\n+        (None, None) => infcx.at(&ObligationCause::dummy(), ty::ParamEnv::empty()).eq(\n+            DefineOpaqueTypes::Yes,\n+            impl1.self_ty,\n+            impl2.self_ty,\n+        ),\n+        _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+    };\n+\n+    result.map(|infer_ok| infer_ok.obligations).ok()\n }\n \n /// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n@@ -325,7 +330,7 @@ fn equate<'tcx>(\n ) -> bool {\n     // do the impls unify? If not, not disjoint.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), impl_env).eq(subject1, subject2)\n+        infcx.at(&ObligationCause::dummy(), impl_env).eq(DefineOpaqueTypes::No,subject1, subject2)\n     else {\n         debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n         return true;"}, {"sha": "8acc31cd410bdfa4d0372927671503989773144b", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n@@ -128,8 +128,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .eq_exp(a_is_expected, a, b)\n+            .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, a, b)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -142,8 +141,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .eq(expected, actual)\n+            .eq(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -157,8 +155,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .sub(expected, actual)\n+            .sub(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -172,8 +169,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .sup(expected, actual)\n+            .sup(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n "}, {"sha": "277926688e21d51f7038bb277bef412ec5d809fd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -144,6 +144,10 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> OnUnimplementedNote {\n+        if self.tcx.opt_rpitit_info(obligation.cause.body_id.to_def_id()).is_some() {\n+            return OnUnimplementedNote::default();\n+        }\n+\n         let (def_id, substs) = self\n             .impl_similar_to(trait_ref, obligation)\n             .unwrap_or_else(|| (trait_ref.def_id(), trait_ref.skip_binder().substs));"}, {"sha": "1aaadae12ddd9641f353de2bbcb2147ace6997ac", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,6 +2,7 @@ use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n@@ -515,7 +516,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                                 if let Ok(new_obligations) = infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n-                                    .eq(a.substs, b.substs)\n+                                    .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n                                     return ProcessResult::Changed(mk_pending(\n                                         new_obligations.into_obligations(),\n@@ -524,8 +525,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                             }\n                             (_, Unevaluated(_)) | (Unevaluated(_), _) => (),\n                             (_, _) => {\n-                                if let Ok(new_obligations) =\n-                                    infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                                if let Ok(new_obligations) = infcx\n+                                    .at(&obligation.cause, obligation.param_env)\n+                                    .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n                                     return ProcessResult::Changed(mk_pending(\n                                         new_obligations.into_obligations(),\n@@ -565,12 +567,11 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self\n-                                .selcx\n-                                .infcx\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n-                            {\n+                            match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                                DefineOpaqueTypes::No,\n+                                c1,\n+                                c2,\n+                            ) {\n                                 Ok(inf_ok) => {\n                                     ProcessResult::Changed(mk_pending(inf_ok.into_obligations()))\n                                 }\n@@ -610,12 +611,11 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    match self\n-                        .selcx\n-                        .infcx\n-                        .at(&obligation.cause, obligation.param_env)\n-                        .eq(ct.ty(), ty)\n-                    {\n+                    match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                        DefineOpaqueTypes::No,\n+                        ct.ty(),\n+                        ty,\n+                    ) {\n                         Ok(inf_ok) => ProcessResult::Changed(mk_pending(inf_ok.into_obligations())),\n                         Err(_) => ProcessResult::Error(FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented,"}, {"sha": "a5def4151bfda5d2d73ccb75388a4f2080204a05", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -13,7 +13,6 @@ use super::{elaborate_predicates, elaborate_trait_ref};\n use crate::infer::TyCtxtInferExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n-use hir::def::DefKind;\n use rustc_errors::{DelayDm, FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -157,6 +156,7 @@ fn object_safety_violations_for_trait(\n                 .in_definition_order()\n                 .filter(|item| item.kind == ty::AssocKind::Type)\n                 .filter(|item| !tcx.generics_of(item.def_id).params.is_empty())\n+                .filter(|item| tcx.opt_rpitit_info(item.def_id).is_none())\n                 .map(|item| {\n                     let ident = item.ident(tcx);\n                     ObjectSafetyViolation::GAT(ident.name, ident.span)\n@@ -854,7 +854,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<TyCtxt<'tcx>>>(\n                     }\n                 }\n                 ty::Alias(ty::Projection, ref data)\n-                    if self.tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder =>\n+                    if self.tcx.is_impl_trait_in_trait(data.def_id) =>\n                 {\n                     // We'll deny these later in their own pass\n                     ControlFlow::Continue(())\n@@ -921,7 +921,7 @@ pub fn contains_illegal_impl_trait_in_trait<'tcx>(\n     ty.skip_binder().walk().find_map(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n             && let ty::Alias(ty::Projection, proj) = ty.kind()\n-            && tcx.def_kind(proj.def_id) == DefKind::ImplTraitPlaceholder\n+            && tcx.is_impl_trait_in_trait(proj.def_id)\n         {\n             Some(MethodViolationCode::ReferencesImplTraitInTrait(tcx.def_span(proj.def_id)))\n         } else {"}, {"sha": "0f0cccea13075a4ac5bcb67064b961dd1fb99aa6", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -28,6 +28,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -285,12 +286,12 @@ fn project_and_unify_type<'cx, 'tcx>(\n         );\n     obligations.extend(new);\n \n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        // This is needed to support nested opaque types like `impl Fn() -> impl Trait`\n-        .define_opaque_types(true)\n-        .eq(normalized, actual)\n-    {\n+    // Need to define opaque types to support nested opaque types like `impl Fn() -> impl Trait`\n+    match infcx.at(&obligation.cause, obligation.param_env).eq(\n+        DefineOpaqueTypes::Yes,\n+        normalized,\n+        actual,\n+    ) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             ProjectAndUnifyResult::Holds(obligations)\n@@ -467,6 +468,11 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n             return ty;\n         }\n \n+        let (kind, data) = match *ty.kind() {\n+            ty::Alias(kind, alias_ty) => (kind, alias_ty),\n+            _ => return ty.super_fold_with(self),\n+        };\n+\n         // We try to be a little clever here as a performance optimization in\n         // cases where there are nested projections under binders.\n         // For example:\n@@ -490,13 +496,11 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n         // replace bound vars if the current type is a `Projection` and we need\n         // to make sure we don't forget to fold the substs regardless.\n \n-        match *ty.kind() {\n+        match kind {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. })\n-                if !substs.has_escaping_bound_vars() =>\n-            {\n+            ty::Opaque if !data.substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n@@ -512,8 +516,8 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                             );\n                         }\n \n-                        let substs = substs.fold_with(self);\n-                        let generic_ty = self.interner().type_of(def_id);\n+                        let substs = data.substs.fold_with(self);\n+                        let generic_ty = self.interner().type_of(data.def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.depth += 1;\n                         let folded_ty = self.fold_ty(concrete_ty);\n@@ -522,8 +526,9 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                     }\n                 }\n             }\n+            ty::Opaque => ty.super_fold_with(self),\n \n-            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n+            ty::Projection if !data.has_escaping_bound_vars() => {\n                 // This branch is *mostly* just an optimization: when we don't\n                 // have escaping bound vars, we don't need to replace them with\n                 // placeholders (see branch below). *Also*, we know that we can\n@@ -562,7 +567,7 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 normalized_ty.ty().unwrap()\n             }\n \n-            ty::Alias(ty::Projection, data) => {\n+            ty::Projection => {\n                 // If there are escaping bound vars, we temporarily replace the\n                 // bound vars with placeholders. Note though, that in the case\n                 // that we still can't project for whatever reason (e.g. self\n@@ -611,8 +616,6 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n-\n-            _ => ty.super_fold_with(self),\n         }\n     }\n \n@@ -2064,7 +2067,11 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n \n     debug!(?cache_projection, ?obligation_projection);\n \n-    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n+    match infcx.at(cause, param_env).eq(\n+        DefineOpaqueTypes::No,\n+        cache_projection,\n+        obligation_projection,\n+    ) {\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);"}, {"sha": "a986a9b6a71b13597cd72125de3684527845408b", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -197,23 +197,30 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n             return Ok(*ty);\n         }\n \n+        let (kind, data) = match *ty.kind() {\n+            ty::Alias(kind, data) => (kind, data),\n+            _ => {\n+                let res = ty.try_super_fold_with(self)?;\n+                self.cache.insert(ty, res);\n+                return Ok(res);\n+            }\n+        };\n+\n         // See note in `rustc_trait_selection::traits::project` about why we\n         // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n-        let res = match *ty.kind() {\n+        let res = match kind {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. })\n-                if !substs.has_escaping_bound_vars() =>\n-            {\n+            ty::Opaque if !data.substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.try_super_fold_with(self)?,\n \n                     Reveal::All => {\n-                        let substs = substs.try_fold_with(self)?;\n+                        let substs = data.substs.try_fold_with(self)?;\n                         let recursion_limit = self.interner().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n                             // A closure or generator may have itself as in its upvars.\n@@ -228,7 +235,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                             return ty.try_super_fold_with(self);\n                         }\n \n-                        let generic_ty = self.interner().type_of(def_id);\n+                        let generic_ty = self.interner().type_of(data.def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.anon_depth += 1;\n                         if concrete_ty == ty {\n@@ -248,62 +255,22 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 }\n             }\n \n-            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n-                // This branch is just an optimization: when we don't have escaping bound vars,\n-                // we don't need to replace them with placeholders (see branch below).\n-\n-                let tcx = self.infcx.tcx;\n-                let data = data.try_fold_with(self)?;\n-\n-                let mut orig_values = OriginalQueryValues::default();\n-                // HACK(matthewjasper) `'static` is special-cased in selection,\n-                // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n-                    .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n-                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n-                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n-                // We don't expect ambiguity.\n-                if result.is_ambiguous() {\n-                    // Rustdoc normalizes possibly not well-formed types, so only\n-                    // treat this as a bug if we're not in rustdoc.\n-                    if !tcx.sess.opts.actually_rustdoc {\n-                        tcx.sess.delay_span_bug(\n-                            DUMMY_SP,\n-                            format!(\"unexpected ambiguity: {:?} {:?}\", c_data, result),\n-                        );\n-                    }\n-                    return Err(NoSolution);\n-                }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n-                        self.cause,\n-                        self.param_env,\n-                        &orig_values,\n-                        result,\n-                    )?;\n-                debug!(\"QueryNormalizer: result = {:#?}\", result);\n-                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n-                self.obligations.extend(obligations);\n-\n-                let res = result.normalized_ty;\n-                // `tcx.normalize_projection_ty` may normalize to a type that still has\n-                // unevaluated consts, so keep normalizing here if that's the case.\n-                if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    res.try_super_fold_with(self)?\n-                } else {\n-                    res\n-                }\n-            }\n+            ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Alias(ty::Projection, data) => {\n+            ty::Projection => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n                 let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n-                let (data, mapped_regions, mapped_types, mapped_consts) =\n-                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                // Just an optimization: When we don't have escaping bound vars,\n+                // we don't need to replace them with placeholders.\n+                let (data, maps) = if data.has_escaping_bound_vars() {\n+                    let (data, mapped_regions, mapped_types, mapped_consts) =\n+                        BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                    (data, Some((mapped_regions, mapped_types, mapped_consts)))\n+                } else {\n+                    (data, None)\n+                };\n                 let data = data.try_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n@@ -337,14 +304,18 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                 self.obligations.extend(obligations);\n-                let res = PlaceholderReplacer::replace_placeholders(\n-                    infcx,\n-                    mapped_regions,\n-                    mapped_types,\n-                    mapped_consts,\n-                    &self.universes,\n-                    result.normalized_ty,\n-                );\n+                let res = if let Some((mapped_regions, mapped_types, mapped_consts)) = maps {\n+                    PlaceholderReplacer::replace_placeholders(\n+                        infcx,\n+                        mapped_regions,\n+                        mapped_types,\n+                        mapped_consts,\n+                        &self.universes,\n+                        result.normalized_ty,\n+                    )\n+                } else {\n+                    result.normalized_ty\n+                };\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n@@ -353,8 +324,6 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     res\n                 }\n             }\n-\n-            _ => ty.try_super_fold_with(self)?,\n         };\n \n         self.cache.insert(ty, res);"}, {"sha": "3d5dd18f4c1d7355f81dcebf622e8efe5f98e844", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,8 +8,8 @@\n //! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::ty::{\n     self, Binder, GenericParamDefKind, InternalSubsts, SubstsRef, ToPolyTraitRef, ToPredicate,\n     TraitRef, Ty, TyCtxt, TypeVisitableExt,\n@@ -177,7 +177,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligations.extend(self.infcx.commit_if_ok(|_| {\n             self.infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .sup(placeholder_trait_predicate, candidate)\n+                .sup(DefineOpaqueTypes::No, placeholder_trait_predicate, candidate)\n                 .map(|InferOk { obligations, .. }| obligations)\n                 .map_err(|_| Unimplemented)\n         })?);\n@@ -462,7 +462,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         nested.extend(self.infcx.commit_if_ok(|_| {\n             self.infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .sup(obligation_trait_ref, upcast_trait_ref)\n+                .sup(DefineOpaqueTypes::No, obligation_trait_ref, upcast_trait_ref)\n                 .map(|InferOk { obligations, .. }| obligations)\n                 .map_err(|_| Unimplemented)\n         })?);\n@@ -827,11 +827,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 )\n             });\n \n+        // needed to define opaque types for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            // needed for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs\n-            .define_opaque_types(true)\n-            .sup(obligation_trait_ref, expected_trait_ref)\n+            .sup(DefineOpaqueTypes::Yes, obligation_trait_ref, expected_trait_ref)\n             .map(|InferOk { mut obligations, .. }| {\n                 obligations.extend(nested);\n                 obligations\n@@ -896,7 +895,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .sup(target, source_trait)\n+                    .sup(DefineOpaqueTypes::No, target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -995,7 +994,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .sup(target, source_trait)\n+                    .sup(DefineOpaqueTypes::No, target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -1066,7 +1065,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(b, a)\n+                    .eq(DefineOpaqueTypes::No, b, a)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n             }\n@@ -1114,7 +1113,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_struct)\n+                    .eq(DefineOpaqueTypes::No, target, new_struct)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -1144,7 +1143,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_tuple)\n+                    .eq(DefineOpaqueTypes::No, target, new_tuple)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n "}, {"sha": "bc1c72da1e175faeac50891fac5d22fab7cb8556", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -38,6 +38,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::TraitEngineExt;\n@@ -912,7 +913,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n-                                    .eq(a.substs, b.substs)\n+                                    .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n                                     self.add_depth(\n@@ -930,7 +931,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 if let Ok(new_obligations) = self\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n-                                    .eq(c1, c2)\n+                                    .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n                                     self.add_depth(\n@@ -964,8 +965,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n-                            {\n+                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                                DefineOpaqueTypes::No,\n+                                c1,\n+                                c2,\n+                            ) {\n                                 Ok(inf_ok) => self.evaluate_predicates_recursively(\n                                     previous_stack,\n                                     inf_ok.into_obligations(),\n@@ -993,7 +997,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(ct.ty(), ty) {\n+                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                        DefineOpaqueTypes::No,\n+                        ct.ty(),\n+                        ty,\n+                    ) {\n                         Ok(inf_ok) => self.evaluate_predicates_recursively(\n                             previous_stack,\n                             inf_ok.into_obligations(),\n@@ -1751,7 +1759,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n+            .sup(DefineOpaqueTypes::No, ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n                 // inference variables and placeholders escape.\n@@ -1813,7 +1821,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let is_match = self\n             .infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation.predicate, infer_projection)\n+            .sup(DefineOpaqueTypes::No, obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n@@ -2534,7 +2542,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         let InferOk { obligations, .. } = self\n             .infcx\n             .at(&cause, obligation.param_env)\n-            .eq(placeholder_obligation_trait_ref, impl_trait_ref)\n+            .eq(DefineOpaqueTypes::No, placeholder_obligation_trait_ref, impl_trait_ref)\n             .map_err(|e| {\n                 debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e.to_string(self.tcx()))\n             })?;\n@@ -2584,7 +2592,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n+            .sup(DefineOpaqueTypes::No, obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())\n     }"}, {"sha": "8e229dd8d6b98aabaab20aae11d5e0ffab889d41", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -10,6 +10,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n@@ -193,7 +194,7 @@ fn fulfill_implication<'tcx>(\n \n     // do the impls unify? If not, no specialization.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait, target_trait)\n+        infcx.at(&ObligationCause::dummy(), param_env, ).eq(DefineOpaqueTypes::No,source_trait, target_trait)\n     else {\n         debug!(\n             \"fulfill_implication: {:?} does not unify with {:?}\","}, {"sha": "ab4c36975a0ecf07053efd85ae48a626498f1ec4", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,15 +1,14 @@\n-use rustc_errors::Diagnostic;\n-use rustc_span::Span;\n-use smallvec::SmallVec;\n-\n+use super::NormalizeExt;\n+use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{GenericArg, SubstsRef};\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n \n-use super::NormalizeExt;\n-use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n-use rustc_infer::infer::InferOk;\n pub use rustc_infer::traits::{self, util::*};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -201,6 +200,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n+\n     let InferOk { value: subject, obligations: normalization_obligations1 } =\n         selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(subject);\n "}, {"sha": "a28161245384c033812c60d899001a80e5bdae14", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -328,6 +328,9 @@ fn impl_associated_item_for_impl_trait_in_trait(\n     // `opt_local_def_id_to_hir_id` with `None`.\n     impl_assoc_ty.opt_local_def_id_to_hir_id(None);\n \n+    // Copy span of the opaque.\n+    impl_assoc_ty.def_ident_span(Some(span));\n+\n     impl_assoc_ty.associated_item(ty::AssocItem {\n         name: kw::Empty,\n         kind: ty::AssocKind::Type,\n@@ -342,6 +345,9 @@ fn impl_associated_item_for_impl_trait_in_trait(\n     // extra predicates to assume.\n     impl_assoc_ty.param_env(tcx.param_env(impl_fn_def_id));\n \n+    // Copy visility of the containing function.\n+    impl_assoc_ty.visibility(tcx.visibility(impl_fn_def_id));\n+\n     // Copy impl_defaultness of the containing function.\n     impl_assoc_ty.impl_defaultness(tcx.impl_defaultness(impl_fn_def_id));\n "}, {"sha": "1788f544a7f9a1ccddaa973c7a346264ac3e7b23", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -156,7 +156,11 @@ fn layout_of_uncached<'tcx>(\n \n             let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n \n-            let metadata = if let Some(metadata_def_id) = tcx.lang_items().metadata_type() {\n+            let metadata = if let Some(metadata_def_id) = tcx.lang_items().metadata_type()\n+                // Projection eagerly bails out when the pointee references errors,\n+                // fall back to structurally deducing metadata.\n+                && !pointee.references_error()\n+            {\n                 let metadata_ty = tcx.normalize_erasing_regions(\n                     param_env,\n                     tcx.mk_projection(metadata_def_id, [pointee]),"}, {"sha": "d41bf603983c071f8f51e3f9208698e5dab259f4", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -119,12 +119,9 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> &[Ty<'_>] {\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // When computing the param_env of an RPITIT, copy param_env of the containing function. The\n     // synthesized associated type doesn't have extra predicates to assume.\n-    let def_id =\n-        if let Some(ImplTraitInTraitData::Trait { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id) {\n-            fn_def_id\n-        } else {\n-            def_id\n-        };\n+    if let Some(ImplTraitInTraitData::Trait { fn_def_id, .. }) = tcx.opt_rpitit_info(def_id) {\n+        return tcx.param_env(fn_def_id);\n+    }\n \n     // Compute the bounds on Self and the type parameters.\n     let ty::InstantiatedPredicates { mut predicates, .. } ="}, {"sha": "7ae46203f972a8619ce8c93549fff6b591666e65", "filename": "config.example.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/config.example.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/config.example.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.example.toml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -146,6 +146,9 @@ changelog-seen = 2\n # Whether to build the clang compiler.\n #clang = false\n \n+# Whether to enable llvm compilation warnings.\n+#enable-warnings = false\n+\n # Custom CMake defines to set when building LLVM.\n #build-config = {}\n "}, {"sha": "089b6b6418dc15002b820e5cbaf8e3391a49e14c", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1738,11 +1738,11 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n \n     /// Inequality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are unequal if their inner values are unequal.\n+    /// Two `Rc`s are not equal if their inner values are not equal.\n     ///\n     /// If `T` also implements `Eq` (implying reflexivity of equality),\n     /// two `Rc`s that point to the same allocation are\n-    /// never unequal.\n+    /// always equal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "8a27a7ecdf653c69c851b9b87e48c1256bf5b808", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2475,10 +2475,10 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n \n     /// Inequality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are unequal if their inner values are unequal.\n+    /// Two `Arc`s are not equal if their inner values are not equal.\n     ///\n     /// If `T` also implements `Eq` (implying reflexivity of equality),\n-    /// two `Arc`s that point to the same value are never unequal.\n+    /// two `Arc`s that point to the same value are always equal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "6d764237dc8ae429c17bc19fe81c7e99fb946018", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -392,8 +392,31 @@ enum FlagV1 {\n }\n \n impl<'a> Arguments<'a> {\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n+    pub const fn new_const(pieces: &'a [&'static str]) -> Self {\n+        if pieces.len() > 1 {\n+            panic!(\"invalid args\");\n+        }\n+        Arguments { pieces, fmt: None, args: &[] }\n+    }\n+\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n+    #[cfg(not(bootstrap))]\n+    #[doc(hidden)]\n+    #[inline]\n+    #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n+    pub fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\n+        if pieces.len() < args.len() || pieces.len() > args.len() + 1 {\n+            panic!(\"invalid args\");\n+        }\n+        Arguments { pieces, fmt: None, args }\n+    }\n+\n+    #[cfg(bootstrap)]\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n@@ -417,8 +440,7 @@ impl<'a> Arguments<'a> {\n     #[doc(hidden)]\n     #[inline]\n     #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\", issue = \"none\")]\n-    #[rustc_const_unstable(feature = \"const_fmt_arguments_new\", issue = \"none\")]\n-    pub const fn new_v1_formatted(\n+    pub fn new_v1_formatted(\n         pieces: &'a [&'static str],\n         args: &'a [ArgumentV1<'a>],\n         fmt: &'a [rt::v1::Argument],"}, {"sha": "3bdde0993b9a28e315c938a3647061f5e215965d", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -158,7 +158,7 @@ mod sip;\n ///\n /// Implementations of `hash` should ensure that the data they\n /// pass to the `Hasher` are prefix-free. That is,\n-/// unequal values should cause two different sequences of values to be written,\n+/// values which are not equal should cause two different sequences of values to be written,\n /// and neither of the two sequences should be a prefix of the other.\n ///\n /// For example, the standard implementation of [`Hash` for `&str`][impl] passes an extra"}, {"sha": "ee8846675ce25135403d8fff3fdbe92e3ec5d12b", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2020,6 +2020,16 @@ extern \"rust-intrinsic\" {\n     #[rustc_safe_intrinsic]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n+    /// This is an implementation detail of [`crate::ptr::read`] and should\n+    /// not be used anywhere else.  See its comments for why this exists.\n+    ///\n+    /// This intrinsic can *only* be called where the argument is a local without\n+    /// projections (`read_via_copy(p)`, not `read_via_copy(*p)`) so that it\n+    /// trivially obeys runtime-MIR rules about derefs in operands.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    pub fn read_via_copy<T>(p: *const T) -> T;\n+\n     /// Returns the value of the discriminant for the variant in 'v';\n     /// if `T` has no discriminant, returns `0`.\n     ///"}, {"sha": "e791158e25948385f9a37d943dc7d44b8fa32e25", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -3721,7 +3721,7 @@ pub trait Iterator {\n         }\n     }\n \n-    /// Determines if the elements of this [`Iterator`] are unequal to those of\n+    /// Determines if the elements of this [`Iterator`] are not equal to those of\n     /// another.\n     ///\n     /// # Examples"}, {"sha": "dd0105c0eb4fa3862c66620b7f434c41687b1b42", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -111,7 +111,7 @@ pub const fn panic(expr: &'static str) -> ! {\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+    panic_fmt(fmt::Arguments::new_const(&[expr]));\n }\n \n /// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n@@ -120,7 +120,7 @@ pub const fn panic(expr: &'static str) -> ! {\n #[lang = \"panic_nounwind\"] // needed by codegen for non-unwinding panics\n #[rustc_nounwind]\n pub fn panic_nounwind(expr: &'static str) -> ! {\n-    panic_nounwind_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]));\n }\n \n #[inline]"}, {"sha": "e12a3e378a6154dbea7013bd5c5e6c6438980a19", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1110,7 +1110,7 @@ impl<T: Copy> Copy for (T,) {\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n ///   behavior:\n-///   - It is unequal to any float, including itself! This is the reason `f32`\n+///   - It is not equal to any float, including itself! This is the reason `f32`\n ///     doesn't implement the `Eq` trait.\n ///   - It is also neither smaller nor greater than any float, making it\n ///     impossible to sort by the default comparison operation, which is the"}, {"sha": "5884a8ca308072bbf8dc5e008bba2723439119ac", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1135,27 +1135,58 @@ pub const unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n pub const unsafe fn read<T>(src: *const T) -> T {\n-    // We are calling the intrinsics directly to avoid function calls in the generated code\n-    // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n-    extern \"rust-intrinsic\" {\n-        #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n-        fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n-    }\n+    // It would be semantically correct to implement this via `copy_nonoverlapping`\n+    // and `MaybeUninit`, as was done before PR #109035. Calling `assume_init`\n+    // provides enough information to know that this is a typed operation.\n \n-    let mut tmp = MaybeUninit::<T>::uninit();\n-    // SAFETY: the caller must guarantee that `src` is valid for reads.\n-    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n-    // the stack as a separate allocated object.\n+    // However, as of March 2023 the compiler was not capable of taking advantage\n+    // of that information.  Thus the implementation here switched to an intrinsic,\n+    // which lowers to `_0 = *src` in MIR, to address a few issues:\n     //\n-    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n-    // to be properly initialized.\n+    // - Using `MaybeUninit::assume_init` after a `copy_nonoverlapping` was not\n+    //   turning the untyped copy into a typed load. As such, the generated\n+    //   `load` in LLVM didn't get various metadata, such as `!range` (#73258),\n+    //   `!nonnull`, and `!noundef`, resulting in poorer optimization.\n+    // - Going through the extra local resulted in multiple extra copies, even\n+    //   in optimized MIR.  (Ignoring StorageLive/Dead, the intrinsic is one\n+    //   MIR statement, while the previous implementation was eight.)  LLVM\n+    //   could sometimes optimize them away, but because `read` is at the core\n+    //   of so many things, not having them in the first place improves what we\n+    //   hand off to the backend.  For example, `mem::replace::<Big>` previously\n+    //   emitted 4 `alloca` and 6 `memcpy`s, but is now 1 `alloc` and 3 `memcpy`s.\n+    // - In general, this approach keeps us from getting any more bugs (like\n+    //   #106369) that boil down to \"`read(p)` is worse than `*p`\", as this\n+    //   makes them look identical to the backend (or other MIR consumers).\n+    //\n+    // Future enhancements to MIR optimizations might well allow this to return\n+    // to the previous implementation, rather than using an intrinsic.\n+\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n     unsafe {\n         assert_unsafe_precondition!(\n             \"ptr::read requires that the pointer argument is aligned and non-null\",\n             [T](src: *const T) => is_aligned_and_not_null(src)\n         );\n-        copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-        tmp.assume_init()\n+\n+        #[cfg(bootstrap)]\n+        {\n+            // We are calling the intrinsics directly to avoid function calls in the\n+            // generated code as `intrinsics::copy_nonoverlapping` is a wrapper function.\n+            extern \"rust-intrinsic\" {\n+                #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+                fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+            }\n+\n+            // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+            // the stack as a separate allocated object.\n+            let mut tmp = MaybeUninit::<T>::uninit();\n+            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+            tmp.assume_init()\n+        }\n+        #[cfg(not(bootstrap))]\n+        {\n+            crate::intrinsics::read_via_copy(src)\n+        }\n     }\n }\n "}, {"sha": "c1c80c46c78b7327f6eaf671884a1b4ee9a32cd4", "filename": "library/core/tests/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Ffmt%2Fmod.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -22,11 +22,11 @@ fn test_pointer_formats_data_pointer() {\n #[test]\n fn test_estimated_capacity() {\n     assert_eq!(format_args!(\"\").estimated_capacity(), 0);\n-    assert_eq!(format_args!(\"{}\", \"\").estimated_capacity(), 0);\n+    assert_eq!(format_args!(\"{}\", {\"\"}).estimated_capacity(), 0);\n     assert_eq!(format_args!(\"Hello\").estimated_capacity(), 5);\n-    assert_eq!(format_args!(\"Hello, {}!\", \"\").estimated_capacity(), 16);\n-    assert_eq!(format_args!(\"{}, hello!\", \"World\").estimated_capacity(), 0);\n-    assert_eq!(format_args!(\"{}. 16-bytes piece\", \"World\").estimated_capacity(), 32);\n+    assert_eq!(format_args!(\"Hello, {}!\", {\"\"}).estimated_capacity(), 16);\n+    assert_eq!(format_args!(\"{}, hello!\", {\"World\"}).estimated_capacity(), 0);\n+    assert_eq!(format_args!(\"{}. 16-bytes piece\", {\"World\"}).estimated_capacity(), 32);\n }\n \n #[test]"}, {"sha": "e12a3e378a6154dbea7013bd5c5e6c6438980a19", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1110,7 +1110,7 @@ impl<T: Copy> Copy for (T,) {\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n ///   behavior:\n-///   - It is unequal to any float, including itself! This is the reason `f32`\n+///   - It is not equal to any float, including itself! This is the reason `f32`\n ///     doesn't implement the `Eq` trait.\n ///   - It is also neither smaller nor greater than any float, making it\n ///     impossible to sort by the default comparison operation, which is the"}, {"sha": "519ec2c32bd5d5b59ec50b5699851e141cd9f6f3", "filename": "library/std/src/sync/remutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -35,7 +35,7 @@ use crate::sys::locks as sys;\n /// `owner` can be checked by other threads that want to see if they already\n /// hold the lock, so needs to be atomic. If it compares equal, we're on the\n /// same thread that holds the mutex and memory access can use relaxed ordering\n-/// since we're not dealing with multiple threads. If it compares unequal,\n+/// since we're not dealing with multiple threads. If it's not equal,\n /// synchronization is left to the mutex, making relaxed memory ordering for\n /// the `owner` field fine in all cases.\n pub struct ReentrantMutex<T> {"}, {"sha": "654e03d0c3c7f5d222b700f105dc997f0d61f8e0", "filename": "src/bootstrap/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCHANGELOG.md?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -25,6 +25,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n - If you have Rust already installed, `x.py` will now infer the host target\n   from the default rust toolchain. [#78513](https://github.com/rust-lang/rust/pull/78513)\n - Add options for enabling overflow checks, one for std (`overflow-checks-std`) and one for everything else (`overflow-checks`). Both default to false.\n+- Add llvm option `enable-warnings` to have control on llvm compilation warnings. Default to false.\n \n \n ## [Version 2] - 2020-09-25"}, {"sha": "58729f396f0b65a09519b3bd098e73c3098aa867", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -133,6 +133,7 @@ pub struct Config {\n     pub llvm_allow_old_toolchain: bool,\n     pub llvm_polly: bool,\n     pub llvm_clang: bool,\n+    pub llvm_enable_warnings: bool,\n     pub llvm_from_ci: bool,\n     pub llvm_build_config: HashMap<String, String>,\n \n@@ -688,6 +689,7 @@ define_config! {\n         allow_old_toolchain: Option<bool> = \"allow-old-toolchain\",\n         polly: Option<bool> = \"polly\",\n         clang: Option<bool> = \"clang\",\n+        enable_warnings: Option<bool> = \"enable-warnings\",\n         download_ci_llvm: Option<StringOrBool> = \"download-ci-llvm\",\n         build_config: Option<HashMap<String, String>> = \"build-config\",\n     }\n@@ -1184,6 +1186,7 @@ impl Config {\n             config.llvm_allow_old_toolchain = llvm.allow_old_toolchain.unwrap_or(false);\n             config.llvm_polly = llvm.polly.unwrap_or(false);\n             config.llvm_clang = llvm.clang.unwrap_or(false);\n+            config.llvm_enable_warnings = llvm.enable_warnings.unwrap_or(false);\n             config.llvm_build_config = llvm.build_config.clone().unwrap_or(Default::default());\n \n             let asserts = llvm_assertions.unwrap_or(false);"}, {"sha": "20b2699c761bf8c6ad89b0a6147154dadebc2221", "filename": "src/bootstrap/defaults/config.codegen.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Fdefaults%2Fconfig.codegen.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Fdefaults%2Fconfig.codegen.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.codegen.toml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -7,6 +7,8 @@ compiler-docs = true\n # This enables debug-assertions in LLVM,\n # catching logic errors in codegen much earlier in the process.\n assertions = true\n+# enable warnings during the llvm compilation\n+enable-warnings = true\n \n [rust]\n # This enables `RUSTC_LOG=debug`, avoiding confusing situations"}, {"sha": "f136690592d7218423915a528264d8c0c011cf46", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -495,6 +495,7 @@ impl Build {\n \n         // Make a symbolic link so we can use a consistent directory in the documentation.\n         let build_triple = build.out.join(&build.build.triple);\n+        t!(fs::create_dir_all(&build_triple));\n         let host = build.out.join(\"host\");\n         if let Err(e) = symlink_dir(&build.config, &build_triple, &host) {\n             if e.kind() != ErrorKind::AlreadyExists {"}, {"sha": "41ee509655326a02b7f54a764dcbdc4cd74b73a1", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -304,6 +304,7 @@ impl Step for Llvm {\n         let assertions = if builder.config.llvm_assertions { \"ON\" } else { \"OFF\" };\n         let plugins = if builder.config.llvm_plugins { \"ON\" } else { \"OFF\" };\n         let enable_tests = if builder.config.llvm_tests { \"ON\" } else { \"OFF\" };\n+        let enable_warnings = if builder.config.llvm_enable_warnings { \"ON\" } else { \"OFF\" };\n \n         cfg.out_dir(&out_dir)\n             .profile(profile)\n@@ -321,7 +322,8 @@ impl Step for Llvm {\n             .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n             .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n             .define(\"LLVM_TARGET_ARCH\", target_native.split('-').next().unwrap())\n-            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target_native);\n+            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target_native)\n+            .define(\"LLVM_ENABLE_WARNINGS\", enable_warnings);\n \n         // Parts of our test suite rely on the `FileCheck` tool, which is built by default in\n         // `build/$TARGET/llvm/build/bin` is but *not* then installed to `build/$TARGET/llvm/bin`.\n@@ -483,11 +485,6 @@ impl Step for Llvm {\n             cfg.define(key, val);\n         }\n \n-        // FIXME: we don't actually need to build all LLVM tools and all LLVM\n-        //        libraries here, e.g., we just want a few components and a few\n-        //        tools. Figure out how to filter them down and only build the right\n-        //        tools and libs on all platforms.\n-\n         if builder.config.dry_run() {\n             return res;\n         }"}, {"sha": "2d74a2240969ccf0ee94f22d795374e68834588e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -295,6 +295,7 @@ target | std | host | notes\n [`riscv32imac-unknown-xous-elf`](platform-support/riscv32imac-unknown-xous-elf.md) | ? |  | RISC-V Xous (RV32IMAC ISA)\n `riscv32imc-esp-espidf` | \u2713 |  | RISC-V ESP-IDF\n `riscv64gc-unknown-freebsd` |   |   | RISC-V FreeBSD\n+`riscv64gc-unknown-fuchsia` |   |   | RISC-V Fuchsia\n `riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)\n [`riscv64gc-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | OpenBSD/riscv64\n `s390x-unknown-linux-musl` |  |  | S390x Linux (kernel 3.2, MUSL)"}, {"sha": "29912b95703b2f8c48dada046dbfeb2642376127", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -20,15 +20,13 @@ smallvec = \"1.8.1\"\n tempfile = \"3\"\n tracing = \"0.1\"\n tracing-tree = \"0.2.0\"\n+threadpool = \"1.8.1\"\n \n [dependencies.tracing-subscriber]\n version = \"0.3.3\"\n default-features = false\n features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"]\n \n-[target.'cfg(windows)'.dependencies]\n-rayon = \"1.5.1\"\n-\n [dev-dependencies]\n expect-test = \"1.4.0\"\n "}, {"sha": "3a3bf6a7ab9e862bd874c4e6aa0946271219861e", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,6 +1,6 @@\n use crate::rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_hir as hir;\n-use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::ty::ToPredicate;\n use rustc_span::DUMMY_SP;\n@@ -47,8 +47,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n                 // Require the type the impl is implemented on to match\n                 // our type, and ignore the impl if there was a mismatch.\n-                let cause = traits::ObligationCause::dummy();\n-                let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                let Ok(eq_result) = infcx.at(&traits::ObligationCause::dummy(), param_env).eq(DefineOpaqueTypes::No, impl_trait_ref.self_ty(), impl_ty) else {\n                         continue\n                     };\n                 let InferOk { value: (), obligations } = eq_result;"}, {"sha": "d58b8dc6ad4a4473fde1991f3c0f19ad5716b00f", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,18 +2,20 @@\n //!\n //! On Windows this indirects IO into threads to work around performance issues\n //! with Defender (and other similar virus scanners that do blocking operations).\n-//! On other platforms this is a thin shim to fs.\n //!\n //! Only calls needed to permit this workaround have been abstracted: thus\n //! fs::read is still done directly via the fs module; if in future rustdoc\n //! needs to read-after-write from a file, then it would be added to this\n //! abstraction.\n \n+use std::cmp::max;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::string::ToString;\n use std::sync::mpsc::Sender;\n+use std::thread::available_parallelism;\n+use threadpool::ThreadPool;\n \n pub(crate) trait PathError {\n     fn new<S, P: AsRef<Path>>(e: S, path: P) -> Self\n@@ -24,11 +26,21 @@ pub(crate) trait PathError {\n pub(crate) struct DocFS {\n     sync_only: bool,\n     errors: Option<Sender<String>>,\n+    pool: ThreadPool,\n }\n \n impl DocFS {\n     pub(crate) fn new(errors: Sender<String>) -> DocFS {\n-        DocFS { sync_only: false, errors: Some(errors) }\n+        const MINIMUM_NB_THREADS: usize = 2;\n+        DocFS {\n+            sync_only: false,\n+            errors: Some(errors),\n+            pool: ThreadPool::new(\n+                available_parallelism()\n+                    .map(|nb| max(nb.get(), MINIMUM_NB_THREADS))\n+                    .unwrap_or(MINIMUM_NB_THREADS),\n+            ),\n+        }\n     }\n \n     pub(crate) fn set_sync_only(&mut self, sync_only: bool) {\n@@ -54,12 +66,11 @@ impl DocFS {\n     where\n         E: PathError,\n     {\n-        #[cfg(windows)]\n         if !self.sync_only {\n             // A possible future enhancement after more detailed profiling would\n             // be to create the file sync so errors are reported eagerly.\n             let sender = self.errors.clone().expect(\"can't write after closing\");\n-            rayon::spawn(move || {\n+            self.pool.execute(move || {\n                 fs::write(&path, contents).unwrap_or_else(|e| {\n                     sender.send(format!(\"\\\"{}\\\": {}\", path.display(), e)).unwrap_or_else(|_| {\n                         panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n@@ -70,9 +81,12 @@ impl DocFS {\n             fs::write(&path, contents).map_err(|e| E::new(e, path))?;\n         }\n \n-        #[cfg(not(windows))]\n-        fs::write(&path, contents).map_err(|e| E::new(e, path))?;\n-\n         Ok(())\n     }\n }\n+\n+impl Drop for DocFS {\n+    fn drop(&mut self) {\n+        self.pool.join();\n+    }\n+}"}, {"sha": "27010b771d33b29462afeb36d01ec794197544d5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -771,6 +771,12 @@ pub(crate) fn link_tooltip(did: DefId, fragment: &Option<UrlFragment>, cx: &Cont\n         .or_else(|| cache.external_paths.get(&did))\n         else { return String::new() };\n     let mut buf = Buffer::new();\n+    let fqp = if *shortty == ItemType::Primitive {\n+        // primitives are documented in a crate, but not actually part of it\n+        &fqp[fqp.len() - 1..]\n+    } else {\n+        &fqp\n+    };\n     if let &Some(UrlFragment::Item(id)) = fragment {\n         write!(buf, \"{} \", cx.tcx().def_descr(id));\n         for component in fqp {"}, {"sha": "08a0e1c377ef8231f4e5a60b03d1c1037ec5b7c6", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -486,7 +486,7 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n     }\n \n     // First, check if it's \"Self\".\n-    let arg = if let Some(self_) = self_ {\n+    let mut arg = if let Some(self_) = self_ {\n         match &*arg {\n             Type::BorrowedRef { type_, .. } if type_.is_self_type() => self_,\n             type_ if type_.is_self_type() => self_,\n@@ -496,11 +496,16 @@ fn add_generics_and_bounds_as_types<'tcx, 'a>(\n         arg\n     };\n \n+    // strip references from the argument type\n+    while let Type::BorrowedRef { type_, .. } = &*arg {\n+        arg = &*type_;\n+    }\n+\n     // If this argument is a type parameter and not a trait bound or a type, we need to look\n     // for its bounds.\n     if let Type::Generic(arg_s) = *arg {\n         // First we check if the bounds are in a `where` predicate...\n-        if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n+        for where_pred in generics.where_predicates.iter().filter(|g| match g {\n             WherePredicate::BoundPredicate { ty: Type::Generic(ty_s), .. } => *ty_s == arg_s,\n             _ => false,\n         }) {"}, {"sha": "4a3c588b1f0a8e2dc8dd8789dbf3b6a71b02ed49", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1 +1 @@\n-Subproject commit 7d3033d2e59383fd76193daf9423c3d141972a7d\n+Subproject commit 4a3c588b1f0a8e2dc8dd8789dbf3b6a71b02ed49"}, {"sha": "c0e32068ecaccecb39ee2ca6d5fd476559163f54", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -533,6 +533,14 @@ struct FormatArgsValues<'tcx> {\n }\n \n impl<'tcx> FormatArgsValues<'tcx> {\n+    fn new_empty(format_string_span: SpanData) -> Self {\n+        Self {\n+            value_args: Vec::new(),\n+            pos_to_value_index: Vec::new(),\n+            format_string_span,\n+        }\n+    }\n+\n     fn new(args: &'tcx Expr<'tcx>, format_string_span: SpanData) -> Self {\n         let mut pos_to_value_index = Vec::new();\n         let mut value_args = Vec::new();\n@@ -997,12 +1005,13 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n             .find(|&name| matches!(name, sym::const_format_args | sym::format_args | sym::format_args_nl))?;\n         let newline = macro_name == sym::format_args_nl;\n \n+        // ::core::fmt::Arguments::new_const(pieces)\n         // ::core::fmt::Arguments::new_v1(pieces, args)\n         // ::core::fmt::Arguments::new_v1_formatted(pieces, args, fmt, _unsafe_arg)\n-        if let ExprKind::Call(callee, [pieces, args, rest @ ..]) = expr.kind\n+        if let ExprKind::Call(callee, [pieces, rest @ ..]) = expr.kind\n             && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind\n             && let TyKind::Path(QPath::LangItem(LangItem::FormatArguments, _, _)) = ty.kind\n-            && matches!(seg.ident.as_str(), \"new_v1\" | \"new_v1_formatted\")\n+            && matches!(seg.ident.as_str(), \"new_const\" | \"new_v1\" | \"new_v1_formatted\")\n         {\n             let format_string = FormatString::new(cx, pieces)?;\n \n@@ -1026,7 +1035,7 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n                 return None;\n             }\n \n-            let positions = if let Some(fmt_arg) = rest.first() {\n+            let positions = if let Some(fmt_arg) = rest.get(1) {\n                 // If the argument contains format specs, `new_v1_formatted(_, _, fmt, _)`, parse\n                 // them.\n \n@@ -1042,7 +1051,11 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n                 }))\n             };\n \n-            let values = FormatArgsValues::new(args, format_string.span.data());\n+            let values = if let Some(args) = rest.first() {\n+                FormatArgsValues::new(args, format_string.span.data())\n+            } else {\n+                FormatArgsValues::new_empty(format_string.span.data())\n+            };\n \n             let args = izip!(positions, parsed_args, parser.arg_places)\n                 .map(|(position, parsed_arg, arg_span)| {"}, {"sha": "18c2561242a39fd0fdf51db39b21d595629a5b41", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1 +1 @@\n-1716932743a7b3705cbf0c34db0c4e070ed1930d\n+511364e7874dba9649a264100407e4bffe7b5425"}, {"sha": "fdbfa1b096d4b610619f6e924f2a8cd72df552b2", "filename": "tests/codegen-units/polymorphization/auxiliary/poly-dep.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen-units%2Fpolymorphization%2Fauxiliary%2Fpoly-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen-units%2Fpolymorphization%2Fauxiliary%2Fpoly-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen-units%2Fpolymorphization%2Fauxiliary%2Fpoly-dep.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,4 @@\n+// compile-flags: -Zpolymorphize=on\n+\n+#[inline(never)]\n+pub fn foo<T>() {}"}, {"sha": "9da082daf114a99f457c03c0186f5941db0fb1dd", "filename": "tests/codegen-units/polymorphization/poly-foreign.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen-units%2Fpolymorphization%2Fpoly-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen-units%2Fpolymorphization%2Fpoly-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen-units%2Fpolymorphization%2Fpoly-foreign.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,11 @@\n+// aux-build:poly-dep.rs\n+// compile-flags: --crate-type=lib -Zprint-mono-items=eager -Zpolymorphize=on\n+\n+extern crate poly_dep;\n+\n+pub static FN1: fn() = poly_dep::foo::<i32>;\n+pub static FN2: fn() = poly_dep::foo::<u32>;\n+\n+//~ MONO_ITEM static FN1\n+//~ MONO_ITEM static FN2\n+//~ MONO_ITEM fn poly_dep::foo::<T>"}, {"sha": "3fe7be4f1442ef0feacc591d410d32b09500d899", "filename": "tests/codegen/issues/issue-106369.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fissues%2Fissue-106369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fissues%2Fissue-106369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-106369.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -O\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// From <https://github.com/rust-lang/rust/issues/106369#issuecomment-1369095304>\n+\n+// CHECK-LABEL: @issue_106369(\n+#[no_mangle]\n+pub unsafe fn issue_106369(ptr: *const &i32) -> bool {\n+    // CHECK-NOT: icmp\n+    // CHECK: ret i1 true\n+    // CHECK-NOT: icmp\n+    Some(std::ptr::read(ptr)).is_some()\n+}"}, {"sha": "0134f929b296111e2491e5bcf540f69af0437bae", "filename": "tests/codegen/issues/issue-73258.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fissues%2Fissue-73258.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fissues%2Fissue-73258.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fissues%2Fissue-73258.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,38 @@\n+// compile-flags: -O\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// Adapted from <https://github.com/rust-lang/rust/issues/73258#issue-637346014>\n+\n+#[derive(Clone, Copy)]\n+#[repr(u8)]\n+pub enum Foo {\n+    A, B, C, D,\n+}\n+\n+// CHECK-LABEL: @issue_73258(\n+#[no_mangle]\n+pub unsafe fn issue_73258(ptr: *const Foo) -> Foo {\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: call\n+    // CHECK-NOT: br\n+    // CHECK-NOT: select\n+\n+    // CHECK: %[[R:.+]] = load i8\n+    // CHECK-SAME: !range !\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: call\n+    // CHECK-NOT: br\n+    // CHECK-NOT: select\n+\n+    // CHECK: ret i8 %[[R]]\n+\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: call\n+    // CHECK-NOT: br\n+    // CHECK-NOT: select\n+    let k: Option<Foo> = Some(ptr.read());\n+    return k.unwrap();\n+}"}, {"sha": "f6898e2f75814e87d1d91c094257601c78504566", "filename": "tests/codegen/mem-replace-big-type.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fmem-replace-big-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fmem-replace-big-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-big-type.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,36 @@\n+// This test ensures that `mem::replace::<T>` only ever calls `@llvm.memcpy`\n+// with `size_of::<T>()` as the size, and never goes through any wrapper that\n+// may e.g. multiply `size_of::<T>()` with a variable \"count\" (which is only\n+// known to be `1` after inlining).\n+\n+// compile-flags: -C no-prepopulate-passes -Zinline-mir=no\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+#[repr(C, align(8))]\n+pub struct Big([u64; 7]);\n+pub fn replace_big(dst: &mut Big, src: Big) -> Big {\n+    // Before the `read_via_copy` intrinsic, this emitted six `memcpy`s.\n+    std::mem::replace(dst, src)\n+}\n+\n+// NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n+// the entire output, are the direct calls we want, from `ptr::replace`.\n+\n+// CHECK-NOT: call void @llvm.memcpy\n+\n+// For a large type, we expect exactly three `memcpy`s\n+// CHECK-LABEL: define internal void @{{.+}}mem{{.+}}replace{{.+}}sret(%Big)\n+    // CHECK-NOT: alloca\n+    // CHECK: alloca %Big\n+    // CHECK-NOT: alloca\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 8 %{{.*}}, {{i8\\*|ptr}} align 8 %{{.*}}, i{{.*}} 56, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+\n+// CHECK-NOT: call void @llvm.memcpy"}, {"sha": "83babab4f847b150dc4d0e8301b13c7298e49e3a", "filename": "tests/codegen/mem-replace-direct-memcpy.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fmem-replace-direct-memcpy.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -13,12 +13,21 @@ pub fn replace_byte(dst: &mut u8, src: u8) -> u8 {\n }\n \n // NOTE(eddyb) the `CHECK-NOT`s ensure that the only calls of `@llvm.memcpy` in\n-// the entire output, are the two direct calls we want, from `ptr::replace`.\n+// the entire output, are the direct calls we want, from `ptr::replace`.\n \n // CHECK-NOT: call void @llvm.memcpy\n-// CHECK: ; core::mem::replace\n-// CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n-// CHECK-NOT: call void @llvm.memcpy\n-// CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+\n+// For a small type, we expect one each of `load`/`store`/`memcpy` instead\n+// CHECK-LABEL: define internal noundef i8 @{{.+}}mem{{.+}}replace\n+    // CHECK-NOT: alloca\n+    // CHECK: alloca i8\n+    // CHECK-NOT: alloca\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: load i8\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: store i8\n+    // CHECK-NOT: call void @llvm.memcpy\n+    // CHECK: call void @llvm.memcpy.{{.+}}({{i8\\*|ptr}} align 1 %{{.*}}, {{i8\\*|ptr}} align 1 %{{.*}}, i{{.*}} 1, i1 false)\n+    // CHECK-NOT: call void @llvm.memcpy\n+\n // CHECK-NOT: call void @llvm.memcpy"}, {"sha": "e1e3272662c4bbc0ea3c9a2c45ecd8719e2b510c", "filename": "tests/codegen/ptr-read-metadata.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fptr-read-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fcodegen%2Fptr-read-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fptr-read-metadata.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,96 @@\n+// compile-flags: -O -Z merge-functions=disabled\n+// no-system-llvm\n+// ignore-debug (the extra assertions get in the way)\n+\n+#![crate_type = \"lib\"]\n+\n+// Ensure that various forms of reading pointers correctly annotate the `load`s\n+// with `!noundef` and `!range` metadata to enable extra optimization.\n+\n+use std::mem::MaybeUninit;\n+\n+// CHECK-LABEL: define noundef i8 @copy_byte(\n+#[no_mangle]\n+pub unsafe fn copy_byte(p: *const u8) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    *p\n+}\n+\n+// CHECK-LABEL: define noundef i8 @read_byte(\n+#[no_mangle]\n+pub unsafe fn read_byte(p: *const u8) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i8 @read_byte_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_byte_maybe_uninit(p: *const MaybeUninit<u8>) -> MaybeUninit<u8> {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define noundef i8 @read_byte_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_byte_assume_init(p: &MaybeUninit<u8>) -> u8 {\n+    // CHECK-NOT: load\n+    // CHECK: load i8, ptr %p, align 1\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.assume_init_read()\n+}\n+\n+// CHECK-LABEL: define noundef i32 @copy_char(\n+#[no_mangle]\n+pub unsafe fn copy_char(p: *const char) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE:[0-9]+]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    *p\n+}\n+\n+// CHECK-LABEL: define noundef i32 @read_char(\n+#[no_mangle]\n+pub unsafe fn read_char(p: *const char) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define i32 @read_char_maybe_uninit(\n+#[no_mangle]\n+pub unsafe fn read_char_maybe_uninit(p: *const MaybeUninit<char>) -> MaybeUninit<char> {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-NOT: range\n+    // CHECK-NOT: noundef\n+    // CHECK-NOT: load\n+    p.read()\n+}\n+\n+// CHECK-LABEL: define noundef i32 @read_char_assume_init(\n+#[no_mangle]\n+pub unsafe fn read_char_assume_init(p: &MaybeUninit<char>) -> char {\n+    // CHECK-NOT: load\n+    // CHECK: load i32, ptr %p\n+    // CHECK-SAME: !range ![[RANGE]]\n+    // CHECK-SAME: !noundef !\n+    // CHECK-NOT: load\n+    p.assume_init_read()\n+}\n+\n+// CHECK: ![[RANGE]] = !{i32 0, i32 1114112}"}, {"sha": "c5ce044dd53f0ba8a4b5880347c6a046743fb325", "filename": "tests/debuginfo/type-names.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Ftype-names.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -175,7 +175,6 @@\n // 0-sized structs appear to be optimized away in some cases, so only check the structs that do\n // actually appear.\n // cdb-command:dv /t *_struct\n-// cdb-check:struct type_names::GenericStruct<enum2$<type_names::mod1::Enum2>,f64> mut_generic_struct = [...]\n \n // ENUMS\n // cdb-command:dv /t *_enum_*"}, {"sha": "7e77c18d5758ee8c5930c1c07c4e16f9245e69aa", "filename": "tests/mir-opt/const_prop/control_flow_simplification.hello.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fcontrol_flow_simplification.hello.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fcontrol_flow_simplification.hello.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fcontrol_flow_simplification.hello.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -14,7 +14,6 @@\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 0 at $SRC_DIR/std/src/panic.rs:LL:COL\n           _2 = begin_panic::<&str>(const \"explicit panic\"); // scope 0 at $SRC_DIR/std/src/panic.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/panic.rs:LL:COL"}, {"sha": "85dedf68ce925efc94ea8ee96f28a97fcafc6743", "filename": "tests/mir-opt/const_prop/invalid_constant.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -12,12 +12,10 @@\n           let _3: [E; 1];                  // in scope 1 at $DIR/invalid_constant.rs:+13:9: +13:21\n           scope 3 {\n               debug _invalid_tag => _3;    // in scope 3 at $DIR/invalid_constant.rs:+13:9: +13:21\n-              let _6: [Empty; 1];          // in scope 3 at $DIR/invalid_constant.rs:+20:9: +20:31\n               scope 5 {\n-                  debug _enum_without_variants => _6; // in scope 5 at $DIR/invalid_constant.rs:+20:9: +20:31\n-                  let _7: main::Str<\"\ufffd\ufffd\ufffd\">; // in scope 5 at $DIR/invalid_constant.rs:+24:9: +24:22\n+                  debug _enum_without_variants => const [ZeroSized: Empty]; // in scope 5 at $DIR/invalid_constant.rs:+20:9: +20:31\n                   scope 7 {\n-                      debug _non_utf8_str => _7; // in scope 7 at $DIR/invalid_constant.rs:+24:9: +24:22\n+                      debug _non_utf8_str => const Str::<\"\ufffd\ufffd\ufffd\">; // in scope 7 at $DIR/invalid_constant.rs:+24:9: +24:22\n                   }\n               }\n               scope 6 {\n@@ -52,10 +50,6 @@\n +                                          // + literal: Const { ty: E, val: Value(Scalar(0x00000004)) }\n           StorageDead(_4);                 // scope 1 at $DIR/invalid_constant.rs:+13:59: +13:60\n           StorageDead(_5);                 // scope 1 at $DIR/invalid_constant.rs:+13:60: +13:61\n-          StorageLive(_6);                 // scope 3 at $DIR/invalid_constant.rs:+20:9: +20:31\n-          StorageLive(_7);                 // scope 5 at $DIR/invalid_constant.rs:+24:9: +24:22\n-          StorageDead(_7);                 // scope 5 at $DIR/invalid_constant.rs:+27:1: +27:2\n-          StorageDead(_6);                 // scope 3 at $DIR/invalid_constant.rs:+27:1: +27:2\n           StorageDead(_3);                 // scope 1 at $DIR/invalid_constant.rs:+27:1: +27:2\n           StorageDead(_1);                 // scope 0 at $DIR/invalid_constant.rs:+27:1: +27:2\n           return;                          // scope 0 at $DIR/invalid_constant.rs:+27:2: +27:2"}, {"sha": "e31c2bc39388be10c706214f6f33331f77ffd9c3", "filename": "tests/mir-opt/const_prop/invalid_constant.main.RemoveZsts.diff", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.RemoveZsts.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.RemoveZsts.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.RemoveZsts.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,76 @@\n+- // MIR for `main` before RemoveZsts\n++ // MIR for `main` after RemoveZsts\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/invalid_constant.rs:+0:11: +0:11\n+      let _1: char;                        // in scope 0 at $DIR/invalid_constant.rs:+6:9: +6:22\n+      let mut _2: main::InvalidChar;       // in scope 0 at $DIR/invalid_constant.rs:+6:34: +6:63\n+      let mut _4: E;                       // in scope 0 at $DIR/invalid_constant.rs:+13:25: +13:59\n+      let mut _5: main::InvalidTag;        // in scope 0 at $DIR/invalid_constant.rs:+13:34: +13:55\n+      let mut _7: Empty;                   // in scope 0 at $DIR/invalid_constant.rs:+20:35: +20:73\n+      let mut _8: main::NoVariants;        // in scope 0 at $DIR/invalid_constant.rs:+20:44: +20:65\n+      scope 1 {\n+          debug _invalid_char => _1;       // in scope 1 at $DIR/invalid_constant.rs:+6:9: +6:22\n+          let _3: [E; 1];                  // in scope 1 at $DIR/invalid_constant.rs:+13:9: +13:21\n+          scope 3 {\n+              debug _invalid_tag => _3;    // in scope 3 at $DIR/invalid_constant.rs:+13:9: +13:21\n+              let _6: [Empty; 1];          // in scope 3 at $DIR/invalid_constant.rs:+20:9: +20:31\n+              scope 5 {\n+-                 debug _enum_without_variants => _6; // in scope 5 at $DIR/invalid_constant.rs:+20:9: +20:31\n++                 debug _enum_without_variants => const [ZeroSized: Empty]; // in scope 5 at $DIR/invalid_constant.rs:+20:9: +20:31\n+                  let _9: main::Str<\"\ufffd\ufffd\ufffd\">; // in scope 5 at $DIR/invalid_constant.rs:+24:9: +24:22\n+                  scope 7 {\n+-                     debug _non_utf8_str => _9; // in scope 7 at $DIR/invalid_constant.rs:+24:9: +24:22\n++                     debug _non_utf8_str => const Str::<\"\ufffd\ufffd\ufffd\">; // in scope 7 at $DIR/invalid_constant.rs:+24:9: +24:22\n+                  }\n+              }\n+              scope 6 {\n+              }\n+          }\n+          scope 4 {\n+          }\n+      }\n+      scope 2 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/invalid_constant.rs:+6:9: +6:22\n+          StorageLive(_2);                 // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:63\n+          _2 = InvalidChar { int: const 1114113_u32 }; // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:63\n+          _1 = (_2.1: char);               // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:67\n+          StorageDead(_2);                 // scope 0 at $DIR/invalid_constant.rs:+6:69: +6:70\n+          StorageLive(_3);                 // scope 1 at $DIR/invalid_constant.rs:+13:9: +13:21\n+          StorageLive(_4);                 // scope 1 at $DIR/invalid_constant.rs:+13:25: +13:59\n+          StorageLive(_5);                 // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:55\n+          _5 = InvalidTag { int: const 4_u32 }; // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:55\n+          _4 = (_5.1: E);                  // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:57\n+          _3 = [move _4];                  // scope 1 at $DIR/invalid_constant.rs:+13:24: +13:60\n+          StorageDead(_4);                 // scope 1 at $DIR/invalid_constant.rs:+13:59: +13:60\n+          StorageDead(_5);                 // scope 1 at $DIR/invalid_constant.rs:+13:60: +13:61\n+-         StorageLive(_6);                 // scope 3 at $DIR/invalid_constant.rs:+20:9: +20:31\n+-         StorageLive(_7);                 // scope 3 at $DIR/invalid_constant.rs:+20:35: +20:73\n++         nop;                             // scope 3 at $DIR/invalid_constant.rs:+20:9: +20:31\n++         nop;                             // scope 3 at $DIR/invalid_constant.rs:+20:35: +20:73\n+          StorageLive(_8);                 // scope 6 at $DIR/invalid_constant.rs:+20:44: +20:65\n+          _8 = NoVariants { int: const 0_u32 }; // scope 6 at $DIR/invalid_constant.rs:+20:44: +20:65\n+-         _7 = (_8.1: Empty);              // scope 6 at $DIR/invalid_constant.rs:+20:44: +20:71\n+-         _6 = [move _7];                  // scope 3 at $DIR/invalid_constant.rs:+20:34: +20:74\n+-         StorageDead(_7);                 // scope 3 at $DIR/invalid_constant.rs:+20:73: +20:74\n++         nop;                             // scope 6 at $DIR/invalid_constant.rs:+20:44: +20:71\n++         nop;                             // scope 3 at $DIR/invalid_constant.rs:+20:34: +20:74\n++         nop;                             // scope 3 at $DIR/invalid_constant.rs:+20:73: +20:74\n+          StorageDead(_8);                 // scope 3 at $DIR/invalid_constant.rs:+20:74: +20:75\n+-         StorageLive(_9);                 // scope 5 at $DIR/invalid_constant.rs:+24:9: +24:22\n+-         _0 = const ();                   // scope 0 at $DIR/invalid_constant.rs:+0:11: +27:2\n+-         StorageDead(_9);                 // scope 5 at $DIR/invalid_constant.rs:+27:1: +27:2\n+-         StorageDead(_6);                 // scope 3 at $DIR/invalid_constant.rs:+27:1: +27:2\n++         nop;                             // scope 5 at $DIR/invalid_constant.rs:+24:9: +24:22\n++         nop;                             // scope 0 at $DIR/invalid_constant.rs:+0:11: +27:2\n++         nop;                             // scope 5 at $DIR/invalid_constant.rs:+27:1: +27:2\n++         nop;                             // scope 3 at $DIR/invalid_constant.rs:+27:1: +27:2\n+          StorageDead(_3);                 // scope 1 at $DIR/invalid_constant.rs:+27:1: +27:2\n+          StorageDead(_1);                 // scope 0 at $DIR/invalid_constant.rs:+27:1: +27:2\n+          return;                          // scope 0 at $DIR/invalid_constant.rs:+27:2: +27:2\n+      }\n+  }\n+  "}, {"sha": "eb6172cdff90f0cfaacef884a70240c4a99a6259", "filename": "tests/mir-opt/const_prop/invalid_constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -11,6 +11,7 @@ enum E { A, B, C }\n #[derive(Copy, Clone)]\n enum Empty {}\n \n+// EMIT_MIR invalid_constant.main.RemoveZsts.diff\n // EMIT_MIR invalid_constant.main.ConstProp.diff\n fn main() {\n     // An invalid char."}, {"sha": "a4f9003e1401eaa4ced15b9785ae05e90f172df0", "filename": "tests/mir-opt/const_prop/issue_66971.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -5,14 +5,10 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/issue_66971.rs:+0:11: +0:11\n       let _1: ();                          // in scope 0 at $DIR/issue_66971.rs:+1:5: +1:23\n       let mut _2: ((), u8, u8);            // in scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n-      let mut _3: ();                      // in scope 0 at $DIR/issue_66971.rs:+1:13: +1:15\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/issue_66971.rs:+1:5: +1:23\n           StorageLive(_2);                 // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n-          StorageLive(_3);                 // scope 0 at $DIR/issue_66971.rs:+1:13: +1:15\n-          _2 = (move _3, const 0_u8, const 0_u8); // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n-          StorageDead(_3);                 // scope 0 at $DIR/issue_66971.rs:+1:21: +1:22\n+          _2 = (const (), const 0_u8, const 0_u8); // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n           _1 = encode(move _2) -> bb1;     // scope 0 at $DIR/issue_66971.rs:+1:5: +1:23\n                                            // mir::Constant\n                                            // + span: $DIR/issue_66971.rs:17:5: 17:11\n@@ -21,7 +17,6 @@\n   \n       bb1: {\n           StorageDead(_2);                 // scope 0 at $DIR/issue_66971.rs:+1:22: +1:23\n-          StorageDead(_1);                 // scope 0 at $DIR/issue_66971.rs:+1:23: +1:24\n           return;                          // scope 0 at $DIR/issue_66971.rs:+2:2: +2:2\n       }\n   }"}, {"sha": "f456a321204989d74c172b6aa781b4737f5bc741", "filename": "tests/mir-opt/const_prop/issue_67019.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,6 @@\n       let mut _3: (u8, u8);                // in scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/issue_67019.rs:+1:5: +1:20\n           StorageLive(_2);                 // scope 0 at $DIR/issue_67019.rs:+1:10: +1:19\n           StorageLive(_3);                 // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n -         _3 = (const 1_u8, const 2_u8);   // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n@@ -23,7 +22,6 @@\n   \n       bb1: {\n           StorageDead(_2);                 // scope 0 at $DIR/issue_67019.rs:+1:19: +1:20\n-          StorageDead(_1);                 // scope 0 at $DIR/issue_67019.rs:+1:20: +1:21\n           return;                          // scope 0 at $DIR/issue_67019.rs:+2:2: +2:2\n       }\n   }"}, {"sha": "1151caaabbc1275ee0481a8c3caed00049d70e58", "filename": "tests/mir-opt/const_prop/scalar_literal_propagation.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.main.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -12,7 +12,6 @@\n   \n       bb0: {\n           _1 = const 1_u32;                // scope 0 at $DIR/scalar_literal_propagation.rs:+1:13: +1:14\n-          StorageLive(_2);                 // scope 1 at $DIR/scalar_literal_propagation.rs:+2:5: +2:15\n -         _2 = consume(_1) -> bb1;         // scope 1 at $DIR/scalar_literal_propagation.rs:+2:5: +2:15\n +         _2 = consume(const 1_u32) -> bb1; // scope 1 at $DIR/scalar_literal_propagation.rs:+2:5: +2:15\n                                            // mir::Constant\n@@ -21,7 +20,6 @@\n       }\n   \n       bb1: {\n-          StorageDead(_2);                 // scope 1 at $DIR/scalar_literal_propagation.rs:+2:15: +2:16\n           return;                          // scope 0 at $DIR/scalar_literal_propagation.rs:+3:2: +3:2\n       }\n   }"}, {"sha": "d370abce45a473caef323513c9b3e3b01361c132", "filename": "tests/mir-opt/const_prop/tuple_literal_propagation.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -13,15 +13,13 @@\n       bb0: {\n -         _1 = (const 1_u32, const 2_u32); // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n +         _1 = const (1_u32, 2_u32);       // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n-          StorageLive(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:+3:5: +3:15\n           _2 = consume(_1) -> bb1;         // scope 1 at $DIR/tuple_literal_propagation.rs:+3:5: +3:15\n                                            // mir::Constant\n                                            // + span: $DIR/tuple_literal_propagation.rs:5:5: 5:12\n                                            // + literal: Const { ty: fn((u32, u32)) {consume}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          StorageDead(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:+3:15: +3:16\n           return;                          // scope 0 at $DIR/tuple_literal_propagation.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "ed290063a930545cba8d4bbd7e1adf4f20a5b262", "filename": "tests/mir-opt/inline/asm_unwind.main.Inline.diff", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fasm_unwind.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fasm_unwind.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fasm_unwind.main.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -7,7 +7,7 @@\n +     scope 1 (inlined foo) {              // at $DIR/asm_unwind.rs:21:5: 21:10\n +         let _2: D;                       // in scope 1 at $DIR/asm_unwind.rs:15:9: 15:11\n +         scope 2 {\n-+             debug _d => _2;              // in scope 2 at $DIR/asm_unwind.rs:15:9: 15:11\n++             debug _d => const D;         // in scope 2 at $DIR/asm_unwind.rs:15:9: 15:11\n +             scope 3 {\n +             }\n +         }\n@@ -19,21 +19,21 @@\n -                                          // mir::Constant\n -                                          // + span: $DIR/asm_unwind.rs:21:5: 21:8\n -                                          // + literal: Const { ty: fn() {foo}, val: Value(<ZST>) }\n-+         StorageLive(_2);                 // scope 1 at $DIR/asm_unwind.rs:15:9: 15:11\n-+         asm!(\"\", options(MAY_UNWIND)) -> [return: bb1, unwind: bb3]; // scope 3 at $DIR/asm_unwind.rs:16:14: 16:54\n++         StorageLive(_2);                 // scope 0 at $DIR/asm_unwind.rs:+1:5: +1:10\n++         asm!(\"\", options(MAY_UNWIND)) -> [return: bb2, unwind: bb3]; // scope 3 at $DIR/asm_unwind.rs:16:14: 16:54\n       }\n   \n       bb1: {\n-+         drop(_2) -> bb2;                 // scope 1 at $DIR/asm_unwind.rs:17:1: 17:2\n-+     }\n-+ \n-+     bb2: {\n-+         StorageDead(_2);                 // scope 1 at $DIR/asm_unwind.rs:17:1: 17:2\n++         StorageDead(_2);                 // scope 0 at $DIR/asm_unwind.rs:+1:5: +1:10\n           StorageDead(_1);                 // scope 0 at $DIR/asm_unwind.rs:+1:10: +1:11\n           _0 = const ();                   // scope 0 at $DIR/asm_unwind.rs:+0:15: +2:2\n           return;                          // scope 0 at $DIR/asm_unwind.rs:+2:2: +2:2\n +     }\n + \n++     bb2: {\n++         drop(_2) -> bb1;                 // scope 1 at $DIR/asm_unwind.rs:17:1: 17:2\n++     }\n++ \n +     bb3 (cleanup): {\n +         drop(_2) -> bb4;                 // scope 1 at $DIR/asm_unwind.rs:17:1: 17:2\n +     }"}, {"sha": "20d313aecf5880f04a79381bf75aa7752078ccf9", "filename": "tests/mir-opt/inline/cycle.g.Inline.diff", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fcycle.g.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -5,11 +5,11 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:+0:8: +0:8\n       let _1: ();                          // in scope 0 at $DIR/cycle.rs:+1:5: +1:12\n +     let mut _2: fn() {main};             // in scope 0 at $DIR/cycle.rs:+1:5: +1:12\n++     let mut _5: ();                      // in scope 0 at $DIR/cycle.rs:6:5: 6:8\n +     scope 1 (inlined f::<fn() {main}>) { // at $DIR/cycle.rs:12:5: 12:12\n +         debug g => _2;                   // in scope 1 at $DIR/cycle.rs:5:6: 5:7\n +         let _3: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         let mut _4: &fn() {main};        // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n-+         let mut _5: ();                  // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         scope 2 (inlined <fn() {main} as Fn<()>>::call - shim(fn() {main})) { // at $DIR/cycle.rs:6:5: 6:8\n +         }\n +     }\n@@ -25,14 +25,16 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/cycle.rs:12:7: 12:11\n                                            // + literal: Const { ty: fn() {main}, val: Value(<ZST>) }\n-+         StorageLive(_3);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n++         StorageLive(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n +         StorageLive(_4);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         _4 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         StorageLive(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n++         _5 = const ();                   // scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         _3 = move (*_4)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n       }\n   \n       bb1: {\n++         StorageDead(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n +         StorageDead(_2);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:12\n           StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:+1:12: +1:13\n           _0 = const ();                   // scope 0 at $DIR/cycle.rs:+0:8: +2:2\n@@ -48,9 +50,8 @@\n +     }\n + \n +     bb4: {\n-+         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:8: 6:9\n +         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n       }\n   }"}, {"sha": "dacc5f4be9d7fb5b47465586113f58c02cc77680", "filename": "tests/mir-opt/inline/cycle.main.Inline.diff", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fcycle.main.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -5,11 +5,11 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:+0:11: +0:11\n       let _1: ();                          // in scope 0 at $DIR/cycle.rs:+1:5: +1:9\n +     let mut _2: fn() {g};                // in scope 0 at $DIR/cycle.rs:+1:5: +1:9\n++     let mut _5: ();                      // in scope 0 at $DIR/cycle.rs:6:5: 6:8\n +     scope 1 (inlined f::<fn() {g}>) {    // at $DIR/cycle.rs:17:5: 17:9\n +         debug g => _2;                   // in scope 1 at $DIR/cycle.rs:5:6: 5:7\n +         let _3: ();                      // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         let mut _4: &fn() {g};           // in scope 1 at $DIR/cycle.rs:6:5: 6:6\n-+         let mut _5: ();                  // in scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         scope 2 (inlined <fn() {g} as Fn<()>>::call - shim(fn() {g})) { // at $DIR/cycle.rs:6:5: 6:8\n +         }\n +     }\n@@ -25,14 +25,16 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/cycle.rs:17:7: 17:8\n                                            // + literal: Const { ty: fn() {g}, val: Value(<ZST>) }\n-+         StorageLive(_3);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n++         StorageLive(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n +         StorageLive(_4);                 // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         _4 = &_2;                        // scope 1 at $DIR/cycle.rs:6:5: 6:6\n +         StorageLive(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n++         _5 = const ();                   // scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         _3 = move (*_4)() -> [return: bb4, unwind: bb2]; // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n       }\n   \n       bb1: {\n++         StorageDead(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n +         StorageDead(_2);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:9\n           StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:+1:9: +1:10\n           _0 = const ();                   // scope 0 at $DIR/cycle.rs:+0:11: +2:2\n@@ -48,9 +50,8 @@\n +     }\n + \n +     bb4: {\n-+         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n++         StorageDead(_5);                 // scope 1 at $DIR/cycle.rs:6:5: 6:8\n +         StorageDead(_4);                 // scope 1 at $DIR/cycle.rs:6:7: 6:8\n-+         StorageDead(_3);                 // scope 1 at $DIR/cycle.rs:6:8: 6:9\n +         drop(_2) -> bb1;                 // scope 1 at $DIR/cycle.rs:7:1: 7:2\n       }\n   }"}, {"sha": "dd1f253cb47dd46f15dec6ba20fcf89ad839bfea", "filename": "tests/mir-opt/inline/exponential_runtime.main.Inline.diff", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fexponential_runtime.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fexponential_runtime.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fexponential_runtime.main.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -18,9 +18,13 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n -         _1 = <() as G>::call() -> bb1;   // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n-+         StorageLive(_2);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n-+         StorageLive(_5);                 // scope 2 at $DIR/exponential_runtime.rs:61:9: 61:25\n-+         _5 = <() as E>::call() -> bb3;   // scope 2 at $DIR/exponential_runtime.rs:61:9: 61:25\n++         StorageLive(_2);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++         StorageLive(_3);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++         StorageLive(_4);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++         StorageLive(_5);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         StorageLive(_6);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         StorageLive(_7);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         _5 = <() as E>::call() -> bb4;   // scope 2 at $DIR/exponential_runtime.rs:61:9: 61:25\n                                            // mir::Constant\n -                                          // + span: $DIR/exponential_runtime.rs:86:5: 86:20\n -                                          // + literal: Const { ty: fn() {<() as G>::call}, val: Value(<ZST>) }\n@@ -29,47 +33,43 @@\n       }\n   \n       bb1: {\n-+         StorageDead(_3);                 // scope 1 at $DIR/exponential_runtime.rs:74:25: 74:26\n-+         StorageLive(_4);                 // scope 1 at $DIR/exponential_runtime.rs:75:9: 75:25\n-+         _4 = <() as F>::call() -> bb2;   // scope 1 at $DIR/exponential_runtime.rs:75:9: 75:25\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/exponential_runtime.rs:75:9: 75:23\n-+                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n-+     }\n-+ \n-+     bb2: {\n-+         StorageDead(_4);                 // scope 1 at $DIR/exponential_runtime.rs:75:25: 75:26\n++         StorageDead(_4);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++         StorageDead(_3);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n++         StorageDead(_2);                 // scope 0 at $DIR/exponential_runtime.rs:+1:5: +1:22\n           StorageDead(_1);                 // scope 0 at $DIR/exponential_runtime.rs:+1:22: +1:23\n           _0 = const ();                   // scope 0 at $DIR/exponential_runtime.rs:+0:11: +2:2\n           return;                          // scope 0 at $DIR/exponential_runtime.rs:+2:2: +2:2\n +     }\n + \n++     bb2: {\n++         StorageDead(_7);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         StorageDead(_6);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         StorageDead(_5);                 // scope 1 at $DIR/exponential_runtime.rs:73:9: 73:25\n++         _3 = <() as F>::call() -> bb3;   // scope 1 at $DIR/exponential_runtime.rs:74:9: 74:25\n++                                          // mir::Constant\n++                                          // + span: $DIR/exponential_runtime.rs:74:9: 74:23\n++                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n++     }\n++ \n +     bb3: {\n-+         StorageDead(_5);                 // scope 2 at $DIR/exponential_runtime.rs:61:25: 61:26\n-+         StorageLive(_6);                 // scope 2 at $DIR/exponential_runtime.rs:62:9: 62:25\n-+         _6 = <() as E>::call() -> bb4;   // scope 2 at $DIR/exponential_runtime.rs:62:9: 62:25\n++         _4 = <() as F>::call() -> bb1;   // scope 1 at $DIR/exponential_runtime.rs:75:9: 75:25\n +                                          // mir::Constant\n-+                                          // + span: $DIR/exponential_runtime.rs:62:9: 62:23\n-+                                          // + literal: Const { ty: fn() {<() as E>::call}, val: Value(<ZST>) }\n++                                          // + span: $DIR/exponential_runtime.rs:75:9: 75:23\n++                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n +     }\n + \n +     bb4: {\n-+         StorageDead(_6);                 // scope 2 at $DIR/exponential_runtime.rs:62:25: 62:26\n-+         StorageLive(_7);                 // scope 2 at $DIR/exponential_runtime.rs:63:9: 63:25\n-+         _7 = <() as E>::call() -> bb5;   // scope 2 at $DIR/exponential_runtime.rs:63:9: 63:25\n++         _6 = <() as E>::call() -> bb5;   // scope 2 at $DIR/exponential_runtime.rs:62:9: 62:25\n +                                          // mir::Constant\n-+                                          // + span: $DIR/exponential_runtime.rs:63:9: 63:23\n++                                          // + span: $DIR/exponential_runtime.rs:62:9: 62:23\n +                                          // + literal: Const { ty: fn() {<() as E>::call}, val: Value(<ZST>) }\n +     }\n + \n +     bb5: {\n-+         StorageDead(_7);                 // scope 2 at $DIR/exponential_runtime.rs:63:25: 63:26\n-+         StorageDead(_2);                 // scope 1 at $DIR/exponential_runtime.rs:73:25: 73:26\n-+         StorageLive(_3);                 // scope 1 at $DIR/exponential_runtime.rs:74:9: 74:25\n-+         _3 = <() as F>::call() -> bb1;   // scope 1 at $DIR/exponential_runtime.rs:74:9: 74:25\n++         _7 = <() as E>::call() -> bb2;   // scope 2 at $DIR/exponential_runtime.rs:63:9: 63:25\n +                                          // mir::Constant\n-+                                          // + span: $DIR/exponential_runtime.rs:74:9: 74:23\n-+                                          // + literal: Const { ty: fn() {<() as F>::call}, val: Value(<ZST>) }\n++                                          // + span: $DIR/exponential_runtime.rs:63:9: 63:23\n++                                          // + literal: Const { ty: fn() {<() as E>::call}, val: Value(<ZST>) }\n       }\n   }\n   "}, {"sha": "0215b3d93f9e38ed4af14b181ac7644010a50f6a", "filename": "tests/mir-opt/inline/inline_cycle.two.Inline.diff", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_cycle.two.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -5,10 +5,10 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline_cycle.rs:+0:10: +0:10\n       let _1: ();                          // in scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12\n +     let mut _2: fn() {f};                // in scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12\n++     let mut _4: ();                      // in scope 0 at $DIR/inline_cycle.rs:54:5: 54:8\n +     scope 1 (inlined call::<fn() {f}>) { // at $DIR/inline_cycle.rs:49:5: 49:12\n +         debug f => _2;                   // in scope 1 at $DIR/inline_cycle.rs:53:22: 53:23\n +         let _3: ();                      // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n-+         let mut _4: ();                  // in scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n +         scope 2 (inlined <fn() {f} as FnOnce<()>>::call_once - shim(fn() {f})) { // at $DIR/inline_cycle.rs:54:5: 54:8\n +         }\n +     }\n@@ -24,14 +24,15 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline_cycle.rs:49:10: 49:11\n                                            // + literal: Const { ty: fn() {f}, val: Value(<ZST>) }\n-+         StorageLive(_3);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n++         StorageLive(_3);                 // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12\n +         StorageLive(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n++         _4 = const ();                   // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n +         _3 = move _2() -> bb1;           // scope 2 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n       }\n   \n       bb1: {\n-+         StorageDead(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:7: 54:8\n-+         StorageDead(_3);                 // scope 1 at $DIR/inline_cycle.rs:54:8: 54:9\n++         StorageDead(_4);                 // scope 1 at $DIR/inline_cycle.rs:54:5: 54:8\n++         StorageDead(_3);                 // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12\n +         StorageDead(_2);                 // scope 0 at $DIR/inline_cycle.rs:+1:5: +1:12\n           StorageDead(_1);                 // scope 0 at $DIR/inline_cycle.rs:+1:12: +1:13\n           _0 = const ();                   // scope 0 at $DIR/inline_cycle.rs:+0:10: +2:2"}, {"sha": "4f22ad43700ac27e783bea4682f95e4e87abc22b", "filename": "tests/mir-opt/inline/inline_diverging.g.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -34,7 +34,7 @@\n       bb2: {\n           StorageLive(_6);                 // scope 0 at $DIR/inline_diverging.rs:+4:9: +4:16\n -         _6 = panic();                    // scope 0 at $DIR/inline_diverging.rs:+4:9: +4:16\n-+         StorageLive(_7);                 // scope 1 at $SRC_DIR/std/src/panic.rs:LL:COL\n++         StorageLive(_7);                 // scope 0 at $DIR/inline_diverging.rs:+4:9: +4:16\n +         _7 = begin_panic::<&str>(const \"explicit panic\"); // scope 1 at $SRC_DIR/std/src/panic.rs:LL:COL\n                                            // mir::Constant\n -                                          // + span: $DIR/inline_diverging.rs:16:9: 16:14"}, {"sha": "31208e0052c6f65ebaac4daa12861a3e849a290a", "filename": "tests/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -5,19 +5,18 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline_diverging.rs:+0:12: +0:12\n       let _1: (!, !);                      // in scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n +     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n++     let mut _8: ();                      // in scope 0 at $DIR/inline_diverging.rs:27:13: 27:16\n +     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline_diverging.rs:22:5: 22:22\n +         debug f => _2;                   // in scope 1 at $DIR/inline_diverging.rs:26:36: 26:37\n +         let _3: !;                       // in scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n +         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n-+         let mut _5: ();                  // in scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n-+         let mut _6: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:14\n-+         let mut _7: ();                  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:16\n-+         let mut _8: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         let mut _9: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:9: 29:10\n++         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline_diverging.rs:28:13: 28:14\n++         let mut _6: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:6: 29:7\n++         let mut _7: !;                   // in scope 1 at $DIR/inline_diverging.rs:29:9: 29:10\n +         scope 2 {\n +             debug a => _3;               // in scope 2 at $DIR/inline_diverging.rs:27:9: 27:10\n +             scope 3 {\n-+                 debug b => _9;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n++                 debug b => _7;           // in scope 3 at $DIR/inline_diverging.rs:28:9: 28:10\n +             }\n +         }\n +         scope 4 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline_diverging.rs:27:13: 27:16\n@@ -35,21 +34,21 @@\n -                                          // mir::Constant\n                                            // + span: $DIR/inline_diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(<ZST>) }\n-+         StorageLive(_9);                 // scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n++         StorageLive(_7);                 // scope 0 at $DIR/inline_diverging.rs:+1:5: +1:22\n +         StorageLive(_3);                 // scope 1 at $DIR/inline_diverging.rs:27:9: 27:10\n +         StorageLive(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n +         _4 = &_2;                        // scope 1 at $DIR/inline_diverging.rs:27:13: 27:14\n-+         StorageLive(_5);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n++         StorageLive(_8);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n++         _8 = const ();                   // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n +         _3 = move (*_4)() -> [return: bb6, unwind: bb4]; // scope 4 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n +     }\n + \n +     bb1: {\n-+         StorageDead(_7);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n-+         StorageDead(_6);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n-+         StorageLive(_8);                 // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         _8 = move _3;                    // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         _1 = (move _8, move _9);         // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n-+         StorageDead(_8);                 // scope 3 at $DIR/inline_diverging.rs:29:10: 29:11\n++         StorageDead(_5);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n++         StorageLive(_6);                 // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n++         _6 = move _3;                    // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n++         _1 = (move _6, move _7);         // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n++         StorageDead(_6);                 // scope 3 at $DIR/inline_diverging.rs:29:10: 29:11\n +         StorageDead(_3);                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n +         drop(_2) -> bb2;                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n +     }\n@@ -71,12 +70,11 @@\n +     }\n + \n +     bb6: {\n-+         StorageDead(_5);                 // scope 1 at $DIR/inline_diverging.rs:27:15: 27:16\n++         StorageDead(_8);                 // scope 1 at $DIR/inline_diverging.rs:27:13: 27:16\n +         StorageDead(_4);                 // scope 1 at $DIR/inline_diverging.rs:27:15: 27:16\n-+         StorageLive(_6);                 // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n-+         _6 = &_2;                        // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n-+         StorageLive(_7);                 // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n-+         _9 = <fn() -> ! {sleep} as Fn<()>>::call(move _6, move _7) -> [return: bb1, unwind: bb3]; // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n++         StorageLive(_5);                 // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n++         _5 = &_2;                        // scope 2 at $DIR/inline_diverging.rs:28:13: 28:14\n++         _7 = <fn() -> ! {sleep} as Fn<()>>::call(move _5, const ()) -> [return: bb1, unwind: bb3]; // scope 2 at $DIR/inline_diverging.rs:28:13: 28:16\n +                                          // mir::Constant\n +                                          // + span: $DIR/inline_diverging.rs:28:13: 28:14\n +                                          // + literal: Const { ty: for<'a> extern \"rust-call\" fn(&'a fn() -> ! {sleep}, ()) -> <fn() -> ! {sleep} as FnOnce<()>>::Output {<fn() -> ! {sleep} as Fn<()>>::call}, val: Value(<ZST>) }"}, {"sha": "abe26bd8ce363a820e0ad2937e31801d9e4f89af", "filename": "tests/mir-opt/inline/inline_options.main.Inline.after.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_options.main.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Finline_options.main.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_options.main.Inline.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -21,35 +21,35 @@ fn main() -> () {\n     bb1: {\n         StorageDead(_1);                 // scope 0 at $DIR/inline_options.rs:+1:18: +1:19\n         StorageLive(_2);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n-        StorageLive(_3);                 // scope 1 at $DIR/inline_options.rs:16:23: 16:26\n-        _3 = g() -> bb2;                 // scope 1 at $DIR/inline_options.rs:16:23: 16:26\n+        StorageLive(_3);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n+        StorageLive(_4);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n+        StorageLive(_5);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n+        _3 = g() -> bb3;                 // scope 1 at $DIR/inline_options.rs:16:23: 16:26\n                                          // mir::Constant\n                                          // + span: $DIR/inline_options.rs:16:23: 16:24\n                                          // + literal: Const { ty: fn() {g}, val: Value(<ZST>) }\n     }\n \n     bb2: {\n-        StorageDead(_3);                 // scope 1 at $DIR/inline_options.rs:16:26: 16:27\n-        StorageLive(_4);                 // scope 1 at $DIR/inline_options.rs:16:28: 16:31\n-        _4 = g() -> bb3;                 // scope 1 at $DIR/inline_options.rs:16:28: 16:31\n-                                         // mir::Constant\n-                                         // + span: $DIR/inline_options.rs:16:28: 16:29\n-                                         // + literal: Const { ty: fn() {g}, val: Value(<ZST>) }\n+        StorageDead(_5);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n+        StorageDead(_4);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n+        StorageDead(_3);                 // scope 0 at $DIR/inline_options.rs:+2:5: +2:21\n+        StorageDead(_2);                 // scope 0 at $DIR/inline_options.rs:+2:21: +2:22\n+        _0 = const ();                   // scope 0 at $DIR/inline_options.rs:+0:11: +3:2\n+        return;                          // scope 0 at $DIR/inline_options.rs:+3:2: +3:2\n     }\n \n     bb3: {\n-        StorageDead(_4);                 // scope 1 at $DIR/inline_options.rs:16:31: 16:32\n-        StorageLive(_5);                 // scope 1 at $DIR/inline_options.rs:16:33: 16:36\n-        _5 = g() -> bb4;                 // scope 1 at $DIR/inline_options.rs:16:33: 16:36\n+        _4 = g() -> bb4;                 // scope 1 at $DIR/inline_options.rs:16:28: 16:31\n                                          // mir::Constant\n-                                         // + span: $DIR/inline_options.rs:16:33: 16:34\n+                                         // + span: $DIR/inline_options.rs:16:28: 16:29\n                                          // + literal: Const { ty: fn() {g}, val: Value(<ZST>) }\n     }\n \n     bb4: {\n-        StorageDead(_5);                 // scope 1 at $DIR/inline_options.rs:16:36: 16:37\n-        StorageDead(_2);                 // scope 0 at $DIR/inline_options.rs:+2:21: +2:22\n-        _0 = const ();                   // scope 0 at $DIR/inline_options.rs:+0:11: +3:2\n-        return;                          // scope 0 at $DIR/inline_options.rs:+3:2: +3:2\n+        _5 = g() -> bb2;                 // scope 1 at $DIR/inline_options.rs:16:33: 16:36\n+                                         // mir::Constant\n+                                         // + span: $DIR/inline_options.rs:16:33: 16:34\n+                                         // + literal: Const { ty: fn() {g}, val: Value(<ZST>) }\n     }\n }"}, {"sha": "a98c294cacbe9ec8106570cb564f2dd347eb78c1", "filename": "tests/mir-opt/inline/issue_76997_inline_scopes_parenting.main.Inline.after.mir", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -10,10 +10,9 @@ fn main() -> () {\n     scope 1 {\n         debug f => _1;                   // in scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:9: +1:10\n         scope 2 (inlined main::{closure#0}) { // at $DIR/issue_76997_inline_scopes_parenting.rs:6:5: 6:10\n-            debug x => _5;               // in scope 2 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:14: +1:15\n-            let _6: ();                  // in scope 2 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:23: +1:24\n+            debug x => const ();         // in scope 2 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:14: +1:15\n             scope 3 {\n-                debug y => _6;           // in scope 3 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:23: +1:24\n+                debug y => const ();     // in scope 3 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:23: +1:24\n             }\n         }\n     }\n@@ -36,8 +35,6 @@ fn main() -> () {\n         _3 = (move _4,);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         StorageLive(_5);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         _5 = move (_3.0: ());            // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n-        StorageLive(_6);                 // scope 2 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:23: +1:24\n-        StorageDead(_6);                 // scope 2 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:32: +1:33\n         StorageDead(_5);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         StorageDead(_4);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:9: +2:10\n         StorageDead(_3);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:9: +2:10"}, {"sha": "7031c3f3e6990835593b4719285d03d9f55038a9", "filename": "tests/mir-opt/intrinsic_asserts.generic.InstCombine.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fintrinsic_asserts.generic.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fintrinsic_asserts.generic.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fintrinsic_asserts.generic.InstCombine.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,33 +8,33 @@\n       let _3: ();                          // in scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:60\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:46\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:46\n           _1 = assert_inhabited::<T>() -> bb1; // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:46\n                                            // mir::Constant\n                                            // + span: $DIR/intrinsic_asserts.rs:25:5: 25:44\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn() {assert_inhabited::<T>}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          StorageDead(_1);                 // scope 0 at $DIR/intrinsic_asserts.rs:+1:46: +1:47\n-          StorageLive(_2);                 // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:47\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+1:46: +1:47\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:47\n           _2 = assert_zero_valid::<T>() -> bb2; // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:47\n                                            // mir::Constant\n                                            // + span: $DIR/intrinsic_asserts.rs:26:5: 26:45\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn() {assert_zero_valid::<T>}, val: Value(<ZST>) }\n       }\n   \n       bb2: {\n-          StorageDead(_2);                 // scope 0 at $DIR/intrinsic_asserts.rs:+2:47: +2:48\n-          StorageLive(_3);                 // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:60\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+2:47: +2:48\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:60\n           _3 = assert_mem_uninitialized_valid::<T>() -> bb3; // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:60\n                                            // mir::Constant\n                                            // + span: $DIR/intrinsic_asserts.rs:27:5: 27:58\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn() {assert_mem_uninitialized_valid::<T>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n-          StorageDead(_3);                 // scope 0 at $DIR/intrinsic_asserts.rs:+3:60: +3:61\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+3:60: +3:61\n           nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+0:21: +4:2\n           return;                          // scope 0 at $DIR/intrinsic_asserts.rs:+4:2: +4:2\n       }"}, {"sha": "4caa9971fef8076a6011f447ba9c3107f358215e", "filename": "tests/mir-opt/intrinsic_asserts.panics.InstCombine.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fintrinsic_asserts.panics.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fintrinsic_asserts.panics.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fintrinsic_asserts.panics.InstCombine.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,7 @@\n       let _3: ();                          // in scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:62\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:50\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:50\n -         _1 = assert_inhabited::<Never>() -> bb1; // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:50\n +         _1 = assert_inhabited::<Never>(); // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:50\n                                            // mir::Constant\n@@ -17,8 +17,8 @@\n       }\n   \n       bb1: {\n-          StorageDead(_1);                 // scope 0 at $DIR/intrinsic_asserts.rs:+1:50: +1:51\n-          StorageLive(_2);                 // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:49\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+1:50: +1:51\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:49\n -         _2 = assert_zero_valid::<&u8>() -> bb2; // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:49\n +         _2 = assert_zero_valid::<&u8>(); // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:49\n                                            // mir::Constant\n@@ -28,8 +28,8 @@\n       }\n   \n       bb2: {\n-          StorageDead(_2);                 // scope 0 at $DIR/intrinsic_asserts.rs:+2:49: +2:50\n-          StorageLive(_3);                 // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:62\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+2:49: +2:50\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:62\n -         _3 = assert_mem_uninitialized_valid::<&u8>() -> bb3; // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:62\n +         _3 = assert_mem_uninitialized_valid::<&u8>(); // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:62\n                                            // mir::Constant\n@@ -39,7 +39,7 @@\n       }\n   \n       bb3: {\n-          StorageDead(_3);                 // scope 0 at $DIR/intrinsic_asserts.rs:+3:62: +3:63\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+3:62: +3:63\n           nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+0:17: +4:2\n           return;                          // scope 0 at $DIR/intrinsic_asserts.rs:+4:2: +4:2\n       }"}, {"sha": "b0bec95736971b58fbf86ad907430aa71035d718", "filename": "tests/mir-opt/intrinsic_asserts.removable.InstCombine.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fintrinsic_asserts.removable.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fintrinsic_asserts.removable.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fintrinsic_asserts.removable.InstCombine.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -8,7 +8,7 @@\n       let _3: ();                          // in scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:61\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:47\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:47\n -         _1 = assert_inhabited::<()>() -> bb1; // scope 0 at $DIR/intrinsic_asserts.rs:+1:5: +1:47\n -                                          // mir::Constant\n -                                          // + span: $DIR/intrinsic_asserts.rs:7:5: 7:45\n@@ -17,8 +17,8 @@\n       }\n   \n       bb1: {\n-          StorageDead(_1);                 // scope 0 at $DIR/intrinsic_asserts.rs:+1:47: +1:48\n-          StorageLive(_2);                 // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:48\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+1:47: +1:48\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:48\n -         _2 = assert_zero_valid::<u8>() -> bb2; // scope 0 at $DIR/intrinsic_asserts.rs:+2:5: +2:48\n -                                          // mir::Constant\n -                                          // + span: $DIR/intrinsic_asserts.rs:8:5: 8:46\n@@ -27,8 +27,8 @@\n       }\n   \n       bb2: {\n-          StorageDead(_2);                 // scope 0 at $DIR/intrinsic_asserts.rs:+2:48: +2:49\n-          StorageLive(_3);                 // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:61\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+2:48: +2:49\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:61\n -         _3 = assert_mem_uninitialized_valid::<u8>() -> bb3; // scope 0 at $DIR/intrinsic_asserts.rs:+3:5: +3:61\n -                                          // mir::Constant\n -                                          // + span: $DIR/intrinsic_asserts.rs:9:5: 9:59\n@@ -37,7 +37,7 @@\n       }\n   \n       bb3: {\n-          StorageDead(_3);                 // scope 0 at $DIR/intrinsic_asserts.rs:+3:61: +3:62\n+          nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+3:61: +3:62\n           nop;                             // scope 0 at $DIR/intrinsic_asserts.rs:+0:20: +4:2\n           return;                          // scope 0 at $DIR/intrinsic_asserts.rs:+4:2: +4:2\n       }"}, {"sha": "fb0b3866e696baf062c0265ee1d5fb87a954bdf2", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -12,13 +12,14 @@\n       let mut _7: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n       let mut _8: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _9: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:33: +1:39\n-      let mut _10: (u32, bool);            // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      let mut _11: (u32, bool);            // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _10: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _11: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _12: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:14:5: 14:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n-          let mut _12: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n-          let mut _13: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n-          let mut _14: (u32, bool);        // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n+          let mut _14: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n+          let mut _15: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n           scope 2 {\n               debug out => _4;             // in scope 2 at $DIR/issue_101973.rs:6:9: 6:16\n           }\n@@ -32,43 +33,46 @@\n           StorageLive(_2);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageLive(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:58\n           StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n-          StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n-          StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          _14 = CheckedShr(_1, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          assert(!move (_14.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 0_i32) -> bb3; // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n+          StorageLive(_15);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _15 = Shr(_1, const 0_i32);      // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _14 = BitAnd(move _15, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n+          StorageDead(_15);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          _4 = BitOr(const 0_u32, move _14); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n+          StorageDead(_14);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+          StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n+          StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _10 = BitAnd(const 8_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _11 = Ne(move _10, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         assert(!move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _10 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _11 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         assert(!const false, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb1: {\n-          _8 = move (_10.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+          _8 = Shr(_1, const 8_i32);       // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageDead(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:51: +1:52\n-          _11 = CheckedShl(_7, const 1_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-          assert(!move (_11.1: bool), \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _12 = BitAnd(const 1_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _13 = Ne(move _12, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         assert(!move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _12 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _13 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         assert(!const false, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       }\n   \n       bb2: {\n-          _6 = move (_11.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+          _6 = Shl(move _7, const 1_i32);  // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageDead(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:56: +1:57\n-          _3 = rotate_right::<u32>(_4, _6) -> bb4; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _3 = rotate_right::<u32>(_4, _6) -> bb3; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn(u32, u32) -> u32 {rotate_right::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n-          _13 = move (_14.0: u32);         // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          _12 = BitAnd(move _13, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n-          StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n-          StorageDead(_12);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-          StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n-          StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-          _10 = CheckedShr(_1, const 8_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-          assert(!move (_10.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      }\n-  \n-      bb4: {\n           StorageDead(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           StorageDead(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           _2 = move _3 as i32 (IntToInt);  // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65"}, {"sha": "abb89b91dd36d71f29cc4aed88c82a025eb45f93", "filename": "tests/mir-opt/issue_76432.test.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fissue_76432.test.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fissue_76432.test.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_76432.test.SimplifyComparisonIntegral.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -42,7 +42,6 @@\n       }\n   \n       bb1: {\n-          StorageLive(_15);                // scope 1 at $SRC_DIR/core/src/panic.rs:LL:COL\n           _15 = core::panicking::panic(const \"internal error: entered unreachable code\"); // scope 1 at $SRC_DIR/core/src/panic.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/panic.rs:LL:COL"}, {"sha": "6e28fb61b6bd731551cd7d72edd76a2dc8ec329f", "filename": "tests/mir-opt/issues/issue_59352.num_to_digit.PreCodegen.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -66,7 +66,6 @@ fn num_to_digit(_1: char) -> u32 {\n     }\n \n     bb6: {\n-        StorageLive(_8);                 // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n         _8 = core::panicking::panic(const \"called `Option::unwrap()` on a `None` value\"); // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/option.rs:LL:COL"}, {"sha": "27fceeedf6e2c894054bd73de474d3721c2b6ec7", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,27 @@\n+- // MIR for `read_via_copy_primitive` before LowerIntrinsics\n++ // MIR for `read_via_copy_primitive` after LowerIntrinsics\n+  \n+  fn read_via_copy_primitive(_1: &i32) -> i32 {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:32: +0:33\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:44: +0:47\n+      let mut _2: *const i32;              // in scope 0 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+          _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+-         _0 = read_via_copy::<i32>(move _2) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:85:14: 85:45\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32) -> i32 {read_via_copy::<i32>}, val: Value(<ZST>) }\n++         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+      }\n+  \n+      bb1: {\n+          StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:47: +1:48\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "610c67d2fecd67b45a5194059756bb2cb9594777", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,21 @@\n+- // MIR for `read_via_copy_uninhabited` before LowerIntrinsics\n++ // MIR for `read_via_copy_uninhabited` after LowerIntrinsics\n+  \n+  fn read_via_copy_uninhabited(_1: &Never) -> Never {\n+      debug r => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:34: +0:35\n+      let mut _0: Never;                   // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:48: +0:53\n+      let mut _2: *const Never;            // in scope 0 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+      scope 1 {\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+          _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n+-         _0 = read_via_copy::<Never>(move _2); // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:90:14: 90:45\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n++         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n+      }\n+  }\n+  "}, {"sha": "a0a1df4e5ca86c5f203662727f3cd43de8db4b54", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -79,3 +79,15 @@ pub fn with_overflow(a: i32, b: i32) {\n     let _y = core::intrinsics::sub_with_overflow(a, b);\n     let _z = core::intrinsics::mul_with_overflow(a, b);\n }\n+\n+// EMIT_MIR lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff\n+pub fn read_via_copy_primitive(r: &i32) -> i32 {\n+    unsafe { core::intrinsics::read_via_copy(r) }\n+}\n+\n+// EMIT_MIR lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff\n+pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n+    unsafe { core::intrinsics::read_via_copy(r) }\n+}\n+\n+pub enum Never {}"}, {"sha": "adfc6b2731c1a545149cfe2683dd7cfcface1f50", "filename": "tests/mir-opt/lower_intrinsics_e2e.f_u64.PreCodegen.after.mir", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics_e2e.f_u64.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics_e2e.f_u64.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics_e2e.f_u64.PreCodegen.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -12,15 +12,13 @@ fn f_u64() -> () {\n \n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:5: +1:21\n-        StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:9: 23:21\n         _2 = f_non_zst::<u64>(const 0_u64) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:9: 23:21\n                                          // mir::Constant\n                                          // + span: $DIR/lower_intrinsics_e2e.rs:23:9: 23:18\n                                          // + literal: Const { ty: fn(u64) {f_non_zst::<u64>}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:23:21: 23:22\n         StorageDead(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:5: +1:21\n         return;                          // scope 0 at $DIR/lower_intrinsics_e2e.rs:+2:2: +2:2\n     }"}, {"sha": "302ca09aac4b2efeb5c7a659429124a76b44a8b9", "filename": "tests/mir-opt/lower_intrinsics_e2e.f_unit.PreCodegen.after.mir", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics_e2e.f_unit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Flower_intrinsics_e2e.f_unit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics_e2e.f_unit.PreCodegen.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,26 +2,21 @@\n \n fn f_unit() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics_e2e.rs:+0:17: +0:17\n-    let mut _1: ();                      // in scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:16: +1:18\n     scope 1 (inlined f_dispatch::<()>) { // at $DIR/lower_intrinsics_e2e.rs:9:5: 9:19\n-        debug t => _1;                   // in scope 1 at $DIR/lower_intrinsics_e2e.rs:19:22: 19:23\n-        let _2: ();                      // in scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n+        debug t => const ();             // in scope 1 at $DIR/lower_intrinsics_e2e.rs:19:22: 19:23\n+        let _1: ();                      // in scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n         scope 2 (inlined std::mem::size_of::<()>) { // at $DIR/lower_intrinsics_e2e.rs:20:8: 20:32\n         }\n     }\n \n     bb0: {\n-        StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:16: +1:18\n-        StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n-        _2 = f_zst::<()>(move _1) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n+        _1 = f_zst::<()>(const ()) -> bb1; // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:9: 21:17\n                                          // mir::Constant\n                                          // + span: $DIR/lower_intrinsics_e2e.rs:21:9: 21:14\n                                          // + literal: Const { ty: fn(()) {f_zst::<()>}, val: Value(<ZST>) }\n     }\n \n     bb1: {\n-        StorageDead(_2);                 // scope 1 at $DIR/lower_intrinsics_e2e.rs:21:17: 21:18\n-        StorageDead(_1);                 // scope 0 at $DIR/lower_intrinsics_e2e.rs:+1:18: +1:19\n         return;                          // scope 0 at $DIR/lower_intrinsics_e2e.rs:+2:2: +2:2\n     }\n }"}, {"sha": "7713649c5b96b07ec58bbbc1f82aaf519cd9f1de", "filename": "tests/mir-opt/remove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_unneeded_drops.cannot_opt_generic.RemoveUnneededDrops.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -11,7 +11,7 @@\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n+          nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n           StorageLive(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n           _3 = move _1;                    // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n           drop(_3) -> [return: bb2, unwind: bb1]; // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n@@ -23,7 +23,7 @@\n   \n       bb2: {\n           StorageDead(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:11: +1:12\n-          StorageDead(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n+          nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n           nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+0:32: +2:2\n           return;                          // scope 0 at $DIR/remove_unneeded_drops.rs:+2:2: +2:2\n       }"}, {"sha": "533db4051ef1fbcc64084e523ba255846fad31a7", "filename": "tests/mir-opt/remove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_unneeded_drops.dont_opt.RemoveUnneededDrops.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -11,7 +11,7 @@\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n+          nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n           StorageLive(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n           _3 = move _1;                    // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n           drop(_3) -> [return: bb2, unwind: bb1]; // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n@@ -23,7 +23,7 @@\n   \n       bb2: {\n           StorageDead(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:11: +1:12\n-          StorageDead(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n+          nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n           nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+0:27: +2:2\n           return;                          // scope 0 at $DIR/remove_unneeded_drops.rs:+2:2: +2:2\n       }"}, {"sha": "04a2d54e9a19baaca5467b7543a5f3c63ccdaff2", "filename": "tests/mir-opt/remove_unneeded_drops.opt.RemoveUnneededDrops.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.opt.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.opt.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_unneeded_drops.opt.RemoveUnneededDrops.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -11,15 +11,15 @@\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n+-         nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n           StorageLive(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n           _3 = _1;                         // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n -         drop(_3) -> bb1;                 // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n -     }\n - \n -     bb1: {\n           StorageDead(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:11: +1:12\n-          StorageDead(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n+-         nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n -         nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+0:17: +2:2\n           return;                          // scope 0 at $DIR/remove_unneeded_drops.rs:+2:2: +2:2\n       }"}, {"sha": "782d0c6c5f267e6be877be922e0d6eeb2a890e1b", "filename": "tests/mir-opt/remove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_unneeded_drops.opt_generic_copy.RemoveUnneededDrops.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -11,15 +11,15 @@\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n+-         nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:5: +1:12\n           StorageLive(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n           _3 = _1;                         // scope 0 at $DIR/remove_unneeded_drops.rs:+1:10: +1:11\n -         drop(_3) -> bb1;                 // scope 1 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n -     }\n - \n -     bb1: {\n           StorageDead(_3);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:11: +1:12\n-          StorageDead(_2);                 // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n+-         nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+1:12: +1:13\n -         nop;                             // scope 0 at $DIR/remove_unneeded_drops.rs:+0:36: +2:2\n           return;                          // scope 0 at $DIR/remove_unneeded_drops.rs:+2:2: +2:2\n       }"}, {"sha": "7ac9ef3d49013b631118e7f6d9412e863f02b065", "filename": "tests/mir-opt/remove_zsts.get_union.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,12 +2,9 @@\n \n fn get_union() -> Foo {\n     let mut _0: Foo;                     // return place in scope 0 at $DIR/remove_zsts.rs:+0:19: +0:22\n-    let mut _1: ();                      // in scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n \n     bb0: {\n-        StorageLive(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n-        _0 = Foo { x: move _1 };         // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n-        StorageDead(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n+        _0 = Foo { x: const () };        // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n         return;                          // scope 0 at $DIR/remove_zsts.rs:+2:2: +2:2\n     }\n }"}, {"sha": "edd86ef0aa97a5bfab4484492e8553eecd4f1edd", "filename": "tests/mir-opt/remove_zsts.get_union.RemoveZsts.diff", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -6,11 +6,14 @@\n       let mut _1: ();                      // in scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+-         StorageLive(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n -         _1 = ();                         // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+-         _0 = Foo { x: move _1 };         // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+-         StorageDead(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n +         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n-          _0 = Foo { x: move _1 };         // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n-          StorageDead(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n++         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n++         _0 = Foo { x: const () };        // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n++         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n           return;                          // scope 0 at $DIR/remove_zsts.rs:+2:2: +2:2\n       }\n   }"}, {"sha": "cae89fb177a7c2d63e02bcc5e85b9c9fda0a9015", "filename": "tests/mir-opt/simple_option_map_e2e.ezmap.PreCodegen.after.mir", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -3,47 +3,40 @@\n fn ezmap(_1: Option<i32>) -> Option<i32> {\n     debug x => _1;                       // in scope 0 at $DIR/simple_option_map_e2e.rs:+0:14: +0:15\n     let mut _0: std::option::Option<i32>; // return place in scope 0 at $DIR/simple_option_map_e2e.rs:+0:33: +0:44\n-    let mut _2: [closure@$DIR/simple_option_map_e2e.rs:14:12: 14:15]; // in scope 0 at $DIR/simple_option_map_e2e.rs:+1:12: +1:21\n     scope 1 (inlined map::<i32, i32, [closure@$DIR/simple_option_map_e2e.rs:14:12: 14:15]>) { // at $DIR/simple_option_map_e2e.rs:14:5: 14:22\n         debug slf => _1;                 // in scope 1 at $DIR/simple_option_map_e2e.rs:2:17: 2:20\n-        debug f => _2;                   // in scope 1 at $DIR/simple_option_map_e2e.rs:2:33: 2:34\n-        let mut _3: isize;               // in scope 1 at $DIR/simple_option_map_e2e.rs:7:9: 7:16\n-        let _4: i32;                     // in scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n-        let mut _5: i32;                 // in scope 1 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n+        debug f => const ZeroSized: [closure@$DIR/simple_option_map_e2e.rs:14:12: 14:15]; // in scope 1 at $DIR/simple_option_map_e2e.rs:2:33: 2:34\n+        let mut _2: isize;               // in scope 1 at $DIR/simple_option_map_e2e.rs:7:9: 7:16\n+        let _3: i32;                     // in scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n+        let mut _4: i32;                 // in scope 1 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n         scope 2 {\n-            debug x => _4;               // in scope 2 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n+            debug x => _3;               // in scope 2 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n             scope 3 (inlined ezmap::{closure#0}) { // at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n-                debug n => _4;           // in scope 3 at $DIR/simple_option_map_e2e.rs:+1:13: +1:14\n+                debug n => _3;           // in scope 3 at $DIR/simple_option_map_e2e.rs:+1:13: +1:14\n             }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/simple_option_map_e2e.rs:+1:12: +1:21\n-        _3 = discriminant(_1);           // scope 1 at $DIR/simple_option_map_e2e.rs:6:11: 6:14\n-        switchInt(move _3) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 1 at $DIR/simple_option_map_e2e.rs:6:5: 6:14\n+        _2 = discriminant(_1);           // scope 1 at $DIR/simple_option_map_e2e.rs:6:11: 6:14\n+        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 1 at $DIR/simple_option_map_e2e.rs:6:5: 6:14\n     }\n \n     bb1: {\n         _0 = Option::<i32>::None;        // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n-        goto -> bb4;                     // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n+        return;                          // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n     }\n \n     bb2: {\n         unreachable;                     // scope 1 at $DIR/simple_option_map_e2e.rs:6:11: 6:14\n     }\n \n     bb3: {\n-        _4 = ((_1 as Some).0: i32);      // scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n-        StorageLive(_5);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n-        _5 = Add(_4, const 1_i32);       // scope 3 at $DIR/simple_option_map_e2e.rs:+1:16: +1:21\n-        _0 = Option::<i32>::Some(move _5); // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30\n-        StorageDead(_5);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:29: 7:30\n-        goto -> bb4;                     // scope 1 at $DIR/simple_option_map_e2e.rs:10:1: 10:2\n-    }\n-\n-    bb4: {\n-        StorageDead(_2);                 // scope 0 at $DIR/simple_option_map_e2e.rs:+1:21: +1:22\n-        return;                          // scope 0 at $DIR/simple_option_map_e2e.rs:+2:2: +2:2\n+        _3 = ((_1 as Some).0: i32);      // scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n+        StorageLive(_4);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n+        _4 = Add(_3, const 1_i32);       // scope 3 at $DIR/simple_option_map_e2e.rs:+1:16: +1:21\n+        _0 = Option::<i32>::Some(move _4); // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30\n+        StorageDead(_4);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:29: 7:30\n+        return;                          // scope 1 at $DIR/simple_option_map_e2e.rs:10:1: 10:2\n     }\n }"}, {"sha": "ac79e72701344366c3f82bee1054e23ebe664f0c", "filename": "tests/mir-opt/simplify_if.main.SimplifyConstCondition-after-const-prop.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -14,15 +14,13 @@\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 0 at $DIR/simplify_if.rs:+2:9: +2:15\n           _2 = noop() -> bb2;              // scope 0 at $DIR/simplify_if.rs:+2:9: +2:15\n                                            // mir::Constant\n                                            // + span: $DIR/simplify_if.rs:7:9: 7:13\n                                            // + literal: Const { ty: fn() {noop}, val: Value(<ZST>) }\n       }\n   \n       bb2: {\n-          StorageDead(_2);                 // scope 0 at $DIR/simplify_if.rs:+2:15: +2:16\n           goto -> bb4;                     // scope 0 at $DIR/simplify_if.rs:+1:5: +3:6\n       }\n   "}, {"sha": "4020a433d6254eed3bd15b5c642669293b80ce51", "filename": "tests/pretty/issue-4264.pp", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpretty%2Fissue-4264.pp?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -32,13 +32,11 @@\n         ({\n                 let res =\n                     ((::alloc::fmt::format as\n-                            for<'a> fn(Arguments<'a>) -> String {format})(((<#[lang = \"format_arguments\"]>::new_v1\n+                            for<'a> fn(Arguments<'a>) -> String {format})(((<#[lang = \"format_arguments\"]>::new_const\n                                 as\n-                                fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> Arguments<'_> {Arguments::<'_>::new_v1})((&([(\"test\"\n-                                            as &str)] as [&str; 1]) as &[&str; 1]),\n-                            (&([] as [core::fmt::ArgumentV1<'_>; 0]) as\n-                                &[core::fmt::ArgumentV1<'_>; 0])) as Arguments<'_>)) as\n-                        String);\n+                                fn(&[&'static str]) -> Arguments<'_> {Arguments::<'_>::new_const})((&([(\"test\"\n+                                            as &str)] as [&str; 1]) as &[&str; 1])) as Arguments<'_>))\n+                        as String);\n                 (res as String)\n             } as String);\n     } as ())"}, {"sha": "6bf421a21356072eda42297d227e7de6bf7492f8", "filename": "tests/rustdoc-js-std/option-type-signatures.js", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Foption-type-signatures.js?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,7 +1,18 @@\n-const QUERY = 'option, fnonce -> option';\n+const QUERY = [\n+    'option, fnonce -> option',\n+    'option -> default',\n+];\n \n-const EXPECTED = {\n-    'others': [\n-        { 'path': 'std::option::Option', 'name': 'map' },\n-    ],\n-};\n+const EXPECTED = [\n+    {\n+        'others': [\n+            { 'path': 'std::option::Option', 'name': 'map' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'std::option::Option', 'name': 'unwrap_or_default' },\n+            { 'path': 'std::option::Option', 'name': 'get_or_insert_default' },\n+        ],\n+    },\n+];"}, {"sha": "86254a80e20f3623ac14e93bbba366cc4342bbde", "filename": "tests/rustdoc-js/where-clause.js", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-js%2Fwhere-clause.js", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-js%2Fwhere-clause.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fwhere-clause.js?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,4 @@\n-const QUERY = ['trait<nested>', '-> trait<nested>', 't1, t2'];\n+const QUERY = ['trait<nested>', '-> trait<nested>', 't1, t2', '-> shazam', 'drizzel -> shazam'];\n \n const EXPECTED = [\n     {\n@@ -16,4 +16,15 @@ const EXPECTED = [\n             { 'path': 'where_clause', 'name': 'presto' },\n         ],\n     },\n+    {\n+        'others': [\n+            { 'path': 'where_clause', 'name': 'bippety' },\n+            { 'path': 'where_clause::Drizzel', 'name': 'boppety' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'where_clause::Drizzel', 'name': 'boppety' },\n+        ],\n+    },\n ];"}, {"sha": "56c01019fb69fb70fbcb2ff8b1483508da01094c", "filename": "tests/rustdoc-js/where-clause.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-js%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-js%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fwhere-clause.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -14,3 +14,17 @@ pub trait T2<'a, T> {\n }\n \n pub fn presto<A, B>(_: A, _: B) where A: T1, B: for <'b> T2<'b, Nested> {}\n+\n+pub trait Shazam {}\n+\n+pub fn bippety<X>() -> &'static X where X: Shazam {\n+    panic!()\n+}\n+\n+pub struct Drizzel<T>(T);\n+\n+impl<T> Drizzel<T> {\n+    pub fn boppety(&self) -> &T where T: Shazam {\n+        panic!();\n+    }\n+}"}, {"sha": "5ad38e4fd9821ab1e7fb34722c2c1694bb3846b7", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -44,6 +44,7 @@\n     -Z             export-executable-symbols=val -- export symbols from executables, as if they were dynamic libraries\n     -Z                 extra-const-ub-checks=val -- turns on more checks to detect const UB, which can be slow (default: no)\n     -Z                           fewer-names=val -- reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) (default: no)\n+    -Z                   flatten-format-args=val -- flatten nested format_args!() and literals into a simplified format_args!() call (default: no)\n     -Z            force-unstable-if-unmarked=val -- force all crates to be `rustc_private` unstable (default: no)\n     -Z                                  fuel=val -- set the optimization fuel quota for a crate\n     -Z                     function-sections=val -- whether each function should go in its own section"}, {"sha": "bc1965aac5594a167fd6fb49381fa2cddc7fd38a", "filename": "tests/rustdoc/intra-doc/prim-methods.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc%2Fintra-doc%2Fprim-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Frustdoc%2Fintra-doc%2Fprim-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Fprim-methods.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -2,6 +2,8 @@\n \n // @has prim_methods/index.html\n // @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html\"]/@title' 'primitive char'\n // @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html#method.len_utf8\"]' 'char::len_utf8'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"{{channel}}/std/primitive.char.html#method.len_utf8\"]/@title' 'method char::len_utf8'\n \n //! A [`char`] and its [`char::len_utf8`]."}, {"sha": "89ca4039bce9120da804cab91ee7ca3b96aca955", "filename": "tests/ui/async-await/in-trait/async-associated-types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(impl_trait_projections)]"}, {"sha": "cdecb02bfad1e53d773eeb13fc3b4eefe4baa2da", "filename": "tests/ui/async-await/in-trait/async-associated-types2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types2.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(type_alias_impl_trait)]"}, {"sha": "b5ace9ada4f806317dc92930f80caea86b4bd773", "filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed-in-trait.current.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,11 +1,11 @@\n error[E0053]: method `foo` has an incompatible type for trait\n-  --> $DIR/async-example-desugared-boxed-in-trait.rs:15:28\n+  --> $DIR/async-example-desugared-boxed-in-trait.rs:17:28\n    |\n LL |     async fn foo(&self) -> i32 {\n    |                            ^^^ expected `Pin<Box<dyn Future<Output = i32>>>`, found future\n    |\n note: type in trait\n-  --> $DIR/async-example-desugared-boxed-in-trait.rs:11:22\n+  --> $DIR/async-example-desugared-boxed-in-trait.rs:13:22\n    |\n LL |     fn foo(&self) -> Pin<Box<dyn Future<Output = i32> + '_>>;\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed-in-trait.stderr"}, {"sha": "b5ace9ada4f806317dc92930f80caea86b4bd773", "filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed-in-trait.next.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,17 @@\n+error[E0053]: method `foo` has an incompatible type for trait\n+  --> $DIR/async-example-desugared-boxed-in-trait.rs:17:28\n+   |\n+LL |     async fn foo(&self) -> i32 {\n+   |                            ^^^ expected `Pin<Box<dyn Future<Output = i32>>>`, found future\n+   |\n+note: type in trait\n+  --> $DIR/async-example-desugared-boxed-in-trait.rs:13:22\n+   |\n+LL |     fn foo(&self) -> Pin<Box<dyn Future<Output = i32> + '_>>;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature `fn(&i32) -> Pin<Box<dyn Future<Output = i32>>>`\n+              found signature `fn(&i32) -> impl Future<Output = i32>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "7b53379b24b784cd49d90eb2ee9f76038637a7ac", "filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed-in-trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed-in-trait.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "6c0b5859186b5d096037e84948fcf2f3c4d8fbbe", "filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error: method `foo` should be async because the method from the trait is async\n-  --> $DIR/async-example-desugared-boxed.rs:15:5\n+  --> $DIR/async-example-desugared-boxed.rs:17:5\n    |\n LL |     async fn foo(&self) -> i32;\n    |     --------------------------- required because the trait method is async", "previous_filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed.stderr"}, {"sha": "6c0b5859186b5d096037e84948fcf2f3c4d8fbbe", "filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed.next.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,11 @@\n+error: method `foo` should be async because the method from the trait is async\n+  --> $DIR/async-example-desugared-boxed.rs:17:5\n+   |\n+LL |     async fn foo(&self) -> i32;\n+   |     --------------------------- required because the trait method is async\n+...\n+LL |     fn foo(&self) -> Pin<Box<dyn Future<Output = i32> + '_>> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "916488ffafaf45a3d9c30fd9bfd3b05b3f055e54", "filename": "tests/ui/async-await/in-trait/async-example-desugared-boxed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-boxed.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "edac0b374a3259ade7e9ae67f5e47e940ffbd241", "filename": "tests/ui/async-await/in-trait/async-example-desugared-extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-extra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-extra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-extra.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "934f7643dd1c9c43fe077cc843724dbb5dacd11d", "filename": "tests/ui/async-await/in-trait/async-example-desugared-in-trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-in-trait.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "0d2551ab84f959063191d25a9fff68ba13d27a08", "filename": "tests/ui/async-await/in-trait/async-example-desugared-manual.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error: method `foo` should be async because the method from the trait is async\n-  --> $DIR/async-example-desugared-manual.rs:23:5\n+  --> $DIR/async-example-desugared-manual.rs:25:5\n    |\n LL |     async fn foo(&self) -> i32;\n    |     --------------------------- required because the trait method is async", "previous_filename": "tests/ui/async-await/in-trait/async-example-desugared-manual.stderr"}, {"sha": "0d2551ab84f959063191d25a9fff68ba13d27a08", "filename": "tests/ui/async-await/in-trait/async-example-desugared-manual.next.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,11 @@\n+error: method `foo` should be async because the method from the trait is async\n+  --> $DIR/async-example-desugared-manual.rs:25:5\n+   |\n+LL |     async fn foo(&self) -> i32;\n+   |     --------------------------- required because the trait method is async\n+...\n+LL |     fn foo(&self) -> MyFuture {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4883828d32fef979507020e6b9313910e5839e3f", "filename": "tests/ui/async-await/in-trait/async-example-desugared-manual.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared-manual.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "214171b2e2cba01403af4c80f75c4e6418e7b646", "filename": "tests/ui/async-await/in-trait/async-example-desugared.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-example-desugared.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "67b491f19d2694227a9562d9d6f9085657dd779a", "filename": "tests/ui/async-await/in-trait/async-recursive-generic.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error[E0733]: recursion in an `async fn` requires boxing\n-  --> $DIR/async-recursive-generic.rs:11:48\n+  --> $DIR/async-recursive-generic.rs:13:48\n    |\n LL |     async fn foo_recursive(&self, n: usize) -> T {\n    |                                                ^ recursive `async fn`", "previous_filename": "tests/ui/async-await/in-trait/async-recursive-generic.stderr"}, {"sha": "67b491f19d2694227a9562d9d6f9085657dd779a", "filename": "tests/ui/async-await/in-trait/async-recursive-generic.next.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,12 @@\n+error[E0733]: recursion in an `async fn` requires boxing\n+  --> $DIR/async-recursive-generic.rs:13:48\n+   |\n+LL |     async fn foo_recursive(&self, n: usize) -> T {\n+   |                                                ^ recursive `async fn`\n+   |\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0733`."}, {"sha": "64c6ba15c0cf0d9f528e89065e99ebc93ce86e27", "filename": "tests/ui/async-await/in-trait/async-recursive-generic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive-generic.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "85af27e3746536f686dc9f521b8d35138c6530c0", "filename": "tests/ui/async-await/in-trait/async-recursive.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error[E0733]: recursion in an `async fn` requires boxing\n-  --> $DIR/async-recursive.rs:11:48\n+  --> $DIR/async-recursive.rs:13:48\n    |\n LL |     async fn foo_recursive(&self, n: usize) -> i32 {\n    |                                                ^^^ recursive `async fn`", "previous_filename": "tests/ui/async-await/in-trait/async-recursive.stderr"}, {"sha": "85af27e3746536f686dc9f521b8d35138c6530c0", "filename": "tests/ui/async-await/in-trait/async-recursive.next.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,12 @@\n+error[E0733]: recursion in an `async fn` requires boxing\n+  --> $DIR/async-recursive.rs:13:48\n+   |\n+LL |     async fn foo_recursive(&self, n: usize) -> i32 {\n+   |                                                ^^^ recursive `async fn`\n+   |\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n+   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0733`."}, {"sha": "d928909e3ae5bc7f25b2a84203a8905b56cbf3f4", "filename": "tests/ui/async-await/in-trait/async-recursive.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fasync-recursive.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "5a05b080c3e57590d587d7ac00469d592f4b45d6", "filename": "tests/ui/async-await/in-trait/bad-signatures.current.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,11 +1,11 @@\n error: expected identifier, found keyword `self`\n-  --> $DIR/bad-signatures.rs:7:23\n+  --> $DIR/bad-signatures.rs:9:23\n    |\n LL |     async fn bar(&abc self);\n    |                       ^^^^ expected identifier, found keyword\n \n error: expected one of `:`, `@`, or `|`, found keyword `self`\n-  --> $DIR/bad-signatures.rs:7:23\n+  --> $DIR/bad-signatures.rs:9:23\n    |\n LL |     async fn bar(&abc self);\n    |                  -----^^^^\n@@ -14,7 +14,7 @@ LL |     async fn bar(&abc self);\n    |                  help: declare the type after the parameter binding: `<identifier>: <type>`\n \n warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/bad-signatures.rs:3:12\n+  --> $DIR/bad-signatures.rs:5:12\n    |\n LL | #![feature(async_fn_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^", "previous_filename": "tests/ui/async-await/in-trait/bad-signatures.stderr"}, {"sha": "5a05b080c3e57590d587d7ac00469d592f4b45d6", "filename": "tests/ui/async-await/in-trait/bad-signatures.next.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,26 @@\n+error: expected identifier, found keyword `self`\n+  --> $DIR/bad-signatures.rs:9:23\n+   |\n+LL |     async fn bar(&abc self);\n+   |                       ^^^^ expected identifier, found keyword\n+\n+error: expected one of `:`, `@`, or `|`, found keyword `self`\n+  --> $DIR/bad-signatures.rs:9:23\n+   |\n+LL |     async fn bar(&abc self);\n+   |                  -----^^^^\n+   |                  |    |\n+   |                  |    expected one of `:`, `@`, or `|`\n+   |                  help: declare the type after the parameter binding: `<identifier>: <type>`\n+\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/bad-signatures.rs:5:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+"}, {"sha": "e0093be8cb33fdb3a44d7b75c4115f359f48982e", "filename": "tests/ui/async-await/in-trait/bad-signatures.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fbad-signatures.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n //~^ WARN the feature `async_fn_in_trait` is incomplete"}, {"sha": "30843473defc77dac6578d54a4b12459d35ac461", "filename": "tests/ui/async-await/in-trait/early-bound-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fearly-bound-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fearly-bound-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fearly-bound-1.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "1c5a68c2a5adfb6be7e82c48e0c4604629627e53", "filename": "tests/ui/async-await/in-trait/early-bound-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fearly-bound-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fearly-bound-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fearly-bound-2.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "1a7495149899a4b1df38de5e4cdd1e7793e60462", "filename": "tests/ui/async-await/in-trait/fn-not-async-err2.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `impl` method return types\n-  --> $DIR/fn-not-async-err2.rs:13:22\n+  --> $DIR/fn-not-async-err2.rs:15:22\n    |\n LL |     fn foo(&self) -> impl Future<Output = i32> {\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "tests/ui/async-await/in-trait/fn-not-async-err2.stderr"}, {"sha": "1a7495149899a4b1df38de5e4cdd1e7793e60462", "filename": "tests/ui/async-await/in-trait/fn-not-async-err2.next.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,12 @@\n+error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in `impl` method return types\n+  --> $DIR/fn-not-async-err2.rs:15:22\n+   |\n+LL |     fn foo(&self) -> impl Future<Output = i32> {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = help: add `#![feature(return_position_impl_trait_in_trait)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0562`."}, {"sha": "5fdb7296aaf97d2133ace7c2f033dc6b96e8ca34", "filename": "tests/ui/async-await/in-trait/fn-not-async-err2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Ffn-not-async-err2.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "45ada1d84c320cb574d1c3f81dac0b1377b5322a", "filename": "tests/ui/async-await/in-trait/implied-bounds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fimplied-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fimplied-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fimplied-bounds.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "ced30b7e4e4b99866ff146301ff57365bbec0e80", "filename": "tests/ui/async-await/in-trait/issue-102138.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102138.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102138.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102138.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "f3fdfa3459aeaf3949b3bde0385618c66a66205d", "filename": "tests/ui/async-await/in-trait/issue-102219.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102219.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102219.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102219.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,6 +1,8 @@\n // compile-flags:--crate-type=lib\n // edition:2021\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "90e049a99606f69d20f6256d2d47381d2f34184a", "filename": "tests/ui/async-await/in-trait/object-safety.current.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/object-safety.rs:3:12\n+  --> $DIR/object-safety.rs:5:12\n    |\n LL | #![feature(async_fn_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^\n@@ -8,13 +8,13 @@ LL | #![feature(async_fn_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/object-safety.rs:11:12\n+  --> $DIR/object-safety.rs:13:12\n    |\n LL |     let x: &dyn Foo = todo!();\n    |            ^^^^^^^^ `Foo` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/object-safety.rs:7:14\n+  --> $DIR/object-safety.rs:9:14\n    |\n LL | trait Foo {\n    |       --- this trait cannot be made into an object...", "previous_filename": "tests/ui/async-await/in-trait/object-safety.stderr"}, {"sha": "90e049a99606f69d20f6256d2d47381d2f34184a", "filename": "tests/ui/async-await/in-trait/object-safety.next.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/object-safety.rs:5:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety.rs:13:12\n+   |\n+LL |     let x: &dyn Foo = todo!();\n+   |            ^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety.rs:9:14\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     async fn foo(&self);\n+   |              ^^^ ...because method `foo` is `async`\n+   = help: consider moving `foo` to another trait\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "f67286a20a24404be9d829f5925dfba5ae85fb2b", "filename": "tests/ui/async-await/in-trait/object-safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fobject-safety.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n //~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes"}, {"sha": "f032ea779dd489094ba84c61f0887b6aa8e993bc", "filename": "tests/ui/borrowck/issue-64453.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fborrowck%2Fissue-64453.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fborrowck%2Fissue-64453.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-64453.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,4 @@\n-error: `Arguments::<'a>::new_v1` is not yet stable as a const fn\n+error: `Arguments::<'a>::new_const` is not yet stable as a const fn\n   --> $DIR/issue-64453.rs:4:31\n    |\n LL | static settings_dir: String = format!(\"\");"}, {"sha": "1ea32ed2c4fac33d8ba2ce6d3809953f473c49c8", "filename": "tests/ui/codegen/mono-impossible.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fcodegen%2Fmono-impossible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fcodegen%2Fmono-impossible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcodegen%2Fmono-impossible.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Clink-dead-code=on --crate-type=lib\n+// build-pass\n+\n+// Make sure that we don't monomorphize the impossible method `<() as Visit>::visit`,\n+// which does not hold under a reveal-all param env.\n+\n+pub trait Visit {\n+    fn visit() {}\n+}\n+\n+pub trait Array<'a> {}\n+\n+impl Visit for () where (): for<'a> Array<'a> {}"}, {"sha": "123ce71727f67c0dd4641a046b73472abedb8376", "filename": "tests/ui/conditional-compilation/cfg-attr-multi-true.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconditional-compilation%2Fcfg-attr-multi-true.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -35,6 +35,10 @@ note: the lint level is defined here\n    |\n LL | #![warn(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = MustUseDeprecated::new();\n+   |     +++++++\n \n warning: 5 warnings emitted\n "}, {"sha": "89536f53f08b0440377650eb32330efffeb3460b", "filename": "tests/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,7 +1,7 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -14,7 +14,7 @@ LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n@@ -29,7 +29,7 @@ LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   = note: dereferencing pointer failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL"}, {"sha": "5bdb2bf19543907e9f563257b3ec0096345f5342", "filename": "tests/ui/consts/const-eval/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,12 +1,13 @@\n const fn failure() {\n     panic!(\"{:?}\", 0);\n     //~^ ERROR cannot call non-const formatting macro in constant functions\n+    //~| ERROR cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n }\n \n const fn print() {\n     println!(\"{:?}\", 0);\n     //~^ ERROR cannot call non-const formatting macro in constant functions\n-    //~| ERROR `Arguments::<'a>::new_v1` is not yet stable as a const fn\n+    //~| ERROR cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n     //~| ERROR cannot call non-const fn `_print` in constant functions\n }\n "}, {"sha": "c39920d444def348c5676fa24508a05b9504bdcf", "filename": "tests/ui/consts/const-eval/format.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fformat.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -7,26 +7,35 @@ LL |     panic!(\"{:?}\", 0);\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error[E0015]: cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n+  --> $DIR/format.rs:2:5\n+   |\n+LL |     panic!(\"{:?}\", 0);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error[E0015]: cannot call non-const formatting macro in constant functions\n-  --> $DIR/format.rs:7:22\n+  --> $DIR/format.rs:8:22\n    |\n LL |     println!(\"{:?}\", 0);\n    |                      ^\n    |\n    = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: `Arguments::<'a>::new_v1` is not yet stable as a const fn\n-  --> $DIR/format.rs:7:5\n+error[E0015]: cannot call non-const fn `Arguments::<'_>::new_v1` in constant functions\n+  --> $DIR/format.rs:8:5\n    |\n LL |     println!(\"{:?}\", 0);\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: add `#![feature(const_fmt_arguments_new)]` to the crate attributes to enable\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0015]: cannot call non-const fn `_print` in constant functions\n-  --> $DIR/format.rs:7:5\n+  --> $DIR/format.rs:8:5\n    |\n LL |     println!(\"{:?}\", 0);\n    |     ^^^^^^^^^^^^^^^^^^^\n@@ -63,33 +72,33 @@ LL |     panic!(\"{:?}\", 0);\n    = note: this note originates in the macro `$crate::const_format_args` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:14\n+  --> $DIR/format.rs:8:14\n    |\n LL |     println!(\"{:?}\", 0);\n    |              ^^^^^^\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:14\n+  --> $DIR/format.rs:8:14\n    |\n LL |     println!(\"{:?}\", 0);\n    |              ^^^^^^\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:22\n+  --> $DIR/format.rs:8:22\n    |\n LL |     println!(\"{:?}\", 0);\n    |                      ^\n    |\n    = note: this note originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used\n-  --> $DIR/format.rs:7:22\n+  --> $DIR/format.rs:8:22\n    |\n LL |     println!(\"{:?}\", 0);\n    |                      ^\n    |\n    = note: this note originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0015`."}, {"sha": "080568b51ef715ec3644a33a5f52cef0368a12af", "filename": "tests/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -148,11 +148,11 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                HEX_DUMP\n            }\n \n-error: accessing memory with alignment 1, but alignment 4 is required\n+error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+   = note: accessing memory with alignment 1, but alignment 4 is required\n+   |\n note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n note: inside `ptr::const_ptr::<impl *const u32>::read`\n@@ -162,25 +162,7 @@ note: inside `UNALIGNED_READ`\n    |\n LL |     ptr.read();\n    |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n \n error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`.\n-Future incompatibility report: Future breakage diagnostic:\n-error: accessing memory with alignment 1, but alignment 4 is required\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-   |\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n-  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:67:5\n-   |\n-LL |     ptr.read();\n-   |     ^^^^^^^^^^\n-   = note: `#[deny(invalid_alignment)]` on by default\n-"}, {"sha": "a10eea9de114fb82c924bbe593bafa768664a8d8", "filename": "tests/ui/consts/issue-miri-1910.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fissue-miri-1910.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,7 +1,7 @@\n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: unable to copy parts of a pointer from memory at ALLOC\n+   = note: unable to turn pointer into raw bytes\n    |\n    = help: this code performed an operation that depends on the underlying bytes representing a pointer\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported"}, {"sha": "6530084a5857dd27f7346292dc67e58514971dff", "filename": "tests/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -39,19 +39,19 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:79:14"}, {"sha": "5c9d2e356fc7048fb301b9ff7898497599038ab0", "filename": "tests/ui/impl-trait/in-trait/deep-match-works.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match-works.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match-works.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match-works.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n@@ -10,7 +12,9 @@ trait Foo {\n }\n \n impl Foo for () {\n-    fn bar() -> Wrapper<i32> { Wrapper(0) }\n+    fn bar() -> Wrapper<i32> {\n+        Wrapper(0)\n+    }\n }\n \n fn main() {}"}, {"sha": "400db20c79c928fe1f863df3f8e146b34816d3b4", "filename": "tests/ui/impl-trait/in-trait/deep-match.current.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,7 +1,7 @@\n error[E0053]: method `bar` has an incompatible return type for trait\n-  --> $DIR/deep-match.rs:11:17\n+  --> $DIR/deep-match.rs:14:17\n    |\n-LL |     fn bar() -> i32 { 0 }\n+LL |     fn bar() -> i32 {\n    |                 ^^^\n    |                 |\n    |                 expected `Wrapper<_>`, found `i32`", "previous_filename": "tests/ui/impl-trait/in-trait/deep-match.stderr"}, {"sha": "400db20c79c928fe1f863df3f8e146b34816d3b4", "filename": "tests/ui/impl-trait/in-trait/deep-match.next.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,15 @@\n+error[E0053]: method `bar` has an incompatible return type for trait\n+  --> $DIR/deep-match.rs:14:17\n+   |\n+LL |     fn bar() -> i32 {\n+   |                 ^^^\n+   |                 |\n+   |                 expected `Wrapper<_>`, found `i32`\n+   |                 return type in trait\n+   |\n+   = note: expected struct `Wrapper<_>`\n+                found type `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "413d054e148a6f8f8a75040c3355397ab642182b", "filename": "tests/ui/impl-trait/in-trait/deep-match.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdeep-match.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n \n@@ -8,8 +11,10 @@ trait Foo {\n }\n \n impl Foo for () {\n-    fn bar() -> i32 { 0 }\n-    //~^ ERROR method `bar` has an incompatible return type for trait\n+    fn bar() -> i32 {\n+        //~^ ERROR method `bar` has an incompatible return type for trait\n+        0\n+    }\n }\n \n fn main() {}"}, {"sha": "a0c0589b9a1c04fb7a7fbd3f4520697cb942ce0c", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/default-method-binder-shifting.rs:3:12\n+  --> $DIR/default-method-binder-shifting.rs:5:12\n    |\n LL | #![feature(return_position_impl_trait_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.stderr"}, {"sha": "a0c0589b9a1c04fb7a7fbd3f4520697cb942ce0c", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.next.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/default-method-binder-shifting.rs:5:12\n+   |\n+LL | #![feature(return_position_impl_trait_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "75b0ec939847af189e9b2423f18ad6f7fe5a4bbd", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n //~^ WARN the feature `return_position_impl_trait_in_trait` is incomplete"}, {"sha": "98aaf4a6553f53c454123f8d4fecbcbb2817c0f3", "filename": "tests/ui/impl-trait/in-trait/encode.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fencode.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // build-pass\n // compile-flags: --crate-type=lib\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "df77372aabdfcf51bcda7bf479eb8fd62c3bb7f8", "filename": "tests/ui/impl-trait/in-trait/foreign.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fforeign.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // aux-build: rpitit.rs\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n extern crate rpitit;\n "}, {"sha": "7aa7880e258839df79df9fa5047e0db92de10cc6", "filename": "tests/ui/impl-trait/in-trait/issue-102140.current.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n-  --> $DIR/issue-102140.rs:23:22\n+  --> $DIR/issue-102140.rs:26:22\n    |\n LL |         MyTrait::foo(&self)\n    |         ------------ ^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`\n@@ -13,15 +13,15 @@ LL +         MyTrait::foo(self)\n    |\n \n error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n-  --> $DIR/issue-102140.rs:23:9\n+  --> $DIR/issue-102140.rs:26:9\n    |\n LL |         MyTrait::foo(&self)\n    |         ^^^^^^^^^^^^^^^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`\n    |\n    = help: the trait `MyTrait` is implemented for `Outer`\n \n error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n-  --> $DIR/issue-102140.rs:23:9\n+  --> $DIR/issue-102140.rs:26:9\n    |\n LL |         MyTrait::foo(&self)\n    |         ^^^^^^^^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`", "previous_filename": "tests/ui/impl-trait/in-trait/issue-102140.stderr"}, {"sha": "7aa7880e258839df79df9fa5047e0db92de10cc6", "filename": "tests/ui/impl-trait/in-trait/issue-102140.next.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,33 @@\n+error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n+  --> $DIR/issue-102140.rs:26:22\n+   |\n+LL |         MyTrait::foo(&self)\n+   |         ------------ ^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`\n+   |         |\n+   |         required by a bound introduced by this call\n+   |\n+help: consider removing the leading `&`-reference\n+   |\n+LL -         MyTrait::foo(&self)\n+LL +         MyTrait::foo(self)\n+   |\n+\n+error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n+  --> $DIR/issue-102140.rs:26:9\n+   |\n+LL |         MyTrait::foo(&self)\n+   |         ^^^^^^^^^^^^^^^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`\n+   |\n+   = help: the trait `MyTrait` is implemented for `Outer`\n+\n+error[E0277]: the trait bound `&dyn MyTrait: MyTrait` is not satisfied\n+  --> $DIR/issue-102140.rs:26:9\n+   |\n+LL |         MyTrait::foo(&self)\n+   |         ^^^^^^^^^^^^ the trait `MyTrait` is not implemented for `&dyn MyTrait`\n+   |\n+   = help: the trait `MyTrait` is implemented for `Outer`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4dcac4f5b0eac053d885a1656dd031e17f45a9ef", "filename": "tests/ui/impl-trait/in-trait/issue-102140.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102140.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n "}, {"sha": "ae09d20f6f5b76ae721a5653618b9155abe1d638", "filename": "tests/ui/impl-trait/in-trait/new-lowering-strategy/simple-impl-trait.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-impl-trait.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,17 +0,0 @@\n-// check-pass\n-// compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n-\n-#![feature(return_position_impl_trait_in_trait)]\n-#![allow(incomplete_features)]\n-\n-trait Foo {\n-    fn foo() -> impl Sized;\n-}\n-\n-impl Foo for String {\n-    fn foo() -> i32 {\n-        22\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "dfce973d770b906b4449ca539625ba9699b9a10d", "filename": "tests/ui/impl-trait/in-trait/new-lowering-strategy/simple-trait.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fnew-lowering-strategy%2Fsimple-trait.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,11 +0,0 @@\n-// check-pass\n-// compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n-\n-#![feature(return_position_impl_trait_in_trait)]\n-#![allow(incomplete_features)]\n-\n-trait Foo {\n-    fn foo() -> impl Sized;\n-}\n-\n-fn main() {}"}, {"sha": "b7f2b019a7765aaafd7883f60283e1ea0347988e", "filename": "tests/ui/impl-trait/in-trait/object-safety.current.stderr", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,11 +1,11 @@\n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/object-safety.rs:17:33\n+  --> $DIR/object-safety.rs:20:33\n    |\n LL |     let i = Box::new(42_u32) as Box<dyn Foo>;\n    |                                 ^^^^^^^^^^^^ `Foo` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/object-safety.rs:7:22\n+  --> $DIR/object-safety.rs:10:22\n    |\n LL | trait Foo {\n    |       --- this trait cannot be made into an object...\n@@ -14,13 +14,13 @@ LL |     fn baz(&self) -> impl Debug;\n    = help: consider moving `baz` to another trait\n \n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/object-safety.rs:20:13\n+  --> $DIR/object-safety.rs:23:13\n    |\n LL |     let s = i.baz();\n    |             ^^^^^^^ `Foo` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/object-safety.rs:7:22\n+  --> $DIR/object-safety.rs:10:22\n    |\n LL | trait Foo {\n    |       --- this trait cannot be made into an object...\n@@ -29,13 +29,13 @@ LL |     fn baz(&self) -> impl Debug;\n    = help: consider moving `baz` to another trait\n \n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/object-safety.rs:17:13\n+  --> $DIR/object-safety.rs:20:13\n    |\n LL |     let i = Box::new(42_u32) as Box<dyn Foo>;\n    |             ^^^^^^^^^^^^^^^^ `Foo` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n-  --> $DIR/object-safety.rs:7:22\n+  --> $DIR/object-safety.rs:10:22\n    |\n LL | trait Foo {\n    |       --- this trait cannot be made into an object...", "previous_filename": "tests/ui/impl-trait/in-trait/object-safety.stderr"}, {"sha": "b7f2b019a7765aaafd7883f60283e1ea0347988e", "filename": "tests/ui/impl-trait/in-trait/object-safety.next.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,50 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety.rs:20:33\n+   |\n+LL |     let i = Box::new(42_u32) as Box<dyn Foo>;\n+   |                                 ^^^^^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety.rs:10:22\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn baz(&self) -> impl Debug;\n+   |                      ^^^^^^^^^^ ...because method `baz` references an `impl Trait` type in its return type\n+   = help: consider moving `baz` to another trait\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety.rs:23:13\n+   |\n+LL |     let s = i.baz();\n+   |             ^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety.rs:10:22\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn baz(&self) -> impl Debug;\n+   |                      ^^^^^^^^^^ ...because method `baz` references an `impl Trait` type in its return type\n+   = help: consider moving `baz` to another trait\n+\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety.rs:20:13\n+   |\n+LL |     let i = Box::new(42_u32) as Box<dyn Foo>;\n+   |             ^^^^^^^^^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety.rs:10:22\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn baz(&self) -> impl Debug;\n+   |                      ^^^^^^^^^^ ...because method `baz` references an `impl Trait` type in its return type\n+   = help: consider moving `baz` to another trait\n+   = note: required for `Box<u32>` to implement `CoerceUnsized<Box<dyn Foo>>`\n+   = note: required by cast to type `Box<dyn Foo>`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "016a0aaae4b6e4b4cd0ec18521f613d4bec8f16a", "filename": "tests/ui/impl-trait/in-trait/object-safety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fobject-safety.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n "}, {"sha": "a57653b2c9ed76ddb212df8a2a77c2a817326289", "filename": "tests/ui/impl-trait/in-trait/opaque-in-impl-is-opaque.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/opaque-in-impl-is-opaque.rs:17:19\n+  --> $DIR/opaque-in-impl-is-opaque.rs:20:19\n    |\n LL |     fn bar(&self) -> impl Display {\n    |                      ------------ the found opaque type", "previous_filename": "tests/ui/impl-trait/in-trait/opaque-in-impl-is-opaque.stderr"}, {"sha": "a57653b2c9ed76ddb212df8a2a77c2a817326289", "filename": "tests/ui/impl-trait/in-trait/opaque-in-impl-is-opaque.next.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,17 @@\n+error[E0308]: mismatched types\n+  --> $DIR/opaque-in-impl-is-opaque.rs:20:19\n+   |\n+LL |     fn bar(&self) -> impl Display {\n+   |                      ------------ the found opaque type\n+...\n+LL |     let x: &str = ().bar();\n+   |            ----   ^^^^^^^^ expected `&str`, found opaque type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&str`\n+            found opaque type `impl std::fmt::Display`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c07ece15a8324a919797365665493663e62a87f1", "filename": "tests/ui/impl-trait/in-trait/opaque-in-impl-is-opaque.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl-is-opaque.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n "}, {"sha": "1f42ec744dbe8031a1e3d4c38de3dae8fd036169", "filename": "tests/ui/impl-trait/in-trait/reveal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Freveal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Freveal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Freveal.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "eba270af7f0ee918d853f73cfe3345dde343fbb0", "filename": "tests/ui/impl-trait/in-trait/signature-mismatch.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.current.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,5 +1,5 @@\n error: `impl` item signature doesn't match `trait` item signature\n-  --> $DIR/signature-mismatch.rs:15:5\n+  --> $DIR/signature-mismatch.rs:17:5\n    |\n LL |     fn async_fn(&self, buff: &[u8]) -> impl Future<Output = Vec<u8>>;\n    |     ----------------------------------------------------------------- expected `fn(&'1 Struct, &'2 [u8]) -> impl Future<Output = Vec<u8>> + '3`", "previous_filename": "tests/ui/impl-trait/in-trait/signature-mismatch.stderr"}, {"sha": "eba270af7f0ee918d853f73cfe3345dde343fbb0", "filename": "tests/ui/impl-trait/in-trait/signature-mismatch.next.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.next.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,16 @@\n+error: `impl` item signature doesn't match `trait` item signature\n+  --> $DIR/signature-mismatch.rs:17:5\n+   |\n+LL |     fn async_fn(&self, buff: &[u8]) -> impl Future<Output = Vec<u8>>;\n+   |     ----------------------------------------------------------------- expected `fn(&'1 Struct, &'2 [u8]) -> impl Future<Output = Vec<u8>> + '3`\n+...\n+LL |     fn async_fn<'a>(&self, buff: &'a [u8]) -> impl Future<Output = Vec<u8>> + 'a {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&'1 Struct, &'2 [u8]) -> impl Future<Output = Vec<u8>> + '2`\n+   |\n+   = note: expected signature `fn(&'1 Struct, &'2 [u8]) -> impl Future<Output = Vec<u8>> + '3`\n+              found signature `fn(&'1 Struct, &'2 [u8]) -> impl Future<Output = Vec<u8>> + '2`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+\n+error: aborting due to previous error\n+"}, {"sha": "38c902a97a980382b60aec36d73800e58455e1a7", "filename": "tests/ui/impl-trait/in-trait/signature-mismatch.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsignature-mismatch.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "dbc5d38f192929430e269b407b7148f9c3758ca3", "filename": "tests/ui/impl-trait/in-trait/specialization-substs-remap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-substs-remap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-substs-remap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fspecialization-substs-remap.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(specialization)]\n #![feature(return_position_impl_trait_in_trait)]"}, {"sha": "0e69e0490c776aece731e301d6b812726f433e80", "filename": "tests/ui/impl-trait/in-trait/success.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsuccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsuccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fsuccess.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "90d0bb406554350793bc7537752184952bd29eab", "filename": "tests/ui/issues/issue-19086.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fissues%2Fissue-19086.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fissues%2Fissue-19086.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-19086.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -5,7 +5,7 @@ LL |     FooB { x: i32, y: i32 }\n    |     ----------------------- `FooB` defined here\n ...\n LL |         FooB(a, b) => println!(\"{} {}\", a, b),\n-   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x, y }`\n+   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x: a, y: b }`\n \n error: aborting due to previous error\n "}, {"sha": "6753ce15ed15827ed4351dba2429ec84e60c5461", "filename": "tests/ui/layout/transmute-to-tail-with-err.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flayout%2Ftransmute-to-tail-with-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flayout%2Ftransmute-to-tail-with-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Ftransmute-to-tail-with-err.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,8 @@\n+trait Trait<T> {}\n+\n+struct Bar(Box<dyn Trait<T>>);\n+//~^ ERROR cannot find type `T` in this scope\n+\n+fn main() {\n+    let x: Bar = unsafe { std::mem::transmute(()) };\n+}"}, {"sha": "97ab59c398a3baa1b51d7ebbaa2439fb4fee3d66", "filename": "tests/ui/layout/transmute-to-tail-with-err.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flayout%2Ftransmute-to-tail-with-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flayout%2Ftransmute-to-tail-with-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flayout%2Ftransmute-to-tail-with-err.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,14 @@\n+error[E0412]: cannot find type `T` in this scope\n+  --> $DIR/transmute-to-tail-with-err.rs:3:26\n+   |\n+LL | struct Bar(Box<dyn Trait<T>>);\n+   |                          ^ not found in this scope\n+   |\n+help: you might be missing a type parameter\n+   |\n+LL | struct Bar<T>(Box<dyn Trait<T>>);\n+   |           +++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "e88c1a9b8a9b99c0d3e4fae7b8818b451a6db6ab", "filename": "tests/ui/lint/fn_must_use.stderr", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Ffn_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Ffn_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Ffn_must_use.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -10,12 +10,21 @@ note: the lint level is defined here\n    |\n LL | #![warn(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = need_to_use_this_value();\n+   |     +++++++\n \n warning: unused return value of `MyStruct::need_to_use_this_method_value` that must be used\n   --> $DIR/fn_must_use.rs:60:5\n    |\n LL |     m.need_to_use_this_method_value();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = m.need_to_use_this_method_value();\n+   |     +++++++\n \n warning: unused return value of `EvenNature::is_even` that must be used\n   --> $DIR/fn_must_use.rs:61:5\n@@ -24,24 +33,43 @@ LL |     m.is_even(); // trait method!\n    |     ^^^^^^^^^^^\n    |\n    = note: no side effects\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = m.is_even(); // trait method!\n+   |     +++++++\n \n warning: unused return value of `MyStruct::need_to_use_this_associated_function_value` that must be used\n   --> $DIR/fn_must_use.rs:64:5\n    |\n LL |     MyStruct::need_to_use_this_associated_function_value();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = MyStruct::need_to_use_this_associated_function_value();\n+   |     +++++++\n \n warning: unused return value of `std::cmp::PartialEq::eq` that must be used\n   --> $DIR/fn_must_use.rs:70:5\n    |\n LL |     2.eq(&3);\n    |     ^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = 2.eq(&3);\n+   |     +++++++\n \n warning: unused return value of `std::cmp::PartialEq::eq` that must be used\n   --> $DIR/fn_must_use.rs:71:5\n    |\n LL |     m.eq(&n);\n    |     ^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = m.eq(&n);\n+   |     +++++++\n \n warning: unused comparison that must be used\n   --> $DIR/fn_must_use.rs:74:5"}, {"sha": "daf530e6d0b6eeca0e12987dcbee5c8356c295e6", "filename": "tests/ui/lint/issue-109152.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Fissue-109152.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Fissue-109152.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-109152.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,7 @@\n+#![deny(map_unit_fn)]\n+\n+#![crate_type = \"lib\"]\n+fn _y() {\n+    vec![42].iter().map(drop);\n+    //~^ ERROR `Iterator::map` call that discard the iterator's values\n+}"}, {"sha": "7db9e71a584b0533dada5b4096caacfe9f60366a", "filename": "tests/ui/lint/issue-109152.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Fissue-109152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Fissue-109152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fissue-109152.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,23 @@\n+error: `Iterator::map` call that discard the iterator's values\n+  --> $DIR/issue-109152.rs:5:21\n+   |\n+LL |     vec![42].iter().map(drop);\n+   |                     ^^^^----^\n+   |                     |   |\n+   |                     |   this function returns `()`, which is likely not what you wanted\n+   |                     |   called `Iterator::map` with callable that returns `()`\n+   |                     after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+   |\n+   = note: `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+note: the lint level is defined here\n+  --> $DIR/issue-109152.rs:1:9\n+   |\n+LL | #![deny(map_unit_fn)]\n+   |         ^^^^^^^^^^^\n+help: you might have meant to use `Iterator::for_each`\n+   |\n+LL |     vec![42].iter().for_each(drop);\n+   |                     ~~~~~~~~\n+\n+error: aborting due to previous error\n+"}, {"sha": "4898db7fe3ddd7a76d49bc7b7061eb04961d4168", "filename": "tests/ui/lint/unused/must-use-box-from-raw.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fmust-use-box-from-raw.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -10,6 +10,10 @@ note: the lint level is defined here\n    |\n LL | #![warn(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = Box::from_raw(ptr);\n+   |     +++++++\n \n warning: 1 warning emitted\n "}, {"sha": "993a19e5f04ed85f4816a4974965bd5149434f14", "filename": "tests/ui/lint/unused/must_use-unit.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Fmust_use-unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Fmust_use-unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fmust_use-unit.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -9,12 +9,21 @@ note: the lint level is defined here\n    |\n LL | #![deny(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo();\n+   |     +++++++\n \n error: unused return value of `bar` that must be used\n   --> $DIR/must_use-unit.rs:15:5\n    |\n LL |     bar();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = bar();\n+   |     +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1c3702ba265c0480fa3b36a7e59b36a5f7e693c1", "filename": "tests/ui/lint/unused/unused-async.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Funused-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Funused-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-async.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -16,12 +16,22 @@ error: unused return value of `foo` that must be used\n    |\n LL |     foo();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo();\n+   |     +++++++\n \n error: unused output of future returned by `foo` that must be used\n   --> $DIR/unused-async.rs:33:5\n    |\n LL |     foo().await;\n    |     ^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo().await;\n+   |     +++++++\n \n error: unused implementer of `Future` that must be used\n   --> $DIR/unused-async.rs:34:5\n@@ -36,12 +46,22 @@ error: unused return value of `bar` that must be used\n    |\n LL |     bar();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = bar();\n+   |     +++++++\n \n error: unused output of future returned by `bar` that must be used\n   --> $DIR/unused-async.rs:36:5\n    |\n LL |     bar().await;\n    |     ^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = bar().await;\n+   |     +++++++\n \n error: unused implementer of `Future` that must be used\n   --> $DIR/unused-async.rs:37:5"}, {"sha": "f42995a65d13eadc51da96b262f48c8f9f9801f7", "filename": "tests/ui/lint/unused/unused-result.stderr", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Funused-result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Funused-result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused-result.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -9,6 +9,10 @@ note: the lint level is defined here\n    |\n LL | #![deny(unused_results, unused_must_use)]\n    |                         ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUse>();\n+   |     +++++++\n \n error: unused `MustUseMsg` that must be used\n   --> $DIR/unused-result.rs:22:5\n@@ -17,6 +21,10 @@ LL |     foo::<MustUseMsg>();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: some message\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUseMsg>();\n+   |     +++++++\n \n error: unused result of type `isize`\n   --> $DIR/unused-result.rs:34:5\n@@ -35,6 +43,11 @@ error: unused `MustUse` that must be used\n    |\n LL |     foo::<MustUse>();\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUse>();\n+   |     +++++++\n \n error: unused `MustUseMsg` that must be used\n   --> $DIR/unused-result.rs:36:5\n@@ -43,6 +56,10 @@ LL |     foo::<MustUseMsg>();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: some message\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo::<MustUseMsg>();\n+   |     +++++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "9633767c4428767a162995e2c862ce7e6ab04eb5", "filename": "tests/ui/lint/unused/unused_attributes-must_use.stderr", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Funused_attributes-must_use.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -146,42 +146,76 @@ note: the lint level is defined here\n    |\n LL | #![deny(unused_attributes, unused_must_use)]\n    |                            ^^^^^^^^^^^^^^^\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = X;\n+   |     +++++++\n \n error: unused `Y` that must be used\n   --> $DIR/unused_attributes-must_use.rs:104:5\n    |\n LL |     Y::Z;\n    |     ^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = Y::Z;\n+   |     +++++++\n \n error: unused `U` that must be used\n   --> $DIR/unused_attributes-must_use.rs:105:5\n    |\n LL |     U { unit: () };\n    |     ^^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = U { unit: () };\n+   |     +++++++\n \n error: unused return value of `U::method` that must be used\n   --> $DIR/unused_attributes-must_use.rs:106:5\n    |\n LL |     U::method();\n    |     ^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = U::method();\n+   |     +++++++\n \n error: unused return value of `foo` that must be used\n   --> $DIR/unused_attributes-must_use.rs:107:5\n    |\n LL |     foo();\n    |     ^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = foo();\n+   |     +++++++\n \n error: unused return value of `foreign_foo` that must be used\n   --> $DIR/unused_attributes-must_use.rs:110:9\n    |\n LL |         foreign_foo();\n    |         ^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |         let _ = foreign_foo();\n+   |         +++++++\n \n error: unused return value of `Use::get_four` that must be used\n   --> $DIR/unused_attributes-must_use.rs:118:5\n    |\n LL |     ().get_four();\n    |     ^^^^^^^^^^^^^\n+   |\n+help: use `let _ = ...` to ignore the resulting value\n+   |\n+LL |     let _ = ().get_four();\n+   |     +++++++\n \n error: aborting due to 28 previous errors\n "}, {"sha": "5a90b314a6ed15a00fa82c8cfacf96e3ef1b1a0c", "filename": "tests/ui/panic-runtime/unwind-tables-target-required.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpanic-runtime%2Funwind-tables-target-required.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpanic-runtime%2Funwind-tables-target-required.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanic-runtime%2Funwind-tables-target-required.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -1,10 +1,11 @@\n // Tests that the compiler errors if the user tries to turn off unwind tables\n // when they are required.\n //\n-// only-x86_64-windows-msvc\n+// only-x86_64-pc-windows-msvc\n // compile-flags: -C force-unwind-tables=no\n //\n-// error-pattern: target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`.\n+// dont-check-compiler-stderr\n+// error-pattern: target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n \n pub fn main() {\n }"}, {"sha": "9b27a61ffd06905be77f622acce6931455bddfde", "filename": "tests/ui/pattern/issue-106862.fixed", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpattern%2Fissue-106862.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpattern%2Fissue-106862.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106862.fixed?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,44 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+use Foo::{FooB, FooA};\n+\n+enum Foo {\n+    FooA { opt_x: Option<i32>, y: i32 },\n+    FooB { x: i32, y: i32 }\n+}\n+\n+fn main() {\n+    let f = FooB { x: 3, y: 4 };\n+\n+    match f {\n+        FooB { x: a, y: b } => println!(\"{} {}\", a, b),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB { x, y } => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooA { opt_x: Some(x), y } => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooA`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB { x: a, y: _ } => println!(\"{}\", a),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB { x, y } => (),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+}"}, {"sha": "590430a784314e1308869b79bb345fc607cba14a", "filename": "tests/ui/pattern/issue-106862.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpattern%2Fissue-106862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpattern%2Fissue-106862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106862.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,44 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+use Foo::{FooB, FooA};\n+\n+enum Foo {\n+    FooA { opt_x: Option<i32>, y: i32 },\n+    FooB { x: i32, y: i32 }\n+}\n+\n+fn main() {\n+    let f = FooB { x: 3, y: 4 };\n+\n+    match f {\n+        FooB(a, b) => println!(\"{} {}\", a, b),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB(x, y) => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooA(Some(x), y) => println!(\"{} {}\", x, y),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooA`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB(a, _, _) => println!(\"{}\", a),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+\n+    match f {\n+        FooB() => (),\n+        //~^ ERROR expected tuple struct or tuple variant, found variant `FooB`\n+        _ => (),\n+    }\n+}"}, {"sha": "27f8ac97284ebd7063a15b629f64736e320bf1a2", "filename": "tests/ui/pattern/issue-106862.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpattern%2Fissue-106862.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fpattern%2Fissue-106862.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fissue-106862.stderr?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,48 @@\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:16:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB(a, b) => println!(\"{} {}\", a, b),\n+   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x: a, y: b }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:22:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB(x, y) => println!(\"{} {}\", x, y),\n+   |         ^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x, y }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooA`\n+  --> $DIR/issue-106862.rs:28:9\n+   |\n+LL |     FooA { opt_x: Option<i32>, y: i32 },\n+   |     ----------------------------------- `FooA` defined here\n+...\n+LL |         FooA(Some(x), y) => println!(\"{} {}\", x, y),\n+   |         ^^^^^^^^^^^^^^^^ help: use struct pattern syntax instead: `FooA { opt_x: Some(x), y }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:34:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB(a, _, _) => println!(\"{}\", a),\n+   |         ^^^^^^^^^^^^^ help: use struct pattern syntax instead: `FooB { x: a, y: _ }`\n+\n+error[E0532]: expected tuple struct or tuple variant, found variant `FooB`\n+  --> $DIR/issue-106862.rs:40:9\n+   |\n+LL |     FooB { x: i32, y: i32 }\n+   |     ----------------------- `FooB` defined here\n+...\n+LL |         FooB() => (),\n+   |         ^^^^^^ help: use struct pattern syntax instead: `FooB { x, y }`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0532`."}, {"sha": "d214c7ac8b274c9a9a26aeb11782c57a835d24b1", "filename": "tests/ui/proc-macro/bad-projection.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fproc-macro%2Fbad-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3831a254905873af4da996ab21c6f9f3d4050051/tests%2Fui%2Fproc-macro%2Fbad-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Fbad-projection.rs?ref=3831a254905873af4da996ab21c6f9f3d4050051", "patch": "@@ -0,0 +1,15 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![allow(warnings)]\n+\n+extern crate proc_macro;\n+\n+trait Project {\n+    type Assoc;\n+}\n+\n+#[proc_macro]\n+pub fn uwu() -> <() as Project>::Assoc {}\n+//~^ ERROR the trait bound `(): Project` is not satisfied"}]}