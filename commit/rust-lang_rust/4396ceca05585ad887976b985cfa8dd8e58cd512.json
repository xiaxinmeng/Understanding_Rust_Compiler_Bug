{"sha": "4396ceca05585ad887976b985cfa8dd8e58cd512", "node_id": "C_kwDOAAsO6NoAKDQzOTZjZWNhMDU1ODVhZDg4Nzk3NmI5ODVjZmE4ZGQ4ZTU4Y2Q1MTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-22T15:15:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-22T15:15:51Z"}, "message": "Auto merge of #109753 - compiler-errors:replenish-region-constraints, r=aliemjay\n\nClone region var origins instead of taking them in borrowck\n\nFixes an issue with the new solver where reporting a borrow-checker error ICEs because it calls `InferCtxt::evaluate_obligation`.\n\nThis also removes a handful of unnecessary `tcx.infer_ctxt().build()` calls that are only there to mitigate this same exact issue, but with the old solver.\n\nFixes compiler-errors/next-solver-hir-issues#12.\n\n----\n\nThis implements `@aliemjay's` solution where we just don't *take* the region constraints, but clone them. This potentially makes it easier to write a bug about taking region constraints twice or never at all, but again, not many folks are touching this code.", "tree": {"sha": "57ccce436c3230950a9a7dab80eb88cf55cde126", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57ccce436c3230950a9a7dab80eb88cf55cde126"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4396ceca05585ad887976b985cfa8dd8e58cd512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4396ceca05585ad887976b985cfa8dd8e58cd512", "html_url": "https://github.com/rust-lang/rust/commit/4396ceca05585ad887976b985cfa8dd8e58cd512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4396ceca05585ad887976b985cfa8dd8e58cd512/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39cf520299794e6c1b6b471db5d9935e0c6271ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/39cf520299794e6c1b6b471db5d9935e0c6271ab", "html_url": "https://github.com/rust-lang/rust/commit/39cf520299794e6c1b6b471db5d9935e0c6271ab"}, {"sha": "964600b38ed0aeec8d3869aa38d31b3e1553066a", "url": "https://api.github.com/repos/rust-lang/rust/commits/964600b38ed0aeec8d3869aa38d31b3e1553066a", "html_url": "https://github.com/rust-lang/rust/commit/964600b38ed0aeec8d3869aa38d31b3e1553066a"}], "stats": {"total": 76, "additions": 43, "deletions": 33}, "files": [{"sha": "8dd03aaa72d160759a56bbbe50d458fffbeacfc6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=4396ceca05585ad887976b985cfa8dd8e58cd512", "patch": "@@ -10,7 +10,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::mir::tcx::PlaceTy;\n@@ -643,11 +642,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let Some(default_trait) = tcx.get_diagnostic_item(sym::Default) else {\n                 return false;\n             };\n-            // Regions are already solved, so we must use a fresh InferCtxt,\n-            // but the type has region variables, so erase those.\n-            tcx.infer_ctxt()\n-                .build()\n-                .type_implements_trait(default_trait, [tcx.erase_regions(ty)], param_env)\n+            self.infcx\n+                .type_implements_trait(default_trait, [ty], param_env)\n                 .must_apply_modulo_regions()\n         };\n \n@@ -740,13 +736,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn suggest_cloning(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.infcx.tcx;\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let infcx = tcx.infer_ctxt().build();\n-\n         if let Some(clone_trait_def) = tcx.lang_items().clone_trait()\n-            && infcx\n+            && self.infcx\n                 .type_implements_trait(\n                     clone_trait_def,\n-                    [tcx.erase_regions(ty)],\n+                    [ty],\n                     self.param_env,\n                 )\n                 .must_apply_modulo_regions()\n@@ -770,12 +764,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|def_id| tcx.hir().get_generics(def_id))\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let infcx = tcx.infer_ctxt().build();\n-        let ocx = ObligationCtxt::new(&infcx);\n+        let ocx = ObligationCtxt::new(&self.infcx);\n         let copy_did = tcx.require_lang_item(LangItem::Copy, Some(span));\n         let cause = ObligationCause::misc(span, self.mir_def_id());\n \n-        ocx.register_bound(cause, self.param_env, infcx.tcx.erase_regions(ty), copy_did);\n+        ocx.register_bound(cause, self.param_env, ty, copy_did);\n         let errors = ocx.select_all_or_error();\n \n         // Only emit suggestion if all required predicates are on generic\n@@ -2219,7 +2212,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let tcx = self.infcx.tcx;\n \n             let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n-            let return_ty = tcx.erase_regions(return_ty);\n \n             // to avoid panics\n             if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator)"}, {"sha": "299d04c4fb6e3dffaf47120d5689b9ce94e98afa", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=4396ceca05585ad887976b985cfa8dd8e58cd512", "patch": "@@ -10,7 +10,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::GeneratorKind;\n use rustc_index::vec::IndexSlice;\n-use rustc_infer::infer::{LateBoundRegionConversionTime, TyCtxtInferExt};\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Local, LocalInfo, LocalKind, Location, Operand, Place,\n@@ -1042,15 +1042,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, tcx).ty;\n                         let suggest = match tcx.get_diagnostic_item(sym::IntoIterator) {\n-                            Some(def_id) => {\n-                                let infcx = self.infcx.tcx.infer_ctxt().build();\n-                                type_known_to_meet_bound_modulo_regions(\n-                                    &infcx,\n-                                    self.param_env,\n-                                    tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.erase_regions(ty)),\n-                                    def_id,\n-                                )\n-                            }\n+                            Some(def_id) => type_known_to_meet_bound_modulo_regions(\n+                                &self.infcx,\n+                                self.param_env,\n+                                tcx.mk_imm_ref(tcx.lifetimes.re_erased, ty),\n+                                def_id,\n+                            ),\n                             _ => false,\n                         };\n                         if suggest {\n@@ -1094,20 +1091,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             is_partial,\n                             is_loop_message,\n                         });\n-                        let infcx = tcx.infer_ctxt().build();\n                         // Erase and shadow everything that could be passed to the new infcx.\n-                        let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n-                        let method_substs = tcx.erase_regions(method_substs);\n+                        let ty = moved_place.ty(self.body, tcx).ty;\n \n                         if let ty::Adt(def, substs) = ty.kind()\n                             && Some(def.did()) == tcx.lang_items().pin_type()\n                             && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()\n-                            && let self_ty = infcx.instantiate_binder_with_fresh_vars(\n+                            && let self_ty = self.infcx.instantiate_binder_with_fresh_vars(\n                                 fn_call_span,\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),\n                             )\n-                            && infcx.can_eq(self.param_env, ty, self_ty)\n+                            && self.infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n                             err.eager_subdiagnostic(\n                                 &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n@@ -1123,7 +1118,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 self.param_env,\n                                 ty::Binder::dummy(trait_ref),\n                             )\n-                            && infcx.predicate_must_hold_modulo_regions(&o)\n+                            && self.infcx.predicate_must_hold_modulo_regions(&o)\n                         {\n                             err.span_suggestion_verbose(\n                                 fn_call_span.shrink_to_lo(),"}, {"sha": "5e55e1128e84e3040423c925dbf20f8f3651c46d", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=4396ceca05585ad887976b985cfa8dd8e58cd512", "patch": "@@ -235,7 +235,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     // Create the region inference context, taking ownership of the\n     // region inference data that was contained in `infcx`, and the\n     // base constraints generated by the type-check.\n-    let var_origins = infcx.take_region_var_origins();\n+    let var_origins = infcx.get_region_var_origins();\n     let MirTypeckRegionConstraints {\n         placeholder_indices,\n         placeholder_index_to_region: _,"}, {"sha": "1cd09cde0fc0848a72823f00c0d031f2e36701b6", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4396ceca05585ad887976b985cfa8dd8e58cd512/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=4396ceca05585ad887976b985cfa8dd8e58cd512", "patch": "@@ -1228,11 +1228,11 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// hence that `resolve_regions_and_report_errors` can never be\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region variables into the NLL region context.\n-    pub fn take_region_var_origins(&self) -> VarInfos {\n+    pub fn get_region_var_origins(&self) -> VarInfos {\n         let mut inner = self.inner.borrow_mut();\n         let (var_infos, data) = inner\n             .region_constraint_storage\n-            .take()\n+            .clone()\n             .expect(\"regions already resolved\")\n             .with_log(&mut inner.undo_log)\n             .into_infos_and_data();"}, {"sha": "4787a2c7e1192820152b645b0d912bd41f55cb5d", "filename": "tests/ui/traits/new-solver/borrowck-error.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4396ceca05585ad887976b985cfa8dd8e58cd512/tests%2Fui%2Ftraits%2Fnew-solver%2Fborrowck-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4396ceca05585ad887976b985cfa8dd8e58cd512/tests%2Fui%2Ftraits%2Fnew-solver%2Fborrowck-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fborrowck-error.rs?ref=4396ceca05585ad887976b985cfa8dd8e58cd512", "patch": "@@ -0,0 +1,11 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+use std::collections::HashMap;\n+\n+fn foo() -> &'static HashMap<i32, i32>\n+{\n+    &HashMap::new()\n+    //~^ ERROR cannot return reference to temporary value\n+}\n+\n+fn main() {}"}, {"sha": "a7d8201747a1226cdca0aa9ee7994a0daecc85a5", "filename": "tests/ui/traits/new-solver/borrowck-error.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4396ceca05585ad887976b985cfa8dd8e58cd512/tests%2Fui%2Ftraits%2Fnew-solver%2Fborrowck-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4396ceca05585ad887976b985cfa8dd8e58cd512/tests%2Fui%2Ftraits%2Fnew-solver%2Fborrowck-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fborrowck-error.stderr?ref=4396ceca05585ad887976b985cfa8dd8e58cd512", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return reference to temporary value\n+  --> $DIR/borrowck-error.rs:7:5\n+   |\n+LL |     &HashMap::new()\n+   |     ^--------------\n+   |     ||\n+   |     |temporary value created here\n+   |     returns a reference to data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}]}