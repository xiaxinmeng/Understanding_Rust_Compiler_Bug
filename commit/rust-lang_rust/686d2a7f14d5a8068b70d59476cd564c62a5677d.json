{"sha": "686d2a7f14d5a8068b70d59476cd564c62a5677d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NmQyYTdmMTRkNWE4MDY4YjcwZDU5NDc2Y2Q1NjRjNjJhNTY3N2Q=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-18T15:48:36Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-24T12:01:44Z"}, "message": "incr.comp.: Factor some persistence functionality out of crate metadata code.", "tree": {"sha": "5c2491a666ee005cf8025ea5c23acaed1e7d1a6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c2491a666ee005cf8025ea5c23acaed1e7d1a6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/686d2a7f14d5a8068b70d59476cd564c62a5677d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/686d2a7f14d5a8068b70d59476cd564c62a5677d", "html_url": "https://github.com/rust-lang/rust/commit/686d2a7f14d5a8068b70d59476cd564c62a5677d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/686d2a7f14d5a8068b70d59476cd564c62a5677d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a789fa0440214347e1bf6228fdb8fd36bf2f4520", "url": "https://api.github.com/repos/rust-lang/rust/commits/a789fa0440214347e1bf6228fdb8fd36bf2f4520", "html_url": "https://github.com/rust-lang/rust/commit/a789fa0440214347e1bf6228fdb8fd36bf2f4520"}], "stats": {"total": 430, "additions": 316, "deletions": 114}, "files": [{"sha": "1c793920bf2e4de8a5f30bfab4c5f20739db1364", "filename": "src/librustc/ty/codec.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=686d2a7f14d5a8068b70d59476cd564c62a5677d", "patch": "@@ -0,0 +1,243 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This module contains some shared code for encoding and decoding various\n+// things from the `ty` module, and in particular implements support for\n+// \"shorthands\" which allow to have pointers back into the already encoded\n+// stream instead of re-encoding the same thing twice.\n+//\n+// The functionality in here is shared between persisting to crate metadata and\n+// persisting to incr. comp. caches.\n+\n+use hir::def_id::{DefId, CrateNum};\n+use middle::const_val::ByteArray;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_serialize::{Decodable, Decoder, Encoder, Encodable};\n+use std::hash::Hash;\n+use std::intrinsics;\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Substs;\n+\n+/// The shorthand encoding uses an enum's variant index `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const SHORTHAND_OFFSET: usize = 0x80;\n+\n+pub trait EncodableWithShorthand: Clone + Eq + Hash {\n+    type Variant: Encodable;\n+    fn variant(&self) -> &Self::Variant;\n+}\n+\n+impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n+    type Variant = ty::TypeVariants<'tcx>;\n+    fn variant(&self) -> &Self::Variant {\n+        &self.sty\n+    }\n+}\n+\n+impl<'tcx> EncodableWithShorthand for ty::Predicate<'tcx> {\n+    type Variant = ty::Predicate<'tcx>;\n+    fn variant(&self) -> &Self::Variant {\n+        self\n+    }\n+}\n+\n+pub trait TyEncoder: Encoder {\n+    fn position(&self) -> usize;\n+}\n+\n+/// Encode the given value or a previously cached shorthand.\n+pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n+                                      value: &T,\n+                                      cache: M)\n+                                      -> Result<(), E::Error>\n+    where E: TyEncoder,\n+          M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n+          T: EncodableWithShorthand,\n+{\n+    let existing_shorthand = cache(encoder).get(value).cloned();\n+    if let Some(shorthand) = existing_shorthand {\n+        return encoder.emit_usize(shorthand);\n+    }\n+\n+    let variant = value.variant();\n+\n+    let start = encoder.position();\n+    variant.encode(encoder)?;\n+    let len = encoder.position() - start;\n+\n+    // The shorthand encoding uses the same usize as the\n+    // discriminant, with an offset so they can't conflict.\n+    let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n+    assert!(discriminant < SHORTHAND_OFFSET as u64);\n+    let shorthand = start + SHORTHAND_OFFSET;\n+\n+    // Get the number of bits that leb128 could fit\n+    // in the same space as the fully encoded type.\n+    let leb128_bits = len * 7;\n+\n+    // Check that the shorthand is a not longer than the\n+    // full encoding itself, i.e. it's an obvious win.\n+    if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n+        cache(encoder).insert(value.clone(), shorthand);\n+    }\n+\n+    Ok(())\n+}\n+\n+pub fn encode_predicates<'tcx, E, C>(encoder: &mut E,\n+                                     predicates: &ty::GenericPredicates<'tcx>,\n+                                     cache: C)\n+                                     -> Result<(), E::Error>\n+    where E: TyEncoder,\n+          C: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<ty::Predicate<'tcx>, usize>,\n+{\n+    predicates.parent.encode(encoder)?;\n+    predicates.predicates.len().encode(encoder)?;\n+    for predicate in &predicates.predicates {\n+        encode_with_shorthand(encoder, predicate, &cache)?\n+    }\n+    Ok(())\n+}\n+\n+pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n+\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+\n+    fn peek_byte(&self) -> u8;\n+\n+    fn cached_ty_for_shorthand<F>(&mut self,\n+                                  shorthand: usize,\n+                                  or_insert_with: F)\n+                                  -> Result<Ty<'tcx>, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R;\n+\n+    fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum;\n+\n+    fn positioned_at_shorthand(&self) -> bool {\n+        (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n+    }\n+}\n+\n+pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n+    Ok(decoder.map_encoded_cnum_to_current(cnum))\n+}\n+\n+pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    // Handle shorthands first, if we have an usize > 0x80.\n+    // if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+    if decoder.positioned_at_shorthand() {\n+        let pos = decoder.read_usize()?;\n+        assert!(pos >= SHORTHAND_OFFSET);\n+        let shorthand = pos - SHORTHAND_OFFSET;\n+\n+        decoder.cached_ty_for_shorthand(shorthand, |decoder| {\n+            decoder.with_position(shorthand, Ty::decode)\n+        })\n+    } else {\n+        let tcx = decoder.tcx();\n+        Ok(tcx.mk_ty(ty::TypeVariants::decode(decoder)?))\n+    }\n+}\n+\n+pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n+                                      -> Result<ty::GenericPredicates<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(ty::GenericPredicates {\n+        parent: Decodable::decode(decoder)?,\n+        predicates: (0..decoder.read_usize()?).map(|_| {\n+                // Handle shorthands first, if we have an usize > 0x80.\n+                if decoder.positioned_at_shorthand() {\n+                    let pos = decoder.read_usize()?;\n+                    assert!(pos >= SHORTHAND_OFFSET);\n+                    let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                    decoder.with_position(shorthand, ty::Predicate::decode)\n+                } else {\n+                    ty::Predicate::decode(decoder)\n+                }\n+            })\n+            .collect::<Result<Vec<_>, _>>()?,\n+    })\n+}\n+\n+pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    let tcx = decoder.tcx();\n+    Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n+}\n+\n+pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+}\n+\n+pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n+                                    -> Result<&'tcx ty::Slice<Ty<'tcx>>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n+}\n+\n+pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n+                                   -> Result<&'tcx ty::AdtDef, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let def_id = DefId::decode(decoder)?;\n+    Ok(decoder.tcx().adt_def(def_id))\n+}\n+\n+pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n+    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let len = decoder.read_usize()?;\n+    Ok(decoder.tcx()\n+              .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+}\n+\n+pub fn decode_byte_array<'a, 'tcx, D>(decoder: &mut D)\n+                                      -> Result<ByteArray<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(ByteArray {\n+        data: decoder.tcx().alloc_byte_array(&Vec::decode(decoder)?)\n+    })\n+}\n+\n+pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n+                                 -> Result<&'tcx ty::Const<'tcx>, D::Error>\n+    where D: TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+}"}, {"sha": "99885e3e637cc0ddcbf333486593e802cb5a83a1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=686d2a7f14d5a8068b70d59476cd564c62a5677d", "patch": "@@ -89,6 +89,7 @@ pub use self::maps::queries;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;\n+pub mod codec;\n pub mod error;\n mod erase_regions;\n pub mod fast_reject;"}, {"sha": "fed0f526033fcb60885a95c8f768476d69c9ffd9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=686d2a7f14d5a8068b70d59476cd564c62a5677d", "patch": "@@ -25,6 +25,7 @@ use rustc::ich::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::codec::{self as ty_codec, TyDecoder};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::DefIdSet;\n \n@@ -143,16 +144,6 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n-    fn with_position<F: FnOnce(&mut Self) -> R, R>(&mut self, pos: usize, f: F) -> R {\n-        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n-        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n-        let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n-        let r = f(self);\n-        self.opaque = old_opaque;\n-        self.lazy_state = old_state;\n-        r\n-    }\n-\n     fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n@@ -208,6 +199,60 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n     }\n }\n \n+\n+impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n+\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+    }\n+\n+    fn peek_byte(&self) -> u8 {\n+        self.opaque.data[self.opaque.position()]\n+    }\n+\n+    fn cached_ty_for_shorthand<F>(&mut self,\n+                                  shorthand: usize,\n+                                  or_insert_with: F)\n+                                  -> Result<Ty<'tcx>, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>\n+    {\n+        let tcx = self.tcx();\n+\n+        let key = ty::CReaderCacheKey {\n+            cnum: self.cdata().cnum,\n+            pos: shorthand,\n+        };\n+\n+        if let Some(&ty) = tcx.rcache.borrow().get(&key) {\n+            return Ok(ty);\n+        }\n+\n+        let ty = or_insert_with(self)?;\n+        tcx.rcache.borrow_mut().insert(key, ty);\n+        Ok(ty)\n+    }\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n+        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n+        let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n+        let r = f(self);\n+        self.opaque = old_opaque;\n+        self.lazy_state = old_state;\n+        r\n+    }\n+\n+    fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n+        if cnum == LOCAL_CRATE {\n+            self.cdata().cnum\n+        } else {\n+            self.cdata().cnum_map.borrow()[cnum]\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n         Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n@@ -302,96 +347,57 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n-        let tcx = self.tcx();\n-\n-        // Handle shorthands first, if we have an usize > 0x80.\n-        if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n-            let pos = self.read_usize()?;\n-            assert!(pos >= SHORTHAND_OFFSET);\n-            let key = ty::CReaderCacheKey {\n-                cnum: self.cdata().cnum,\n-                pos: pos - SHORTHAND_OFFSET,\n-            };\n-            if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n-                return Ok(ty);\n-            }\n-\n-            let ty = self.with_position(key.pos, Ty::decode)?;\n-            tcx.rcache.borrow_mut().insert(key, ty);\n-            Ok(ty)\n-        } else {\n-            Ok(tcx.mk_ty(ty::TypeVariants::decode(self)?))\n-        }\n+        ty_codec::decode_ty(self)\n     }\n }\n \n-\n impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n-        Ok(ty::GenericPredicates {\n-            parent: Decodable::decode(self)?,\n-            predicates: (0..self.read_usize()?).map(|_| {\n-                    // Handle shorthands first, if we have an usize > 0x80.\n-                    if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n-                        let pos = self.read_usize()?;\n-                        assert!(pos >= SHORTHAND_OFFSET);\n-                        let pos = pos - SHORTHAND_OFFSET;\n-\n-                        self.with_position(pos, ty::Predicate::decode)\n-                    } else {\n-                        ty::Predicate::decode(self)\n-                    }\n-                })\n-                .collect::<Result<Vec<_>, _>>()?,\n-        })\n+        ty_codec::decode_predicates(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_substs((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)\n+        ty_codec::decode_substs(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_region(Decodable::decode(self)?))\n+        ty_codec::decode_region(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n-        Ok(self.tcx().mk_type_list((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)\n+        ty_codec::decode_ty_slice(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n-        let def_id = DefId::decode(self)?;\n-        Ok(self.tcx().adt_def(def_id))\n+        ty_codec::decode_adt_def(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n     for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self)\n         -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n-        Ok(self.tcx().mk_existential_predicates((0..self.read_usize()?)\n-                                                .map(|_| Decodable::decode(self)))?)\n+        ty_codec::decode_existential_predicate_slice(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n-        Ok(ByteArray {\n-            data: self.tcx().alloc_byte_array(&Vec::decode(self)?)\n-        })\n+        ty_codec::decode_byte_array(self)\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Const<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        Ok(self.tcx().mk_const(Decodable::decode(self)?))\n+        ty_codec::decode_const(self)\n     }\n }\n "}, {"sha": "bf2c61c13c321980e5db1ceecb614449837974e5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=686d2a7f14d5a8068b70d59476cd564c62a5677d", "patch": "@@ -25,14 +25,13 @@ use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n+use rustc::ty::codec::{self as ty_codec, TyEncoder};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n \n-use std::hash::Hash;\n-use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n@@ -119,28 +118,25 @@ impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n-        self.encode_with_shorthand(ty, &ty.sty, |ecx| &mut ecx.type_shorthands)\n+        ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n     }\n }\n \n impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self,\n                           predicates: &ty::GenericPredicates<'tcx>)\n                           -> Result<(), Self::Error> {\n-        predicates.parent.encode(self)?;\n-        predicates.predicates.len().encode(self)?;\n-        for predicate in &predicates.predicates {\n-            self.encode_with_shorthand(predicate, predicate, |ecx| &mut ecx.predicate_shorthands)?\n-        }\n-        Ok(())\n+        ty_codec::encode_predicates(self, predicates, |ecx| &mut ecx.predicate_shorthands)\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-\n-    pub fn position(&self) -> usize {\n+impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n+    fn position(&self) -> usize {\n         self.opaque.position()\n     }\n+}\n+\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n         assert_eq!(self.lazy_state, LazyState::NoNode);\n@@ -204,44 +200,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    /// Encode the given value or a previously cached shorthand.\n-    fn encode_with_shorthand<T, U, M>(&mut self,\n-                                      value: &T,\n-                                      variant: &U,\n-                                      map: M)\n-                                      -> Result<(), <Self as Encoder>::Error>\n-        where M: for<'b> Fn(&'b mut Self) -> &'b mut FxHashMap<T, usize>,\n-              T: Clone + Eq + Hash,\n-              U: Encodable\n-    {\n-        let existing_shorthand = map(self).get(value).cloned();\n-        if let Some(shorthand) = existing_shorthand {\n-            return self.emit_usize(shorthand);\n-        }\n-\n-        let start = self.position();\n-        variant.encode(self)?;\n-        let len = self.position() - start;\n-\n-        // The shorthand encoding uses the same usize as the\n-        // discriminant, with an offset so they can't conflict.\n-        let discriminant = unsafe { intrinsics::discriminant_value(variant) };\n-        assert!(discriminant < SHORTHAND_OFFSET as u64);\n-        let shorthand = start + SHORTHAND_OFFSET;\n-\n-        // Get the number of bits that leb128 could fit\n-        // in the same space as the fully encoded type.\n-        let leb128_bits = len * 7;\n-\n-        // Check that the shorthand is a not longer than the\n-        // full encoding itself, i.e. it's an obvious win.\n-        if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n-            map(self).insert(value.clone(), shorthand);\n-        }\n-\n-        Ok(())\n-    }\n-\n     // Encodes something that corresponds to a single DepNode::GlobalMetaData\n     // and registers the Fingerprint in the `metadata_hashes` map.\n     pub fn tracked<'x, DATA, R>(&'x mut self,"}, {"sha": "20bdfaea0d0bbf0b294b00c4a0c0de510831f7c3", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=686d2a7f14d5a8068b70d59476cd564c62a5677d", "patch": "@@ -15,7 +15,6 @@\n \n #![feature(box_patterns)]\n #![feature(conservative_impl_trait)]\n-#![feature(core_intrinsics)]\n #![feature(i128_type)]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "e1d127d3516b47348412cbb0398792526bbd5f46", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/686d2a7f14d5a8068b70d59476cd564c62a5677d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=686d2a7f14d5a8068b70d59476cd564c62a5677d", "patch": "@@ -53,11 +53,6 @@ pub const METADATA_VERSION: u8 = 4;\n pub const METADATA_HEADER: &'static [u8; 12] =\n     &[0, 0, 0, 0, b'r', b'u', b's', b't', 0, 0, 0, METADATA_VERSION];\n \n-/// The shorthand encoding uses an enum's variant index `usize`\n-/// and is offset by this value so it never matches a real variant.\n-/// This offset is also chosen so that the first byte is never < 0x80.\n-pub const SHORTHAND_OFFSET: usize = 0x80;\n-\n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n ///"}]}