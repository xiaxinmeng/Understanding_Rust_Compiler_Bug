{"sha": "d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYmU5OGU5ZjVlNzIxYjUzZGNjZDBhNDNjMmZmNThkZGQzMmFjNDc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-15T15:08:52Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-15T23:57:47Z"}, "message": "libcore,std,syntax,rustc: move tests into `mod tests`, make them private (no pub mod or pub fn).", "tree": {"sha": "2c1730e5ca7b3352854e92b51a7d0b44e5984438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c1730e5ca7b3352854e92b51a7d0b44e5984438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "html_url": "https://github.com/rust-lang/rust/commit/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f10cf26e25c75e148d86dd151a210d9f4a7ece2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f10cf26e25c75e148d86dd151a210d9f4a7ece2f", "html_url": "https://github.com/rust-lang/rust/commit/f10cf26e25c75e148d86dd151a210d9f4a7ece2f"}], "stats": {"total": 2395, "additions": 1211, "deletions": 1184}, "files": [{"sha": "337b0722ce7ab51a016de54cccaea87afa73fd59", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -277,45 +277,48 @@ pub mod raw {\n     pub unsafe fn reserve_at_least<T>(v: &mut @[T], n: uint) {\n         reserve(v, uint::next_power_of_two(n));\n     }\n-\n }\n \n-#[test]\n-pub fn test() {\n-    // Some code that could use that, then:\n-    fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-        do build |push| {\n-            for uint::range(lo, hi) |i| {\n-                push(i);\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test() {\n+        // Some code that could use that, then:\n+        fn seq_range(lo: uint, hi: uint) -> @[uint] {\n+            do build |push| {\n+                for uint::range(lo, hi) |i| {\n+                    push(i);\n+                }\n             }\n         }\n-    }\n \n-    assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n-    assert!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n-    assert!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n-}\n-\n-#[test]\n-pub fn append_test() {\n-    assert!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n-}\n+        assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n+        assert!(from_fn(5, |x| x+1) == @[1, 2, 3, 4, 5]);\n+        assert!(from_elem(5, 3.14) == @[3.14, 3.14, 3.14, 3.14, 3.14]);\n+    }\n \n-#[test]\n-pub fn test_from_owned() {\n-    assert!(from_owned::<int>(~[]) == @[]);\n-    assert!(from_owned(~[true]) == @[true]);\n-    assert!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-    assert!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n-    assert!(from_owned(~[~[42]]) == @[~[42]]);\n-}\n+    #[test]\n+    fn append_test() {\n+        assert!(@[1,2,3] + @[4,5,6] == @[1,2,3,4,5,6]);\n+    }\n \n-#[test]\n-pub fn test_from_slice() {\n-    assert!(from_slice::<int>([]) == @[]);\n-    assert!(from_slice([true]) == @[true]);\n-    assert!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n-    assert!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n-    assert!(from_slice([@[42]]) == @[@[42]]);\n-}\n+    #[test]\n+    fn test_from_owned() {\n+        assert!(from_owned::<int>(~[]) == @[]);\n+        assert!(from_owned(~[true]) == @[true]);\n+        assert!(from_owned(~[1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+        assert!(from_owned(~[~\"abc\", ~\"123\"]) == @[~\"abc\", ~\"123\"]);\n+        assert!(from_owned(~[~[42]]) == @[~[42]]);\n+    }\n \n+    #[test]\n+    fn test_from_slice() {\n+        assert!(from_slice::<int>([]) == @[]);\n+        assert!(from_slice([true]) == @[true]);\n+        assert!(from_slice([1, 2, 3, 4, 5]) == @[1, 2, 3, 4, 5]);\n+        assert!(from_slice([@\"abc\", @\"123\"]) == @[@\"abc\", @\"123\"]);\n+        assert!(from_slice([@[42]]) == @[@[42]]);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "1d214f402f5ac3594711450c86ed9e5c0e1b7947", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -111,16 +111,16 @@ pub unsafe fn copy_lifetime_vec<'a,S,T>(_ptr: &'a [S], ptr: &T) -> &'a T {\n  ****************************************************************************/\n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use cast::{bump_box_refcount, reinterpret_cast, transmute};\n \n     #[test]\n-    pub fn test_reinterpret_cast() {\n+    fn test_reinterpret_cast() {\n         assert!(1u == unsafe { reinterpret_cast(&1) });\n     }\n \n     #[test]\n-    pub fn test_bump_box_refcount() {\n+    fn test_bump_box_refcount() {\n         unsafe {\n             let box = @~\"box box box\";       // refcount 1\n             bump_box_refcount(box);         // refcount 2\n@@ -135,7 +135,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn test_transmute() {\n+    fn test_transmute() {\n         use managed::raw::BoxRepr;\n         unsafe {\n             let x = @100u8;\n@@ -146,7 +146,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn test_transmute2() {\n+    fn test_transmute2() {\n         unsafe {\n             assert!(~[76u8, 0u8] == transmute(~\"L\"));\n         }"}, {"sha": "f8b046e5b8c4f656b0735cbe3398e5730cf0831e", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -426,12 +426,12 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use either::Right;\n     use super::{Chan, Port, oneshot, recv_one, stream};\n \n     #[test]\n-    pub fn test_select2() {\n+    fn test_select2() {\n         let (p1, c1) = stream();\n         let (p2, c2) = stream();\n \n@@ -446,7 +446,7 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn test_oneshot() {\n+    fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n         oneshot::client::send(c, ());"}, {"sha": "ba1f8cebdb01cf5fbf4db13a3e4c27840bae1b89", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 158, "deletions": 152, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -357,170 +357,176 @@ impl Streaming for SipState {\n     }\n }\n \n-#[test]\n-pub fn test_siphash() {\n-    let vecs : [[u8, ..8], ..64] = [\n-        [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-        [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-        [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-        [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-        [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-        [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-        [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-        [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-        [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-        [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-        [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-        [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-        [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-        [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-        [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-        [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-        [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-        [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-        [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-        [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-        [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-        [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-        [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-        [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-        [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-        [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-        [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-        [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-        [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-        [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-        [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-        [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-        [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-        [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-        [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-        [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-        [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-        [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-        [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-        [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-        [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-        [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-        [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-        [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-        [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-        [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-        [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-        [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-        [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-        [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-        [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-        [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-        [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-        [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-        [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-        [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-        [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-        [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-        [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-        [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-        [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-        [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-        [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-        [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n-    ];\n-\n-    let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n-    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-    let mut buf : ~[u8] = ~[];\n-    let mut t = 0;\n-    let stream_inc = &State(k0,k1);\n-    let stream_full = &State(k0,k1);\n-\n-    fn to_hex_str(r:  &[u8, ..8]) -> ~str {\n-        let mut s = ~\"\";\n-        for vec::each(*r) |b| {\n-            s += uint::to_str_radix(*b as uint, 16u);\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_siphash() {\n+        let vecs : [[u8, ..8], ..64] = [\n+            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n+            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n+            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n+            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n+            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n+            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n+            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n+            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n+            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n+            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n+            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n+            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n+            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n+            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n+            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n+            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n+            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n+            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n+            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n+            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n+            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n+            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n+            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n+            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n+            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n+            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n+            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n+            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n+            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n+            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n+            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n+            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n+            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n+            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n+            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n+            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n+            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n+            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n+            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n+            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n+            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n+            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n+            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n+            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n+            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n+            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n+            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n+            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n+            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n+            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n+            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n+            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n+            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n+            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n+            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n+            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n+            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n+            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n+            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n+            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n+            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n+            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n+            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n+            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n+        ];\n+\n+        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n+        let mut buf : ~[u8] = ~[];\n+        let mut t = 0;\n+        let stream_inc = &State(k0,k1);\n+        let stream_full = &State(k0,k1);\n+\n+        fn to_hex_str(r:  &[u8, ..8]) -> ~str {\n+            let mut s = ~\"\";\n+            for vec::each(*r) |b| {\n+                s += uint::to_str_radix(*b as uint, 16u);\n+            }\n+            s\n         }\n-        s\n-    }\n \n-    while t < 64 {\n-        debug!(\"siphash test %?\", t);\n-        let vec = u8to64_le!(vecs[t], 0);\n-        let out = buf.hash_keyed(k0, k1);\n-        debug!(\"got %?, expected %?\", out, vec);\n-        assert!(vec == out);\n+        while t < 64 {\n+            debug!(\"siphash test %?\", t);\n+            let vec = u8to64_le!(vecs[t], 0);\n+            let out = buf.hash_keyed(k0, k1);\n+            debug!(\"got %?, expected %?\", out, vec);\n+            assert!(vec == out);\n \n-        stream_full.reset();\n-        stream_full.input(buf);\n-        let f = stream_full.result_str();\n-        let i = stream_inc.result_str();\n-        let v = to_hex_str(&vecs[t]);\n-        debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n+            stream_full.reset();\n+            stream_full.input(buf);\n+            let f = stream_full.result_str();\n+            let i = stream_inc.result_str();\n+            let v = to_hex_str(&vecs[t]);\n+            debug!(\"%d: (%s) => inc=%s full=%s\", t, v, i, f);\n \n-        assert!(f == i && f == v);\n+            assert!(f == i && f == v);\n \n-        buf += ~[t as u8];\n-        stream_inc.input(~[t as u8]);\n+            buf += ~[t as u8];\n+            stream_inc.input(~[t as u8]);\n \n-        t += 1;\n+            t += 1;\n+        }\n     }\n-}\n \n-#[test] #[cfg(target_arch = \"arm\")]\n-pub fn test_hash_uint() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!((val as u64).hash() != (val as uint).hash());\n-    assert!((val as u32).hash() == (val as uint).hash());\n-}\n-#[test] #[cfg(target_arch = \"x86_64\")]\n-pub fn test_hash_uint() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!((val as u64).hash() == (val as uint).hash());\n-    assert!((val as u32).hash() != (val as uint).hash());\n-}\n-#[test] #[cfg(target_arch = \"x86\")]\n-pub fn test_hash_uint() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-    assert!((val as u64).hash() != (val as uint).hash());\n-    assert!((val as u32).hash() == (val as uint).hash());\n-}\n+    #[test] #[cfg(target_arch = \"arm\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!((val as u64).hash() != (val as uint).hash());\n+        assert!((val as u32).hash() == (val as uint).hash());\n+    }\n+    #[test] #[cfg(target_arch = \"x86_64\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!((val as u64).hash() == (val as uint).hash());\n+        assert!((val as u32).hash() != (val as uint).hash());\n+    }\n+    #[test] #[cfg(target_arch = \"x86\")]\n+    fn test_hash_uint() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!((val as u64).hash() != (val as uint).hash());\n+        assert!((val as u32).hash() == (val as uint).hash());\n+    }\n \n-#[test]\n-pub fn test_hash_idempotent() {\n-    let val64 = 0xdeadbeef_deadbeef_u64;\n-    val64.hash() == val64.hash();\n-    let val32 = 0xdeadbeef_u32;\n-    val32.hash() == val32.hash();\n-}\n+    #[test]\n+    fn test_hash_idempotent() {\n+        let val64 = 0xdeadbeef_deadbeef_u64;\n+        val64.hash() == val64.hash();\n+        let val32 = 0xdeadbeef_u32;\n+        val32.hash() == val32.hash();\n+    }\n \n-#[test]\n-pub fn test_hash_no_bytes_dropped_64() {\n-    let val = 0xdeadbeef_deadbeef_u64;\n-\n-    assert!(val.hash() != zero_byte(val, 0).hash());\n-    assert!(val.hash() != zero_byte(val, 1).hash());\n-    assert!(val.hash() != zero_byte(val, 2).hash());\n-    assert!(val.hash() != zero_byte(val, 3).hash());\n-    assert!(val.hash() != zero_byte(val, 4).hash());\n-    assert!(val.hash() != zero_byte(val, 5).hash());\n-    assert!(val.hash() != zero_byte(val, 6).hash());\n-    assert!(val.hash() != zero_byte(val, 7).hash());\n-\n-    fn zero_byte(val: u64, byte: uint) -> u64 {\n-        assert!(byte < 8);\n-        val & !(0xff << (byte * 8))\n+    #[test]\n+    fn test_hash_no_bytes_dropped_64() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+\n+        assert!(val.hash() != zero_byte(val, 0).hash());\n+        assert!(val.hash() != zero_byte(val, 1).hash());\n+        assert!(val.hash() != zero_byte(val, 2).hash());\n+        assert!(val.hash() != zero_byte(val, 3).hash());\n+        assert!(val.hash() != zero_byte(val, 4).hash());\n+        assert!(val.hash() != zero_byte(val, 5).hash());\n+        assert!(val.hash() != zero_byte(val, 6).hash());\n+        assert!(val.hash() != zero_byte(val, 7).hash());\n+\n+        fn zero_byte(val: u64, byte: uint) -> u64 {\n+            assert!(byte < 8);\n+            val & !(0xff << (byte * 8))\n+        }\n     }\n-}\n \n-#[test]\n-pub fn test_hash_no_bytes_dropped_32() {\n-    let val = 0xdeadbeef_u32;\n+    #[test]\n+    fn test_hash_no_bytes_dropped_32() {\n+        let val = 0xdeadbeef_u32;\n \n-    assert!(val.hash() != zero_byte(val, 0).hash());\n-    assert!(val.hash() != zero_byte(val, 1).hash());\n-    assert!(val.hash() != zero_byte(val, 2).hash());\n-    assert!(val.hash() != zero_byte(val, 3).hash());\n+        assert!(val.hash() != zero_byte(val, 0).hash());\n+        assert!(val.hash() != zero_byte(val, 1).hash());\n+        assert!(val.hash() != zero_byte(val, 2).hash());\n+        assert!(val.hash() != zero_byte(val, 3).hash());\n \n-    fn zero_byte(val: u32, byte: uint) -> u32 {\n-        assert!(byte < 4);\n-        val & !(0xff << (byte * 8))\n+        fn zero_byte(val: u32, byte: uint) -> u32 {\n+            assert!(byte < 4);\n+            val & !(0xff << (byte * 8))\n+        }\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "3efe21fc42cdbbf782737ac6434ddee6a5e3500b", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -847,7 +847,7 @@ mod test_map {\n     use uint;\n \n     #[test]\n-    pub fn test_insert() {\n+    fn test_insert() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 4));\n@@ -869,7 +869,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_insert_overwrite() {\n+    fn test_insert_overwrite() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(*m.get(&1) == 2);\n@@ -878,7 +878,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_insert_conflicts() {\n+    fn test_insert_conflicts() {\n         let mut m = linear_map_with_capacity(4);\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n@@ -889,7 +889,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_conflict_remove() {\n+    fn test_conflict_remove() {\n         let mut m = linear_map_with_capacity(4);\n         assert!(m.insert(1, 2));\n         assert!(m.insert(5, 3));\n@@ -900,7 +900,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_is_empty() {\n+    fn test_is_empty() {\n         let mut m = linear_map_with_capacity(4);\n         assert!(m.insert(1, 2));\n         assert!(!m.is_empty());\n@@ -909,37 +909,37 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_pop() {\n+    fn test_pop() {\n         let mut m = HashMap::new();\n         m.insert(1, 2);\n         assert!(m.pop(&1) == Some(2));\n         assert!(m.pop(&1) == None);\n     }\n \n     #[test]\n-    pub fn test_swap() {\n+    fn test_swap() {\n         let mut m = HashMap::new();\n         assert!(m.swap(1, 2) == None);\n         assert!(m.swap(1, 3) == Some(2));\n         assert!(m.swap(1, 4) == Some(3));\n     }\n \n     #[test]\n-    pub fn test_find_or_insert() {\n+    fn test_find_or_insert() {\n         let mut m = HashMap::new::<int, int>();\n         assert!(m.find_or_insert(1, 2) == &2);\n         assert!(m.find_or_insert(1, 3) == &2);\n     }\n \n     #[test]\n-    pub fn test_find_or_insert_with() {\n+    fn test_find_or_insert_with() {\n         let mut m = HashMap::new::<int, int>();\n         assert!(m.find_or_insert_with(1, |_| 2) == &2);\n         assert!(m.find_or_insert_with(1, |_| 3) == &2);\n     }\n \n     #[test]\n-    pub fn test_consume() {\n+    fn test_consume() {\n         let mut m = HashMap::new();\n         assert!(m.insert(1, 2));\n         assert!(m.insert(2, 3));\n@@ -954,7 +954,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_iterate() {\n+    fn test_iterate() {\n         let mut m = linear_map_with_capacity(4);\n         for uint::range(0, 32) |i| {\n             assert!(m.insert(i, i*2));\n@@ -968,7 +968,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_find() {\n+    fn test_find() {\n         let mut m = HashMap::new();\n         assert!(m.find(&1).is_none());\n         m.insert(1, 2);\n@@ -979,7 +979,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_eq() {\n+    fn test_eq() {\n         let mut m1 = HashMap::new();\n         m1.insert(1, 2);\n         m1.insert(2, 3);\n@@ -997,7 +997,7 @@ mod test_map {\n     }\n \n     #[test]\n-    pub fn test_expand() {\n+    fn test_expand() {\n         let mut m = HashMap::new();\n \n         assert!(m.len() == 0);"}, {"sha": "488756787b5cd13440b4dbda04ab6f66e7cec80e", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 199, "deletions": 196, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -29,7 +29,6 @@ use from_str;\n \n #[cfg(notest)] use cmp::{Eq, Ord};\n #[cfg(notest)] use ops;\n-#[cfg(test)] use option::{Some, None};\n \n pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n@@ -142,7 +141,7 @@ pub fn to_str_radix(num: float, radix: uint) -> ~str {\n     let (r, special) = strconv::to_str_common(\n         &num, radix, true, strconv::SignNeg, strconv::DigAll);\n     if special { fail!(~\"number has a special value, \\\n-                      try to_str_radix_special() if those are expected\") }\n+                         try to_str_radix_special() if those are expected\") }\n     r\n }\n \n@@ -177,12 +176,6 @@ pub fn to_str_exact(num: float, digits: uint) -> ~str {\n     r\n }\n \n-#[test]\n-pub fn test_to_str_exact_do_decimal() {\n-    let s = to_str_exact(5.0, 4u);\n-    assert!(s == ~\"5.0000\");\n-}\n-\n /**\n  * Converts a float to a string with a maximum number of\n  * significant digits\n@@ -474,195 +467,205 @@ impl ops::Neg<float> for float {\n     fn neg(&self) -> float { -*self }\n }\n \n-#[test]\n-pub fn test_from_str() {\n-   assert!(from_str(~\"3\") == Some(3.));\n-   assert!(from_str(~\"3.14\") == Some(3.14));\n-   assert!(from_str(~\"+3.14\") == Some(3.14));\n-   assert!(from_str(~\"-3.14\") == Some(-3.14));\n-   assert!(from_str(~\"2.5E10\") == Some(25000000000.));\n-   assert!(from_str(~\"2.5e10\") == Some(25000000000.));\n-   assert!(from_str(~\"25000000000.E-10\") == Some(2.5));\n-   assert!(from_str(~\".\") == Some(0.));\n-   assert!(from_str(~\".e1\") == Some(0.));\n-   assert!(from_str(~\".e-1\") == Some(0.));\n-   assert!(from_str(~\"5.\") == Some(5.));\n-   assert!(from_str(~\".5\") == Some(0.5));\n-   assert!(from_str(~\"0.5\") == Some(0.5));\n-   assert!(from_str(~\"-.5\") == Some(-0.5));\n-   assert!(from_str(~\"-5\") == Some(-5.));\n-   assert!(from_str(~\"inf\") == Some(infinity));\n-   assert!(from_str(~\"+inf\") == Some(infinity));\n-   assert!(from_str(~\"-inf\") == Some(neg_infinity));\n-   // note: NaN != NaN, hence this slightly complex test\n-   match from_str(~\"NaN\") {\n-       Some(f) => assert!(is_NaN(f)),\n-       None => fail!()\n-   }\n-   // note: -0 == 0, hence these slightly more complex tests\n-   match from_str(~\"-0\") {\n-       Some(v) if is_zero(v) => assert!(is_negative(v)),\n-       _ => fail!()\n-   }\n-   match from_str(~\"0\") {\n-       Some(v) if is_zero(v) => assert!(is_positive(v)),\n-       _ => fail!()\n-   }\n-\n-   assert!(from_str(~\"\").is_none());\n-   assert!(from_str(~\"x\").is_none());\n-   assert!(from_str(~\" \").is_none());\n-   assert!(from_str(~\"   \").is_none());\n-   assert!(from_str(~\"e\").is_none());\n-   assert!(from_str(~\"E\").is_none());\n-   assert!(from_str(~\"E1\").is_none());\n-   assert!(from_str(~\"1e1e1\").is_none());\n-   assert!(from_str(~\"1e1.1\").is_none());\n-   assert!(from_str(~\"1e1-1\").is_none());\n-}\n-\n-#[test]\n-pub fn test_from_str_hex() {\n-   assert!(from_str_hex(~\"a4\") == Some(164.));\n-   assert!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n-   assert!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n-   assert!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n-   assert!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n-   assert!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n-   assert!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n-   assert!(from_str_hex(~\".\") == Some(0.));\n-   assert!(from_str_hex(~\".p1\") == Some(0.));\n-   assert!(from_str_hex(~\".p-1\") == Some(0.));\n-   assert!(from_str_hex(~\"f.\") == Some(15.));\n-   assert!(from_str_hex(~\".f\") == Some(0.9375));\n-   assert!(from_str_hex(~\"0.f\") == Some(0.9375));\n-   assert!(from_str_hex(~\"-.f\") == Some(-0.9375));\n-   assert!(from_str_hex(~\"-f\") == Some(-15.));\n-   assert!(from_str_hex(~\"inf\") == Some(infinity));\n-   assert!(from_str_hex(~\"+inf\") == Some(infinity));\n-   assert!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n-   // note: NaN != NaN, hence this slightly complex test\n-   match from_str_hex(~\"NaN\") {\n-       Some(f) => assert!(is_NaN(f)),\n-       None => fail!()\n-   }\n-   // note: -0 == 0, hence these slightly more complex tests\n-   match from_str_hex(~\"-0\") {\n-       Some(v) if is_zero(v) => assert!(is_negative(v)),\n-       _ => fail!()\n-   }\n-   match from_str_hex(~\"0\") {\n-       Some(v) if is_zero(v) => assert!(is_positive(v)),\n-       _ => fail!()\n-   }\n-   assert!(from_str_hex(~\"e\") == Some(14.));\n-   assert!(from_str_hex(~\"E\") == Some(14.));\n-   assert!(from_str_hex(~\"E1\") == Some(225.));\n-   assert!(from_str_hex(~\"1e1e1\") == Some(123361.));\n-   assert!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n-\n-   assert!(from_str_hex(~\"\").is_none());\n-   assert!(from_str_hex(~\"x\").is_none());\n-   assert!(from_str_hex(~\" \").is_none());\n-   assert!(from_str_hex(~\"   \").is_none());\n-   assert!(from_str_hex(~\"p\").is_none());\n-   assert!(from_str_hex(~\"P\").is_none());\n-   assert!(from_str_hex(~\"P1\").is_none());\n-   assert!(from_str_hex(~\"1p1p1\").is_none());\n-   assert!(from_str_hex(~\"1p1.1\").is_none());\n-   assert!(from_str_hex(~\"1p1-1\").is_none());\n-}\n-\n-#[test]\n-pub fn test_to_str_hex() {\n-   assert!(to_str_hex(164.) == ~\"a4\");\n-   assert!(to_str_hex(164.9921875) == ~\"a4.fe\");\n-   assert!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n-   assert!(to_str_hex(0xff00 as float) == ~\"ff00\");\n-   assert!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n-   assert!(to_str_hex(0.) == ~\"0\");\n-   assert!(to_str_hex(15.) == ~\"f\");\n-   assert!(to_str_hex(-15.) == ~\"-f\");\n-   assert!(to_str_hex(0.9375) == ~\"0.f\");\n-   assert!(to_str_hex(-0.9375) == ~\"-0.f\");\n-   assert!(to_str_hex(infinity) == ~\"inf\");\n-   assert!(to_str_hex(neg_infinity) == ~\"-inf\");\n-   assert!(to_str_hex(NaN) == ~\"NaN\");\n-   assert!(to_str_hex(0.) == ~\"0\");\n-   assert!(to_str_hex(-0.) == ~\"-0\");\n-}\n-\n-#[test]\n-pub fn test_to_str_radix() {\n-   assert!(to_str_radix(36., 36u) == ~\"10\");\n-   assert!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n-}\n-\n-#[test]\n-pub fn test_from_str_radix() {\n-   assert!(from_str_radix(~\"10\", 36u) == Some(36.));\n-   assert!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n-}\n-\n-#[test]\n-pub fn test_positive() {\n-  assert!((is_positive(infinity)));\n-  assert!((is_positive(1.)));\n-  assert!((is_positive(0.)));\n-  assert!((!is_positive(-1.)));\n-  assert!((!is_positive(neg_infinity)));\n-  assert!((!is_positive(1./neg_infinity)));\n-  assert!((!is_positive(NaN)));\n-}\n-\n-#[test]\n-pub fn test_negative() {\n-  assert!((!is_negative(infinity)));\n-  assert!((!is_negative(1.)));\n-  assert!((!is_negative(0.)));\n-  assert!((is_negative(-1.)));\n-  assert!((is_negative(neg_infinity)));\n-  assert!((is_negative(1./neg_infinity)));\n-  assert!((!is_negative(NaN)));\n-}\n-\n-#[test]\n-pub fn test_nonpositive() {\n-  assert!((!is_nonpositive(infinity)));\n-  assert!((!is_nonpositive(1.)));\n-  assert!((!is_nonpositive(0.)));\n-  assert!((is_nonpositive(-1.)));\n-  assert!((is_nonpositive(neg_infinity)));\n-  assert!((is_nonpositive(1./neg_infinity)));\n-  assert!((!is_nonpositive(NaN)));\n-}\n-\n-#[test]\n-pub fn test_nonnegative() {\n-  assert!((is_nonnegative(infinity)));\n-  assert!((is_nonnegative(1.)));\n-  assert!((is_nonnegative(0.)));\n-  assert!((!is_nonnegative(-1.)));\n-  assert!((!is_nonnegative(neg_infinity)));\n-  assert!((!is_nonnegative(1./neg_infinity)));\n-  assert!((!is_nonnegative(NaN)));\n-}\n-\n-#[test]\n-pub fn test_to_str_inf() {\n-    assert!(to_str_digits(infinity, 10u) == ~\"inf\");\n-    assert!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n-}\n-\n-#[test]\n-pub fn test_round() {\n-    assert!(round(5.8) == 6.0);\n-    assert!(round(5.2) == 5.0);\n-    assert!(round(3.0) == 3.0);\n-    assert!(round(2.5) == 3.0);\n-    assert!(round(-3.5) == -4.0);\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+    #[test]\n+    pub fn test_to_str_exact_do_decimal() {\n+        let s = to_str_exact(5.0, 4u);\n+        assert!(s == ~\"5.0000\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_str() {\n+        assert!(from_str(~\"3\") == Some(3.));\n+        assert!(from_str(~\"3.14\") == Some(3.14));\n+        assert!(from_str(~\"+3.14\") == Some(3.14));\n+        assert!(from_str(~\"-3.14\") == Some(-3.14));\n+        assert!(from_str(~\"2.5E10\") == Some(25000000000.));\n+        assert!(from_str(~\"2.5e10\") == Some(25000000000.));\n+        assert!(from_str(~\"25000000000.E-10\") == Some(2.5));\n+        assert!(from_str(~\".\") == Some(0.));\n+        assert!(from_str(~\".e1\") == Some(0.));\n+        assert!(from_str(~\".e-1\") == Some(0.));\n+        assert!(from_str(~\"5.\") == Some(5.));\n+        assert!(from_str(~\".5\") == Some(0.5));\n+        assert!(from_str(~\"0.5\") == Some(0.5));\n+        assert!(from_str(~\"-.5\") == Some(-0.5));\n+        assert!(from_str(~\"-5\") == Some(-5.));\n+        assert!(from_str(~\"inf\") == Some(infinity));\n+        assert!(from_str(~\"+inf\") == Some(infinity));\n+        assert!(from_str(~\"-inf\") == Some(neg_infinity));\n+        // note: NaN != NaN, hence this slightly complex test\n+        match from_str(~\"NaN\") {\n+            Some(f) => assert!(is_NaN(f)),\n+            None => fail!()\n+        }\n+        // note: -0 == 0, hence these slightly more complex tests\n+        match from_str(~\"-0\") {\n+            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            _ => fail!()\n+        }\n+        match from_str(~\"0\") {\n+            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            _ => fail!()\n+        }\n+\n+        assert!(from_str(~\"\").is_none());\n+        assert!(from_str(~\"x\").is_none());\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"   \").is_none());\n+        assert!(from_str(~\"e\").is_none());\n+        assert!(from_str(~\"E\").is_none());\n+        assert!(from_str(~\"E1\").is_none());\n+        assert!(from_str(~\"1e1e1\").is_none());\n+        assert!(from_str(~\"1e1.1\").is_none());\n+        assert!(from_str(~\"1e1-1\").is_none());\n+    }\n+\n+    #[test]\n+    pub fn test_from_str_hex() {\n+        assert!(from_str_hex(~\"a4\") == Some(164.));\n+        assert!(from_str_hex(~\"a4.fe\") == Some(164.9921875));\n+        assert!(from_str_hex(~\"-a4.fe\") == Some(-164.9921875));\n+        assert!(from_str_hex(~\"+a4.fe\") == Some(164.9921875));\n+        assert!(from_str_hex(~\"ff0P4\") == Some(0xff00 as float));\n+        assert!(from_str_hex(~\"ff0p4\") == Some(0xff00 as float));\n+        assert!(from_str_hex(~\"ff0p-4\") == Some(0xff as float));\n+        assert!(from_str_hex(~\".\") == Some(0.));\n+        assert!(from_str_hex(~\".p1\") == Some(0.));\n+        assert!(from_str_hex(~\".p-1\") == Some(0.));\n+        assert!(from_str_hex(~\"f.\") == Some(15.));\n+        assert!(from_str_hex(~\".f\") == Some(0.9375));\n+        assert!(from_str_hex(~\"0.f\") == Some(0.9375));\n+        assert!(from_str_hex(~\"-.f\") == Some(-0.9375));\n+        assert!(from_str_hex(~\"-f\") == Some(-15.));\n+        assert!(from_str_hex(~\"inf\") == Some(infinity));\n+        assert!(from_str_hex(~\"+inf\") == Some(infinity));\n+        assert!(from_str_hex(~\"-inf\") == Some(neg_infinity));\n+        // note: NaN != NaN, hence this slightly complex test\n+        match from_str_hex(~\"NaN\") {\n+            Some(f) => assert!(is_NaN(f)),\n+            None => fail!()\n+        }\n+        // note: -0 == 0, hence these slightly more complex tests\n+        match from_str_hex(~\"-0\") {\n+            Some(v) if is_zero(v) => assert!(is_negative(v)),\n+            _ => fail!()\n+        }\n+        match from_str_hex(~\"0\") {\n+            Some(v) if is_zero(v) => assert!(is_positive(v)),\n+            _ => fail!()\n+        }\n+        assert!(from_str_hex(~\"e\") == Some(14.));\n+        assert!(from_str_hex(~\"E\") == Some(14.));\n+        assert!(from_str_hex(~\"E1\") == Some(225.));\n+        assert!(from_str_hex(~\"1e1e1\") == Some(123361.));\n+        assert!(from_str_hex(~\"1e1.1\") == Some(481.0625));\n+\n+        assert!(from_str_hex(~\"\").is_none());\n+        assert!(from_str_hex(~\"x\").is_none());\n+        assert!(from_str_hex(~\" \").is_none());\n+        assert!(from_str_hex(~\"   \").is_none());\n+        assert!(from_str_hex(~\"p\").is_none());\n+        assert!(from_str_hex(~\"P\").is_none());\n+        assert!(from_str_hex(~\"P1\").is_none());\n+        assert!(from_str_hex(~\"1p1p1\").is_none());\n+        assert!(from_str_hex(~\"1p1.1\").is_none());\n+        assert!(from_str_hex(~\"1p1-1\").is_none());\n+    }\n+\n+    #[test]\n+    pub fn test_to_str_hex() {\n+        assert!(to_str_hex(164.) == ~\"a4\");\n+        assert!(to_str_hex(164.9921875) == ~\"a4.fe\");\n+        assert!(to_str_hex(-164.9921875) == ~\"-a4.fe\");\n+        assert!(to_str_hex(0xff00 as float) == ~\"ff00\");\n+        assert!(to_str_hex(-(0xff00 as float)) == ~\"-ff00\");\n+        assert!(to_str_hex(0.) == ~\"0\");\n+        assert!(to_str_hex(15.) == ~\"f\");\n+        assert!(to_str_hex(-15.) == ~\"-f\");\n+        assert!(to_str_hex(0.9375) == ~\"0.f\");\n+        assert!(to_str_hex(-0.9375) == ~\"-0.f\");\n+        assert!(to_str_hex(infinity) == ~\"inf\");\n+        assert!(to_str_hex(neg_infinity) == ~\"-inf\");\n+        assert!(to_str_hex(NaN) == ~\"NaN\");\n+        assert!(to_str_hex(0.) == ~\"0\");\n+        assert!(to_str_hex(-0.) == ~\"-0\");\n+    }\n \n+    #[test]\n+    pub fn test_to_str_radix() {\n+        assert!(to_str_radix(36., 36u) == ~\"10\");\n+        assert!(to_str_radix(8.125, 2u) == ~\"1000.001\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_str_radix() {\n+        assert!(from_str_radix(~\"10\", 36u) == Some(36.));\n+        assert!(from_str_radix(~\"1000.001\", 2u) == Some(8.125));\n+    }\n+\n+    #[test]\n+    pub fn test_positive() {\n+        assert!((is_positive(infinity)));\n+        assert!((is_positive(1.)));\n+        assert!((is_positive(0.)));\n+        assert!((!is_positive(-1.)));\n+        assert!((!is_positive(neg_infinity)));\n+        assert!((!is_positive(1./neg_infinity)));\n+        assert!((!is_positive(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_negative() {\n+        assert!((!is_negative(infinity)));\n+        assert!((!is_negative(1.)));\n+        assert!((!is_negative(0.)));\n+        assert!((is_negative(-1.)));\n+        assert!((is_negative(neg_infinity)));\n+        assert!((is_negative(1./neg_infinity)));\n+        assert!((!is_negative(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_nonpositive() {\n+        assert!((!is_nonpositive(infinity)));\n+        assert!((!is_nonpositive(1.)));\n+        assert!((!is_nonpositive(0.)));\n+        assert!((is_nonpositive(-1.)));\n+        assert!((is_nonpositive(neg_infinity)));\n+        assert!((is_nonpositive(1./neg_infinity)));\n+        assert!((!is_nonpositive(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_nonnegative() {\n+        assert!((is_nonnegative(infinity)));\n+        assert!((is_nonnegative(1.)));\n+        assert!((is_nonnegative(0.)));\n+        assert!((!is_nonnegative(-1.)));\n+        assert!((!is_nonnegative(neg_infinity)));\n+        assert!((!is_nonnegative(1./neg_infinity)));\n+        assert!((!is_nonnegative(NaN)));\n+    }\n+\n+    #[test]\n+    pub fn test_to_str_inf() {\n+        assert!(to_str_digits(infinity, 10u) == ~\"inf\");\n+        assert!(to_str_digits(-infinity, 10u) == ~\"-inf\");\n+    }\n+\n+    #[test]\n+    pub fn test_round() {\n+        assert!(round(5.8) == 6.0);\n+        assert!(round(5.2) == 5.0);\n+        assert!(round(3.0) == 3.0);\n+        assert!(round(2.5) == 3.0);\n+        assert!(round(-3.5) == -4.0);\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "b495f9e7088fe34f88c4954693e2b49701400e63", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 162, "deletions": 155, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -277,181 +277,188 @@ impl ToStrRadix for T {\n     }\n }\n \n-#[test]\n-fn test_from_str() {\n-    assert!(from_str(~\"0\") == Some(0 as T));\n-    assert!(from_str(~\"3\") == Some(3 as T));\n-    assert!(from_str(~\"10\") == Some(10 as T));\n-    assert!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n-    assert!(from_str(~\"00100\") == Some(100 as T));\n-\n-    assert!(from_str(~\"-1\") == Some(-1 as T));\n-    assert!(from_str(~\"-3\") == Some(-3 as T));\n-    assert!(from_str(~\"-10\") == Some(-10 as T));\n-    assert!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n-    assert!(from_str(~\"-00100\") == Some(-100 as T));\n-\n-    assert!(from_str(~\" \").is_none());\n-    assert!(from_str(~\"x\").is_none());\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use super::inst::T;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test_from_str() {\n+        assert!(from_str(~\"0\") == Some(0 as T));\n+        assert!(from_str(~\"3\") == Some(3 as T));\n+        assert!(from_str(~\"10\") == Some(10 as T));\n+        assert!(i32::from_str(~\"123456789\") == Some(123456789 as i32));\n+        assert!(from_str(~\"00100\") == Some(100 as T));\n+\n+        assert!(from_str(~\"-1\") == Some(-1 as T));\n+        assert!(from_str(~\"-3\") == Some(-3 as T));\n+        assert!(from_str(~\"-10\") == Some(-10 as T));\n+        assert!(i32::from_str(~\"-123456789\") == Some(-123456789 as i32));\n+        assert!(from_str(~\"-00100\") == Some(-100 as T));\n+\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"x\").is_none());\n+    }\n \n-#[test]\n-fn test_parse_bytes() {\n-    use str::to_bytes;\n-    assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n-    assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n-    assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n-    assert!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n-                 Some(65535 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n-                 Some(65535 as i32));\n-    assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n-    assert!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n-\n-    assert!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n-    assert!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n-    assert!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n-    assert!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n-                 Some(-291 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n-                 Some(-65535 as i32));\n-    assert!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n-                 Some(-65535 as i32));\n-    assert!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n-    assert!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n-\n-    assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n-    assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n-}\n+    #[test]\n+    fn test_parse_bytes() {\n+        use str::to_bytes;\n+        assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123 as T));\n+        assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9 as T));\n+        assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83 as T));\n+        assert!(i32::parse_bytes(to_bytes(~\"123\"), 16u) == Some(291 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+                Some(65535 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"FFFF\"), 16u) ==\n+                Some(65535 as i32));\n+        assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35 as T));\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 36u) == Some(35 as T));\n+\n+        assert!(parse_bytes(to_bytes(~\"-123\"), 10u) == Some(-123 as T));\n+        assert!(parse_bytes(to_bytes(~\"-1001\"), 2u) == Some(-9 as T));\n+        assert!(parse_bytes(to_bytes(~\"-123\"), 8u) == Some(-83 as T));\n+        assert!(i32::parse_bytes(to_bytes(~\"-123\"), 16u) ==\n+                Some(-291 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"-ffff\"), 16u) ==\n+                Some(-65535 as i32));\n+        assert!(i32::parse_bytes(to_bytes(~\"-FFFF\"), 16u) ==\n+                Some(-65535 as i32));\n+        assert!(parse_bytes(to_bytes(~\"-z\"), 36u) == Some(-35 as T));\n+        assert!(parse_bytes(to_bytes(~\"-Z\"), 36u) == Some(-35 as T));\n+\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 35u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"-9\"), 2u).is_none());\n+    }\n \n-#[test]\n-fn test_to_str() {\n-    assert!((to_str_radix(0 as T, 10u) == ~\"0\"));\n-    assert!((to_str_radix(1 as T, 10u) == ~\"1\"));\n-    assert!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n-    assert!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n-    assert!((to_str_radix(100 as T, 10u) == ~\"100\"));\n+    #[test]\n+    fn test_to_str() {\n+        assert!((to_str_radix(0 as T, 10u) == ~\"0\"));\n+        assert!((to_str_radix(1 as T, 10u) == ~\"1\"));\n+        assert!((to_str_radix(-1 as T, 10u) == ~\"-1\"));\n+        assert!((to_str_radix(127 as T, 16u) == ~\"7f\"));\n+        assert!((to_str_radix(100 as T, 10u) == ~\"100\"));\n \n-}\n+    }\n \n-#[test]\n-fn test_int_to_str_overflow() {\n-    let mut i8_val: i8 = 127_i8;\n-    assert!((i8::to_str(i8_val) == ~\"127\"));\n+    #[test]\n+    fn test_int_to_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert!((i8::to_str(i8_val) == ~\"127\"));\n \n-    i8_val += 1 as i8;\n-    assert!((i8::to_str(i8_val) == ~\"-128\"));\n+        i8_val += 1 as i8;\n+        assert!((i8::to_str(i8_val) == ~\"-128\"));\n \n-    let mut i16_val: i16 = 32_767_i16;\n-    assert!((i16::to_str(i16_val) == ~\"32767\"));\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert!((i16::to_str(i16_val) == ~\"32767\"));\n \n-    i16_val += 1 as i16;\n-    assert!((i16::to_str(i16_val) == ~\"-32768\"));\n+        i16_val += 1 as i16;\n+        assert!((i16::to_str(i16_val) == ~\"-32768\"));\n \n-    let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert!((i32::to_str(i32_val) == ~\"2147483647\"));\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert!((i32::to_str(i32_val) == ~\"2147483647\"));\n \n-    i32_val += 1 as i32;\n-    assert!((i32::to_str(i32_val) == ~\"-2147483648\"));\n+        i32_val += 1 as i32;\n+        assert!((i32::to_str(i32_val) == ~\"-2147483648\"));\n \n-    let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert!((i64::to_str(i64_val) == ~\"9223372036854775807\"));\n \n-    i64_val += 1 as i64;\n-    assert!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n-}\n+        i64_val += 1 as i64;\n+        assert!((i64::to_str(i64_val) == ~\"-9223372036854775808\"));\n+    }\n \n-#[test]\n-fn test_int_from_str_overflow() {\n-    let mut i8_val: i8 = 127_i8;\n-    assert!((i8::from_str(~\"127\") == Some(i8_val)));\n-    assert!((i8::from_str(~\"128\").is_none()));\n+    #[test]\n+    fn test_int_from_str_overflow() {\n+        let mut i8_val: i8 = 127_i8;\n+        assert!((i8::from_str(~\"127\") == Some(i8_val)));\n+        assert!((i8::from_str(~\"128\").is_none()));\n \n-    i8_val += 1 as i8;\n-    assert!((i8::from_str(~\"-128\") == Some(i8_val)));\n-    assert!((i8::from_str(~\"-129\").is_none()));\n+        i8_val += 1 as i8;\n+        assert!((i8::from_str(~\"-128\") == Some(i8_val)));\n+        assert!((i8::from_str(~\"-129\").is_none()));\n \n-    let mut i16_val: i16 = 32_767_i16;\n-    assert!((i16::from_str(~\"32767\") == Some(i16_val)));\n-    assert!((i16::from_str(~\"32768\").is_none()));\n+        let mut i16_val: i16 = 32_767_i16;\n+        assert!((i16::from_str(~\"32767\") == Some(i16_val)));\n+        assert!((i16::from_str(~\"32768\").is_none()));\n \n-    i16_val += 1 as i16;\n-    assert!((i16::from_str(~\"-32768\") == Some(i16_val)));\n-    assert!((i16::from_str(~\"-32769\").is_none()));\n+        i16_val += 1 as i16;\n+        assert!((i16::from_str(~\"-32768\") == Some(i16_val)));\n+        assert!((i16::from_str(~\"-32769\").is_none()));\n \n-    let mut i32_val: i32 = 2_147_483_647_i32;\n-    assert!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n-    assert!((i32::from_str(~\"2147483648\").is_none()));\n+        let mut i32_val: i32 = 2_147_483_647_i32;\n+        assert!((i32::from_str(~\"2147483647\") == Some(i32_val)));\n+        assert!((i32::from_str(~\"2147483648\").is_none()));\n \n-    i32_val += 1 as i32;\n-    assert!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n-    assert!((i32::from_str(~\"-2147483649\").is_none()));\n+        i32_val += 1 as i32;\n+        assert!((i32::from_str(~\"-2147483648\") == Some(i32_val)));\n+        assert!((i32::from_str(~\"-2147483649\").is_none()));\n \n-    let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n-    assert!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n-    assert!((i64::from_str(~\"9223372036854775808\").is_none()));\n+        let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n+        assert!((i64::from_str(~\"9223372036854775807\") == Some(i64_val)));\n+        assert!((i64::from_str(~\"9223372036854775808\").is_none()));\n \n-    i64_val += 1 as i64;\n-    assert!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n-    assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n-}\n+        i64_val += 1 as i64;\n+        assert!((i64::from_str(~\"-9223372036854775808\") == Some(i64_val)));\n+        assert!((i64::from_str(~\"-9223372036854775809\").is_none()));\n+    }\n \n-#[test]\n-pub fn test_ranges() {\n-    let mut l = ~[];\n+    #[test]\n+    fn test_ranges() {\n+        let mut l = ~[];\n \n-    for range(0,3) |i| {\n-        l.push(i);\n-    }\n-    for range_rev(13,10) |i| {\n-        l.push(i);\n-    }\n-    for range_step(20,26,2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(36,30,-2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 2, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 3, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 2, min_value, -2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 3, min_value, -2) |i| {\n-        l.push(i);\n-    }\n-    assert_eq!(l, ~[0,1,2,\n-                    13,12,11,\n-                    20,22,24,\n-                    36,34,32,\n-                    max_value-2,\n-                    max_value-3,max_value-1,\n-                    min_value+2,\n-                    min_value+3,min_value+1]);\n-\n-    // None of the `fail`s should execute.\n-    for range(10,0) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_rev(0,10) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_step(10,0,1) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_step(0,10,-1) |_i| {\n-        fail!(~\"unreachable\");\n+        for range(0,3) |i| {\n+            l.push(i);\n+        }\n+        for range_rev(13,10) |i| {\n+            l.push(i);\n+        }\n+        for range_step(20,26,2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(36,30,-2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 2, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 3, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 2, min_value, -2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 3, min_value, -2) |i| {\n+            l.push(i);\n+        }\n+        assert_eq!(l, ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32,\n+                        max_value-2,\n+                        max_value-3,max_value-1,\n+                        min_value+2,\n+                        min_value+3,min_value+1]);\n+\n+        // None of the `fail`s should execute.\n+        for range(10,0) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_rev(0,10) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(10,0,1) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(0,10,-1) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n     }\n-}\n \n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_range_step_zero_step() {\n-    for range_step(0,10,0) |_i| {}\n-}\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_range_step_zero_step() {\n+        for range_step(0,10,0) |_i| {}\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "af6557e9881f254718e72ee4875285acb0aeba7e", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 161, "deletions": 155, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -242,184 +242,190 @@ impl ToStrRadix for T {\n     }\n }\n \n-#[test]\n-pub fn test_to_str() {\n-    assert!(to_str_radix(0 as T, 10u) == ~\"0\");\n-    assert!(to_str_radix(1 as T, 10u) == ~\"1\");\n-    assert!(to_str_radix(2 as T, 10u) == ~\"2\");\n-    assert!(to_str_radix(11 as T, 10u) == ~\"11\");\n-    assert!(to_str_radix(11 as T, 16u) == ~\"b\");\n-    assert!(to_str_radix(255 as T, 16u) == ~\"ff\");\n-    assert!(to_str_radix(0xff as T, 10u) == ~\"255\");\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use super::inst::T;\n+    use prelude::*;\n+    #[test]\n+    pub fn test_to_str() {\n+        assert!(to_str_radix(0 as T, 10u) == ~\"0\");\n+        assert!(to_str_radix(1 as T, 10u) == ~\"1\");\n+        assert!(to_str_radix(2 as T, 10u) == ~\"2\");\n+        assert!(to_str_radix(11 as T, 10u) == ~\"11\");\n+        assert!(to_str_radix(11 as T, 16u) == ~\"b\");\n+        assert!(to_str_radix(255 as T, 16u) == ~\"ff\");\n+        assert!(to_str_radix(0xff as T, 10u) == ~\"255\");\n+    }\n \n-#[test]\n-pub fn test_from_str() {\n-    assert!(from_str(~\"0\") == Some(0u as T));\n-    assert!(from_str(~\"3\") == Some(3u as T));\n-    assert!(from_str(~\"10\") == Some(10u as T));\n-    assert!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n-    assert!(from_str(~\"00100\") == Some(100u as T));\n-\n-    assert!(from_str(~\"\").is_none());\n-    assert!(from_str(~\" \").is_none());\n-    assert!(from_str(~\"x\").is_none());\n-}\n+    #[test]\n+    pub fn test_from_str() {\n+        assert!(from_str(~\"0\") == Some(0u as T));\n+        assert!(from_str(~\"3\") == Some(3u as T));\n+        assert!(from_str(~\"10\") == Some(10u as T));\n+        assert!(u32::from_str(~\"123456789\") == Some(123456789 as u32));\n+        assert!(from_str(~\"00100\") == Some(100u as T));\n+\n+        assert!(from_str(~\"\").is_none());\n+        assert!(from_str(~\" \").is_none());\n+        assert!(from_str(~\"x\").is_none());\n+    }\n \n-#[test]\n-pub fn test_parse_bytes() {\n-    use str::to_bytes;\n-    assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n-    assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n-    assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n-    assert!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n-                 Some(291u as u16));\n-    assert!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n-                 Some(65535u as u16));\n-    assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n-\n-    assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n-    assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n-}\n+    #[test]\n+    pub fn test_parse_bytes() {\n+        use str::to_bytes;\n+        assert!(parse_bytes(to_bytes(~\"123\"), 10u) == Some(123u as T));\n+        assert!(parse_bytes(to_bytes(~\"1001\"), 2u) == Some(9u as T));\n+        assert!(parse_bytes(to_bytes(~\"123\"), 8u) == Some(83u as T));\n+        assert!(u16::parse_bytes(to_bytes(~\"123\"), 16u) ==\n+                Some(291u as u16));\n+        assert!(u16::parse_bytes(to_bytes(~\"ffff\"), 16u) ==\n+                Some(65535u as u16));\n+        assert!(parse_bytes(to_bytes(~\"z\"), 36u) == Some(35u as T));\n+\n+        assert!(parse_bytes(to_bytes(~\"Z\"), 10u).is_none());\n+        assert!(parse_bytes(to_bytes(~\"_\"), 2u).is_none());\n+    }\n \n-#[test]\n-fn test_uint_to_str_overflow() {\n-    let mut u8_val: u8 = 255_u8;\n-    assert!((u8::to_str(u8_val) == ~\"255\"));\n+    #[test]\n+    fn test_uint_to_str_overflow() {\n+        let mut u8_val: u8 = 255_u8;\n+        assert!((u8::to_str(u8_val) == ~\"255\"));\n \n-    u8_val += 1 as u8;\n-    assert!((u8::to_str(u8_val) == ~\"0\"));\n+        u8_val += 1 as u8;\n+        assert!((u8::to_str(u8_val) == ~\"0\"));\n \n-    let mut u16_val: u16 = 65_535_u16;\n-    assert!((u16::to_str(u16_val) == ~\"65535\"));\n+        let mut u16_val: u16 = 65_535_u16;\n+        assert!((u16::to_str(u16_val) == ~\"65535\"));\n \n-    u16_val += 1 as u16;\n-    assert!((u16::to_str(u16_val) == ~\"0\"));\n+        u16_val += 1 as u16;\n+        assert!((u16::to_str(u16_val) == ~\"0\"));\n \n-    let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert!((u32::to_str(u32_val) == ~\"4294967295\"));\n+        let mut u32_val: u32 = 4_294_967_295_u32;\n+        assert!((u32::to_str(u32_val) == ~\"4294967295\"));\n \n-    u32_val += 1 as u32;\n-    assert!((u32::to_str(u32_val) == ~\"0\"));\n+        u32_val += 1 as u32;\n+        assert!((u32::to_str(u32_val) == ~\"0\"));\n \n-    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n+        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+        assert!((u64::to_str(u64_val) == ~\"18446744073709551615\"));\n \n-    u64_val += 1 as u64;\n-    assert!((u64::to_str(u64_val) == ~\"0\"));\n-}\n+        u64_val += 1 as u64;\n+        assert!((u64::to_str(u64_val) == ~\"0\"));\n+    }\n \n-#[test]\n-fn test_uint_from_str_overflow() {\n-    let mut u8_val: u8 = 255_u8;\n-    assert!((u8::from_str(~\"255\") == Some(u8_val)));\n-    assert!((u8::from_str(~\"256\").is_none()));\n+    #[test]\n+    fn test_uint_from_str_overflow() {\n+        let mut u8_val: u8 = 255_u8;\n+        assert!((u8::from_str(~\"255\") == Some(u8_val)));\n+        assert!((u8::from_str(~\"256\").is_none()));\n \n-    u8_val += 1 as u8;\n-    assert!((u8::from_str(~\"0\") == Some(u8_val)));\n-    assert!((u8::from_str(~\"-1\").is_none()));\n+        u8_val += 1 as u8;\n+        assert!((u8::from_str(~\"0\") == Some(u8_val)));\n+        assert!((u8::from_str(~\"-1\").is_none()));\n \n-    let mut u16_val: u16 = 65_535_u16;\n-    assert!((u16::from_str(~\"65535\") == Some(u16_val)));\n-    assert!((u16::from_str(~\"65536\").is_none()));\n+        let mut u16_val: u16 = 65_535_u16;\n+        assert!((u16::from_str(~\"65535\") == Some(u16_val)));\n+        assert!((u16::from_str(~\"65536\").is_none()));\n \n-    u16_val += 1 as u16;\n-    assert!((u16::from_str(~\"0\") == Some(u16_val)));\n-    assert!((u16::from_str(~\"-1\").is_none()));\n+        u16_val += 1 as u16;\n+        assert!((u16::from_str(~\"0\") == Some(u16_val)));\n+        assert!((u16::from_str(~\"-1\").is_none()));\n \n-    let mut u32_val: u32 = 4_294_967_295_u32;\n-    assert!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n-    assert!((u32::from_str(~\"4294967296\").is_none()));\n+        let mut u32_val: u32 = 4_294_967_295_u32;\n+        assert!((u32::from_str(~\"4294967295\") == Some(u32_val)));\n+        assert!((u32::from_str(~\"4294967296\").is_none()));\n \n-    u32_val += 1 as u32;\n-    assert!((u32::from_str(~\"0\") == Some(u32_val)));\n-    assert!((u32::from_str(~\"-1\").is_none()));\n+        u32_val += 1 as u32;\n+        assert!((u32::from_str(~\"0\") == Some(u32_val)));\n+        assert!((u32::from_str(~\"-1\").is_none()));\n \n-    let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n-    assert!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n-    assert!((u64::from_str(~\"18446744073709551616\").is_none()));\n+        let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n+        assert!((u64::from_str(~\"18446744073709551615\") == Some(u64_val)));\n+        assert!((u64::from_str(~\"18446744073709551616\").is_none()));\n \n-    u64_val += 1 as u64;\n-    assert!((u64::from_str(~\"0\") == Some(u64_val)));\n-    assert!((u64::from_str(~\"-1\").is_none()));\n-}\n+        u64_val += 1 as u64;\n+        assert!((u64::from_str(~\"0\") == Some(u64_val)));\n+        assert!((u64::from_str(~\"-1\").is_none()));\n+    }\n \n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-pub fn to_str_radix1() {\n-    uint::to_str_radix(100u, 1u);\n-}\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    pub fn to_str_radix1() {\n+        uint::to_str_radix(100u, 1u);\n+    }\n \n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-pub fn to_str_radix37() {\n-    uint::to_str_radix(100u, 37u);\n-}\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    pub fn to_str_radix37() {\n+        uint::to_str_radix(100u, 37u);\n+    }\n \n-#[test]\n-pub fn test_ranges() {\n-    let mut l = ~[];\n+    #[test]\n+    pub fn test_ranges() {\n+        let mut l = ~[];\n \n-    for range(0,3) |i| {\n-        l.push(i);\n-    }\n-    for range_rev(13,10) |i| {\n-        l.push(i);\n-    }\n-    for range_step(20,26,2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(36,30,-2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 2, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(max_value - 3, max_value, 2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 2, min_value, -2) |i| {\n-        l.push(i);\n-    }\n-    for range_step(min_value + 3, min_value, -2) |i| {\n-        l.push(i);\n-    }\n+        for range(0,3) |i| {\n+            l.push(i);\n+        }\n+        for range_rev(13,10) |i| {\n+            l.push(i);\n+        }\n+        for range_step(20,26,2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(36,30,-2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 2, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(max_value - 3, max_value, 2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 2, min_value, -2) |i| {\n+            l.push(i);\n+        }\n+        for range_step(min_value + 3, min_value, -2) |i| {\n+            l.push(i);\n+        }\n \n-    assert_eq!(l, ~[0,1,2,\n-                    13,12,11,\n-                    20,22,24,\n-                    36,34,32,\n-                    max_value-2,\n-                    max_value-3,max_value-1,\n-                    min_value+2,\n-                    min_value+3,min_value+1]);\n-\n-    // None of the `fail`s should execute.\n-    for range(0,0) |_i| {\n-        fail!(~\"unreachable\");\n-    }\n-    for range_rev(0,0) |_i| {\n-        fail!(~\"unreachable\");\n+        assert_eq!(l, ~[0,1,2,\n+                        13,12,11,\n+                        20,22,24,\n+                        36,34,32,\n+                        max_value-2,\n+                        max_value-3,max_value-1,\n+                        min_value+2,\n+                        min_value+3,min_value+1]);\n+\n+        // None of the `fail`s should execute.\n+        for range(0,0) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_rev(0,0) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(10,0,1) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n+        for range_step(0,1,-10) |_i| {\n+            fail!(~\"unreachable\");\n+        }\n     }\n-    for range_step(10,0,1) |_i| {\n-        fail!(~\"unreachable\");\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_range_step_zero_step_up() {\n+        for range_step(0,10,0) |_i| {}\n     }\n-    for range_step(0,1,-10) |_i| {\n-        fail!(~\"unreachable\");\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn test_range_step_zero_step_down() {\n+        for range_step(0,-10,0) |_i| {}\n     }\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_range_step_zero_step_up() {\n-    for range_step(0,10,0) |_i| {}\n-}\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_range_step_zero_step_down() {\n-    for range_step(0,-10,0) |_i| {}\n-}\n+}\n\\ No newline at end of file"}, {"sha": "fddb2af558709ecbef256b8071ad1bd3e6f6fb1a", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -957,13 +957,13 @@ pub mod rt {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use either::Right;\n     use comm::{Chan, Port, oneshot, recv_one, stream, Select2,\n                GenericChan, Peekable};\n \n     #[test]\n-    pub fn test_select2() {\n+    fn test_select2() {\n         let (p1, c1) = stream();\n         let (p2, c2) = stream();\n \n@@ -978,7 +978,7 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn test_oneshot() {\n+    fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n         oneshot::client::send(c, ());"}, {"sha": "ebde37e77b42fcde6f468ad75a4ab18ac4131026", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 100, "deletions": 102, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -15,8 +15,6 @@ use libc;\n use libc::{c_void, size_t};\n use sys;\n \n-#[cfg(test)] use vec;\n-#[cfg(test)] use str;\n #[cfg(notest)] use cmp::{Eq, Ord};\n use uint;\n \n@@ -341,101 +339,101 @@ impl<'self,T:Ord> Ord for &'self const T {\n     }\n }\n \n-#[test]\n-pub fn test() {\n-    unsafe {\n-        struct Pair {mut fst: int, mut snd: int};\n-        let mut p = Pair {fst: 10, snd: 20};\n-        let pptr: *mut Pair = &mut p;\n-        let iptr: *mut int = cast::reinterpret_cast(&pptr);\n-        assert!((*iptr == 10));;\n-        *iptr = 30;\n-        assert!((*iptr == 30));\n-        assert!((p.fst == 30));;\n-\n-        *pptr = Pair {fst: 50, snd: 60};\n-        assert!((*iptr == 50));\n-        assert!((p.fst == 50));\n-        assert!((p.snd == 60));\n-\n-        let mut v0 = ~[32000u16, 32001u16, 32002u16];\n-        let mut v1 = ~[0u16, 0u16, 0u16];\n-\n-        copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n-                    offset(vec::raw::to_ptr(v0), 1u), 1u);\n-        assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n-        copy_memory(vec::raw::to_mut_ptr(v1),\n-                    offset(vec::raw::to_ptr(v0), 2u), 1u);\n-        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n-                      v1[2] == 0u16));\n-        copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n-                    vec::raw::to_ptr(v0), 1u);\n-        assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n-                      v1[2] == 32000u16));\n+#[cfg(test)]\n+pub mod ptr_tests {\n+    use super::*;\n+    use prelude::*;\n+\n+    #[test]\n+    fn test() {\n+        unsafe {\n+            struct Pair {mut fst: int, mut snd: int};\n+            let mut p = Pair {fst: 10, snd: 20};\n+            let pptr: *mut Pair = &mut p;\n+            let iptr: *mut int = cast::reinterpret_cast(&pptr);\n+            assert!((*iptr == 10));;\n+            *iptr = 30;\n+            assert!((*iptr == 30));\n+            assert!((p.fst == 30));;\n+\n+            *pptr = Pair {fst: 50, snd: 60};\n+            assert!((*iptr == 50));\n+            assert!((p.fst == 50));\n+            assert!((p.snd == 60));\n+\n+            let mut v0 = ~[32000u16, 32001u16, 32002u16];\n+            let mut v1 = ~[0u16, 0u16, 0u16];\n+\n+            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n+                        offset(vec::raw::to_ptr(v0), 1u), 1u);\n+            assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n+            copy_memory(vec::raw::to_mut_ptr(v1),\n+                        offset(vec::raw::to_ptr(v0), 2u), 1u);\n+            assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+                     v1[2] == 0u16));\n+            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n+                        vec::raw::to_ptr(v0), 1u);\n+            assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n+                     v1[2] == 32000u16));\n+        }\n     }\n-}\n \n-#[test]\n-pub fn test_position() {\n-    use str::as_c_str;\n-    use libc::c_char;\n+    #[test]\n+    fn test_position() {\n+        use str::as_c_str;\n+        use libc::c_char;\n \n-    let s = ~\"hello\";\n-    unsafe {\n-        assert!(2u == as_c_str(s, |p| position(p,\n-            |c| *c == 'l' as c_char)));\n-        assert!(4u == as_c_str(s, |p| position(p,\n-            |c| *c == 'o' as c_char)));\n-        assert!(5u == as_c_str(s, |p| position(p,\n-            |c| *c == 0 as c_char)));\n+        let s = ~\"hello\";\n+        unsafe {\n+            assert!(2u == as_c_str(s, |p| position(p,\n+                                                   |c| *c == 'l' as c_char)));\n+            assert!(4u == as_c_str(s, |p| position(p,\n+                                                   |c| *c == 'o' as c_char)));\n+            assert!(5u == as_c_str(s, |p| position(p,\n+                                                   |c| *c == 0 as c_char)));\n+        }\n     }\n-}\n \n-#[test]\n-pub fn test_buf_len() {\n-    let s0 = ~\"hello\";\n-    let s1 = ~\"there\";\n-    let s2 = ~\"thing\";\n-    do str::as_c_str(s0) |p0| {\n-        do str::as_c_str(s1) |p1| {\n-            do str::as_c_str(s2) |p2| {\n-                let v = ~[p0, p1, p2, null()];\n-                do vec::as_imm_buf(v) |vp, len| {\n-                    assert!(unsafe { buf_len(vp) } == 3u);\n-                    assert!(len == 4u);\n+    #[test]\n+    fn test_buf_len() {\n+        let s0 = ~\"hello\";\n+        let s1 = ~\"there\";\n+        let s2 = ~\"thing\";\n+        do str::as_c_str(s0) |p0| {\n+            do str::as_c_str(s1) |p1| {\n+                do str::as_c_str(s2) |p2| {\n+                    let v = ~[p0, p1, p2, null()];\n+                    do vec::as_imm_buf(v) |vp, len| {\n+                        assert!(unsafe { buf_len(vp) } == 3u);\n+                        assert!(len == 4u);\n+                    }\n                 }\n             }\n         }\n     }\n-}\n-\n-#[test]\n-pub fn test_is_null() {\n-   let p: *int = null();\n-   assert!(p.is_null());\n-   assert!(!p.is_not_null());\n \n-   let q = offset(p, 1u);\n-   assert!(!q.is_null());\n-   assert!(q.is_not_null());\n-\n-   let mp: *mut int = mut_null();\n-   assert!(mp.is_null());\n-   assert!(!mp.is_not_null());\n+    #[test]\n+    fn test_is_null() {\n+        let p: *int = null();\n+        assert!(p.is_null());\n+        assert!(!p.is_not_null());\n+\n+        let q = offset(p, 1u);\n+        assert!(!q.is_null());\n+        assert!(q.is_not_null());\n+\n+        let mp: *mut int = mut_null();\n+        assert!(mp.is_null());\n+        assert!(!mp.is_not_null());\n+\n+        let mq = mp.offset(1u);\n+        assert!(!mq.is_null());\n+        assert!(mq.is_not_null());\n+    }\n \n-   let mq = mp.offset(1u);\n-   assert!(!mq.is_null());\n-   assert!(mq.is_not_null());\n-}\n \n-#[cfg(test)]\n-pub mod ptr_tests {\n-    use ptr;\n-    use str;\n-    use libc;\n-    use vec;\n     #[test]\n-    pub fn test_ptr_array_each_with_len() {\n+    fn test_ptr_array_each_with_len() {\n         unsafe {\n             let one = ~\"oneOne\";\n             let two = ~\"twoTwo\";\n@@ -451,22 +449,22 @@ pub mod ptr_tests {\n             let arr_ptr = &arr[0];\n             let mut ctr = 0;\n             let mut iteration_count = 0;\n-            ptr::array_each_with_len(arr_ptr, vec::len(arr),\n-                |e| {\n-                let actual = str::raw::from_c_str(e);\n-                let expected = copy expected_arr[ctr];\n-                debug!(\n-                    \"test_ptr_array_each e: %s, a: %s\",\n-                         expected, actual);\n-                assert!(actual == expected);\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n+            array_each_with_len(arr_ptr, vec::len(arr),\n+                                |e| {\n+                                         let actual = str::raw::from_c_str(e);\n+                                         let expected = copy expected_arr[ctr];\n+                                         debug!(\n+                                             \"test_ptr_array_each e: %s, a: %s\",\n+                                             expected, actual);\n+                                         assert!(actual == expected);\n+                                         ctr += 1;\n+                                         iteration_count += 1;\n+                                     });\n             assert!(iteration_count == 3u);\n         }\n     }\n     #[test]\n-    pub fn test_ptr_array_each() {\n+    fn test_ptr_array_each() {\n         unsafe {\n             let one = ~\"oneOne\";\n             let two = ~\"twoTwo\";\n@@ -484,12 +482,12 @@ pub mod ptr_tests {\n             let arr_ptr = &arr[0];\n             let mut ctr = 0;\n             let mut iteration_count = 0;\n-            ptr::array_each(arr_ptr, |e| {\n+            array_each(arr_ptr, |e| {\n                 let actual = str::raw::from_c_str(e);\n                 let expected = copy expected_arr[ctr];\n                 debug!(\n                     \"test_ptr_array_each e: %s, a: %s\",\n-                         expected, actual);\n+                    expected, actual);\n                 assert!(actual == expected);\n                 ctr += 1;\n                 iteration_count += 1;\n@@ -500,19 +498,19 @@ pub mod ptr_tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn test_ptr_array_each_with_len_null_ptr() {\n+    fn test_ptr_array_each_with_len_null_ptr() {\n         unsafe {\n-            ptr::array_each_with_len(0 as **libc::c_char, 1, |e| {\n+            array_each_with_len(0 as **libc::c_char, 1, |e| {\n                 str::raw::from_c_str(e);\n             });\n         }\n     }\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn test_ptr_array_each_null_ptr() {\n+    fn test_ptr_array_each_null_ptr() {\n         unsafe {\n-            ptr::array_each(0 as **libc::c_char, |e| {\n+            array_each(0 as **libc::c_char, |e| {\n                 str::raw::from_c_str(e);\n             });\n         }"}, {"sha": "0a93a651a8572f8c4520fd6ef8f6097b1e3a738f", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -747,20 +747,20 @@ pub fn random() -> uint {\n \n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use option::{Option, Some};\n     use rand;\n \n     #[test]\n-    pub fn rng_seeded() {\n+    fn rng_seeded() {\n         let seed = rand::seed();\n         let ra = rand::seeded_rng(seed);\n         let rb = rand::seeded_rng(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n-    pub fn rng_seeded_custom_seed() {\n+    fn rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n@@ -769,7 +769,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn rng_seeded_custom_seed2() {\n+    fn rng_seeded_custom_seed2() {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n         let ra = rand::seeded_rng(seed);\n         // Regression test that isaac is actually using the above vector\n@@ -780,7 +780,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn gen_int_range() {\n+    fn gen_int_range() {\n         let r = rand::Rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n@@ -791,12 +791,12 @@ pub mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn gen_int_from_fail() {\n+    fn gen_int_from_fail() {\n         rand::Rng().gen_int_range(5, -2);\n     }\n \n     #[test]\n-    pub fn gen_uint_range() {\n+    fn gen_uint_range() {\n         let r = rand::Rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n@@ -807,27 +807,27 @@ pub mod tests {\n     #[test]\n     #[should_fail]\n     #[ignore(cfg(windows))]\n-    pub fn gen_uint_range_fail() {\n+    fn gen_uint_range_fail() {\n         rand::Rng().gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n-    pub fn gen_float() {\n+    fn gen_float() {\n         let r = rand::Rng();\n         let a = r.gen_float();\n         let b = r.gen_float();\n         debug!((a, b));\n     }\n \n     #[test]\n-    pub fn gen_weighted_bool() {\n+    fn gen_weighted_bool() {\n         let r = rand::Rng();\n         assert!(r.gen_weighted_bool(0u) == true);\n         assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n-    pub fn gen_str() {\n+    fn gen_str() {\n         let r = rand::Rng();\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n@@ -838,29 +838,29 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn gen_bytes() {\n+    fn gen_bytes() {\n         let r = rand::Rng();\n         assert!(r.gen_bytes(0u).len() == 0u);\n         assert!(r.gen_bytes(10u).len() == 10u);\n         assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n-    pub fn choose() {\n+    fn choose() {\n         let r = rand::Rng();\n         assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n-    pub fn choose_option() {\n+    fn choose_option() {\n         let r = rand::Rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n         assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n-    pub fn choose_weighted() {\n+    fn choose_weighted() {\n         let r = rand::Rng();\n         assert!(r.choose_weighted(~[\n             rand::Weighted { weight: 1u, item: 42 },\n@@ -872,7 +872,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn choose_weighted_option() {\n+    fn choose_weighted_option() {\n         let r = rand::Rng();\n         assert!(r.choose_weighted_option(~[\n             rand::Weighted { weight: 1u, item: 42 },\n@@ -886,7 +886,7 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn weighted_vec() {\n+    fn weighted_vec() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert!(r.weighted_vec(~[]) == empty);\n@@ -898,23 +898,23 @@ pub mod tests {\n     }\n \n     #[test]\n-    pub fn shuffle() {\n+    fn shuffle() {\n         let r = rand::Rng();\n         let empty: ~[int] = ~[];\n         assert!(r.shuffle(~[]) == empty);\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n-    pub fn task_rng() {\n+    fn task_rng() {\n         let r = rand::task_rng();\n         r.gen_int();\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n     }\n \n     #[test]\n-    pub fn random() {\n+    fn random() {\n         // not sure how to test this aside from just getting a number\n         let _n : uint = rand::random();\n     }"}, {"sha": "8e247a25012f113b08ba9810200311368d81a43e", "filename": "src/libcore/run.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -521,15 +521,15 @@ mod tests {\n \n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n-    pub fn test_leaks() {\n+    fn test_leaks() {\n         run::run_program(\"echo\", []);\n         run::start_program(\"echo\", []);\n         run::program_output(\"echo\", []);\n     }\n \n     #[test]\n     #[allow(non_implicitly_copyable_typarams)]\n-    pub fn test_pipes() {\n+    fn test_pipes() {\n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n@@ -555,7 +555,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn waitpid() {\n+    fn waitpid() {\n         let pid = run::spawn_process(\"false\", [],\n                                      &None, &None,\n                                      0i32, 0i32, 0i32);\n@@ -564,20 +564,20 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_destroy_once() {\n+    fn test_destroy_once() {\n         let mut p = run::start_program(\"echo\", []);\n         p.destroy(); // this shouldn't crash (and nor should the destructor)\n     }\n \n     #[test]\n-    pub fn test_destroy_twice() {\n+    fn test_destroy_twice() {\n         let mut p = run::start_program(\"echo\", []);\n         p.destroy(); // this shouldnt crash...\n         p.destroy(); // ...and nor should this (and nor should the destructor)\n     }\n \n     #[cfg(unix)] // there is no way to sleep on windows from inside libcore...\n-    pub fn test_destroy_actually_kills(force: bool) {\n+    fn test_destroy_actually_kills(force: bool) {\n         let path = Path(fmt!(\"test/core-run-test-destroy-actually-kills-%?.tmp\", force));\n \n         os::remove_file(&path);\n@@ -598,13 +598,13 @@ mod tests {\n \n     #[test]\n     #[cfg(unix)]\n-    pub fn test_unforced_destroy_actually_kills() {\n+    fn test_unforced_destroy_actually_kills() {\n         test_destroy_actually_kills(false);\n     }\n \n     #[test]\n     #[cfg(unix)]\n-    pub fn test_forced_destroy_actually_kills() {\n+    fn test_forced_destroy_actually_kills() {\n         test_destroy_actually_kills(true);\n     }\n }"}, {"sha": "04f96f5eb229e5fe8b75065e7b5fdf4aecd4deb9", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -160,12 +160,12 @@ pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n }\n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use cast;\n     use sys::{Closure, pref_align_of, size_of, nonzero_size_of};\n \n     #[test]\n-    pub fn size_of_basic() {\n+    fn size_of_basic() {\n         assert!(size_of::<u8>() == 1u);\n         assert!(size_of::<u16>() == 2u);\n         assert!(size_of::<u32>() == 4u);\n@@ -176,28 +176,28 @@ pub mod tests {\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n-    pub fn size_of_32() {\n+    fn size_of_32() {\n         assert!(size_of::<uint>() == 4u);\n         assert!(size_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    pub fn size_of_64() {\n+    fn size_of_64() {\n         assert!(size_of::<uint>() == 8u);\n         assert!(size_of::<*uint>() == 8u);\n     }\n \n     #[test]\n-    pub fn nonzero_size_of_basic() {\n+    fn nonzero_size_of_basic() {\n         type Z = [i8, ..0];\n         assert!(size_of::<Z>() == 0u);\n         assert!(nonzero_size_of::<Z>() == 1u);\n         assert!(nonzero_size_of::<uint>() == size_of::<uint>());\n     }\n \n     #[test]\n-    pub fn align_of_basic() {\n+    fn align_of_basic() {\n         assert!(pref_align_of::<u8>() == 1u);\n         assert!(pref_align_of::<u16>() == 2u);\n         assert!(pref_align_of::<u32>() == 4u);\n@@ -207,20 +207,20 @@ pub mod tests {\n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"arm\")]\n     #[cfg(target_arch = \"mips\")]\n-    pub fn align_of_32() {\n+    fn align_of_32() {\n         assert!(pref_align_of::<uint>() == 4u);\n         assert!(pref_align_of::<*uint>() == 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n-    pub fn align_of_64() {\n+    fn align_of_64() {\n         assert!(pref_align_of::<uint>() == 8u);\n         assert!(pref_align_of::<*uint>() == 8u);\n     }\n \n     #[test]\n-    pub fn synthesize_closure() {\n+    fn synthesize_closure() {\n         unsafe {\n             let x = 10;\n             let f: &fn(int) -> int = |y| x + y;"}, {"sha": "a6c4b6c526862154caa1510cff4613c4ed5ce3ea", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -925,7 +925,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n }\n \n #[cfg(test)]\n-pub mod testrt {\n+mod testrt {\n     use libc;\n \n     #[nolink]"}, {"sha": "c057fce0abd8cfecc2f5cc43fc5330824dfe365f", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -286,14 +286,14 @@ pub impl<T:Owned> Exclusive<T> {\n }\n \n #[cfg(test)]\n-pub mod tests {\n+mod tests {\n     use comm;\n     use super::exclusive;\n     use task;\n     use uint;\n \n     #[test]\n-    pub fn exclusive_arc() {\n+    fn exclusive_arc() {\n         let mut futures = ~[];\n \n         let num_tasks = 10;\n@@ -324,7 +324,7 @@ pub mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn exclusive_poison() {\n+    fn exclusive_poison() {\n         // Tests that if one task fails inside of an exclusive, subsequent\n         // accesses will also fail.\n         let x = exclusive(1);"}, {"sha": "49935eea0e13d7734dbf5b311c72ca1aff886f80", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -212,14 +212,14 @@ mod test {\n     use driver::session;\n \n     #[test]\n-    pub fn test_rpaths_to_flags() {\n+    fn test_rpaths_to_flags() {\n         let flags = rpaths_to_flags(~[Path(\"path1\"),\n                                       Path(\"path2\")]);\n         assert!(flags == ~[~\"-Wl,-rpath,path1\", ~\"-Wl,-rpath,path2\"]);\n     }\n \n     #[test]\n-    pub fn test_prefix_rpath() {\n+    fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(\"triple\");\n         let d = Path(env!(\"CFG_PREFIX\"))\n             .push_rel(&Path(\"lib/rustc/triple/lib\"));\n@@ -230,21 +230,21 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_prefix_rpath_abs() {\n+    fn test_prefix_rpath_abs() {\n         let res = get_install_prefix_rpath(\"triple\");\n         assert!(res.is_absolute);\n     }\n \n     #[test]\n-    pub fn test_minimize1() {\n+    fn test_minimize1() {\n         let res = minimize_rpaths([Path(\"rpath1\"),\n                                    Path(\"rpath2\"),\n                                    Path(\"rpath1\")]);\n         assert!(res == ~[Path(\"rpath1\"), Path(\"rpath2\")]);\n     }\n \n     #[test]\n-    pub fn test_minimize2() {\n+    fn test_minimize2() {\n         let res = minimize_rpaths(~[Path(\"1a\"), Path(\"2\"), Path(\"2\"),\n                                     Path(\"1a\"), Path(\"4a\"),Path(\"1a\"),\n                                     Path(\"2\"), Path(\"3\"), Path(\"4a\"),\n@@ -253,63 +253,63 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_relative_to1() {\n+    fn test_relative_to1() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to2() {\n+    fn test_relative_to2() {\n         let p1 = Path(\"/usr/bin/rustc\");\n         let p2 = Path(\"/usr/bin/../lib/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to3() {\n+    fn test_relative_to3() {\n         let p1 = Path(\"/usr/bin/whatever/rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../../lib/whatever\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to4() {\n+    fn test_relative_to4() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib/whatever\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to5() {\n+    fn test_relative_to5() {\n         let p1 = Path(\"/usr/bin/whatever/../rustc\");\n         let p2 = Path(\"/usr/lib/whatever/../mylib\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"../lib\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to6() {\n+    fn test_relative_to6() {\n         let p1 = Path(\"/1\");\n         let p2 = Path(\"/2/3\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"2\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to7() {\n+    fn test_relative_to7() {\n         let p1 = Path(\"/1/2\");\n         let p2 = Path(\"/3\");\n         let res = get_relative_to(&p1, &p2);\n         assert!(res == Path(\"..\"));\n     }\n \n     #[test]\n-    pub fn test_relative_to8() {\n+    fn test_relative_to8() {\n         let p1 = Path(\"/home/brian/Dev/rust/build/\").push_rel(\n             &Path(\"stage2/lib/rustc/i686-unknown-linux-gnu/lib/librustc.so\"));\n         let p2 = Path(\"/home/brian/Dev/rust/build/stage2/bin/..\").push_rel(\n@@ -324,7 +324,7 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"andorid\")]\n-    pub fn test_rpath_relative() {\n+    fn test_rpath_relative() {\n       let o = session::os_linux;\n       let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n@@ -333,7 +333,7 @@ mod test {\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n-    pub fn test_rpath_relative() {\n+    fn test_rpath_relative() {\n         let o = session::os_freebsd;\n         let res = get_rpath_relative_to_output(o,\n             &Path(\"bin/rustc\"), &Path(\"lib/libstd.so\"));\n@@ -342,7 +342,7 @@ mod test {\n \n     #[test]\n     #[cfg(target_os = \"macos\")]\n-    pub fn test_rpath_relative() {\n+    fn test_rpath_relative() {\n         // this is why refinements would be nice\n         let o = session::os_macos;\n         let res = get_rpath_relative_to_output(o,\n@@ -352,7 +352,7 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_get_absolute_rpath() {\n+    fn test_get_absolute_rpath() {\n         let res = get_absolute_rpath(&Path(\"lib/libstd.so\"));\n         debug!(\"test_get_absolute_rpath: %s vs. %s\",\n                res.to_str(),"}, {"sha": "a804469ac651187c422366a5840319ca6d5a87b8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -876,7 +876,7 @@ pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use core::prelude::*;\n \n     use driver::driver::{build_configuration, build_session};\n@@ -890,7 +890,7 @@ pub mod test {\n \n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n-    pub fn test_switch_implies_cfg_test() {\n+    fn test_switch_implies_cfg_test() {\n         let matches =\n             &match getopts(~[~\"--test\"], optgroups()) {\n               Ok(copy m) => m,\n@@ -907,7 +907,7 @@ pub mod test {\n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n-    pub fn test_switch_implies_cfg_test_unless_cfg_test() {\n+    fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(~[~\"--test\", ~\"--cfg=test\"], optgroups()) {\n               Ok(copy m) => m,"}, {"sha": "aee5e01e091080fa3df2dd7f69ecac2c4dae258a", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -354,14 +354,14 @@ pub fn sess_os_to_meta_os(os: os) -> metadata::loader::os {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use driver::session::{bin_crate, building_library, lib_crate};\n     use driver::session::{unknown_crate};\n \n     use syntax::ast;\n     use syntax::codemap;\n \n-    pub fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n+    fn make_crate_type_attr(+t: ~str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @codemap::respan(codemap::dummy_sp(),\n@@ -373,7 +373,7 @@ pub mod test {\n         })\n     }\n \n-    pub fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n+    fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n         if with_bin { attrs += ~[make_crate_type_attr(~\"bin\")]; }\n         if with_lib { attrs += ~[make_crate_type_attr(~\"lib\")]; }\n@@ -385,43 +385,43 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn bin_crate_type_attr_results_in_bin_output() {\n+    fn bin_crate_type_attr_results_in_bin_output() {\n         let crate = make_crate(true, false);\n         assert!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn lib_crate_type_attr_results_in_lib_output() {\n+    fn lib_crate_type_attr_results_in_lib_output() {\n         let crate = make_crate(false, true);\n         assert!(building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn bin_option_overrides_lib_crate_type() {\n+    fn bin_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n         assert!(!building_library(bin_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn lib_option_overrides_bin_crate_type() {\n+    fn lib_option_overrides_bin_crate_type() {\n         let crate = make_crate(true, false);\n         assert!(building_library(lib_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn bin_crate_type_is_default() {\n+    fn bin_crate_type_is_default() {\n         let crate = make_crate(false, false);\n         assert!(!building_library(unknown_crate, crate, false));\n     }\n \n     #[test]\n-    pub fn test_option_overrides_lib_crate_type() {\n+    fn test_option_overrides_lib_crate_type() {\n         let crate = make_crate(false, true);\n         assert!(!building_library(unknown_crate, crate, true));\n     }\n \n     #[test]\n-    pub fn test_option_does_not_override_requested_lib_type() {\n+    fn test_option_does_not_override_requested_lib_type() {\n         let crate = make_crate(false, false);\n         assert!(building_library(lib_crate, crate, true));\n     }"}, {"sha": "da1e4688939cc8ac44c9260121277cdde49b8e71", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -492,7 +492,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    pub fn manually_share_arc() {\n+    fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = arc::ARC(v);\n \n@@ -517,7 +517,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_mutex_arc_condvar() {\n+    fn test_mutex_arc_condvar() {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = comm::oneshot();\n@@ -539,7 +539,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_arc_condvar_poison() {\n+    fn test_arc_condvar_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         let (p, c) = comm::stream();\n@@ -561,7 +561,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_mutex_arc_poison() {\n+    fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         do task::try || {\n@@ -574,7 +574,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_poison_wr() {\n+    fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -587,7 +587,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_poison_ww() {\n+    fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -600,7 +600,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_poison_dw() {\n+    fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -615,7 +615,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_no_poison_rr() {\n+    fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -628,7 +628,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_no_poison_rw() {\n+    fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -641,7 +641,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rw_arc_no_poison_dr() {\n+    fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n@@ -657,7 +657,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_rw_arc() {\n+    fn test_rw_arc() {\n         let arc = ~RWARC(0);\n         let arc2 = (*arc).clone();\n         let (p,c) = comm::stream();\n@@ -694,7 +694,7 @@ mod tests {\n         do arc.read |num| { assert!(*num == 10); }\n     }\n     #[test]\n-    pub fn test_rw_downgrade() {\n+    fn test_rw_downgrade() {\n         // (1) A downgrader gets in write mode and does cond.wait.\n         // (2) A writer gets in write mode, sets state to 42, and does signal.\n         // (3) Downgrader wakes, sets state to 31337."}, {"sha": "c960c7186e3d202a7281800fe2c6b64ba6d0408c", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -154,7 +154,7 @@ mod tests {\n     use core::str;\n \n     #[test]\n-    pub fn test_to_base64() {\n+    fn test_to_base64() {\n         assert!((~\"\").to_base64()       == ~\"\");\n         assert!((~\"f\").to_base64()      == ~\"Zg==\");\n         assert!((~\"fo\").to_base64()     == ~\"Zm8=\");\n@@ -165,7 +165,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_base64() {\n+    fn test_from_base64() {\n         assert!((~\"\").from_base64() == str::to_bytes(~\"\"));\n         assert!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n         assert!((~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\"));"}, {"sha": "d89ce4232b175963cb71e39bac0df00210c44985", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -880,7 +880,7 @@ mod tests {\n     static bench_bits : uint = 1 << 14;\n \n     #[test]\n-    pub fn test_to_str() {\n+    fn test_to_str() {\n         let zerolen = Bitv::new(0u, false);\n         assert!(zerolen.to_str() == ~\"\");\n \n@@ -889,7 +889,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_0_elements() {\n+    fn test_0_elements() {\n         let mut act;\n         let mut exp;\n         act = Bitv::new(0u, false);\n@@ -898,7 +898,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_1_element() {\n+    fn test_1_element() {\n         let mut act;\n         act = Bitv::new(1u, false);\n         assert!(act.eq_vec(~[0u]));\n@@ -907,15 +907,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_2_elements() {\n+    fn test_2_elements() {\n         let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert!(b.to_str() == ~\"10\");\n     }\n \n     #[test]\n-    pub fn test_10_elements() {\n+    fn test_10_elements() {\n         let mut act;\n         // all 0\n \n@@ -954,7 +954,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_31_elements() {\n+    fn test_31_elements() {\n         let mut act;\n         // all 0\n \n@@ -1027,7 +1027,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_32_elements() {\n+    fn test_32_elements() {\n         let mut act;\n         // all 0\n \n@@ -1102,7 +1102,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_33_elements() {\n+    fn test_33_elements() {\n         let mut act;\n         // all 0\n \n@@ -1178,21 +1178,21 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_equal_differing_sizes() {\n+    fn test_equal_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(11u, false);\n         assert!(!v0.equal(&v1));\n     }\n \n     #[test]\n-    pub fn test_equal_greatly_differing_sizes() {\n+    fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv::new(10u, false);\n         let v1 = Bitv::new(110u, false);\n         assert!(!v0.equal(&v1));\n     }\n \n     #[test]\n-    pub fn test_equal_sneaky_small() {\n+    fn test_equal_sneaky_small() {\n         let mut a = bitv::Bitv::new(1, false);\n         a.set(0, true);\n \n@@ -1203,7 +1203,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_equal_sneaky_big() {\n+    fn test_equal_sneaky_big() {\n         let mut a = bitv::Bitv::new(100, false);\n         for uint::range(0, 100) |i| {\n             a.set(i, true);\n@@ -1218,14 +1218,14 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_bytes() {\n+    fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n         assert!(bitv.to_str() == str);\n     }\n \n     #[test]\n-    pub fn test_to_bytes() {\n+    fn test_to_bytes() {\n         let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n         assert!(bv.to_bytes() == ~[0b10100000]);\n@@ -1237,19 +1237,19 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_bools() {\n+    fn test_from_bools() {\n         assert!(from_bools([true, false, true, true]).to_str() ==\n             ~\"1011\");\n     }\n \n     #[test]\n-    pub fn test_to_bools() {\n+    fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n         assert!(from_bytes([0b00100110]).to_bools() == bools);\n     }\n \n     #[test]\n-    pub fn test_small_difference() {\n+    fn test_small_difference() {\n         let mut b1 = Bitv::new(3, false);\n         let mut b2 = Bitv::new(3, false);\n         b1.set(0, true);\n@@ -1263,7 +1263,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_big_difference() {\n+    fn test_big_difference() {\n         let mut b1 = Bitv::new(100, false);\n         let mut b2 = Bitv::new(100, false);\n         b1.set(0, true);\n@@ -1277,7 +1277,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_small_clear() {\n+    fn test_small_clear() {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n         for b.ones |i| {\n@@ -1286,7 +1286,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_big_clear() {\n+    fn test_big_clear() {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n         for b.ones |i| {\n@@ -1295,7 +1295,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_bitv_set_basic() {\n+    fn test_bitv_set_basic() {\n         let mut b = BitvSet::new();\n         assert!(b.insert(3));\n         assert!(!b.insert(3));\n@@ -1382,7 +1382,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_bitv_set_union() {\n+    fn test_bitv_set_union() {\n         let mut a = BitvSet::new();\n         let mut b = BitvSet::new();\n         assert!(a.insert(1));\n@@ -1410,7 +1410,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_bitv_remove() {\n+    fn test_bitv_remove() {\n         let mut a = BitvSet::new();\n \n         assert!(a.insert(1));\n@@ -1430,7 +1430,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_uint_small(b: &mut BenchHarness) {\n+    fn bench_uint_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = 0 as uint;\n         do b.iter {\n@@ -1439,7 +1439,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_small_bitv_small(b: &mut BenchHarness) {\n+    fn bench_small_bitv_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n         do b.iter {\n@@ -1448,7 +1448,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_big_bitv_small(b: &mut BenchHarness) {\n+    fn bench_big_bitv_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         do b.iter {\n@@ -1457,7 +1457,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_big_bitv_big(b: &mut BenchHarness) {\n+    fn bench_big_bitv_big(b: &mut BenchHarness) {\n         let r = rng();\n         let mut storage = ~[];\n         storage.grow(bench_bits / uint::bits, &0);\n@@ -1468,7 +1468,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_big(b: &mut BenchHarness) {\n+    fn bench_bitv_big(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = Bitv::new(bench_bits, false);\n         do b.iter {\n@@ -1477,7 +1477,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_small(b: &mut BenchHarness) {\n+    fn bench_bitv_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n@@ -1486,7 +1486,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_set_small(b: &mut BenchHarness) {\n+    fn bench_bitv_set_small(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n@@ -1495,7 +1495,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_set_big(b: &mut BenchHarness) {\n+    fn bench_bitv_set_big(b: &mut BenchHarness) {\n         let r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n@@ -1504,7 +1504,7 @@ mod tests {\n     }\n \n     #[bench]\n-    pub fn bench_bitv_big_union(b: &mut BenchHarness) {\n+    fn bench_bitv_big_union(b: &mut BenchHarness) {\n         let mut b1 = Bitv::new(bench_bits, false);\n         let mut b2 = Bitv::new(bench_bits, false);\n         do b.iter {"}, {"sha": "f9de2e0f58ad0ca3d509c08856b67be4b2a501ec", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -537,7 +537,7 @@ mod tests {\n     use core::prelude::*;\n \n     #[test]\n-    pub fn test_dlist_concat() {\n+    fn test_dlist_concat() {\n         let a = from_vec(~[1,2]);\n         let b = from_vec(~[3,4]);\n         let c = from_vec(~[5,6]);\n@@ -557,7 +557,7 @@ mod tests {\n         abcd.assert_consistent(); assert!(abcd.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append() {\n+    fn test_dlist_append() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n@@ -573,7 +573,7 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append_empty() {\n+    fn test_dlist_append_empty() {\n         let a = from_vec(~[1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n@@ -586,7 +586,7 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append_to_empty() {\n+    fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n         let b = from_vec(~[4,5,6]);\n         a.append(b);\n@@ -599,7 +599,7 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_append_two_empty() {\n+    fn test_dlist_append_two_empty() {\n         let a = DList::<int>();\n         let b = DList::<int>();\n         a.append(b);\n@@ -611,19 +611,19 @@ mod tests {\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n-    pub fn test_dlist_append_self() {\n+    fn test_dlist_append_self() {\n         let a = DList::<int>();\n         a.append(a);\n     }\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]\n-    pub fn test_dlist_prepend_self() {\n+    fn test_dlist_prepend_self() {\n         let a = DList::<int>();\n         a.prepend(a);\n     }\n     #[test]\n-    pub fn test_dlist_prepend() {\n+    fn test_dlist_prepend() {\n         let a = from_vec(~[1,2,3]);\n         let b = from_vec(~[4,5,6]);\n         b.prepend(a);\n@@ -639,7 +639,7 @@ mod tests {\n         b.assert_consistent(); assert!(b.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_reverse() {\n+    fn test_dlist_reverse() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.reverse();\n         assert_eq!(a.len(), 5);\n@@ -651,14 +651,14 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_reverse_empty() {\n+    fn test_dlist_reverse_empty() {\n         let a = DList::<int>();\n         a.reverse();\n         assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n-    pub fn test_dlist_each_node() {\n+    fn test_dlist_each_node() {\n         let a = from_vec(~[1,2,4,5]);\n         for a.each_node |nobe| {\n             if nobe.data > 3 {\n@@ -675,28 +675,28 @@ mod tests {\n         a.assert_consistent(); assert!(a.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_clear() {\n+    fn test_dlist_clear() {\n         let a = from_vec(~[5,4,3,2,1]);\n         a.clear();\n         assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n-    pub fn test_dlist_is_empty() {\n+    fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n         let full1 = from_vec(~[1,2,3]);\n         assert!(empty.is_empty());\n         assert!(!full1.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_head_tail() {\n+    fn test_dlist_head_tail() {\n         let l = from_vec(~[1,2,3]);\n         assert_eq!(l.head(), 1);\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    pub fn test_dlist_pop() {\n+    fn test_dlist_pop() {\n         let l = from_vec(~[1,2,3]);\n         assert_eq!(l.pop().get(), 1);\n         assert_eq!(l.tail(), 3);\n@@ -709,7 +709,7 @@ mod tests {\n         assert!(l.pop().is_none());\n     }\n     #[test]\n-    pub fn test_dlist_pop_tail() {\n+    fn test_dlist_pop_tail() {\n         let l = from_vec(~[1,2,3]);\n         assert_eq!(l.pop_tail().get(), 3);\n         assert_eq!(l.tail(), 2);\n@@ -722,7 +722,7 @@ mod tests {\n         assert!(l.pop_tail().is_none());\n     }\n     #[test]\n-    pub fn test_dlist_push() {\n+    fn test_dlist_push() {\n         let l = DList::<int>();\n         l.push(1);\n         assert_eq!(l.head(), 1);\n@@ -736,7 +736,7 @@ mod tests {\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    pub fn test_dlist_push_head() {\n+    fn test_dlist_push_head() {\n         let l = DList::<int>();\n         l.push_head(3);\n         assert_eq!(l.head(), 3);\n@@ -750,12 +750,12 @@ mod tests {\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n-    pub fn test_dlist_foldl() {\n+    fn test_dlist_foldl() {\n         let l = from_vec(vec::from_fn(101, |x|x));\n         assert_eq!(iter::foldl(&l, 0, |accum,elem| *accum+*elem), 5050);\n     }\n     #[test]\n-    pub fn test_dlist_break_early() {\n+    fn test_dlist_break_early() {\n         let l = from_vec(~[1,2,3,4,5]);\n         let mut x = 0;\n         for l.each |i| {\n@@ -765,7 +765,7 @@ mod tests {\n         assert_eq!(x, 3);\n     }\n     #[test]\n-    pub fn test_dlist_remove_head() {\n+    fn test_dlist_remove_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -780,7 +780,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_mid() {\n+    fn test_dlist_remove_mid() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -795,7 +795,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_tail() {\n+    fn test_dlist_remove_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -810,7 +810,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_one_two() {\n+    fn test_dlist_remove_one_two() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -826,7 +826,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_one_three() {\n+    fn test_dlist_remove_one_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -841,7 +841,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_two_three() {\n+    fn test_dlist_remove_two_three() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -856,7 +856,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_remove_all() {\n+    fn test_dlist_remove_all() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -869,7 +869,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_n_before() {\n+    fn test_dlist_insert_n_before() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -885,7 +885,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_n_after() {\n+    fn test_dlist_insert_n_after() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -901,7 +901,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_before_head() {\n+    fn test_dlist_insert_before_head() {\n         let l = DList::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n@@ -916,7 +916,7 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test]\n-    pub fn test_dlist_insert_after_tail() {\n+    fn test_dlist_insert_after_tail() {\n         let l = DList::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n@@ -931,15 +931,15 @@ mod tests {\n         l.assert_consistent(); assert!(l.is_empty());\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_asymmetric_link() {\n+    fn test_dlist_asymmetric_link() {\n         let l = DList::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n         two.prev = None;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_cyclic_list() {\n+    fn test_dlist_cyclic_list() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n@@ -949,32 +949,32 @@ mod tests {\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_headless() {\n+    fn test_dlist_headless() {\n         DList::<int>().head();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_already_present_before() {\n+    fn test_dlist_insert_already_present_before() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_before(two, one);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_already_present_after() {\n+    fn test_dlist_insert_already_present_after() {\n         let l = DList::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_after(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_before_orphan() {\n+    fn test_dlist_insert_before_orphan() {\n         let l = DList::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);\n         l.insert_n_before(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_dlist_insert_after_orphan() {\n+    fn test_dlist_insert_after_orphan() {\n         let l = DList::<int>();\n         let one = new_dlist_node(1);\n         let two = new_dlist_node(2);"}, {"sha": "a36f67fc95a006d890d54959ea69d105cddd95c4", "filename": "src/libstd/future.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -172,7 +172,7 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n \n #[allow(non_implicitly_copyable_typarams)]\n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use core::prelude::*;\n \n     use future::*;\n@@ -181,53 +181,53 @@ pub mod test {\n     use core::task;\n \n     #[test]\n-    pub fn test_from_value() {\n+    fn test_from_value() {\n         let f = from_value(~\"snail\");\n         assert!(f.get() == ~\"snail\");\n     }\n \n     #[test]\n-    pub fn test_from_port() {\n+    fn test_from_port() {\n         let (ch, po) = oneshot::init();\n         send_one(ch, ~\"whale\");\n         let f = from_port(po);\n         assert!(f.get() == ~\"whale\");\n     }\n \n     #[test]\n-    pub fn test_from_fn() {\n+    fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n         assert!(f.get() == ~\"brail\");\n     }\n \n     #[test]\n-    pub fn test_interface_get() {\n+    fn test_interface_get() {\n         let f = from_value(~\"fail\");\n         assert!(f.get() == ~\"fail\");\n     }\n \n     #[test]\n-    pub fn test_get_ref_method() {\n+    fn test_get_ref_method() {\n         let f = from_value(22);\n         assert!(*f.get_ref() == 22);\n     }\n \n     #[test]\n-    pub fn test_spawn() {\n+    fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n         assert!(f.get() == ~\"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n-    pub fn test_futurefail() {\n+    fn test_futurefail() {\n         let f = spawn(|| fail!());\n         let _x: ~str = f.get();\n     }\n \n     #[test]\n-    pub fn test_sendable_future() {\n+    fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn { copy expected };\n         do task::spawn || {"}, {"sha": "d710a7b873548127d4ef462d1230aa0c02f66675", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -662,7 +662,7 @@ mod tests {\n     use core::result::{Err, Ok};\n     use core::result;\n \n-    pub fn check_fail_type(f: Fail_, ft: FailType) {\n+    fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n           ArgumentMissing(_) => assert!(ft == ArgumentMissing_),\n           UnrecognizedOption(_) => assert!(ft == UnrecognizedOption_),\n@@ -675,7 +675,7 @@ mod tests {\n \n     // Tests for reqopt\n     #[test]\n-    pub fn test_reqopt_long() {\n+    fn test_reqopt_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -689,7 +689,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_long_missing() {\n+    fn test_reqopt_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -700,7 +700,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_long_no_arg() {\n+    fn test_reqopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -711,7 +711,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_long_multi() {\n+    fn test_reqopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -722,7 +722,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short() {\n+    fn test_reqopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -736,7 +736,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short_missing() {\n+    fn test_reqopt_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -747,7 +747,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short_no_arg() {\n+    fn test_reqopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -758,7 +758,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_reqopt_short_multi() {\n+    fn test_reqopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -771,7 +771,7 @@ mod tests {\n \n     // Tests for optopt\n     #[test]\n-    pub fn test_optopt_long() {\n+    fn test_optopt_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -785,7 +785,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_long_missing() {\n+    fn test_optopt_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -796,7 +796,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_long_no_arg() {\n+    fn test_optopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -807,7 +807,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_long_multi() {\n+    fn test_optopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -818,7 +818,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short() {\n+    fn test_optopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -832,7 +832,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short_missing() {\n+    fn test_optopt_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -843,7 +843,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short_no_arg() {\n+    fn test_optopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -854,7 +854,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optopt_short_multi() {\n+    fn test_optopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -867,7 +867,7 @@ mod tests {\n \n     // Tests for optflag\n     #[test]\n-    pub fn test_optflag_long() {\n+    fn test_optflag_long() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -878,7 +878,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_long_missing() {\n+    fn test_optflag_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -889,7 +889,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_long_arg() {\n+    fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -903,7 +903,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_long_multi() {\n+    fn test_optflag_long_multi() {\n         let args = ~[~\"--test\", ~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -914,7 +914,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short() {\n+    fn test_optflag_short() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -925,7 +925,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short_missing() {\n+    fn test_optflag_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -936,7 +936,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short_arg() {\n+    fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -951,7 +951,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflag_short_multi() {\n+    fn test_optflag_short_multi() {\n         let args = ~[~\"-t\", ~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -963,7 +963,7 @@ mod tests {\n \n     // Tests for optflagmulti\n     #[test]\n-    pub fn test_optflagmulti_short1() {\n+    fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -976,7 +976,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_short2a() {\n+    fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -989,7 +989,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_short2b() {\n+    fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -1002,7 +1002,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_long1() {\n+    fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n         let opts = ~[optflagmulti(~\"verbose\")];\n         let rs = getopts(args, opts);\n@@ -1015,7 +1015,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optflagmulti_long2() {\n+    fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n         let opts = ~[optflagmulti(~\"verbose\")];\n         let rs = getopts(args, opts);\n@@ -1029,7 +1029,7 @@ mod tests {\n \n     // Tests for optmulti\n     #[test]\n-    pub fn test_optmulti_long() {\n+    fn test_optmulti_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1043,7 +1043,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_long_missing() {\n+    fn test_optmulti_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1054,7 +1054,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_long_no_arg() {\n+    fn test_optmulti_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1065,7 +1065,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_long_multi() {\n+    fn test_optmulti_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1082,7 +1082,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short() {\n+    fn test_optmulti_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1096,7 +1096,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short_missing() {\n+    fn test_optmulti_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1107,7 +1107,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short_no_arg() {\n+    fn test_optmulti_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1118,7 +1118,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_optmulti_short_multi() {\n+    fn test_optmulti_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1135,7 +1135,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_unrecognized_option_long() {\n+    fn test_unrecognized_option_long() {\n         let args = ~[~\"--untest\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1146,7 +1146,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_unrecognized_option_short() {\n+    fn test_unrecognized_option_short() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1157,7 +1157,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_combined() {\n+    fn test_combined() {\n         let args =\n             ~[~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n@@ -1189,7 +1189,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_multi() {\n+    fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\"), optopt(~\"f\")];\n         let matches = &match getopts(args, opts) {\n@@ -1211,7 +1211,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_nospace() {\n+    fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n         let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n@@ -1226,7 +1226,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_reqopt() {\n+    fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n@@ -1237,7 +1237,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optopt() {\n+    fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n@@ -1248,7 +1248,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optflag() {\n+    fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n         assert!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n@@ -1259,7 +1259,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optflagopt() {\n+    fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"p\",\n@@ -1271,7 +1271,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_optmulti() {\n+    fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"l\",\n@@ -1283,7 +1283,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_long_to_short() {\n+    fn test_groups_long_to_short() {\n         let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n@@ -1292,7 +1292,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_getopts() {\n+    fn test_groups_getopts() {\n         let short = ~[\n             reqopt(~\"b\"), reqopt(~\"banana\"),\n             optopt(~\"a\"), optopt(~\"apple\"),\n@@ -1318,7 +1318,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_groups_usage() {\n+    fn test_groups_usage() {\n         let optgroups = ~[\n             groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n             groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n@@ -1349,7 +1349,7 @@ Options:\n     }\n \n     #[test]\n-    pub fn test_groups_usage_description_wrapping() {\n+    fn test_groups_usage_description_wrapping() {\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n "}, {"sha": "8e173ff8a9c6a34b5b6dd7a36bc5046ba9e3531d", "filename": "src/libstd/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -160,7 +160,7 @@ mod tests {\n     use core::option;\n \n     #[test]\n-    pub fn test_is_empty() {\n+    fn test_is_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n         let full1 = from_vec(~[1]);\n         let full2 = from_vec(~['r', 'u']);\n@@ -171,7 +171,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_vec() {\n+    fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n         assert!((head(l) == 0));\n@@ -184,13 +184,13 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_from_vec_empty() {\n+    fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n         assert!((empty == @list::Nil::<int>));\n     }\n \n     #[test]\n-    pub fn test_foldl() {\n+    fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n@@ -199,7 +199,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_foldl2() {\n+    fn test_foldl2() {\n         fn sub(a: &int, b: &int) -> int {\n             *a - *b\n         }\n@@ -208,14 +208,14 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_find_success() {\n+    fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n         assert!((list::find(l, match_) == option::Some(2)));\n     }\n \n     #[test]\n-    pub fn test_find_fail() {\n+    fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n@@ -224,7 +224,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_has() {\n+    fn test_has() {\n         let l = from_vec(~[5, 8, 6]);\n         let empty = @list::Nil::<int>;\n         assert!((list::has(l, 5)));\n@@ -234,15 +234,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_len() {\n+    fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert!((list::len(l) == 3u));\n         assert!((list::len(empty) == 0u));\n     }\n \n     #[test]\n-    pub fn test_append() {\n+    fn test_append() {\n         assert!(from_vec(~[1,2,3,4])\n             == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n     }"}, {"sha": "b32df75063d97941bf3bc796283bd4db418cf5e8", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -1426,7 +1426,7 @@ struct TcpBufferedSocketData {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use net::ip;\n     use net::tcp::{GenericListenErr, TcpConnectErrData, TcpListenErrData};\n     use net::tcp::{connect, accept, read, listen, TcpSocket, socket_buf};\n@@ -1447,9 +1447,9 @@ pub mod test {\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]\n     #[cfg(target_os=\"android\")]\n-    pub mod tcp_ipv4_server_and_client_test {\n+    mod tcp_ipv4_server_and_client_test {\n         #[cfg(target_arch=\"x86_64\")]\n-        pub mod impl64 {\n+        mod impl64 {\n             use net::tcp::test::*;\n \n             #[test]\n@@ -1497,7 +1497,7 @@ pub mod test {\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         #[cfg(target_arch=\"mips\")]\n-        pub mod impl32 {\n+        mod impl32 {\n             use net::tcp::test::*;\n \n             #[test]"}, {"sha": "4cb9a98036b19dca251aa0625c89dd96e75c4666", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -810,7 +810,7 @@ mod tests {\n     use core::hashmap::HashMap;\n \n     #[test]\n-    pub fn test_url_parse() {\n+    fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n \n         let up = from_str(url);\n@@ -826,109 +826,109 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_url_parse_host_slash() {\n+    fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.host == ~\"0.42.42.42\");\n         assert!(url.path == ~\"/\");\n     }\n \n     #[test]\n-    pub fn test_url_with_underscores() {\n+    fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.path == ~\"/file_name.html\");\n     }\n \n     #[test]\n-    pub fn test_url_with_dashes() {\n+    fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert!(url.path == ~\"/file-name.html\");\n     }\n \n     #[test]\n-    pub fn test_no_scheme() {\n+    fn test_no_scheme() {\n         assert!(get_scheme(\"noschemehere.html\").is_err());\n     }\n \n     #[test]\n-    pub fn test_invalid_scheme_errors() {\n+    fn test_invalid_scheme_errors() {\n         assert!(from_str(\"99://something\").is_err());\n         assert!(from_str(\"://something\").is_err());\n     }\n \n     #[test]\n-    pub fn test_full_url_parse_and_format() {\n+    fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_userless_url_parse_and_format() {\n+    fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_queryless_url_parse_and_format() {\n+    fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_empty_query_url_parse_and_format() {\n+    fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n         assert!(from_str(url).unwrap().to_str() == should_be);\n     }\n \n     #[test]\n-    pub fn test_fragmentless_url_parse_and_format() {\n+    fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_minimal_url_parse_and_format() {\n+    fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_scheme_host_only_url_parse_and_format() {\n+    fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_pathless_url_parse_and_format() {\n+    fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_scheme_host_fragment_only_url_parse_and_format() {\n+    fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_url_component_encoding() {\n+    fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n         assert!(u.path == ~\"/doc uments\");\n         assert!(u.query == ~[(~\"ba%d \", ~\"#&+\")]);\n     }\n \n     #[test]\n-    pub fn test_url_without_authority() {\n+    fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n         assert!(from_str(url).unwrap().to_str() == url);\n     }\n \n     #[test]\n-    pub fn test_encode() {\n+    fn test_encode() {\n         assert!(encode(\"\") == ~\"\");\n         assert!(encode(\"http://example.com\") == ~\"http://example.com\");\n         assert!(encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\");\n@@ -956,7 +956,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_encode_component() {\n+    fn test_encode_component() {\n         assert!(encode_component(\"\") == ~\"\");\n         assert!(encode_component(\"http://example.com\") ==\n             ~\"http%3A%2F%2Fexample.com\");\n@@ -985,7 +985,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_decode() {\n+    fn test_decode() {\n         assert!(decode(\"\") == ~\"\");\n         assert!(decode(\"abc/def 123\") == ~\"abc/def 123\");\n         assert!(decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\");\n@@ -1013,7 +1013,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_decode_component() {\n+    fn test_decode_component() {\n         assert!(decode_component(\"\") == ~\"\");\n         assert!(decode_component(\"abc/def 123\") == ~\"abc/def 123\");\n         assert!(decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\");\n@@ -1041,7 +1041,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_encode_form_urlencoded() {\n+    fn test_encode_form_urlencoded() {\n         let mut m = HashMap::new();\n         assert!(encode_form_urlencoded(&m) == ~\"\");\n \n@@ -1060,7 +1060,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_decode_form_urlencoded() {\n+    fn test_decode_form_urlencoded() {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*"}, {"sha": "6aa4d1c54bc9e8e949558ca405cbe1d780b3a4ec", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -282,7 +282,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         struct Test {\n             input: ~str,\n             output: ~[u8],"}, {"sha": "72a888fcc917be74b0fce4e07f773e5251562d02", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -733,7 +733,7 @@ mod test_qsort3 {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n@@ -745,7 +745,7 @@ mod test_qsort3 {\n     }\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         {\n             let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -777,7 +777,7 @@ mod test_qsort {\n     use core::int;\n     use core::vec;\n \n-    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n@@ -790,7 +790,7 @@ mod test_qsort {\n     }\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         {\n             let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -816,7 +816,7 @@ mod test_qsort {\n \n     // Regression test for #750\n     #[test]\n-    pub fn test_simple() {\n+    fn test_simple() {\n         let mut names = ~[2, 1, 3];\n \n         let expected = ~[1, 2, 3];\n@@ -842,7 +842,7 @@ mod tests {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &[int], v2: &[int]) {\n+    fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n@@ -856,7 +856,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test() {\n+    fn test() {\n         {\n             let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -873,15 +873,15 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_merge_sort_mutable() {\n+    fn test_merge_sort_mutable() {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert!(v2 == ~[1, 2, 3]);\n     }\n \n     #[test]\n-    pub fn test_merge_sort_stability() {\n+    fn test_merge_sort_stability() {\n         // tjc: funny that we have to use parens\n         fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {"}, {"sha": "971bb51f7e9f4b5e6679a06e8d52a2a994d459f4", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -728,19 +728,19 @@ mod tests {\n      * Semaphore tests\n      ************************************************************************/\n     #[test]\n-    pub fn test_sem_acquire_release() {\n+    fn test_sem_acquire_release() {\n         let s = ~semaphore(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n     #[test]\n-    pub fn test_sem_basic() {\n+    fn test_sem_basic() {\n         let s = ~semaphore(1);\n         do s.access { }\n     }\n     #[test]\n-    pub fn test_sem_as_mutex() {\n+    fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n         do task::spawn || {\n@@ -753,7 +753,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_sem_as_cvar() {\n+    fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (p,c) = comm::stream();\n         let s = ~semaphore(0);\n@@ -779,7 +779,7 @@ mod tests {\n         c.send(());\n     }\n     #[test]\n-    pub fn test_sem_multi_resource() {\n+    fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n         let s = ~semaphore(2);\n@@ -798,7 +798,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_sem_runtime_friendly_blocking() {\n+    fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::ManualThreads(1)) {\n@@ -823,7 +823,7 @@ mod tests {\n      * Mutex tests\n      ************************************************************************/\n     #[test]\n-    pub fn test_mutex_lock() {\n+    fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n         let (p,c) = comm::stream();\n@@ -854,7 +854,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_mutex_cond_wait() {\n+    fn test_mutex_cond_wait() {\n         let m = ~Mutex();\n \n         // Child wakes up parent\n@@ -886,7 +886,7 @@ mod tests {\n         let _ = port.recv(); // Wait until child wakes up\n     }\n     #[cfg(test)]\n-    pub fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n+    fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = ~Mutex();\n         let mut ports = ~[];\n \n@@ -913,15 +913,15 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n     }\n     #[test]\n-    pub fn test_mutex_cond_broadcast() {\n+    fn test_mutex_cond_broadcast() {\n         test_mutex_cond_broadcast_helper(12);\n     }\n     #[test]\n-    pub fn test_mutex_cond_broadcast_none() {\n+    fn test_mutex_cond_broadcast_none() {\n         test_mutex_cond_broadcast_helper(0);\n     }\n     #[test]\n-    pub fn test_mutex_cond_no_waiter() {\n+    fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         do task::try || {\n@@ -932,7 +932,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_killed_simple() {\n+    fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n@@ -947,7 +947,7 @@ mod tests {\n         do m.lock { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_killed_cond() {\n+    fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n         let m = ~Mutex();\n@@ -973,7 +973,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_killed_broadcast() {\n+    fn test_mutex_killed_broadcast() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         let (p,c) = comm::stream();\n@@ -1026,7 +1026,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_mutex_cond_signal_on_0() {\n+    fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n@@ -1040,7 +1040,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_different_conds() {\n+    fn test_mutex_different_conds() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n@@ -1061,7 +1061,7 @@ mod tests {\n         assert!(result.is_err());\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_mutex_no_condvars() {\n+    fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n@@ -1084,7 +1084,7 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n+    fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1100,7 +1100,7 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    pub fn test_rwlock_exclusion(x: ~RWlock,\n+    fn test_rwlock_exclusion(x: ~RWlock,\n                                  mode1: RWlockMode,\n                                  mode2: RWlockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n@@ -1132,21 +1132,21 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_rwlock_readers_wont_modify_the_data() {\n+    fn test_rwlock_readers_wont_modify_the_data() {\n         test_rwlock_exclusion(~RWlock(), Read, Write);\n         test_rwlock_exclusion(~RWlock(), Write, Read);\n         test_rwlock_exclusion(~RWlock(), Read, Downgrade);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Read);\n     }\n     #[test]\n-    pub fn test_rwlock_writers_and_writers() {\n+    fn test_rwlock_writers_and_writers() {\n         test_rwlock_exclusion(~RWlock(), Write, Write);\n         test_rwlock_exclusion(~RWlock(), Write, Downgrade);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Write);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    pub fn test_rwlock_handshake(x: ~RWlock,\n+    fn test_rwlock_handshake(x: ~RWlock,\n                                  mode1: RWlockMode,\n                                  mode2: RWlockMode,\n                                  make_mode2_go_first: bool) {\n@@ -1178,7 +1178,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    pub fn test_rwlock_readers_and_readers() {\n+    fn test_rwlock_readers_and_readers() {\n         test_rwlock_handshake(~RWlock(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n@@ -1187,7 +1187,7 @@ mod tests {\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n-    pub fn test_rwlock_downgrade_unlock() {\n+    fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n@@ -1197,12 +1197,12 @@ mod tests {\n         test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n-    pub fn test_rwlock_read_recursive() {\n+    fn test_rwlock_read_recursive() {\n         let x = ~RWlock();\n         do x.read { do x.read { } }\n     }\n     #[test]\n-    pub fn test_rwlock_cond_wait() {\n+    fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = ~RWlock();\n \n@@ -1237,7 +1237,7 @@ mod tests {\n         do x.read { } // Just for good measure\n     }\n     #[cfg(test)]\n-    pub fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n+    fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n@@ -1276,7 +1276,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n     }\n     #[test]\n-    pub fn test_rwlock_cond_broadcast() {\n+    fn test_rwlock_cond_broadcast() {\n         test_rwlock_cond_broadcast_helper(0, true, true);\n         test_rwlock_cond_broadcast_helper(0, true, false);\n         test_rwlock_cond_broadcast_helper(0, false, true);\n@@ -1287,7 +1287,7 @@ mod tests {\n         test_rwlock_cond_broadcast_helper(12, false, false);\n     }\n     #[cfg(test)] #[ignore(cfg(windows))]\n-    pub fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n+    fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let x = ~RWlock();\n         let x2 = (*x).clone();\n@@ -1302,23 +1302,23 @@ mod tests {\n         do lock_rwlock_in_mode(x, mode2) { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_reader_killed_writer() {\n+    fn test_rwlock_reader_killed_writer() {\n         rwlock_kill_helper(Read, Write);\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_writer_killed_reader() {\n+    fn test_rwlock_writer_killed_reader() {\n         rwlock_kill_helper(Write,Read );\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_reader_killed_reader() {\n+    fn test_rwlock_reader_killed_reader() {\n         rwlock_kill_helper(Read, Read );\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_writer_killed_writer() {\n+    fn test_rwlock_writer_killed_writer() {\n         rwlock_kill_helper(Write,Write);\n     }\n     #[test] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_kill_downgrader() {\n+    fn test_rwlock_kill_downgrader() {\n         rwlock_kill_helper(Downgrade, Read);\n         rwlock_kill_helper(Read, Downgrade);\n         rwlock_kill_helper(Downgrade, Write);\n@@ -1333,7 +1333,7 @@ mod tests {\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    pub fn test_rwlock_downgrade_cant_swap() {\n+    fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token.\n         let x = ~RWlock();\n         let y = ~RWlock();"}, {"sha": "ee83a0c9bd65250b9ac7d7e23cda59b737c9e292", "filename": "src/libstd/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -823,7 +823,7 @@ mod tests {\n \n     #[test]\n     #[ignore(cfg(windows))]\n-    pub fn test_should_fail() {\n+    fn test_should_fail() {\n         fn f() { fail!(); }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n@@ -841,7 +841,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_should_fail_but_succeeds() {\n+    fn test_should_fail_but_succeeds() {\n         fn f() { }\n         let desc = TestDescAndFn {\n             desc: TestDesc {\n@@ -859,7 +859,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn first_free_arg_should_be_a_filter() {\n+    fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,\n@@ -869,7 +869,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn parse_ignored_flag() {\n+    fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,"}, {"sha": "70dc4d8cfebbf033e97172bf38878b3e4621d0be", "filename": "src/libstd/time.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -872,7 +872,7 @@ mod tests {\n     use core::str;\n     use core::vec;\n \n-    pub fn test_get_time() {\n+    fn test_get_time() {\n         static some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n         static some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n@@ -893,7 +893,7 @@ mod tests {\n         }\n     }\n \n-    pub fn test_precise_time() {\n+    fn test_precise_time() {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n@@ -910,7 +910,7 @@ mod tests {\n         assert!(ns2 >= ns1);\n     }\n \n-    pub fn test_at_utc() {\n+    fn test_at_utc() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -931,7 +931,7 @@ mod tests {\n         assert!(utc.tm_nsec == 54321_i32);\n     }\n \n-    pub fn test_at() {\n+    fn test_at() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -959,7 +959,7 @@ mod tests {\n         assert!(local.tm_nsec == 54321_i32);\n     }\n \n-    pub fn test_to_timespec() {\n+    fn test_to_timespec() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -970,7 +970,7 @@ mod tests {\n         assert!(utc.to_local().to_timespec() == time);\n     }\n \n-    pub fn test_conversions() {\n+    fn test_conversions() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -986,7 +986,7 @@ mod tests {\n         assert!(utc.to_local().to_utc() == utc);\n     }\n \n-    pub fn test_strptime() {\n+    fn test_strptime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1144,7 +1144,7 @@ mod tests {\n         assert!(test(~\"%\", ~\"%%\"));\n     }\n \n-    pub fn test_ctime() {\n+    fn test_ctime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1158,7 +1158,7 @@ mod tests {\n         assert!(local.ctime() == ~\"Fri Feb 13 15:31:30 2009\");\n     }\n \n-    pub fn test_strftime() {\n+    fn test_strftime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1231,7 +1231,7 @@ mod tests {\n         assert!(utc.rfc3339() == ~\"2009-02-13T23:31:30Z\");\n     }\n \n-    pub fn test_timespec_eq_ord() {\n+    fn test_timespec_eq_ord() {\n         use core::cmp::{eq, ge, gt, le, lt, ne};\n \n         let a = &Timespec::new(-2, 1);\n@@ -1265,7 +1265,7 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn run_tests() {\n+    fn run_tests() {\n         // The tests race on tzset. So instead of having many independent\n         // tests, we will just call the functions now.\n         test_get_time();"}, {"sha": "c229e72ae5d4a40ee6566b331172dbd6aabeb06e", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -183,21 +183,21 @@ mod test {\n     use core::pipes::{stream, SharedChan};\n \n     #[test]\n-    pub fn test_gl_timer_simple_sleep_test() {\n+    fn test_gl_timer_simple_sleep_test() {\n         let hl_loop = &uv::global_loop::get();\n         sleep(hl_loop, 1u);\n     }\n \n     #[test]\n-    pub fn test_gl_timer_sleep_stress1() {\n+    fn test_gl_timer_sleep_stress1() {\n         let hl_loop = &uv::global_loop::get();\n         for iter::repeat(50u) {\n             sleep(hl_loop, 1u);\n         }\n     }\n \n     #[test]\n-    pub fn test_gl_timer_sleep_stress2() {\n+    fn test_gl_timer_sleep_stress2() {\n         let (po, ch) = stream();\n         let ch = SharedChan(ch);\n         let hl_loop = &uv::global_loop::get();\n@@ -241,7 +241,7 @@ mod test {\n \n     #[test]\n     #[cfg(ignore)]\n-    pub fn test_gl_timer_recv_timeout_before_time_passes() {\n+    fn test_gl_timer_recv_timeout_before_time_passes() {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;\n@@ -270,7 +270,7 @@ mod test {\n     }\n \n     #[test]\n-    pub fn test_gl_timer_recv_timeout_after_time_passes() {\n+    fn test_gl_timer_recv_timeout_after_time_passes() {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;"}, {"sha": "740ecec001f832805e5957dfe7ea24f9ddf55cdf", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -1225,7 +1225,7 @@ pub unsafe fn addrinfo_as_sockaddr_in6(input: *addrinfo) -> *sockaddr_in6 {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use core::prelude::*;\n     use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n     use super::*;\n@@ -1759,11 +1759,11 @@ pub mod test {\n     #[cfg(target_os=\"darwin\")]\n     #[cfg(target_os=\"linux\")]\n     #[cfg(target_os=\"android\")]\n-    pub mod tcp_and_server_client_test {\n+    mod tcp_and_server_client_test {\n         #[cfg(target_arch=\"x86_64\")]\n-        pub mod impl64 {\n+        mod impl64 {\n             #[test]\n-            pub fn test_uv_ll_tcp_server_and_request() {\n+            fn test_uv_ll_tcp_server_and_request() {\n                 unsafe {\n                     super::super::impl_uv_tcp_server_and_request();\n                 }\n@@ -1772,10 +1772,10 @@ pub mod test {\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         #[cfg(target_arch=\"mips\")]\n-        pub mod impl32 {\n+        mod impl32 {\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            pub fn test_uv_ll_tcp_server_and_request() {\n+            fn test_uv_ll_tcp_server_and_request() {\n                 unsafe {\n                     super::super::impl_uv_tcp_server_and_request();\n                 }"}, {"sha": "bc930515a5d89886fc1586eeddb464a9c7aa4ccb", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -781,7 +781,7 @@ fn consume_whitespace(rdr: @mut StringReader) {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use super::*;\n \n     use ast;"}, {"sha": "88ecabe28f526928cbc28a552b81cfdc1a5a3059", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -2248,7 +2248,7 @@ pub fn print_onceness(s: @ps, o: ast::Onceness) {\n }\n \n #[cfg(test)]\n-pub mod test {\n+mod test {\n     use super::*;\n \n     use ast;"}, {"sha": "1133fd850d84b4026e3573b4d42e96e6f64aadb2", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=d3be98e9f5e721b53dccd0a43c2ff58ddd32ac47", "patch": "@@ -66,43 +66,47 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n }\n \n-#[test]\n-#[should_fail]\n-pub fn i1 () {\n-    let i : Interner<@~str> = Interner::new();\n-    i.get(13);\n-}\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    #[test]\n+    #[should_fail]\n+    fn i1 () {\n+        let i : Interner<@~str> = Interner::new();\n+        i.get(13);\n+    }\n \n-#[test]\n-pub fn i2 () {\n-    let i : Interner<@~str> = Interner::new();\n-    // first one is zero:\n-    assert_eq!(i.intern (@~\"dog\"), 0);\n-    // re-use gets the same entry:\n-    assert_eq!(i.intern (@~\"dog\"), 0);\n-    // different string gets a different #:\n-    assert_eq!(i.intern (@~\"cat\"), 1);\n-    assert_eq!(i.intern (@~\"cat\"), 1);\n-    // dog is still at zero\n-    assert_eq!(i.intern (@~\"dog\"), 0);\n-    // gensym gets 3\n-    assert_eq!(i.gensym (@~\"zebra\" ), 2);\n-    // gensym of same string gets new number :\n-    assert_eq!(i.gensym (@~\"zebra\" ), 3);\n-    // gensym of *existing* string gets new number:\n-    assert_eq!(i.gensym (@~\"dog\"), 4);\n-    assert_eq!(i.get(0), @~\"dog\");\n-    assert_eq!(i.get(1), @~\"cat\");\n-    assert_eq!(i.get(2), @~\"zebra\");\n-    assert_eq!(i.get(3), @~\"zebra\");\n-    assert_eq!(i.get(4), @~\"dog\");\n-}\n+    #[test]\n+    fn i2 () {\n+        let i : Interner<@~str> = Interner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern (@~\"dog\"), 0);\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (@~\"dog\"), 0);\n+        // different string gets a different #:\n+        assert_eq!(i.intern (@~\"cat\"), 1);\n+        assert_eq!(i.intern (@~\"cat\"), 1);\n+        // dog is still at zero\n+        assert_eq!(i.intern (@~\"dog\"), 0);\n+        // gensym gets 3\n+        assert_eq!(i.gensym (@~\"zebra\" ), 2);\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym (@~\"zebra\" ), 3);\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym (@~\"dog\"), 4);\n+        assert_eq!(i.get(0), @~\"dog\");\n+        assert_eq!(i.get(1), @~\"cat\");\n+        assert_eq!(i.get(2), @~\"zebra\");\n+        assert_eq!(i.get(3), @~\"zebra\");\n+        assert_eq!(i.get(4), @~\"dog\");\n+    }\n \n-#[test]\n-pub fn i3 () {\n-    let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n-    assert_eq!(i.get(0), @~\"Alan\");\n-    assert_eq!(i.get(1), @~\"Bob\");\n-    assert_eq!(i.get(2), @~\"Carol\");\n-    assert_eq!(i.intern(@~\"Bob\"), 1);\n-}\n+    #[test]\n+    fn i3 () {\n+        let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n+        assert_eq!(i.get(0), @~\"Alan\");\n+        assert_eq!(i.get(1), @~\"Bob\");\n+        assert_eq!(i.get(2), @~\"Carol\");\n+        assert_eq!(i.intern(@~\"Bob\"), 1);\n+    }\n+}\n\\ No newline at end of file"}]}