{"sha": "dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNWE1YTQ2ZGMxYzE4MWIwNmQ3MDMxMjhlYzM0YmMyYmYyNjA3ZDU=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-05-18T07:12:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-18T07:12:58Z"}, "message": "Merge pull request #2763 from phansch/tasty_ice_cream\n\nFix SpanlessHash and SpanlessEq tables", "tree": {"sha": "c04945f03a5a7697b54637e2f513d4671f98b7ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c04945f03a5a7697b54637e2f513d4671f98b7ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa/nz6CRBK7hj4Ov3rIwAAdHIIADA68cezLI7kzs63kLcjeXD7\nOqB//t0ZTU3FO7rHHzelAkirCc+3DnAdaewXu9FRNvpikECnWKA+4fYpEEQd3kag\nPKXrMgqvQjo0fiP+7RcJOaC5NoOzLCZpWpzSQOAAKh/tbYPPkxmgVsBLMAyim88C\neOPOtL0Sa90EKs6MDl6lYtlTLF41Cb+l8klf+uq/Rl2yKlCoh2jfNLfeKExzz+aJ\nSxnhtnCZ34Zq0Wq+uIZHaONFu1QbUJqlAMX3E3soycKhf66ajS8u7eDe3EjTz9w2\n+43OiRvilxCNom23TjxNq1k2JOv89Ys4pLXTossMGlhCLk8o2T4UQTFmUFbuC9w=\n=kZvN\n-----END PGP SIGNATURE-----\n", "payload": "tree c04945f03a5a7697b54637e2f513d4671f98b7ab\nparent 3c068d7ba5442c0f328229e25b66b5a697b29aa5\nparent ed885dc2b320e26f47b15ef50f442e4e40cce954\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1526627578 +0200\ncommitter GitHub <noreply@github.com> 1526627578 +0200\n\nMerge pull request #2763 from phansch/tasty_ice_cream\n\nFix SpanlessHash and SpanlessEq tables"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "html_url": "https://github.com/rust-lang/rust/commit/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c068d7ba5442c0f328229e25b66b5a697b29aa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c068d7ba5442c0f328229e25b66b5a697b29aa5", "html_url": "https://github.com/rust-lang/rust/commit/3c068d7ba5442c0f328229e25b66b5a697b29aa5"}, {"sha": "ed885dc2b320e26f47b15ef50f442e4e40cce954", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed885dc2b320e26f47b15ef50f442e4e40cce954", "html_url": "https://github.com/rust-lang/rust/commit/ed885dc2b320e26f47b15ef50f442e4e40cce954"}], "stats": {"total": 183, "additions": 132, "deletions": 51}, "files": [{"sha": "b5a42f03e9adbeafa59df7a92810483d0fbf370e", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n                 let size = size.assert_usize(cx.tcx).unwrap().into();\n \n                 // Index is a constant uint\n-                if let Some((Constant::Int(const_index), _)) = constant(cx, index) {\n+                if let Some((Constant::Int(const_index), _)) = constant(cx, cx.tables, index) {\n                     if size <= const_index {\n                         utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n                     }\n@@ -101,14 +101,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n /// Returns an option containing a tuple with the start and end (exclusive) of\n /// the range.\n fn to_const_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, range: Range, array_size: u128) -> Option<(u128, u128)> {\n-    let s = range.start.map(|expr| constant(cx, expr).map(|(c, _)| c));\n+    let s = range.start.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let start = match s {\n         Some(Some(Constant::Int(x))) => x,\n         Some(_) => return None,\n         None => 0,\n     };\n \n-    let e = range.end.map(|expr| constant(cx, expr).map(|(c, _)| c));\n+    let e = range.end.map(|expr| constant(cx, cx.tables, expr).map(|(c, _)| c));\n     let end = match e {\n         Some(Some(Constant::Int(x))) => if range.limits == RangeLimits::Closed {\n             x + 1"}, {"sha": "4f38fb928316a5bf23bcd87667ad0c004961008f", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -301,7 +301,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n }\n \n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n-    match constant(cx, lit)?.0 {\n+    match constant(cx, cx.tables, lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,\n     }"}, {"sha": "bc57be94cdb65965c09a2efcb4da62941bfdbb61", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -163,23 +163,23 @@ pub fn lit_to_constant<'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n     }\n }\n \n-pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n+pub fn constant<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTables<'cc>, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         tcx: lcx.tcx,\n-        tables: lcx.tables,\n+        tables,\n         param_env: lcx.param_env,\n         needed_resolution: false,\n         substs: lcx.tcx.intern_substs(&[]),\n     };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-pub fn constant_simple(lcx: &LateContext, e: &Expr) -> Option<Constant> {\n-    constant(lcx, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n+pub fn constant_simple<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTables<'cc>, e: &Expr) -> Option<Constant> {\n+    constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n /// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckTables`\n-pub fn constant_context<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'cc ty::TypeckTables<'cc>) -> ConstEvalLateContext<'c, 'cc> {\n+pub fn constant_context<'c, 'cc>(lcx: &LateContext<'c, 'cc>, tables: &'c ty::TypeckTables<'cc>) -> ConstEvalLateContext<'c, 'cc> {\n     ConstEvalLateContext {\n         tcx: lcx.tcx,\n         tables,"}, {"sha": "80601fa92fae6f49ba3bd1f15e8973b8b4719888", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -151,7 +151,7 @@ fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n     let hash: &Fn(&&Expr) -> u64 = &|expr| -> u64 {\n-        let mut h = SpanlessHash::new(cx);\n+        let mut h = SpanlessHash::new(cx, cx.tables);\n         h.hash_expr(expr);\n         h.finish()\n     };\n@@ -174,7 +174,7 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n     if let ExprMatch(_, ref arms, MatchSource::Normal) = expr.node {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n+            let mut h = SpanlessHash::new(cx, cx.tables);\n             h.hash_expr(&arm.body);\n             h.finish()\n         };"}, {"sha": "1ccc5708185e63c7a1a24591fa1ad649f9c33175", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> DoubleComparisonPass {\n             }\n             _ => return,\n         };\n-        let spanless_eq = SpanlessEq::new(cx).ignore_fn();\n+        let mut spanless_eq = SpanlessEq::new(cx).ignore_fn();\n         if !(spanless_eq.eq_expr(&llhs, &rlhs) && spanless_eq.eq_expr(&lrhs, &rrhs)) {\n             return;\n         }"}, {"sha": "ae6e078ddaefb0ab718a9689f2c4a4c28c92f61b", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n }\n \n fn check(cx: &LateContext, e: &Expr, span: Span) {\n-    if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         if v == 0 {\n             span_lint(\n                 cx,"}, {"sha": "24e5f823a35d259b45d0878dd09539de41e753da", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n \n #[allow(cast_possible_wrap)]\n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         let check = match cx.tables.expr_ty(e).sty {\n             ty::TyInt(ity) => unsext(cx.tcx, -1i128, ity),\n             ty::TyUint(uty) => clip(cx.tcx, !0, uty),"}, {"sha": "b0f3993766853e70233d3ff8ad375855d68f9f15", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -1120,8 +1120,8 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n     }) = higher::range(cx, arg)\n     {\n         // ...and both sides are compile-time constant integers...\n-        if let Some((start_idx, _)) = constant(cx, start) {\n-            if let Some((end_idx, _)) = constant(cx, end) {\n+        if let Some((start_idx, _)) = constant(cx, cx.tables, start) {\n+            if let Some((end_idx, _)) = constant(cx, cx.tables, end) {\n                 // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the\n@@ -2146,7 +2146,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n }\n \n fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, block: &'tcx Block, expr: &'tcx Expr) {\n-    if constant(cx, cond).is_some() {\n+    if constant(cx, cx.tables, cond).is_some() {\n         // A pure constant condition (e.g. while false) is not linted.\n         return;\n     }"}, {"sha": "b593c33050359f46582bc8c21fe1cac010a2fe67", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -470,8 +470,8 @@ fn all_ranges<'a, 'tcx>(\n                 [].iter()\n             }.filter_map(|pat| {\n                 if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node {\n-                    let lhs = constant(cx, lhs)?.0;\n-                    let rhs = constant(cx, rhs)?.0;\n+                    let lhs = constant(cx, cx.tables, lhs)?.0;\n+                    let rhs = constant(cx, cx.tables, rhs)?.0;\n                     let rhs = match *range_end {\n                         RangeEnd::Included => Bound::Included(rhs),\n                         RangeEnd::Excluded => Bound::Excluded(rhs),\n@@ -480,7 +480,7 @@ fn all_ranges<'a, 'tcx>(\n                 }\n \n                 if let PatKind::Lit(ref value) = pat.node {\n-                    let value = constant(cx, value)?.0;\n+                    let value = constant(cx, cx.tables, value)?.0;\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), Bound::Included(value)) });\n                 }\n "}, {"sha": "4c80fdb01c5bb2afd573d44a6787500d63f91209", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -1751,7 +1751,7 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, arg: &'tcx hir::Expr) {\n-    if let Some((Constant::Str(r), _)) = constant(cx, arg) {\n+    if let Some((Constant::Str(r), _)) = constant(cx, cx.tables, arg) {\n         if r.len() == 1 {\n             let c = r.chars().next().unwrap();\n             let snip = snippet(cx, expr.span, \"..\");"}, {"sha": "289c5c77ff35290883096a7d6a99c7523e776ee4", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -81,14 +81,14 @@ fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(Min\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(cx, &args[0]) {\n-        if constant_simple(cx, &args[1]).is_none() {\n+    if let Some(c) = constant_simple(cx, cx.tables, &args[0]) {\n+        if constant_simple(cx, cx.tables, &args[1]).is_none() {\n             // otherwise ignore\n             Some((m, c, &args[1]))\n         } else {\n             None\n         }\n-    } else if let Some(c) = constant_simple(cx, &args[1]) {\n+    } else if let Some(c) = constant_simple(cx, cx.tables, &args[1]) {\n         Some((m, c, &args[0]))\n     } else {\n         None"}, {"sha": "0ecd0ac1895d3f96ccdd201c5e85ef96a3ecd207", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -446,15 +446,15 @@ fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n }\n \n fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n-    if let Some((_, res)) = constant(cx, expr) {\n+    if let Some((_, res)) = constant(cx, cx.tables, expr) {\n         res\n     } else {\n        false\n     }\n }\n \n fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n-    match constant(cx, expr) {\n+    match constant(cx, cx.tables, expr) {\n         Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n         _ => false,"}, {"sha": "5d13b3e1ae6d7361aa20cff0d7b794a277746460", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) {\n                 use consts::{constant, Constant};\n-                if let Some((Constant::Int(0), _)) = constant(cx, &args[1]) {\n+                if let Some((Constant::Int(0), _)) = constant(cx, cx.tables, &args[1]) {\n                     span_lint(\n                         cx,\n                         ITERATOR_STEP_BY_ZERO,"}, {"sha": "522c2b9ac29a41518d797725941159a3109ef7bf", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -138,7 +138,7 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n }\n \n fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<String> {\n-    constant(cx, e).and_then(|(c, _)| match c {\n+    constant(cx, cx.tables, e).and_then(|(c, _)| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n     })"}, {"sha": "168086d574a3552b2beca26e6fe33d106d4c3d09", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -1341,7 +1341,7 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -\n \n     let ty = cx.tables.expr_ty(expr);\n \n-    let cv = constant(cx, expr)?.0;\n+    let cv = constant(cx, cx.tables, expr)?.0;\n \n     let which = match (&ty.sty, cv) {\n         (&ty::TyBool, Constant::Bool(false)) |\n@@ -1526,7 +1526,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n }\n \n fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<FullInt> {\n-    let val = constant(cx, expr)?.0;\n+    let val = constant(cx, cx.tables, expr)?.0;\n     if let Constant::Int(const_int) = val {\n         match cx.tables.expr_ty(expr).sty {\n             ty::TyInt(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),"}, {"sha": "7d9945cdddceadec31ac07ad5155bc8adbd87ef4", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -1,6 +1,7 @@\n use consts::{constant_simple, constant_context};\n use rustc::lint::*;\n use rustc::hir::*;\n+use rustc::ty::{TypeckTables};\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n use syntax::ast::Name;\n@@ -16,6 +17,7 @@ use utils::differing_macro_contexts;\n pub struct SpanlessEq<'a, 'tcx: 'a> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'a, 'tcx>,\n+    tables: &'a TypeckTables<'tcx>,\n     /// If is true, never consider as equal expressions containing function\n     /// calls.\n     ignore_fn: bool,\n@@ -25,19 +27,21 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         Self {\n             cx,\n+            tables: cx.tables,\n             ignore_fn: false,\n         }\n     }\n \n     pub fn ignore_fn(self) -> Self {\n         Self {\n             cx: self.cx,\n+            tables: self.cx.tables,\n             ignore_fn: true,\n         }\n     }\n \n     /// Check whether two statements are the same.\n-    pub fn eq_stmt(&self, left: &Stmt, right: &Stmt) -> bool {\n+    pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n         match (&left.node, &right.node) {\n             (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n                 if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n@@ -54,17 +58,17 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Check whether two blocks are the same.\n-    pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n+    pub fn eq_block(&mut self, left: &Block, right: &Block) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n-    pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n+    pub fn eq_expr(&mut self, left: &Expr, right: &Expr) -> bool {\n         if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n-        if let (Some(l), Some(r)) = (constant_simple(self.cx, left), constant_simple(self.cx, right)) {\n+        if let (Some(l), Some(r)) = (constant_simple(self.cx, self.tables, left), constant_simple(self.cx, self.tables, right)) {\n             if l == r {\n                 return true;\n             }\n@@ -140,20 +144,20 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_exprs(&self, left: &P<[Expr]>, right: &P<[Expr]>) -> bool {\n+    fn eq_exprs(&mut self, left: &P<[Expr]>, right: &P<[Expr]>) -> bool {\n         over(left, right, |l, r| self.eq_expr(l, r))\n     }\n \n-    fn eq_field(&self, left: &Field, right: &Field) -> bool {\n+    fn eq_field(&mut self, left: &Field, right: &Field) -> bool {\n         left.name.node == right.name.node && self.eq_expr(&left.expr, &right.expr)\n     }\n \n-    fn eq_lifetime(&self, left: &Lifetime, right: &Lifetime) -> bool {\n+    fn eq_lifetime(&mut self, left: &Lifetime, right: &Lifetime) -> bool {\n         left.name == right.name\n     }\n \n     /// Check whether two patterns are the same.\n-    pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n+    pub fn eq_pat(&mut self, left: &Pat, right: &Pat) -> bool {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n@@ -180,7 +184,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n+    fn eq_qpath(&mut self, left: &QPath, right: &QPath) -> bool {\n         match (left, right) {\n             (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n                 both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n@@ -192,12 +196,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path(&self, left: &Path, right: &Path) -> bool {\n+    fn eq_path(&mut self, left: &Path, right: &Path) -> bool {\n         left.is_global() == right.is_global()\n             && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n-    fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n+    fn eq_path_parameters(&mut self, left: &PathParameters, right: &PathParameters) -> bool {\n         if !(left.parenthesized || right.parenthesized) {\n             over(&left.lifetimes, &right.lifetimes, |l, r| self.eq_lifetime(l, r))\n                 && over(&left.types, &right.types, |l, r| self.eq_ty(l, r))\n@@ -214,7 +218,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n+    fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n         if left.name.as_str() != right.name.as_str() {\n@@ -227,12 +231,23 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n+    fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyArray(ref lt, ll_id), &TyArray(ref rt, rl_id)) => {\n-                self.eq_ty(lt, rt)\n-                    && self.eq_expr(&self.cx.tcx.hir.body(ll_id).value, &self.cx.tcx.hir.body(rl_id).value)\n+                let full_table = self.tables;\n+\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id));\n+                self.tables = self.cx.tcx.body_tables(ll_id);\n+                let ll = celcx.expr(&self.cx.tcx.hir.body(ll_id).value);\n+\n+                let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(rl_id));\n+                self.tables = self.cx.tcx.body_tables(rl_id);\n+                let rl = celcx.expr(&self.cx.tcx.hir.body(rl_id).value);\n+\n+                let eq_ty = self.eq_ty(lt, rt);\n+                self.tables = full_table;\n+                eq_ty && ll == rl\n             },\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n@@ -245,7 +260,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_type_binding(&self, left: &TypeBinding, right: &TypeBinding) -> bool {\n+    fn eq_type_binding(&mut self, left: &TypeBinding, right: &TypeBinding) -> bool {\n         left.name == right.name && self.eq_ty(&left.ty, &right.ty)\n     }\n }\n@@ -288,13 +303,15 @@ where\n pub struct SpanlessHash<'a, 'tcx: 'a> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'a, 'tcx>,\n+    tables: &'a TypeckTables<'tcx>,\n     s: DefaultHasher,\n }\n \n impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n-    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+    pub fn new(cx: &'a LateContext<'a, 'tcx>, tables: &'a TypeckTables<'tcx>) -> Self {\n         Self {\n             cx,\n+            tables,\n             s: DefaultHasher::new(),\n         }\n     }\n@@ -317,7 +334,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n \n     #[allow(many_single_char_names)]\n     pub fn hash_expr(&mut self, e: &Expr) {\n-        if let Some(e) = constant_simple(self.cx, e) {\n+        if let Some(e) = constant_simple(self.cx, self.tables, e) {\n             return e.hash(&mut self.s);\n         }\n \n@@ -461,7 +478,10 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n+                let full_table = self.tables;\n+                self.tables = self.cx.tcx.body_tables(l_id);\n                 self.hash_expr(&self.cx.tcx.hir.body(l_id).value);\n+                self.tables = full_table;\n             },\n             ExprRet(ref e) => {\n                 let c: fn(_) -> _ = ExprRet;"}, {"sha": "6aff0ebc9f7420957b81f86c5ca2a21131b95637", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if constant(cx, len).is_some() {\n+            if constant(cx, cx.tables, len).is_some() {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\"))\n             } else {\n                 return;"}, {"sha": "fc28815c70e673454bc31030893cd10ddc8d401f", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -37,8 +37,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            if let Some(lhs_value) = constant_simple(cx, left);\n-            if let Some(rhs_value) = constant_simple(cx, right);\n+            if let Some(lhs_value) = constant_simple(cx, cx.tables, left);\n+            if let Some(rhs_value) = constant_simple(cx, cx.tables, right);\n             if Constant::F32(0.0) == lhs_value || Constant::F64(0.0) == lhs_value;\n             if Constant::F32(0.0) == rhs_value || Constant::F64(0.0) == rhs_value;\n             then {"}, {"sha": "fcd3e7cf530c1bf850806e8726ccdc3dc6cb6fa9", "filename": "tests/run-pass/ice-1782.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/tests%2Frun-pass%2Fice-1782.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/tests%2Frun-pass%2Fice-1782.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fice-1782.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -0,0 +1,17 @@\n+#![allow(dead_code, unused_variables)]\n+\n+/// Should not trigger an ICE in `SpanlessEq` / `consts::constant`\n+///\n+/// Issue: https://github.com/rust-lang-nursery/rust-clippy/issues/1782\n+\n+use std::{mem, ptr};\n+\n+fn spanless_eq_ice() {\n+    let txt = \"something\";\n+    match txt {\n+        \"something\" => unsafe { ptr::write(ptr::null_mut() as *mut u32, mem::transmute::<[u8; 4], _>([0, 0, 0, 255])) },\n+        _ => unsafe { ptr::write(ptr::null_mut() as *mut u32, mem::transmute::<[u8; 4], _>([13, 246, 24, 255])) },\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "01deb7abfc1065d75d3221d260d18865a471b8ad", "filename": "tests/run-pass/ice-2499.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/tests%2Frun-pass%2Fice-2499.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/tests%2Frun-pass%2Fice-2499.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fice-2499.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -0,0 +1,24 @@\n+#![allow(dead_code, char_lit_as_u8, needless_bool)]\n+\n+/// Should not trigger an ICE in `SpanlessHash` / `consts::constant`\n+///\n+/// Issue: https://github.com/rust-lang-nursery/rust-clippy/issues/2499\n+\n+fn f(s: &[u8]) -> bool {\n+    let t = s[0] as char;\n+\n+    match t {\n+        'E' | 'W' => {}\n+        'T' => if s[0..4] != ['0' as u8; 4] {\n+            return false;\n+        } else {\n+            return true;\n+        },\n+        _ => {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "7cd30b6d946ac29550437503e7854a55f99547f5", "filename": "tests/run-pass/ice-2594.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/tests%2Frun-pass%2Fice-2594.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc5a5a46dc1c181b06d703128ec34bc2bf2607d5/tests%2Frun-pass%2Fice-2594.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fice-2594.rs?ref=dc5a5a46dc1c181b06d703128ec34bc2bf2607d5", "patch": "@@ -0,0 +1,20 @@\n+#![allow(dead_code, unused_variables)]\n+\n+/// Should not trigger an ICE in `SpanlessHash` / `consts::constant`\n+///\n+/// Issue: https://github.com/rust-lang-nursery/rust-clippy/issues/2594\n+\n+fn spanless_hash_ice() {\n+    let txt = \"something\";\n+    let empty_header: [u8; 1] = [1; 1];\n+\n+    match txt {\n+        \"something\" => {\n+            let mut headers = [empty_header; 1];\n+        }\n+        \"\" => (),\n+        _ => (),\n+    }\n+}\n+\n+fn main() {}"}]}