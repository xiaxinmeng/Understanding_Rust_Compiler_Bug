{"sha": "26ed92568596ce45ad96c3e2ea5d54099702537f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZWQ5MjU2ODU5NmNlNDVhZDk2YzNlMmVhNWQ1NDA5OTcwMjUzN2Y=", "commit": {"author": {"name": "Sergey Parilin", "email": "sergey.parilin@fxdd.com", "date": "2019-04-10T21:00:56Z"}, "committer": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-05-06T14:16:11Z"}, "message": "fill struct fields diagnostic", "tree": {"sha": "29624826736c7287ac7dea635e639f20280d2533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29624826736c7287ac7dea635e639f20280d2533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26ed92568596ce45ad96c3e2ea5d54099702537f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26ed92568596ce45ad96c3e2ea5d54099702537f", "html_url": "https://github.com/rust-lang/rust/commit/26ed92568596ce45ad96c3e2ea5d54099702537f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26ed92568596ce45ad96c3e2ea5d54099702537f/comments", "author": null, "committer": null, "parents": [{"sha": "32db5884ada59c72aa7ab9f88910ef7c8f882e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/32db5884ada59c72aa7ab9f88910ef7c8f882e7d", "html_url": "https://github.com/rust-lang/rust/commit/32db5884ada59c72aa7ab9f88910ef7c8f882e7d"}], "stats": {"total": 287, "additions": 269, "deletions": 18}, "files": [{"sha": "726e5c0a3e635f9b06ad4d6441b5ac7f949a4004", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -4,6 +4,7 @@ use arrayvec::ArrayVec;\n use ra_text_edit::TextEditBuilder;\n use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction};\n use ra_fmt::leading_indent;\n+use hir::Name;\n \n pub struct AstEditor<N: AstNode> {\n     original_ast: TreeArc<N>,\n@@ -235,6 +236,10 @@ pub struct AstBuilder<N: AstNode> {\n }\n \n impl AstBuilder<ast::NamedField> {\n+    pub fn from_name(name: &Name) -> TreeArc<ast::NamedField> {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n+    }\n+\n     fn from_text(text: &str) -> TreeArc<ast::NamedField> {\n         ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n     }"}, {"sha": "55e1793c5060c66bc8743980f86b85be48728d01", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -8,15 +8,15 @@ use crate::{\n     HirDatabase, DefDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n-    expr::{Body, BodySourceMap},\n+    expr::{Body, BodySourceMap, validation::ExprValidator},\n     ty::{ TraitRef, InferenceResult},\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n-    diagnostics::DiagnosticSink,\n+    diagnostics::{DiagnosticSink},\n     traits::{TraitItem, TraitData},\n };\n \n@@ -431,8 +431,8 @@ impl Docs for EnumVariant {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum DefWithBody {\n     Function(Function),\n-    Const(Const),\n     Static(Static),\n+    Const(Const),\n }\n \n impl_froms!(DefWithBody: Function, Const, Static);\n@@ -562,7 +562,10 @@ impl Function {\n     }\n \n     pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        self.infer(db).add_diagnostics(db, *self, sink);\n+        let infer = self.infer(db);\n+        infer.add_diagnostics(db, *self, sink);\n+        let mut validator = ExprValidator::new(*self, infer, sink);\n+        validator.validate_body(db);\n     }\n }\n "}, {"sha": "61cd9d6b17b694521dbcd501c889bebc75656d71", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -3,7 +3,7 @@ use std::{fmt, any::Any};\n use ra_syntax::{SyntaxNodePtr, TreeArc, AstPtr, TextRange, ast, SyntaxNode};\n use relative_path::RelativePathBuf;\n \n-use crate::{HirFileId, HirDatabase};\n+use crate::{HirFileId, HirDatabase, Name};\n \n /// Diagnostic defines hir API for errors and warnings.\n ///\n@@ -113,3 +113,25 @@ impl Diagnostic for UnresolvedModule {\n         self\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct MissingFields {\n+    pub file: HirFileId,\n+    pub field_list: AstPtr<ast::NamedFieldList>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingFields {\n+    fn message(&self) -> String {\n+        \"fill structure fields\".to_string()\n+    }\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr {\n+        self.field_list.into()\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "480eaf1716cf913bce5a85996d73fc582c172b72", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -19,6 +19,7 @@ use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, U\n pub use self::scope::ExprScopes;\n \n pub(crate) mod scope;\n+pub(crate) mod validation;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n@@ -670,8 +671,9 @@ where\n             ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n                 let mut field_ptrs = Vec::new();\n-                let fields = if let Some(nfl) = e.named_field_list() {\n-                    nfl.fields()\n+                let struct_lit = if let Some(nfl) = e.named_field_list() {\n+                    let fields = nfl\n+                        .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n                         .map(|field| StructLitField {\n                             name: field\n@@ -694,12 +696,14 @@ where\n                                 self.exprs.alloc(Expr::Missing)\n                             },\n                         })\n-                        .collect()\n+                        .collect();\n+                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n+                    Expr::StructLit { path, fields, spread }\n                 } else {\n-                    Vec::new()\n+                    Expr::StructLit { path, fields: Vec::new(), spread: None }\n                 };\n-                let spread = e.spread().map(|s| self.collect_expr(s));\n-                let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n+\n+                let res = self.alloc_expr(struct_lit, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n                     self.source_map.field_map.insert((res, i), ptr);\n                 }"}, {"sha": "fd49073136bf34b00af1a0cc47f5f2b49b0f252c", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -0,0 +1,92 @@\n+use std::sync::Arc;\n+use rustc_hash::FxHashSet;\n+\n+use ra_syntax::ast::{AstNode, StructLit};\n+\n+use crate::{\n+    expr::AstPtr,\n+    HirDatabase,\n+    Function,\n+    Name,\n+    diagnostics::{DiagnosticSink, MissingFields},\n+    adt::AdtDef,\n+    Path,\n+    ty::InferenceResult\n+};\n+use super::{Expr, StructLitField, ExprId};\n+\n+pub(crate) struct ExprValidator<'a, 'b: 'a> {\n+    func: Function,\n+    infer: Arc<InferenceResult>,\n+    sink: &'a mut DiagnosticSink<'b>,\n+}\n+\n+impl<'a, 'b> ExprValidator<'a, 'b> {\n+    pub(crate) fn new(\n+        func: Function,\n+        infer: Arc<InferenceResult>,\n+        sink: &'a mut DiagnosticSink<'b>,\n+    ) -> ExprValidator<'a, 'b> {\n+        ExprValidator { func, infer, sink }\n+    }\n+\n+    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n+        let body = self.func.body(db);\n+        for e in body.exprs() {\n+            match e {\n+                (id, Expr::StructLit { path, fields, spread }) => {\n+                    self.validate_struct_literal(id, path, fields, spread, db)\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    fn validate_struct_literal(\n+        &mut self,\n+        id: ExprId,\n+        _path: &Option<Path>,\n+        fields: &Vec<StructLitField>,\n+        spread: &Option<ExprId>,\n+        db: &impl HirDatabase,\n+    ) {\n+        if let Some(_) = spread {\n+            return;\n+        }\n+        let lit_fields: FxHashSet<_> = fields.into_iter().map(|f| &f.name).collect();\n+        let struct_ty = &self.infer[id];\n+        if let Some((AdtDef::Struct(s), _)) = struct_ty.as_adt() {\n+            let missed_fields: Vec<Name> = s\n+                .fields(db)\n+                .iter()\n+                .filter_map(|f| {\n+                    let name = f.name(db);\n+                    if lit_fields.contains(&name) {\n+                        None\n+                    } else {\n+                        Some(name)\n+                    }\n+                })\n+                .collect();\n+            if missed_fields.is_empty() {\n+                return;\n+            }\n+            let source_map = self.func.body_source_map(db);\n+            let file_id = self.func.source(db).0;\n+            let source_file = db.parse(file_id.original_file(db));\n+            if let Some(field_list_node) = source_map\n+                .expr_syntax(id)\n+                .map(|ptr| ptr.to_node(&source_file))\n+                .and_then(StructLit::cast)\n+                .and_then(|lit| lit.named_field_list())\n+            {\n+                let field_list_ptr = AstPtr::new(field_list_node);\n+                self.sink.push(MissingFields {\n+                    file: file_id,\n+                    field_list: field_list_ptr,\n+                    missed_fields,\n+                })\n+            }\n+        }\n+    }\n+}"}, {"sha": "a38fe35c72930909d5b1e4c3eb398d601d64721b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -2662,6 +2662,7 @@ fn no_such_field_diagnostics() {\n \n     assert_snapshot_matches!(diagnostics, @r###\"\n \"baz: 62\": no such field\n+\"{\\n            foo: 92,\\n            baz: 62,\\n        }\": fill structure fields\n \"###\n     );\n }"}, {"sha": "855a3ff0f85e39539081d0505334d274f69de1a7", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -5,8 +5,9 @@ use hir::{source_binder, diagnostics::{Diagnostic as _, DiagnosticSink}};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NamedFieldList, NamedField},\n };\n+use ra_assists::ast_editor::{AstEditor, AstBuilder};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_prof::profile;\n \n@@ -48,6 +49,27 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             severity: Severity::Error,\n             fix: Some(fix),\n         })\n+    })\n+    .on::<hir::diagnostics::MissingFields, _>(|d| {\n+        let file_id = d.file().original_file(db);\n+        let source_file = db.parse(file_id);\n+        let syntax_node = d.syntax_node_ptr();\n+        let node = NamedFieldList::cast(syntax_node.to_node(&source_file)).unwrap();\n+        let mut ast_editor = AstEditor::new(node);\n+        for f in d.missed_fields.iter() {\n+            ast_editor.append_field(&AstBuilder::<NamedField>::from_name(f));\n+        }\n+\n+        let mut builder = TextEditBuilder::default();\n+        ast_editor.into_text_edit(&mut builder);\n+        let fix =\n+            SourceChange::source_file_edit_from(\"fill struct fields\", file_id, builder.finish());\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: Some(fix),\n+        })\n     });\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n         m.diagnostics(db, &mut sink);\n@@ -187,6 +209,105 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n+    fn check_apply_diagnostic_fix(before: &str, after: &str) {\n+        let (analysis, file_id) = single_file(before);\n+        let diagnostic = analysis.diagnostics(file_id).unwrap().pop().unwrap();\n+        let mut fix = diagnostic.fix.unwrap();\n+        let edit = fix.source_file_edits.pop().unwrap().edit;\n+        let actual = edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    fn check_no_diagnostic(content: &str) {\n+        let (analysis, file_id) = single_file(content);\n+        let diagnostics = analysis.diagnostics(file_id).unwrap();\n+        assert_eq!(diagnostics.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_empty() {\n+        let before = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{};\n+            }\n+        \";\n+        let after = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{ one: (), two: ()};\n+            }\n+        \";\n+        check_apply_diagnostic_fix(before, after);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_partial() {\n+        let before = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{ two: 2 };\n+            }\n+        \";\n+        let after = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{ two: 2, one: () };\n+            }\n+        \";\n+        check_apply_diagnostic_fix(before, after);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic() {\n+        let content = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+            \n+            fn test_fn() {\n+                let one = 1;\n+                let s = TestStruct{ one, two: 2 };\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n+        let content = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+            \n+            fn test_fn() {\n+                let one = 1;\n+                let s = TestStruct{ ..a };\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn test_unresolved_module_diagnostic() {\n         let (analysis, file_id) = single_file(\"mod foo;\");"}, {"sha": "e73fe22e921f9fbb9ea185f9cce23c784e447b8d", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -2371,6 +2371,10 @@ impl NamedFieldList {\n     pub fn fields(&self) -> impl Iterator<Item = &NamedField> {\n         super::children(self)\n     }\n+\n+    pub fn spread(&self) -> Option<&Expr> {\n+        super::child_opt(self)\n+    }\n }\n \n // NeverType\n@@ -3564,10 +3568,6 @@ impl StructLit {\n     pub fn named_field_list(&self) -> Option<&NamedFieldList> {\n         super::child_opt(self)\n     }\n-\n-    pub fn spread(&self) -> Option<&Expr> {\n-        super::child_opt(self)\n-    }\n }\n \n // StructPat"}, {"sha": "b8665bbc8c95c17b962f4ad0fe547e529467d593", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/26ed92568596ce45ad96c3e2ea5d54099702537f/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=26ed92568596ce45ad96c3e2ea5d54099702537f", "patch": "@@ -451,8 +451,11 @@ Grammar(\n             traits: [ \"AttrsOwner\" ]\n         ),\n         \"MatchGuard\": (options: [\"Expr\"]),\n-        \"StructLit\": (options: [\"Path\", \"NamedFieldList\", [\"spread\", \"Expr\"]]),\n-        \"NamedFieldList\": (collections: [ [\"fields\", \"NamedField\"] ]),\n+        \"StructLit\": (options: [\"Path\", \"NamedFieldList\"]),\n+        \"NamedFieldList\": (\n+            collections: [ [\"fields\", \"NamedField\"] ],\n+            options: [[\"spread\", \"Expr\"]]\n+        ),\n         \"NamedField\": (options: [\"NameRef\", \"Expr\"]),\n         \"CallExpr\": (\n             traits: [\"ArgListOwner\"],"}]}