{"sha": "5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNDJlNjk0Y2I3ZWIyYmMyNjMzNjM1MWExZmI0ZTFlNGY5NDc2OGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-26T20:54:38Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-07T16:14:33Z"}, "message": "trans: support simd_shuffle using MIR constants for indices.", "tree": {"sha": "cbf0d26ca40728ddc7200e38f6b7ba87a91e34f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbf0d26ca40728ddc7200e38f6b7ba87a91e34f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "html_url": "https://github.com/rust-lang/rust/commit/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed66fe48e94df2cd0dee5af4afa44d7fb50cb0cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed66fe48e94df2cd0dee5af4afa44d7fb50cb0cf", "html_url": "https://github.com/rust-lang/rust/commit/ed66fe48e94df2cd0dee5af4afa44d7fb50cb0cf"}], "stats": {"total": 96, "additions": 51, "deletions": 45}, "files": [{"sha": "1824055fcf94dd2369fff4711aad22f0ccd3d794", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "patch": "@@ -1482,28 +1482,23 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n         let total_len = in_len as u64 * 2;\n \n-        let (vector, indirect) = match args {\n+        let vector = match args {\n             Some(args) => {\n                 match consts::const_expr(bcx.ccx(), &args[2], substs, None,\n                                          // this should probably help simd error reporting\n                                          consts::TrueConst::Yes) {\n-                    Ok((vector, _)) => (vector, false),\n+                    Ok((vector, _)) => vector,\n                     Err(err) => bcx.sess().span_fatal(span, &err.description()),\n                 }\n             }\n-            None => (llargs[2], !type_is_immediate(bcx.ccx(), arg_tys[2]))\n+            None => llargs[2]\n         };\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = if indirect {\n-                    Load(bcx, StructGEP(bcx, vector, i))\n-                } else {\n-                    const_get_elt(vector, &[i as libc::c_uint])\n-                };\n-                let c = const_to_opt_uint(val);\n-                match c {\n+                let val = const_get_elt(vector, &[i as libc::c_uint]);\n+                match const_to_opt_uint(val) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None"}, {"sha": "e605ef81c587f1cb60e6e1285de83719649bd10e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "patch": "@@ -26,6 +26,7 @@ use glue;\n use type_::Type;\n \n use super::{MirContext, TempRef, drop};\n+use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n@@ -114,16 +115,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n                 let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let constant = mir::Constant {\n-                        literal: mir::Literal::Value {\n-                            value: value.clone()\n-                        },\n-                        ty: switch_ty,\n-                        span: terminator.span\n-                    };\n-                    let val = self.trans_constant(&bcx, &constant).immediate();\n+                    let val = Const::from_constval(bcx.ccx(), value.clone(), switch_ty);\n                     let llbb = self.llblock(*target);\n-                    build::AddCase(switch, val, llbb)\n+                    build::AddCase(switch, val.llval, llbb)\n                 }\n             }\n \n@@ -247,8 +241,30 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (&args[..], None)\n                 };\n \n+                let is_shuffle = intrinsic.map_or(false, |name| {\n+                    name.starts_with(\"simd_shuffle\")\n+                });\n                 let mut idx = 0;\n                 for arg in first_args {\n+                    // The indices passed to simd_shuffle* in the\n+                    // third argument must be constant. This is\n+                    // checked by const-qualification, which also\n+                    // promotes any complex rvalues to constants.\n+                    if is_shuffle && idx == 2 {\n+                        match *arg {\n+                            mir::Operand::Consume(_) => {\n+                                span_bug!(terminator.span,\n+                                          \"shuffle indices must be constant\");\n+                            }\n+                            mir::Operand::Constant(ref constant) => {\n+                                let val = self.trans_constant(&bcx, constant);\n+                                llargs.push(val.llval);\n+                                idx += 1;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n                     let val = self.trans_operand(&bcx, arg).val;\n                     self.trans_argument(&bcx, val, &mut llargs, &fn_ty,\n                                         &mut idx, &mut callee.data);"}, {"sha": "0097bca2306ac1866e99c6d9774bd2a4b3831c2c", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "patch": "@@ -41,24 +41,24 @@ use super::MirContext;\n /// The LLVM type might not be the same for a single Rust type,\n /// e.g. each enum variant would have its own LLVM struct type.\n #[derive(Copy, Clone)]\n-struct Const<'tcx> {\n-    llval: ValueRef,\n-    ty: Ty<'tcx>\n+pub struct Const<'tcx> {\n+    pub llval: ValueRef,\n+    pub ty: Ty<'tcx>\n }\n \n impl<'tcx> Const<'tcx> {\n-    fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n+    pub fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n         Const {\n             llval: llval,\n             ty: ty\n         }\n     }\n \n     /// Translate ConstVal into a LLVM constant value.\n-    fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                         cv: ConstVal,\n-                         ty: Ty<'tcx>)\n-                         -> Const<'tcx> {\n+    pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                             cv: ConstVal,\n+                             ty: Ty<'tcx>)\n+                             -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n         let val = match cv {\n             ConstVal::Float(v) => C_floating_f64(v, llty),\n@@ -110,7 +110,7 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n-    fn to_operand<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n+    pub fn to_operand<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n         let llty = type_of::immediate_type_of(ccx, self.ty);\n         let llvalty = val_ty(self.llval);\n \n@@ -799,7 +799,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constant(&mut self,\n                           bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n-                          -> OperandRef<'tcx>\n+                          -> Const<'tcx>\n     {\n         let ty = bcx.monomorphize(&constant.ty);\n         let result = match constant.literal.clone() {\n@@ -808,10 +808,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // types, which would not work with MirConstContext.\n                 if common::type_is_zero_size(bcx.ccx(), ty) {\n                     let llty = type_of::type_of(bcx.ccx(), ty);\n-                    return OperandRef {\n-                        val: OperandValue::Immediate(C_null(llty)),\n-                        ty: ty\n-                    };\n+                    return Const::new(C_null(llty), ty);\n                 }\n \n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(substs));\n@@ -827,7 +824,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         };\n \n-        let val = match result {\n+        match result {\n             Ok(v) => v,\n             Err(ConstEvalFailure::Compiletime(_)) => {\n                 // We've errored, so we don't have to produce working code.\n@@ -839,14 +836,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           \"MIR constant {:?} results in runtime panic: {}\",\n                           constant, err.description())\n             }\n-        };\n-\n-        let operand = val.to_operand(bcx.ccx());\n-        if let OperandValue::Ref(ptr) = operand.val {\n-            // If this is a OperandValue::Ref to an immediate constant, load it.\n-            self.trans_load(bcx, ptr, operand.ty)\n-        } else {\n-            operand\n         }\n     }\n }"}, {"sha": "fc726a3474f7e6d996b506b08e1cf6306338ee3f", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "patch": "@@ -140,7 +140,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                self.trans_constant(bcx, constant)\n+                let val = self.trans_constant(bcx, constant);\n+                let operand = val.to_operand(bcx.ccx());\n+                if let OperandValue::Ref(ptr) = operand.val {\n+                    // If this is a OperandValue::Ref to an immediate constant, load it.\n+                    self.trans_load(bcx, ptr, operand.ty)\n+                } else {\n+                    operand\n+                }\n             }\n         }\n     }"}, {"sha": "5cb57b63ada2c24e50c8d60e971d783c1909ee91", "filename": "src/test/run-pass/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c42e694cb7eb2bc26336351a1fb4e1e4f94768e/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=5c42e694cb7eb2bc26336351a1fb4e1e4f94768e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, rustc_attrs, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics)]\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n@@ -52,7 +52,6 @@ macro_rules! all_eq {\n     }}\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't handle shuffle constants.\n fn main() {\n     let x2 = i32x2(20, 21);\n     let x3 = i32x3(30, 31, 32);"}]}