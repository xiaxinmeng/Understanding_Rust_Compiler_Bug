{"sha": "a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OGQ1MzE0ZmJkNWQ2ZGVjZTJjMDlkNzFjYzhmZWExNzk4ODRjN2M=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-11-23T17:43:21Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-10T14:26:34Z"}, "message": "Add toolstate checking into bootstrap\n\nThis is not yet actually used by CI, but implements the logic for\nchecking that tools are properly building on beta/stable and during beta\ncutoff week.\n\nThis attempts to mirror the checking functionality in\nsrc/ci/docker/x86_64-gnu-tools/checktools.sh, and called scripts. It\ndoes not attempt to run the relevant steps (that functionality was\noriginally desired to be moved into bootstrap as well, but doing so\nproved more difficult than expected).\n\nThis is intended as a way to centralize and make clearer the logic\ninvolved in toolstate checking. In particular, the previous logic was\nspread across numerous python and shell scripts in such a way that made\ninterpretation quite difficult.", "tree": {"sha": "e5b1a9066d9094529352ea5ca76fdc91527c5a52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5b1a9066d9094529352ea5ca76fdc91527c5a52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "html_url": "https://github.com/rust-lang/rust/commit/a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8960acf023d6739a601ae83cfc3d4ac30a85893e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8960acf023d6739a601ae83cfc3d4ac30a85893e", "html_url": "https://github.com/rust-lang/rust/commit/8960acf023d6739a601ae83cfc3d4ac30a85893e"}], "stats": {"total": 433, "additions": 406, "deletions": 27}, "files": [{"sha": "5c0b43c1d24e1fdbbc3287a53fed576912284ffe", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "patch": "@@ -368,6 +368,7 @@ impl<'a> Builder<'a> {\n                 check::Rustdoc\n             ),\n             Kind::Test => describe!(\n+                crate::toolstate::ToolStateCheck,\n                 test::Tidy,\n                 test::Ui,\n                 test::CompileFail,"}, {"sha": "1f4a4f923e04805a0f7dc6631e508c8138d03828", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "patch": "@@ -169,7 +169,6 @@ mod job {\n pub use crate::config::Config;\n use crate::flags::Subcommand;\n use crate::cache::{Interned, INTERNER};\n-use crate::toolstate::ToolState;\n \n const LLVM_TOOLS: &[&str] = &[\n     \"llvm-nm\", // used to inspect binaries; it shows symbol names, their sizes and visibility\n@@ -1074,32 +1073,6 @@ impl Build {\n         }\n     }\n \n-    /// Updates the actual toolstate of a tool.\n-    ///\n-    /// The toolstates are saved to the file specified by the key\n-    /// `rust.save-toolstates` in `config.toml`. If unspecified, nothing will be\n-    /// done. The file is updated immediately after this function completes.\n-    pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n-        if let Some(ref path) = self.config.save_toolstates {\n-            if let Some(parent) = path.parent() {\n-                // Ensure the parent directory always exists\n-                t!(std::fs::create_dir_all(parent));\n-            }\n-            let mut file = t!(fs::OpenOptions::new()\n-                .create(true)\n-                .read(true)\n-                .write(true)\n-                .open(path));\n-\n-            let mut current_toolstates: HashMap<Box<str>, ToolState> =\n-                serde_json::from_reader(&mut file).unwrap_or_default();\n-            current_toolstates.insert(tool.into(), state);\n-            t!(file.seek(SeekFrom::Start(0)));\n-            t!(file.set_len(0));\n-            t!(serde_json::to_writer(file, &current_toolstates));\n-        }\n-    }\n-\n     fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n         let mut list = vec![INTERNER.intern_str(root)];"}, {"sha": "bec28534cc29e52757b5d9c556e93d851431bc3d", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68d5314fbd5d6dece2c09d71cc8fea179884c7c/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=a68d5314fbd5d6dece2c09d71cc8fea179884c7c", "patch": "@@ -1,4 +1,28 @@\n use serde::{Deserialize, Serialize};\n+use build_helper::t;\n+use std::time;\n+use std::fs;\n+use std::io::{Seek, SeekFrom};\n+use std::collections::HashMap;\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use std::fmt;\n+use std::process::Command;\n+use std::path::PathBuf;\n+use std::env;\n+\n+// Each cycle is 42 days long (6 weeks); the last week is 35..=42 then.\n+const BETA_WEEK_START: u64 = 35;\n+\n+#[cfg(linux)]\n+const OS: Option<&str> = Some(\"linux\");\n+\n+#[cfg(windows)]\n+const OS: Option<&str> = Some(\"windows\");\n+\n+#[cfg(all(not(linux), not(windows)))]\n+const OS: Option<&str> = None;\n+\n+type ToolstateData = HashMap<Box<str>, ToolState>;\n \n #[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]\n #[serde(rename_all = \"kebab-case\")]\n@@ -12,9 +36,390 @@ pub enum ToolState {\n     BuildFail = 0,\n }\n \n+impl fmt::Display for ToolState {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", match self {\n+            ToolState::TestFail => \"test-fail\",\n+            ToolState::TestPass => \"test-pass\",\n+            ToolState::BuildFail => \"build-fail\",\n+        })\n+    }\n+}\n+\n impl Default for ToolState {\n     fn default() -> Self {\n         // err on the safe side\n         ToolState::BuildFail\n     }\n }\n+\n+/// Number of days after the last promotion of beta.\n+/// Its value is 41 on the Tuesday where \"Promote master to beta (T-2)\" happens.\n+/// The Wednesday after this has value 0.\n+/// We track this value to prevent regressing tools in the last week of the 6-week cycle.\n+fn days_since_beta_promotion() -> u64 {\n+    let since_epoch = t!(time::SystemTime::UNIX_EPOCH.elapsed());\n+    (since_epoch.as_secs() / 86400 - 20) % 42\n+}\n+\n+// These tools must test-pass on the beta/stable channels.\n+//\n+// On the nightly channel, their build step must be attempted, but they may not\n+// be able to build successfully.\n+static STABLE_TOOLS: &[(&str, &str)] = &[\n+    (\"book\", \"src/doc/book\"),\n+    (\"nomicon\", \"src/doc/nomicon\"),\n+    (\"reference\", \"src/doc/reference\"),\n+    (\"rust-by-example\", \"src/doc/rust-by-example\"),\n+    (\"edition-guide\", \"src/doc/edition-guide\"),\n+    (\"rls\", \"src/tools/rls\"),\n+    (\"rustfmt\", \"src/tools/rustfmt\"),\n+    (\"clippy-driver\", \"src/tools/clippy\"),\n+];\n+\n+// These tools are permitted to not build on the beta/stable channels.\n+//\n+// We do require that we checked whether they build or not on the tools builder,\n+// though, as otherwise we will be unable to file an issue if they start\n+// failing.\n+static NIGHTLY_TOOLS: &[(&str, &str)] = &[\n+    (\"miri\", \"src/tools/miri\"),\n+    (\"embedded-book\", \"src/doc/embedded-book\"),\n+    (\"rustc-guide\", \"src/doc/rustc-guide\"),\n+];\n+\n+fn print_error(tool: &str, submodule: &str) {\n+    eprintln!(\"\");\n+    eprintln!(\"We detected that this PR updated '{}', but its tests failed.\", tool);\n+    eprintln!(\"\");\n+    eprintln!(\"If you do intend to update '{}', please check the error messages above and\", tool);\n+    eprintln!(\"commit another update.\");\n+    eprintln!(\"\");\n+    eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n+    eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n+    eprintln!(\"proper steps.\");\n+    std::process::exit(3);\n+}\n+\n+fn check_changed_files(toolstates: &HashMap<Box<str>, ToolState>) {\n+    // Changed files\n+    let output = std::process::Command::new(\"git\")\n+        .arg(\"diff\")\n+        .arg(\"--name-status\")\n+        .arg(\"HEAD\")\n+        .arg(\"HEAD^\")\n+        .output();\n+    let output = match output {\n+        Ok(o) => o,\n+        Err(e) => {\n+            eprintln!(\"Failed to get changed files: {:?}\", e);\n+            std::process::exit(1);\n+        }\n+    };\n+\n+    let output = t!(String::from_utf8(output.stdout));\n+\n+    for (tool, submodule) in STABLE_TOOLS.iter().chain(NIGHTLY_TOOLS.iter()) {\n+        let changed = output.lines().any(|l| {\n+            l.starts_with(\"M\") && l.ends_with(submodule)\n+        });\n+        eprintln!(\"Verifying status of {}...\", tool);\n+        if !changed {\n+            continue;\n+        }\n+\n+        eprintln!(\"This PR updated '{}', verifying if status is 'test-pass'...\", submodule);\n+        if toolstates[*tool] != ToolState::TestPass {\n+            print_error(tool, submodule);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ToolStateCheck;\n+\n+impl Step for ToolStateCheck {\n+    type Output = ();\n+\n+    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will verify the validity of all our links in the\n+    /// documentation to ensure we don't have a bunch of dead ones.\n+    fn run(self, builder: &Builder<'_>) {\n+        if builder.config.dry_run {\n+            return;\n+        }\n+\n+        let days_since_beta_promotion = days_since_beta_promotion();\n+        let in_beta_week = days_since_beta_promotion >= BETA_WEEK_START;\n+        let is_nightly = !(builder.config.channel == \"beta\" || builder.config.channel == \"stable\");\n+        let toolstates = builder.toolstates();\n+\n+        let mut did_error = false;\n+\n+        for (tool, _) in STABLE_TOOLS.iter().chain(NIGHTLY_TOOLS.iter()) {\n+            if !toolstates.contains_key(*tool) {\n+                did_error = true;\n+                eprintln!(\"error: Tool `{}` was not recorded in tool state.\", tool);\n+            }\n+        }\n+\n+        if did_error {\n+            std::process::exit(1);\n+        }\n+\n+        check_changed_files(&toolstates);\n+\n+        for (tool, _) in STABLE_TOOLS.iter() {\n+            let state = toolstates[*tool];\n+\n+            if state != ToolState::TestPass {\n+                if !is_nightly {\n+                    did_error = true;\n+                    eprintln!(\"error: Tool `{}` should be test-pass but is {}\", tool, state);\n+                } else if in_beta_week {\n+                    did_error = true;\n+                    eprintln!(\"error: Tool `{}` should be test-pass but is {} during beta week.\",\n+                        tool, state);\n+                }\n+            }\n+        }\n+\n+        if did_error {\n+            std::process::exit(1);\n+        }\n+\n+        if builder.config.channel == \"nightly\" && env::var_os(\"TOOLSTATE_PUBLISH\").is_some() {\n+            commit_toolstate_change(&toolstates, in_beta_week);\n+        }\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"check-tools\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(ToolStateCheck);\n+    }\n+}\n+\n+impl Builder<'_> {\n+    fn toolstates(&self) -> HashMap<Box<str>, ToolState> {\n+        if let Some(ref path) = self.config.save_toolstates {\n+            if let Some(parent) = path.parent() {\n+                // Ensure the parent directory always exists\n+                t!(std::fs::create_dir_all(parent));\n+            }\n+            let mut file = t!(fs::OpenOptions::new()\n+                .create(true)\n+                .write(true)\n+                .read(true)\n+                .open(path));\n+\n+            serde_json::from_reader(&mut file).unwrap_or_default()\n+        } else {\n+            Default::default()\n+        }\n+    }\n+\n+    /// Updates the actual toolstate of a tool.\n+    ///\n+    /// The toolstates are saved to the file specified by the key\n+    /// `rust.save-toolstates` in `config.toml`. If unspecified, nothing will be\n+    /// done. The file is updated immediately after this function completes.\n+    pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n+        if let Some(ref path) = self.config.save_toolstates {\n+            if let Some(parent) = path.parent() {\n+                // Ensure the parent directory always exists\n+                t!(std::fs::create_dir_all(parent));\n+            }\n+            let mut file = t!(fs::OpenOptions::new()\n+                .create(true)\n+                .read(true)\n+                .write(true)\n+                .open(path));\n+\n+            let mut current_toolstates: HashMap<Box<str>, ToolState> =\n+                serde_json::from_reader(&mut file).unwrap_or_default();\n+            current_toolstates.insert(tool.into(), state);\n+            t!(file.seek(SeekFrom::Start(0)));\n+            t!(file.set_len(0));\n+            t!(serde_json::to_writer(file, &current_toolstates));\n+        }\n+    }\n+}\n+\n+/// This function `commit_toolstate_change` provides functionality for pushing a change\n+/// to the `rust-toolstate` repository.\n+///\n+/// The function relies on a GitHub bot user, which should have a Personal access\n+/// token defined in the environment variable $TOOLSTATE_REPO_ACCESS_TOKEN. If for\n+/// some reason you need to change the token, please update the Azure Pipelines\n+/// variable group.\n+///\n+///   1. Generate a new Personal access token:\n+///\n+///       * Login to the bot account, and go to Settings -> Developer settings ->\n+///           Personal access tokens\n+///       * Click \"Generate new token\"\n+///       * Enable the \"public_repo\" permission, then click \"Generate token\"\n+///       * Copy the generated token (should be a 40-digit hexadecimal number).\n+///           Save it somewhere secure, as the token would be gone once you leave\n+///           the page.\n+///\n+///   2. Update the variable group in Azure Pipelines\n+///\n+///       * Ping a member of the infrastructure team to do this.\n+///\n+///   4. Replace the email address below if the bot account identity is changed\n+///\n+///       * See <https://help.github.com/articles/about-commit-email-addresses/>\n+///           if a private email by GitHub is wanted.\n+fn commit_toolstate_change(\n+    current_toolstate: &ToolstateData,\n+    in_beta_week: bool,\n+) {\n+    fn git_config(key: &str, value: &str) {\n+        let status = Command::new(\"git\").arg(\"config\").arg(\"--global\").arg(key).arg(value).status();\n+        let success = match status {\n+            Ok(s) => s.success(),\n+            Err(_) => false,\n+        };\n+        if !success {\n+            panic!(\"git config key={} value={} successful (status: {:?})\", key, value, status);\n+        }\n+    }\n+\n+    git_config(\"user.email\", \"7378925+rust-toolstate-update@users.noreply.github.com\");\n+    git_config(\"user.name\", \"Rust Toolstate Update\");\n+    git_config(\"credential.helper\", \"store\");\n+\n+    let credential = format!(\n+        \"https://{}:x-oauth-basic@github.com\\n\",\n+        t!(env::var(\"TOOLSTATE_REPO_ACCESS_TOKEN\")),\n+    );\n+    let git_credential_path = PathBuf::from(t!(env::var(\"HOME\"))).join(\".git-credentials\");\n+    t!(fs::write(&git_credential_path, credential));\n+\n+    let status = Command::new(\"git\").arg(\"clone\")\n+        .arg(\"--depth=1\")\n+        .arg(t!(env::var(\"TOOLSTATE_REPO\")))\n+        .status();\n+    let success = match status {\n+        Ok(s) => s.success(),\n+        Err(_) => false,\n+    };\n+    if !success {\n+        panic!(\"git clone successful (status: {:?})\", status);\n+    }\n+\n+    let old_toolstate = t!(fs::read(\"rust-toolstate/_data/latest.json\"));\n+    let old_toolstate: Vec<RepoState> = t!(serde_json::from_slice(&old_toolstate));\n+\n+    let message = format!(\"({} CI update)\", OS.expect(\"linux/windows only\"));\n+    let mut success = false;\n+    for _ in 1..=5 {\n+        // Update the toolstate results (the new commit-to-toolstate mapping) in the toolstate repo.\n+        change_toolstate(&current_toolstate, &old_toolstate, in_beta_week);\n+\n+        // `git commit` failing means nothing to commit.\n+        let status = t!(Command::new(\"git\")\n+            .current_dir(\"rust-toolstate\")\n+            .arg(\"commit\")\n+            .arg(\"-a\")\n+            .arg(\"-m\")\n+            .arg(&message)\n+            .status());\n+        if !status.success() {\n+            success = true;\n+            break;\n+        }\n+\n+        let status = t!(Command::new(\"git\")\n+            .current_dir(\"rust-toolstate\")\n+            .arg(\"push\")\n+            .arg(\"origin\")\n+            .arg(\"master\")\n+            .status());\n+        // If we successfully push, exit.\n+        if status.success() {\n+            success = true;\n+            break;\n+        }\n+        eprintln!(\"Sleeping for 3 seconds before retrying push\");\n+        std::thread::sleep(std::time::Duration::from_secs(3));\n+        let status = t!(Command::new(\"git\")\n+            .current_dir(\"rust-toolstate\")\n+            .arg(\"fetch\")\n+            .arg(\"origin\")\n+            .arg(\"master\")\n+            .status());\n+        assert!(status.success());\n+        let status = t!(Command::new(\"git\")\n+            .current_dir(\"rust-toolstate\")\n+            .arg(\"reset\")\n+            .arg(\"--hard\")\n+            .arg(\"origin/master\")\n+            .status());\n+        assert!(status.success());\n+    }\n+\n+    if !success {\n+        panic!(\"Failed to update toolstate repository with new data\");\n+    }\n+}\n+\n+fn change_toolstate(\n+    current_toolstate: &ToolstateData,\n+    old_toolstate: &[RepoState],\n+    in_beta_week: bool,\n+) {\n+    let mut regressed = false;\n+    for repo_state in old_toolstate {\n+        let tool = &repo_state.tool;\n+        let state = if cfg!(linux) {\n+            &repo_state.linux\n+        } else if cfg!(windows) {\n+            &repo_state.windows\n+        } else {\n+            unimplemented!()\n+        };\n+        let new_state = current_toolstate[tool.as_str()];\n+\n+        if new_state != *state {\n+            eprintln!(\"The state of `{}` has changed from `{}` to `{}`\", tool, state, new_state);\n+            if (new_state as u8) < (*state as u8) {\n+                if ![\"rustc-guide\", \"miri\", \"embedded-book\"].contains(&tool.as_str()) {\n+                    regressed = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    if regressed && in_beta_week {\n+        std::process::exit(1);\n+    }\n+\n+    let commit = t!(std::process::Command::new(\"git\")\n+        .arg(\"rev-parse\")\n+        .arg(\"HEAD\")\n+        .output());\n+    let commit = t!(String::from_utf8(commit.stdout));\n+\n+    let toolstate_serialized = t!(serde_json::to_string(&current_toolstate));\n+\n+    let history_path = format!(\"rust-toolstate/history/{}.tsv\", OS.expect(\"linux/windows only\"));\n+    let mut file = t!(fs::read_to_string(&history_path));\n+    let end_of_first_line = file.find('\\n').unwrap();\n+    file.insert_str(end_of_first_line, &format!(\"{}\\t{}\\n\", commit, toolstate_serialized));\n+    t!(fs::write(&history_path, file));\n+}\n+\n+#[derive(Debug, Serialize, Deserialize)]\n+struct RepoState {\n+    tool: String,\n+    windows: ToolState,\n+    linux: ToolState,\n+    commit: String,\n+    datetime: String,\n+}"}]}