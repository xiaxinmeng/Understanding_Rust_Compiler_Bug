{"sha": "5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNGFlNGY0NWZhYjdjZTFhOTg0ZDViNTI4MWUxMjlmNzY0ODZkMTA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-30T22:29:42Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-01T06:57:59Z"}, "message": "make small (<= size_of::<int>()) tuples immediate\n\n    fn foo() -> (u32, u8, u8, u8, u8) {\n        (4, 5, 6, 7, 8)\n    }\n\nBefore:\n\n    ; Function Attrs: nounwind uwtable\n    define void @_ZN3foo18hbb616262f874f8daf4v0.0E({ i32, i8, i8, i8, i8 }* noalias nocapture sret, { i64, %tydesc*, i8*, i8*, i8 }* nocapture readnone) #0 {\n    \"function top level\":\n      %2 = getelementptr inbounds { i32, i8, i8, i8, i8 }* %0, i64 0, i32 0\n      store i32 4, i32* %2, align 4\n      %3 = getelementptr inbounds { i32, i8, i8, i8, i8 }* %0, i64 0, i32 1\n      store i8 5, i8* %3, align 4\n      %4 = getelementptr inbounds { i32, i8, i8, i8, i8 }* %0, i64 0, i32 2\n      store i8 6, i8* %4, align 1\n      %5 = getelementptr inbounds { i32, i8, i8, i8, i8 }* %0, i64 0, i32 3\n      store i8 7, i8* %5, align 2\n      %6 = getelementptr inbounds { i32, i8, i8, i8, i8 }* %0, i64 0, i32 4\n      store i8 8, i8* %6, align 1\n      ret void\n    }\n\nAfter:\n\n    ; Function Attrs: nounwind readnone uwtable\n    define { i32, i8, i8, i8, i8 } @_ZN3foo18hbb616262f874f8daf4v0.0E({ i64, %tydesc*, i8*, i8*, i8 }* nocapture readnone) #0 {\n    \"function top level\":\n      ret { i32, i8, i8, i8, i8 } { i32 4, i8 5, i8 6, i8 7, i8 8 }\n    }", "tree": {"sha": "bf425dc3058bea3c01093e2a4ddf15561d24547d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf425dc3058bea3c01093e2a4ddf15561d24547d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "html_url": "https://github.com/rust-lang/rust/commit/5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dbc467fd957a0daf3fd935ccce0fc9ea5d1dcd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dbc467fd957a0daf3fd935ccce0fc9ea5d1dcd8", "html_url": "https://github.com/rust-lang/rust/commit/1dbc467fd957a0daf3fd935ccce0fc9ea5d1dcd8"}], "stats": {"total": 193, "additions": 118, "deletions": 75}, "files": [{"sha": "d1fb3e54340ef6199bf3db32ce0ceb61ffd6ba49", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -236,7 +236,7 @@ pub fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n         _ => ()\n     }\n \n-    let uses_outptr = type_of::return_uses_outptr(ccx.tcx, output);\n+    let uses_outptr = type_of::return_uses_outptr(ccx, output);\n     let offset = if uses_outptr { 2 } else { 1 };\n \n     for (i, &arg_ty) in inputs.iter().enumerate() {\n@@ -1121,13 +1121,13 @@ pub fn do_spill_noroot(cx: @mut Block, v: ValueRef) -> ValueRef {\n \n pub fn spill_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n-    if type_is_immediate(cx.tcx(), t) { return do_spill(cx, v, t); }\n+    if type_is_immediate(cx.ccx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n pub fn load_if_immediate(cx: @mut Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n-    if type_is_immediate(cx.tcx(), t) { return Load(cx, v); }\n+    if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n     return v;\n }\n \n@@ -1660,7 +1660,7 @@ pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> ValueRef {\n     unsafe {\n-        if type_of::return_uses_outptr(fcx.ccx.tcx, output_type) {\n+        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n@@ -1700,7 +1700,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n         }\n     };\n-    let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n+    let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n     let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n     let fcx = @mut FunctionContext {\n@@ -1812,7 +1812,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n     match fcx.llself {\n         Some(slf) => {\n             let self_val = if slf.is_copy\n-                    && datum::appropriate_mode(bcx.tcx(), slf.t).is_by_value() {\n+                    && datum::appropriate_mode(bcx.ccx(), slf.t).is_by_value() {\n                 let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n                 let alloc = alloc_ty(bcx, slf.t, \"__self\");\n                 Store(bcx, tmp, alloc);\n@@ -1842,7 +1842,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n         // only by value if immediate:\n-        let llarg = if datum::appropriate_mode(bcx.tcx(), arg_ty).is_by_value() {\n+        let llarg = if datum::appropriate_mode(bcx.ccx(), arg_ty).is_by_value() {\n             let alloc = alloc_ty(bcx, arg_ty, \"__arg\");\n             Store(bcx, raw_llarg, alloc);\n             alloc"}, {"sha": "65225d4f187b80b406c27bf1252346ad11000d0f", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -655,7 +655,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         // not care about the result, just make a stack slot.\n         let opt_llretslot = match dest {\n             None => {\n-                assert!(!type_of::return_uses_outptr(in_cx.tcx(), ret_ty));\n+                assert!(!type_of::return_uses_outptr(in_cx.ccx(), ret_ty));\n                 None\n             }\n             Some(expr::SaveIn(dst)) => Some(dst),\n@@ -685,7 +685,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n \n             // Push the out-pointer if we use an out-pointer for this\n             // return type, otherwise push \"undef\".\n-            if type_of::return_uses_outptr(in_cx.tcx(), ret_ty) {\n+            if type_of::return_uses_outptr(in_cx.ccx(), ret_ty) {\n                 llargs.push(opt_llretslot.unwrap());\n             }\n \n@@ -711,7 +711,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             // any attributes with ABI implications directly to the call instruction. Right now, the\n             // only attribute we need to worry about is `sret`.\n             let mut attrs = ~[];\n-            if type_of::return_uses_outptr(in_cx.tcx(), ret_ty) {\n+            if type_of::return_uses_outptr(in_cx.ccx(), ret_ty) {\n                 attrs.push((1, StructRetAttribute));\n             }\n \n@@ -734,7 +734,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             // the return value, copy it into llretslot.\n             match opt_llretslot {\n                 Some(llretslot) => {\n-                    if !type_of::return_uses_outptr(bcx.tcx(), ret_ty) &&\n+                    if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n                         !ty::type_is_voidish(ret_ty)\n                     {\n                         Store(bcx, llret, llretslot);\n@@ -758,7 +758,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         // drop the temporary slot we made.\n         match dest {\n             None => {\n-                assert!(!type_of::return_uses_outptr(bcx.tcx(), ret_ty));\n+                assert!(!type_of::return_uses_outptr(bcx.ccx(), ret_ty));\n             }\n             Some(expr::Ignore) => {\n                 // drop the value if it is not being saved.\n@@ -871,7 +871,7 @@ pub fn trans_arg_expr(bcx: @mut Block,\n             DontAutorefArg => {\n                 let need_scratch = ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n                     (bcx.expr_is_lval(arg_expr) &&\n-                     arg_datum.appropriate_mode(bcx.tcx()).is_by_ref());\n+                     arg_datum.appropriate_mode(bcx.ccx()).is_by_ref());\n \n                 let arg_datum = if need_scratch {\n                     let scratch = scratch_datum(bcx, arg_datum.ty, \"__self\", false);"}, {"sha": "5678c2a9ee172e795a40a2485c8fdb8509665ca7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -46,23 +46,37 @@ use syntax::{ast, ast_map};\n \n pub use middle::trans::context::CrateContext;\n \n-fn type_is_newtype_immediate(cx: ty::ctxt, ty: ty::t) -> bool {\n+fn type_is_newtype_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::struct_fields(cx, def_id, substs);\n+            let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n             fields.len() == 1 &&\n                 fields[0].ident.name == token::special_idents::unnamed_field.name &&\n-                type_is_immediate(cx, fields[0].mt.ty)\n+                type_is_immediate(ccx, fields[0].mt.ty)\n         }\n         _ => false\n     }\n }\n \n-pub fn type_is_immediate(cx: ty::ctxt, ty: ty::t) -> bool {\n-    ty::type_is_scalar(ty) || ty::type_is_boxed(ty) ||\n+pub fn type_is_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+    use middle::trans::machine::llsize_of_alloc;\n+    use middle::trans::type_of::sizing_type_of;\n+    let tcx = ccx.tcx;\n+    let simple = ty::type_is_scalar(ty) || ty::type_is_boxed(ty) ||\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n-        type_is_newtype_immediate(cx, ty) ||\n-        ty::type_is_simd(cx, ty)\n+        type_is_newtype_immediate(ccx, ty) ||\n+        ty::type_is_simd(tcx, ty);\n+    if simple {\n+        return true;\n+    }\n+    match ty::get(ty).sty {\n+        // FIXME: #9651: small `ty_struct` and `ty_enum` should also be immediate\n+        ty::ty_tup(*) => {\n+            let llty = sizing_type_of(ccx, ty);\n+            llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type)\n+        }\n+        _ => false\n+    }\n }\n \n pub fn gensym_name(name: &str) -> (Ident, path_elt) {"}, {"sha": "7c131b173e4fb0bd8e70546c7e5dc872def56717", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -188,7 +188,7 @@ pub fn scratch_datum(bcx: @mut Block, ty: ty::t, name: &str, zero: bool) -> Datu\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n-pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n+pub fn appropriate_mode(ccx: &mut CrateContext, ty: ty::t) -> DatumMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n      * which is either by ref or by value, depending\n@@ -197,7 +197,7 @@ pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n \n     if ty::type_is_voidish(ty) {\n         ByValue\n-    } else if type_is_immediate(tcx, ty) {\n+    } else if type_is_immediate(ccx, ty) {\n         ByValue\n     } else {\n         ByRef(RevokeClean)\n@@ -505,18 +505,18 @@ impl Datum {\n         }\n     }\n \n-    pub fn appropriate_mode(&self, tcx: ty::ctxt) -> DatumMode {\n+    pub fn appropriate_mode(&self, ccx: &mut CrateContext) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n-        appropriate_mode(tcx, self.ty)\n+        appropriate_mode(ccx, self.ty)\n     }\n \n     pub fn to_appropriate_llval(&self, bcx: @mut Block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n \n-        match self.appropriate_mode(bcx.tcx()) {\n+        match self.appropriate_mode(bcx.ccx()) {\n             ByValue => self.to_value_llval(bcx),\n             ByRef(_) => self.to_ref_llval(bcx)\n         }\n@@ -527,7 +527,7 @@ impl Datum {\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n \n-        match self.appropriate_mode(bcx.tcx()) {\n+        match self.appropriate_mode(bcx.ccx()) {\n             ByValue => self.to_value_datum(bcx),\n             ByRef(_) => self.to_ref_datum(bcx)\n         }\n@@ -667,7 +667,7 @@ impl Datum {\n                     ByValue => {\n                         // Actually, this case cannot happen right\n                         // now, because enums are never immediate.\n-                        assert!(type_is_immediate(bcx.tcx(), ty));\n+                        assert!(type_is_immediate(bcx.ccx(), ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n@@ -699,7 +699,7 @@ impl Datum {\n                         )\n                     }\n                     ByValue => {\n-                        assert!(type_is_immediate(bcx.tcx(), ty));\n+                        assert!(type_is_immediate(bcx.ccx(), ty));\n                         (\n                             Some(Datum {\n                                 val: ExtractValue(bcx, self.val, 0),"}, {"sha": "ced72e5c6a5c71f75ce27d9424ac89fd41627d4d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -290,7 +290,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert_eq!(datum.appropriate_mode(tcx), ByValue);\n+        assert_eq!(datum.appropriate_mode(bcx.ccx()), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx.ccx()), llenv);"}, {"sha": "8f0f3493a3ad474d65a7c64170814ff2ca575400", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -492,7 +492,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n \n         // Push Rust return pointer, using null if it will be unused.\n         let rust_uses_outptr =\n-            type_of::return_uses_outptr(tcx, tys.fn_sig.output);\n+            type_of::return_uses_outptr(ccx, tys.fn_sig.output);\n         let return_alloca: Option<ValueRef>;\n         let llrust_ret_ty = tys.llsig.llret_ty;\n         let llrust_retptr_ty = llrust_ret_ty.ptr_to();\n@@ -702,7 +702,7 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n         llret_ty: llret_ty,\n-        sret: type_of::return_uses_outptr(ccx.tcx, fn_sig.output),\n+        sret: type_of::return_uses_outptr(ccx, fn_sig.output),\n     }\n }\n "}, {"sha": "3f1f326e72946303f4b4edc33ad7385f037063fc", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 68, "deletions": 39, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -53,7 +53,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         Ret(bcx, llcall);\n     }\n \n-    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str) {\n+    fn with_overflow_instrinsic(bcx: @mut Block, name: &'static str, t: ty::t) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let a = get_param(bcx.fcx.llfn, first_real_arg);\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n@@ -63,12 +63,17 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         let val = Call(bcx, llfn, [a, b], []);\n         let result = ExtractValue(bcx, val, 0);\n         let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n-        let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-        let ret = Load(bcx, retptr);\n+        let ret = Load(bcx, Alloca(bcx, type_of::type_of(bcx.ccx(), t), \"\"));\n         let ret = InsertValue(bcx, ret, result, 0);\n         let ret = InsertValue(bcx, ret, overflow, 1);\n-        Store(bcx, ret, retptr);\n-        RetVoid(bcx)\n+\n+        if type_is_immediate(bcx.ccx(), t) {\n+            Ret(bcx, ret);\n+        } else {\n+            let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n+            Store(bcx, ret, retptr);\n+            RetVoid(bcx);\n+        }\n     }\n \n     fn memcpy_intrinsic(bcx: @mut Block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n@@ -227,7 +232,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx.tcx, tp_ty);\n+            let mode = appropriate_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n@@ -237,7 +242,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"move_val_init\" => {\n             // See comments for `\"move_val\"`.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(ccx.tcx, tp_ty);\n+            let mode = appropriate_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n@@ -278,7 +283,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n             let retty = substs.tys[0];\n-            if type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n+            if type_is_immediate(ccx, retty) && !ty::type_is_nil(retty) {\n                 unsafe {\n                     Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n                 }\n@@ -316,7 +321,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n \n             if !ty::type_is_voidish(out_type) {\n                 let llsrcval = get_param(decl, first_real_arg);\n-                if type_is_immediate(ccx.tcx, in_type) {\n+                if type_is_immediate(ccx, in_type) {\n                     match fcx.llretptr {\n                         Some(llretptr) => {\n                             Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n@@ -335,7 +340,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                             }\n                         }\n                     }\n-                } else if type_is_immediate(ccx.tcx, out_type) {\n+                } else if type_is_immediate(ccx, out_type) {\n                     let llsrcptr = PointerCast(bcx, llsrcval, llouttype.ptr_to());\n                     let ll_load = Load(bcx, llsrcptr);\n                     Ret(bcx, ll_load);\n@@ -466,35 +471,59 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n         \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n \n-        \"i8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\"),\n-        \"i16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\"),\n-        \"i32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\"),\n-        \"i64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\"),\n-\n-        \"u8_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\"),\n-        \"u16_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\"),\n-        \"u32_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\"),\n-        \"u64_add_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\"),\n-\n-        \"i8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\"),\n-        \"i16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\"),\n-        \"i32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\"),\n-        \"i64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\"),\n-\n-        \"u8_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\"),\n-        \"u16_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\"),\n-        \"u32_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\"),\n-        \"u64_sub_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\"),\n-\n-        \"i8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\"),\n-        \"i16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\"),\n-        \"i32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\"),\n-        \"i64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\"),\n-\n-        \"u8_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\"),\n-        \"u16_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\"),\n-        \"u32_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\"),\n-        \"u64_mul_with_overflow\" => with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\"),\n+        \"i8_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i8\", output_type),\n+        \"i16_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i16\", output_type),\n+        \"i32_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i32\", output_type),\n+        \"i64_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.sadd.with.overflow.i64\", output_type),\n+\n+        \"u8_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i8\", output_type),\n+        \"u16_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i16\", output_type),\n+        \"u32_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i32\", output_type),\n+        \"u64_add_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.uadd.with.overflow.i64\", output_type),\n+\n+        \"i8_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i8\", output_type),\n+        \"i16_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i16\", output_type),\n+        \"i32_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i32\", output_type),\n+        \"i64_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.ssub.with.overflow.i64\", output_type),\n+\n+        \"u8_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i8\", output_type),\n+        \"u16_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i16\", output_type),\n+        \"u32_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i32\", output_type),\n+        \"u64_sub_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.usub.with.overflow.i64\", output_type),\n+\n+        \"i8_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i8\", output_type),\n+        \"i16_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i16\", output_type),\n+        \"i32_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i32\", output_type),\n+        \"i64_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.smul.with.overflow.i64\", output_type),\n+\n+        \"u8_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i8\", output_type),\n+        \"u16_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i16\", output_type),\n+        \"u32_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i32\", output_type),\n+        \"u64_mul_with_overflow\" =>\n+            with_overflow_instrinsic(bcx, \"llvm.umul.with.overflow.i64\", output_type),\n \n         _ => {\n             // Could we make this an enum rather than a string? does it get"}, {"sha": "c954bc75b0e82bd144e5366bbef654d9647f1fd2", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e4ae4f45fab7ce1a984d5b5281e129f76486d10/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5e4ae4f45fab7ce1a984d5b5281e129f76486d10", "patch": "@@ -20,12 +20,12 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::opt_vec;\n \n-pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n-    !type_is_immediate(ccx.tcx, arg_ty)\n+pub fn arg_is_indirect(ccx: &mut CrateContext, arg_ty: ty::t) -> bool {\n+    !type_is_immediate(ccx, arg_ty)\n }\n \n-pub fn return_uses_outptr(tcx: ty::ctxt, ty: ty::t) -> bool {\n-    !type_is_immediate(tcx, ty)\n+pub fn return_uses_outptr(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+    !type_is_immediate(ccx, ty)\n }\n \n pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n@@ -49,7 +49,7 @@ pub fn type_of_rust_fn(cx: &mut CrateContext,\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let use_out_pointer = return_uses_outptr(cx.tcx, output);\n+    let use_out_pointer = return_uses_outptr(cx, output);\n     let lloutputtype = type_of(cx, output);\n     if use_out_pointer {\n         atys.push(lloutputtype.ptr_to());"}]}