{"sha": "34662c69614028944668f96c91ef294e7da048f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NjYyYzY5NjE0MDI4OTQ0NjY4Zjk2YzkxZWYyOTRlN2RhMDQ4ZjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-09-04T20:00:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-09-09T15:20:34Z"}, "message": "std: Add a `backtrace` module\n\nThis commit adds a `backtrace` module to the standard library, as\ndesigned in [RFC 2504]. The `Backtrace` type is intentionally very\nconservative, effectively only allowing capturing it and printing it.\n\nAdditionally this commit also adds a `backtrace` method to the `Error`\ntrait which defaults to returning `None`, as specified in [RFC 2504].\nMore information about the design here can be found in [RFC 2504] and in\nthe [tracking issue].\n\nImplementation-wise this is all based on the `backtrace` crate and very\nclosely mirrors the `backtrace::Backtrace` type on crates.io. Otherwise\nit's pretty standard in how it handles everything internally.\n\n[RFC 2504]: https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md\n[tracking issue]: https://github.com/rust-lang/rust/issues/53487\n\ncc #53487", "tree": {"sha": "2bcb69599dfd9ad63c623f69328ee533db8ee212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bcb69599dfd9ad63c623f69328ee533db8ee212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34662c69614028944668f96c91ef294e7da048f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34662c69614028944668f96c91ef294e7da048f0", "html_url": "https://github.com/rust-lang/rust/commit/34662c69614028944668f96c91ef294e7da048f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34662c69614028944668f96c91ef294e7da048f0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "824383d4ab66abd32abc6e19b68d78ecfddcb7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/824383d4ab66abd32abc6e19b68d78ecfddcb7d4", "html_url": "https://github.com/rust-lang/rust/commit/824383d4ab66abd32abc6e19b68d78ecfddcb7d4"}], "stats": {"total": 562, "additions": 508, "deletions": 54}, "files": [{"sha": "5d46ef7dbb10aed22958cef02c7e957630db8996", "filename": "src/libstd/backtrace.rs", "status": "added", "additions": 352, "deletions": 0, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=34662c69614028944668f96c91ef294e7da048f0", "patch": "@@ -0,0 +1,352 @@\n+//! Support for capturing a stack backtrace of an OS thread\n+//!\n+//! This module contains the support necessary to capture a stack backtrace of a\n+//! running OS thread from the OS thread itself. The `Backtrace` type supports\n+//! capturing a stack trace via the `Backtrace::capture` and\n+//! `Backtrace::force_capture` functions.\n+//!\n+//! A backtrace is typically quite handy to attach to errors (e.g. types\n+//! implementing `std::error::Error`) to get a causal chain of where an error\n+//! was generated.\n+//!\n+//! > **Note**: this module is unstable and is designed in [RFC 2504], and you\n+//! > can learn more about its status in the [tracking issue].\n+//!\n+//! [RFC 2504]: https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md\n+//! [tracking issue]: https://github.com/rust-lang/rust/issues/53487\n+//!\n+//! ## Accuracy\n+//!\n+//! Backtraces are attempted to be as accurate as possible, but no guarantees\n+//! are provided about the exact accuracy of a backtrace. Instruction pointers,\n+//! symbol names, filenames, line numbers, etc, may all be incorrect when\n+//! reported. Accuracy is attempted on a best-effort basis, however, and bugs\n+//! are always welcome to indicate areas of improvement!\n+//!\n+//! For most platforms a backtrace with a filename/line number requires that\n+//! programs be compiled with debug information. Without debug information\n+//! filenames/line numbers will not be reported.\n+//!\n+//! ## Platform support\n+//!\n+//! Not all platforms that libstd compiles for support capturing backtraces.\n+//! Some platforms simply do nothing when capturing a backtrace. To check\n+//! whether the platform supports capturing backtraces you can consult the\n+//! `BacktraceStatus` enum as a result of `Backtrace::status`.\n+//!\n+//! Like above with accuracy platform support is done on a best effort basis.\n+//! Sometimes libraries may not be available at runtime or something may go\n+//! wrong which would cause a backtrace to not be captured. Please feel free to\n+//! report issues with platforms where a backtrace cannot be captured though!\n+//!\n+//! ## Environment Variables\n+//!\n+//! The `Backtrace::capture` function may not actually capture a backtrace by\n+//! default. Its behavior is governed by two environment variables:\n+//!\n+//! * `RUST_LIB_BACKTRACE` - if this is set to `0` then `Backtrace::capture`\n+//!   will never capture a backtrace. Any other value this is set to will enable\n+//!   `Backtrace::capture`.\n+//!\n+//! * `RUST_BACKTRACE` - if `RUST_LIB_BACKTRACE` is not set, then this variable\n+//!   is consulted with the same rules of `RUST_LIB_BACKTRACE`.\n+//!\n+//! * If neither of the above env vars are set, then `Backtrace::capture` will\n+//!   be disabled.\n+//!\n+//! Capturing a backtrace can be a quite expensive runtime operation, so the\n+//! environment variables allow either forcibly disabling this runtime\n+//! performance hit or allow selectively enabling it in some programs.\n+//!\n+//! Note that the `Backtrace::force_capture` function can be used to ignore\n+//! these environment variables. Also note that the state of environment\n+//! variables is cached once the first backtrace is created, so altering\n+//! `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` at runtime may not actually change\n+//! how backtraces are captured.\n+\n+#![unstable(feature = \"backtrace\", issue = \"53487\")]\n+\n+// NB: A note on resolution of a backtrace:\n+//\n+// Backtraces primarily happen in two steps, one is where we actually capture\n+// the stack backtrace, giving us a list of instruction pointers corresponding\n+// to stack frames. Next we take these instruction pointers and, one-by-one,\n+// turn them into a human readable name (like `main`).\n+//\n+// The first phase can be somewhat expensive (walking the stack), especially\n+// on MSVC where debug information is consulted to return inline frames each as\n+// their own frame. The second phase, however, is almost always extremely\n+// expensive (on the order of milliseconds sometimes) when it's consulting debug\n+// information.\n+//\n+// We attempt to amortize this cost as much as possible by delaying resolution\n+// of an address to a human readable name for as long as possible. When\n+// `Backtrace::create` is called to capture a backtrace it doesn't actually\n+// perform any symbol resolution, but rather we lazily resolve symbols only just\n+// before they're needed for printing. This way we can make capturing a\n+// backtrace and throwing it away much cheaper, but actually printing a\n+// backtrace is still basically the same cost.\n+//\n+// This strategy comes at the cost of some synchronization required inside of a\n+// `Backtrace`, but that's a relatively small price to pay relative to capturing\n+// a backtrace or actually symbolizing it.\n+\n+use crate::env;\n+use crate::fmt;\n+use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+use crate::sync::Mutex;\n+use crate::sys_common::backtrace::{output_filename, lock};\n+use crate::vec::Vec;\n+use backtrace::BytesOrWideString;\n+\n+/// A captured OS thread stack backtrace.\n+///\n+/// This type represents a stack backtrace for an OS thread captured at a\n+/// previous point in time. In some instances the `Backtrace` type may\n+/// internally be empty due to configuration. For more information see\n+/// `Backtrace::capture`.\n+pub struct Backtrace {\n+    inner: Inner,\n+}\n+\n+/// The current status of a backtrace, indicating whether it was captured or\n+/// whether it is empty for some other reason.\n+#[non_exhaustive]\n+#[derive(Debug)]\n+pub enum BacktraceStatus {\n+    /// Capturing a backtrace is not supported, likely because it's not\n+    /// implemented for the current platform.\n+    Unsupported,\n+    /// Capturing a backtrace has been disabled through either the\n+    /// `RUST_LIB_BACKTRACE` or `RUST_BACKTRACE` environment variables.\n+    Disabled,\n+    /// A backtrace has been captured and the `Backtrace` should print\n+    /// reasonable information when rendered.\n+    Captured,\n+}\n+\n+enum Inner {\n+    Unsupported,\n+    Disabled,\n+    Captured(Mutex<Capture>),\n+}\n+\n+struct Capture {\n+    actual_start: usize,\n+    resolved: bool,\n+    frames: Vec<BacktraceFrame>,\n+}\n+\n+fn _assert_send_sync() {\n+    fn _assert<T: Send + Sync>() {}\n+    _assert::<Backtrace>();\n+}\n+\n+struct BacktraceFrame {\n+    frame: backtrace::Frame,\n+    symbols: Vec<BacktraceSymbol>,\n+}\n+\n+struct BacktraceSymbol {\n+    name: Option<Vec<u8>>,\n+    filename: Option<BytesOrWide>,\n+    lineno: Option<u32>,\n+}\n+\n+enum BytesOrWide {\n+    Bytes(Vec<u8>),\n+    Wide(Vec<u16>),\n+}\n+\n+impl Backtrace {\n+    /// Returns whether backtrace captures are enabled through environment\n+    /// variables.\n+    fn enabled() -> bool {\n+        // Cache the result of reading the environment variables to make\n+        // backtrace captures speedy, because otherwise reading environment\n+        // variables every time can be somewhat slow.\n+        static ENABLED: AtomicUsize = AtomicUsize::new(0);\n+        match ENABLED.load(SeqCst) {\n+            0 => {}\n+            1 => return false,\n+            _ => return true,\n+        }\n+        let enabled = match env::var(\"RUST_LIB_BACKTRACE\") {\n+            Ok(s) => s != \"0\",\n+            Err(_) => match env::var(\"RUST_BACKTRACE\") {\n+                Ok(s) => s != \"0\",\n+                Err(_) => false,\n+            },\n+        };\n+        ENABLED.store(enabled as usize + 1, SeqCst);\n+        return enabled;\n+    }\n+\n+    /// Capture a stack backtrace of the current thread.\n+    ///\n+    /// This function will capture a stack backtrace of the current OS thread of\n+    /// execution, returning a `Backtrace` type which can be later used to print\n+    /// the entire stack trace or render it to a string.\n+    ///\n+    /// This function will be a noop if the `RUST_BACKTRACE` or\n+    /// `RUST_LIB_BACKTRACE` backtrace variables are both not set. If either\n+    /// environment variable is set and enabled then this function will actually\n+    /// capture a backtrace. Capturing a backtrace can be both memory intensive\n+    /// and slow, so these environment variables allow liberally using\n+    /// `Backtrace::capture` and only incurring a slowdown when the environment\n+    /// variables are set.\n+    ///\n+    /// To forcibly capture a backtrace regardless of environment variables, use\n+    /// the `Backtrace::force_capture` function.\n+    #[inline(never)] // want to make sure there's a frame here to remove\n+    pub fn capture() -> Backtrace {\n+        if !Backtrace::enabled() {\n+            return Backtrace { inner: Inner::Disabled };\n+        }\n+        Backtrace::create(Backtrace::capture as usize)\n+    }\n+\n+    /// Forcibly captures a full backtrace, regardless of environment variable\n+    /// configuration.\n+    ///\n+    /// This function behaves the same as `capture` except that it ignores the\n+    /// values of the `RUST_BACKTRACE` and `RUST_LIB_BACKTRACE` environment\n+    /// variables, always capturing a backtrace.\n+    ///\n+    /// Note that capturing a backtrace can be an expensive operation on some\n+    /// platforms, so this should be used with caution in performance-sensitive\n+    /// parts of code.\n+    #[inline(never)] // want to make sure there's a frame here to remove\n+    pub fn force_capture() -> Backtrace {\n+        Backtrace::create(Backtrace::force_capture as usize)\n+    }\n+\n+    // Capture a backtrace which start just before the function addressed by\n+    // `ip`\n+    fn create(ip: usize) -> Backtrace {\n+        let _lock = lock();\n+        let mut frames = Vec::new();\n+        let mut actual_start = None;\n+        unsafe {\n+            backtrace::trace_unsynchronized(|frame| {\n+                frames.push(BacktraceFrame { frame: frame.clone(), symbols: Vec::new() });\n+                if frame.symbol_address() as usize == ip && actual_start.is_none() {\n+                    actual_start = Some(frames.len());\n+                }\n+                true\n+            });\n+        }\n+\n+        // If no frames came out assume that this is an unsupported platform\n+        // since `backtrace` doesn't provide a way of learning this right now,\n+        // and this should be a good enough approximation.\n+        let inner = if frames.len() == 0 {\n+            Inner::Unsupported\n+        } else {\n+            Inner::Captured(Mutex::new(Capture {\n+                actual_start: actual_start.unwrap_or(0),\n+                frames,\n+                resolved: false,\n+            }))\n+        };\n+\n+        Backtrace { inner }\n+    }\n+\n+    /// Returns the status of this backtrace, indicating whether this backtrace\n+    /// request was unsupported, disabled, or a stack trace was actually\n+    /// captured.\n+    pub fn status(&self) -> BacktraceStatus {\n+        match self.inner {\n+            Inner::Unsupported => BacktraceStatus::Unsupported,\n+            Inner::Disabled => BacktraceStatus::Disabled,\n+            Inner::Captured(_) => BacktraceStatus::Captured,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Backtrace {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(self, fmt)\n+    }\n+}\n+\n+impl fmt::Debug for Backtrace {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut capture = match &self.inner {\n+            Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n+            Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n+            Inner::Captured(c) => c.lock().unwrap(),\n+        };\n+        capture.resolve();\n+\n+        let full = fmt.alternate();\n+        let (frames, style) = if full {\n+            (&capture.frames[..], backtrace::PrintFmt::Full)\n+        } else {\n+            (&capture.frames[capture.actual_start..], backtrace::PrintFmt::Short)\n+        };\n+\n+        // When printing paths we try to strip the cwd if it exists, otherwise\n+        // we just print the path as-is. Note that we also only do this for the\n+        // short format, because if it's full we presumably want to print\n+        // everything.\n+        let cwd = crate::env::current_dir();\n+        let mut print_path = move |fmt: &mut fmt::Formatter<'_>, path: BytesOrWideString<'_>| {\n+            output_filename(fmt, path, style, cwd.as_ref().ok())\n+        };\n+\n+        let mut f = backtrace::BacktraceFmt::new(fmt, style, &mut print_path);\n+        f.add_context()?;\n+        for frame in frames {\n+            let mut f = f.frame();\n+            if frame.symbols.is_empty() {\n+                f.print_raw(frame.frame.ip(), None, None, None)?;\n+            } else {\n+                for symbol in frame.symbols.iter() {\n+                    f.print_raw(\n+                        frame.frame.ip(),\n+                        symbol.name.as_ref().map(|b| backtrace::SymbolName::new(b)),\n+                        symbol.filename.as_ref().map(|b| match b {\n+                            BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n+                            BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n+                        }),\n+                        symbol.lineno,\n+                    )?;\n+                }\n+            }\n+        }\n+        f.finish()?;\n+        Ok(())\n+    }\n+}\n+\n+impl Capture {\n+    fn resolve(&mut self) {\n+        // If we're already resolved, nothing to do!\n+        if self.resolved {\n+            return;\n+        }\n+        self.resolved = true;\n+\n+        // Use the global backtrace lock to synchronize this as it's a\n+        // requirement of the `backtrace` crate, and then actually resolve\n+        // everything.\n+        let _lock = lock();\n+        for frame in self.frames.iter_mut() {\n+            let symbols = &mut frame.symbols;\n+            unsafe {\n+                backtrace::resolve_frame_unsynchronized(&frame.frame, |symbol| {\n+                    symbols.push(BacktraceSymbol {\n+                        name: symbol.name().map(|m| m.as_bytes().to_vec()),\n+                        filename: symbol.filename_raw().map(|b| match b {\n+                            BytesOrWideString::Bytes(b) => BytesOrWide::Bytes(b.to_owned()),\n+                            BytesOrWideString::Wide(b) => BytesOrWide::Wide(b.to_owned()),\n+                        }),\n+                        lineno: symbol.lineno(),\n+                    });\n+                });\n+            }\n+        }\n+    }\n+}"}, {"sha": "998d59f90a255966ecd9ce768428da7cf536458c", "filename": "src/libstd/error.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=34662c69614028944668f96c91ef294e7da048f0", "patch": "@@ -17,6 +17,7 @@ use core::array;\n \n use crate::alloc::{AllocErr, LayoutErr, CannotReallocInPlace};\n use crate::any::TypeId;\n+use crate::backtrace::Backtrace;\n use crate::borrow::Cow;\n use crate::cell;\n use crate::char;\n@@ -204,6 +205,20 @@ pub trait Error: Debug + Display {\n     fn type_id(&self, _: private::Internal) -> TypeId where Self: 'static {\n         TypeId::of::<Self>()\n     }\n+\n+    /// Returns a stack backtrace, if available, of where this error ocurred.\n+    ///\n+    /// This function allows inspecting the location, in code, of where an error\n+    /// happened. The returned `Backtrace` contains information about the stack\n+    /// trace of the OS thread of execution of where the error originated from.\n+    ///\n+    /// Note that not all errors contain a `Backtrace`. Also note that a\n+    /// `Backtrace` may actually be empty. For more information consult the\n+    /// `Backtrace` type itself.\n+    #[unstable(feature = \"backtrace\", issue = \"53487\")]\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        None\n+    }\n }\n \n mod private {"}, {"sha": "388c997d7c77cccb67185f9063e5cf13518d8a1c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=34662c69614028944668f96c91ef294e7da048f0", "patch": "@@ -452,6 +452,7 @@ pub mod f64;\n #[macro_use]\n pub mod thread;\n pub mod ascii;\n+pub mod backtrace;\n pub mod collections;\n pub mod env;\n pub mod error;"}, {"sha": "839dc51b9e9e8bc554d6a2ddc45f9a05257eedf6", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 65, "deletions": 54, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34662c69614028944668f96c91ef294e7da048f0/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=34662c69614028944668f96c91ef294e7da048f0", "patch": "@@ -4,8 +4,9 @@\n use crate::env;\n use crate::fmt;\n use crate::io;\n+use crate::borrow::Cow;\n use crate::io::prelude::*;\n-use crate::path::{self, Path};\n+use crate::path::{self, Path, PathBuf};\n use crate::sync::atomic::{self, Ordering};\n use crate::sys::mutex::Mutex;\n \n@@ -14,10 +15,26 @@ use backtrace::{BacktraceFmt, BytesOrWideString, PrintFmt};\n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n \n-/// Prints the current backtrace.\n-pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n+pub fn lock() -> impl Drop {\n+    struct Guard;\n     static LOCK: Mutex = Mutex::new();\n \n+    impl Drop for Guard {\n+        fn drop(&mut self) {\n+            unsafe {\n+                LOCK.unlock();\n+            }\n+        }\n+    }\n+\n+    unsafe {\n+        LOCK.lock();\n+        return Guard;\n+    }\n+}\n+\n+/// Prints the current backtrace.\n+pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n     // There are issues currently linking libbacktrace into tests, and in\n     // general during libstd's own unit tests we're not testing this path. In\n     // test mode immediately return here to optimize away any references to the\n@@ -29,71 +46,67 @@ pub fn print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n     // Use a lock to prevent mixed output in multithreading context.\n     // Some platforms also requires it, like `SymFromAddr` on Windows.\n     unsafe {\n-        LOCK.lock();\n-        let res = _print(w, format);\n-        LOCK.unlock();\n-        res\n+        let _lock = lock();\n+        _print(w, format)\n     }\n }\n \n-fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n+unsafe fn _print(w: &mut dyn Write, format: PrintFmt) -> io::Result<()> {\n     struct DisplayBacktrace {\n         format: PrintFmt,\n     }\n     impl fmt::Display for DisplayBacktrace {\n         fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            _print_fmt(fmt, self.format)\n+            unsafe {\n+                _print_fmt(fmt, self.format)\n+            }\n         }\n     }\n     write!(w, \"{}\", DisplayBacktrace { format })\n }\n \n-fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n+unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::Result {\n+    let cwd = env::current_dir().ok();\n     let mut print_path = move |fmt: &mut fmt::Formatter<'_>, bows: BytesOrWideString<'_>| {\n-        output_filename(fmt, bows, print_fmt)\n+        output_filename(fmt, bows, print_fmt, cwd.as_ref())\n     };\n     let mut bt_fmt = BacktraceFmt::new(fmt, print_fmt, &mut print_path);\n     bt_fmt.add_context()?;\n-    let mut skipped = false;\n-    unsafe {\n-        let mut idx = 0;\n-        let mut res = Ok(());\n-        backtrace::trace_unsynchronized(|frame| {\n-            if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n-                skipped = true;\n-                return false;\n-            }\n+    let mut idx = 0;\n+    let mut res = Ok(());\n+    backtrace::trace_unsynchronized(|frame| {\n+        if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n+            return false;\n+        }\n \n-            let mut hit = false;\n-            let mut stop = false;\n-            backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n-                hit = true;\n-                if print_fmt == PrintFmt::Short {\n-                    if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n-                        if sym.contains(\"__rust_begin_short_backtrace\") {\n-                            skipped = true;\n-                            stop = true;\n-                            return;\n-                        }\n+        let mut hit = false;\n+        let mut stop = false;\n+        backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n+            hit = true;\n+            if print_fmt == PrintFmt::Short {\n+                if let Some(sym) = symbol.name().and_then(|s| s.as_str()) {\n+                    if sym.contains(\"__rust_begin_short_backtrace\") {\n+                        stop = true;\n+                        return;\n                     }\n                 }\n-\n-                res = bt_fmt.frame().symbol(frame, symbol);\n-            });\n-            if stop {\n-                return false;\n-            }\n-            if !hit {\n-                res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n             }\n \n-            idx += 1;\n-            res.is_ok()\n+            res = bt_fmt.frame().symbol(frame, symbol);\n         });\n-        res?;\n-    }\n+        if stop {\n+            return false;\n+        }\n+        if !hit {\n+            res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n+        }\n+\n+        idx += 1;\n+        res.is_ok()\n+    });\n+    res?;\n     bt_fmt.finish()?;\n-    if skipped {\n+    if print_fmt == PrintFmt::Short {\n         writeln!(\n             fmt,\n             \"note: Some details are omitted, \\\n@@ -147,36 +160,34 @@ pub fn log_enabled() -> Option<PrintFmt> {\n /// Prints the filename of the backtrace frame.\n ///\n /// See also `output`.\n-fn output_filename(\n+pub fn output_filename(\n     fmt: &mut fmt::Formatter<'_>,\n     bows: BytesOrWideString<'_>,\n     print_fmt: PrintFmt,\n+    cwd: Option<&PathBuf>,\n ) -> fmt::Result {\n-    #[cfg(windows)]\n-    let path_buf;\n-    let file = match bows {\n+    let file: Cow<'_, Path> = match bows {\n         #[cfg(unix)]\n         BytesOrWideString::Bytes(bytes) => {\n             use crate::os::unix::prelude::*;\n-            Path::new(crate::ffi::OsStr::from_bytes(bytes))\n+            Path::new(crate::ffi::OsStr::from_bytes(bytes)).into()\n         }\n         #[cfg(not(unix))]\n         BytesOrWideString::Bytes(bytes) => {\n-            Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\"))\n+            Path::new(crate::str::from_utf8(bytes).unwrap_or(\"<unknown>\")).into()\n         }\n         #[cfg(windows)]\n         BytesOrWideString::Wide(wide) => {\n             use crate::os::windows::prelude::*;\n-            path_buf = crate::ffi::OsString::from_wide(wide);\n-            Path::new(&path_buf)\n+            Cow::Owned(crate::ffi::OsString::from_wide(wide).into())\n         }\n         #[cfg(not(windows))]\n         BytesOrWideString::Wide(_wide) => {\n-            Path::new(\"<unknown>\")\n+            Path::new(\"<unknown>\").into()\n         }\n     };\n     if print_fmt == PrintFmt::Short && file.is_absolute() {\n-        if let Ok(cwd) = env::current_dir() {\n+        if let Some(cwd) = cwd {\n             if let Ok(stripped) = file.strip_prefix(&cwd) {\n                 if let Some(s) = stripped.to_str() {\n                     return write!(fmt, \".{}{}\", path::MAIN_SEPARATOR, s);"}, {"sha": "d84c493d53523be9f58f24a6f8aa580c58d7a9ac", "filename": "src/test/ui/std-backtrace.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/34662c69614028944668f96c91ef294e7da048f0/src%2Ftest%2Fui%2Fstd-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34662c69614028944668f96c91ef294e7da048f0/src%2Ftest%2Fui%2Fstd-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstd-backtrace.rs?ref=34662c69614028944668f96c91ef294e7da048f0", "patch": "@@ -0,0 +1,75 @@\n+// run-pass\n+// ignore-android FIXME #17520\n+// ignore-cloudabi spawning processes is not supported\n+// ignore-emscripten spawning processes is not supported\n+// ignore-openbsd no support for libbacktrace without filename\n+// ignore-sgx no processes\n+// ignore-msvc see #62897 and `backtrace-debuginfo.rs` test\n+// compile-flags:-g\n+\n+#![feature(backtrace)]\n+\n+use std::env;\n+use std::process::Command;\n+use std::str;\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() >= 2 && args[1] == \"force\" {\n+        println!(\"{}\", std::backtrace::Backtrace::force_capture());\n+    } else if args.len() >= 2 {\n+        println!(\"{}\", std::backtrace::Backtrace::capture());\n+    } else {\n+        runtest(&args[0]);\n+        println!(\"test ok\");\n+    }\n+}\n+\n+fn runtest(me: &str) {\n+    env::remove_var(\"RUST_BACKTRACE\");\n+    env::remove_var(\"RUST_LIB_BACKTRACE\");\n+\n+    let p = Command::new(me).arg(\"a\").env(\"RUST_BACKTRACE\", \"1\").output().unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"stack backtrace:\\n\"));\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"backtrace::main\"));\n+\n+    let p = Command::new(me).arg(\"a\").env(\"RUST_BACKTRACE\", \"0\").output().unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"disabled backtrace\\n\"));\n+\n+    let p = Command::new(me).arg(\"a\").output().unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"disabled backtrace\\n\"));\n+\n+    let p = Command::new(me)\n+        .arg(\"a\")\n+        .env(\"RUST_LIB_BACKTRACE\", \"1\")\n+        .env(\"RUST_BACKTRACE\", \"1\")\n+        .output()\n+        .unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"stack backtrace:\\n\"));\n+\n+    let p = Command::new(me)\n+        .arg(\"a\")\n+        .env(\"RUST_LIB_BACKTRACE\", \"0\")\n+        .env(\"RUST_BACKTRACE\", \"1\")\n+        .output()\n+        .unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"disabled backtrace\\n\"));\n+\n+    let p = Command::new(me)\n+        .arg(\"force\")\n+        .env(\"RUST_LIB_BACKTRACE\", \"0\")\n+        .env(\"RUST_BACKTRACE\", \"0\")\n+        .output()\n+        .unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"stack backtrace:\\n\"));\n+\n+    let p = Command::new(me).arg(\"force\").output().unwrap();\n+    assert!(p.status.success());\n+    assert!(String::from_utf8_lossy(&p.stdout).contains(\"stack backtrace:\\n\"));\n+}"}]}