{"sha": "92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYmZjZDJiMTkyZTU5ZDEyZDY0YWNmNmY0NmMxODk3YTMyNzNiM2U=", "commit": {"author": {"name": "snf", "email": "snf@users.noreply.github.com", "date": "2018-03-08T14:36:43Z"}, "committer": {"name": "snf", "email": "snf@users.noreply.github.com", "date": "2018-03-14T10:48:42Z"}, "message": "implementing fallible allocation API (try_reserve) for Vec, String and HashMap", "tree": {"sha": "001462078f9c699aa3cf33322be05cc6f7b9b3d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/001462078f9c699aa3cf33322be05cc6f7b9b3d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "html_url": "https://github.com/rust-lang/rust/commit/92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/comments", "author": {"login": "snf", "id": 3269911, "node_id": "MDQ6VXNlcjMyNjk5MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3269911?v=4", "gravatar_id": "", "url": "https://api.github.com/users/snf", "html_url": "https://github.com/snf", "followers_url": "https://api.github.com/users/snf/followers", "following_url": "https://api.github.com/users/snf/following{/other_user}", "gists_url": "https://api.github.com/users/snf/gists{/gist_id}", "starred_url": "https://api.github.com/users/snf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/snf/subscriptions", "organizations_url": "https://api.github.com/users/snf/orgs", "repos_url": "https://api.github.com/users/snf/repos", "events_url": "https://api.github.com/users/snf/events{/privacy}", "received_events_url": "https://api.github.com/users/snf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "snf", "id": 3269911, "node_id": "MDQ6VXNlcjMyNjk5MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/3269911?v=4", "gravatar_id": "", "url": "https://api.github.com/users/snf", "html_url": "https://github.com/snf", "followers_url": "https://api.github.com/users/snf/followers", "following_url": "https://api.github.com/users/snf/following{/other_user}", "gists_url": "https://api.github.com/users/snf/gists{/gist_id}", "starred_url": "https://api.github.com/users/snf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/snf/subscriptions", "organizations_url": "https://api.github.com/users/snf/orgs", "repos_url": "https://api.github.com/users/snf/repos", "events_url": "https://api.github.com/users/snf/events{/privacy}", "received_events_url": "https://api.github.com/users/snf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fab632f9759af4f3d96c6ec69e24e5428060dba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fab632f9759af4f3d96c6ec69e24e5428060dba4", "html_url": "https://github.com/rust-lang/rust/commit/fab632f9759af4f3d96c6ec69e24e5428060dba4"}], "stats": {"total": 1128, "additions": 1056, "deletions": 72}, "files": [{"sha": "fdc4efc66b988a9df322a083285ba8d6809dec38", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -373,6 +373,24 @@ impl fmt::Display for CannotReallocInPlace {\n     }\n }\n \n+/// Augments `AllocErr` with a CapacityOverflow variant.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+pub enum CollectionAllocErr {\n+    /// Error due to the computed capacity exceeding the collection's maximum\n+    /// (usually `isize::MAX` bytes).\n+    CapacityOverflow,\n+    /// Error due to the allocator (see the `AllocErr` type's docs).\n+    AllocErr(AllocErr),\n+}\n+\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+impl From<AllocErr> for CollectionAllocErr {\n+    fn from(err: AllocErr) -> Self {\n+        CollectionAllocErr::AllocErr(err)\n+    }\n+}\n+\n /// An implementation of `Alloc` can allocate, reallocate, and\n /// deallocate arbitrary blocks of data described via `Layout`.\n ///"}, {"sha": "b93e128d5081917bed021171d0d6fafec73fd562", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -117,6 +117,7 @@\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsize)]"}, {"sha": "229ae54d7474adffd634883aa654b69b32518698", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -15,6 +15,8 @@ use core::ptr::{self, Unique};\n use core::slice;\n use heap::{Alloc, Layout, Heap};\n use super::boxed::Box;\n+use super::allocator::CollectionAllocErr;\n+use super::allocator::CollectionAllocErr::*;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -84,7 +86,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let elem_size = mem::size_of::<T>();\n \n             let alloc_size = cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-            alloc_guard(alloc_size);\n+            alloc_guard(alloc_size).expect(\"capacity overflow\");\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n@@ -308,7 +310,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n-                    alloc_guard(new_size);\n+                    alloc_guard(new_size).expect(\"capacity overflow\");\n                     let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n                                                  cur,\n                                                  new_layout);\n@@ -367,7 +369,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n-            alloc_guard(new_size);\n+            alloc_guard(new_size).expect(\"capacity overflow\");\n             let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n@@ -403,7 +405,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n+           -> Result<(), CollectionAllocErr> {\n+\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -413,43 +417,50 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity.\n             // Wrapping in case they gave a bad `used_cap`.\n             if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return;\n+                return Ok(());\n             }\n \n             // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n-            let new_layout = match Layout::array::<T>(new_cap) {\n-                Some(layout) => layout,\n-                None => panic!(\"capacity overflow\"),\n-            };\n-            alloc_guard(new_layout.size());\n+            let new_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n+            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+\n+            alloc_guard(new_layout.size())?;\n+\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n                     self.a.realloc(old_ptr, layout, new_layout)\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n-            let uniq = match res {\n-                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n-                Err(e) => self.a.oom(e),\n-            };\n-            self.ptr = uniq;\n+\n+            self.ptr = Unique::new_unchecked(res? as *mut T);\n             self.cap = new_cap;\n+\n+            Ok(())\n         }\n     }\n \n+    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        match self.try_reserve_exact(used_cap, needed_extra_cap) {\n+            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(AllocErr(e)) => self.a.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+     }\n+\n     /// Calculates the buffer's new size given that it'll hold `used_cap +\n     /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> usize {\n+    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<usize, CollectionAllocErr> {\n+\n         // Nothing we can really do about these checks :(\n-        let required_cap = used_cap.checked_add(needed_extra_cap)\n-            .expect(\"capacity overflow\");\n+        let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n-        cmp::max(double_cap, required_cap)\n+        Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -504,8 +515,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        unsafe {\n+    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<(), CollectionAllocErr> {\n+         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -514,33 +526,38 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity.\n             // Wrapping in case they give a bad `used_cap`\n             if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return;\n+               return Ok(());\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n+            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+\n+             // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size())?;\n \n-            let new_layout = match Layout::array::<T>(new_cap) {\n-                Some(layout) => layout,\n-                None => panic!(\"capacity overflow\"),\n-            };\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size());\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     let old_ptr = self.ptr.as_ptr() as *mut u8;\n                     self.a.realloc(old_ptr, layout, new_layout)\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n-            let uniq = match res {\n-                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n-                Err(e) => self.a.oom(e),\n-            };\n-            self.ptr = uniq;\n+\n+            self.ptr = Unique::new_unchecked(res? as *mut T);\n             self.cap = new_cap;\n+\n+            Ok(())\n         }\n     }\n \n+    /// The same as try_reserve, but errors are lowered to a call to oom().\n+    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n+        match self.try_reserve(used_cap, needed_extra_cap) {\n+            Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(AllocErr(e)) => self.a.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+     }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -576,7 +593,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n+                              .expect(\"capacity overflow\");\n \n             // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n             // (regardless of whether `self.cap - used_cap` wrapped).\n@@ -585,7 +603,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size());\n+            alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -709,14 +727,14 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g. PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) {\n-    if mem::size_of::<usize>() < 8 {\n-        assert!(alloc_size <= ::core::isize::MAX as usize,\n-                \"capacity overflow\");\n+fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+    if mem::size_of::<usize>() < 8 && alloc_size > ::core::isize::MAX as usize {\n+        Err(CapacityOverflow)\n+    } else {\n+        Ok(())\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "dcc814173460dc3c0b394626abf40cf8be056129", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -71,6 +71,7 @@ use Bound::{Excluded, Included, Unbounded};\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n+use super::allocator::CollectionAllocErr;\n \n /// A UTF-8 encoded, growable string.\n ///\n@@ -920,6 +921,79 @@ impl String {\n         self.vec.reserve_exact(additional)\n     }\n \n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `String`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    ///     let mut output = String::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.push_str(data);\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.vec.try_reserve(additional)\n+    }\n+\n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `String`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    ///     let mut output = String::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.push_str(data);\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.vec.try_reserve_exact(additional)\n+    }\n+\n     /// Shrinks the capacity of this `String` to match its length.\n     ///\n     /// # Examples"}, {"sha": "285cba0270c033402f64c1d5d38d30a7fa00273e", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -26,6 +26,7 @@\n #![feature(splice)]\n #![feature(str_escape)]\n #![feature(string_retain)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(exact_chunks)]"}, {"sha": "d1e746ea43b45516875e87f7d30f94f0e194556d", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n use std::borrow::Cow;\n+use std::collections::CollectionAllocErr::*;\n+use std::mem::size_of;\n+use std::{usize, isize};\n \n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B>;\n@@ -504,3 +507,163 @@ fn test_into_boxed_str() {\n     let ys = xs.into_boxed_str();\n     assert_eq!(&*ys, \"hello my name is bob\");\n }\n+\n+#[test]\n+fn test_reserve_exact() {\n+    // This is all the same as test_reserve\n+\n+    let mut s = String::new();\n+    assert_eq!(s.capacity(), 0);\n+\n+    s.reserve_exact(2);\n+    assert!(s.capacity() >= 2);\n+\n+    for _i in 0..16 {\n+        s.push('0');\n+    }\n+\n+    assert!(s.capacity() >= 16);\n+    s.reserve_exact(16);\n+    assert!(s.capacity() >= 32);\n+\n+    s.push('0');\n+\n+    s.reserve_exact(16);\n+    assert!(s.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_string: String = String::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX + 1 is an OOM\n+            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            // Check usize::MAX is an OOM\n+            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: String = String::from(\"0123456789\");\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_string: String = String::new();\n+\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: String = String::from(\"0123456789\");\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "3c17a401bbaf5793b4d63486d8ad3121b879c0a5", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 208, "deletions": 1, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -10,8 +10,9 @@\n \n use std::borrow::Cow;\n use std::mem::size_of;\n-use std::panic;\n+use std::{usize, isize, panic};\n use std::vec::{Drain, IntoIter};\n+use std::collections::CollectionAllocErr::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -965,3 +966,209 @@ fn drain_filter_complex() {\n         assert_eq!(vec, vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n }\n+\n+#[test]\n+fn test_reserve_exact() {\n+    // This is all the same as test_reserve\n+\n+    let mut v = Vec::new();\n+    assert_eq!(v.capacity(), 0);\n+\n+    v.reserve_exact(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push(16);\n+\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_bytes: Vec<u8> = Vec::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX + 1 is an OOM\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            // Check usize::MAX is an OOM\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with interesting type size\n+        let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should fail in the mul-by-size\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = isize::MAX as usize;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_bytes: Vec<u8> = Vec::new();\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: Vec<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        let mut ten_u32s: Vec<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "fc1a0b624a555eebde59edf875a7f459074800bc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -11,6 +11,9 @@\n use std::collections::VecDeque;\n use std::fmt::Debug;\n use std::collections::vec_deque::{Drain};\n+use std::collections::CollectionAllocErr::*;\n+use std::mem::size_of;\n+use std::{usize, isize};\n \n use self::Taggy::*;\n use self::Taggypar::*;\n@@ -1022,3 +1025,208 @@ fn test_placement_in() {\n     }\n     assert_eq!(buf, [5,4,3,1,2,6]);\n }\n+\n+#[test]\n+fn test_reserve_exact_2() {\n+    // This is all the same as test_reserve\n+\n+    let mut v = VecDeque::new();\n+\n+    v.reserve_exact(2);\n+    assert!(v.capacity() >= 2);\n+\n+    for i in 0..16 {\n+        v.push_back(i);\n+    }\n+\n+    assert!(v.capacity() >= 16);\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 32);\n+\n+    v.push_back(16);\n+\n+    v.reserve_exact(16);\n+    assert!(v.capacity() >= 48)\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+\n+    // These are the interesting cases:\n+    // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n+    // * > isize::MAX should always fail\n+    //    * On 16/32-bit should CapacityOverflow\n+    //    * On 64-bit should OOM\n+    // * overflow may trigger when adding `len` to `cap` (in number of elements)\n+    // * overflow may trigger when multiplying `new_cap` by size_of::<T> (to get bytes)\n+\n+    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    // On 16/32-bit, we check that allocations don't exceed isize::MAX,\n+    // on 64-bit, we assume the OS will give an OOM for such a ridiculous size.\n+    // Any platform that succeeds for these requests is technically broken with\n+    // ptr::offset because LLVM is the worst.\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        // Note: basic stuff is checked by test_reserve\n+        let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n+\n+        // Check isize::MAX doesn't count as an overflow\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        // Play it again, frank! (just to be sure)\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            // Check isize::MAX + 1 does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            // Check usize::MAX does count as overflow\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX is an OOM\n+            // VecDeque starts with capacity 7, always adds 1 to the capacity\n+            // and also rounds the number to next power of 2 so this is the\n+            // furthest we can go without triggering CapacityOverflow\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with non-zero len\n+        let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should always overflow in the add-to-len\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        // Same basic idea, but with interesting type size\n+        let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        // Should fail in the mul-by-size\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\");\n+        }\n+    }\n+\n+}\n+\n+#[test]\n+fn test_try_reserve_exact() {\n+\n+    // This is exactly the same as test_try_reserve with the method changed.\n+    // See that test for comments.\n+\n+    const MAX_CAP: usize = (isize::MAX as usize + 1) / 2 - 1;\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    let guards_against_isize = size_of::<usize>() < 8;\n+\n+    {\n+        let mut empty_bytes: VecDeque<u8> = VecDeque::new();\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            // Check isize::MAX is an OOM\n+            // VecDeque starts with capacity 7, always adds 1 to the capacity\n+            // and also rounds the number to next power of 2 so this is the\n+            // furthest we can go without triggering CapacityOverflow\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n+\n+    {\n+        let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+\n+    {\n+        let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+            panic!(\"isize::MAX shouldn't trigger an overflow!\");\n+        }\n+        if guards_against_isize {\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+        } else {\n+            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+    }\n+\n+}"}, {"sha": "953f95876be1586763d384ec54b6edf5b7c5cfa0", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -86,6 +86,7 @@ use borrow::Cow;\n use boxed::Box;\n use raw_vec::RawVec;\n use super::range::RangeArgument;\n+use super::allocator::CollectionAllocErr;\n use Bound::{Excluded, Included, Unbounded};\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n@@ -489,6 +490,83 @@ impl<T> Vec<T> {\n         self.buf.reserve_exact(self.len, additional);\n     }\n \n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    ///     let mut output = Vec::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.buf.try_reserve(self.len, additional)\n+    }\n+\n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `Vec<T>`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    ///     let mut output = Vec::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.buf.try_reserve_exact(self.len, additional)\n+    }\n+\n     /// Shrinks the capacity of the vector as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator"}, {"sha": "0658777f0a0e0bba40c15f012f7e352502f202eb", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -31,6 +31,7 @@ use core::cmp;\n \n use raw_vec::RawVec;\n \n+use super::allocator::CollectionAllocErr;\n use super::range::RangeArgument;\n use Bound::{Excluded, Included, Unbounded};\n use super::vec::Vec;\n@@ -566,6 +567,97 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n+    /// capacity will be greater than or equal to `self.len() + additional`.\n+    /// Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it\n+    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// minimal. Prefer `reserve` if future insertions are expected.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    ///     let mut output = VecDeque::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve_exact(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+        self.try_reserve(additional)\n+    }\n+\n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `VecDeque<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations. After calling `reserve`, capacity will be\n+    /// greater than or equal to `self.len() + additional`. Does nothing if\n+    /// capacity is already sufficient.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    ///     let mut output = VecDeque::new();\n+    ///\n+    ///     // Pre-reserve the memory, exiting if we can't\n+    ///     output.try_reserve(data.len())?;\n+    ///\n+    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     output.extend(data.iter().map(|&val| {\n+    ///         val * 2 + 5 // very complicated\n+    ///     }));\n+    ///\n+    ///     Ok(output)\n+    /// }\n+    /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        let old_cap = self.cap();\n+        let used_cap = self.len() + 1;\n+        let new_cap = used_cap.checked_add(additional)\n+            .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n+            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+\n+        if new_cap > old_cap {\n+            self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n+            unsafe {\n+                self.handle_cap_increase(old_cap);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Shrinks the capacity of the `VecDeque` as much as possible.\n     ///\n     /// It will drop down as close as possible to the length but the allocator may still inform the"}, {"sha": "b18b38ec302460e4eb1f0fd9c84739dfac9252a3", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 83, "deletions": 13, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -11,6 +11,8 @@\n use self::Entry::*;\n use self::VacantEntryState::*;\n \n+use alloc::heap::{Heap, Alloc};\n+use alloc::allocator::CollectionAllocErr;\n use cell::Cell;\n use borrow::Borrow;\n use cmp::max;\n@@ -42,21 +44,28 @@ impl DefaultResizePolicy {\n     /// provide that capacity, accounting for maximum loading. The raw capacity\n     /// is always zero or a power of two.\n     #[inline]\n-    fn raw_capacity(&self, len: usize) -> usize {\n+    fn try_raw_capacity(&self, len: usize) -> Result<usize, CollectionAllocErr> {\n         if len == 0 {\n-            0\n+            Ok(0)\n         } else {\n             // 1. Account for loading: `raw_capacity >= len * 1.1`.\n             // 2. Ensure it is a power of two.\n             // 3. Ensure it is at least the minimum size.\n-            let mut raw_cap = len * 11 / 10;\n-            assert!(raw_cap >= len, \"raw_cap overflow\");\n-            raw_cap = raw_cap.checked_next_power_of_two().expect(\"raw_capacity overflow\");\n+            let mut raw_cap = len.checked_mul(11)\n+                .map(|l| l / 10)\n+                .and_then(|l| l.checked_next_power_of_two())\n+                .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+\n             raw_cap = max(MIN_NONZERO_RAW_CAPACITY, raw_cap);\n-            raw_cap\n+            Ok(raw_cap)\n         }\n     }\n \n+    #[inline]\n+    fn raw_capacity(&self, len: usize) -> usize {\n+        self.try_raw_capacity(len).expect(\"raw_capacity overflow\")\n+    }\n+\n     /// The capacity of the given raw capacity.\n     #[inline]\n     fn capacity(&self, raw_cap: usize) -> usize {\n@@ -775,17 +784,45 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n+        match self.try_reserve(additional) {\n+            Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Ok(()) => { /* yay */ }\n+         }\n+    }\n+\n+    /// Tries to reserve capacity for at least `additional` more elements to be inserted\n+    /// in the given `HashMap<K,V>`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(try_reserve)]\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, isize> = HashMap::new();\n+    /// map.try_reserve(10).expect(\"why is the test harness OOMing on 10 bytes?\");\n+    /// ```\n+    #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n         let remaining = self.capacity() - self.len(); // this can't overflow\n         if remaining < additional {\n-            let min_cap = self.len().checked_add(additional).expect(\"reserve overflow\");\n-            let raw_cap = self.resize_policy.raw_capacity(min_cap);\n-            self.resize(raw_cap);\n+            let min_cap = self.len().checked_add(additional)\n+                .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+            let raw_cap = self.resize_policy.try_raw_capacity(min_cap)?;\n+            self.try_resize(raw_cap)?;\n         } else if self.table.tag() && remaining <= self.len() {\n             // Probe sequence is too long and table is half full,\n             // resize early to reduce probing length.\n             let new_capacity = self.table.capacity() * 2;\n-            self.resize(new_capacity);\n+            self.try_resize(new_capacity)?;\n         }\n+        Ok(())\n     }\n \n     /// Resizes the internal vectors to a new capacity. It's your\n@@ -795,15 +832,15 @@ impl<K, V, S> HashMap<K, V, S>\n     ///   2) Ensure `new_raw_cap` is a power of two or zero.\n     #[inline(never)]\n     #[cold]\n-    fn resize(&mut self, new_raw_cap: usize) {\n+    fn try_resize(&mut self, new_raw_cap: usize) -> Result<(), CollectionAllocErr> {\n         assert!(self.table.size() <= new_raw_cap);\n         assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n \n-        let mut old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n+        let mut old_table = replace(&mut self.table, RawTable::try_new(new_raw_cap)?);\n         let old_size = old_table.size();\n \n         if old_table.size() == 0 {\n-            return;\n+            return Ok(());\n         }\n \n         let mut bucket = Bucket::head_bucket(&mut old_table);\n@@ -838,6 +875,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n \n         assert_eq!(self.table.size(), old_size);\n+        Ok(())\n     }\n \n     /// Shrinks the capacity of the map as much as possible. It will drop\n@@ -2717,6 +2755,9 @@ mod test_map {\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n     use panic;\n+    use realstd::collections::CollectionAllocErr::*;\n+    use realstd::mem::size_of;\n+    use realstd::usize;\n \n     #[test]\n     fn test_zero_capacities() {\n@@ -3651,4 +3692,33 @@ mod test_map {\n         let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { hm.entry(0) <- makepanic(); }));\n         assert_eq!(hm.len(), 0);\n     }\n+\n+    #[test]\n+    fn test_try_reserve() {\n+\n+        let mut empty_bytes: HashMap<u8,u8> = HashMap::new();\n+\n+        const MAX_USIZE: usize = usize::MAX;\n+\n+        // HashMap and RawTables use complicated size calculations\n+        // hashes_size is sizeof(HashUint) * capacity;\n+        // pairs_size is sizeof((K. V)) * capacity;\n+        // alignment_hashes_size is 8\n+        // alignment_pairs size is 4\n+        let size_of_multiplier = (size_of::<usize>() + size_of::<(u8, u8)>()).next_power_of_two();\n+        // The following formula is used to calculate the new capacity\n+        let max_no_ovf = ((MAX_USIZE / 11) * 10) / size_of_multiplier - 1;\n+\n+        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+        } else { panic!(\"usize::MAX should trigger an overflow!\"); }\n+\n+        if size_of::<usize>() < 8 {\n+            if let Err(CapacityOverflow) = empty_bytes.try_reserve(max_no_ovf) {\n+            } else { panic!(\"isize::MAX + 1 should trigger a CapacityOverflow!\") }\n+        } else {\n+            if let Err(AllocErr(_)) = empty_bytes.try_reserve(max_no_ovf) {\n+            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+        }\n+    }\n+\n }"}, {"sha": "8e78dc546c6c7de108f26eb57a412fa1ce323669", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -17,6 +17,7 @@ use mem::{align_of, size_of, needs_drop};\n use mem;\n use ops::{Deref, DerefMut};\n use ptr::{self, Unique, NonNull};\n+use alloc::allocator::CollectionAllocErr;\n \n use self::BucketState::*;\n \n@@ -741,14 +742,15 @@ fn test_offset_calculation() {\n impl<K, V> RawTable<K, V> {\n     /// Does not initialize the buckets. The caller should ensure they,\n     /// at the very least, set every hash to EMPTY_BUCKET.\n-    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n+    /// Returns an error if it cannot allocate or capacity overflows.\n+    unsafe fn try_new_uninitialized(capacity: usize) -> Result<RawTable<K, V>, CollectionAllocErr> {\n         if capacity == 0 {\n-            return RawTable {\n+            return Ok(RawTable {\n                 size: 0,\n                 capacity_mask: capacity.wrapping_sub(1),\n                 hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n-            };\n+            });\n         }\n \n         // No need for `checked_mul` before a more restrictive check performed\n@@ -768,25 +770,38 @@ impl<K, V> RawTable<K, V> {\n                                                            align_of::<HashUint>(),\n                                                            pairs_size,\n                                                            align_of::<(K, V)>());\n-        assert!(!oflo, \"capacity overflow\");\n+        if oflo {\n+            return Err(CollectionAllocErr::CapacityOverflow);\n+        }\n \n         // One check for overflow that covers calculation and rounding of size.\n-        let size_of_bucket = size_of::<HashUint>().checked_add(size_of::<(K, V)>()).unwrap();\n-        assert!(size >=\n-                capacity.checked_mul(size_of_bucket)\n-                    .expect(\"capacity overflow\"),\n-                \"capacity overflow\");\n+        let size_of_bucket = size_of::<HashUint>().checked_add(size_of::<(K, V)>())\n+            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+        let capacity_mul_size_of_bucket = capacity.checked_mul(size_of_bucket);\n+        if capacity_mul_size_of_bucket.is_none() || size < capacity_mul_size_of_bucket.unwrap() {\n+            return Err(CollectionAllocErr::CapacityOverflow);\n+        }\n \n-        let buffer = Heap.alloc(Layout::from_size_align(size, alignment).unwrap())\n-            .unwrap_or_else(|e| Heap.oom(e));\n+        let buffer = Heap.alloc(Layout::from_size_align(size, alignment)\n+            .ok_or(CollectionAllocErr::CapacityOverflow)?)?;\n \n         let hashes = buffer as *mut HashUint;\n \n-        RawTable {\n+        Ok(RawTable {\n             capacity_mask: capacity.wrapping_sub(1),\n             size: 0,\n             hashes: TaggedHashUintPtr::new(hashes),\n             marker: marker::PhantomData,\n+        })\n+    }\n+\n+    /// Does not initialize the buckets. The caller should ensure they,\n+    /// at the very least, set every hash to EMPTY_BUCKET.\n+    unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n+        match Self::try_new_uninitialized(capacity) {\n+            Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Ok(table) => { table }\n         }\n     }\n \n@@ -809,13 +824,23 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n+    /// Tries to create a new raw table from a given capacity. If it cannot allocate,\n+    /// it returns with AllocErr.\n+    pub fn try_new(capacity: usize) -> Result<RawTable<K, V>, CollectionAllocErr> {\n+        unsafe {\n+            let ret = RawTable::try_new_uninitialized(capacity)?;\n+            ptr::write_bytes(ret.hashes.ptr(), 0, capacity);\n+            Ok(ret)\n+        }\n+    }\n+\n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n-        unsafe {\n-            let ret = RawTable::new_uninitialized(capacity);\n-            ptr::write_bytes(ret.hashes.ptr(), 0, capacity);\n-            ret\n+        match Self::try_new(capacity) {\n+            Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n+            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Ok(table) => { table }\n         }\n     }\n "}, {"sha": "be88f4e268aa0b0ffb6ecd1a43e59af60989d36f", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -438,6 +438,9 @@ pub use self::hash_set::HashSet;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc::range;\n \n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+pub use alloc::allocator::CollectionAllocErr;\n+\n mod hash;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ccc5373acc7ef4aae161ca5227a778c9b380be1c", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -314,6 +314,7 @@\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n #![feature(try_from)]\n+#![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(untagged_unions)]"}, {"sha": "9322dbd272f70c076565c4de14010ad6513c4151", "filename": "src/test/ui/feature-gate-try_reserve.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Ftest%2Fui%2Ffeature-gate-try_reserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Ftest%2Fui%2Ffeature-gate-try_reserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-try_reserve.rs?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = Vec::new();\n+    v.try_reserve(10); //~ ERROR: use of unstable library feature 'try_reserve'\n+}"}, {"sha": "b1fef61dd24595758405a139f1bb28708cafc0c5", "filename": "src/test/ui/feature-gate-try_reserve.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Ftest%2Fui%2Ffeature-gate-try_reserve.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92bfcd2b192e59d12d64acf6f46c1897a3273b3e/src%2Ftest%2Fui%2Ffeature-gate-try_reserve.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-try_reserve.stderr?ref=92bfcd2b192e59d12d64acf6f46c1897a3273b3e", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: use of unstable library feature 'try_reserve': new API (see issue #48043)\n+  --> $DIR/feature-gate-try_reserve.rs:13:7\n+   |\n+LL |     v.try_reserve(10); //~ ERROR: use of unstable library feature 'try_reserve'\n+   |       ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(try_reserve)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+If you want more information on this error, try using \"rustc --explain E0658\""}]}