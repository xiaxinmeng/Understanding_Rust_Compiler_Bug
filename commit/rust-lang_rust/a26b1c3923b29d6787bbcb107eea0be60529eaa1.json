{"sha": "a26b1c3923b29d6787bbcb107eea0be60529eaa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNmIxYzM5MjNiMjlkNjc4N2JiY2IxMDdlZWEwYmU2MDUyOWVhYTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-14T16:45:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-08-14T16:45:47Z"}, "message": "internal: remove old editing API", "tree": {"sha": "cb7ee528c28eef608515ee3dd441622af870e52a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb7ee528c28eef608515ee3dd441622af870e52a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a26b1c3923b29d6787bbcb107eea0be60529eaa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a26b1c3923b29d6787bbcb107eea0be60529eaa1", "html_url": "https://github.com/rust-lang/rust/commit/a26b1c3923b29d6787bbcb107eea0be60529eaa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a26b1c3923b29d6787bbcb107eea0be60529eaa1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a60e9106b8dcfae4caa4d8fdb62de078d3c12a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a60e9106b8dcfae4caa4d8fdb62de078d3c12a9", "html_url": "https://github.com/rust-lang/rust/commit/5a60e9106b8dcfae4caa4d8fdb62de078d3c12a9"}], "stats": {"total": 82, "additions": 36, "deletions": 46}, "files": [{"sha": "1ec0e0a5da397b3cd5e7f14caeae73b09c00b07c", "filename": "crates/ide_assists/src/handlers/convert_to_guarded_return.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a26b1c3923b29d6787bbcb107eea0be60529eaa1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26b1c3923b29d6787bbcb107eea0be60529eaa1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=a26b1c3923b29d6787bbcb107eea0be60529eaa1", "patch": "@@ -1,15 +1,14 @@\n-use std::{iter::once, ops::RangeInclusive};\n+use std::iter::once;\n \n use syntax::{\n-    algo::replace_children,\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n         make,\n     },\n-    AstNode,\n-    SyntaxKind::{FN, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n-    SyntaxNode,\n+    ted, AstNode,\n+    SyntaxKind::{FN, LOOP_EXPR, WHILE_EXPR, WHITESPACE},\n+    T,\n };\n \n use crate::{\n@@ -53,17 +52,16 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n         None => None, // No IfLet, supported.\n         Some(ast::Pat::TupleStructPat(pat)) if pat.fields().count() == 1 => {\n             let path = pat.path()?;\n-            match path.qualifier() {\n-                None => {\n-                    let bound_ident = pat.fields().next().unwrap();\n-                    if ast::IdentPat::can_cast(bound_ident.syntax().kind()) {\n-                        Some((path, bound_ident))\n-                    } else {\n-                        return None;\n-                    }\n-                }\n-                Some(_) => return None,\n+            if path.qualifier().is_some() {\n+                return None;\n+            }\n+\n+            let bound_ident = pat.fields().next().unwrap();\n+            if !ast::IdentPat::can_cast(bound_ident.syntax().kind()) {\n+                return None;\n             }\n+\n+            Some((path, bound_ident))\n         }\n         Some(_) => return None, // Unsupported IfLet.\n     };\n@@ -96,20 +94,21 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n         _ => return None,\n     };\n \n-    if then_block.syntax().first_child_or_token().map(|t| t.kind() == L_CURLY).is_none() {\n+    if then_block.syntax().first_child_or_token().map(|t| t.kind() == T!['{']).is_none() {\n         return None;\n     }\n \n-    then_block.syntax().last_child_or_token().filter(|t| t.kind() == R_CURLY)?;\n+    then_block.syntax().last_child_or_token().filter(|t| t.kind() == T!['}'])?;\n \n     let target = if_expr.syntax().text_range();\n     acc.add(\n         AssistId(\"convert_to_guarded_return\", AssistKind::RefactorRewrite),\n         \"Convert to guarded return\",\n         target,\n         |edit| {\n+            let if_expr = edit.make_mut(if_expr);\n             let if_indent_level = IndentLevel::from_node(if_expr.syntax());\n-            let new_block = match if_let_pat {\n+            let replacement = match if_let_pat {\n                 None => {\n                     // If.\n                     let new_expr = {\n@@ -119,7 +118,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                         make::expr_if(make::condition(cond, None), then_branch, None)\n                             .indent(if_indent_level)\n                     };\n-                    replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+                    new_expr.syntax().clone_for_update()\n                 }\n                 Some((path, bound_ident)) => {\n                     // If-let.\n@@ -148,41 +147,32 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n \n                     let let_stmt = make::let_stmt(bound_ident, None, Some(match_expr));\n                     let let_stmt = let_stmt.indent(if_indent_level);\n-                    replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n+                    let_stmt.syntax().clone_for_update()\n                 }\n             };\n-            edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-\n-            fn replace(\n-                new_expr: &SyntaxNode,\n-                then_block: &ast::BlockExpr,\n-                parent_block: &ast::BlockExpr,\n-                if_expr: &ast::IfExpr,\n-            ) -> SyntaxNode {\n-                let then_block_items = then_block.dedent(IndentLevel(1));\n-                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-                let end_of_then =\n-                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                        end_of_then.prev_sibling_or_token().unwrap()\n-                    } else {\n-                        end_of_then\n-                    };\n-                let mut then_statements = new_expr.children_with_tokens().chain(\n+\n+            let then_block_items = then_block.dedent(IndentLevel(1)).clone_for_update();\n+\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+\n+            let then_statements = replacement\n+                .children_with_tokens()\n+                .chain(\n                     then_block_items\n                         .syntax()\n                         .children_with_tokens()\n                         .skip(1)\n                         .take_while(|i| *i != end_of_then),\n-                );\n-                replace_children(\n-                    parent_block.syntax(),\n-                    RangeInclusive::new(\n-                        if_expr.clone().syntax().clone().into(),\n-                        if_expr.syntax().clone().into(),\n-                    ),\n-                    &mut then_statements,\n                 )\n-            }\n+                .collect();\n+\n+            ted::replace_with_many(if_expr.syntax(), then_statements)\n         },\n     )\n }"}]}