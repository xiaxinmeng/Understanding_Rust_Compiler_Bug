{"sha": "3bede9fd310540a0fd72371008f8aa606b23b11b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZWRlOWZkMzEwNTQwYTBmZDcyMzcxMDA4ZjhhYTYwNmIyM2IxMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-11T18:17:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-11T18:17:01Z"}, "message": "auto merge of #12780 : zslayton/rust/json-nav, r=alexcrichton\n\nThis is my first non-docs contribution to Rust, so please let me know what I can fix. I probably should've submitted this to the mailing list first for comments, but it didn't take too long to implement so I figured I'd just give it a shot.\r\n\r\nThese changes are modeled loosely on the [JsonNode API](http://jackson.codehaus.org/1.7.9/javadoc/org/codehaus/jackson/JsonNode.html) provided by the [Jackson JSON processor](http://jackson.codehaus.org/).\r\n\r\nMany common use cases for parsing JSON involve pulling one or more fields out of an object, however deeply nested. At present, this requires writing a pyramid of match statements. The added methods in this PR aim to make this a more painless process.\r\n\r\n**Edited to reflect final implementation**\r\n\r\nExample JSON:\r\n```json\r\n{\r\n    \"successful\" : true,\r\n    \"status\" : 200,\r\n    \"error\" : null,\r\n    \"content\" : {\r\n        \"vehicles\" : [\r\n            {\"make\" : \"Toyota\", \"model\" : \"Camry\", \"year\" : 1997},\r\n            {\"make\" : \"Honda\", \"model\" : \"Accord\", \"year\" : 2003}\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\nAccessing \"successful\":\r\n```rust\r\n let example_json : Json = from_str(\"...above json...\").unwrap();\r\n let was_successful: Option<bool> = example_json.find(&~\"successful\").and_then(|j| j.as_boolean());\r\n```\r\n\r\nAccessing \"status\":\r\n```rust\r\n let example_json : Json = from_str(\"...above json...\").unwrap();\r\n let status_code : Option<f64> = example_json.find(&~\"status\").and_then(|j| j.as_number());\r\n```\r\n\r\nAccessing \"vehicles\":\r\n```rust\r\n let example_json : Json = from_str(\"...above json...\").unwrap();\r\n let vehicle_list: Option<List> = example_json.search(&~\"vehicles\").and_then(|j| j.as_list());\r\n```\r\n\r\nAccessing \"vehicles\" with an explicit path:\r\n```rust\r\n let example_json : Json = from_str(\"...above json...\").unwrap();\r\n let vehicle_list: Option<List> = example_json.find_path(&[&~\"content\", &~\"vehicles\"]).and_then(|j| j.as_list());\r\n```\r\n\r\nAccessing \"error\", which might be null or a string:\r\n```rust\r\n let example_json : Json = from_str(\"...above json...\").unwrap();\r\n let error: Option<Json> = example_json.find(&~\"error\");\r\n if error.is_null() { // This would be nicer as a match, I'm just illustrating the boolean test methods\r\n    println!(\"Error is null, everything's fine.\");\r\n } else if error.is_str(){\r\n    println!(\"Something went wrong: {}\", error.as_string().unwrap());\r\n}\r\n```\r\n\r\nSome notes:\r\n* Macros would help to eliminate some of the repetitiveness of the implementation, but I couldn't use them due to #4621. (**Edit**: There is no longer repetitive impl. Methods were simplified to make them more composable.)\r\n* Would it be better to name methods after the Json enum type (e.g. `get_string`) or the associated Rust built-in? (e.g. `get_str`)\r\n* TreeMap requires its keys to be &~str. Because of this, all of the new methods required &~str for their parameters. I'm uncertain what the best approach to fixing this is: neither demanding an owned pointer nor allocating within the methods to appease TreeMap's find() seems desirable. If I were able to take &str, people could put together paths easily with `\"foo.bar.baz\".split('.').collect();` (**Edit**: Follow on investigation into making TreeMap able to search by Equiv would be worthwhile.)\r\n* At the moment, the `find_<sometype>` methods all find the first match for the provided key and attempt to return that value if it's of the specified type. This makes sense to me, but it's possible that users would interpret a call to `find_boolean(\"successful\")` as looking for the first \"successful\" item that was a boolean rather than looking for the first \"successful\" and returning None if it isn't boolean. (**Edit**: No longer relevant.)\r\n\r\nI hope this is helpful. Any feedback is appreciated!", "tree": {"sha": "85cdfdcedcae25fafb202474b104b3163d572582", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85cdfdcedcae25fafb202474b104b3163d572582"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bede9fd310540a0fd72371008f8aa606b23b11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bede9fd310540a0fd72371008f8aa606b23b11b", "html_url": "https://github.com/rust-lang/rust/commit/3bede9fd310540a0fd72371008f8aa606b23b11b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bede9fd310540a0fd72371008f8aa606b23b11b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f3ebd8fc50682d6e4ef549cb31e70171acdcd71", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3ebd8fc50682d6e4ef549cb31e70171acdcd71", "html_url": "https://github.com/rust-lang/rust/commit/9f3ebd8fc50682d6e4ef549cb31e70171acdcd71"}, {"sha": "9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108", "html_url": "https://github.com/rust-lang/rust/commit/9e0cfa23e8b3d2d17302eefd9d728e63e7c6c108"}], "stats": {"total": 247, "additions": 247, "deletions": 0}, "files": [{"sha": "c5d10d25838cede0a611bee63a6ac6289afa0629", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/3bede9fd310540a0fd72371008f8aa606b23b11b/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bede9fd310540a0fd72371008f8aa606b23b11b/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=3bede9fd310540a0fd72371008f8aa606b23b11b", "patch": "@@ -709,6 +709,148 @@ impl Json {\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n         str::from_utf8_owned(s.unwrap()).unwrap()\n     }\n+\n+     /// If the Json value is an Object, returns the value associated with the provided key.\n+    /// Otherwise, returns None.\n+    pub fn find<'a>(&'a self, key: &~str) -> Option<&'a Json>{\n+        match self {\n+            &Object(ref map) => map.find(key),\n+            _ => None\n+        }\n+    }\n+\n+    /// Attempts to get a nested Json Object for each key in `keys`.\n+    /// If any key is found not to exist, get_path will return None.\n+    /// Otherwise, it will return the Json value associated with the final key.\n+    pub fn find_path<'a>(&'a self, keys: &[&~str]) -> Option<&'a Json>{\n+        keys.iter().fold(Some(self), |target, key| target.map_or(None, |t| t.find(*key)))\n+    }\n+\n+    /// If the Json value is an Object, performs a depth-first search until\n+    /// a value associated with the provided key is found. If no value is found\n+    /// or the Json value is not an Object, returns None.\n+    pub fn search<'a>(&'a self, key: &~str) -> Option<&'a Json> {\n+        match self {\n+            &Object(ref map) => {\n+                match map.find(key) {\n+                    Some(json_value) => Some(json_value),\n+                    None => {\n+                        let mut value : Option<&'a Json> = None;\n+                        for (_, v) in map.iter() {\n+                            value = v.search(key);\n+                            if value.is_some() {\n+                                break;\n+                            }\n+                        }\n+                        value\n+                    }\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is an Object. Returns false otherwise.\n+    pub fn is_object<'a>(&'a self) -> bool {\n+        match self {\n+            &Object(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is an Object, returns the associated TreeMap.\n+    /// Returns None otherwise.\n+    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n+        match self {\n+            &Object(ref map) => Some(&**map),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a List. Returns false otherwise.\n+    pub fn is_list<'a>(&'a self) -> bool {\n+        match self {\n+            &List(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a List, returns the associated vector.\n+    /// Returns None otherwise.\n+    pub fn as_list<'a>(&'a self) -> Option<&'a List> {\n+        match self {\n+            &List(ref list) => Some(&*list),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a String. Returns false otherwise.\n+    pub fn is_str<'a>(&'a self) -> bool {\n+        match self {\n+            &String(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a String, returns the associated str.\n+    /// Returns None otherwise.\n+    pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n+        match *self {\n+            String(ref s) => Some(s.as_slice()),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Number. Returns false otherwise.\n+    pub fn is_number(&self) -> bool {\n+        match self {\n+            &Number(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a Number, returns the associated f64.\n+    /// Returns None otherwise.\n+    pub fn as_number(&self) -> Option<f64> {\n+        match self {\n+            &Number(n) => Some(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Boolean. Returns false otherwise.\n+    pub fn is_boolean(&self) -> bool {\n+        match self {\n+            &Boolean(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a Boolean, returns the associated bool.\n+    /// Returns None otherwise.\n+    pub fn as_boolean(&self) -> Option<bool> {\n+        match self {\n+            &Boolean(b) => Some(b),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Null. Returns false otherwise.\n+    pub fn is_null(&self) -> bool {\n+        match self {\n+            &Null => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// If the Json value is a Null, returns ().\n+    /// Returns None otherwise.\n+    pub fn as_null(&self) -> Option<()> {\n+        match self {\n+            &Null => Some(()),\n+            _ => None\n+        }\n+    }\n }\n \n pub struct Parser<T> {\n@@ -2283,4 +2425,109 @@ mod tests {\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n                                 \"unknown variant name\");\n     }\n+\n+    #[test]\n+    fn test_find(){\n+        let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n+        let found_str = json_value.find(&~\"dog\");\n+        assert!(found_str.is_some() && found_str.unwrap().as_str().unwrap() == &\"cat\");\n+    }\n+\n+    #[test]\n+    fn test_find_path(){\n+        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+        let found_str = json_value.find_path(&[&~\"dog\", &~\"cat\", &~\"mouse\"]);\n+        assert!(found_str.is_some() && found_str.unwrap().as_str().unwrap() == &\"cheese\");\n+    }\n+\n+    #[test]\n+    fn test_search(){\n+        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+        let found_str = json_value.search(&~\"mouse\").and_then(|j| j.as_str());\n+        assert!(found_str.is_some());\n+        assert!(found_str.unwrap() == &\"cheese\");\n+    }\n+\n+    #[test]\n+    fn test_is_object(){\n+        let json_value = from_str(\"{}\").unwrap();\n+        assert!(json_value.is_object());\n+    }\n+\n+    #[test]\n+    fn test_as_object(){\n+        let json_value = from_str(\"{}\").unwrap();\n+        let json_object = json_value.as_object();\n+        assert!(json_object.is_some());\n+    }\n+\n+    #[test]\n+    fn test_is_list(){\n+        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+        assert!(json_value.is_list());\n+    }\n+\n+    #[test]\n+    fn test_as_list(){\n+        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+        let json_list = json_value.as_list();\n+        let expected_length = 3;\n+        assert!(json_list.is_some() && json_list.unwrap().len() == expected_length);\n+    }\n+\n+    #[test]\n+    fn test_is_str(){\n+        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+        assert!(json_value.is_str());\n+    }\n+\n+    #[test]\n+    fn test_as_str(){\n+        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+        let json_str = json_value.as_str();\n+        let expected_str = &\"dog\";\n+        assert_eq!(json_str, Some(expected_str));\n+    }\n+\n+    #[test]\n+    fn test_is_number(){\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(json_value.is_number());\n+    }\n+\n+    #[test]\n+    fn test_as_number(){\n+        let json_value = from_str(\"12\").unwrap();\n+        let json_num = json_value.as_number();\n+        let expected_num = 12f64;\n+        assert!(json_num.is_some() && json_num.unwrap() == expected_num);\n+    }\n+\n+    #[test]\n+    fn test_is_boolean(){\n+        let json_value = from_str(\"false\").unwrap();\n+        assert!(json_value.is_boolean());\n+    }\n+\n+    #[test]\n+    fn test_as_boolean(){\n+        let json_value = from_str(\"false\").unwrap();\n+        let json_bool = json_value.as_boolean();\n+        let expected_bool = false;\n+        assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n+    }\n+\n+    #[test]\n+    fn test_is_null(){\n+        let json_value = from_str(\"null\").unwrap();\n+        assert!(json_value.is_null());\n+    }\n+\n+    #[test]\n+    fn test_as_null(){\n+        let json_value = from_str(\"null\").unwrap();\n+        let json_null = json_value.as_null();\n+        let expected_null = ();\n+        assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n+    }\n }"}]}