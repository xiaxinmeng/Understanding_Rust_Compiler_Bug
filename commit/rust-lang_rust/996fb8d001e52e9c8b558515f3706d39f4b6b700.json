{"sha": "996fb8d001e52e9c8b558515f3706d39f4b6b700", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NmZiOGQwMDFlNTJlOWM4YjU1ODUxNWYzNzA2ZDM5ZjRiNmI3MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-29T19:24:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-29T19:24:40Z"}, "message": "Auto merge of #25494 - alexcrichton:stdio-from-raw, r=aturon\n\nThis commit implements a number of standard traits for the standard library's\r\nprocess I/O handles. The `FromRaw{Fd,Handle}` traits are now implemented for the\r\n`Stdio` type and the `AsRaw{Fd,Handle}` traits are now implemented for the\r\n`Child{Stdout,Stdin,Stderr}` types.\r\n\r\nThe stability markers for these implementations mention that they are stable for\r\n1.1 as I will nominate this commit for cherry-picking to beta.", "tree": {"sha": "6427a548914b23cc143112e2cb007fb4d98f010f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6427a548914b23cc143112e2cb007fb4d98f010f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/996fb8d001e52e9c8b558515f3706d39f4b6b700", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/996fb8d001e52e9c8b558515f3706d39f4b6b700", "html_url": "https://github.com/rust-lang/rust/commit/996fb8d001e52e9c8b558515f3706d39f4b6b700", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/996fb8d001e52e9c8b558515f3706d39f4b6b700/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84254948c2e7eee3869e132453d7b870639890f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/84254948c2e7eee3869e132453d7b870639890f3", "html_url": "https://github.com/rust-lang/rust/commit/84254948c2e7eee3869e132453d7b870639890f3"}, {"sha": "3dd3450484c1a914d07da2ab522e3bd27ce2a4bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd3450484c1a914d07da2ab522e3bd27ce2a4bb", "html_url": "https://github.com/rust-lang/rust/commit/3dd3450484c1a914d07da2ab522e3bd27ce2a4bb"}], "stats": {"total": 302, "additions": 243, "deletions": 59}, "files": [{"sha": "42d9ad81b598aac8cdd23d6afd2cac1a75901b35", "filename": "src/libstd/process.rs", "status": "modified", "additions": 58, "deletions": 41, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -22,11 +22,8 @@ use io::{self, Error, ErrorKind};\n use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe::{self, AnonPipe};\n-use sys::process::Command as CommandImp;\n-use sys::process::Process as ProcessImp;\n-use sys::process::ExitStatus as ExitStatusImp;\n-use sys::process::Stdio as StdioImp2;\n-use sys_common::{AsInner, AsInnerMut};\n+use sys::process as imp;\n+use sys_common::{AsInner, AsInnerMut, FromInner};\n use thread;\n \n /// Representation of a running or exited child process.\n@@ -52,10 +49,10 @@ use thread;\n /// ```\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n-    handle: ProcessImp,\n+    handle: imp::Process,\n \n     /// None until wait() or wait_with_output() is called.\n-    status: Option<ExitStatusImp>,\n+    status: Option<imp::ExitStatus>,\n \n     /// The handle for writing to the child's stdin, if it has been captured\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n@@ -70,6 +67,10 @@ pub struct Child {\n     pub stderr: Option<ChildStderr>,\n }\n \n+impl AsInner<imp::Process> for Child {\n+    fn as_inner(&self) -> &imp::Process { &self.handle }\n+}\n+\n /// A handle to a child procesess's stdin\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n@@ -87,6 +88,10 @@ impl Write for ChildStdin {\n     }\n }\n \n+impl AsInner<AnonPipe> for ChildStdin {\n+    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+}\n+\n /// A handle to a child procesess's stdout\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n@@ -100,6 +105,10 @@ impl Read for ChildStdout {\n     }\n }\n \n+impl AsInner<AnonPipe> for ChildStdout {\n+    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+}\n+\n /// A handle to a child procesess's stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n@@ -113,6 +122,10 @@ impl Read for ChildStderr {\n     }\n }\n \n+impl AsInner<AnonPipe> for ChildStderr {\n+    fn as_inner(&self) -> &AnonPipe { &self.inner }\n+}\n+\n /// The `Command` type acts as a process builder, providing fine-grained control\n /// over how a new process should be spawned. A default configuration can be\n /// generated using `Command::new(program)`, where `program` gives a path to the\n@@ -131,12 +144,12 @@ impl Read for ChildStderr {\n /// ```\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Command {\n-    inner: CommandImp,\n+    inner: imp::Command,\n \n     // Details explained in the builder methods\n-    stdin: Option<StdioImp>,\n-    stdout: Option<StdioImp>,\n-    stderr: Option<StdioImp>,\n+    stdin: Option<Stdio>,\n+    stdout: Option<Stdio>,\n+    stderr: Option<Stdio>,\n }\n \n impl Command {\n@@ -153,7 +166,7 @@ impl Command {\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n         Command {\n-            inner: CommandImp::new(program.as_ref()),\n+            inner: imp::Command::new(program.as_ref()),\n             stdin: None,\n             stdout: None,\n             stderr: None,\n@@ -210,25 +223,26 @@ impl Command {\n     /// Configuration for the child process's stdin handle (file descriptor 0).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stdin = Some(cfg.0);\n+        self.stdin = Some(cfg);\n         self\n     }\n \n     /// Configuration for the child process's stdout handle (file descriptor 1).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stdout = Some(cfg.0);\n+        self.stdout = Some(cfg);\n         self\n     }\n \n     /// Configuration for the child process's stderr handle (file descriptor 2).\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n-        self.stderr = Some(cfg.0);\n+        self.stderr = Some(cfg);\n         self\n     }\n \n     fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> {\n+        let default_io = Stdio(default_io);\n         let (their_stdin, our_stdin) = try!(\n             setup_io(self.stdin.as_ref().unwrap_or(&default_io), true)\n         );\n@@ -239,7 +253,8 @@ impl Command {\n             setup_io(self.stderr.as_ref().unwrap_or(&default_io), false)\n         );\n \n-        match ProcessImp::spawn(&self.inner, their_stdin, their_stdout, their_stderr) {\n+        match imp::Process::spawn(&self.inner, their_stdin, their_stdout,\n+                                  their_stderr) {\n             Err(e) => Err(e),\n             Ok(handle) => Ok(Child {\n                 handle: handle,\n@@ -256,7 +271,7 @@ impl Command {\n     /// By default, stdin, stdout and stderr are inherited by the parent.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn spawn(&mut self) -> io::Result<Child> {\n-        self.spawn_inner(StdioImp::Inherit)\n+        self.spawn_inner(StdioImp::Raw(imp::Stdio::Inherit))\n     }\n \n     /// Executes the command as a child process, waiting for it to finish and\n@@ -279,7 +294,7 @@ impl Command {\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn output(&mut self) -> io::Result<Output> {\n-        self.spawn_inner(StdioImp::Piped).and_then(|p| p.wait_with_output())\n+        self.spawn_inner(StdioImp::MakePipe).and_then(|p| p.wait_with_output())\n     }\n \n     /// Executes a command as a child process, waiting for it to finish and\n@@ -318,29 +333,27 @@ impl fmt::Debug for Command {\n     }\n }\n \n-impl AsInner<CommandImp> for Command {\n-    fn as_inner(&self) -> &CommandImp { &self.inner }\n+impl AsInner<imp::Command> for Command {\n+    fn as_inner(&self) -> &imp::Command { &self.inner }\n }\n \n-impl AsInnerMut<CommandImp> for Command {\n-    fn as_inner_mut(&mut self) -> &mut CommandImp { &mut self.inner }\n+impl AsInnerMut<imp::Command> for Command {\n+    fn as_inner_mut(&mut self) -> &mut imp::Command { &mut self.inner }\n }\n \n-fn setup_io(io: &StdioImp, readable: bool)\n-            -> io::Result<(StdioImp2, Option<AnonPipe>)>\n+fn setup_io(io: &Stdio, readable: bool)\n+            -> io::Result<(imp::Stdio, Option<AnonPipe>)>\n {\n-    use self::StdioImp::*;\n-    Ok(match *io {\n-        Null => (StdioImp2::None, None),\n-        Inherit => (StdioImp2::Inherit, None),\n-        Piped => {\n+    Ok(match io.0 {\n+        StdioImp::MakePipe => {\n             let (reader, writer) = try!(pipe::anon_pipe());\n             if readable {\n-                (StdioImp2::Piped(reader), Some(writer))\n+                (imp::Stdio::Piped(reader), Some(writer))\n             } else {\n-                (StdioImp2::Piped(writer), Some(reader))\n+                (imp::Stdio::Piped(writer), Some(reader))\n             }\n         }\n+        StdioImp::Raw(ref raw) => (raw.clone_if_copy(), None),\n     })\n }\n \n@@ -364,32 +377,36 @@ pub struct Output {\n pub struct Stdio(StdioImp);\n \n // The internal enum for stdio setup; see below for descriptions.\n-#[derive(Clone)]\n enum StdioImp {\n-    Piped,\n-    Inherit,\n-    Null,\n+    MakePipe,\n+    Raw(imp::Stdio),\n }\n \n impl Stdio {\n     /// A new pipe should be arranged to connect the parent and child processes.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn piped() -> Stdio { Stdio(StdioImp::Piped) }\n+    pub fn piped() -> Stdio { Stdio(StdioImp::MakePipe) }\n \n     /// The child inherits from the corresponding parent descriptor.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn inherit() -> Stdio { Stdio(StdioImp::Inherit) }\n+    pub fn inherit() -> Stdio { Stdio(StdioImp::Raw(imp::Stdio::Inherit)) }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n     /// stream to `/dev/null`\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn null() -> Stdio { Stdio(StdioImp::Null) }\n+    pub fn null() -> Stdio { Stdio(StdioImp::Raw(imp::Stdio::None)) }\n+}\n+\n+impl FromInner<imp::Stdio> for Stdio {\n+    fn from_inner(inner: imp::Stdio) -> Stdio {\n+        Stdio(StdioImp::Raw(inner))\n+    }\n }\n \n /// Describes the result of a process after it has terminated.\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n-pub struct ExitStatus(ExitStatusImp);\n+pub struct ExitStatus(imp::ExitStatus);\n \n impl ExitStatus {\n     /// Was termination successful? Signal termination not considered a success,\n@@ -410,8 +427,8 @@ impl ExitStatus {\n     }\n }\n \n-impl AsInner<ExitStatusImp> for ExitStatus {\n-    fn as_inner(&self) -> &ExitStatusImp { &self.0 }\n+impl AsInner<imp::ExitStatus> for ExitStatus {\n+    fn as_inner(&self) -> &imp::ExitStatus { &self.0 }\n }\n \n #[stable(feature = \"process\", since = \"1.0.0\")]"}, {"sha": "2d30b016a2d2098ae4b1e813a96da76c209b132c", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -13,10 +13,11 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use os::unix::raw::{uid_t, gid_t};\n+use os::unix::io::{FromRawFd, RawFd, AsRawFd};\n use prelude::v1::*;\n use process;\n use sys;\n-use sys_common::{AsInnerMut, AsInner};\n+use sys_common::{AsInnerMut, AsInner, FromInner};\n \n /// Unix-specific extensions to the `std::process::Command` builder\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -63,3 +64,49 @@ impl ExitStatusExt for process::ExitStatus {\n         }\n     }\n }\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for process::Stdio {\n+    /// Creates a new instance of `Stdio` from the raw underlying file\n+    /// descriptor.\n+    ///\n+    /// When this `Stdio` is used as an I/O handle for a child process the given\n+    /// file descriptor will be `dup`d into the destination file descriptor in\n+    /// the child process.\n+    ///\n+    /// Note that this function **does not** take ownership of the file\n+    /// descriptor provided and it will **not** be closed when `Stdio` goes out\n+    /// of scope. As a result this method is unsafe because due to the lack of\n+    /// knowledge about the lifetime of the provided file descriptor, this could\n+    /// cause another I/O primitive's ownership property of its file descriptor\n+    /// to be violated.\n+    ///\n+    /// Also note that this file descriptor may be used multiple times to spawn\n+    /// processes. For example the `Command::spawn` function could be called\n+    /// more than once to spawn more than one process sharing this file\n+    /// descriptor.\n+    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n+        process::Stdio::from_inner(sys::process::Stdio::Fd(fd))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawFd for process::ChildStdin {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawFd for process::ChildStdout {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawFd for process::ChildStderr {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().raw()\n+    }\n+}"}, {"sha": "6283a29ae4625bc0071ed4cc722284b2f4b57986", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -44,7 +44,6 @@ impl AnonPipe {\n         self.0.write(buf)\n     }\n \n-    pub fn into_fd(self) -> FileDesc {\n-        self.0\n-    }\n+    pub fn fd(&self) -> &FileDesc { &self.0 }\n+    pub fn into_fd(self) -> FileDesc { self.0 }\n }"}, {"sha": "76af42d9348dea3c4319c487ba584c67c26d3b98", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -123,6 +123,7 @@ pub enum Stdio {\n     Inherit,\n     Piped(AnonPipe),\n     None,\n+    Fd(c_int),\n }\n \n const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n@@ -253,6 +254,7 @@ impl Process {\n         let setup = |src: Stdio, dst: c_int| {\n             let fd = match src {\n                 Stdio::Inherit => return true,\n+                Stdio::Fd(fd) => return cvt_r(|| libc::dup2(fd, dst)).is_ok(),\n                 Stdio::Piped(pipe) => pipe.into_fd(),\n \n                 // If a stdio file descriptor is set to be ignored, we open up\n@@ -416,3 +418,14 @@ fn translate_status(status: c_int) -> ExitStatus {\n         ExitStatus::Signal(imp::WTERMSIG(status))\n     }\n }\n+\n+impl Stdio {\n+    pub fn clone_if_copy(&self) -> Stdio {\n+        match *self {\n+            Stdio::Inherit => Stdio::Inherit,\n+            Stdio::None => Stdio::None,\n+            Stdio::Fd(fd) => Stdio::Fd(fd),\n+            Stdio::Piped(_) => unreachable!(),\n+        }\n+    }\n+}"}, {"sha": "ead533e775968a0f5f5932754e7e3f5de5d5f13b", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -20,6 +20,7 @@ pub mod ffi;\n pub mod fs;\n pub mod io;\n pub mod raw;\n+pub mod process;\n \n /// A prelude for conveniently writing platform-specific code.\n ///"}, {"sha": "0fd43a450f330dc24f272786f241a1dc542a2384", "filename": "src/libstd/sys/windows/ext/process.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Extensions to `std::process` for Windows.\n+\n+#![stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+\n+use os::windows::io::{FromRawHandle, RawHandle, AsRawHandle};\n+use process;\n+use sys;\n+use sys_common::{AsInner, FromInner};\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawHandle for process::Stdio {\n+    /// Creates a new instance of `Stdio` from the raw underlying handle.\n+    ///\n+    /// When this `Stdio` is used as an I/O handle for a child process the given\n+    /// handle will be duplicated via `DuplicateHandle` to ensure that the\n+    /// handle has the correct permissions to cross the process boundary.\n+    ///\n+    /// Note that this function **does not** take ownership of the handle\n+    /// provided and it will **not** be closed when `Stdio` goes out of scope.\n+    /// As a result this method is unsafe because due to the lack of knowledge\n+    /// about the lifetime of the provided handle, this could cause another I/O\n+    /// primitive's ownership property of its handle to be violated.\n+    ///\n+    /// Also note that this handle may be used multiple times to spawn\n+    /// processes. For example the `Command::spawn` function could be called\n+    /// more than once to spawn more than one process sharing this handle.\n+    unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio {\n+        let handle = sys::handle::RawHandle::new(handle as *mut _);\n+        process::Stdio::from_inner(sys::process::Stdio::Handle(handle))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawHandle for process::Child {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().handle().raw() as *mut _\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawHandle for process::ChildStdin {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().handle().raw() as *mut _\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawHandle for process::ChildStdout {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().handle().raw() as *mut _\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl AsRawHandle for process::ChildStderr {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().handle().raw() as *mut _\n+    }\n+}"}, {"sha": "a566c5eff324e04ad6cb4a477dc7ceb6421ca9b9", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -15,26 +15,55 @@ use io;\n use libc::funcs::extra::kernel32::{GetCurrentProcess, DuplicateHandle};\n use libc::{self, HANDLE};\n use mem;\n+use ops::Deref;\n use ptr;\n use sys::cvt;\n \n-pub struct Handle(HANDLE);\n+/// An owned container for `HANDLE` object, closing them on Drop.\n+///\n+/// All methods are inherited through a `Deref` impl to `RawHandle`\n+pub struct Handle(RawHandle);\n \n-unsafe impl Send for Handle {}\n-unsafe impl Sync for Handle {}\n+/// A wrapper type for `HANDLE` objects to give them proper Send/Sync inference\n+/// as well as Rust-y methods.\n+///\n+/// This does **not** drop the handle when it goes out of scope, use `Handle`\n+/// instead for that.\n+#[derive(Copy, Clone)]\n+pub struct RawHandle(HANDLE);\n+\n+unsafe impl Send for RawHandle {}\n+unsafe impl Sync for RawHandle {}\n \n impl Handle {\n     pub fn new(handle: HANDLE) -> Handle {\n-        Handle(handle)\n+        Handle(RawHandle::new(handle))\n     }\n \n-    pub fn raw(&self) -> HANDLE { self.0 }\n-\n     pub fn into_raw(self) -> HANDLE {\n-        let ret = self.0;\n+        let ret = self.raw();\n         mem::forget(self);\n         return ret;\n     }\n+}\n+\n+impl Deref for Handle {\n+    type Target = RawHandle;\n+    fn deref(&self) -> &RawHandle { &self.0 }\n+}\n+\n+impl Drop for Handle {\n+    fn drop(&mut self) {\n+        unsafe { let _ = libc::CloseHandle(self.raw()); }\n+    }\n+}\n+\n+impl RawHandle {\n+    pub fn new(handle: HANDLE) -> RawHandle {\n+        RawHandle(handle)\n+    }\n+\n+    pub fn raw(&self) -> HANDLE { self.0 }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n@@ -79,9 +108,3 @@ impl Handle {\n         Ok(Handle::new(ret))\n     }\n }\n-\n-impl Drop for Handle {\n-    fn drop(&mut self) {\n-        unsafe { let _ = libc::CloseHandle(self.0); }\n-    }\n-}"}, {"sha": "05073e60f5d268f7f48919d07341ff84cc5dd8c9", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/996fb8d001e52e9c8b558515f3706d39f4b6b700/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=996fb8d001e52e9c8b558515f3706d39f4b6b700", "patch": "@@ -27,7 +27,7 @@ use ptr;\n use sync::StaticMutex;\n use sys::c;\n use sys::fs::{OpenOptions, File};\n-use sys::handle::Handle;\n+use sys::handle::{Handle, RawHandle};\n use sys::pipe::AnonPipe;\n use sys::stdio;\n use sys::{self, cvt};\n@@ -109,6 +109,7 @@ pub enum Stdio {\n     Inherit,\n     Piped(AnonPipe),\n     None,\n+    Handle(RawHandle),\n }\n \n impl Process {\n@@ -217,6 +218,8 @@ impl Process {\n             }\n         }\n     }\n+\n+    pub fn handle(&self) -> &Handle { &self.handle }\n }\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n@@ -353,6 +356,15 @@ fn make_dirp(d: Option<&OsString>) -> (*const u16, Vec<u16>) {\n }\n \n impl Stdio {\n+    pub fn clone_if_copy(&self) -> Stdio {\n+        match *self {\n+            Stdio::Inherit => Stdio::Inherit,\n+            Stdio::None => Stdio::None,\n+            Stdio::Handle(handle) => Stdio::Handle(handle),\n+            Stdio::Piped(_) => unreachable!(),\n+        }\n+    }\n+\n     fn to_handle(&self, stdio_id: libc::DWORD) -> io::Result<Handle> {\n         use libc::DUPLICATE_SAME_ACCESS;\n \n@@ -362,6 +374,9 @@ impl Stdio {\n                     io.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n                 })\n             }\n+            Stdio::Handle(ref handle) => {\n+                handle.duplicate(0, true, DUPLICATE_SAME_ACCESS)\n+            }\n             Stdio::Piped(ref pipe) => {\n                 pipe.handle().duplicate(0, true, DUPLICATE_SAME_ACCESS)\n             }"}]}