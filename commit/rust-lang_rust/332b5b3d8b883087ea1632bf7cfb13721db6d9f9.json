{"sha": "332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "node_id": "C_kwDOAAsO6NoAKDMzMmI1YjNkOGI4ODMwODdlYTE2MzJiZjdjZmIxMzcyMWRiNmQ5Zjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T05:56:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T05:56:19Z"}, "message": "Auto merge of #9566 - smoelius:diagnostic-item-path, r=dswij\n\nExpand internal lint `unnecessary_def_path`\n\nThis PR does essentially two things:\n* Separates the internal lints into modules by pass. (`internal_lints.rs` was over 1400 lines, which is a little unruly IMHO.)\n* ~Adds a new~ Expands the `unnecessary_def_path` internal lint to flag hardcoded paths to diagnostic and language items.\n\nMy understanding is that the latter is currently done by reviewers. Automating this process should make things easier for both reviewers and contributors.\n\nI could make the first bullet a separate PR, or remove it entirely, if desired.\n\nchangelog: Add internal lint `diagnostic_item_path`", "tree": {"sha": "8b63a9ba51aeaf30143f7d8f4f47fcdfbe53e9a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b63a9ba51aeaf30143f7d8f4f47fcdfbe53e9a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "html_url": "https://github.com/rust-lang/rust/commit/332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba5ff9d054cff5c1fbdccc72ea5e25d3ba33b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba5ff9d054cff5c1fbdccc72ea5e25d3ba33b76", "html_url": "https://github.com/rust-lang/rust/commit/eba5ff9d054cff5c1fbdccc72ea5e25d3ba33b76"}, {"sha": "5dc54c60660b2e37c2978c38df9298edcc2988f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dc54c60660b2e37c2978c38df9298edcc2988f2", "html_url": "https://github.com/rust-lang/rust/commit/5dc54c60660b2e37c2978c38df9298edcc2988f2"}], "stats": {"total": 3734, "additions": 1996, "deletions": 1738}, "files": [{"sha": "08164c0b654e2a0daa18737dfc44e0134603dca0", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::eq_expr_value;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{eq_expr_value, get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -483,7 +483,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n \n fn implements_ord<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    cx.tcx\n+        .get_diagnostic_item(sym::Ord)\n+        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n \n struct NotSimplificationVisitor<'a, 'tcx> {"}, {"sha": "0fe973b49a3550235520ab0f87a55139f46fd18f", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, if_sequence, in_constant, is_else_clause, paths, SpanlessEq};\n+use clippy_utils::{if_sequence, in_constant, is_else_clause, SpanlessEq};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -106,7 +107,10 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n \n                 // Check that the type being compared implements `core::cmp::Ord`\n                 let ty = cx.typeck_results().expr_ty(lhs1);\n-                let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));\n+                let is_ord = cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::Ord)\n+                    .map_or(false, |id| implements_trait(cx, ty, id, &[]));\n \n                 if !is_ord {\n                     return;"}, {"sha": "3064b6c9d22f808f6593660db86a0f6adf589e2f", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -7,14 +7,14 @@ use rustc_middle::{\n     lint::in_external_macro,\n     ty::{self, Ty},\n };\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, Span, Symbol};\n \n use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n use clippy_utils::visitors::for_each_expr;\n-use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n+use clippy_utils::{return_ty, trait_ref_of_method};\n \n use core::ops::ControlFlow;\n \n@@ -181,15 +181,17 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet)\n     }\n }\n \n-static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+static KNOWN_WRAPPER_TYS: &[Symbol] = &[sym::Rc, sym::Arc];\n \n fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut DefIdSet) -> bool {\n     match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n             tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did(), path))\n+                || KNOWN_WRAPPER_TYS\n+                    .iter()\n+                    .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),"}, {"sha": "b7798b1c1d749ae488a6ed08fee2824f7ca9999f", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::{is_must_use_ty, match_type};\n+use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item, match_type};\n use clippy_utils::{is_must_use_func_call, paths};\n use if_chain::if_chain;\n use rustc_hir::{Local, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -99,10 +100,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_DROP]);\n \n-const SYNC_GUARD_PATHS: [&[&str]; 6] = [\n-    &paths::MUTEX_GUARD,\n-    &paths::RWLOCK_READ_GUARD,\n-    &paths::RWLOCK_WRITE_GUARD,\n+const SYNC_GUARD_SYMS: [Symbol; 3] = [sym::MutexGuard, sym::RwLockReadGuard, sym::RwLockWriteGuard];\n+\n+const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n     &paths::PARKING_LOT_MUTEX_GUARD,\n     &paths::PARKING_LOT_RWLOCK_READ_GUARD,\n     &paths::PARKING_LOT_RWLOCK_WRITE_GUARD,\n@@ -121,7 +121,10 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 let init_ty = cx.typeck_results().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n-                        SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n+                        SYNC_GUARD_SYMS\n+                            .iter()\n+                            .any(|&sym| is_type_diagnostic_item(cx, inner_ty, sym))\n+                            || SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n                     },\n \n                     GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n@@ -134,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"non-binding let on a synchronization lock\",\n                         None,\n                         \"consider using an underscore-prefixed named \\\n-                            binding or dropping explicitly with `std::mem::drop`\"\n+                            binding or dropping explicitly with `std::mem::drop`\",\n                     );\n                 } else if init_ty.needs_drop(cx.tcx, cx.param_env) {\n                     span_lint_and_help(\n@@ -144,7 +147,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"non-binding `let` on a type that implements `Drop`\",\n                         None,\n                         \"consider using an underscore-prefixed named \\\n-                            binding or dropping explicitly with `std::mem::drop`\"\n+                            binding or dropping explicitly with `std::mem::drop`\",\n                     );\n                 } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n                     span_lint_and_help(\n@@ -153,7 +156,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         local.span,\n                         \"non-binding let on an expression with `#[must_use]` type\",\n                         None,\n-                        \"consider explicitly using expression value\"\n+                        \"consider explicitly using expression value\",\n                     );\n                 } else if is_must_use_func_call(cx, init) {\n                     span_lint_and_help(\n@@ -162,7 +165,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         local.span,\n                         \"non-binding let on a result of a `#[must_use]` function\",\n                         None,\n-                        \"consider explicitly using function result\"\n+                        \"consider explicitly using function result\",\n                     );\n                 }\n             }"}, {"sha": "40c94c6e8d33dc8101986d7ba7251433288adaa5", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -3,20 +3,20 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n-    LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n-    LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n-    LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n-    LintId::of(utils::internal_lints::DEFAULT_DEPRECATION_REASON),\n-    LintId::of(utils::internal_lints::DEFAULT_LINT),\n-    LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n-    LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n-    LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::INVALID_PATHS),\n-    LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n-    LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n-    LintId::of(utils::internal_lints::PRODUCE_ICE),\n-    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n-    LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n+    LintId::of(utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL),\n+    LintId::of(utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS),\n+    LintId::of(utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS),\n+    LintId::of(utils::internal_lints::if_chain_style::IF_CHAIN_STYLE),\n+    LintId::of(utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL),\n+    LintId::of(utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR),\n+    LintId::of(utils::internal_lints::invalid_paths::INVALID_PATHS),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL),\n+    LintId::of(utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA),\n+    LintId::of(utils::internal_lints::produce_ice::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH),\n ])"}, {"sha": "5609a4dc9ea074857530c7f923cee627f3ccbbe6", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -4,37 +4,37 @@\n \n store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n+    utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n+    utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n+    utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::DEFAULT_DEPRECATION_REASON,\n+    utils::internal_lints::if_chain_style::IF_CHAIN_STYLE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::DEFAULT_LINT,\n+    utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::IF_CHAIN_STYLE,\n+    utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n+    utils::internal_lints::invalid_paths::INVALID_PATHS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INVALID_PATHS,\n+    utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+    utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n+    utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n+    utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::PRODUCE_ICE,\n+    utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    utils::internal_lints::produce_ice::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n+    utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,"}, {"sha": "893410dbfdc984817292c9d9bf5b6bea24140dc5", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -528,17 +528,23 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     // all the internal lints\n     #[cfg(feature = \"internal\")]\n     {\n-        store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n-        store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::CollapsibleCalls));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::IfChainStyle));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n-        store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n-        store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::clippy_lints_internal::ClippyLintsInternal));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::produce_ice::ProduceIce));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::collapsible_calls::CollapsibleCalls));\n+        store.register_late_pass(|_| {\n+            Box::new(utils::internal_lints::compiler_lint_functions::CompilerLintFunctions::new())\n+        });\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::if_chain_style::IfChainStyle));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::invalid_paths::InvalidPaths));\n+        store.register_late_pass(|_| {\n+            Box::<utils::internal_lints::interning_defined_symbol::InterningDefinedSymbol>::default()\n+        });\n+        store.register_late_pass(|_| {\n+            Box::<utils::internal_lints::lint_without_lint_pass::LintWithoutLintPass>::default()\n+        });\n+        store.register_late_pass(|_| Box::<utils::internal_lints::unnecessary_def_path::UnnecessaryDefPath>::default());\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::outer_expn_data_pass::OuterExpnDataPass));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::msrv_attr_impl::MsrvAttrImpl));\n     }\n \n     let arithmetic_side_effects_allowed = conf.arithmetic_side_effects_allowed.clone();"}, {"sha": "27ba27202bf7e8b6ec2c764d51c133c434d6593a", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n+use clippy_utils::{contains_name, higher, is_integer_const, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -263,7 +263,8 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx\n+                        let extent = self\n+                            .cx\n                             .tcx\n                             .region_scope_tree(parent_def_id)\n                             .var_scope(hir_id.local_id)\n@@ -274,11 +275,12 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                                 (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n                         } else {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                            self.indexed_indirectly\n+                                .insert(seqvar.segments[0].ident.name, Some(extent));\n                         }\n-                        return false;  // no need to walk further *on the variable*\n-                    }\n-                    Res::Def(DefKind::Static (_)| DefKind::Const, ..) => {\n+                        return false; // no need to walk further *on the variable*\n+                    },\n+                    Res::Def(DefKind::Static(_) | DefKind::Const, ..) => {\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n@@ -287,8 +289,8 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                         } else {\n                             self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n-                        return false;  // no need to walk further *on the variable*\n-                    }\n+                        return false; // no need to walk further *on the variable*\n+                    },\n                     _ => (),\n                 }\n             }\n@@ -302,17 +304,26 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // a range index op\n             if let ExprKind::MethodCall(meth, args_0, [args_1, ..], _) = &expr.kind;\n-            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n-                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if let Some(trait_id) = self\n+                .cx\n+                .typeck_results()\n+                .type_dependent_def_id(expr.hir_id)\n+                .and_then(|def_id| self.cx.tcx.trait_of_item(def_id));\n+            if (meth.ident.name == sym::index && self.cx.tcx.lang_items().index_trait() == Some(trait_id))\n+                || (meth.ident.name == sym::index_mut && self.cx.tcx.lang_items().index_mut_trait() == Some(trait_id));\n             if !self.check(args_1, args_0, expr);\n-            then { return }\n+            then {\n+                return;\n+            }\n         }\n \n         if_chain! {\n             // an index op\n             if let ExprKind::Index(seqexpr, idx) = expr.kind;\n             if !self.check(idx, seqexpr, expr);\n-            then { return }\n+            then {\n+                return;\n+            }\n         }\n \n         if_chain! {"}, {"sha": "090f9f8ff73cfd40e9825954d4b5c163ae6a6ccc", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::match_function_call;\n-use clippy_utils::paths::FUTURE_FROM_GENERATOR;\n+use clippy_utils::match_function_call_with_def_id;\n use clippy_utils::source::{position_before_rarrow, snippet_block, snippet_opt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -140,9 +139,9 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n         if args.bindings.len() == 1;\n         let binding = &args.bindings[0];\n         if binding.ident.name == sym::Output;\n-        if let TypeBindingKind::Equality{term: Term::Ty(output)} = binding.kind;\n+        if let TypeBindingKind::Equality { term: Term::Ty(output) } = binding.kind;\n         then {\n-            return Some(output)\n+            return Some(output);\n         }\n     }\n \n@@ -175,9 +174,16 @@ fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName])\n fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n     if_chain! {\n         if let Some(block_expr) = block.expr;\n-        if let Some(args) = match_function_call(cx, block_expr, &FUTURE_FROM_GENERATOR);\n+        if let Some(args) = cx\n+            .tcx\n+            .lang_items()\n+            .from_generator_fn()\n+            .and_then(|def_id| match_function_call_with_def_id(cx, block_expr, def_id));\n         if args.len() == 1;\n-        if let Expr{kind: ExprKind::Closure(&Closure { body, .. }), ..} = args[0];\n+        if let Expr {\n+            kind: ExprKind::Closure(&Closure { body, .. }),\n+            ..\n+        } = args[0];\n         let closure_body = cx.tcx.hir().body(body);\n         if closure_body.generator_kind == Some(GeneratorKind::Async(AsyncGeneratorKind::Block));\n         then {"}, {"sha": "02dc8755dd61c9e86f23bbe209066680d964d5f0", "filename": "clippy_lints/src/manual_clamp.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_clamp.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -12,9 +12,9 @@ use std::ops::Deref;\n \n use clippy_utils::{\n     diagnostics::{span_lint_and_then, span_lint_hir_and_then},\n-    eq_expr_value, get_trait_def_id,\n+    eq_expr_value,\n     higher::If,\n-    is_diag_trait_item, is_trait_method, meets_msrv, msrvs, path_res, path_to_local_id, paths, peel_blocks,\n+    is_diag_trait_item, is_trait_method, meets_msrv, msrvs, path_res, path_to_local_id, peel_blocks,\n     peel_blocks_with_stmt,\n     sugg::Sugg,\n     ty::implements_trait,\n@@ -190,7 +190,11 @@ impl TypeClampability {\n     fn is_clampable<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<TypeClampability> {\n         if ty.is_floating_point() {\n             Some(TypeClampability::Float)\n-        } else if get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+        } else if cx\n+            .tcx\n+            .get_diagnostic_item(sym::Ord)\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+        {\n             Some(TypeClampability::Ord)\n         } else {\n             None"}, {"sha": "e5a15b2e1a1d2b454a8a5f488f6dfa1f7aa654fb", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{expr_block, snippet};\n-use clippy_utils::ty::{implements_trait, match_type, peel_mid_ty_refs};\n-use clippy_utils::{\n-    is_lint_allowed, is_unit_expr, is_wild, paths, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs,\n-};\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, peel_mid_ty_refs};\n+use clippy_utils::{is_lint_allowed, is_unit_expr, is_wild, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs};\n use core::cmp::max;\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n \n use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n \n@@ -156,10 +155,10 @@ fn pat_in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'a>, pat: &Pat<'_>) ->\n /// Returns `true` if the given type is an enum we know won't be expanded in the future\n fn in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'_>) -> bool {\n     // list of candidate `Enum`s we know will never get any more members\n-    let candidates = [&paths::COW, &paths::OPTION, &paths::RESULT];\n+    let candidates = [sym::Cow, sym::Option, sym::Result];\n \n     for candidate_ty in candidates {\n-        if match_type(cx, ty, candidate_ty) {\n+        if is_type_diagnostic_item(cx, ty, candidate_ty) {\n             return true;\n         }\n     }"}, {"sha": "fb92779be2a7a54b9e58dd83bacb4d5416d40016", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -102,9 +102,7 @@ use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{\n-    contains_return, get_trait_def_id, is_trait_method, iter_input_pats, meets_msrv, msrvs, paths, return_ty,\n-};\n+use clippy_utils::{contains_return, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -3372,15 +3370,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             then {\n                 let first_arg_span = first_arg_ty.span;\n                 let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty().skip_binder();\n+                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+                    .self_ty()\n+                    .skip_binder();\n                 wrong_self_convention::check(\n                     cx,\n                     item.ident.name.as_str(),\n                     self_ty,\n                     first_arg_ty,\n                     first_arg_span,\n                     false,\n-                    true\n+                    true,\n                 );\n             }\n         }\n@@ -3389,7 +3389,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n-            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty().skip_binder();\n+            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+                .self_ty()\n+                .skip_binder();\n             if !ret_ty.contains(self_ty);\n \n             then {\n@@ -3846,12 +3848,12 @@ impl SelfKind {\n                 return m == mutability && t == parent_ty;\n             }\n \n-            let trait_path = match mutability {\n-                hir::Mutability::Not => &paths::ASREF_TRAIT,\n-                hir::Mutability::Mut => &paths::ASMUT_TRAIT,\n+            let trait_sym = match mutability {\n+                hir::Mutability::Not => sym::AsRef,\n+                hir::Mutability::Mut => sym::AsMut,\n             };\n \n-            let Some(trait_def_id) = get_trait_def_id(cx, trait_path) else {\n+            let Some(trait_def_id) = cx.tcx.get_diagnostic_item(trait_sym) else {\n                 return false\n             };\n             implements_trait(cx, ty, trait_def_id, &[parent_ty.into()])"}, {"sha": "742483e6b2e5545274adf08081f1db58953eb8c5", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -32,8 +32,7 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let deref_aliases: [&[&str]; 9] = [\n-        &paths::DEREF_TRAIT_METHOD,\n+    let deref_aliases: [&[&str]; 8] = [\n         &paths::DEREF_MUT_TRAIT_METHOD,\n         &paths::CSTRING_AS_C_STR,\n         &paths::OS_STRING_AS_OS_STR,\n@@ -45,12 +44,14 @@ pub(super) fn check<'tcx>(\n     ];\n \n     let is_deref = match map_arg.kind {\n-        hir::ExprKind::Path(ref expr_qpath) => cx\n-            .qpath_res(expr_qpath, map_arg.hir_id)\n-            .opt_def_id()\n-            .map_or(false, |fun_def_id| {\n-                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n-            }),\n+        hir::ExprKind::Path(ref expr_qpath) => {\n+            cx.qpath_res(expr_qpath, map_arg.hir_id)\n+                .opt_def_id()\n+                .map_or(false, |fun_def_id| {\n+                    cx.tcx.is_diagnostic_item(sym::deref_method, fun_def_id)\n+                        || deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+                })\n+        },\n         hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n             let closure_body = cx.tcx.hir().body(body);\n             let closure_expr = peel_blocks(closure_body.value);\n@@ -68,7 +69,8 @@ pub(super) fn check<'tcx>(\n                         if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n                         then {\n                             let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n-                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n+                            cx.tcx.is_diagnostic_item(sym::deref_method, method_did)\n+                                || deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n                         } else {\n                             false\n                         }"}, {"sha": "991d3dd538bf86a7ea572c011cd419fb1aa22999", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,14 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::eager_or_lazy::switch_to_lazy_eval;\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::ty::{implements_trait, match_type};\n-use clippy_utils::{contains_return, is_trait_item, last_path_segment, paths};\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::{contains_return, is_trait_item, last_path_segment};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use std::borrow::Cow;\n \n use super::OR_FUN_CALL;\n@@ -88,11 +88,11 @@ pub(super) fn check<'tcx>(\n         fun_span: Option<Span>,\n     ) {\n         // (path, fn_has_argument, methods, suffix)\n-        const KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n-            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        const KNOW_TYPES: [(Symbol, bool, &[&str], &str); 4] = [\n+            (sym::BTreeEntry, false, &[\"or_insert\"], \"with\"),\n+            (sym::HashMapEntry, false, &[\"or_insert\"], \"with\"),\n+            (sym::Option, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (sym::Result, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n         if_chain! {\n@@ -104,7 +104,7 @@ pub(super) fn check<'tcx>(\n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+                KNOW_TYPES.iter().find(|&&i| is_type_diagnostic_item(cx, self_ty, i.0));\n \n             if poss.contains(&name);\n \n@@ -121,10 +121,9 @@ pub(super) fn check<'tcx>(\n                             macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n                             match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n                                 Some(stripped) => Cow::from(stripped),\n-                                None => macro_expanded_snipped\n+                                None => macro_expanded_snipped,\n                             }\n-                        }\n-                        else {\n+                        } else {\n                             not_macro_argument_snippet\n                         }\n                     };"}, {"sha": "5c2b96f5b2ce6287a327567635a64184cc56e1a0", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{self, get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -47,18 +47,16 @@ declare_lint_pass!(NoNegCompOpForPartialOrd => [NEG_CMP_OP_ON_PARTIAL_ORD]);\n impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-\n             if !in_external_macro(cx.sess(), expr.span);\n             if let ExprKind::Unary(UnOp::Not, inner) = expr.kind;\n             if let ExprKind::Binary(ref op, left, _) = inner.kind;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {\n-\n                 let ty = cx.typeck_results().expr_ty(left);\n \n                 let implements_ord = {\n-                    if let Some(id) = get_trait_def_id(cx, &paths::ORD) {\n+                    if let Some(id) = cx.tcx.get_diagnostic_item(sym::Ord) {\n                         implements_trait(cx, ty, id, &[])\n                     } else {\n                         return;\n@@ -81,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n                         \"the use of negated comparison operators on partially ordered \\\n                         types produces code that is hard to read and refactor, please \\\n                         consider using the `partial_cmp` method instead, to make it \\\n-                        clear that the two values could be incomparable\"\n+                        clear that the two values could be incomparable\",\n                     );\n                 }\n             }"}, {"sha": "24aeb82a37f3107095a9944ca1b5fb9738a0c51b", "filename": "clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{match_any_def_paths, path_def_id, paths};\n+use clippy_utils::{match_def_path, path_def_id, paths};\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n use rustc_lint::LateContext;\n@@ -49,13 +49,15 @@ fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool)\n             (arg, arg.span)\n         },\n         ExprKind::Call(path, [arg])\n-            if path_def_id(cx, path)\n-                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n-                .map_or(false, |idx| match idx {\n-                    0 => true,\n-                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n-                    _ => false,\n-                }) =>\n+            if path_def_id(cx, path).map_or(false, |id| {\n+                if match_def_path(cx, id, &paths::FROM_STR_METHOD) {\n+                    true\n+                } else if cx.tcx.lang_items().from_fn() == Some(id) {\n+                    !is_copy(cx, typeck.expr_ty(expr))\n+                } else {\n+                    false\n+                }\n+            }) =>\n         {\n             (arg, arg.span)\n         },"}, {"sha": "1307288623f95f3d99e85f572fcc9df379c7856a", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,13 +1,12 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::{get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Closure, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::{GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{sym, BytePos, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -80,7 +79,7 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n         let fn_sig = cx.tcx.fn_sig(def_id);\n         let generics = cx.tcx.predicates_of(def_id);\n         let fn_mut_preds = get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().fn_mut_trait());\n-        let ord_preds = get_trait_predicates_for_trait_id(cx, generics, get_trait_def_id(cx, &paths::ORD));\n+        let ord_preds = get_trait_predicates_for_trait_id(cx, generics, cx.tcx.get_diagnostic_item(sym::Ord));\n         let partial_ord_preds =\n             get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().partial_ord_trait());\n         // Trying to call erase_late_bound_regions on fn_sig.inputs() gives the following error\n@@ -99,11 +98,15 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n                         if trait_pred.self_ty() == inp;\n                         if let Some(return_ty_pred) = get_projection_pred(cx, generics, *trait_pred);\n                         then {\n-                            if ord_preds.iter().any(|ord| Some(ord.self_ty()) == return_ty_pred.term.ty()) {\n+                            if ord_preds\n+                                .iter()\n+                                .any(|ord| Some(ord.self_ty()) == return_ty_pred.term.ty())\n+                            {\n                                 args_to_check.push((i, \"Ord\".to_string()));\n-                            } else if partial_ord_preds.iter().any(|pord| {\n-                                pord.self_ty() == return_ty_pred.term.ty().unwrap()\n-                            }) {\n+                            } else if partial_ord_preds\n+                                .iter()\n+                                .any(|pord| pord.self_ty() == return_ty_pred.term.ty().unwrap())\n+                            {\n                                 args_to_check.push((i, \"PartialOrd\".to_string()));\n                             }\n                         }"}, {"sha": "71f6c9909ddda5881d6d9e5f181e20154516e879", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 11, "deletions": 1559, "changes": 1570, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,1560 +1,12 @@\n-use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n-use clippy_utils::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n-    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n-};\n-use if_chain::if_chain;\n-use rustc_ast as ast;\n-use rustc_ast::ast::{Crate, ItemKind, LitKind, ModKind, NodeId};\n-use rustc_ast::visit::FnKind;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::hir_id::CRATE_HIR_ID;\n-use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n-    TyKind, UnOp,\n-};\n-use rustc_hir_analysis::hir_ty_to_ty;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n-use rustc_middle::ty::{\n-    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n-};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{sym, BytePos, Span};\n-\n-use std::borrow::{Borrow, Cow};\n-use std::str;\n-\n-#[cfg(feature = \"internal\")]\n+pub mod clippy_lints_internal;\n+pub mod collapsible_calls;\n+pub mod compiler_lint_functions;\n+pub mod if_chain_style;\n+pub mod interning_defined_symbol;\n+pub mod invalid_paths;\n+pub mod lint_without_lint_pass;\n pub mod metadata_collector;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for various things we like to keep tidy in clippy.\n-    ///\n-    /// ### Why is this bad?\n-    /// We like to pretend we're an example of tidy code.\n-    ///\n-    /// ### Example\n-    /// Wrong ordering of the util::paths constants.\n-    pub CLIPPY_LINTS_INTERNAL,\n-    internal,\n-    \"various things that will negatively affect your clippy experience\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Ensures every lint is associated to a `LintPass`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The compiler only knows lints via a `LintPass`. Without\n-    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n-    /// know the name of the lint.\n-    ///\n-    /// ### Known problems\n-    /// Only checks for lints associated using the\n-    /// `declare_lint_pass!`, `impl_lint_pass!`, and `lint_array!` macros.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_lint! { pub LINT_1, ... }\n-    /// declare_lint! { pub LINT_2, ... }\n-    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n-    /// // ...\n-    /// declare_lint_pass!(Pass => [LINT_1, LINT_2]);\n-    /// // missing FORGOTTEN_LINT\n-    /// ```\n-    pub LINT_WITHOUT_LINT_PASS,\n-    internal,\n-    \"declaring a lint without associating it in a LintPass\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n-    /// variant of the function.\n-    ///\n-    /// ### Why is this bad?\n-    /// The `utils::*` variants also add a link to the Clippy documentation to the\n-    /// warning/error messages.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// cx.span_lint(LINT_NAME, \"message\");\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// utils::span_lint(cx, LINT_NAME, \"message\");\n-    /// ```\n-    pub COMPILER_LINT_FUNCTIONS,\n-    internal,\n-    \"usage of the lint functions of the compiler instead of the utils::* variant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `cx.outer().expn_data()` and suggests to use\n-    /// the `cx.outer_expn_data()`\n-    ///\n-    /// ### Why is this bad?\n-    /// `cx.outer_expn_data()` is faster and more concise.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// expr.span.ctxt().outer().expn_data()\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// expr.span.ctxt().outer_expn_data()\n-    /// ```\n-    pub OUTER_EXPN_EXPN_DATA,\n-    internal,\n-    \"using `cx.outer_expn().expn_data()` instead of `cx.outer_expn_data()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Not an actual lint. This lint is only meant for testing our customized internal compiler\n-    /// error message by calling `panic`.\n-    ///\n-    /// ### Why is this bad?\n-    /// ICE in large quantities can damage your teeth\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// \ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\n-    /// ```\n-    pub PRODUCE_ICE,\n-    internal,\n-    \"this message should not appear anywhere as we ICE before and don't emit the lint\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for cases of an auto-generated lint without an updated description,\n-    /// i.e. `default lint description`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Indicates that the lint is not finished.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_lint! { pub COOL_LINT, nursery, \"default lint description\" }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// declare_lint! { pub COOL_LINT, nursery, \"a great new lint\" }\n-    /// ```\n-    pub DEFAULT_LINT,\n-    internal,\n-    \"found 'default lint description' in a lint declaration\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lints `span_lint_and_then` function calls, where the\n-    /// closure argument has only one statement and that statement is a method\n-    /// call to `span_suggestion`, `span_help`, `span_note` (using the same\n-    /// span), `help` or `note`.\n-    ///\n-    /// These usages of `span_lint_and_then` should be replaced with one of the\n-    /// wrapper functions `span_lint_and_sugg`, span_lint_and_help`, or\n-    /// `span_lint_and_note`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using the wrapper `span_lint_and_*` functions, is more\n-    /// convenient, readable and less error prone.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_suggestion(\n-    ///         expr.span,\n-    ///         help_msg,\n-    ///         sugg.to_string(),\n-    ///         Applicability::MachineApplicable,\n-    ///     );\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_help(expr.span, help_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.help(help_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_note(expr.span, note_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.note(note_msg);\n-    /// });\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// span_lint_and_sugg(\n-    ///     cx,\n-    ///     TEST_LINT,\n-    ///     expr.span,\n-    ///     lint_msg,\n-    ///     help_msg,\n-    ///     sugg.to_string(),\n-    ///     Applicability::MachineApplicable,\n-    /// );\n-    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg);\n-    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg);\n-    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg);\n-    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, None, note_msg);\n-    /// ```\n-    pub COLLAPSIBLE_SPAN_LINT_CALLS,\n-    internal,\n-    \"found collapsible `span_lint_and_then` calls\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n-    ///\n-    /// ### Why is this bad?\n-    /// The path for an item is subject to change and is less efficient to look up than a\n-    /// diagnostic item or a `LangItem`.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// utils::match_type(cx, ty, &paths::VEC)\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n-    /// ```\n-    pub UNNECESSARY_DEF_PATH,\n-    internal,\n-    \"using a def path when a diagnostic item or a `LangItem` is available\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks the paths module for invalid paths.\n-    ///\n-    /// ### Why is this bad?\n-    /// It indicates a bug in the code.\n-    ///\n-    /// ### Example\n-    /// None.\n-    pub INVALID_PATHS,\n-    internal,\n-    \"invalid path\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's faster and easier to use the symbol constant.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// let _ = sym!(f32);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// let _ = sym::f32;\n-    /// ```\n-    pub INTERNING_DEFINED_SYMBOL,\n-    internal,\n-    \"interning a symbol that is pre-interned and defined as a constant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for unnecessary conversion from Symbol to a string.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's faster use symbols directly instead of strings.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// symbol.as_str() == \"clippy\";\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// symbol == sym::clippy;\n-    /// ```\n-    pub UNNECESSARY_SYMBOL_STR,\n-    internal,\n-    \"unnecessary conversion between Symbol and string\"\n-}\n-\n-declare_clippy_lint! {\n-    /// Finds unidiomatic usage of `if_chain!`\n-    pub IF_CHAIN_STYLE,\n-    internal,\n-    \"non-idiomatic `if_chain!` usage\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for invalid `clippy::version` attributes.\n-    ///\n-    /// Valid values are:\n-    /// * \"pre 1.29.0\"\n-    /// * any valid semantic version\n-    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-    internal,\n-    \"found an invalid `clippy::version` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for declared clippy lints without the `clippy::version` attribute.\n-    ///\n-    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-    internal,\n-    \"found clippy lint without `clippy::version` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n-    ///\n-    pub MISSING_MSRV_ATTR_IMPL,\n-    internal,\n-    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n-    /// i.e. `\"default deprecation note\"`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Indicates that the documentation is incomplete.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_deprecated_lint! {\n-    ///     /// ### What it does\n-    ///     /// Nothing. This lint has been deprecated.\n-    ///     ///\n-    ///     /// ### Deprecation reason\n-    ///     /// TODO\n-    ///     #[clippy::version = \"1.63.0\"]\n-    ///     pub COOL_LINT,\n-    ///     \"default deprecation note\"\n-    /// }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// declare_deprecated_lint! {\n-    ///     /// ### What it does\n-    ///     /// Nothing. This lint has been deprecated.\n-    ///     ///\n-    ///     /// ### Deprecation reason\n-    ///     /// This lint has been replaced by `cooler_lint`\n-    ///     #[clippy::version = \"1.63.0\"]\n-    ///     pub COOL_LINT,\n-    ///     \"this lint has been replaced by `cooler_lint`\"\n-    /// }\n-    /// ```\n-    pub DEFAULT_DEPRECATION_REASON,\n-    internal,\n-    \"found 'default deprecation note' in a deprecated lint declaration\"\n-}\n-\n-declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n-\n-impl EarlyLintPass for ClippyLintsInternal {\n-    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n-        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n-            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n-                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n-                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n-                        let mut last_name: Option<&str> = None;\n-                        for item in items {\n-                            let name = item.ident.as_str();\n-                            if let Some(last_name) = last_name {\n-                                if *last_name > *name {\n-                                    span_lint(\n-                                        cx,\n-                                        CLIPPY_LINTS_INTERNAL,\n-                                        item.span,\n-                                        \"this constant should be before the previous constant due to lexical \\\n-                                         ordering\",\n-                                    );\n-                                }\n-                            }\n-                            last_name = Some(name);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-pub struct LintWithoutLintPass {\n-    declared_lints: FxHashMap<Symbol, Span>,\n-    registered_lints: FxHashSet<Symbol>,\n-}\n-\n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n-            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n-        {\n-            return;\n-        }\n-\n-        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n-            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n-            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n-                check_invalid_clippy_version_attribute(cx, item);\n-\n-                let expr = &cx.tcx.hir().body(body_id).value;\n-                let fields;\n-                if is_lint_ref_ty {\n-                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n-                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n-                            fields = struct_fields;\n-                    } else {\n-                        return;\n-                    }\n-                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n-                    fields = struct_fields;\n-                } else {\n-                    return;\n-                }\n-\n-                let field = fields\n-                    .iter()\n-                    .find(|f| f.ident.as_str() == \"desc\")\n-                    .expect(\"lints must have a description field\");\n-\n-                if let ExprKind::Lit(Spanned {\n-                    node: LitKind::Str(ref sym, _),\n-                    ..\n-                }) = field.expr.kind\n-                {\n-                    let sym_str = sym.as_str();\n-                    if is_lint_ref_ty {\n-                        if sym_str == \"default lint description\" {\n-                            span_lint(\n-                                cx,\n-                                DEFAULT_LINT,\n-                                item.span,\n-                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n-                            );\n-                        }\n-\n-                        self.declared_lints.insert(item.ident.name, item.span);\n-                    } else if sym_str == \"default deprecation note\" {\n-                        span_lint(\n-                            cx,\n-                            DEFAULT_DEPRECATION_REASON,\n-                            item.span,\n-                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n-                        );\n-                    }\n-                }\n-            }\n-        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n-            if !matches!(\n-                cx.tcx.item_name(macro_call.def_id).as_str(),\n-                \"impl_lint_pass\" | \"declare_lint_pass\"\n-            ) {\n-                return;\n-            }\n-            if let hir::ItemKind::Impl(hir::Impl {\n-                of_trait: None,\n-                items: impl_item_refs,\n-                ..\n-            }) = item.kind\n-            {\n-                let mut collector = LintCollector {\n-                    output: &mut self.registered_lints,\n-                    cx,\n-                };\n-                let body_id = cx.tcx.hir().body_owned_by(\n-                    cx.tcx.hir().local_def_id(\n-                        impl_item_refs\n-                            .iter()\n-                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n-                            .expect(\"LintPass needs to implement get_lints\")\n-                            .id\n-                            .hir_id(),\n-                    ),\n-                );\n-                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n-            }\n-        }\n-    }\n-\n-    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n-        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        for (lint_name, &lint_span) in &self.declared_lints {\n-            // When using the `declare_tool_lint!` macro, the original `lint_span`'s\n-            // file points to \"<rustc macros>\".\n-            // `compiletest-rs` thinks that's an error in a different file and\n-            // just ignores it. This causes the test in compile-fail/lint_pass\n-            // not able to capture the error.\n-            // Therefore, we need to climb the macro expansion tree and find the\n-            // actual span that invoked `declare_tool_lint!`:\n-            let lint_span = lint_span.ctxt().outer_expn_data().call_site;\n-\n-            if !self.registered_lints.contains(lint_name) {\n-                span_lint(\n-                    cx,\n-                    LINT_WITHOUT_LINT_PASS,\n-                    lint_span,\n-                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n-    if let TyKind::Rptr(\n-        _,\n-        MutTy {\n-            ty: inner,\n-            mutbl: Mutability::Not,\n-        },\n-    ) = ty.kind\n-    {\n-        if let TyKind::Path(ref path) = inner.kind {\n-            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n-                return match_def_path(cx, def_id, &paths::LINT);\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n-    if let Some(value) = extract_clippy_version_value(cx, item) {\n-        // The `sym!` macro doesn't work as it only expects a single token.\n-        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n-        if value == Symbol::intern(\"pre 1.29.0\") {\n-            return;\n-        }\n-\n-        if RustcVersion::parse(value.as_str()).is_err() {\n-            span_lint_and_help(\n-                cx,\n-                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-                item.span,\n-                \"this item has an invalid `clippy::version` attribute\",\n-                None,\n-                \"please use a valid semantic version, see `doc/adding_lints.md`\",\n-            );\n-        }\n-    } else {\n-        span_lint_and_help(\n-            cx,\n-            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-            item.span,\n-            \"this lint is missing the `clippy::version` attribute or version value\",\n-            None,\n-            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n-        );\n-    }\n-}\n-\n-/// This function extracts the version value of a `clippy::version` attribute if the given value has\n-/// one\n-fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n-    let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    attrs.iter().find_map(|attr| {\n-        if_chain! {\n-            // Identify attribute\n-            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n-            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n-            if tool_name.ident.name == sym::clippy;\n-            if attr_name.ident.name == sym::version;\n-            if let Some(version) = attr.value_str();\n-            then {\n-                Some(version)\n-            } else {\n-                None\n-            }\n-        }\n-    })\n-}\n-\n-struct LintCollector<'a, 'tcx> {\n-    output: &'a mut FxHashSet<Symbol>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn visit_path(&mut self, path: &'tcx Path<'_>, _: HirId) {\n-        if path.segments.len() == 1 {\n-            self.output.insert(path.segments[0].ident.name);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct CompilerLintFunctions {\n-    map: FxHashMap<&'static str, &'static str>,\n-}\n-\n-impl CompilerLintFunctions {\n-    #[must_use]\n-    pub fn new() -> Self {\n-        let mut map = FxHashMap::default();\n-        map.insert(\"span_lint\", \"utils::span_lint\");\n-        map.insert(\"struct_span_lint\", \"utils::span_lint\");\n-        map.insert(\"lint\", \"utils::span_lint\");\n-        map.insert(\"span_lint_note\", \"utils::span_lint_and_note\");\n-        map.insert(\"span_lint_help\", \"utils::span_lint_and_help\");\n-        Self { map }\n-    }\n-}\n-\n-impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n-            let fn_name = path.ident;\n-            if let Some(sugg) = self.map.get(fn_name.as_str());\n-            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if match_type(cx, ty, &paths::EARLY_CONTEXT)\n-                || match_type(cx, ty, &paths::LATE_CONTEXT);\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    COMPILER_LINT_FUNCTIONS,\n-                    path.ident.span,\n-                    \"usage of a compiler lint function\",\n-                    None,\n-                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n-            return;\n-        }\n-\n-        let (method_names, arg_lists, spans) = method_calls(expr, 2);\n-        let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n-        if_chain! {\n-            if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n-            let (self_arg, args)= arg_lists[1];\n-            if args.is_empty();\n-            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    OUTER_EXPN_EXPN_DATA,\n-                    spans[1].with_hi(expr.span.hi()),\n-                    \"usage of `outer_expn().expn_data()`\",\n-                    \"try\",\n-                    \"outer_expn_data()\".to_string(),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n-\n-impl EarlyLintPass for ProduceIce {\n-    fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n-        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n-    }\n-}\n-\n-fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n-    match fn_kind {\n-        FnKind::Fn(_, ident, ..) => ident.name.as_str() == \"it_looks_like_you_are_trying_to_kill_clippy\",\n-        FnKind::Closure(..) => false,\n-    }\n-}\n-\n-declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, and_then_args) = expr.kind;\n-            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n-            if and_then_args.len() == 5;\n-            if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n-            let body = cx.tcx.hir().body(body);\n-            let only_expr = peel_blocks_with_stmt(body.value);\n-            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n-            if let ExprKind::Path(..) = recv.kind;\n-            then {\n-                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n-                match ps.ident.as_str() {\n-                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n-                    },\n-                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n-                    },\n-                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n-                    },\n-                    \"help\" => {\n-                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n-                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n-                    }\n-                    \"note\" => {\n-                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n-                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n-                    }\n-                    _  => (),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct AndThenSnippets<'a> {\n-    cx: Cow<'a, str>,\n-    lint: Cow<'a, str>,\n-    span: Cow<'a, str>,\n-    msg: Cow<'a, str>,\n-}\n-\n-fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n-    let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n-    let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n-    let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n-    let msg_snippet = snippet(cx, and_then_snippets[3].span, r#\"\"...\"\"#);\n-\n-    AndThenSnippets {\n-        cx: cx_snippet,\n-        lint: lint_snippet,\n-        span: span_snippet,\n-        msg: msg_snippet,\n-    }\n-}\n-\n-struct SpanSuggestionSnippets<'a> {\n-    help: Cow<'a, str>,\n-    sugg: Cow<'a, str>,\n-    applicability: Cow<'a, str>,\n-}\n-\n-fn span_suggestion_snippets<'a, 'hir>(\n-    cx: &LateContext<'_>,\n-    span_call_args: &'hir [Expr<'hir>],\n-) -> SpanSuggestionSnippets<'a> {\n-    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n-    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n-\n-    SpanSuggestionSnippets {\n-        help: help_snippet,\n-        sugg: sugg_snippet,\n-        applicability: applicability_snippet,\n-    }\n-}\n-\n-fn suggest_suggestion(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n-) {\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_sugg({}, {}, {}, {}, {}, {}, {})\",\n-            and_then_snippets.cx,\n-            and_then_snippets.lint,\n-            and_then_snippets.span,\n-            and_then_snippets.msg,\n-            span_suggestion_snippets.help,\n-            span_suggestion_snippets.sugg,\n-            span_suggestion_snippets.applicability\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn suggest_help(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    help: &str,\n-    with_span: bool,\n-) {\n-    let option_span = if with_span {\n-        format!(\"Some({})\", and_then_snippets.span)\n-    } else {\n-        \"None\".to_string()\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n-            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn suggest_note(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    note: &str,\n-    with_span: bool,\n-) {\n-    let note_span = if with_span {\n-        format!(\"Some({})\", and_then_snippets.span)\n-    } else {\n-        \"None\".to_string()\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n-            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n-\n-#[allow(clippy::too_many_lines)]\n-impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        enum Item {\n-            LangItem(Symbol),\n-            DiagnosticItem(Symbol),\n-        }\n-        static PATHS: &[&[&str]] = &[\n-            &[\"clippy_utils\", \"match_def_path\"],\n-            &[\"clippy_utils\", \"match_trait_method\"],\n-            &[\"clippy_utils\", \"ty\", \"match_type\"],\n-            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n-        ];\n-\n-        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n-            if let ExprKind::Path(path) = &func.kind;\n-            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n-            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n-            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n-            // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, item_arg);\n-            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n-            then {\n-                // def_path_res will match field names before anything else, but for this we want to match\n-                // inherent functions first.\n-                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n-                    let method_name = *segments.last().unwrap();\n-                    cx.tcx.def_key(def_id).parent\n-                        .and_then(|parent_idx|\n-                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n-                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n-                                    .find_by_name_and_kind(\n-                                        cx.tcx,\n-                                        Ident::from_str(method_name),\n-                                        AssocKind::Fn,\n-                                        *impl_id,\n-                                    )\n-                                )\n-                        )\n-                        .map_or(def_id, |item| item.def_id)\n-                } else {\n-                    def_id\n-                };\n-\n-                // Check if the target item is a diagnostic item or LangItem.\n-                let (msg, item) = if let Some(item_name)\n-                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n-                {\n-                    (\n-                        \"use of a def path to a diagnostic item\",\n-                        Item::DiagnosticItem(*item_name),\n-                    )\n-                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n-                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n-                    (\n-                        \"use of a def path to a `LangItem`\",\n-                        Item::LangItem(item_name),\n-                    )\n-                } else {\n-                    return;\n-                };\n-\n-                let has_ctor = match cx.tcx.def_kind(def_id) {\n-                    DefKind::Struct => {\n-                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n-                    }\n-                    DefKind::Variant => {\n-                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n-                    }\n-                    _ => false,\n-                };\n-\n-                let mut app = Applicability::MachineApplicable;\n-                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n-                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n-                let (sugg, with_note) = match (which_path, item) {\n-                    // match_def_path\n-                    (0, Item::DiagnosticItem(item)) =>\n-                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n-                    (0, Item::LangItem(item)) => (\n-                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n-                        has_ctor\n-                    ),\n-                    // match_trait_method\n-                    (1, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    // match_type\n-                    (2, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    (2, Item::LangItem(item)) =>\n-                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n-                    // is_expr_path_def_path\n-                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n-                        format!(\n-                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n-                        ),\n-                        false,\n-                    ),\n-                    (3, Item::LangItem(item)) if has_ctor => (\n-                        format!(\n-                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n-                        ),\n-                        false,\n-                    ),\n-                    (3, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    (3, Item::LangItem(item)) => (\n-                        format!(\n-                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n-                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n-                        ),\n-                        false,\n-                    ),\n-                    _ => return,\n-                };\n-\n-                span_lint_and_then(\n-                    cx,\n-                    UNNECESSARY_DEF_PATH,\n-                    expr.span,\n-                    msg,\n-                    |diag| {\n-                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n-                        if with_note {\n-                            diag.help(\n-                                \"if this `DefId` came from a constructor expression or pattern then the \\\n-                                    parent `DefId` should be used instead\"\n-                            );\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n-    match peel_hir_expr_refs(expr).0.kind {\n-        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n-            Res::Local(hir_id) => {\n-                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n-                    path_to_matched_type(cx, init)\n-                } else {\n-                    None\n-                }\n-            },\n-            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n-                cx,\n-                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n-                cx.tcx.type_of(def_id),\n-            ),\n-            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n-                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n-                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ExprKind::Array(exprs) => exprs\n-            .iter()\n-            .map(|expr| {\n-                if let ExprKind::Lit(lit) = &expr.kind {\n-                    if let LitKind::Str(sym, _) = lit.node {\n-                        return Some((*sym.as_str()).to_owned());\n-                    }\n-                }\n-\n-                None\n-            })\n-            .collect(),\n-        _ => None,\n-    }\n-}\n-\n-fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n-    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n-        let &alloc = alloc.provenance().values().next()?;\n-        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n-            (alloc.inner(), ty)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        (alloc, ty)\n-    };\n-\n-    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n-        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n-        && ty.is_str()\n-    {\n-        alloc\n-            .provenance()\n-            .values()\n-            .map(|&alloc| {\n-                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n-                    let alloc = alloc.inner();\n-                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n-                        .ok().map(ToOwned::to_owned)\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect()\n-    } else {\n-        None\n-    }\n-}\n-\n-// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n-// module.  That's all it does and all it needs to do.\n-pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path, None) != Res::Err {\n-        return true;\n-    }\n-\n-    // Some implementations can't be found by `path_to_res`, particularly inherent\n-    // implementations of native types. Check lang items.\n-    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n-    let lang_items = cx.tcx.lang_items();\n-    // This list isn't complete, but good enough for our current list of paths.\n-    let incoherent_impls = [\n-        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F32),\n-        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F64),\n-        SimplifiedTypeGen::SliceSimplifiedType,\n-        SimplifiedTypeGen::StrSimplifiedType,\n-    ]\n-    .iter()\n-    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n-    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n-        let lang_item_path = cx.get_def_path(*item_def_id);\n-        if path_syms.starts_with(&lang_item_path) {\n-            if let [item] = &path_syms[lang_item_path.len()..] {\n-                if matches!(\n-                    cx.tcx.def_kind(*item_def_id),\n-                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n-                ) {\n-                    for child in cx.tcx.module_children(*item_def_id) {\n-                        if child.ident.name == *item {\n-                            return true;\n-                        }\n-                    }\n-                } else {\n-                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n-                        if cx.tcx.item_name(*child) == *item {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n-        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n-        if_chain! {\n-            if mod_name.as_str() == \"paths\";\n-            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n-            let ty = hir_ty_to_ty(cx.tcx, ty);\n-            if let ty::Array(el_ty, _) = &ty.kind();\n-            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n-            if el_ty.is_str();\n-            let body = cx.tcx.hir().body(body_id);\n-            let typeck_results = cx.tcx.typeck_body(body_id);\n-            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n-            let path: Vec<&str> = path.iter().map(|x| {\n-                    if let Constant::Str(s) = x {\n-                        s.as_str()\n-                    } else {\n-                        // We checked the type of the constant above\n-                        unreachable!()\n-                    }\n-                }).collect();\n-            if !check_path(cx, &path[..]);\n-            then {\n-                span_lint(cx, INVALID_PATHS, item.span, \"invalid path\");\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct InterningDefinedSymbol {\n-    // Maps the symbol value to the constant DefId.\n-    symbol_map: FxHashMap<u32, DefId>,\n-}\n-\n-impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if !self.symbol_map.is_empty() {\n-            return;\n-        }\n-\n-        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n-                for item in cx.tcx.module_children(def_id).iter() {\n-                    if_chain! {\n-                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n-                        let ty = cx.tcx.type_of(item_def_id);\n-                        if match_type(cx, ty, &paths::SYMBOL);\n-                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n-                        if let Ok(value) = value.to_u32();\n-                        then {\n-                            self.symbol_map.insert(value, item_def_id);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(func, [arg]) = &expr.kind;\n-            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n-            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n-            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n-            let value = Symbol::intern(&arg).as_u32();\n-            if let Some(&def_id) = self.symbol_map.get(&value);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    INTERNING_DEFINED_SYMBOL,\n-                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n-                    \"interning a defined symbol\",\n-                    \"try\",\n-                    cx.tcx.def_path_str(def_id),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        if let ExprKind::Binary(op, left, right) = expr.kind {\n-            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n-                let data = [\n-                    (left, self.symbol_str_expr(left, cx)),\n-                    (right, self.symbol_str_expr(right, cx)),\n-                ];\n-                match data {\n-                    // both operands are a symbol string\n-                    [(_, Some(left)), (_, Some(right))] => {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            UNNECESSARY_SYMBOL_STR,\n-                            expr.span,\n-                            \"unnecessary `Symbol` to string conversion\",\n-                            \"try\",\n-                            format!(\n-                                \"{} {} {}\",\n-                                left.as_symbol_snippet(cx),\n-                                op.node.as_str(),\n-                                right.as_symbol_snippet(cx),\n-                            ),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                    // one of the operands is a symbol string\n-                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n-                        // creating an owned string for comparison\n-                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                UNNECESSARY_SYMBOL_STR,\n-                                expr.span,\n-                                \"unnecessary string allocation\",\n-                                \"try\",\n-                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    },\n-                    // nothing found\n-                    [(_, None), (_, None)] => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl InterningDefinedSymbol {\n-    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n-        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n-        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n-            &paths::SYMBOL_AS_STR,\n-            &paths::SYMBOL_TO_IDENT_STRING,\n-            &paths::TO_STRING_METHOD,\n-        ];\n-        let call = if_chain! {\n-            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n-            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n-            then { e } else { expr }\n-        };\n-        if_chain! {\n-            // is a method call\n-            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n-            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n-            let ty = cx.typeck_results().expr_ty(item);\n-            // ...on either an Ident or a Symbol\n-            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n-                Some(false)\n-            } else if match_type(cx, ty, &paths::IDENT) {\n-                Some(true)\n-            } else {\n-                None\n-            };\n-            // ...which converts it to a string\n-            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n-            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n-            then {\n-                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n-                return Some(SymbolStrExpr::Expr {\n-                    item,\n-                    is_ident,\n-                    is_to_owned,\n-                });\n-            }\n-        }\n-        // is a string constant\n-        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n-            let value = Symbol::intern(&s).as_u32();\n-            // ...which matches a symbol constant\n-            if let Some(&def_id) = self.symbol_map.get(&value) {\n-                return Some(SymbolStrExpr::Const(def_id));\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-enum SymbolStrExpr<'tcx> {\n-    /// a string constant with a corresponding symbol constant\n-    Const(DefId),\n-    /// a \"symbol to string\" expression like `symbol.as_str()`\n-    Expr {\n-        /// part that evaluates to `Symbol` or `Ident`\n-        item: &'tcx Expr<'tcx>,\n-        is_ident: bool,\n-        /// whether an owned `String` is created like `to_ident_string()`\n-        is_to_owned: bool,\n-    },\n-}\n-\n-impl<'tcx> SymbolStrExpr<'tcx> {\n-    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n-    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n-        match *self {\n-            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n-            Self::Expr { item, is_ident, .. } => {\n-                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n-                if is_ident {\n-                    // get `Ident.name`\n-                    snip.to_mut().push_str(\".name\");\n-                }\n-                snip\n-            },\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        let (local, after, if_chain_span) = if_chain! {\n-            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n-            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n-            then { (local, after, if_chain_span) } else { return }\n-        };\n-        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n-            span_lint(\n-                cx,\n-                IF_CHAIN_STYLE,\n-                if_chain_local_span(cx, local, if_chain_span),\n-                \"`let` expression should be above the `if_chain!`\",\n-            );\n-        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n-            span_lint(\n-                cx,\n-                IF_CHAIN_STYLE,\n-                if_chain_local_span(cx, local, if_chain_span),\n-                \"`let` expression should be inside `then { .. }`\",\n-            );\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n-            (cond, then, r#else.is_some())\n-        } else {\n-            return;\n-        };\n-        let ExprKind::Block(then_block, _) = then.kind else { return };\n-        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n-        if !els {\n-            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n-        }\n-        let Some(if_chain_span) = if_chain_span else { return };\n-        // check for `if a && b;`\n-        if_chain! {\n-            if let ExprKind::Binary(op, _, _) = cond.kind;\n-            if op.node == BinOpKind::And;\n-            if cx.sess().source_map().is_multiline(cond.span);\n-            then {\n-                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n-            }\n-        }\n-        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n-            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n-        {\n-            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n-        }\n-    }\n-}\n-\n-fn check_nested_if_chains(\n-    cx: &LateContext<'_>,\n-    if_expr: &Expr<'_>,\n-    then_block: &Block<'_>,\n-    if_chain_span: Option<Span>,\n-) {\n-    #[rustfmt::skip]\n-    let (head, tail) = match *then_block {\n-        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n-        Block {\n-            stmts: &[\n-                ref head @ ..,\n-                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n-            ],\n-            ..\n-        } => (head, tail),\n-        _ => return,\n-    };\n-    if_chain! {\n-        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n-        let sm = cx.sess().source_map();\n-        if head\n-            .iter()\n-            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n-        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n-        then {} else { return }\n-    }\n-    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n-        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n-        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n-        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n-        _ => return,\n-    };\n-    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n-        let (span, msg) = match head {\n-            [] => return,\n-            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n-            [a, .., b] => (\n-                a.span.to(b.span),\n-                \"these `let` statements can also be in the `if_chain!`\",\n-            ),\n-        };\n-        diag.span_help(span, msg);\n-    });\n-}\n-\n-fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n-    cx.tcx\n-        .hir()\n-        .parent_iter(hir_id)\n-        .find(|(_, node)| {\n-            #[rustfmt::skip]\n-            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n-        })\n-        .map_or(false, |(id, _)| {\n-            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n-        })\n-}\n-\n-/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n-/// of the `then {..}` portion of an `if_chain!`\n-fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n-    let span = if let [stmt, ..] = stmts {\n-        stmt.span\n-    } else if let Some(expr) = expr {\n-        expr.span\n-    } else {\n-        // empty `then {}`\n-        return true;\n-    };\n-    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n-}\n-\n-/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n-fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n-    let mut span = local.pat.span;\n-    if let Some(init) = local.init {\n-        span = span.to(init.span);\n-    }\n-    span.adjust(if_chain_span.ctxt().outer_expn());\n-    let sm = cx.sess().source_map();\n-    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n-    let span = sm.span_extend_to_next_char(span, ';', false);\n-    Span::new(\n-        span.lo() - BytePos(3),\n-        span.hi() + BytePos(1),\n-        span.ctxt(),\n-        span.parent(),\n-    )\n-}\n-\n-declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n-\n-impl LateLintPass<'_> for MsrvAttrImpl {\n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if_chain! {\n-            if let hir::ItemKind::Impl(hir::Impl {\n-                of_trait: Some(lint_pass_trait_ref),\n-                self_ty,\n-                items,\n-                ..\n-            }) = &item.kind;\n-            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n-            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n-            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n-            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n-            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n-            if self_ty_def.is_struct();\n-            if self_ty_def.all_fields().any(|f| {\n-                cx.tcx\n-                    .type_of(f.did)\n-                    .walk()\n-                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n-                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n-            });\n-            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n-            then {\n-                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n-                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n-                let span = cx.sess().source_map().span_through_char(item.span, '{');\n-                span_lint_and_sugg(\n-                    cx,\n-                    MISSING_MSRV_ATTR_IMPL,\n-                    span,\n-                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n-                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n-                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n+pub mod msrv_attr_impl;\n+pub mod outer_expn_data_pass;\n+pub mod produce_ice;\n+pub mod unnecessary_def_path;"}, {"sha": "da9514dd15eee4c85293c8ea8e0c546c99f5cb0e", "filename": "clippy_lints/src/utils/internal_lints/clippy_lints_internal.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,49 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{Crate, ItemKind, ModKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for various things we like to keep tidy in clippy.\n+    ///\n+    /// ### Why is this bad?\n+    /// We like to pretend we're an example of tidy code.\n+    ///\n+    /// ### Example\n+    /// Wrong ordering of the util::paths constants.\n+    pub CLIPPY_LINTS_INTERNAL,\n+    internal,\n+    \"various things that will negatively affect your clippy experience\"\n+}\n+\n+declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n+\n+impl EarlyLintPass for ClippyLintsInternal {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n+        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n+            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n+                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n+                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n+                        let mut last_name: Option<&str> = None;\n+                        for item in items {\n+                            let name = item.ident.as_str();\n+                            if let Some(last_name) = last_name {\n+                                if *last_name > *name {\n+                                    span_lint(\n+                                        cx,\n+                                        CLIPPY_LINTS_INTERNAL,\n+                                        item.span,\n+                                        \"this constant should be before the previous constant due to lexical \\\n+                                         ordering\",\n+                                    );\n+                                }\n+                            }\n+                            last_name = Some(name);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "d7666b77f6e969d1086f1ba0db9b5dd4f4c5bace", "filename": "clippy_lints/src/utils/internal_lints/collapsible_calls.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,245 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{is_expr_path_def_path, is_lint_allowed, peel_blocks_with_stmt, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Closure, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use std::borrow::{Borrow, Cow};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lints `span_lint_and_then` function calls, where the\n+    /// closure argument has only one statement and that statement is a method\n+    /// call to `span_suggestion`, `span_help`, `span_note` (using the same\n+    /// span), `help` or `note`.\n+    ///\n+    /// These usages of `span_lint_and_then` should be replaced with one of the\n+    /// wrapper functions `span_lint_and_sugg`, span_lint_and_help`, or\n+    /// `span_lint_and_note`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the wrapper `span_lint_and_*` functions, is more\n+    /// convenient, readable and less error prone.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_suggestion(\n+    ///         expr.span,\n+    ///         help_msg,\n+    ///         sugg.to_string(),\n+    ///         Applicability::MachineApplicable,\n+    ///     );\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_help(expr.span, help_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.help(help_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_note(expr.span, note_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.note(note_msg);\n+    /// });\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     TEST_LINT,\n+    ///     expr.span,\n+    ///     lint_msg,\n+    ///     help_msg,\n+    ///     sugg.to_string(),\n+    ///     Applicability::MachineApplicable,\n+    /// );\n+    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg);\n+    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg);\n+    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg);\n+    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, None, note_msg);\n+    /// ```\n+    pub COLLAPSIBLE_SPAN_LINT_CALLS,\n+    internal,\n+    \"found collapsible `span_lint_and_then` calls\"\n+}\n+\n+declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Call(func, and_then_args) = expr.kind;\n+            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n+            if and_then_args.len() == 5;\n+            if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n+            let body = cx.tcx.hir().body(body);\n+            let only_expr = peel_blocks_with_stmt(body.value);\n+            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::Path(..) = recv.kind;\n+            then {\n+                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n+                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n+                match ps.ident.as_str() {\n+                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        suggest_suggestion(\n+                            cx,\n+                            expr,\n+                            &and_then_snippets,\n+                            &span_suggestion_snippets(cx, span_call_args),\n+                        );\n+                    },\n+                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n+                    },\n+                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n+                    },\n+                    \"help\" => {\n+                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n+                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n+                    },\n+                    \"note\" => {\n+                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n+                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct AndThenSnippets<'a> {\n+    cx: Cow<'a, str>,\n+    lint: Cow<'a, str>,\n+    span: Cow<'a, str>,\n+    msg: Cow<'a, str>,\n+}\n+\n+fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n+    let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n+    let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n+    let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n+    let msg_snippet = snippet(cx, and_then_snippets[3].span, r#\"\"...\"\"#);\n+\n+    AndThenSnippets {\n+        cx: cx_snippet,\n+        lint: lint_snippet,\n+        span: span_snippet,\n+        msg: msg_snippet,\n+    }\n+}\n+\n+struct SpanSuggestionSnippets<'a> {\n+    help: Cow<'a, str>,\n+    sugg: Cow<'a, str>,\n+    applicability: Cow<'a, str>,\n+}\n+\n+fn span_suggestion_snippets<'a, 'hir>(\n+    cx: &LateContext<'_>,\n+    span_call_args: &'hir [Expr<'hir>],\n+) -> SpanSuggestionSnippets<'a> {\n+    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n+    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n+\n+    SpanSuggestionSnippets {\n+        help: help_snippet,\n+        sugg: sugg_snippet,\n+        applicability: applicability_snippet,\n+    }\n+}\n+\n+fn suggest_suggestion(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n+) {\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_sugg({}, {}, {}, {}, {}, {}, {})\",\n+            and_then_snippets.cx,\n+            and_then_snippets.lint,\n+            and_then_snippets.span,\n+            and_then_snippets.msg,\n+            span_suggestion_snippets.help,\n+            span_suggestion_snippets.sugg,\n+            span_suggestion_snippets.applicability\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn suggest_help(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    help: &str,\n+    with_span: bool,\n+) {\n+    let option_span = if with_span {\n+        format!(\"Some({})\", and_then_snippets.span)\n+    } else {\n+        \"None\".to_string()\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn suggest_note(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    note: &str,\n+    with_span: bool,\n+) {\n+    let note_span = if with_span {\n+        format!(\"Some({})\", and_then_snippets.span)\n+    } else {\n+        \"None\".to_string()\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "cacd05262a2151093552d0cfde6329911e3710b6", "filename": "clippy_lints/src/utils/internal_lints/compiler_lint_functions.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,77 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{is_lint_allowed, paths};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n+    /// variant of the function.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `utils::*` variants also add a link to the Clippy documentation to the\n+    /// warning/error messages.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// cx.span_lint(LINT_NAME, \"message\");\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// utils::span_lint(cx, LINT_NAME, \"message\");\n+    /// ```\n+    pub COMPILER_LINT_FUNCTIONS,\n+    internal,\n+    \"usage of the lint functions of the compiler instead of the utils::* variant\"\n+}\n+\n+impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n+\n+#[derive(Clone, Default)]\n+pub struct CompilerLintFunctions {\n+    map: FxHashMap<&'static str, &'static str>,\n+}\n+\n+impl CompilerLintFunctions {\n+    #[must_use]\n+    pub fn new() -> Self {\n+        let mut map = FxHashMap::default();\n+        map.insert(\"span_lint\", \"utils::span_lint\");\n+        map.insert(\"struct_span_lint\", \"utils::span_lint\");\n+        map.insert(\"lint\", \"utils::span_lint\");\n+        map.insert(\"span_lint_note\", \"utils::span_lint_and_note\");\n+        map.insert(\"span_lint_help\", \"utils::span_lint_and_help\");\n+        Self { map }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n+            let fn_name = path.ident;\n+            if let Some(sugg) = self.map.get(fn_name.as_str());\n+            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+            if match_type(cx, ty, &paths::EARLY_CONTEXT) || match_type(cx, ty, &paths::LATE_CONTEXT);\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    COMPILER_LINT_FUNCTIONS,\n+                    path.ident.span,\n+                    \"usage of a compiler lint function\",\n+                    None,\n+                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "883a5c08e5c11b1f86ec1c84e3a627a27ffc1aad", "filename": "clippy_lints/src/utils/internal_lints/if_chain_style.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,164 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::{higher, is_else_clause, is_expn_of};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Local, Node, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Span};\n+\n+declare_clippy_lint! {\n+    /// Finds unidiomatic usage of `if_chain!`\n+    pub IF_CHAIN_STYLE,\n+    internal,\n+    \"non-idiomatic `if_chain!` usage\"\n+}\n+\n+declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n+        let (local, after, if_chain_span) = if_chain! {\n+            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n+            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n+            then { (local, after, if_chain_span) } else { return }\n+        };\n+        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be above the `if_chain!`\",\n+            );\n+        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be inside `then { .. }`\",\n+            );\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n+            (cond, then, r#else.is_some())\n+        } else {\n+            return;\n+        };\n+        let ExprKind::Block(then_block, _) = then.kind else { return };\n+        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n+        if !els {\n+            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n+        }\n+        let Some(if_chain_span) = if_chain_span else { return };\n+        // check for `if a && b;`\n+        if_chain! {\n+            if let ExprKind::Binary(op, _, _) = cond.kind;\n+            if op.node == BinOpKind::And;\n+            if cx.sess().source_map().is_multiline(cond.span);\n+            then {\n+                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n+            }\n+        }\n+        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n+            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n+        {\n+            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n+        }\n+    }\n+}\n+\n+fn check_nested_if_chains(\n+    cx: &LateContext<'_>,\n+    if_expr: &Expr<'_>,\n+    then_block: &Block<'_>,\n+    if_chain_span: Option<Span>,\n+) {\n+    #[rustfmt::skip]\n+    let (head, tail) = match *then_block {\n+        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n+        Block {\n+            stmts: &[\n+                ref head @ ..,\n+                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n+            ],\n+            ..\n+        } => (head, tail),\n+        _ => return,\n+    };\n+    if_chain! {\n+        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n+        let sm = cx.sess().source_map();\n+        if head\n+            .iter()\n+            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n+        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n+        then {\n+        } else {\n+            return;\n+        }\n+    }\n+    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n+        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n+        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n+        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n+        _ => return,\n+    };\n+    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n+        let (span, msg) = match head {\n+            [] => return,\n+            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n+            [a, .., b] => (\n+                a.span.to(b.span),\n+                \"these `let` statements can also be in the `if_chain!`\",\n+            ),\n+        };\n+        diag.span_help(span, msg);\n+    });\n+}\n+\n+fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n+    cx.tcx\n+        .hir()\n+        .parent_iter(hir_id)\n+        .find(|(_, node)| {\n+            #[rustfmt::skip]\n+            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n+        })\n+        .map_or(false, |(id, _)| {\n+            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n+        })\n+}\n+\n+/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n+/// of the `then {..}` portion of an `if_chain!`\n+fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n+    let span = if let [stmt, ..] = stmts {\n+        stmt.span\n+    } else if let Some(expr) = expr {\n+        expr.span\n+    } else {\n+        // empty `then {}`\n+        return true;\n+    };\n+    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n+}\n+\n+/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n+fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n+    let mut span = local.pat.span;\n+    if let Some(init) = local.init {\n+        span = span.to(init.span);\n+    }\n+    span.adjust(if_chain_span.ctxt().outer_expn());\n+    let sm = cx.sess().source_map();\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n+    let span = sm.span_extend_to_next_char(span, ';', false);\n+    Span::new(\n+        span.lo() - BytePos(3),\n+        span.hi() + BytePos(1),\n+        span.ctxt(),\n+        span.parent(),\n+    )\n+}"}, {"sha": "096b601572b4db5dcce28ff090f39b8e1d4eadf6", "filename": "clippy_lints/src/utils/internal_lints/interning_defined_symbol.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,239 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{def_path_res, is_expn_of, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::Symbol;\n+\n+use std::borrow::Cow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's faster and easier to use the symbol constant.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let _ = sym!(f32);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// let _ = sym::f32;\n+    /// ```\n+    pub INTERNING_DEFINED_SYMBOL,\n+    internal,\n+    \"interning a symbol that is pre-interned and defined as a constant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary conversion from Symbol to a string.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's faster use symbols directly instead of strings.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// symbol.as_str() == \"clippy\";\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// symbol == sym::clippy;\n+    /// ```\n+    pub UNNECESSARY_SYMBOL_STR,\n+    internal,\n+    \"unnecessary conversion between Symbol and string\"\n+}\n+\n+#[derive(Default)]\n+pub struct InterningDefinedSymbol {\n+    // Maps the symbol value to the constant DefId.\n+    symbol_map: FxHashMap<u32, DefId>,\n+}\n+\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        if !self.symbol_map.is_empty() {\n+            return;\n+        }\n+\n+        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n+            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n+                for item in cx.tcx.module_children(def_id).iter() {\n+                    if_chain! {\n+                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n+                        let ty = cx.tcx.type_of(item_def_id);\n+                        if match_type(cx, ty, &paths::SYMBOL);\n+                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n+                        if let Ok(value) = value.to_u32();\n+                        then {\n+                            self.symbol_map.insert(value, item_def_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(func, [arg]) = &expr.kind;\n+            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n+            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n+            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n+            let value = Symbol::intern(&arg).as_u32();\n+            if let Some(&def_id) = self.symbol_map.get(&value);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    INTERNING_DEFINED_SYMBOL,\n+                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n+                    \"interning a defined symbol\",\n+                    \"try\",\n+                    cx.tcx.def_path_str(def_id),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n+            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n+                let data = [\n+                    (left, self.symbol_str_expr(left, cx)),\n+                    (right, self.symbol_str_expr(right, cx)),\n+                ];\n+                match data {\n+                    // both operands are a symbol string\n+                    [(_, Some(left)), (_, Some(right))] => {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_SYMBOL_STR,\n+                            expr.span,\n+                            \"unnecessary `Symbol` to string conversion\",\n+                            \"try\",\n+                            format!(\n+                                \"{} {} {}\",\n+                                left.as_symbol_snippet(cx),\n+                                op.node.as_str(),\n+                                right.as_symbol_snippet(cx),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                    // one of the operands is a symbol string\n+                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n+                        // creating an owned string for comparison\n+                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_SYMBOL_STR,\n+                                expr.span,\n+                                \"unnecessary string allocation\",\n+                                \"try\",\n+                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                    // nothing found\n+                    [(_, None), (_, None)] => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl InterningDefinedSymbol {\n+    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n+        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n+        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n+            &paths::SYMBOL_AS_STR,\n+            &paths::SYMBOL_TO_IDENT_STRING,\n+            &paths::TO_STRING_METHOD,\n+        ];\n+        let call = if_chain! {\n+            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n+            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n+            then { e } else { expr }\n+        };\n+        if_chain! {\n+            // is a method call\n+            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n+            let ty = cx.typeck_results().expr_ty(item);\n+            // ...on either an Ident or a Symbol\n+            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n+                Some(false)\n+            } else if match_type(cx, ty, &paths::IDENT) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            // ...which converts it to a string\n+            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n+            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n+            then {\n+                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n+                return Some(SymbolStrExpr::Expr {\n+                    item,\n+                    is_ident,\n+                    is_to_owned,\n+                });\n+            }\n+        }\n+        // is a string constant\n+        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n+            let value = Symbol::intern(&s).as_u32();\n+            // ...which matches a symbol constant\n+            if let Some(&def_id) = self.symbol_map.get(&value) {\n+                return Some(SymbolStrExpr::Const(def_id));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+enum SymbolStrExpr<'tcx> {\n+    /// a string constant with a corresponding symbol constant\n+    Const(DefId),\n+    /// a \"symbol to string\" expression like `symbol.as_str()`\n+    Expr {\n+        /// part that evaluates to `Symbol` or `Ident`\n+        item: &'tcx Expr<'tcx>,\n+        is_ident: bool,\n+        /// whether an owned `String` is created like `to_ident_string()`\n+        is_to_owned: bool,\n+    },\n+}\n+\n+impl<'tcx> SymbolStrExpr<'tcx> {\n+    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n+    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n+        match *self {\n+            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n+            Self::Expr { item, is_ident, .. } => {\n+                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n+                if is_ident {\n+                    // get `Ident.name`\n+                    snip.to_mut().push_str(\".name\");\n+                }\n+                snip\n+            },\n+        }\n+    }\n+}"}, {"sha": "25532dd4e2681e6455921480339e937b536e3e92", "filename": "clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,108 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::def_path_res;\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::Item;\n+use rustc_hir_analysis::hir_ty_to_ty;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, FloatTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks the paths module for invalid paths.\n+    ///\n+    /// ### Why is this bad?\n+    /// It indicates a bug in the code.\n+    ///\n+    /// ### Example\n+    /// None.\n+    pub INVALID_PATHS,\n+    internal,\n+    \"invalid path\"\n+}\n+\n+declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n+        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n+        if_chain! {\n+            if mod_name.as_str() == \"paths\";\n+            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n+            let ty = hir_ty_to_ty(cx.tcx, ty);\n+            if let ty::Array(el_ty, _) = &ty.kind();\n+            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n+            if el_ty.is_str();\n+            let body = cx.tcx.hir().body(body_id);\n+            let typeck_results = cx.tcx.typeck_body(body_id);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n+            let path: Vec<&str> = path\n+                .iter()\n+                .map(|x| {\n+                    if let Constant::Str(s) = x {\n+                        s.as_str()\n+                    } else {\n+                        // We checked the type of the constant above\n+                        unreachable!()\n+                    }\n+                })\n+                .collect();\n+            if !check_path(cx, &path[..]);\n+            then {\n+                span_lint(cx, INVALID_PATHS, item.span, \"invalid path\");\n+            }\n+        }\n+    }\n+}\n+\n+// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n+// module.  That's all it does and all it needs to do.\n+pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n+    if def_path_res(cx, path, None) != Res::Err {\n+        return true;\n+    }\n+\n+    // Some implementations can't be found by `path_to_res`, particularly inherent\n+    // implementations of native types. Check lang items.\n+    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n+    let lang_items = cx.tcx.lang_items();\n+    // This list isn't complete, but good enough for our current list of paths.\n+    let incoherent_impls = [\n+        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F32),\n+        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F64),\n+        SimplifiedTypeGen::SliceSimplifiedType,\n+        SimplifiedTypeGen::StrSimplifiedType,\n+    ]\n+    .iter()\n+    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n+    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n+        let lang_item_path = cx.get_def_path(*item_def_id);\n+        if path_syms.starts_with(&lang_item_path) {\n+            if let [item] = &path_syms[lang_item_path.len()..] {\n+                if matches!(\n+                    cx.tcx.def_kind(*item_def_id),\n+                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n+                ) {\n+                    for child in cx.tcx.module_children(*item_def_id) {\n+                        if child.ident.name == *item {\n+                            return true;\n+                        }\n+                    }\n+                } else {\n+                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n+                        if cx.tcx.item_name(*child) == *item {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "0dac64376b06539109482966d66918fb66f7efab", "filename": "clippy_lints/src/utils/internal_lints/lint_without_lint_pass.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,342 @@\n+use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::{is_lint_allowed, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast as ast;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::hir_id::CRATE_HIR_ID;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{ExprKind, HirId, Item, MutTy, Mutability, Path, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Ensures every lint is associated to a `LintPass`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The compiler only knows lints via a `LintPass`. Without\n+    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n+    /// know the name of the lint.\n+    ///\n+    /// ### Known problems\n+    /// Only checks for lints associated using the\n+    /// `declare_lint_pass!`, `impl_lint_pass!`, and `lint_array!` macros.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_lint! { pub LINT_1, ... }\n+    /// declare_lint! { pub LINT_2, ... }\n+    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n+    /// // ...\n+    /// declare_lint_pass!(Pass => [LINT_1, LINT_2]);\n+    /// // missing FORGOTTEN_LINT\n+    /// ```\n+    pub LINT_WITHOUT_LINT_PASS,\n+    internal,\n+    \"declaring a lint without associating it in a LintPass\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated lint without an updated description,\n+    /// i.e. `default lint description`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the lint is not finished.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_lint! { pub COOL_LINT, nursery, \"default lint description\" }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_lint! { pub COOL_LINT, nursery, \"a great new lint\" }\n+    /// ```\n+    pub DEFAULT_LINT,\n+    internal,\n+    \"found 'default lint description' in a lint declaration\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for invalid `clippy::version` attributes.\n+    ///\n+    /// Valid values are:\n+    /// * \"pre 1.29.0\"\n+    /// * any valid semantic version\n+    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found an invalid `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for declared clippy lints without the `clippy::version` attribute.\n+    ///\n+    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found clippy lint without `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n+    /// i.e. `\"default deprecation note\"`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the documentation is incomplete.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// TODO\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"default deprecation note\"\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// This lint has been replaced by `cooler_lint`\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"this lint has been replaced by `cooler_lint`\"\n+    /// }\n+    /// ```\n+    pub DEFAULT_DEPRECATION_REASON,\n+    internal,\n+    \"found 'default deprecation note' in a deprecated lint declaration\"\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct LintWithoutLintPass {\n+    declared_lints: FxHashMap<Symbol, Span>,\n+    registered_lints: FxHashSet<Symbol>,\n+}\n+\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n+\n+impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n+            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n+        {\n+            return;\n+        }\n+\n+        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n+            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n+            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n+                check_invalid_clippy_version_attribute(cx, item);\n+\n+                let expr = &cx.tcx.hir().body(body_id).value;\n+                let fields;\n+                if is_lint_ref_ty {\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n+                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n+                            fields = struct_fields;\n+                    } else {\n+                        return;\n+                    }\n+                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n+                    fields = struct_fields;\n+                } else {\n+                    return;\n+                }\n+\n+                let field = fields\n+                    .iter()\n+                    .find(|f| f.ident.as_str() == \"desc\")\n+                    .expect(\"lints must have a description field\");\n+\n+                if let ExprKind::Lit(Spanned {\n+                    node: LitKind::Str(ref sym, _),\n+                    ..\n+                }) = field.expr.kind\n+                {\n+                    let sym_str = sym.as_str();\n+                    if is_lint_ref_ty {\n+                        if sym_str == \"default lint description\" {\n+                            span_lint(\n+                                cx,\n+                                DEFAULT_LINT,\n+                                item.span,\n+                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            );\n+                        }\n+\n+                        self.declared_lints.insert(item.ident.name, item.span);\n+                    } else if sym_str == \"default deprecation note\" {\n+                        span_lint(\n+                            cx,\n+                            DEFAULT_DEPRECATION_REASON,\n+                            item.span,\n+                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n+                        );\n+                    }\n+                }\n+            }\n+        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n+            if !matches!(\n+                cx.tcx.item_name(macro_call.def_id).as_str(),\n+                \"impl_lint_pass\" | \"declare_lint_pass\"\n+            ) {\n+                return;\n+            }\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: None,\n+                items: impl_item_refs,\n+                ..\n+            }) = item.kind\n+            {\n+                let mut collector = LintCollector {\n+                    output: &mut self.registered_lints,\n+                    cx,\n+                };\n+                let body_id = cx.tcx.hir().body_owned_by(\n+                    cx.tcx.hir().local_def_id(\n+                        impl_item_refs\n+                            .iter()\n+                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n+                            .expect(\"LintPass needs to implement get_lints\")\n+                            .id\n+                            .hir_id(),\n+                    ),\n+                );\n+                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n+            }\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n+            return;\n+        }\n+\n+        for (lint_name, &lint_span) in &self.declared_lints {\n+            // When using the `declare_tool_lint!` macro, the original `lint_span`'s\n+            // file points to \"<rustc macros>\".\n+            // `compiletest-rs` thinks that's an error in a different file and\n+            // just ignores it. This causes the test in compile-fail/lint_pass\n+            // not able to capture the error.\n+            // Therefore, we need to climb the macro expansion tree and find the\n+            // actual span that invoked `declare_tool_lint!`:\n+            let lint_span = lint_span.ctxt().outer_expn_data().call_site;\n+\n+            if !self.registered_lints.contains(lint_name) {\n+                span_lint(\n+                    cx,\n+                    LINT_WITHOUT_LINT_PASS,\n+                    lint_span,\n+                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n+    if let TyKind::Rptr(\n+        _,\n+        MutTy {\n+            ty: inner,\n+            mutbl: Mutability::Not,\n+        },\n+    ) = ty.kind\n+    {\n+        if let TyKind::Path(ref path) = inner.kind {\n+            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n+                return match_def_path(cx, def_id, &paths::LINT);\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n+    if let Some(value) = extract_clippy_version_value(cx, item) {\n+        // The `sym!` macro doesn't work as it only expects a single token.\n+        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n+        if value == Symbol::intern(\"pre 1.29.0\") {\n+            return;\n+        }\n+\n+        if RustcVersion::parse(value.as_str()).is_err() {\n+            span_lint_and_help(\n+                cx,\n+                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+                item.span,\n+                \"this item has an invalid `clippy::version` attribute\",\n+                None,\n+                \"please use a valid semantic version, see `doc/adding_lints.md`\",\n+            );\n+        }\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+            item.span,\n+            \"this lint is missing the `clippy::version` attribute or version value\",\n+            None,\n+            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n+        );\n+    }\n+}\n+\n+/// This function extracts the version value of a `clippy::version` attribute if the given value has\n+/// one\n+pub(super) fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    attrs.iter().find_map(|attr| {\n+        if_chain! {\n+            // Identify attribute\n+            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n+            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n+            if tool_name.ident.name == sym::clippy;\n+            if attr_name.ident.name == sym::version;\n+            if let Some(version) = attr.value_str();\n+            then { Some(version) } else { None }\n+        }\n+    })\n+}\n+\n+struct LintCollector<'a, 'tcx> {\n+    output: &'a mut FxHashSet<Symbol>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'_>, _: HirId) {\n+        if path.segments.len() == 1 {\n+            self.output.insert(path.segments[0].ident.name);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+}"}, {"sha": "d06a616e4b30b2d8ee796e9cc5fe5d967d99f6d3", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -8,7 +8,7 @@\n //! a simple mistake)\n \n use crate::renamed_lints::RENAMED_LINTS;\n-use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n+use crate::utils::internal_lints::lint_without_lint_pass::{extract_clippy_version_value, is_lint_ref_type};\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};\n@@ -532,7 +532,11 @@ fn parse_config_field_doc(doc_comment: &str) -> Option<(Vec<String>, String)> {\n \n             // Extract lints\n             doc_comment.make_ascii_lowercase();\n-            let lints: Vec<String> = doc_comment.split_off(DOC_START.len()).split(\", \").map(str::to_string).collect();\n+            let lints: Vec<String> = doc_comment\n+                .split_off(DOC_START.len())\n+                .split(\", \")\n+                .map(str::to_string)\n+                .collect();\n \n             // Format documentation correctly\n             // split off leading `.` from lint name list and indent for correct formatting"}, {"sha": "1e994e3f2b1713b1c2cef1502479177d8f7566e0", "filename": "clippy_lints/src/utils/internal_lints/msrv_attr_impl.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,63 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir_analysis::hir_ty_to_ty;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::{self, subst::GenericArgKind};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n+    ///\n+    pub MISSING_MSRV_ATTR_IMPL,\n+    internal,\n+    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n+}\n+\n+declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n+\n+impl LateLintPass<'_> for MsrvAttrImpl {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if_chain! {\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: Some(lint_pass_trait_ref),\n+                self_ty,\n+                items,\n+                ..\n+            }) = &item.kind;\n+            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n+            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n+            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n+            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n+            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n+            if self_ty_def.is_struct();\n+            if self_ty_def.all_fields().any(|f| {\n+                cx.tcx\n+                    .type_of(f.did)\n+                    .walk()\n+                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n+                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n+            });\n+            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n+            then {\n+                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n+                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n+                let span = cx.sess().source_map().span_through_char(item.span, '{');\n+                span_lint_and_sugg(\n+                    cx,\n+                    MISSING_MSRV_ATTR_IMPL,\n+                    span,\n+                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n+                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n+                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "2b13fad80665c73ae93e82fd7d1d8115e6c95d1e", "filename": "clippy_lints/src/utils/internal_lints/outer_expn_data_pass.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,62 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{is_lint_allowed, method_calls, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `cx.outer().expn_data()` and suggests to use\n+    /// the `cx.outer_expn_data()`\n+    ///\n+    /// ### Why is this bad?\n+    /// `cx.outer_expn_data()` is faster and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// expr.span.ctxt().outer().expn_data()\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// expr.span.ctxt().outer_expn_data()\n+    /// ```\n+    pub OUTER_EXPN_EXPN_DATA,\n+    internal,\n+    \"using `cx.outer_expn().expn_data()` instead of `cx.outer_expn_data()`\"\n+}\n+\n+declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n+            return;\n+        }\n+\n+        let (method_names, arg_lists, spans) = method_calls(expr, 2);\n+        let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n+        if_chain! {\n+            if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n+            let (self_arg, args) = arg_lists[1];\n+            if args.is_empty();\n+            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+            if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    OUTER_EXPN_EXPN_DATA,\n+                    spans[1].with_hi(expr.span.hi()),\n+                    \"usage of `outer_expn().expn_data()`\",\n+                    \"try\",\n+                    \"outer_expn_data()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "5899b94e16ba241e078300d5760ca6537a525ec3", "filename": "clippy_lints/src/utils/internal_lints/produce_ice.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,37 @@\n+use rustc_ast::ast::NodeId;\n+use rustc_ast::visit::FnKind;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Not an actual lint. This lint is only meant for testing our customized internal compiler\n+    /// error message by calling `panic`.\n+    ///\n+    /// ### Why is this bad?\n+    /// ICE in large quantities can damage your teeth\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// \ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\n+    /// ```\n+    pub PRODUCE_ICE,\n+    internal,\n+    \"this message should not appear anywhere as we ICE before and don't emit the lint\"\n+}\n+\n+declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n+\n+impl EarlyLintPass for ProduceIce {\n+    fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n+        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n+    }\n+}\n+\n+fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n+    match fn_kind {\n+        FnKind::Fn(_, ident, ..) => ident.name.as_str() == \"it_looks_like_you_are_trying_to_kill_clippy\",\n+        FnKind::Closure(..) => false,\n+    }\n+}"}, {"sha": "4cf76f53625510fd7989b0a6aa450c202df14c0c", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,343 @@\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{def_path_res, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Namespace, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind, Local, Mutability, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{self, AssocKind, DefIdTree, Ty};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+use std::str;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n+    ///\n+    /// ### Why is this bad?\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// utils::match_type(cx, ty, &paths::VEC)\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n+    /// ```\n+    pub UNNECESSARY_DEF_PATH,\n+    internal,\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n+}\n+\n+impl_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n+\n+#[derive(Default)]\n+pub struct UnnecessaryDefPath {\n+    array_def_ids: FxHashSet<(DefId, Span)>,\n+    linted_def_ids: FxHashSet<DefId>,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Call(func, args) => self.check_call(cx, func, args, expr.span),\n+            ExprKind::Array(elements) => self.check_array(cx, elements, expr.span),\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(def_id, span) in &self.array_def_ids {\n+            if self.linted_def_ids.contains(&def_id) {\n+                continue;\n+            }\n+\n+            let (msg, sugg) = if let Some(sym) = cx.tcx.get_diagnostic_name(def_id) {\n+                (\"diagnostic item\", format!(\"sym::{sym}\"))\n+            } else if let Some(sym) = get_lang_item_name(cx, def_id) {\n+                (\"language item\", format!(\"LangItem::{sym}\"))\n+            } else {\n+                continue;\n+            };\n+\n+            span_lint_and_help(\n+                cx,\n+                UNNECESSARY_DEF_PATH,\n+                span,\n+                &format!(\"hardcoded path to a {msg}\"),\n+                None,\n+                &format!(\"convert all references to use `{sugg}`\"),\n+            );\n+        }\n+    }\n+}\n+\n+impl UnnecessaryDefPath {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_call(&mut self, cx: &LateContext<'_>, func: &Expr<'_>, args: &[Expr<'_>], span: Span) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if_chain! {\n+            if let [cx_arg, def_arg, args @ ..] = args;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n+            // Extract the path to the matched type\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = inherent_def_path_res(cx, &segments[..]);\n+            then {\n+                // Check if the target item is a diagnostic item or LangItem.\n+                #[rustfmt::skip]\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(item_name) = get_lang_item_name(cx, def_id) {\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    },\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    },\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"),\n+                        has_ctor,\n+                    ),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor,\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) => {\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false)\n+                    },\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) => (\n+                        format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"),\n+                        false,\n+                    ),\n+                    (2, Item::LangItem(item)) => (\n+                        format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"),\n+                        false,\n+                    ),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) => (\n+                        format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(cx, UNNECESSARY_DEF_PATH, span, msg, |diag| {\n+                    diag.span_suggestion(span, \"try\", sugg, app);\n+                    if with_note {\n+                        diag.help(\n+                            \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\",\n+                        );\n+                    }\n+                });\n+\n+                self.linted_def_ids.insert(def_id);\n+            }\n+        }\n+    }\n+\n+    fn check_array(&mut self, cx: &LateContext<'_>, elements: &[Expr<'_>], span: Span) {\n+        let Some(path) = path_from_array(elements) else { return };\n+\n+        if let Some(def_id) = inherent_def_path_res(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n+            self.array_def_ids.insert((def_id, span));\n+        }\n+    }\n+}\n+\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+            Res::Local(hir_id) => {\n+                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n+                }\n+            },\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ExprKind::Array(exprs) => path_from_array(exprs),\n+        _ => None,\n+    }\n+}\n+\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n+\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n+}\n+\n+fn path_from_array(exprs: &[Expr<'_>]) -> Option<Vec<String>> {\n+    exprs\n+        .iter()\n+        .map(|expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind {\n+                if let LitKind::Str(sym, _) = lit.node {\n+                    return Some((*sym.as_str()).to_owned());\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect()\n+}\n+\n+// def_path_res will match field names before anything else, but for this we want to match\n+// inherent functions first.\n+fn inherent_def_path_res(cx: &LateContext<'_>, segments: &[&str]) -> Option<DefId> {\n+    def_path_res(cx, segments, None).opt_def_id().map(|def_id| {\n+        if cx.tcx.def_kind(def_id) == DefKind::Field {\n+            let method_name = *segments.last().unwrap();\n+            cx.tcx\n+                .def_key(def_id)\n+                .parent\n+                .and_then(|parent_idx| {\n+                    cx.tcx\n+                        .inherent_impls(DefId {\n+                            index: parent_idx,\n+                            krate: def_id.krate,\n+                        })\n+                        .iter()\n+                        .find_map(|impl_id| {\n+                            cx.tcx.associated_items(*impl_id).find_by_name_and_kind(\n+                                cx.tcx,\n+                                Ident::from_str(method_name),\n+                                AssocKind::Fn,\n+                                *impl_id,\n+                            )\n+                        })\n+                })\n+                .map_or(def_id, |item| item.def_id)\n+        } else {\n+            def_id\n+        }\n+    })\n+}\n+\n+fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<Symbol> {\n+    if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+        let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n+        let item_name = cx\n+            .tcx\n+            .adt_def(lang_items)\n+            .variants()\n+            .iter()\n+            .nth(lang_item)\n+            .unwrap()\n+            .name;\n+        Some(item_name)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "cbc2fde69d1244d6fa2086269705d61924a2ee53", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1766,6 +1766,7 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool\n /// ```rust,ignore\n /// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n /// ```\n+/// This function is deprecated. Use [`match_function_call_with_def_id`].\n pub fn match_function_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -1783,6 +1784,22 @@ pub fn match_function_call<'tcx>(\n     None\n }\n \n+pub fn match_function_call_with_def_id<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    fun_def_id: DefId,\n+) -> Option<&'tcx [Expr<'tcx>]> {\n+    if_chain! {\n+        if let ExprKind::Call(fun, args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if cx.qpath_res(qpath, fun.hir_id).opt_def_id() == Some(fun_def_id);\n+        then {\n+            return Some(args);\n+        }\n+    };\n+    None\n+}\n+\n /// Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if\n /// any.\n ///"}, {"sha": "bc851473430454d8b1dc0f4bdf7dece213606e4c", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -16,56 +16,40 @@ pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n #[cfg(feature = \"internal\")]\n pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n-pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n-pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n-pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const BTREESET_ITER: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\", \"iter\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n-pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CORE_ITER_COLLECT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"collect\"];\n pub const CORE_ITER_CLONED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"cloned\"];\n pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n-pub const CORE_ITER_INTO_ITER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\", \"into_iter\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n-/// Preferably use the diagnostic item `sym::deref_method` where possible\n-pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_LINT_PASS: [&str; 3] = [\"rustc_lint\", \"passes\", \"EarlyLintPass\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n-pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n-pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n-pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n-pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n #[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const FUTURES_IO_ASYNCREADEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncReadExt\"];\n #[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWriteExt\"];\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n-pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n pub const HASHSET_ITER: [&str; 6] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\", \"iter\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n-pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n-pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n-pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n@@ -76,13 +60,7 @@ pub const LATE_LINT_PASS: [&str; 3] = [\"rustc_lint\", \"passes\", \"LateLintPass\"];\n #[cfg(feature = \"internal\")]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_SWAP: [&str; 3] = [\"core\", \"mem\", \"swap\"];\n-pub const MUTEX_GUARD: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"MutexGuard\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n-/// Preferably use the diagnostic item `sym::Option` where possible\n-pub const OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const OPTION_NONE: [&str; 4] = [\"core\", \"option\", \"Option\", \"None\"];\n-pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n-pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 3] = [\"lock_api\", \"mutex\", \"MutexGuard\"];\n@@ -95,8 +73,6 @@ pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n #[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n-pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n-pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n pub const PTR_COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const PTR_COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n@@ -125,14 +101,8 @@ pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n pub const REGEX_BYTES_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n pub const REGEX_NEW: [&str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n-/// Preferably use the diagnostic item `sym::Result` where possible\n-pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n-pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n #[cfg(feature = \"internal\")]\n pub const RUSTC_VERSION: [&str; 2] = [\"rustc_semver\", \"RustcVersion\"];\n-pub const RWLOCK_READ_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockReadGuard\"];\n-pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const SERDE_DESERIALIZE: [&str; 3] = [\"serde\", \"de\", \"Deserialize\"];\n pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts\"];"}, {"sha": "07c5941013c1af5d6b89a661100c9b2a42e01801", "filename": "tests/ui-internal/custom_ice_message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.stderr?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints.rs\n+thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints/produce_ice.rs:28:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n error: internal compiler error: unexpected panic"}, {"sha": "9a9790a4bae51ec7c99447c4a4ddfa46f1080e77", "filename": "tests/ui-internal/invalid_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_paths.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n+#![allow(clippy::missing_clippy_version_attribute, clippy::unnecessary_def_path)]\n \n mod paths {\n     // Good path"}, {"sha": "cbbb4652306415b7256435bcdc5f83256c47c6b4", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -28,17 +28,17 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n \n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n \n fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n     let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n     let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n \n-    #[allow(unused)]\n+    #[allow(unused, clippy::unnecessary_def_path)]\n     let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n     let _ = is_type_diagnostic_item(cx, ty, sym::Rc);\n "}, {"sha": "f17fed6c6530410cc139dfe34c4dfa85d155917d", "filename": "tests/ui-internal/unnecessary_def_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -28,17 +28,17 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n \n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n \n fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = match_type(cx, ty, &OPTION);\n     let _ = match_type(cx, ty, RESULT);\n     let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n \n-    #[allow(unused)]\n+    #[allow(unused, clippy::unnecessary_def_path)]\n     let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n     let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n "}, {"sha": "b5ff3a5420561a8d7f473e843d26d73e77c9ede4", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,16 @@\n+#![feature(rustc_private)]\n+#![allow(unused)]\n+#![warn(clippy::unnecessary_def_path)]\n+\n+extern crate rustc_hir;\n+\n+use rustc_hir::LangItem;\n+\n+fn main() {\n+    const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+    const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+    const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+\n+    // Don't lint, not yet a diagnostic or language item\n+    const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n+}"}, {"sha": "af46d87bf676e42816316dcf94aef37abb063059", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/332b5b3d8b883087ea1632bf7cfb13721db6d9f9/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=332b5b3d8b883087ea1632bf7cfb13721db6d9f9", "patch": "@@ -0,0 +1,27 @@\n+error: hardcoded path to a language item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n+   |\n+LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `LangItem::DerefMut`\n+   = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n+\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n+   |\n+LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::deref_method`\n+\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n+   |\n+LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::Deref`\n+\n+error: aborting due to 3 previous errors\n+"}]}