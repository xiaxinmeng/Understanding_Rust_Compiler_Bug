{"sha": "9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "node_id": "C_kwDOAAsO6NoAKDlhZDgzZGVlY2NkOGNiM2QzNzViNTU1OGViN2UzZDMzOWIxYTRlMGI", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T15:40:25Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T15:40:25Z"}, "message": "Support overloaded index MIR lowering", "tree": {"sha": "e533c936fd7fed5481422d1edcfa82ed61ac9868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e533c936fd7fed5481422d1edcfa82ed61ac9868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "html_url": "https://github.com/rust-lang/rust/commit/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb4939e217960ee77d79ec436a39f3cead646de4", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4939e217960ee77d79ec436a39f3cead646de4", "html_url": "https://github.com/rust-lang/rust/commit/eb4939e217960ee77d79ec436a39f3cead646de4"}], "stats": {"total": 172, "additions": 169, "deletions": 3}, "files": [{"sha": "944912b6c262fd42397f4b5298b4906b0697b548", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "patch": "@@ -2,7 +2,8 @@ use base_db::fixture::WithFixture;\n use hir_def::db::DefDatabase;\n \n use crate::{\n-    consteval::try_const_usize, db::HirDatabase, test_db::TestDB, Const, ConstScalar, Interner,\n+    consteval::try_const_usize, db::HirDatabase, mir::pad16, test_db::TestDB, Const, ConstScalar,\n+    Interner,\n };\n \n use super::{\n@@ -30,7 +31,12 @@ fn check_number(ra_fixture: &str, answer: i128) {\n     match &r.data(Interner).value {\n         chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n             ConstScalar::Bytes(b, _) => {\n-                assert_eq!(b, &answer.to_le_bytes()[0..b.len()]);\n+                assert_eq!(\n+                    b,\n+                    &answer.to_le_bytes()[0..b.len()],\n+                    \"Bytes differ. In decimal form: actual = {}, expected = {answer}\",\n+                    i128::from_le_bytes(pad16(b, true))\n+                );\n             }\n             x => panic!(\"Expected number but found {:?}\", x),\n         },\n@@ -215,6 +221,42 @@ fn overloaded_deref_autoref() {\n     );\n }\n \n+#[test]\n+fn overloaded_index() {\n+    check_number(\n+        r#\"\n+    //- minicore: index\n+    struct Foo;\n+\n+    impl core::ops::Index<usize> for Foo {\n+        type Output = i32;\n+        fn index(&self, index: usize) -> &i32 {\n+            if index == 7 {\n+                &700\n+            } else {\n+                &1000\n+            }\n+        }\n+    }\n+\n+    impl core::ops::IndexMut<usize> for Foo {\n+        fn index_mut(&mut self, index: usize) -> &mut i32 {\n+            if index == 7 {\n+                &mut 7\n+            } else {\n+                &mut 10\n+            }\n+        }\n+    }\n+\n+    const GOAL: i32 = {\n+        (Foo[2]) + (Foo[7]) + (*&Foo[2]) + (*&Foo[7]) + (*&mut Foo[2]) + (*&mut Foo[7])\n+    };\n+    \"#,\n+        3417,\n+    );\n+}\n+\n #[test]\n fn function_call() {\n     check_number("}, {"sha": "784725da93508dc804cf7e3fc7943e3de8fa7a90", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "patch": "@@ -95,6 +95,21 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_mut_not_expr_iter(fields.iter().map(|x| x.expr).chain(*spread))\n             }\n             &Expr::Index { base, index } => {\n+                if let Some((f, _)) = self.result.method_resolutions.get_mut(&tgt_expr) {\n+                    if mutability == Mutability::Mut {\n+                        if let Some(index_trait) = self\n+                            .db\n+                            .lang_item(self.table.trait_env.krate, LangItem::IndexMut)\n+                            .and_then(|l| l.as_trait())\n+                        {\n+                            if let Some(index_fn) =\n+                                self.db.trait_data(index_trait).method_by_name(&name![index_mut])\n+                            {\n+                                *f = index_fn;\n+                            }\n+                        }\n+                    }\n+                }\n                 self.infer_mut_expr(base, mutability);\n                 self.infer_mut_expr(index, Mutability::Not);\n             }"}, {"sha": "425904850ba85436609d711cf2152a28e6ed5733", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "patch": "@@ -1,6 +1,7 @@\n //! MIR lowering for places\n \n use super::*;\n+use hir_def::FunctionId;\n use hir_expand::name;\n \n macro_rules! not_supported {\n@@ -193,7 +194,24 @@ impl MirLowerCtx<'_> {\n                 if index_ty != TyBuilder::usize()\n                     || !matches!(base_ty.kind(Interner), TyKind::Array(..) | TyKind::Slice(..))\n                 {\n-                    not_supported!(\"overloaded index\");\n+                    let Some(index_fn) = self.infer.method_resolution(expr_id) else {\n+                        return Err(MirLowerError::UnresolvedMethod);\n+                    };\n+                    let Some((base_place, current)) = self.lower_expr_as_place(current, *base, true)? else {\n+                        return Ok(None);\n+                    };\n+                    let Some((index_operand, current)) = self.lower_expr_to_some_operand(*index, current)? else {\n+                        return Ok(None);\n+                    };\n+                    return self.lower_overloaded_index(\n+                        current,\n+                        base_place,\n+                        self.expr_ty_after_adjustments(*base),\n+                        self.expr_ty(expr_id),\n+                        index_operand,\n+                        expr_id.into(),\n+                        index_fn,\n+                    );\n                 }\n                 let Some((mut p_base, current)) =\n                     self.lower_expr_as_place(current, *base, true)? else {\n@@ -210,6 +228,49 @@ impl MirLowerCtx<'_> {\n         }\n     }\n \n+    fn lower_overloaded_index(\n+        &mut self,\n+        current: BasicBlockId,\n+        place: Place,\n+        base_ty: Ty,\n+        result_ty: Ty,\n+        index_operand: Operand,\n+        span: MirSpan,\n+        index_fn: (FunctionId, Substitution),\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let is_mutable = 'b: {\n+            if let Some(index_mut_trait) = self.resolve_lang_item(LangItem::IndexMut)?.as_trait() {\n+                if let Some(index_mut_fn) =\n+                    self.db.trait_data(index_mut_trait).method_by_name(&name![index_mut])\n+                {\n+                    break 'b index_mut_fn == index_fn.0;\n+                }\n+            }\n+            false\n+        };\n+        let (mutability, borrow_kind) = match is_mutable {\n+            true => (Mutability::Mut, BorrowKind::Mut { allow_two_phase_borrow: false }),\n+            false => (Mutability::Not, BorrowKind::Shared),\n+        };\n+        let base_ref = TyKind::Ref(mutability, static_lifetime(), base_ty).intern(Interner);\n+        let result_ref = TyKind::Ref(mutability, static_lifetime(), result_ty).intern(Interner);\n+        let ref_place: Place = self.temp(base_ref)?.into();\n+        self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n+        let mut result: Place = self.temp(result_ref)?.into();\n+        let index_fn_op = Operand::const_zst(\n+            TyKind::FnDef(\n+                self.db.intern_callable_def(CallableDefId::FunctionId(index_fn.0)).into(),\n+                index_fn.1,\n+            )\n+            .intern(Interner),\n+        );\n+        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(ref_place), index_operand], result.clone(), current, false)? else {\n+            return Ok(None);\n+        };\n+        result.projection.push(ProjectionElem::Deref);\n+        Ok(Some((result, current)))\n+    }\n+\n     fn lower_overloaded_deref(\n         &mut self,\n         current: BasicBlockId,"}, {"sha": "17a70f5701bc9827837c0695851213cdf5c71551", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=9ad83deeccd8cb3d375b5558eb7e3d339b1a4e0b", "patch": "@@ -564,6 +564,54 @@ fn f(x: [(i32, u8); 10]) {\n         );\n     }\n \n+    #[test]\n+    fn overloaded_index() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: index\n+use core::ops::{Index, IndexMut};\n+\n+struct Foo;\n+impl Index<usize> for Foo {\n+    type Output = (i32, u8);\n+    fn index(&self, index: usize) -> &(i32, u8) {\n+        &(5, 2)\n+    }\n+}\n+impl IndexMut<usize> for Foo {\n+    fn index_mut(&mut self, index: usize) -> &mut (i32, u8) {\n+        &mut (5, 2)\n+    }\n+}\n+fn f() {\n+    let mut x = Foo;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let y = &x[2];\n+    let x = Foo;\n+    let y = &mut x[2];\n+               //^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let mut x = &mut Foo;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let y: &mut (i32, u8) = &mut x[2];\n+    let x = Foo;\n+    let ref mut y = x[7];\n+                  //^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    let (ref mut y, _) = x[3];\n+                       //^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    match x[10] {\n+        //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        (ref y, _) => (),\n+        (_, ref mut y) => (),\n+    }\n+    let mut x = Foo;\n+    let mut i = 5;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    let y = &mut x[i];\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn overloaded_deref() {\n         check_diagnostics("}]}