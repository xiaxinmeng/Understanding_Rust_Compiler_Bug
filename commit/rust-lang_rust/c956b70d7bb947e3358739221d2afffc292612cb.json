{"sha": "c956b70d7bb947e3358739221d2afffc292612cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NTZiNzBkN2JiOTQ3ZTMzNTg3MzkyMjFkMmFmZmZjMjkyNjEyY2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-01T05:53:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-05T19:38:42Z"}, "message": "rustc: Modify crate loading to ignore versions\n\nThis commit modifies crate loading to purely work off a `crate_name` and nothing\nelse. This commit also changes the patterns recognized from `lib<foo>-*` to\n`lib<foo>*` to accomodate the future renamings of output files.\n\nRFC: 0035-remove-crate-id", "tree": {"sha": "86d4fb064ddc17bf4a9d5377761b436fa1e71bad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86d4fb064ddc17bf4a9d5377761b436fa1e71bad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c956b70d7bb947e3358739221d2afffc292612cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c956b70d7bb947e3358739221d2afffc292612cb", "html_url": "https://github.com/rust-lang/rust/commit/c956b70d7bb947e3358739221d2afffc292612cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c956b70d7bb947e3358739221d2afffc292612cb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1007739b20110bf7af654354815e2a1265282ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1007739b20110bf7af654354815e2a1265282ec2", "html_url": "https://github.com/rust-lang/rust/commit/1007739b20110bf7af654354815e2a1265282ec2"}], "stats": {"total": 121, "additions": 34, "deletions": 87}, "files": [{"sha": "8b5b450eb4676d8daadb5df54bbbfbbd623bd032", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 34, "deletions": 87, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c956b70d7bb947e3358739221d2afffc292612cb/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c956b70d7bb947e3358739221d2afffc292612cb/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=c956b70d7bb947e3358739221d2afffc292612cb", "patch": "@@ -21,8 +21,6 @@ use metadata::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use syntax::abi;\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use syntax::crateid::CrateId;\n-use syntax::attr::AttrMetaMethods;\n use util::fs;\n \n use std::c_str::ToCStr;\n@@ -61,8 +59,7 @@ pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n     pub ident: &'a str,\n-    pub crate_id: &'a CrateId,\n-    pub id_hash: &'a str,\n+    pub crate_name: &'a str,\n     pub hash: Option<&'a Svh>,\n     pub triple: &'a str,\n     pub os: abi::Os,\n@@ -171,15 +168,15 @@ impl<'a> Context<'a> {\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n         let dylib_prefix = dypair.map(|(prefix, _)| {\n-            format!(\"{}{}-\", prefix, self.crate_id.name)\n+            format!(\"{}{}\", prefix, self.crate_name)\n         });\n-        let rlib_prefix = format!(\"lib{}-\", self.crate_id.name);\n+        let rlib_prefix = format!(\"lib{}\", self.crate_name);\n \n         let mut candidates = HashMap::new();\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n         // the name of the files themselves. We're trying to match against an\n-        // exact crate_id and a possibly an exact hash.\n+        // exact crate name and a possibly an exact hash.\n         //\n         // During this step, we can filter all found libraries based on the\n         // name and id found in the crate id (we ignore the path portion for\n@@ -195,49 +192,32 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            if file.starts_with(rlib_prefix.as_slice()) &&\n+            let (hash, rlib) = if file.starts_with(rlib_prefix.as_slice()) &&\n                     file.ends_with(\".rlib\") {\n-                info!(\"rlib candidate: {}\", path.display());\n-                match self.try_match(file, rlib_prefix.as_slice(), \".rlib\") {\n-                    Some(hash) => {\n-                        info!(\"rlib accepted, hash: {}\", hash);\n-                        let slot = candidates.find_or_insert_with(hash, |_| {\n-                            (HashSet::new(), HashSet::new())\n-                        });\n-                        let (ref mut rlibs, _) = *slot;\n-                        rlibs.insert(fs::realpath(path).unwrap());\n-                        FileMatches\n-                    }\n-                    None => {\n-                        info!(\"rlib rejected\");\n-                        FileDoesntMatch\n-                    }\n-                }\n+                (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n+                 true)\n             } else if dypair.map_or(false, |(_, suffix)| {\n                 file.starts_with(dylib_prefix.get_ref().as_slice()) &&\n                 file.ends_with(suffix)\n             }) {\n                 let (_, suffix) = dypair.unwrap();\n                 let dylib_prefix = dylib_prefix.get_ref().as_slice();\n-                info!(\"dylib candidate: {}\", path.display());\n-                match self.try_match(file, dylib_prefix, suffix) {\n-                    Some(hash) => {\n-                        info!(\"dylib accepted, hash: {}\", hash);\n-                        let slot = candidates.find_or_insert_with(hash, |_| {\n-                            (HashSet::new(), HashSet::new())\n-                        });\n-                        let (_, ref mut dylibs) = *slot;\n-                        dylibs.insert(fs::realpath(path).unwrap());\n-                        FileMatches\n-                    }\n-                    None => {\n-                        info!(\"dylib rejected\");\n-                        FileDoesntMatch\n-                    }\n-                }\n+                (file.slice(dylib_prefix.len(), file.len() - suffix.len()),\n+                 false)\n+            } else {\n+                return FileDoesntMatch\n+            };\n+            info!(\"lib candidate: {}\", path.display());\n+            let slot = candidates.find_or_insert_with(hash.to_string(), |_| {\n+                (HashSet::new(), HashSet::new())\n+            });\n+            let (ref mut rlibs, ref mut dylibs) = *slot;\n+            if rlib {\n+                rlibs.insert(fs::realpath(path).unwrap());\n             } else {\n-                FileDoesntMatch\n+                dylibs.insert(fs::realpath(path).unwrap());\n             }\n+            FileMatches\n         });\n \n         // We have now collected all known libraries into a set of candidates\n@@ -274,7 +254,7 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n-                            self.crate_id.name).as_slice());\n+                            self.crate_name).as_slice());\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n@@ -292,50 +272,14 @@ impl<'a> Context<'a> {\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n-                    let crate_id = decoder::get_crate_id(data);\n-                    note_crateid_attr(self.sess.diagnostic(), &crate_id);\n+                    let name = decoder::get_crate_name(data);\n+                    note_crate_name(self.sess.diagnostic(), name.as_slice());\n                 }\n                 None\n             }\n         }\n     }\n \n-    // Attempts to match the requested version of a library against the file\n-    // specified. The prefix/suffix are specified (disambiguates between\n-    // rlib/dylib).\n-    //\n-    // The return value is `None` if `file` doesn't look like a rust-generated\n-    // library, or if a specific version was requested and it doesn't match the\n-    // apparent file's version.\n-    //\n-    // If everything checks out, then `Some(hash)` is returned where `hash` is\n-    // the listed hash in the filename itself.\n-    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<String>{\n-        let middle = file.slice(prefix.len(), file.len() - suffix.len());\n-        debug!(\"matching -- {}, middle: {}\", file, middle);\n-        let mut parts = middle.splitn('-', 1);\n-        let hash = match parts.next() { Some(h) => h, None => return None };\n-        debug!(\"matching -- {}, hash: {} (want {})\", file, hash, self.id_hash);\n-        let vers = match parts.next() { Some(v) => v, None => return None };\n-        debug!(\"matching -- {}, vers: {} (want {})\", file, vers,\n-               self.crate_id.version);\n-        match self.crate_id.version {\n-            Some(ref version) if version.as_slice() != vers => return None,\n-            Some(..) => {} // check the hash\n-\n-            // hash is irrelevant, no version specified\n-            None => return Some(hash.to_string())\n-        }\n-        debug!(\"matching -- {}, vers ok\", file);\n-        // hashes in filenames are prefixes of the \"true hash\"\n-        if self.id_hash == hash.as_slice() {\n-            debug!(\"matching -- {}, hash ok\", file);\n-            Some(hash.to_string())\n-        } else {\n-            None\n-        }\n-    }\n-\n     // Attempts to extract *one* library from the set `m`. If the set has no\n     // elements, `None` is returned. If the set has more than one element, then\n     // the errors and notes are emitted about the set of libraries.\n@@ -382,7 +326,7 @@ impl<'a> Context<'a> {\n                                    format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_id.name).as_slice());\n+                                           self.crate_name).as_slice());\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n                                             ret.get_ref()\n@@ -404,9 +348,9 @@ impl<'a> Context<'a> {\n     }\n \n     fn crate_matches(&mut self, crate_data: &[u8], libpath: &Path) -> bool {\n-        match decoder::maybe_get_crate_id(crate_data) {\n-            Some(ref id) if self.crate_id.matches(id) => {}\n-            _ => { info!(\"Rejecting via crate_id\"); return false }\n+        match decoder::maybe_get_crate_name(crate_data) {\n+            Some(ref name) if self.crate_name == name.as_slice() => {}\n+            _ => { info!(\"Rejecting via crate name\"); return false }\n         }\n         let hash = match decoder::maybe_get_crate_hash(crate_data) {\n             Some(hash) => hash, None => {\n@@ -415,7 +359,10 @@ impl<'a> Context<'a> {\n             }\n         };\n \n-        let triple = decoder::get_crate_triple(crate_data);\n+        let triple = match decoder::get_crate_triple(crate_data) {\n+            None => { debug!(\"triple not present\"); return false }\n+            Some(t) => t,\n+        };\n         if triple.as_slice() != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n             self.rejected_via_triple.push(CrateMismatch {\n@@ -458,8 +405,8 @@ impl<'a> Context<'a> {\n \n }\n \n-pub fn note_crateid_attr(diag: &SpanHandler, crateid: &CrateId) {\n-    diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()).as_slice());\n+pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n+    diag.handler().note(format!(\"crate name: {}\", name).as_slice());\n }\n \n impl ArchiveMetadata {"}]}