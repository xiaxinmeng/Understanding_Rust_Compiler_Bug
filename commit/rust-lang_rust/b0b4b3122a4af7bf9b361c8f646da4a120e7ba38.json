{"sha": "b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYjRiMzEyMmE0YWY3YmY5YjM2MWM4ZjY0NmRhNGExMjBlN2JhMzg=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-12T04:22:11Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T17:08:27Z"}, "message": "refactor Method definition to make space for macros\n\nThis change propagates to many locations, but because of the\nMacro Exterminator (or, more properly, the invariant that it\nprotects), macro invocations can't occur downstream of expansion.\nThis means that in librustc and librustdoc, extracting the\ndesired field can simply assume that it can't be a macro\ninvocation. Functions in ast_util abstract over this check.", "tree": {"sha": "d3e0fcb19160fcdc2f2977bebc647af9587cf512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3e0fcb19160fcdc2f2977bebc647af9587cf512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "html_url": "https://github.com/rust-lang/rust/commit/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e178ebf681d532c1c965883ae34788713f748960", "url": "https://api.github.com/repos/rust-lang/rust/commits/e178ebf681d532c1c965883ae34788713f748960", "html_url": "https://github.com/rust-lang/rust/commit/e178ebf681d532c1c965883ae34788713f748960"}], "stats": {"total": 450, "additions": 277, "deletions": 173}, "files": [{"sha": "6cb0ab51ca10d074f3e09a39f8131777a9434588", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -799,7 +799,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n-        encode_method_argument_names(ebml_w, &*ast_method.decl);\n+        encode_method_argument_names(ebml_w, method_fn_decl(&*ast_method));\n     }\n \n     ebml_w.end_tag();\n@@ -1241,7 +1241,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_method_sort(ebml_w, 'p');\n                     encode_inlined_item(ecx, ebml_w,\n                                         IIMethodRef(def_id, true, &*m));\n-                    encode_method_argument_names(ebml_w, &*m.decl);\n+                    encode_method_argument_names(ebml_w, method_fn_decl(m));\n                 }\n             }\n "}, {"sha": "8fa7d7c2aaa775003de3887e1fe299010a9590d4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -136,7 +136,7 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         let ident = match ii {\n             ast::IIItem(i) => i.ident,\n             ast::IIForeign(i) => i.ident,\n-            ast::IIMethod(_, _, m) => m.ident,\n+            ast::IIMethod(_, _, m) => ast_util::method_ident(&*m),\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\","}, {"sha": "d84c62f744edc21b4c49f1be1c03ce6f1ba6d4fc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -22,6 +22,7 @@ use util::nodemap::NodeSet;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -212,7 +213,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n                 visit::walk_trait_method(self, &*trait_method, ctxt);\n             }\n             ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, &*method.body, ctxt);\n+                visit::walk_block(self, ast_util::method_body(&*method), ctxt);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n                 visit::walk_foreign_item(self, &*foreign_item, ctxt);\n@@ -520,7 +521,8 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {\n-            ast::Provided(ref method) => visit::walk_block(self, &*method.body, ()),\n+            ast::Provided(ref method) => visit::walk_block(self,\n+                                                           ast_util::method_body(&**method), ()),\n             ast::Required(_) => ()\n         }\n     }"}, {"sha": "415135a2d048f04ff4bb8ec38207b35fa03d7279", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -17,6 +17,7 @@ use middle::typeck::MethodCall;\n use util::ppaux;\n \n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -94,7 +95,7 @@ impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n             visit::FkItemFn(_, _, fn_style, _) =>\n                 (true, fn_style == ast::UnsafeFn),\n             visit::FkMethod(_, _, method) =>\n-                (true, method.fn_style == ast::UnsafeFn),\n+                (true, ast_util::method_fn_style(method) == ast::UnsafeFn),\n             _ => (false, false),\n         };\n "}, {"sha": "580e7b2db57c294a772070b04eba0189916541db", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -26,6 +26,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::ast_util::{is_local, local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -263,10 +264,10 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n \n                 if public_ty || public_trait {\n                     for method in methods.iter() {\n-                        let meth_public = match method.explicit_self.node {\n+                        let meth_public = match ast_util::method_explicit_self(&**method).node {\n                             ast::SelfStatic => public_ty,\n                             _ => true,\n-                        } && method.vis == ast::Public;\n+                        } && ast_util::method_vis(&**method) == ast::Public;\n                         if meth_public || tr.is_some() {\n                             self.exported_items.insert(method.id);\n                         }\n@@ -456,8 +457,8 @@ impl<'a> PrivacyVisitor<'a> {\n                     let imp = self.tcx.map.get_parent_did(closest_private_id);\n                     match ty::impl_trait_ref(self.tcx, imp) {\n                         Some(..) => return Allowable,\n-                        _ if m.vis == ast::Public => return Allowable,\n-                        _ => m.vis\n+                        _ if ast_util::method_vis(&**m) == ast::Public => return Allowable,\n+                        _ => ast_util::method_vis(&**m)\n                     }\n                 }\n                 Some(ast_map::NodeTraitMethod(_)) => {\n@@ -1078,7 +1079,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n                 for m in methods.iter() {\n-                    check_inherited(m.span, m.vis, \"\");\n+                    check_inherited(m.span, ast_util::method_vis(&**m), \"\");\n                 }\n             }\n \n@@ -1110,7 +1111,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Provided(ref m) => {\n-                            check_inherited(m.span, m.vis,\n+                            check_inherited(m.span, ast_util::method_vis(&**m),\n                                             \"unnecessary visibility\");\n                         }\n                         ast::Required(ref m) => {\n@@ -1148,7 +1149,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n         match item.node {\n             ast::ItemImpl(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n-                    check_inherited(tcx, m.span, m.vis);\n+                    check_inherited(tcx, m.span, ast_util::method_vis(&**m));\n                 }\n             }\n             ast::ItemForeignMod(ref fm) => {\n@@ -1174,7 +1175,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                     match *m {\n                         ast::Required(..) => {}\n                         ast::Provided(ref m) => check_inherited(tcx, m.span,\n-                                                                m.vis),\n+                                                                ast_util::method_vis(&**m)),\n                     }\n                 }\n             }\n@@ -1344,7 +1345,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for method in methods.iter() {\n-                        if method.explicit_self.node == ast::SelfStatic &&\n+                        if ast_util::method_explicit_self(&**method).node == ast::SelfStatic &&\n                             self.exported_items.contains(&method.id) {\n                             found_pub_static = true;\n                             visit::walk_method_helper(self, &**method, ());"}, {"sha": "d9324574da73f78a4afd9de153ac5c026831c1b3", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -68,7 +68,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs.as_slice()) ||\n-        generics_require_inlining(&method.generics) {\n+        generics_require_inlining(ast_util::method_generics(&*method)) {\n         return true\n     }\n     if is_local(impl_src) {\n@@ -200,7 +200,7 @@ impl<'a> ReachableContext<'a> {\n                 }\n             }\n             Some(ast_map::NodeMethod(method)) => {\n-                if generics_require_inlining(&method.generics) ||\n+                if generics_require_inlining(ast_util::method_generics(&*method)) ||\n                         attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n@@ -316,14 +316,14 @@ impl<'a> ReachableContext<'a> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(self, &*method.body, ())\n+                        visit::walk_block(self, ast_util::method_body(&**method), ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n                 if method_might_be_inlined(self.tcx, &*method, did) {\n-                    visit::walk_block(self, &*method.body, ())\n+                    visit::walk_block(self, ast_util::method_body(&*method), ())\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "6c6ac81b985303ba6b3dd38eb8a67bf8841953e5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -22,6 +22,7 @@ use util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n \n use syntax::ast::*;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::ast_util::{local_def};\n use syntax::ast_util::{walk_pat, trait_method_to_ty_method};\n use syntax::ext::mtwt;\n@@ -1298,20 +1299,20 @@ impl<'a> Resolver<'a> {\n                         // For each method...\n                         for method in methods.iter() {\n                             // Add the method to the module.\n-                            let ident = method.ident;\n+                            let ident = ast_util::method_ident(&**method);\n                             let method_name_bindings =\n                                 self.add_child(ident,\n                                                new_parent.clone(),\n                                                ForbidDuplicateValues,\n                                                method.span);\n-                            let def = match method.explicit_self.node {\n+                            let def = match ast_util::method_explicit_self(&**method).node {\n                                 SelfStatic => {\n                                     // Static methods become\n                                     // `def_static_method`s.\n                                     DefStaticMethod(local_def(method.id),\n                                                       FromImpl(local_def(\n                                                         item.id)),\n-                                                      method.fn_style)\n+                                                    ast_util::method_fn_style(&**method))\n                                 }\n                                 _ => {\n                                     // Non-static methods become\n@@ -1320,7 +1321,7 @@ impl<'a> Resolver<'a> {\n                                 }\n                             };\n \n-                            let is_public = method.vis == ast::Public;\n+                            let is_public = ast_util::method_vis(&**method) == ast::Public;\n                             method_name_bindings.define_value(def,\n                                                               method.span,\n                                                               is_public);\n@@ -4003,13 +4004,15 @@ impl<'a> Resolver<'a> {\n     fn resolve_method(&mut self,\n                       rib_kind: RibKind,\n                       method: &Method) {\n-        let method_generics = &method.generics;\n+        let method_generics = ast_util::method_generics(method);\n         let type_parameters = HasTypeParameters(method_generics,\n                                                 FnSpace,\n                                                 method.id,\n                                                 rib_kind);\n \n-        self.resolve_function(rib_kind, Some(method.decl), type_parameters, method.body);\n+        self.resolve_function(rib_kind, Some(ast_util::method_fn_decl(method)),\n+                              type_parameters,\n+                              ast_util::method_body(method));\n     }\n \n     fn with_current_self_type<T>(&mut self, self_type: &Ty, f: |&mut Resolver| -> T) -> T {\n@@ -4080,7 +4083,7 @@ impl<'a> Resolver<'a> {\n     fn check_trait_method(&self, method: &Method) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            let method_name = method.ident.name;\n+            let method_name = ast_util::method_ident(method).name;\n \n             if self.method_map.borrow().find(&(method_name, did)).is_none() {\n                 let path_str = self.path_idents_to_string(&trait_ref.path);"}, {"sha": "a492b4ab9525e193ef67e9dced2af4aa342d8db7", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -333,7 +333,7 @@ impl <'l> DxrVisitor<'l> {\n             },\n         };\n \n-        qualname.push_str(get_ident(method.ident).get());\n+        qualname.push_str(get_ident(ast_util::method_ident(&*method)).get());\n         let qualname = qualname.as_slice();\n \n         // record the decl for this def (if it has one)\n@@ -349,17 +349,18 @@ impl <'l> DxrVisitor<'l> {\n                             decl_id,\n                             scope_id);\n \n-        self.process_formals(&method.decl.inputs, qualname, e);\n+        let m_decl = ast_util::method_fn_decl(&*method);\n+        self.process_formals(&m_decl.inputs, qualname, e);\n \n         // walk arg and return types\n-        for arg in method.decl.inputs.iter() {\n+        for arg in m_decl.inputs.iter() {\n             self.visit_ty(&*arg.ty, e);\n         }\n-        self.visit_ty(&*method.decl.output, e);\n+        self.visit_ty(m_decl.output, e);\n         // walk the fn body\n-        self.visit_block(&*method.body, DxrVisitorEnv::new_nested(method.id));\n+        self.visit_block(ast_util::method_body(&*method), DxrVisitorEnv::new_nested(method.id));\n \n-        self.process_generic_params(&method.generics,\n+        self.process_generic_params(ast_util::method_generics(&*method),\n                                     method.span,\n                                     qualname,\n                                     method.id,"}, {"sha": "e3af8f93eadb3590ea50dc40d2ee9a32be786736", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -1138,10 +1138,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n         }\n         ast_map::NodeMethod(ref method) => {\n-            (method.ident,\n-             method.decl,\n-             &method.generics,\n-             method.body,\n+            (ast_util::method_ident(&**method),\n+             ast_util::method_fn_decl(&**method),\n+             ast_util::method_generics(&**method),\n+             ast_util::method_body(&**method),\n              method.span,\n              true)\n         }\n@@ -1167,10 +1167,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeTraitMethod(ref trait_method) => {\n             match **trait_method {\n                 ast::Provided(ref method) => {\n-                    (method.ident,\n-                     method.decl,\n-                     &method.generics,\n-                     method.body,\n+                    (ast_util::method_ident(&**method),\n+                     ast_util::method_fn_decl(&**method),\n+                     ast_util::method_generics(&**method),\n+                     ast_util::method_body(&**method),\n                      method.span,\n                      true)\n                 }"}, {"sha": "f11577482b6dca9ceb3178a171047c53e5a4428b", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -128,11 +128,12 @@ pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n             let unparameterized =\n                 impl_tpt.generics.types.is_empty() &&\n-                mth.generics.ty_params.is_empty();\n+                ast_util::method_generics(&*mth).ty_params.is_empty();\n \n           if unparameterized {\n               let llfn = get_item_val(ccx, mth.id);\n-              trans_fn(ccx, &*mth.decl, &*mth.body, llfn,\n+              trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n+                       ast_util::method_body(&*mth), llfn,\n                        &param_substs::empty(), mth.id, []);\n           }\n           local_def(mth.id)"}, {"sha": "6b54556bbe0ac82644dd25adc68b60d532d9d9cc", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -38,7 +38,7 @@ use std::c_str::ToCStr;\n use std::gc::Gc;\n use syntax::abi::Rust;\n use syntax::parse::token;\n-use syntax::{ast, ast_map, visit};\n+use syntax::{ast, ast_map, visit, ast_util};\n \n /**\n The main \"translation\" pass for methods.  Generates code\n@@ -66,9 +66,10 @@ pub fn trans_impl(ccx: &CrateContext,\n         return;\n     }\n     for method in methods.iter() {\n-        if method.generics.ty_params.len() == 0u {\n+        if ast_util::method_generics(&**method).ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n-            trans_fn(ccx, &*method.decl, &*method.body,\n+            trans_fn(ccx, ast_util::method_fn_decl(&**method),\n+                     ast_util::method_body(&**method),\n                      llfn, &param_substs::empty(), method.id, []);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n@@ -160,7 +161,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n             ast_map::NodeTraitMethod(method) => {\n                 let ident = match *method {\n                     ast::Required(ref m) => m.ident,\n-                    ast::Provided(ref m) => m.ident\n+                    ast::Provided(ref m) => ast_util::method_ident(&**m)\n                 };\n                 ident.name\n             }"}, {"sha": "01544214ccf7ff51d3f4592e74984a8ad04c86df", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -25,6 +25,7 @@ use util::ppaux::Repr;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax::ast_util::local_def;\n use std::hash::{sip, Hash};\n \n@@ -181,15 +182,17 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeMethod(mth) => {\n             let d = mk_lldecl();\n             set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-            trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n+            trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n+                     ast_util::method_body(&*mth), d, &psubsts, mth.id, []);\n             d\n         }\n         ast_map::NodeTraitMethod(method) => {\n             match *method {\n                 ast::Provided(mth) => {\n                     let d = mk_lldecl();\n                     set_llvm_fn_attrs(mth.attrs.as_slice(), d);\n-                    trans_fn(ccx, &*mth.decl, &*mth.body, d, &psubsts, mth.id, []);\n+                    trans_fn(ccx, ast_util::method_fn_decl(&*mth),\n+                             ast_util::method_body(&*mth), d, &psubsts, mth.id, []);\n                     d\n                 }\n                 _ => {"}, {"sha": "fb29baeea73f2c592d5ad99303d1e3865863b82d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -757,14 +757,16 @@ fn check_method_body(ccx: &CrateCtxt,\n     let method_def_id = local_def(method.id);\n     let method_ty = ty::method(ccx.tcx, method_def_id);\n     let method_generics = &method_ty.generics;\n+    let m_body = ast_util::method_body(&*method);\n \n     let param_env = ty::construct_parameter_environment(ccx.tcx,\n                                                         method_generics,\n-                                                        method.body.id);\n+                                                        m_body.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n \n-    check_bare_fn(ccx, &*method.decl, &*method.body, method.id, fty, param_env);\n+    check_bare_fn(ccx, ast_util::method_fn_decl(&*method),\n+                  m_body, method.id, fty, param_env);\n }\n \n fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n@@ -792,7 +794,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                 compare_impl_method(ccx.tcx,\n                                     &*impl_method_ty,\n                                     impl_method.span,\n-                                    impl_method.body.id,\n+                                    ast_util::method_body(&**impl_method).id,\n                                     &**trait_method_ty,\n                                     &impl_trait_ref.substs);\n             }\n@@ -815,7 +817,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n     for trait_method in trait_methods.iter() {\n         let is_implemented =\n             impl_methods.iter().any(\n-                |m| m.ident.name == trait_method.ident.name);\n+                |m| ast_util::method_ident(&**m).name == trait_method.ident.name);\n         let is_provided =\n             provided_methods.iter().any(\n                 |m| m.ident.name == trait_method.ident.name);"}, {"sha": "9f08dc2c924839df6f62db371a154ca097300d08", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -57,7 +57,8 @@ use syntax::ast::{StaticRegionTyParamBound, OtherRegionTyParamBound};\n use syntax::ast::{TraitTyParamBound, UnboxedFnTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, split_trait_methods};\n+use syntax::ast_util;\n+use syntax::ast_util::{local_def, method_ident, split_trait_methods};\n use syntax::codemap::Span;\n use syntax::codemap;\n use syntax::owned_slice::OwnedSlice;\n@@ -213,8 +214,11 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             &ast::Provided(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_def.generics,\n-                                    &m.id, &m.ident, &m.explicit_self,\n-                                    &m.generics, &m.fn_style, &*m.decl)\n+                                    &m.id, &ast_util::method_ident(&**m),\n+                                    ast_util::method_explicit_self(&**m),\n+                                    ast_util::method_generics(&**m),\n+                                    &ast_util::method_fn_style(&**m),\n+                                    ast_util::method_fn_decl(&**m))\n                             }\n                         });\n \n@@ -330,7 +334,7 @@ fn convert_methods(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n     for m in ms.iter() {\n-        if !seen_methods.insert(m.ident.repr(ccx.tcx)) {\n+        if !seen_methods.insert(ast_util::method_ident(&**m).repr(tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n@@ -342,9 +346,9 @@ fn convert_methods(ccx: &CrateCtxt,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n-                m.ident.repr(ccx.tcx),\n+                method_ident(&**m).repr(tcx),\n                 m.id,\n-                fty.repr(ccx.tcx));\n+                fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n             local_def(m.id),\n             Polytype {\n@@ -365,23 +369,24 @@ fn convert_methods(ccx: &CrateCtxt,\n                     rcvr_visibility: ast::Visibility)\n                     -> ty::Method\n     {\n-        let fty = astconv::ty_of_method(ccx, m.id, m.fn_style,\n+        let fty = astconv::ty_of_method(ccx, m.id, ast_util::method_fn_style(&*m),\n                                         untransformed_rcvr_ty,\n-                                        m.explicit_self, &*m.decl);\n+                                        *ast_util::method_explicit_self(&*m),\n+                                        ast_util::method_fn_decl(&*m));\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n         // { fn foo(); }` is public, but private in `priv impl { fn\n         // foo(); }`).\n-        let method_vis = m.vis.inherit_from(rcvr_visibility);\n+        let method_vis = ast_util::method_vis(&*m).inherit_from(rcvr_visibility);\n \n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx, &m.generics,\n+            ty_generics_for_fn_or_method(ccx, ast_util::method_generics(&*m),\n                                          (*rcvr_ty_generics).clone());\n-        ty::Method::new(m.ident,\n+        ty::Method::new(ast_util::method_ident(&*m),\n                         m_ty_generics,\n                         fty,\n-                        m.explicit_self.node,\n+                        ast_util::method_explicit_self(&*m).node,\n                         method_vis,\n                         local_def(m.id),\n                         container,"}, {"sha": "bdd6d96f394a29131e357e47eeb9adf6aff022c7", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -693,15 +693,18 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        ast::ItemFn(ref fn_decl, ref pur, _, ref gen, _) => {\n+                        ast::ItemFn(fn_decl, ref pur, _, ref gen, _) => {\n                             Some((fn_decl, gen, *pur, item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n                 }\n                 ast_map::NodeMethod(ref m) => {\n-                    Some((&m.decl, &m.generics, m.fn_style,\n-                          m.ident, Some(m.explicit_self.node), m.span))\n+                    Some((ast_util::method_fn_decl(&**m),\n+                          ast_util::method_generics(&**m),\n+                          ast_util::method_fn_style(&**m),\n+                          ast_util::method_ident(&**m),\n+                          Some(ast_util::method_explicit_self(&**m).node), m.span))\n                 },\n                 _ => None\n             },\n@@ -711,7 +714,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n         let life_giver = LifeGiver::with_taken(taken.as_slice());\n-        let rebuilder = Rebuilder::new(self.tcx, *fn_decl, expl_self,\n+        let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(&fn_decl, fn_style, ident,\n@@ -1452,7 +1455,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                 _ => None\n             },\n             ast_map::NodeMethod(m) => {\n-                taken.push_all(m.generics.lifetimes.as_slice());\n+                taken.push_all(ast_util::method_generics(&*m).lifetimes.as_slice());\n                 Some(m.id)\n             },\n             _ => None"}, {"sha": "2e3bb2eef7d9df7b77f14a9f1895854ad0bcc5d9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -695,29 +695,30 @@ pub struct Method {\n \n impl Clean<Item> for ast::Method {\n     fn clean(&self) -> Item {\n-        let inputs = match self.explicit_self.node {\n-            ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs.slice_from(1)\n+        let fn_decl = ast_util::method_fn_decl(self);\n+        let inputs = match ast_util::method_explicit_self(self).node {\n+            ast::SelfStatic => fn_decl.inputs.as_slice(),\n+            _ => fn_decl.inputs.slice_from(1)\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n                 values: inputs.iter().map(|x| x.clean()).collect(),\n             },\n-            output: (self.decl.output.clean()),\n-            cf: self.decl.cf.clean(),\n+            output: (fn_decl.output.clean()),\n+            cf: fn_decl.cf.clean(),\n             attrs: Vec::new()\n         };\n         Item {\n-            name: Some(self.ident.clean()),\n+            name: Some(ast_util::method_ident(self).clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n-            visibility: self.vis.clean(),\n+            visibility: ast_util::method_vis(self).clean(),\n             stability: get_stability(ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n-                generics: self.generics.clean(),\n-                self_: self.explicit_self.node.clean(),\n-                fn_style: self.fn_style.clone(),\n+                generics: ast_util::method_generics(self).clean(),\n+                self_: ast_util::method_explicit_self(self).node.clean(),\n+                fn_style: ast_util::method_fn_style(self).clone(),\n                 decl: decl,\n             }),\n         }"}, {"sha": "98318312d58da9884e2ba14ced892813df13a378", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -633,6 +633,8 @@ pub type Mac = Spanned<Mac_>;\n /// There's only one flavor, now, so this could presumably be simplified.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n+    // NB: the additional ident for a macro_rules-style macro is actually\n+    // stored in the enclosing item. Oog.\n     MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n }\n \n@@ -950,19 +952,20 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-// Represents a method declaration\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n-    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub generics: Generics,\n-    pub explicit_self: ExplicitSelf,\n-    pub fn_style: FnStyle,\n-    pub decl: P<FnDecl>,\n-    pub body: P<Block>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub vis: Visibility,\n+    pub node: Method_\n+}\n+\n+#[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n+pub enum Method_ {\n+    /// Represents a method declaration\n+    MethDecl(Ident, Generics, ExplicitSelf, FnStyle, P<FnDecl>, P<Block>, Visibility),\n+    /// Represents a macro in method position\n+    MethMac(Mac),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]"}, {"sha": "d0a0c4fe380f04621b09e8b705c9c2765a914a64", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -304,8 +304,10 @@ impl Map {\n         }\n     }\n \n+    /// returns the name associated with the given NodeId's AST\n     pub fn get_path_elem(&self, id: NodeId) -> PathElem {\n-        match self.get(id) {\n+        let node = self.get(id);\n+        match node {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemMod(_) | ItemForeignMod(_) => {\n@@ -315,13 +317,19 @@ impl Map {\n                 }\n             }\n             NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeMethod(m) => PathName(m.ident.name),\n+            NodeMethod(m) => match m.node {\n+                MethDecl(ident, _, _, _, _, _, _) => PathName(ident.name),\n+                MethMac(_) => fail!(\"no path elem for {:?}\", node)\n+            },\n             NodeTraitMethod(tm) => match *tm {\n                 Required(ref m) => PathName(m.ident.name),\n-                Provided(ref m) => PathName(m.ident.name)\n+                Provided(m) => match m.node {\n+                    MethDecl(ident, _, _, _, _, _, _) => PathName(ident.name),\n+                    MethMac(_) => fail!(\"no path elem for {:?}\", node),\n+                }\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n-            node => fail!(\"no path elem for {:?}\", node)\n+            _ => fail!(\"no path elem for {:?}\", node)\n         }\n     }\n \n@@ -369,6 +377,8 @@ impl Map {\n         }\n     }\n \n+    /// Given a node ID and a closure, apply the closure to the array\n+    /// of attributes associated with the AST corresponding to the Node ID\n     pub fn with_attrs<T>(&self, id: NodeId, f: |Option<&[Attribute]>| -> T) -> T {\n         let node = self.get(id);\n         let attrs = match node {\n@@ -695,11 +705,15 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {} (id={})\", path_str, id)\n         }\n-        Some(NodeMethod(m)) => {\n-            format!(\"method {} in {} (id={})\",\n-                    token::get_ident(m.ident),\n-                    map.path_to_string(id), id)\n-        }\n+        Some(NodeMethod(m)) => match m.node {\n+            MethDecl(ident, _, _, _, _, _, _) =>\n+                format!(\"method {} in {} (id={})\",\n+                        token::get_ident(ident),\n+                        map.path_to_string(id), id),\n+            MethMac(ref mac) =>\n+                format!(\"method macro {} (id={})\",\n+                        pprust::mac_to_string(mac), id)\n+        },\n         Some(NodeTraitMethod(ref tm)) => {\n             let m = ast_util::trait_method_to_ty_method(&**tm);\n             format!(\"method {} in {} (id={})\","}, {"sha": "a18d8a81ef47f7655b9cfb55a99d9656374ae54c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -240,32 +240,31 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n-pub fn public_methods(ms: Vec<Gc<Method>> ) -> Vec<Gc<Method>> {\n-    ms.move_iter().filter(|m| {\n-        match m.vis {\n-            Public => true,\n-            _   => false\n-        }\n-    }).collect()\n-}\n-\n /// extract a TypeMethod from a TraitMethod. if the TraitMethod is\n /// a default, pull out the useful fields to make a TypeMethod\n+//\n+// NB: to be used only after expansion is complete, and macros are gone.\n pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n     match *method {\n         Required(ref m) => (*m).clone(),\n-        Provided(ref m) => {\n-            TypeMethod {\n-                ident: m.ident,\n-                attrs: m.attrs.clone(),\n-                fn_style: m.fn_style,\n-                decl: m.decl,\n-                generics: m.generics.clone(),\n-                explicit_self: m.explicit_self,\n-                id: m.id,\n-                span: m.span,\n-                vis: m.vis,\n+        Provided(m) => {\n+            match m.node {\n+                MethDecl(ident, ref generics, explicit_self, fn_style, decl, _, vis) => {\n+                    TypeMethod {\n+                        ident: ident,\n+                        attrs: m.attrs.clone(),\n+                        fn_style: fn_style,\n+                        decl: decl,\n+                        generics: generics.clone(),\n+                        explicit_self: explicit_self,\n+                        id: m.id,\n+                        span: m.span,\n+                        vis: vis,\n+                    }\n+                },\n+                MethMac(_) => fail!(\"expected non-macro method declaration\")\n             }\n+\n         }\n     }\n }\n@@ -346,6 +345,9 @@ pub trait IdVisitingOperation {\n     fn visit_id(&self, node_id: NodeId);\n }\n \n+/// A visitor that applies its operation to all of the node IDs\n+/// in a visitable thing.\n+\n pub struct IdVisitor<'a, O> {\n     pub operation: &'a O,\n     pub pass_through_items: bool,\n@@ -740,6 +742,38 @@ pub fn static_has_significant_address(mutbl: ast::Mutability,\n     inline == InlineNever || inline == InlineNone\n }\n \n+\n+/// Macro invocations are guaranteed not to occur after expansion is complete.\n+/// extracting fields of a method requires a dynamic check to make sure that it's\n+/// not a macro invocation, though this check is guaranteed to succeed, assuming\n+/// that the invocations are indeed gone.\n+macro_rules! method_field_extractor {\n+    ($fn_name:ident, $field_ty:ty, $field_pat:pat, $result:ident) => {\n+        /// Returns the ident of a Method. To be used after expansion is complete\n+        pub fn $fn_name<'a>(method: &'a ast::Method) -> $field_ty {\n+            match method.node {\n+                $field_pat => $result,\n+                MethMac(_) => {\n+                    fail!(\"expected an AST without macro invocations\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Note: this is unhygienic in the lifetime 'a. In order to fix this, we'd have to\n+// add :lifetime as a macro argument type, so that the 'a could be supplied by the macro\n+// invocation.\n+pub method_field_extractor!(method_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_),ident)\n+pub method_field_extractor!(method_generics,&'a ast::Generics,\n+                            MethDecl(_,ref generics,_,_,_,_,_),generics)\n+pub method_field_extractor!(method_explicit_self,&'a ast::ExplicitSelf,\n+                            MethDecl(_,_,ref explicit_self,_,_,_,_),explicit_self)\n+pub method_field_extractor!(method_fn_style,ast::FnStyle,MethDecl(_,_,_,fn_style,_,_,_),fn_style)\n+pub method_field_extractor!(method_fn_decl,P<ast::FnDecl>,MethDecl(_,_,_,_,decl,_,_),decl)\n+pub method_field_extractor!(method_body,P<ast::Block>,MethDecl(_,_,_,_,_,body,_),body)\n+pub method_field_extractor!(method_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,vis),vis)\n+\n #[cfg(test)]\n mod test {\n     use ast::*;\n@@ -765,3 +799,4 @@ mod test {\n                 .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().as_slice()));\n     }\n }\n+"}, {"sha": "46efdccadec8033d16b185da5a534b31dd8a316e", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -648,16 +648,16 @@ impl<'a> MethodDef<'a> {\n \n         // Create the method.\n         box(GC) ast::Method {\n-            ident: method_ident,\n             attrs: self.attributes.clone(),\n-            generics: fn_generics,\n-            explicit_self: explicit_self,\n-            fn_style: ast::NormalFn,\n-            decl: fn_decl,\n-            body: body_block,\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n-            vis: ast::Inherited,\n+            node: ast::MethDecl(method_ident,\n+                                fn_generics,\n+                                explicit_self,\n+                                ast::NormalFn,\n+                                fn_decl,\n+                                body_block,\n+                                ast::Inherited)\n         }\n     }\n "}, {"sha": "81309181bc01f35c8de3838813ffc3aebb3ad069", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -941,21 +941,25 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n // expand a method\n fn expand_method(m: &ast::Method, fld: &mut MacroExpander) -> Gc<ast::Method> {\n     let id = fld.new_id(m.id);\n-    let (rewritten_fn_decl, rewritten_body)\n-        = expand_and_rename_fn_decl_and_block(m.decl,m.body,fld);\n-\n-    // all of the other standard stuff:\n     box(GC) ast::Method {\n-        id: id,\n-        ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n-        generics: fold_generics(&m.generics, fld),\n-        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n-        fn_style: m.fn_style,\n-        decl: rewritten_fn_decl,\n-        body: rewritten_body,\n+        id: id,\n         span: fld.new_span(m.span),\n-        vis: m.vis\n+        node: match m.node {\n+            ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+                let (rewritten_fn_decl, rewritten_body)\n+                    = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+\n+                ast::MethDecl(fld.fold_ident(ident),\n+                         fold_generics(generics, fld),\n+                         fld.fold_explicit_self(explicit_self),\n+                         fn_style,\n+                         rewritten_fn_decl,\n+                         rewritten_body,\n+                         vis)\n+            },\n+            ast::MethMac(ref _mac) => fail!(\"expansion in method position not implemented yet!\")\n+        }\n     }\n }\n "}, {"sha": "88c8318e1b78bd31051d84ec6a4d5ca05dd9441a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -794,16 +794,21 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> Gc<Method> {\n     let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n     box(GC) Method {\n-        id: id,\n-        ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n-        generics: fold_generics(&m.generics, folder),\n-        explicit_self: folder.fold_explicit_self(&m.explicit_self),\n-        fn_style: m.fn_style,\n-        decl: folder.fold_fn_decl(&*m.decl),\n-        body: folder.fold_block(m.body),\n+        id: id,\n         span: folder.new_span(m.span),\n-        vis: m.vis\n+        node: match m.node {\n+            MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+                MethDecl(folder.fold_ident(ident),\n+                         fold_generics(generics, folder),\n+                         folder.fold_explicit_self(explicit_self),\n+                         fn_style,\n+                         folder.fold_fn_decl(&*decl),\n+                         folder.fold_block(body),\n+                         vis)\n+            },\n+            MethMac(ref mac) => MethMac(folder.fold_mac(mac)),\n+        }\n     }\n }\n "}, {"sha": "cc3a7dc095bd25136e3b1ab9ed890a2661d5b627", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -1249,16 +1249,10 @@ impl<'a> Parser<'a> {\n                     p.parse_inner_attrs_and_block();\n                 let attrs = attrs.append(inner_attrs.as_slice());\n                 Provided(box(GC) ast::Method {\n-                    ident: ident,\n                     attrs: attrs,\n-                    generics: generics,\n-                    explicit_self: explicit_self,\n-                    fn_style: style,\n-                    decl: d,\n-                    body: body,\n                     id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n-                    vis: vis,\n+                    node: ast::MethDecl(ident, generics, explicit_self, style, d, body, vis)\n                 })\n               }\n \n@@ -4049,16 +4043,10 @@ impl<'a> Parser<'a> {\n         let hi = body.span.hi;\n         let attrs = attrs.append(inner_attrs.as_slice());\n         box(GC) ast::Method {\n-            ident: ident,\n             attrs: attrs,\n-            generics: generics,\n-            explicit_self: explicit_self,\n-            fn_style: fn_style,\n-            decl: decl,\n-            body: body,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n-            vis: visa,\n+            node: ast::MethDecl(ident, generics, explicit_self, fn_style, decl, body, visa),\n         }\n     }\n "}, {"sha": "615a4489a73de46041e29694a90db51b2776e962", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -245,6 +245,10 @@ pub fn arg_to_string(arg: &ast::Arg) -> String {\n     to_string(|s| s.print_arg(arg))\n }\n \n+pub fn mac_to_string(arg: &ast::Mac) -> String {\n+    to_string(|s| s.print_mac(arg))\n+}\n+\n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n     match vis {\n         ast::Public => format!(\"pub {}\", s),\n@@ -342,6 +346,7 @@ impl<'a> State<'a> {\n         match self.s.last_token() { pp::End => true, _ => false }\n     }\n \n+    // is this the beginning of a line?\n     pub fn is_bol(&mut self) -> bool {\n         self.s.last_token().is_eof() || self.s.last_token().is_hardbreak_tok()\n     }\n@@ -627,6 +632,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n@@ -998,11 +1004,26 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(&*meth.decl, Some(meth.fn_style), abi::Rust,\n-                        meth.ident, &meth.generics, Some(meth.explicit_self.node),\n-                        meth.vis));\n-        try!(word(&mut self.s, \" \"));\n-        self.print_block_with_attrs(&*meth.body, meth.attrs.as_slice())\n+        match meth.node {\n+            ast::MethDecl(ident, ref generics, ref explicit_self, fn_style, decl, body, vis) => {\n+                try!(self.print_fn(&*decl, Some(fn_style), abi::Rust,\n+                                   ident, generics, Some(explicit_self.node),\n+                                   vis));\n+                try!(word(&mut self.s, \" \"));\n+                self.print_block_with_attrs(&*body, meth.attrs.as_slice())\n+            },\n+            ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n+                                            ..}) => {\n+                // code copied from ItemMac:\n+                try!(self.print_path(pth, false));\n+                try!(word(&mut self.s, \"! \"));\n+                try!(self.cbox(indent_unit));\n+                try!(self.popen());\n+                try!(self.print_tts(tts.as_slice()));\n+                try!(self.pclose());\n+                self.end()\n+            }\n+        }\n     }\n \n     pub fn print_outer_attributes(&mut self,"}, {"sha": "795f19d0cfb06170050fea6da1206a8e09390189", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b4b3122a4af7bf9b361c8f646da4a120e7ba38/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b0b4b3122a4af7bf9b361c8f646da4a120e7ba38", "patch": "@@ -560,15 +560,21 @@ pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,\n pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                    method: &Method,\n                                                    env: E) {\n-    visitor.visit_ident(method.span, method.ident, env.clone());\n-    visitor.visit_fn(&FkMethod(method.ident, &method.generics, method),\n-                     &*method.decl,\n-                     &*method.body,\n-                     method.span,\n-                     method.id,\n-                     env.clone());\n-    for attr in method.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+    match method.node {\n+        MethDecl(ident, ref generics, _, _, decl, body, _) => {\n+            visitor.visit_ident(method.span, ident, env.clone());\n+            visitor.visit_fn(&FkMethod(ident, generics, method),\n+                             decl,\n+                             body,\n+                             method.span,\n+                             method.id,\n+                             env.clone());\n+            for attr in method.attrs.iter() {\n+                visitor.visit_attribute(attr, env.clone());\n+            }\n+\n+        },\n+        MethMac(ref mac) => visitor.visit_mac(mac, env.clone())\n     }\n }\n \n@@ -586,8 +592,12 @@ pub fn walk_fn<E: Clone, V: Visitor<E>>(visitor: &mut V,\n         }\n         FkMethod(_, generics, method) => {\n             visitor.visit_generics(generics, env.clone());\n-\n-            visitor.visit_explicit_self(&method.explicit_self, env.clone());\n+            match method.node {\n+                MethDecl(_, _, ref explicit_self, _, _, _, _) =>\n+                    visitor.visit_explicit_self(explicit_self, env.clone()),\n+                MethMac(ref mac) =>\n+                    visitor.visit_mac(mac, env.clone())\n+            }\n         }\n         FkFnBlock(..) => {}\n     }"}]}