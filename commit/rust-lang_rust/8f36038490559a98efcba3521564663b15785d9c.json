{"sha": "8f36038490559a98efcba3521564663b15785d9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMzYwMzg0OTA1NTlhOThlZmNiYTM1MjE1NjQ2NjNiMTU3ODVkOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T17:09:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-22T17:09:37Z"}, "message": "Auto merge of #31087 - nikomatsakis:incr-comp-fulfillment-cache, r=arielb1\n\nThis is a fix for #30741. It simplifies dep-graph tracking for trait matching. I was experimenting with having a greater resolution here, but decided to pare back to just have one dep node for \"trait resolutions on trait `Foo`\", which means that adding an impl to the trait `Foo` will invalidate all fns that had to do any trait matching at all on `Foo`. This seems like a reasonable starting place.\n\nIndependently, I realized I had neglected to record a dependency from trans on typeck -- this is obviously needed, since trans consumes a bunch of data structures that typeck produces (but which are not currently individually tracked) -- and because trans assumes that typeck has been done. Eventually those are going to go away and be replaced with MIR, which will be tracked, so this edge would presumably be derived automatically then, but it's an obvious enough thing to want for now.\n\nr? @arielb1\n\ncc @michaelwoerister -- this might indirectly fix the problem you observed with the trans cache, though it'd be nice to try and craft an independent test case for that.", "tree": {"sha": "e5647084ffdbecfba7a8068c0c573bcf50dbca09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5647084ffdbecfba7a8068c0c573bcf50dbca09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f36038490559a98efcba3521564663b15785d9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f36038490559a98efcba3521564663b15785d9c", "html_url": "https://github.com/rust-lang/rust/commit/8f36038490559a98efcba3521564663b15785d9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f36038490559a98efcba3521564663b15785d9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1cb0a3508423383250662adb65137be4b86066b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1cb0a3508423383250662adb65137be4b86066b", "html_url": "https://github.com/rust-lang/rust/commit/e1cb0a3508423383250662adb65137be4b86066b"}, {"sha": "56c73e58a24c7106e7160df4624b64bf7672e089", "url": "https://api.github.com/repos/rust-lang/rust/commits/56c73e58a24c7106e7160df4624b64bf7672e089", "html_url": "https://github.com/rust-lang/rust/commit/56c73e58a24c7106e7160df4624b64bf7672e089"}], "stats": {"total": 185, "additions": 139, "deletions": 46}, "files": [{"sha": "3bb73ecca2c43aad946075dbd1ae41c8b4f8f6c2", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -11,7 +11,6 @@\n use self::thread::{DepGraphThreadData, DepMessage};\n use middle::def_id::DefId;\n use middle::ty;\n-use middle::ty::fast_reject::SimplifiedType;\n use rustc_front::hir;\n use rustc_front::intravisit::Visitor;\n use std::rc::Rc;\n@@ -102,7 +101,7 @@ pub enum DepNode {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(DefId),\n     ReprHints(DefId),\n-    TraitSelect(DefId, Option<SimplifiedType>),\n+    TraitSelect(DefId),\n }\n \n #[derive(Clone)]"}, {"sha": "d28504db585c745b5a4c582b2a5b08b0cf1f0ae8", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepGraph;\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n@@ -30,7 +31,12 @@ use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n \n-pub struct FulfilledPredicates<'tcx> {\n+pub struct GlobalFulfilledPredicates<'tcx> {\n+    set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n+    dep_graph: DepGraph,\n+}\n+\n+pub struct LocalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::Predicate<'tcx>>\n }\n \n@@ -56,7 +62,7 @@ pub struct FulfillmentContext<'tcx> {\n     // initially-distinct type variables are unified after being\n     // inserted. Deduplicating the predicate set on selection had a\n     // significant performance cost the last time I checked.\n-    duplicate_set: FulfilledPredicates<'tcx>,\n+    duplicate_set: LocalFulfilledPredicates<'tcx>,\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -106,7 +112,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n-            duplicate_set: FulfilledPredicates::new(),\n+            duplicate_set: LocalFulfilledPredicates::new(),\n             predicates: ObligationForest::new(),\n             region_obligations: NodeMap(),\n         }\n@@ -240,7 +246,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         // local cache).  This is because the tcx cache maintains the\n         // invariant that it only contains things that have been\n         // proven, and we have not yet proven that `predicate` holds.\n-        if predicate.is_global() && tcx.fulfilled_predicates.borrow().is_duplicate(predicate) {\n+        if tcx.fulfilled_predicates.borrow().check_duplicate(predicate) {\n             return true;\n         }\n \n@@ -283,10 +289,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             // these are obligations that were proven to be true.\n             for pending_obligation in outcome.completed {\n                 let predicate = &pending_obligation.obligation.predicate;\n-                if predicate.is_global() {\n-                    selcx.tcx().fulfilled_predicates.borrow_mut()\n-                                                    .is_duplicate_or_add(predicate);\n-                }\n+                selcx.tcx().fulfilled_predicates.borrow_mut().add_if_global(predicate);\n             }\n \n             errors.extend(\n@@ -329,17 +332,16 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             // However, this is a touch tricky, so I'm doing something\n             // a bit hackier for now so that the `huge-struct.rs` passes.\n \n+            let tcx = selcx.tcx();\n+\n             let retain_vec: Vec<_> = {\n                 let mut dedup = FnvHashSet();\n                 v.iter()\n                  .map(|o| {\n                      // Screen out obligations that we know globally\n                      // are true. This should really be the DAG check\n                      // mentioned above.\n-                     if\n-                         o.predicate.is_global() &&\n-                         selcx.tcx().fulfilled_predicates.borrow().is_duplicate(&o.predicate)\n-                     {\n+                     if tcx.fulfilled_predicates.borrow().check_duplicate(&o.predicate) {\n                          return false;\n                      }\n \n@@ -611,22 +613,62 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n \n }\n \n-impl<'tcx> FulfilledPredicates<'tcx> {\n-    pub fn new() -> FulfilledPredicates<'tcx> {\n-        FulfilledPredicates {\n+impl<'tcx> LocalFulfilledPredicates<'tcx> {\n+    pub fn new() -> LocalFulfilledPredicates<'tcx> {\n+        LocalFulfilledPredicates {\n             set: FnvHashSet()\n         }\n     }\n \n-    pub fn is_duplicate(&self, key: &ty::Predicate<'tcx>) -> bool {\n-        self.set.contains(key)\n-    }\n-\n     fn is_duplicate_or_add(&mut self, key: &ty::Predicate<'tcx>) -> bool {\n+        // For a `LocalFulfilledPredicates`, if we find a match, we\n+        // don't need to add a read edge to the dep-graph. This is\n+        // because it means that the predicate has already been\n+        // considered by this `FulfillmentContext`, and hence the\n+        // containing task will already have an edge. (Here we are\n+        // assuming each `FulfillmentContext` only gets used from one\n+        // task; but to do otherwise makes no sense)\n         !self.set.insert(key.clone())\n     }\n }\n \n+impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n+    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'tcx> {\n+        GlobalFulfilledPredicates {\n+            set: FnvHashSet(),\n+            dep_graph: dep_graph,\n+        }\n+    }\n+\n+    pub fn check_duplicate(&self, key: &ty::Predicate<'tcx>) -> bool {\n+        if let ty::Predicate::Trait(ref data) = *key {\n+            // For the global predicate registry, when we find a match, it\n+            // may have been computed by some other task, so we want to\n+            // add a read from the node corresponding to the predicate\n+            // processing to make sure we get the transitive dependencies.\n+            if self.set.contains(data) {\n+                debug_assert!(data.is_global());\n+                self.dep_graph.read(data.dep_node());\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    fn add_if_global(&mut self, key: &ty::Predicate<'tcx>) {\n+        if let ty::Predicate::Trait(ref data) = *key {\n+            // We only add things to the global predicate registry\n+            // after the current task has proved them, and hence\n+            // already has the required read edges, so we don't need\n+            // to add any more edges here.\n+            if data.is_global() {\n+                self.set.insert(data.clone());\n+            }\n+        }\n+    }\n+}\n+\n fn to_fulfillment_error<'tcx>(\n     error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n     -> FulfillmentError<'tcx>"}, {"sha": "f0ff0380aaa3109f1172b12fdc4afbd102d03bab", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -15,12 +15,10 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n-use dep_graph::DepNode;\n use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::ty::{self, Ty, TypeFoldable};\n-use middle::ty::fast_reject;\n use middle::infer::{self, fixup_err_to_string, InferCtxt};\n \n use std::rc::Rc;\n@@ -37,7 +35,7 @@ pub use self::error_reporting::report_object_safety_error;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n-pub use self::fulfill::{FulfillmentContext, FulfilledPredicates, RegionObligation};\n+pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::normalize;\n pub use self::project::Normalized;\n@@ -617,18 +615,6 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n-    /// Creates the dep-node for selecting/evaluating this trait reference.\n-    fn dep_node(&self, tcx: &ty::ctxt<'tcx>) -> DepNode {\n-        let simplified_ty =\n-            fast_reject::simplify_type(tcx,\n-                                       self.predicate.skip_binder().self_ty(), // (*)\n-                                       true);\n-\n-        // (*) skip_binder is ok because `simplify_type` doesn't care about regions\n-\n-        DepNode::TraitSelect(self.predicate.def_id(), simplified_ty)\n-    }\n-\n     fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n         ty::Binder(self.predicate.skip_binder().self_ty())\n     }"}, {"sha": "61418734b674bacc1130ad16708c156ed3e18877", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -307,7 +307,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"select({:?})\", obligation);\n         assert!(!obligation.predicate.has_escaping_regions());\n \n-        let dep_node = obligation.dep_node(self.tcx());\n+        let dep_node = obligation.predicate.dep_node();\n         let _task = self.tcx().dep_graph.in_task(dep_node);\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n@@ -462,7 +462,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // have been proven elsewhere. This cache only contains\n         // predicates that are global in scope and hence unaffected by\n         // the current environment.\n-        if self.tcx().fulfilled_predicates.borrow().is_duplicate(&obligation.predicate) {\n+        if self.tcx().fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n             return EvaluatedToOk;\n         }\n "}, {"sha": "7010bae7ee5bfc7d58bc85fca9bd9dec519adc79", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -367,7 +367,7 @@ pub struct ctxt<'tcx> {\n     /// This is used to avoid duplicate work. Predicates are only\n     /// added to this set when they mention only \"global\" names\n     /// (i.e., no type or lifetime parameters).\n-    pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n+    pub fulfilled_predicates: RefCell<traits::GlobalFulfilledPredicates<'tcx>>,\n \n     /// Caches the representation hints for struct definitions.\n     repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n@@ -510,6 +510,7 @@ impl<'tcx> ctxt<'tcx> {\n         let interner = RefCell::new(FnvHashMap());\n         let common_types = CommonTypes::new(&arenas.type_, &interner);\n         let dep_graph = DepGraph::new(s.opts.incremental_compilation);\n+        let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         tls::enter(ctxt {\n             arenas: arenas,\n             interner: interner,\n@@ -532,7 +533,7 @@ impl<'tcx> ctxt<'tcx> {\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n+            fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n             freevars: RefCell::new(freevars),\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "06ea945a09eb3c0b055e179928127de29a688a8a", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -838,6 +838,11 @@ impl<'tcx> TraitPredicate<'tcx> {\n         self.trait_ref.def_id\n     }\n \n+    /// Creates the dep-node for selecting/evaluating this trait reference.\n+    fn dep_node(&self) -> DepNode {\n+        DepNode::TraitSelect(self.def_id())\n+    }\n+\n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n         self.trait_ref.substs.types.as_slice()\n     }\n@@ -849,8 +854,14 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn def_id(&self) -> DefId {\n+        // ok to skip binder since trait def-id does not care about regions\n         self.0.def_id()\n     }\n+\n+    pub fn dep_node(&self) -> DepNode {\n+        // ok to skip binder since depnode does not care about regions\n+        self.0.dep_node()\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]"}, {"sha": "7460ef82ebee4d493e79f1b49fe5474565c1e3d9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -3323,6 +3323,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n                 // giving `trans_item` access to this item, so also record a read.\n                 tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n                     tcx.dep_graph.read(DepNode::Hir(def_id));\n+\n+                    // We are going to be accessing various tables\n+                    // generated by TypeckItemBody; we also assume\n+                    // that the body passes type check. These tables\n+                    // are not individually tracked, so just register\n+                    // a read here.\n+                    tcx.dep_graph.read(DepNode::TypeckItemBody(def_id));\n+\n                     trans_item(self.ccx, i);\n                 });\n "}, {"sha": "d1ecff5984ac5d76f83f8fb01aabe8edff31fd17", "filename": "src/test/compile-fail/dep-graph-assoc-type-trans.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-trans.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when a trait impl changes, fns whose body uses that trait\n+// must also be recompiled.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    type T;\n+    fn method(self) { }\n+}\n+\n+mod x {\n+    use Foo;\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for char { type T = char; }\n+\n+    impl Foo for u32 { type T = u32; }\n+}\n+\n+mod y {\n+    use Foo;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn use_char_assoc() {\n+        // Careful here: in the representation, <char as Foo>::T gets\n+        // normalized away, so at a certain point we had no edge to\n+        // trans.  (But now trans just depends on typeck.)\n+        let x: <char as Foo>::T = 'a';\n+    }\n+\n+    pub fn take_foo<T:Foo>(t: T) { }\n+}"}, {"sha": "b38fdad9809ed1cb4b57f80a9d6d88e8d163216b", "filename": "src/test/compile-fail/dep-graph-trait-impl.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f36038490559a98efcba3521564663b15785d9c/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f36038490559a98efcba3521564663b15785d9c/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs?ref=8f36038490559a98efcba3521564663b15785d9c", "patch": "@@ -40,9 +40,8 @@ mod y {\n         char::method('a');\n     }\n \n-    // FIXME(#30741) tcx fulfillment cache not tracked\n-    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n-    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n     pub fn take_foo_with_char() {\n         take_foo::<char>('a');\n     }\n@@ -53,9 +52,8 @@ mod y {\n         u32::method(22);\n     }\n \n-    // FIXME(#30741) tcx fulfillment cache not tracked\n-    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n-    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n     pub fn take_foo_with_u32() {\n         take_foo::<u32>(22);\n     }"}]}