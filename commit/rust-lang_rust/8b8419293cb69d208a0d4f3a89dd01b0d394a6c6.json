{"sha": "8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiODQxOTI5M2NiNjlkMjA4YTBkNGYzYTg5ZGQwMWIwZDM5NGE2YzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-02-01T00:42:33Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:49Z"}, "message": "libsyntax: Remove `@str` from the interner", "tree": {"sha": "cef113f731bbd16c556f52242191b744396a7e42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cef113f731bbd16c556f52242191b744396a7e42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "html_url": "https://github.com/rust-lang/rust/commit/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a80fa647ad7f634c9626e7fed1caa618e1fd6cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a80fa647ad7f634c9626e7fed1caa618e1fd6cc", "html_url": "https://github.com/rust-lang/rust/commit/7a80fa647ad7f634c9626e7fed1caa618e1fd6cc"}], "stats": {"total": 168, "additions": 112, "deletions": 56}, "files": [{"sha": "89209ab2104f00780452b0e5cdc69063615bfafb", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "patch": "@@ -62,9 +62,10 @@ pub fn path_to_str_with_sep(p: &[PathElem], sep: &str, itr: @IdentInterner)\n \n pub fn path_ident_to_str(p: &Path, i: Ident, itr: @IdentInterner) -> ~str {\n     if p.is_empty() {\n-        itr.get(i.name).to_owned()\n+        itr.get(i.name).into_owned()\n     } else {\n-        format!(\"{}::{}\", path_to_str(*p, itr), itr.get(i.name))\n+        let string = itr.get(i.name);\n+        format!(\"{}::{}\", path_to_str(*p, itr), string.as_slice())\n     }\n }\n \n@@ -75,7 +76,7 @@ pub fn path_to_str(p: &[PathElem], itr: @IdentInterner) -> ~str {\n pub fn path_elem_to_str(pe: PathElem, itr: @IdentInterner) -> ~str {\n     match pe {\n         PathMod(s) | PathName(s) | PathPrettyName(s, _) => {\n-            itr.get(s.name).to_owned()\n+            itr.get(s.name).into_owned()\n         }\n     }\n }\n@@ -105,7 +106,11 @@ fn pretty_ty(ty: &Ty, itr: @IdentInterner, out: &mut ~str) {\n         // need custom handling.\n         TyNil => { out.push_str(\"$NIL$\"); return }\n         TyPath(ref path, _, _) => {\n-            out.push_str(itr.get(path.segments.last().unwrap().identifier.name));\n+            out.push_str(itr.get(path.segments\n+                                     .last()\n+                                     .unwrap()\n+                                     .identifier\n+                                     .name).as_slice());\n             return\n         }\n         TyTup(ref tys) => {\n@@ -138,7 +143,8 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> PathElem {\n     match *trait_ref {\n         None => pretty = ~\"\",\n         Some(ref trait_ref) => {\n-            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name).to_owned();\n+            pretty = itr.get(trait_ref.path.segments.last().unwrap().identifier.name)\n+                        .into_owned();\n             pretty.push_char('$');\n         }\n     };\n@@ -489,17 +495,21 @@ pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n              path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n       Some(NodeMethod(m, _, path)) => {\n+        let name = itr.get(m.ident.name);\n         format!(\"method {} in {} (id={})\",\n-             itr.get(m.ident.name), path_to_str(*path, itr), id)\n+             name.as_slice(), path_to_str(*path, itr), id)\n       }\n       Some(NodeTraitMethod(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n+        let name = itr.get(m.ident.name);\n         format!(\"method {} in {} (id={})\",\n-             itr.get(m.ident.name), path_to_str(*path, itr), id)\n+             name.as_slice(), path_to_str(*path, itr), id)\n       }\n       Some(NodeVariant(ref variant, _, path)) => {\n+        let name = itr.get(variant.node.name.name);\n         format!(\"variant {} in {} (id={})\",\n-             itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n+             name.as_slice(),\n+             path_to_str(*path, itr), id)\n       }\n       Some(NodeExpr(expr)) => {\n         format!(\"expr {} (id={})\", pprust::expr_to_str(expr, itr), id)"}, {"sha": "dc16f32b872519dfbc42c3681ec58c5b02dced90", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "patch": "@@ -3979,8 +3979,9 @@ impl Parser {\n                 fields.push(self.parse_struct_decl_field());\n             }\n             if fields.len() == 0 {\n+                let string = get_ident_interner().get(class_name.name);\n                 self.fatal(format!(\"Unit-like struct definition should be written as `struct {};`\",\n-                                get_ident_interner().get(class_name.name)));\n+                                   string.as_slice()));\n             }\n             self.bump();\n         } else if self.token == token::LPAREN {"}, {"sha": "eb2fa151f51eb76db5ca48159db718e02abdfc95", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "patch": "@@ -12,7 +12,7 @@ use ast;\n use ast::{P, Name, Mrk};\n use ast_util;\n use parse::token;\n-use util::interner::StrInterner;\n+use util::interner::{RcStr, StrInterner};\n use util::interner;\n \n use extra::serialize::{Decodable, Decoder, Encodable, Encoder};\n@@ -214,8 +214,11 @@ pub fn to_str(input: @IdentInterner, t: &Token) -> ~str {\n       }\n \n       /* Name components */\n-      IDENT(s, _) => input.get(s.name).to_owned(),\n-      LIFETIME(s) => format!(\"'{}\", input.get(s.name)),\n+      IDENT(s, _) => input.get(s.name).into_owned(),\n+      LIFETIME(s) => {\n+          let name = input.get(s.name);\n+          format!(\"'{}\", name.as_slice())\n+      }\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n@@ -549,7 +552,7 @@ pub fn get_ident_interner() -> @IdentInterner {\n #[no_send]\n #[deriving(Clone, Eq, IterBytes, Ord, TotalEq, TotalOrd)]\n pub struct InternedString {\n-    priv string: @str,\n+    priv string: RcStr,\n }\n \n #[unsafe_destructor]\n@@ -563,13 +566,12 @@ impl InternedString {\n     #[inline]\n     pub fn new(string: &'static str) -> InternedString {\n         InternedString {\n-            string: string.to_managed(),\n+            string: RcStr::new(string),\n         }\n     }\n \n-    // NB: Do not make this public. We are trying to remove `@str`.\n     #[inline]\n-    fn new_from_at_str(string: @str) -> InternedString {\n+    fn new_from_rc_str(string: RcStr) -> InternedString {\n         InternedString {\n             string: string,\n         }\n@@ -594,7 +596,7 @@ impl BytesContainer for InternedString {\n \n impl fmt::Default for InternedString {\n     fn fmt(obj: &InternedString, f: &mut fmt::Formatter) {\n-        write!(f.buf, \"{}\", obj.string);\n+        write!(f.buf, \"{}\", obj.string.as_slice());\n     }\n }\n \n@@ -613,7 +615,7 @@ impl<D:Decoder> Decodable<D> for InternedString {\n \n impl<E:Encoder> Encodable<E> for InternedString {\n     fn encode(&self, e: &mut E) {\n-        e.emit_str(self.string)\n+        e.emit_str(self.string.as_slice())\n     }\n }\n \n@@ -622,7 +624,7 @@ impl<E:Encoder> Encodable<E> for InternedString {\n #[inline]\n pub fn get_ident(idx: Name) -> InternedString {\n     let interner = get_ident_interner();\n-    InternedString::new_from_at_str(interner.get(idx))\n+    InternedString::new_from_rc_str(interner.get(idx))\n }\n \n /// Interns and returns the string contents of an identifier, using the"}, {"sha": "e20efda9c6eccbdba410eb87ef056ee2ccaa49be", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 80, "deletions": 37, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b8419293cb69d208a0d4f3a89dd01b0d394a6c6/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=8b8419293cb69d208a0d4f3a89dd01b0d394a6c6", "patch": "@@ -18,6 +18,7 @@ use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n use std::hashmap::HashMap;\n+use std::rc::Rc;\n \n pub struct Interner<T> {\n     priv map: @RefCell<HashMap<T, Name>>,\n@@ -83,11 +84,49 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     }\n }\n \n+#[deriving(Clone, Eq, IterBytes, Ord)]\n+pub struct RcStr {\n+    priv string: Rc<~str>,\n+}\n+\n+impl TotalEq for RcStr {\n+    fn equals(&self, other: &RcStr) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl TotalOrd for RcStr {\n+    fn cmp(&self, other: &RcStr) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n+}\n+\n+impl Str for RcStr {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        let s: &'a str = *self.string.borrow();\n+        s\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        self.string.borrow().to_owned()\n+    }\n+}\n+\n+impl RcStr {\n+    pub fn new(string: &str) -> RcStr {\n+        RcStr {\n+            string: Rc::new(string.to_owned()),\n+        }\n+    }\n+}\n+\n // A StrInterner differs from Interner<String> in that it accepts\n // references rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n-    priv map: @RefCell<HashMap<@str, Name>>,\n-    priv vect: @RefCell<~[@str]>,\n+    priv map: @RefCell<HashMap<RcStr, Name>>,\n+    priv vect: @RefCell<~[RcStr]>,\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n@@ -113,8 +152,8 @@ impl StrInterner {\n         }\n \n         let new_idx = self.len() as Name;\n-        let val = val.to_managed();\n-        map.get().insert(val, new_idx);\n+        let val = RcStr::new(val);\n+        map.get().insert(val.clone(), new_idx);\n         let mut vect = self.vect.borrow_mut();\n         vect.get().push(val);\n         new_idx\n@@ -124,7 +163,7 @@ impl StrInterner {\n         let new_idx = self.len() as Name;\n         // leave out of .map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        vect.get().push(val.to_managed());\n+        vect.get().push(RcStr::new(val));\n         new_idx\n     }\n \n@@ -142,21 +181,21 @@ impl StrInterner {\n         let new_idx = self.len() as Name;\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = vect.get()[idx];\n+        let existing = vect.get()[idx].clone();\n         vect.get().push(existing);\n         new_idx\n     }\n \n-    pub fn get(&self, idx: Name) -> @str {\n+    pub fn get(&self, idx: Name) -> RcStr {\n         let vect = self.vect.borrow();\n-        vect.get()[idx]\n+        vect.get()[idx].clone()\n     }\n \n     /// Returns this string with lifetime tied to the interner. Since\n     /// strings may never be removed from the interner, this is safe.\n     pub fn get_ref<'a>(&'a self, idx: Name) -> &'a str {\n         let vect = self.vect.borrow();\n-        let s: &str = vect.get()[idx];\n+        let s: &str = vect.get()[idx].as_slice();\n         unsafe {\n             cast::transmute(s)\n         }\n@@ -167,7 +206,7 @@ impl StrInterner {\n         vect.get().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<RcStr>>(&self, val: &Q)\n                                                          -> Option<Name> {\n         let map = self.map.borrow();\n         match map.get().find_equiv(val) {\n@@ -183,42 +222,46 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn i1 () {\n-        let i : Interner<@str> = Interner::new();\n+        let i : Interner<RcStr> = Interner::new();\n         i.get(13);\n     }\n \n     #[test]\n     fn interner_tests () {\n-        let i : Interner<@str> = Interner::new();\n+        let i : Interner<RcStr> = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern(@\"dog\"), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n         // re-use gets the same entry:\n-        assert_eq!(i.intern(@\"dog\"), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n         // different string gets a different #:\n-        assert_eq!(i.intern(@\"cat\"), 1);\n-        assert_eq!(i.intern(@\"cat\"), 1);\n+        assert_eq!(i.intern(RcStr::new(\"cat\")), 1);\n+        assert_eq!(i.intern(RcStr::new(\"cat\")), 1);\n         // dog is still at zero\n-        assert_eq!(i.intern(@\"dog\"), 0);\n+        assert_eq!(i.intern(RcStr::new(\"dog\")), 0);\n         // gensym gets 3\n-        assert_eq!(i.gensym(@\"zebra\" ), 2);\n+        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), 2);\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym (@\"zebra\" ), 3);\n+        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), 3);\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(@\"dog\"), 4);\n-        assert_eq!(i.get(0), @\"dog\");\n-        assert_eq!(i.get(1), @\"cat\");\n-        assert_eq!(i.get(2), @\"zebra\");\n-        assert_eq!(i.get(3), @\"zebra\");\n-        assert_eq!(i.get(4), @\"dog\");\n+        assert_eq!(i.gensym(RcStr::new(\"dog\")), 4);\n+        assert_eq!(i.get(0), RcStr::new(\"dog\"));\n+        assert_eq!(i.get(1), RcStr::new(\"cat\"));\n+        assert_eq!(i.get(2), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(3), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(4), RcStr::new(\"dog\"));\n     }\n \n     #[test]\n     fn i3 () {\n-        let i : Interner<@str> = Interner::prefill([@\"Alan\",@\"Bob\",@\"Carol\"]);\n-        assert_eq!(i.get(0), @\"Alan\");\n-        assert_eq!(i.get(1), @\"Bob\");\n-        assert_eq!(i.get(2), @\"Carol\");\n-        assert_eq!(i.intern(@\"Bob\"), 1);\n+        let i : Interner<@~str> = Interner::prefill([\n+            RcStr::new(\"Alan\"),\n+            RcStr::new(\"Bob\"),\n+            RcStr::new(\"Carol\")\n+        ]);\n+        assert_eq!(i.get(0), RcStr::new(\"Alan\"));\n+        assert_eq!(i.get(1), RcStr::new(\"Bob\"));\n+        assert_eq!(i.get(2), RcStr::new(\"Carol\"));\n+        assert_eq!(i.intern(RcStr::new(\"Bob\")), 1);\n     }\n \n     #[test]\n@@ -241,13 +284,13 @@ mod tests {\n         assert_eq!(i.gensym(\"dog\"), 4);\n         // gensym tests again with gensym_copy:\n         assert_eq!(i.gensym_copy(2), 5);\n-        assert_eq!(i.get(5), @\"zebra\");\n+        assert_eq!(i.get(5), RcStr::new(\"zebra\"));\n         assert_eq!(i.gensym_copy(2), 6);\n-        assert_eq!(i.get(6), @\"zebra\");\n-        assert_eq!(i.get(0), @\"dog\");\n-        assert_eq!(i.get(1), @\"cat\");\n-        assert_eq!(i.get(2), @\"zebra\");\n-        assert_eq!(i.get(3), @\"zebra\");\n-        assert_eq!(i.get(4), @\"dog\");\n+        assert_eq!(i.get(6), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(0), RcStr::new(\"dog\"));\n+        assert_eq!(i.get(1), RcStr::new(\"cat\"));\n+        assert_eq!(i.get(2), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(3), RcStr::new(\"zebra\"));\n+        assert_eq!(i.get(4), RcStr::new(\"dog\"));\n     }\n }"}]}