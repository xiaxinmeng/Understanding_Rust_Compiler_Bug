{"sha": "ca87d24467c46c07961f1b6450dabfb9674913da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhODdkMjQ0NjdjNDZjMDc5NjFmMWI2NDUwZGFiZmI5Njc0OTEzZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-21T15:55:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-13T15:22:07Z"}, "message": "introduce `infcx.at(..).dropck_outlives(..)` operaton [VIC]\n\nBacked by a canonicalized query. This computes all the types/regions that need\nto be live when the destructor runs (i.e., that the dtor may access).", "tree": {"sha": "f386f8d42d501af1f28539acc9be2195102672f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f386f8d42d501af1f28539acc9be2195102672f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca87d24467c46c07961f1b6450dabfb9674913da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca87d24467c46c07961f1b6450dabfb9674913da", "html_url": "https://github.com/rust-lang/rust/commit/ca87d24467c46c07961f1b6450dabfb9674913da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca87d24467c46c07961f1b6450dabfb9674913da/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87", "html_url": "https://github.com/rust-lang/rust/commit/3a50b41da4cbb135fc74cdc8ebf2b09edb396f87"}], "stats": {"total": 861, "additions": 560, "deletions": 301}, "files": [{"sha": "130fbc192677fdd10ae5f359b766ef2bcc9422a9", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -70,7 +70,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use std::fmt;\n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;\n-use traits::query::CanonicalProjectionGoal;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};\n use ty::subst::Substs;\n \n@@ -637,6 +637,8 @@ define_dep_nodes!( <'tcx>\n     [input] OutputFilenames,\n     [anon] NormalizeTy,\n     [] NormalizeProjectionTy(CanonicalProjectionGoal<'tcx>),\n+    [] NormalizeTyAfterErasingRegions(ParamEnvAnd<'tcx, Ty<'tcx>>),\n+    [] DropckOutlives(CanonicalTyGoal<'tcx>),\n \n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n "}, {"sha": "4eb4f0edafe40981f2f8e77a63c2311f033df8fb", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -1017,12 +1017,6 @@ impl_stable_hash_for!(struct ty::Destructor {\n     did\n });\n \n-impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n-    outlives,\n-    dtorck_types\n-});\n-\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "5c964f6559a3f8b0eff1c494e58123708bdf117f", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::at::At;\n+use infer::canonical::{Canonical, Canonicalize, QueryResult};\n+use infer::InferOk;\n+use std::iter::FromIterator;\n+use traits::query::CanonicalTyGoal;\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Kind;\n+use std::rc::Rc;\n+\n+impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n+    /// Given a type `ty` of some value being dropped, computes a set\n+    /// of \"kinds\" (types, regions) that must be outlive the execution\n+    /// of the destructor. These basically correspond to data that the\n+    /// destructor might access. This is used during regionck to\n+    /// impose \"outlives\" constraints on any lifetimes referenced\n+    /// within.\n+    ///\n+    /// The rules here are given by the \"dropck\" RFCs, notably [#1238]\n+    /// and [#1327]. This is a fixed-point computation, where we\n+    /// explore all the data that will be dropped (transitively) when\n+    /// a value of type `ty` is dropped. For each type T that will be\n+    /// dropped and which has a destructor, we must assume that all\n+    /// the types/regions of T are live during the destructor, unless\n+    /// they are marked with a special attribute (`#[may_dangle]`).\n+    ///\n+    /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n+    /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n+    pub fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<Kind<'tcx>>> {\n+        debug!(\n+            \"dropck_outlives(ty={:?}, param_env={:?})\",\n+            ty, self.param_env,\n+        );\n+\n+        let tcx = self.infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+        let (c_ty, orig_values) = self.infcx.canonicalize_query(&self.param_env.and(ty));\n+        let span = self.cause.span;\n+        match &gcx.dropck_outlives(c_ty) {\n+            Ok(result) if result.is_proven() => {\n+                match self.infcx.instantiate_query_result(\n+                    self.cause,\n+                    self.param_env,\n+                    &orig_values,\n+                    result,\n+                ) {\n+                    Ok(InferOk {\n+                        value: DropckOutlivesResult { kinds, overflows },\n+                        obligations,\n+                    }) => {\n+                        for overflow_ty in overflows.into_iter().take(1) {\n+                            let mut err = struct_span_err!(\n+                                tcx.sess,\n+                                span,\n+                                E0320,\n+                                \"overflow while adding drop-check rules for {}\",\n+                                self.infcx.resolve_type_vars_if_possible(&ty),\n+                            );\n+                            err.note(&format!(\"overflowed on {}\", overflow_ty));\n+                            err.emit();\n+                        }\n+\n+                        return InferOk {\n+                            value: kinds,\n+                            obligations,\n+                        };\n+                    }\n+\n+                    Err(_) => { /* fallthrough to error-handling code below */ }\n+                }\n+            }\n+\n+            _ => { /* fallthrough to error-handling code below */ }\n+        }\n+\n+        // Errors and ambiuity in dropck occur in two cases:\n+        // - unresolved inference variables at the end of typeck\n+        // - non well-formed types where projections cannot be resolved\n+        // Either of these should hvae created an error before.\n+        tcx.sess\n+            .delay_span_bug(span, \"dtorck encountered internal error\");\n+        return InferOk {\n+            value: vec![],\n+            obligations: vec![],\n+        };\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct DropckOutlivesResult<'tcx> {\n+    pub kinds: Vec<Kind<'tcx>>,\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+/// A set of constraints that need to be satisfied in order for\n+/// a type to be valid for destruction.\n+#[derive(Clone, Debug)]\n+pub struct DtorckConstraint<'tcx> {\n+    /// Types that are required to be alive in order for this\n+    /// type to be valid for destruction.\n+    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n+\n+    /// Types that could not be resolved: projections and params.\n+    pub dtorck_types: Vec<Ty<'tcx>>,\n+\n+    /// If, during the computation of the dtorck constraint, we\n+    /// overflow, that gets recorded here. The caller is expected to\n+    /// report an error.\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> DtorckConstraint<'tcx> {\n+    pub fn empty() -> DtorckConstraint<'tcx> {\n+        DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![],\n+            overflows: vec![],\n+        }\n+    }\n+}\n+\n+impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n+    fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n+        let mut result = Self::empty();\n+\n+        for DtorckConstraint {\n+            outlives,\n+            dtorck_types,\n+            overflows,\n+        } in iter\n+        {\n+            result.outlives.extend(outlives);\n+            result.dtorck_types.extend(dtorck_types);\n+            result.overflows.extend(overflows);\n+        }\n+\n+        result\n+    }\n+}\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, Ty<'tcx>> {\n+    type Canonicalized = CanonicalTyGoal<'gcx>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for DropckOutlivesResult<'tcx> {\n+        kinds, overflows\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for DropckOutlivesResult<'a> {\n+        type Lifted = DropckOutlivesResult<'tcx>;\n+        kinds, overflows\n+    }\n+}\n+\n+impl_stable_hash_for!(struct DropckOutlivesResult<'tcx> {\n+    kinds, overflows\n+});\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for QueryResult<'tcx, DropckOutlivesResult<'tcx>> {\n+    // we ought to intern this, but I'm too lazy just now\n+    type Canonicalized = Rc<Canonical<'gcx, QueryResult<'gcx, DropckOutlivesResult<'gcx>>>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        Rc::new(value)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n+    outlives,\n+    dtorck_types,\n+    overflows\n+});"}, {"sha": "607344f9c67817e372a0b97b701f91b909ffde82", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -16,13 +16,16 @@\n //! `librustc_traits`.\n \n use infer::canonical::Canonical;\n-use ty;\n+use ty::{self, Ty};\n \n+pub mod dropck_outlives;\n pub mod normalize;\n \n pub type CanonicalProjectionGoal<'tcx> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n \n+pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct NoSolution;\n "}, {"sha": "24d3b37f804eed3a00c2c3d7fced48873df38a2c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -106,7 +106,6 @@ pub struct GlobalArenas<'tcx> {\n     tables: TypedArena<ty::TypeckTables<'tcx>>,\n     /// miri allocations\n     const_allocs: TypedArena<interpret::Allocation>,\n-\n }\n \n impl<'tcx> GlobalArenas<'tcx> {"}, {"sha": "bcd6a5ace627da6b062014799243879750123723", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -11,7 +11,7 @@\n use dep_graph::SerializedDepNodeIndex;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use mir::interpret::{GlobalId};\n-use traits::query::CanonicalProjectionGoal;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::maps::queries;\n@@ -61,6 +61,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::normalize_projection_ty<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::dropck_outlives<'tcx> {\n+    fn describe(_tcx: TyCtxt, goal: CanonicalTyGoal<'tcx>) -> String {\n+        format!(\"computing dropck types for `{:?}`\", goal)\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)"}, {"sha": "b8167ec918638be880a6bc0351e98c105208dd01", "filename": "src/librustc/ty/maps/keys.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -11,7 +11,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n-use traits::query::CanonicalProjectionGoal;\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n@@ -181,3 +181,13 @@ impl<'tcx> Key for CanonicalProjectionGoal<'tcx> {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for CanonicalTyGoal<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "4df15b2e76be853c021799ea055af48e2ae9185c", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -34,7 +34,8 @@ use mir::interpret::{GlobalId};\n use session::{CompileResult, CrateDisambiguator};\n use session::config::OutputFilenames;\n use traits::Vtable;\n-use traits::query::{CanonicalProjectionGoal, NoSolution};\n+use traits::query::{CanonicalProjectionGoal, CanonicalTyGoal, NoSolution};\n+use traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n use traits::query::normalize::NormalizationResult;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n@@ -114,7 +115,9 @@ define_maps! { <'tcx>\n     [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n     [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] fn adt_dtorck_constraint: DtorckConstraint(\n+        DefId\n+    ) -> Result<DtorckConstraint<'tcx>, NoSolution>,\n \n     /// True if this is a const fn\n     [] fn is_const_fn: IsConstFn(DefId) -> bool,\n@@ -391,6 +394,14 @@ define_maps! { <'tcx>\n         NoSolution,\n     >,\n \n+    /// Do not call this query directly: invoke `infcx.at().dropck_outlives()` instead.\n+    [] fn dropck_outlives: DropckOutlives(\n+        CanonicalTyGoal<'tcx>\n+    ) -> Result<\n+        Lrc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>,\n+        NoSolution,\n+    >,\n+\n     [] fn substitute_normalize_and_test_predicates:\n         substitute_normalize_and_test_predicates_node((DefId, &'tcx Substs<'tcx>)) -> bool,\n "}, {"sha": "64b17922049a158b0b8cc119e4697fd2c5a5ffba", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -774,6 +774,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::EraseRegionsTy |\n         DepKind::NormalizeTy |\n         DepKind::NormalizeProjectionTy |\n+        DepKind::DropckOutlives |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::InstanceDefSizeEstimate |\n "}, {"sha": "8d38d7dbbbbff6e3594f0319a727f991197a06ea", "filename": "src/librustc/ty/maps/values.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -35,12 +35,6 @@ impl<'tcx> Value<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        Self::empty()\n-    }\n-}\n-\n impl<'tcx> Value<'tcx> for ty::SymbolName {\n     fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }"}, {"sha": "fc1d26b0e09100e665d14406012f27b8e1fbb9f5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 79, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -34,15 +34,13 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n-use util::common::ErrorReported;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::cell::RefCell;\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::iter::FromIterator;\n use std::ops::Deref;\n use rustc_data_structures::sync::Lrc;\n use std::slice;\n@@ -2661,38 +2659,6 @@ fn adt_sized_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result\n }\n \n-/// Calculates the dtorck constraint for a type.\n-fn adt_dtorck_constraint<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   def_id: DefId)\n-                                   -> DtorckConstraint<'tcx> {\n-    let def = tcx.adt_def(def_id);\n-    let span = tcx.def_span(def_id);\n-    debug!(\"dtorck_constraint: {:?}\", def);\n-\n-    if def.is_phantom_data() {\n-        let result = DtorckConstraint {\n-            outlives: vec![],\n-            dtorck_types: vec![\n-                tcx.mk_param_from_def(&tcx.generics_of(def_id).types[0])\n-           ]\n-        };\n-        debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n-        return result;\n-    }\n-\n-    let mut result = def.all_fields()\n-        .map(|field| tcx.type_of(field.did))\n-        .map(|fty| tcx.dtorck_constraint_for_ty(span, fty, 0, fty))\n-        .collect::<Result<DtorckConstraint, ErrorReported>>()\n-        .unwrap_or(DtorckConstraint::empty());\n-    result.outlives.extend(tcx.destructor_constraints(def));\n-    result.dedup();\n-\n-    debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n-\n-    result\n-}\n-\n fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> Lrc<Vec<DefId>> {\n@@ -2808,7 +2774,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         adt_sized_constraint,\n-        adt_dtorck_constraint,\n         def_span,\n         param_env,\n         trait_of_item,\n@@ -2831,49 +2796,6 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Lrc<Vec<DefId>>>,\n }\n \n-/// A set of constraints that need to be satisfied in order for\n-/// a type to be valid for destruction.\n-#[derive(Clone, Debug)]\n-pub struct DtorckConstraint<'tcx> {\n-    /// Types that are required to be alive in order for this\n-    /// type to be valid for destruction.\n-    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n-    /// Types that could not be resolved: projections and params.\n-    pub dtorck_types: Vec<Ty<'tcx>>,\n-}\n-\n-impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx>\n-{\n-    fn from_iter<I: IntoIterator<Item=DtorckConstraint<'tcx>>>(iter: I) -> Self {\n-        let mut result = Self::empty();\n-\n-        for constraint in iter {\n-            result.outlives.extend(constraint.outlives);\n-            result.dtorck_types.extend(constraint.dtorck_types);\n-        }\n-\n-        result\n-    }\n-}\n-\n-\n-impl<'tcx> DtorckConstraint<'tcx> {\n-    fn empty() -> DtorckConstraint<'tcx> {\n-        DtorckConstraint {\n-            outlives: vec![],\n-            dtorck_types: vec![]\n-        }\n-    }\n-\n-    fn dedup<'a>(&mut self) {\n-        let mut outlives = FxHashSet();\n-        let mut dtorck_types = FxHashSet();\n-\n-        self.outlives.retain(|&val| outlives.replace(val).is_none());\n-        self.dtorck_types.retain(|&val| dtorck_types.replace(val).is_none());\n-    }\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub struct SymbolName {\n     // FIXME: we don't rely on interning or equality here - better have"}, {"sha": "753f89d8cd2932a042afa7d0452f8610b460efbb", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 94, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -19,7 +19,7 @@ use middle::const_val::ConstVal;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::TypeVisitor;\n-use ty::subst::{Subst, UnpackedKind};\n+use ty::subst::UnpackedKind;\n use ty::maps::TyCtxtAt;\n use ty::TypeVariants::*;\n use ty::layout::Integer;\n@@ -537,99 +537,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Return a set of constraints that needs to be satisfied in\n-    /// order for `ty` to be valid for destruction.\n-    pub fn dtorck_constraint_for_ty(self,\n-                                    span: Span,\n-                                    for_ty: Ty<'tcx>,\n-                                    depth: usize,\n-                                    ty: Ty<'tcx>)\n-                                    -> Result<ty::DtorckConstraint<'tcx>, ErrorReported>\n-    {\n-        debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\",\n-               span, for_ty, depth, ty);\n-\n-        if depth >= self.sess.recursion_limit.get() {\n-            let mut err = struct_span_err!(\n-                self.sess, span, E0320,\n-                \"overflow while adding drop-check rules for {}\", for_ty);\n-            err.note(&format!(\"overflowed on {}\", ty));\n-            err.emit();\n-            return Err(ErrorReported);\n-        }\n-\n-        let result = match ty.sty {\n-            ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-            ty::TyFloat(_) | ty::TyStr | ty::TyNever | ty::TyForeign(..) |\n-            ty::TyRawPtr(..) | ty::TyRef(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) |\n-            ty::TyGeneratorWitness(..) => {\n-                // these types never have a destructor\n-                Ok(ty::DtorckConstraint::empty())\n-            }\n-\n-            ty::TyArray(ety, _) | ty::TySlice(ety) => {\n-                // single-element containers, behave like their element\n-                self.dtorck_constraint_for_ty(span, for_ty, depth+1, ety)\n-            }\n-\n-            ty::TyTuple(tys, _) => {\n-                tys.iter().map(|ty| {\n-                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n-                }).collect()\n-            }\n-\n-            ty::TyClosure(def_id, substs) => {\n-                substs.upvar_tys(def_id, self).map(|ty| {\n-                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n-                }).collect()\n-            }\n-\n-            ty::TyGenerator(def_id, substs, _) => {\n-                // Note that the interior types are ignored here.\n-                // Any type reachable inside the interior must also be reachable\n-                // through the upvars.\n-                substs.upvar_tys(def_id, self).map(|ty| {\n-                    self.dtorck_constraint_for_ty(span, for_ty, depth+1, ty)\n-                }).collect()\n-            }\n-\n-            ty::TyAdt(def, substs) => {\n-                let ty::DtorckConstraint {\n-                    dtorck_types, outlives\n-                } = self.at(span).adt_dtorck_constraint(def.did);\n-                Ok(ty::DtorckConstraint {\n-                    // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n-                    // there, but that needs some way to handle cycles.\n-                    dtorck_types: dtorck_types.subst(self, substs),\n-                    outlives: outlives.subst(self, substs)\n-                })\n-            }\n-\n-            // Objects must be alive in order for their destructor\n-            // to be called.\n-            ty::TyDynamic(..) => Ok(ty::DtorckConstraint {\n-                outlives: vec![ty.into()],\n-                dtorck_types: vec![],\n-            }),\n-\n-            // Types that can't be resolved. Pass them forward.\n-            ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => {\n-                Ok(ty::DtorckConstraint {\n-                    outlives: vec![],\n-                    dtorck_types: vec![ty],\n-                })\n-            }\n-\n-            ty::TyInfer(..) | ty::TyError => {\n-                self.sess.delay_span_bug(span, \"unresolved type in dtorck\");\n-                Err(ErrorReported)\n-            }\n-        };\n-\n-        debug!(\"dtorck_constraint_for_ty({:?}) = {:?}\", ty, result);\n-        result\n-    }\n-\n     pub fn is_closure(self, def_id: DefId) -> bool {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n     }"}, {"sha": "d19fd2bb5969dfc353142cfda186e5f93c19e8da", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 24, "deletions": 67, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -14,13 +14,9 @@ use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::mir::Local;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::traits;\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc::infer::InferOk;\n-use rustc::util::common::ErrorReported;\n use borrow_check::nll::type_check::AtLocation;\n-use rustc_data_structures::fx::FxHashSet;\n-use syntax::codemap::DUMMY_SP;\n use util::liveness::LivenessResults;\n \n use super::TypeChecker;\n@@ -193,73 +189,34 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         //\n         // For this reason, we avoid calling TypeChecker.normalize, instead doing all normalization\n         // ourselves in one large 'fully_perform_op' callback.\n-        let (type_constraints, kind_constraints) = self.cx.fully_perform_op(location.at_self(),\n-            |cx| {\n-\n-            let tcx = cx.infcx.tcx;\n-            let mut selcx = traits::SelectionContext::new(cx.infcx);\n-            let cause = cx.misc(cx.last_span);\n-\n-            let mut types = vec![(dropped_ty, 0)];\n-            let mut final_obligations = Vec::new();\n-            let mut type_constraints = Vec::new();\n-            let mut kind_constraints = Vec::new();\n-\n-            let mut known = FxHashSet();\n-\n-            while let Some((ty, depth)) = types.pop() {\n-                let span = DUMMY_SP; // FIXME\n-                let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n-                    Ok(result) => result,\n-                    Err(ErrorReported) => {\n-                        continue;\n-                    }\n-                };\n-\n-                let ty::DtorckConstraint {\n-                    outlives,\n-                    dtorck_types,\n-                } = result;\n-\n-                // All things in the `outlives` array may be touched by\n-                // the destructor and must be live at this point.\n-                for outlive in outlives {\n+        let kind_constraints = self.cx\n+            .fully_perform_op(location.at_self(), |cx| {\n+                let span = cx.last_span;\n+\n+                let mut final_obligations = Vec::new();\n+                let mut kind_constraints = Vec::new();\n+\n+                let InferOk {\n+                    value: kinds,\n+                    obligations,\n+                } = cx.infcx\n+                    .at(&cx.misc(span), cx.param_env)\n+                    .dropck_outlives(dropped_ty);\n+                for kind in kinds {\n+                    // All things in the `outlives` array may be touched by\n+                    // the destructor and must be live at this point.\n                     let cause = Cause::DropVar(dropped_local, location);\n-                    kind_constraints.push((outlive, location, cause));\n+                    kind_constraints.push((kind, location, cause));\n                 }\n \n-                // However, there may also be some types that\n-                // `dtorck_constraint_for_ty` could not resolve (e.g.,\n-                // associated types and parameters). We need to normalize\n-                // associated types here and possibly recursively process.\n-                for ty in dtorck_types {\n-                    let traits::Normalized { value: ty, obligations } =\n-                        traits::normalize(&mut selcx, cx.param_env, cause.clone(), &ty);\n-\n-                    final_obligations.extend(obligations);\n+                final_obligations.extend(obligations);\n \n-                    let ty = cx.infcx.resolve_type_and_region_vars_if_possible(&ty);\n-                    match ty.sty {\n-                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                            let cause = Cause::DropVar(dropped_local, location);\n-                            type_constraints.push((ty, location, cause));\n-                        }\n-\n-                        _ => if known.insert(ty) {\n-                            types.push((ty, depth + 1));\n-                        },\n-                    }\n-                }\n-            }\n-\n-            Ok(InferOk {\n-                value: (type_constraints, kind_constraints), obligations: final_obligations\n+                Ok(InferOk {\n+                    value: kind_constraints,\n+                    obligations: final_obligations,\n+                })\n             })\n-        }).unwrap();\n-\n-        for (ty, location, cause) in type_constraints {\n-            self.push_type_live_constraint(ty, location, cause);\n-        }\n+            .unwrap();\n \n         for (kind, location, cause) in kind_constraints {\n             self.push_type_live_constraint(kind, location, cause);"}, {"sha": "2274f3942bdbcf4d40df5a84f8dbe768aae160fa", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -0,0 +1,285 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::infer::canonical::{Canonical, QueryResult};\n+use rustc::hir::def_id::DefId;\n+use rustc::traits::{FulfillmentContext, Normalized, ObligationCause};\n+use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n+use rustc::traits::query::dropck_outlives::{DtorckConstraint, DropckOutlivesResult};\n+use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::ty::subst::Subst;\n+use rustc::util::nodemap::FxHashSet;\n+use std::rc::Rc;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use util;\n+\n+crate fn dropck_outlives<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    goal: CanonicalTyGoal<'tcx>,\n+) -> Result<Rc<Canonical<'tcx, QueryResult<'tcx, DropckOutlivesResult<'tcx>>>>, NoSolution> {\n+    debug!(\"dropck_outlives(goal={:#?})\", goal);\n+\n+    tcx.infer_ctxt().enter(|ref infcx| {\n+        let tcx = infcx.tcx;\n+        let (\n+            ParamEnvAnd {\n+                param_env,\n+                value: for_ty,\n+            },\n+            canonical_inference_vars,\n+        ) = infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &goal);\n+\n+        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+        // A stack of types left to process. Each round, we pop\n+        // something from the stack and invoke\n+        // `dtorck_constraint_for_ty`. This may produce new types that\n+        // have to be pushed on the stack. This continues until we have explored\n+        // all the reachable types from the type `for_ty`.\n+        //\n+        // Example: Imagine that we have the following code:\n+        //\n+        // ```rust\n+        // struct A {\n+        //     value: B,\n+        //     children: Vec<A>,\n+        // }\n+        //\n+        // struct B {\n+        //     value: u32\n+        // }\n+        //\n+        // fn f() {\n+        //   let a: A = ...;\n+        //   ..\n+        // } // here, `a` is dropped\n+        // ```\n+        //\n+        // at the point where `a` is dropped, we need to figure out\n+        // which types inside of `a` contain region data that may be\n+        // accessed by any destructors in `a`. We begin by pushing `A`\n+        // onto the stack, as that is the type of `a`. We will then\n+        // invoke `dtorck_constraint_for_ty` which will expand `A`\n+        // into the types of its fields `(B, Vec<A>)`. These will get\n+        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+        // lead to us trying to push `A` a second time -- to prevent\n+        // infinite recusion, we notice that `A` was already pushed\n+        // once and stop.\n+        let mut ty_stack = vec![(for_ty, 0)];\n+\n+        // Set used to detect infinite recursion.\n+        let mut ty_set = FxHashSet();\n+\n+        let fulfill_cx = &mut FulfillmentContext::new();\n+\n+        let cause = ObligationCause::dummy();\n+        while let Some((ty, depth)) = ty_stack.pop() {\n+            let DtorckConstraint {\n+                dtorck_types,\n+                outlives,\n+                overflows,\n+            } = dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty)?;\n+\n+            // \"outlives\" represent types/regions that may be touched\n+            // by a destructor.\n+            result.kinds.extend(outlives);\n+            result.overflows.extend(overflows);\n+\n+            // dtorck types are \"types that will get dropped but which\n+            // do not themselves define a destructor\", more or less. We have\n+            // to push them onto the stack to be expanded.\n+            for ty in dtorck_types {\n+                match infcx.at(&cause, param_env).normalize(&ty) {\n+                    Ok(Normalized {\n+                        value: ty,\n+                        obligations,\n+                    }) => {\n+                        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+                        debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                        match ty.sty {\n+                            // All parameters live for the duration of the\n+                            // function.\n+                            ty::TyParam(..) => {}\n+\n+                            // A projection that we couldn't resolve - it\n+                            // might have a destructor.\n+                            ty::TyProjection(..) | ty::TyAnon(..) => {\n+                                result.kinds.push(ty.into());\n+                            }\n+\n+                            _ => {\n+                                if ty_set.insert(ty) {\n+                                    ty_stack.push((ty, depth + 1));\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // We don't actually expect to fail to normalize.\n+                    // That implies a WF error somewhere else.\n+                    Err(NoSolution) => {\n+                        return Err(NoSolution);\n+                    }\n+                }\n+            }\n+        }\n+\n+        debug!(\"dropck_outlives: result = {:#?}\", result);\n+\n+        util::make_query_response(infcx, canonical_inference_vars, result, fulfill_cx)\n+    })\n+}\n+\n+/// Return a set of constraints that needs to be satisfied in\n+/// order for `ty` to be valid for destruction.\n+fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    span: Span,\n+    for_ty: Ty<'tcx>,\n+    depth: usize,\n+    ty: Ty<'tcx>,\n+) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+    debug!(\n+        \"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\",\n+        span, for_ty, depth, ty\n+    );\n+\n+    if depth >= tcx.sess.recursion_limit.get() {\n+        return Ok(DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![],\n+            overflows: vec![ty],\n+        });\n+    }\n+\n+    let result = match ty.sty {\n+        ty::TyBool\n+        | ty::TyChar\n+        | ty::TyInt(_)\n+        | ty::TyUint(_)\n+        | ty::TyFloat(_)\n+        | ty::TyStr\n+        | ty::TyNever\n+        | ty::TyForeign(..)\n+        | ty::TyRawPtr(..)\n+        | ty::TyRef(..)\n+        | ty::TyFnDef(..)\n+        | ty::TyFnPtr(_)\n+        | ty::TyGeneratorWitness(..) => {\n+            // these types never have a destructor\n+            Ok(DtorckConstraint::empty())\n+        }\n+\n+        ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+            // single-element containers, behave like their element\n+            dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety)\n+        }\n+\n+        ty::TyTuple(tys, _) => tys.iter()\n+            .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+            .collect(),\n+\n+        ty::TyClosure(def_id, substs) => substs\n+            .upvar_tys(def_id, tcx)\n+            .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+            .collect(),\n+\n+        ty::TyGenerator(def_id, substs, _) => {\n+            // Note that the interior types are ignored here.\n+            // Any type reachable inside the interior must also be reachable\n+            // through the upvars.\n+            substs\n+                .upvar_tys(def_id, tcx)\n+                .map(|ty| dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty))\n+                .collect()\n+        }\n+\n+        ty::TyAdt(def, substs) => {\n+            let DtorckConstraint {\n+                dtorck_types,\n+                outlives,\n+                overflows,\n+            } = tcx.at(span).adt_dtorck_constraint(def.did)?;\n+            Ok(DtorckConstraint {\n+                // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+                // there, but that needs some way to handle cycles.\n+                dtorck_types: dtorck_types.subst(tcx, substs),\n+                outlives: outlives.subst(tcx, substs),\n+                overflows: overflows.subst(tcx, substs),\n+            })\n+        }\n+\n+        // Objects must be alive in order for their destructor\n+        // to be called.\n+        ty::TyDynamic(..) => Ok(DtorckConstraint {\n+            outlives: vec![ty.into()],\n+            dtorck_types: vec![],\n+            overflows: vec![],\n+        }),\n+\n+        // Types that can't be resolved. Pass them forward.\n+        ty::TyProjection(..) | ty::TyAnon(..) | ty::TyParam(..) => Ok(DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![ty],\n+            overflows: vec![],\n+        }),\n+\n+        ty::TyInfer(..) | ty::TyError => {\n+            // By the time this code runs, all type variables ought to\n+            // be fully resolved.\n+            Err(NoSolution)\n+        }\n+    };\n+\n+    debug!(\"dtorck_constraint_for_ty({:?}) = {:?}\", ty, result);\n+    result\n+}\n+\n+/// Calculates the dtorck constraint for a type.\n+crate fn adt_dtorck_constraint<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+    let def = tcx.adt_def(def_id);\n+    let span = tcx.def_span(def_id);\n+    debug!(\"dtorck_constraint: {:?}\", def);\n+\n+    if def.is_phantom_data() {\n+        let result = DtorckConstraint {\n+            outlives: vec![],\n+            dtorck_types: vec![tcx.mk_param_from_def(&tcx.generics_of(def_id).types[0])],\n+            overflows: vec![],\n+        };\n+        debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+        return Ok(result);\n+    }\n+\n+    let mut result = def.all_fields()\n+        .map(|field| tcx.type_of(field.did))\n+        .map(|fty| dtorck_constraint_for_ty(tcx, span, fty, 0, fty))\n+        .collect::<Result<DtorckConstraint, NoSolution>>()?;\n+    result.outlives.extend(tcx.destructor_constraints(def));\n+    dedup_dtorck_constraint(&mut result);\n+\n+    debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n+\n+    Ok(result)\n+}\n+\n+fn dedup_dtorck_constraint<'tcx>(c: &mut DtorckConstraint<'tcx>) {\n+    let mut outlives = FxHashSet();\n+    let mut dtorck_types = FxHashSet();\n+\n+    c.outlives.retain(|&val| outlives.replace(val).is_none());\n+    c.dtorck_types\n+        .retain(|&val| dtorck_types.replace(val).is_none());\n+}"}, {"sha": "59083dcfbf0f446fa87c86e6170b6408875e5cac", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -24,13 +24,16 @@ extern crate rustc_data_structures;\n extern crate syntax;\n extern crate syntax_pos;\n \n+mod dropck_outlives;\n mod normalize_projection_ty;\n mod util;\n \n use rustc::ty::maps::Providers;\n \n pub fn provide(p: &mut Providers) {\n     *p = Providers {\n+        dropck_outlives: dropck_outlives::dropck_outlives,\n+        adt_dtorck_constraint: dropck_outlives::adt_dtorck_constraint,\n         normalize_projection_ty: normalize_projection_ty::normalize_projection_ty,\n         ..*p\n     };"}, {"sha": "67c9832cbf9f467337e57e6d6894822b02096eb2", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -18,8 +18,8 @@ use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause};\n use util::common::ErrorReported;\n-use util::nodemap::FxHashSet;\n \n+use syntax::ast;\n use syntax_pos::Span;\n \n /// check_drop_impl confirms that the Drop implementation identified by\n@@ -282,6 +282,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n+    body_id: ast::NodeId,\n     scope: region::Scope)\n     -> Result<(), ErrorReported>\n {\n@@ -297,46 +298,15 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     };\n     let parent_scope = rcx.tcx.mk_region(ty::ReScope(parent_scope));\n     let origin = || infer::SubregionOrigin::SafeDestructor(span);\n-\n-    let ty = rcx.fcx.resolve_type_vars_if_possible(&ty);\n-    let for_ty = ty;\n-    let mut types = vec![(ty, 0)];\n-    let mut known = FxHashSet();\n-    while let Some((ty, depth)) = types.pop() {\n-        let ty::DtorckConstraint {\n-            dtorck_types, outlives\n-        } = rcx.tcx.dtorck_constraint_for_ty(span, for_ty, depth, ty)?;\n-\n-        for ty in dtorck_types {\n-            let ty = rcx.fcx.normalize_associated_types_in(span, &ty);\n-            let ty = rcx.fcx.resolve_type_vars_with_obligations(ty);\n-            let ty = rcx.fcx.resolve_type_and_region_vars_if_possible(&ty);\n-            match ty.sty {\n-                // All parameters live for the duration of the\n-                // function.\n-                ty::TyParam(..) => {}\n-\n-                // A projection that we couldn't resolve - it\n-                // might have a destructor.\n-                ty::TyProjection(..) | ty::TyAnon(..) => {\n-                    rcx.type_must_outlive(origin(), ty, parent_scope);\n-                }\n-\n-                _ => {\n-                    if let None = known.replace(ty) {\n-                        types.push((ty, depth+1));\n-                    }\n-                }\n-            }\n-        }\n-\n-        for outlive in outlives {\n-            match outlive.unpack() {\n-                UnpackedKind::Lifetime(lt) => rcx.sub_regions(origin(), parent_scope, lt),\n-                UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n-            }\n+    let cause = &ObligationCause::misc(span, body_id);\n+    let infer_ok = rcx.infcx.at(cause, rcx.fcx.param_env).dropck_outlives(ty);\n+    debug!(\"dropck_outlives = {:#?}\", infer_ok);\n+    let kinds = rcx.fcx.register_infer_ok_obligations(infer_ok);\n+    for kind in kinds {\n+        match kind.unpack() {\n+            UnpackedKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n+            UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n         }\n     }\n-\n     Ok(())\n }"}, {"sha": "9ed4ab45a1ba7dd19c22d9a5e3ebd95e76107e9f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca87d24467c46c07961f1b6450dabfb9674913da/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ca87d24467c46c07961f1b6450dabfb9674913da", "patch": "@@ -411,8 +411,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n             let typ = self.resolve_node_type(hir_id);\n+            let body_id = self.body_id;\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n-                self, typ, span, var_scope);\n+                self, typ, span, body_id, var_scope);\n         })\n     }\n }\n@@ -884,8 +885,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n+                        let body_id = self.body_id;\n                         let _ = dropck::check_safety_of_destructor_if_necessary(\n-                            self, typ, span, rvalue_scope);\n+                            self, typ, span, body_id, rvalue_scope);\n                     }\n                     ty::ReStatic => {}\n                     _ => {"}]}