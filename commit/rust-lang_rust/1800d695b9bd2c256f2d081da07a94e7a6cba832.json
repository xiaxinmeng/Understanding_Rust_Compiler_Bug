{"sha": "1800d695b9bd2c256f2d081da07a94e7a6cba832", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MDBkNjk1YjliZDJjMjU2ZjJkMDgxZGEwN2E5NGU3YTZjYmE4MzI=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-05T16:26:58Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-11T22:13:52Z"}, "message": "Move char conversions into a separate private module.", "tree": {"sha": "8fd80e8d9b141db95a38924325f0642469aa570e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fd80e8d9b141db95a38924325f0642469aa570e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1800d695b9bd2c256f2d081da07a94e7a6cba832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1800d695b9bd2c256f2d081da07a94e7a6cba832", "html_url": "https://github.com/rust-lang/rust/commit/1800d695b9bd2c256f2d081da07a94e7a6cba832", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1800d695b9bd2c256f2d081da07a94e7a6cba832/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "955450212aac9c2babd6cb511974092224fcf93d", "url": "https://api.github.com/repos/rust-lang/rust/commits/955450212aac9c2babd6cb511974092224fcf93d", "html_url": "https://github.com/rust-lang/rust/commit/955450212aac9c2babd6cb511974092224fcf93d"}], "stats": {"total": 605, "additions": 315, "deletions": 290}, "files": [{"sha": "150562a4a9b290019c62835286f05573291b345c", "filename": "src/libcore/char/convert.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/1800d695b9bd2c256f2d081da07a94e7a6cba832/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1800d695b9bd2c256f2d081da07a94e7a6cba832/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=1800d695b9bd2c256f2d081da07a94e7a6cba832", "patch": "@@ -0,0 +1,304 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Character conversions.\n+\n+use convert::TryFrom;\n+use fmt;\n+use mem::transmute;\n+use str::FromStr;\n+use super::MAX;\n+\n+/// Converts a `u32` to a `char`.\n+///\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n+/// [`as`]:\n+///\n+/// ```\n+/// let c = '\ud83d\udcaf';\n+/// let i = c as u32;\n+///\n+/// assert_eq!(128175, i);\n+/// ```\n+///\n+/// However, the reverse is not true: not all valid [`u32`]s are valid\n+/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n+/// for a [`char`].\n+///\n+/// [`char`]: ../../std/primitive.char.html\n+/// [`u32`]: ../../std/primitive.u32.html\n+/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n+///\n+/// For an unsafe version of this function which ignores these checks, see\n+/// [`from_u32_unchecked`].\n+///\n+/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(0x2764);\n+///\n+/// assert_eq!(Some('\u2764'), c);\n+/// ```\n+///\n+/// Returning `None` when the input is not a valid [`char`]:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_u32(0x110000);\n+///\n+/// assert_eq!(None, c);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_u32(i: u32) -> Option<char> {\n+    char::try_from(i).ok()\n+}\n+\n+/// Converts a `u32` to a `char`, ignoring validity.\n+///\n+/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n+/// [`as`]:\n+///\n+/// ```\n+/// let c = '\ud83d\udcaf';\n+/// let i = c as u32;\n+///\n+/// assert_eq!(128175, i);\n+/// ```\n+///\n+/// However, the reverse is not true: not all valid [`u32`]s are valid\n+/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n+/// [`char`], possibly creating an invalid one.\n+///\n+/// [`char`]: ../../std/primitive.char.html\n+/// [`u32`]: ../../std/primitive.u32.html\n+/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n+///\n+/// # Safety\n+///\n+/// This function is unsafe, as it may construct invalid `char` values.\n+///\n+/// For a safe version of this function, see the [`from_u32`] function.\n+///\n+/// [`from_u32`]: fn.from_u32.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n+///\n+/// assert_eq!('\u2764', c);\n+/// ```\n+#[inline]\n+#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n+pub unsafe fn from_u32_unchecked(i: u32) -> char {\n+    transmute(i)\n+}\n+\n+#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n+impl From<char> for u32 {\n+    #[inline]\n+    fn from(c: char) -> Self {\n+        c as u32\n+    }\n+}\n+\n+/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n+///\n+/// Unicode is designed such that this effectively decodes bytes\n+/// with the character encoding that IANA calls ISO-8859-1.\n+/// This encoding is compatible with ASCII.\n+///\n+/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n+/// which leaves some \"blanks\", byte values that are not assigned to any character.\n+/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n+///\n+/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n+/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n+/// to punctuation and various Latin characters.\n+///\n+/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n+/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n+/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n+/// C0 and C1 control codes.\n+#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n+impl From<u8> for char {\n+    #[inline]\n+    fn from(i: u8) -> Self {\n+        i as char\n+    }\n+}\n+\n+\n+/// An error which can be returned when parsing a char.\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct ParseCharError {\n+    kind: CharErrorKind,\n+}\n+\n+impl ParseCharError {\n+    #[unstable(feature = \"char_error_internals\",\n+               reason = \"this method should not be available publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            CharErrorKind::EmptyString => {\n+                \"cannot parse char from empty string\"\n+            },\n+            CharErrorKind::TooManyChars => \"too many characters in string\"\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum CharErrorKind {\n+    EmptyString,\n+    TooManyChars,\n+}\n+\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+impl fmt::Display for ParseCharError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}\n+\n+\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+impl FromStr for char {\n+    type Err = ParseCharError;\n+\n+    #[inline]\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let mut chars = s.chars();\n+        match (chars.next(), chars.next()) {\n+            (None, _) => {\n+                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n+            },\n+            (Some(c), None) => Ok(c),\n+            _ => {\n+                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n+            }\n+        }\n+    }\n+}\n+\n+\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+impl TryFrom<u32> for char {\n+    type Error = CharTryFromError;\n+\n+    #[inline]\n+    fn try_from(i: u32) -> Result<Self, Self::Error> {\n+        if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n+            Err(CharTryFromError(()))\n+        } else {\n+            Ok(unsafe { from_u32_unchecked(i) })\n+        }\n+    }\n+}\n+\n+/// The error type returned when a conversion from u32 to char fails.\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct CharTryFromError(());\n+\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+impl fmt::Display for CharTryFromError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"converted integer out of range for `char`\".fmt(f)\n+    }\n+}\n+\n+/// Converts a digit in the given radix to a `char`.\n+///\n+/// A 'radix' here is sometimes also called a 'base'. A radix of two\n+/// indicates a binary number, a radix of ten, decimal, and a radix of\n+/// sixteen, hexadecimal, to give some common values. Arbitrary\n+/// radices are supported.\n+///\n+/// `from_digit()` will return `None` if the input is not a digit in\n+/// the given radix.\n+///\n+/// # Panics\n+///\n+/// Panics if given a radix larger than 36.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(4, 10);\n+///\n+/// assert_eq!(Some('4'), c);\n+///\n+/// // Decimal 11 is a single digit in base 16\n+/// let c = char::from_digit(11, 16);\n+///\n+/// assert_eq!(Some('b'), c);\n+/// ```\n+///\n+/// Returning `None` when the input is not a digit:\n+///\n+/// ```\n+/// use std::char;\n+///\n+/// let c = char::from_digit(20, 10);\n+///\n+/// assert_eq!(None, c);\n+/// ```\n+///\n+/// Passing a large radix, causing a panic:\n+///\n+/// ```\n+/// use std::thread;\n+/// use std::char;\n+///\n+/// let result = thread::spawn(|| {\n+///     // this panics\n+///     let c = char::from_digit(1, 37);\n+/// }).join();\n+///\n+/// assert!(result.is_err());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n+    if radix > 36 {\n+        panic!(\"from_digit: radix is too high (maximum 36)\");\n+    }\n+    if num < radix {\n+        let num = num as u8;\n+        if num < 10 {\n+            Some((b'0' + num) as char)\n+        } else {\n+            Some((b'a' + num - 10) as char)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+"}, {"sha": "01a7b49ac7446acbbe72106713163dfbb29cf43f", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 11, "deletions": 290, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/1800d695b9bd2c256f2d081da07a94e7a6cba832/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1800d695b9bd2c256f2d081da07a94e7a6cba832/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=1800d695b9bd2c256f2d081da07a94e7a6cba832", "patch": "@@ -15,11 +15,20 @@\n #![allow(non_snake_case)]\n #![stable(feature = \"core_char\", since = \"1.2.0\")]\n \n-mod printable;\n+mod convert;\n mod decode;\n+mod printable;\n \n // stable re-exports\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::convert::{from_u32, from_digit};\n+#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n+pub use self::convert::from_u32_unchecked;\n+#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n+pub use self::convert::ParseCharError;\n+#[stable(feature = \"try_from\", since = \"1.26.0\")]\n+pub use self::convert::CharTryFromError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use unicode::char::{ToLowercase, ToUppercase};\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n@@ -33,12 +42,10 @@ pub use unicode::version::UnicodeVersion;\n pub use self::decode::{decode_utf8, DecodeUtf8, InvalidSequence};\n \n use self::printable::is_printable;\n-use convert::TryFrom;\n use fmt::{self, Write};\n use slice;\n-use str::{from_utf8_unchecked_mut, FromStr};\n+use str::from_utf8_unchecked_mut;\n use iter::FusedIterator;\n-use mem::transmute;\n \n // UTF-8 ranges and tags for encoding characters\n const TAG_CONT: u8    = 0b1000_0000;\n@@ -102,292 +109,6 @@ pub const MAX: char = '\\u{10ffff}';\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n \n-/// Converts a `u32` to a `char`.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// [`as`]:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32()` will return `None` if the input is not a valid value\n-/// for a [`char`].\n-///\n-/// [`char`]: ../../std/primitive.char.html\n-/// [`u32`]: ../../std/primitive.u32.html\n-/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n-///\n-/// For an unsafe version of this function which ignores these checks, see\n-/// [`from_u32_unchecked`].\n-///\n-/// [`from_u32_unchecked`]: fn.from_u32_unchecked.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x2764);\n-///\n-/// assert_eq!(Some('\u2764'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a valid [`char`]:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_u32(0x110000);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_u32(i: u32) -> Option<char> {\n-    char::try_from(i).ok()\n-}\n-\n-/// Converts a `u32` to a `char`, ignoring validity.\n-///\n-/// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n-/// [`as`]:\n-///\n-/// ```\n-/// let c = '\ud83d\udcaf';\n-/// let i = c as u32;\n-///\n-/// assert_eq!(128175, i);\n-/// ```\n-///\n-/// However, the reverse is not true: not all valid [`u32`]s are valid\n-/// [`char`]s. `from_u32_unchecked()` will ignore this, and blindly cast to\n-/// [`char`], possibly creating an invalid one.\n-///\n-/// [`char`]: ../../std/primitive.char.html\n-/// [`u32`]: ../../std/primitive.u32.html\n-/// [`as`]: ../../book/first-edition/casting-between-types.html#as\n-///\n-/// # Safety\n-///\n-/// This function is unsafe, as it may construct invalid `char` values.\n-///\n-/// For a safe version of this function, see the [`from_u32`] function.\n-///\n-/// [`from_u32`]: fn.from_u32.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = unsafe { char::from_u32_unchecked(0x2764) };\n-///\n-/// assert_eq!('\u2764', c);\n-/// ```\n-#[inline]\n-#[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n-pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-    transmute(i)\n-}\n-\n-#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-impl From<char> for u32 {\n-    #[inline]\n-    fn from(c: char) -> Self {\n-        c as u32\n-    }\n-}\n-\n-/// Maps a byte in 0x00...0xFF to a `char` whose code point has the same value, in U+0000 to U+00FF.\n-///\n-/// Unicode is designed such that this effectively decodes bytes\n-/// with the character encoding that IANA calls ISO-8859-1.\n-/// This encoding is compatible with ASCII.\n-///\n-/// Note that this is different from ISO/IEC 8859-1 a.k.a. ISO 8859-1 (with one less hyphen),\n-/// which leaves some \"blanks\", byte values that are not assigned to any character.\n-/// ISO-8859-1 (the IANA one) assigns them to the C0 and C1 control codes.\n-///\n-/// Note that this is *also* different from Windows-1252 a.k.a. code page 1252,\n-/// which is a superset ISO/IEC 8859-1 that assigns some (not all!) blanks\n-/// to punctuation and various Latin characters.\n-///\n-/// To confuse things further, [on the Web](https://encoding.spec.whatwg.org/)\n-/// `ascii`, `iso-8859-1`, and `windows-1252` are all aliases\n-/// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n-/// C0 and C1 control codes.\n-#[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-impl From<u8> for char {\n-    #[inline]\n-    fn from(i: u8) -> Self {\n-        i as char\n-    }\n-}\n-\n-\n-/// An error which can be returned when parsing a char.\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub struct ParseCharError {\n-    kind: CharErrorKind,\n-}\n-\n-impl ParseCharError {\n-    #[unstable(feature = \"char_error_internals\",\n-               reason = \"this method should not be available publicly\",\n-               issue = \"0\")]\n-    #[doc(hidden)]\n-    pub fn __description(&self) -> &str {\n-        match self.kind {\n-            CharErrorKind::EmptyString => {\n-                \"cannot parse char from empty string\"\n-            },\n-            CharErrorKind::TooManyChars => \"too many characters in string\"\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum CharErrorKind {\n-    EmptyString,\n-    TooManyChars,\n-}\n-\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-impl fmt::Display for ParseCharError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.__description().fmt(f)\n-    }\n-}\n-\n-\n-#[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-impl FromStr for char {\n-    type Err = ParseCharError;\n-\n-    #[inline]\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        let mut chars = s.chars();\n-        match (chars.next(), chars.next()) {\n-            (None, _) => {\n-                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n-            },\n-            (Some(c), None) => Ok(c),\n-            _ => {\n-                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n-            }\n-        }\n-    }\n-}\n-\n-\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-impl TryFrom<u32> for char {\n-    type Error = CharTryFromError;\n-\n-    #[inline]\n-    fn try_from(i: u32) -> Result<Self, Self::Error> {\n-        if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n-            Err(CharTryFromError(()))\n-        } else {\n-            Ok(unsafe { from_u32_unchecked(i) })\n-        }\n-    }\n-}\n-\n-/// The error type returned when a conversion from u32 to char fails.\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct CharTryFromError(());\n-\n-#[stable(feature = \"try_from\", since = \"1.26.0\")]\n-impl fmt::Display for CharTryFromError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"converted integer out of range for `char`\".fmt(f)\n-    }\n-}\n-\n-/// Converts a digit in the given radix to a `char`.\n-///\n-/// A 'radix' here is sometimes also called a 'base'. A radix of two\n-/// indicates a binary number, a radix of ten, decimal, and a radix of\n-/// sixteen, hexadecimal, to give some common values. Arbitrary\n-/// radices are supported.\n-///\n-/// `from_digit()` will return `None` if the input is not a digit in\n-/// the given radix.\n-///\n-/// # Panics\n-///\n-/// Panics if given a radix larger than 36.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(4, 10);\n-///\n-/// assert_eq!(Some('4'), c);\n-///\n-/// // Decimal 11 is a single digit in base 16\n-/// let c = char::from_digit(11, 16);\n-///\n-/// assert_eq!(Some('b'), c);\n-/// ```\n-///\n-/// Returning `None` when the input is not a digit:\n-///\n-/// ```\n-/// use std::char;\n-///\n-/// let c = char::from_digit(20, 10);\n-///\n-/// assert_eq!(None, c);\n-/// ```\n-///\n-/// Passing a large radix, causing a panic:\n-///\n-/// ```\n-/// use std::thread;\n-/// use std::char;\n-///\n-/// let result = thread::spawn(|| {\n-///     // this panics\n-///     let c = char::from_digit(1, 37);\n-/// }).join();\n-///\n-/// assert!(result.is_err());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n-    if radix > 36 {\n-        panic!(\"from_digit: radix is too high (maximum 36)\");\n-    }\n-    if num < radix {\n-        let num = num as u8;\n-        if num < 10 {\n-            Some((b'0' + num) as char)\n-        } else {\n-            Some((b'a' + num - 10) as char)\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n // NB: the stabilization and documentation for this trait is in\n // unicode/char.rs, not here\n #[allow(missing_docs)] // docs in libunicode/u_char.rs"}]}