{"sha": "dde825db464b08d6f572766579dfb629b837368c", "node_id": "C_kwDOAAsO6NoAKGRkZTgyNWRiNDY0YjA4ZDZmNTcyNzY2NTc5ZGZiNjI5YjgzNzM2OGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-17T22:12:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-17T22:12:34Z"}, "message": "Auto merge of #89841 - cormacrelf:let-else-typed, r=nagisa\n\nImplement let-else type annotations natively\n\nTracking issue: #87335\n\nFixes #89688, fixes #89807, edit: fixes  #89960 as well\n\nAs explained in https://github.com/rust-lang/rust/issues/89688#issuecomment-940405082, the previous desugaring moved the let-else scrutinee into a dummy variable, which meant if you wanted to refer to it again in the else block, it had moved.\n\nThis introduces a new hir type, ~~`hir::LetExpr`~~ `hir::Let`, which takes over all the fields of `hir::ExprKind::Let(...)` and adds an optional type annotation. The `hir::Let` is then treated like a `hir::Local` when type checking a function body, specifically:\n\n* `GatherLocalsVisitor` overrides a new `Visitor::visit_let_expr` and does pretty much exactly what it does for `visit_local`, assigning a local type to the `hir::Let` ~~(they could be deduplicated but they are right next to each other, so at least we know they're the same)~~\n* It reuses the code in `check_decl_local` to typecheck the `hir::Let`, simply returning 'bool' for the expression type after doing that.\n\n* ~~`FnCtxt::check_expr_let` passes this local type in to `demand_scrutinee_type`, and then imitates check_decl_local's pattern checking~~\n* ~~`demand_scrutinee_type` (the blindest change for me, please give this extra scrutiny) uses this local type instead of of creating a new one~~\n    * ~~Just realised the `check_expr_with_needs` was passing NoExpectation further down, need to pass the type there too. And apparently this Expectation API already exists.~~\n\nSome other misc notes:\n\n* ~~Is the clippy code supposed to be autoformatted? I tried not to give huge diffs but maybe some rustfmt changes simply haven't hit it yet.~~\n* in `rustc_ast_lowering/src/block.rs`, I noticed some existing `self.alias_attrs()` calls in `LoweringContext::lower_stmts` seem to be copying attributes from the lowered locals/etc to the statements. Is that right? I'm new at this, I don't know.", "tree": {"sha": "d10ae64adc03c0baadf998ef99b4a18c4c850ae7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10ae64adc03c0baadf998ef99b4a18c4c850ae7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dde825db464b08d6f572766579dfb629b837368c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dde825db464b08d6f572766579dfb629b837368c", "html_url": "https://github.com/rust-lang/rust/commit/dde825db464b08d6f572766579dfb629b837368c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dde825db464b08d6f572766579dfb629b837368c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7abab1efb21617ba6845fa86328dffa16cfcf1dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7abab1efb21617ba6845fa86328dffa16cfcf1dc", "html_url": "https://github.com/rust-lang/rust/commit/7abab1efb21617ba6845fa86328dffa16cfcf1dc"}, {"sha": "fec8a507a27de1b08a0b95592dc8ec93bf0a321a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fec8a507a27de1b08a0b95592dc8ec93bf0a321a", "html_url": "https://github.com/rust-lang/rust/commit/fec8a507a27de1b08a0b95592dc8ec93bf0a321a"}], "stats": {"total": 1042, "additions": 900, "deletions": 142}, "files": [{"sha": "082c5bb783347a2dbffe4dcb33b42d38559d55a8", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -2,7 +2,6 @@ use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n use rustc_ast::{AttrVec, Block, BlockCheckMode, Expr, Local, LocalKind, Stmt, StmtKind};\n use rustc_hir as hir;\n use rustc_session::parse::feature_err;\n-use rustc_span::symbol::Ident;\n use rustc_span::{sym, DesugaringKind};\n \n use smallvec::SmallVec;\n@@ -39,8 +38,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let hir_id = self.lower_node_id(s.id);\n                     match &local.kind {\n                         LocalKind::InitElse(init, els) => {\n-                            let (s, e) = self.lower_let_else(hir_id, local, init, els, tail);\n-                            stmts.push(s);\n+                            let e = self.lower_let_else(hir_id, local, init, els, tail);\n                             expr = Some(e);\n                             // remaining statements are in let-else expression\n                             break;\n@@ -125,36 +123,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         init: &Expr,\n         els: &Block,\n         tail: &[Stmt],\n-    ) -> (hir::Stmt<'hir>, &'hir hir::Expr<'hir>) {\n+    ) -> &'hir hir::Expr<'hir> {\n         let ty = local\n             .ty\n             .as_ref()\n             .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Binding)));\n         let span = self.lower_span(local.span);\n         let span = self.mark_span_with_reason(DesugaringKind::LetElse, span, None);\n-        let init = Some(self.lower_expr(init));\n-        let val = Ident::with_dummy_span(sym::val);\n-        let (pat, val_id) =\n-            self.pat_ident_binding_mode(span, val, hir::BindingAnnotation::Unannotated);\n+        let init = self.lower_expr(init);\n         let local_hir_id = self.lower_node_id(local.id);\n         self.lower_attrs(local_hir_id, &local.attrs);\n-        // first statement which basically exists for the type annotation\n-        let stmt = {\n-            let local = self.arena.alloc(hir::Local {\n+        let let_expr = {\n+            let lex = self.arena.alloc(hir::Let {\n                 hir_id: local_hir_id,\n+                pat: self.lower_pat(&local.pat),\n                 ty,\n-                pat,\n                 init,\n                 span,\n-                source: hir::LocalSource::Normal,\n             });\n-            let kind = hir::StmtKind::Local(local);\n-            hir::Stmt { hir_id: stmt_hir_id, kind, span }\n-        };\n-        let let_expr = {\n-            let scrutinee = self.expr_ident(span, val, val_id);\n-            let let_kind = hir::ExprKind::Let(self.lower_pat(&local.pat), scrutinee, span);\n-            self.arena.alloc(self.expr(span, let_kind, AttrVec::new()))\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))\n         };\n         let then_expr = {\n             let (stmts, expr) = self.lower_stmts(tail);\n@@ -165,9 +152,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             let block = self.lower_block(els, false);\n             self.arena.alloc(self.expr_block(block, AttrVec::new()))\n         };\n+        self.alias_attrs(let_expr.hir_id, local_hir_id);\n         self.alias_attrs(else_expr.hir_id, local_hir_id);\n         let if_expr = self.arena.alloc(hir::Expr {\n-            hir_id: self.next_id(),\n+            hir_id: stmt_hir_id,\n             span,\n             kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n         });\n@@ -180,6 +168,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n             .emit();\n         }\n-        (stmt, if_expr)\n+        if_expr\n     }\n }"}, {"sha": "6ee1dbe4ae3eebee5781aedd0d3454379c811d16", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -91,11 +91,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::AddrOf(k, m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee, span) => hir::ExprKind::Let(\n-                    self.lower_pat(pat),\n-                    self.lower_expr(scrutinee),\n-                    self.lower_span(span),\n-                ),\n+                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                    hir::ExprKind::Let(self.arena.alloc(hir::Let {\n+                        hir_id: self.next_id(),\n+                        span: self.lower_span(span),\n+                        pat: self.lower_pat(pat),\n+                        ty: None,\n+                        init: self.lower_expr(scrutinee),\n+                    }))\n+                }\n                 ExprKind::If(ref cond, ref then, ref else_opt) => {\n                     self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }"}, {"sha": "edad00ed6a2fe0ce03de074dc48a0d3473d3c547", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -20,6 +20,7 @@ macro_rules! arena_types {\n             [] generic_bound: rustc_hir::GenericBound<'tcx>,\n             [] generic_param: rustc_hir::GenericParam<'tcx>,\n             [] expr: rustc_hir::Expr<'tcx>,\n+            [] let_expr: rustc_hir::Let<'tcx>,\n             [] expr_field: rustc_hir::ExprField<'tcx>,\n             [] pat_field: rustc_hir::PatField<'tcx>,\n             [] fn_decl: rustc_hir::FnDecl<'tcx>,"}, {"sha": "64bd32b8ddc79d169a99757316b2dad1d44f9e51", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -1160,10 +1160,24 @@ pub struct Arm<'hir> {\n     pub body: &'hir Expr<'hir>,\n }\n \n+/// Represents a `let <pat>[: <ty>] = <expr>` expression (not a Local), occurring in an `if-let` or\n+/// `let-else`, evaluating to a boolean. Typically the pattern is refutable.\n+///\n+/// In an if-let, imagine it as `if (let <pat> = <expr>) { ... }`; in a let-else, it is part of the\n+/// desugaring to if-let. Only let-else supports the type annotation at present.\n+#[derive(Debug, HashStable_Generic)]\n+pub struct Let<'hir> {\n+    pub hir_id: HirId,\n+    pub span: Span,\n+    pub pat: &'hir Pat<'hir>,\n+    pub ty: Option<&'hir Ty<'hir>>,\n+    pub init: &'hir Expr<'hir>,\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n-    // FIXME use ExprKind::Let for this.\n+    // FIXME use hir::Let for this.\n     IfLet(&'hir Pat<'hir>, &'hir Expr<'hir>),\n }\n \n@@ -1680,7 +1694,7 @@ pub enum ExprKind<'hir> {\n     ///\n     /// These are not `Local` and only occur as expressions.\n     /// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.\n-    Let(&'hir Pat<'hir>, &'hir Expr<'hir>, Span),\n+    Let(&'hir Let<'hir>),\n     /// An `if` block, with an optional else block.\n     ///\n     /// I.e., `if <expr> { <expr> } else { <expr> }`."}, {"sha": "0fab7cbfeea3472a3d2758f987ba4c0e1304d84f", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -389,6 +389,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n         walk_expr(self, ex)\n     }\n+    fn visit_let_expr(&mut self, lex: &'v Let<'v>) {\n+        walk_let_expr(self, lex)\n+    }\n     fn visit_ty(&mut self, t: &'v Ty<'v>) {\n         walk_ty(self, t)\n     }\n@@ -1126,6 +1129,14 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n     visitor.visit_nested_body(constant.body);\n }\n \n+pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n+    // match the visit order in walk_local\n+    visitor.visit_expr(let_expr.init);\n+    visitor.visit_id(let_expr.hir_id);\n+    visitor.visit_pat(let_expr.pat);\n+    walk_list!(visitor, visit_ty, let_expr.ty);\n+}\n+\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n     match expression.kind {\n@@ -1172,10 +1183,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::Let(ref pat, ref expr, _) => {\n-            visitor.visit_expr(expr);\n-            visitor.visit_pat(pat);\n-        }\n+        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n         ExprKind::If(ref cond, ref then, ref else_opt) => {\n             visitor.visit_expr(cond);\n             visitor.visit_expr(then);"}, {"sha": "2f5f158856f1e68f4d0270240bee0aaf0d9f5dfc", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -1101,13 +1101,17 @@ impl<'a> State<'a> {\n     }\n \n     /// Print a `let pat = expr` expression.\n-    fn print_let(&mut self, pat: &hir::Pat<'_>, expr: &hir::Expr<'_>) {\n-        self.word(\"let \");\n+    fn print_let(&mut self, pat: &hir::Pat<'_>, ty: Option<&hir::Ty<'_>>, init: &hir::Expr<'_>) {\n+        self.word_space(\"let\");\n         self.print_pat(pat);\n+        if let Some(ty) = ty {\n+            self.word_space(\":\");\n+            self.print_type(ty);\n+        }\n         self.space();\n         self.word_space(\"=\");\n-        let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n-        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n+        let npals = || parser::needs_par_as_let_scrutinee(init.precedence().order());\n+        self.print_expr_cond_paren(init, Self::cond_needs_par(init) || npals())\n     }\n \n     // Does `expr` need parentheses when printed in a condition position?\n@@ -1462,8 +1466,8 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, true);\n             }\n-            hir::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                self.print_let(pat, scrutinee);\n+            hir::ExprKind::Let(hir::Let { pat, ty, init, .. }) => {\n+                self.print_let(pat, *ty, init);\n             }\n             hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));"}, {"sha": "092fe131174703b32343eb75f608ed07900fd302", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -605,9 +605,10 @@ impl<'tcx> Cx<'tcx> {\n                 },\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n             },\n-            hir::ExprKind::Let(ref pat, ref expr, _) => {\n-                ExprKind::Let { expr: self.mirror_expr(expr), pat: self.pattern_from_hir(pat) }\n-            }\n+            hir::ExprKind::Let(let_expr) => ExprKind::Let {\n+                expr: self.mirror_expr(let_expr.init),\n+                pat: self.pattern_from_hir(let_expr.pat),\n+            },\n             hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n                 if_then_scope: region::Scope {\n                     id: then.hir_id.local_id,"}, {"sha": "7a4fd6ffc4adef9d1a6f186860b4eb44b4ab870a", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -64,7 +64,9 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n         intravisit::walk_expr(self, ex);\n         match &ex.kind {\n             hir::ExprKind::Match(scrut, arms, source) => self.check_match(scrut, arms, *source),\n-            hir::ExprKind::Let(pat, scrut, span) => self.check_let(pat, scrut, *span),\n+            hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n+                self.check_let(pat, init, *span)\n+            }\n             _ => {}\n         }\n     }\n@@ -148,9 +150,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         }\n     }\n \n-    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, expr: &hir::Expr<'_>, span: Span) {\n+    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, scrutinee: &hir::Expr<'_>, span: Span) {\n         self.check_patterns(pat, Refutable);\n-        let mut cx = self.new_cx(expr.hir_id);\n+        let mut cx = self.new_cx(scrutinee.hir_id);\n         let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n         check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n     }"}, {"sha": "4ae1e5cee925e7625517b7d07a2eb4b4eec02420", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -429,8 +429,8 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::Let(ref pat, ..) => {\n-                self.add_from_pat(pat);\n+            hir::ExprKind::Let(let_expr) => {\n+                self.add_from_pat(let_expr.pat);\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -856,9 +856,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            hir::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                let succ = self.propagate_through_expr(scrutinee, succ);\n-                self.define_bindings_in_pat(pat, succ)\n+            hir::ExprKind::Let(let_expr) => {\n+                let succ = self.propagate_through_expr(let_expr.init, succ);\n+                self.define_bindings_in_pat(let_expr.pat, succ)\n             }\n \n             // Note that labels have been resolved, so we don't need to look\n@@ -1401,8 +1401,8 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n         }\n \n-        hir::ExprKind::Let(ref pat, ..) => {\n-            this.check_unused_vars_in_pat(pat, None, |_, _, _, _| {});\n+        hir::ExprKind::Let(let_expr) => {\n+            this.check_unused_vars_in_pat(let_expr.pat, None, |_, _, _, _| {});\n         }\n \n         // no correctness conditions related to liveness"}, {"sha": "4c385828ea96f91c8935c6135adb80be41719f32", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Let(pat, let_expr, _) => self.check_expr_let(let_expr, pat),\n+            ExprKind::Let(let_expr) => self.check_expr_let(let_expr),\n             ExprKind::Loop(body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n@@ -1044,10 +1044,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_let(&self, expr: &'tcx hir::Expr<'tcx>, pat: &'tcx hir::Pat<'tcx>) -> Ty<'tcx> {\n-        self.warn_if_unreachable(expr.hir_id, expr.span, \"block in `let` expression\");\n-        let expr_ty = self.demand_scrutinee_type(expr, pat.contains_explicit_ref_binding(), false);\n-        self.check_pat_top(pat, expr_ty, Some(expr.span), true);\n+    fn check_expr_let(&self, let_expr: &'tcx hir::Let<'tcx>) -> Ty<'tcx> {\n+        // for let statements, this is done in check_stmt\n+        let init = let_expr.init;\n+        self.warn_if_unreachable(init.hir_id, init.span, \"block in `let` expression\");\n+        // otherwise check exactly as a let statement\n+        self.check_decl(let_expr.into());\n+        // but return a bool, for this is a boolean expression\n         self.tcx.types.bool\n     }\n "}, {"sha": "38a8c1bb9f57b41ecc3a8174bc9d9c4eb25c72ee", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -1,5 +1,6 @@\n use crate::astconv::AstConv;\n use crate::check::coercion::CoerceMany;\n+use crate::check::gather_locals::Declaration;\n use crate::check::method::MethodCallee;\n use crate::check::Expectation::*;\n use crate::check::TupleArgumentsFlag::*;\n@@ -538,16 +539,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_decl_initializer(\n         &self,\n-        local: &'tcx hir::Local<'tcx>,\n+        hir_id: hir::HirId,\n+        pat: &'tcx hir::Pat<'tcx>,\n         init: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n         // for #42640 (default match binding modes).\n         //\n         // See #44848.\n-        let ref_bindings = local.pat.contains_explicit_ref_binding();\n+        let ref_bindings = pat.contains_explicit_ref_binding();\n \n-        let local_ty = self.local_ty(init.span, local.hir_id).revealed_ty;\n+        let local_ty = self.local_ty(init.span, hir_id).revealed_ty;\n         if let Some(m) = ref_bindings {\n             // Somewhat subtle: if we have a `ref` binding in the pattern,\n             // we want to avoid introducing coercions for the RHS. This is\n@@ -565,29 +567,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Type check a `let` statement.\n-    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n+    pub(in super::super) fn check_decl(&self, decl: Declaration<'tcx>) {\n         // Determine and write the type which we'll check the pattern against.\n-        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n-        self.write_ty(local.hir_id, ty);\n+        let decl_ty = self.local_ty(decl.span, decl.hir_id).decl_ty;\n+        self.write_ty(decl.hir_id, decl_ty);\n \n         // Type check the initializer.\n-        if let Some(ref init) = local.init {\n-            let init_ty = self.check_decl_initializer(local, &init);\n-            self.overwrite_local_ty_if_err(local, ty, init_ty);\n+        if let Some(ref init) = decl.init {\n+            let init_ty = self.check_decl_initializer(decl.hir_id, decl.pat, &init);\n+            self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, init_ty);\n         }\n \n         // Does the expected pattern type originate from an expression and what is the span?\n-        let (origin_expr, ty_span) = match (local.ty, local.init) {\n+        let (origin_expr, ty_span) = match (decl.ty, decl.init) {\n             (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n             (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n             _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n         };\n \n         // Type check the pattern. Override if necessary to avoid knock-on errors.\n-        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n-        let pat_ty = self.node_ty(local.pat.hir_id);\n-        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n+        self.check_pat_top(&decl.pat, decl_ty, ty_span, origin_expr);\n+        let pat_ty = self.node_ty(decl.pat.hir_id);\n+        self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, pat_ty);\n+    }\n+\n+    /// Type check a `let` statement.\n+    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n+        self.check_decl(local.into());\n     }\n \n     pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>, is_last: bool) {\n@@ -891,17 +897,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn overwrite_local_ty_if_err(\n         &self,\n-        local: &'tcx hir::Local<'tcx>,\n+        hir_id: hir::HirId,\n+        pat: &'tcx hir::Pat<'tcx>,\n         decl_ty: Ty<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n             // Override the types everywhere with `err()` to avoid knock on errors.\n-            self.write_ty(local.hir_id, ty);\n-            self.write_ty(local.pat.hir_id, ty);\n+            self.write_ty(hir_id, ty);\n+            self.write_ty(pat.hir_id, ty);\n             let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n-            self.locals.borrow_mut().insert(local.hir_id, local_ty);\n-            self.locals.borrow_mut().insert(local.pat.hir_id, local_ty);\n+            self.locals.borrow_mut().insert(hir_id, local_ty);\n+            self.locals.borrow_mut().insert(pat.hir_id, local_ty);\n         }\n     }\n "}, {"sha": "839bd56b396ef1911b30a34635101bfa22c2130e", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -7,6 +7,31 @@ use rustc_middle::ty::Ty;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n+/// A declaration is an abstraction of [hir::Local] and [hir::Let].\n+///\n+/// It must have a hir_id, as this is how we connect gather_locals to the check functions.\n+pub(super) struct Declaration<'a> {\n+    pub hir_id: hir::HirId,\n+    pub pat: &'a hir::Pat<'a>,\n+    pub ty: Option<&'a hir::Ty<'a>>,\n+    pub span: Span,\n+    pub init: Option<&'a hir::Expr<'a>>,\n+}\n+\n+impl<'a> From<&'a hir::Local<'a>> for Declaration<'a> {\n+    fn from(local: &'a hir::Local<'a>) -> Self {\n+        let hir::Local { hir_id, pat, ty, span, init, .. } = *local;\n+        Declaration { hir_id, pat, ty, span, init }\n+    }\n+}\n+\n+impl<'a> From<&'a hir::Let<'a>> for Declaration<'a> {\n+    fn from(let_expr: &'a hir::Let<'a>) -> Self {\n+        let hir::Let { hir_id, pat, ty, span, init } = *let_expr;\n+        Declaration { hir_id, pat, ty, span, init: Some(init) }\n+    }\n+}\n+\n pub(super) struct GatherLocalsVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     // parameters are special cases of patterns, but we want to handle them as\n@@ -41,18 +66,12 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n             }\n         }\n     }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n-    type Map = intravisit::ErasedMap<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n \n-    // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n-        let local_ty = match local.ty {\n+    /// Allocates a [LocalTy] for a declaration, which may have a type annotation. If it does have\n+    /// a type annotation, then the LocalTy stored will be the resolved type. This may be found\n+    /// again during type checking by querying [FnCtxt::local_ty] for the same hir_id.\n+    fn declare(&mut self, decl: Declaration<'tcx>) {\n+        let local_ty = match decl.ty {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n@@ -68,16 +87,34 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n             }\n             None => None,\n         };\n-        self.assign(local.span, local.hir_id, local_ty);\n+        self.assign(decl.span, decl.hir_id, local_ty);\n \n         debug!(\n             \"local variable {:?} is assigned type {}\",\n-            local.pat,\n-            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&local.hir_id).unwrap().decl_ty)\n+            decl.pat,\n+            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&decl.hir_id).unwrap().decl_ty)\n         );\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    // Add explicitly-declared locals.\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n+        self.declare(local.into());\n         intravisit::walk_local(self, local);\n     }\n \n+    fn visit_let_expr(&mut self, let_expr: &'tcx hir::Let<'tcx>) {\n+        self.declare(let_expr.into());\n+        intravisit::walk_let_expr(self, let_expr);\n+    }\n+\n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         let old_outermost_fn_param_pat = self.outermost_fn_param_pat.replace(param.ty_span);\n         intravisit::walk_param(self, param);"}, {"sha": "32b4018f626b27f9cdb4eab668d81560f0e31baf", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -229,8 +229,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::Let(pat, ref expr, _) => {\n-                self.walk_local(expr, pat, |t| t.borrow_expr(expr, ty::ImmBorrow));\n+            hir::ExprKind::Let(hir::Let { pat, init, .. }) => {\n+                self.walk_local(init, pat, |t| t.borrow_expr(init, ty::ImmBorrow));\n             }\n \n             hir::ExprKind::Match(ref discr, arms, _) => {"}, {"sha": "8fd55adbfd428d9c67d244267b71b924a0ff87ae", "filename": "src/test/ui/let-else/issue-89960.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7abab1efb21617ba6845fa86328dffa16cfcf1dc/src%2Ftest%2Fui%2Flet-else%2Fissue-89960.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7abab1efb21617ba6845fa86328dffa16cfcf1dc/src%2Ftest%2Fui%2Flet-else%2Fissue-89960.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Fissue-89960.rs?ref=7abab1efb21617ba6845fa86328dffa16cfcf1dc", "patch": "@@ -1,7 +0,0 @@\n-#![feature(let_else)]\n-\n-fn main() {\n-    // FIXME: more precise diagnostics\n-    let Some(ref mut meow) = Some(()) else { return };\n-    //~^ ERROR: cannot borrow value as mutable, as `val` is not declared as mutable\n-}"}, {"sha": "697f04d6d2735c1b38409781dba25862251a72e4", "filename": "src/test/ui/let-else/issue-89960.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7abab1efb21617ba6845fa86328dffa16cfcf1dc/src%2Ftest%2Fui%2Flet-else%2Fissue-89960.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7abab1efb21617ba6845fa86328dffa16cfcf1dc/src%2Ftest%2Fui%2Flet-else%2Fissue-89960.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Fissue-89960.stderr?ref=7abab1efb21617ba6845fa86328dffa16cfcf1dc", "patch": "@@ -1,12 +0,0 @@\n-error[E0596]: cannot borrow value as mutable, as `val` is not declared as mutable\n-  --> $DIR/issue-89960.rs:5:14\n-   |\n-LL |     let Some(ref mut meow) = Some(()) else { return };\n-   |     ---------^^^^^^^^^^^^-----------------------------\n-   |     |        |\n-   |     |        cannot borrow as mutable\n-   |     help: consider changing this to be mutable: `mut val`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0596`."}, {"sha": "bcd8c987628b33972bf22d60690abb45d6c1ad14", "filename": "src/test/ui/let-else/let-else-allow-unused.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-allow-unused.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+// issue #89807\n+\n+#![feature(let_else)]\n+\n+#[deny(unused_variables)]\n+\n+fn main() {\n+    let value = Some(String::new());\n+    #[allow(unused)]\n+    let banana = 1;\n+    #[allow(unused)]\n+    let Some(chaenomeles) = value else { return }; // OK\n+}"}, {"sha": "b65fa13c1de1eb1383be87db0f2b26c5b02a6442", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-annotated.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,16 @@\n+// from rfc2005 test suite\n+\n+#![feature(let_else)]\n+\n+// Verify the binding mode shifts - only when no `&` are auto-dereferenced is the\n+// final default binding mode mutable.\n+\n+fn main() {\n+    let Some(n): &mut Option<i32> = &&Some(5i32) else { return }; //~ ERROR mismatched types\n+    *n += 1;\n+    let _ = n;\n+\n+    let Some(n): &mut Option<i32> = &&mut Some(5i32) else { return }; //~ ERROR mismatched types\n+    *n += 1;\n+    let _ = n;\n+}"}, {"sha": "fdec7e7f6a75361b3890038c7840015e9e6c56ae", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-annotated.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-binding-explicit-mut-annotated.rs:9:37\n+   |\n+LL |     let Some(n): &mut Option<i32> = &&Some(5i32) else { return };\n+   |                                     ^^^^^^^^^^^^ types differ in mutability\n+   |\n+   = note: expected mutable reference `&mut Option<i32>`\n+                      found reference `&&Option<i32>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-binding-explicit-mut-annotated.rs:13:37\n+   |\n+LL |     let Some(n): &mut Option<i32> = &&mut Some(5i32) else { return };\n+   |                                     ^^^^^^^^^^^^^^^^ types differ in mutability\n+   |\n+   = note: expected mutable reference `&mut Option<i32>`\n+                      found reference `&&mut Option<i32>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "63b35df76aa044e5f632aef4cea4fdc71aad205a", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-borrow.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-borrow.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,13 @@\n+#![feature(let_else)]\n+\n+// Slightly different from explicit-mut-annotated -- this won't show an error until borrowck.\n+// Should it show a type error instead?\n+\n+fn main() {\n+    let Some(n): &mut Option<i32> = &mut &Some(5i32) else {\n+        //~^ ERROR cannot borrow data in a `&` reference as mutable\n+        return\n+    };\n+    *n += 1;\n+    let _ = n;\n+}"}, {"sha": "023fab8fe4a3ddef6aba425c596cae5e5a22a513", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-borrow.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-borrow.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,9 @@\n+error[E0596]: cannot borrow data in a `&` reference as mutable\n+  --> $DIR/let-else-binding-explicit-mut-borrow.rs:7:37\n+   |\n+LL |     let Some(n): &mut Option<i32> = &mut &Some(5i32) else {\n+   |                                     ^^^^^^^^^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "305be922192144f1a31456c55e6bcb512a330720", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-pass.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-pass.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(let_else)]\n+\n+fn main() {\n+    let Some(n) = &mut &mut Some(5i32) else { return; };\n+    *n += 1; // OK\n+    let _ = n;\n+\n+    let Some(n): &mut Option<i32> = &mut &mut Some(5i32) else { return; };\n+    *n += 1; // OK\n+    let _ = n;\n+}"}, {"sha": "dbe4715b1a9751d68aa19277f067fbd481ece62c", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,20 @@\n+// from rfc2005 test suite\n+\n+#![feature(let_else)]\n+\n+// Verify the binding mode shifts - only when no `&` are auto-dereferenced is the\n+// final default binding mode mutable.\n+\n+fn main() {\n+    let Some(n) = &&Some(5i32) else { return };\n+    *n += 1; //~ ERROR cannot assign to `*n`, which is behind a `&` reference\n+    let _ = n;\n+\n+    let Some(n) = &mut &Some(5i32) else { return };\n+    *n += 1; //~ ERROR cannot assign to `*n`, which is behind a `&` reference\n+    let _ = n;\n+\n+    let Some(n) = &&mut Some(5i32) else { return };\n+    *n += 1; //~ ERROR cannot assign to `*n`, which is behind a `&` reference\n+    let _ = n;\n+}"}, {"sha": "45f2b6b3bcee8c30abdbd6d79eccc565a4ca3aff", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,21 @@\n+error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n+  --> $DIR/let-else-binding-explicit-mut.rs:10:5\n+   |\n+LL |     *n += 1;\n+   |     ^^^^^^^ `n` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n+  --> $DIR/let-else-binding-explicit-mut.rs:14:5\n+   |\n+LL |     *n += 1;\n+   |     ^^^^^^^ `n` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0594]: cannot assign to `*n`, which is behind a `&` reference\n+  --> $DIR/let-else-binding-explicit-mut.rs:18:5\n+   |\n+LL |     *n += 1;\n+   |     ^^^^^^^ `n` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "96de0ffe26e6b4c05a7a4b6a7807a750268a5529", "filename": "src/test/ui/let-else/let-else-binding-immutable.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-immutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-immutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-immutable.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,10 @@\n+// from rfc2005 test suite\n+\n+#![feature(let_else)]\n+\n+pub fn main() {\n+    let Some(x) = &Some(3) else {\n+        panic!();\n+    };\n+    *x += 1; //~ ERROR: cannot assign to `*x`, which is behind a `&` reference\n+}"}, {"sha": "dd1365a9ef0785274847660ddf8b1a8eea6dd2a8", "filename": "src/test/ui/let-else/let-else-binding-immutable.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-immutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-immutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-immutable.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,9 @@\n+error[E0594]: cannot assign to `*x`, which is behind a `&` reference\n+  --> $DIR/let-else-binding-immutable.rs:9:5\n+   |\n+LL |     *x += 1;\n+   |     ^^^^^^^ `x` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "d5121e744dad39b9766f276d850351c9f2226363", "filename": "src/test/ui/let-else/let-else-bindings.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-bindings.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,75 @@\n+// run-pass\n+// adapted from src/test/ui/binding/if-let.rs\n+#![feature(let_else)]\n+#![allow(dead_code)]\n+\n+fn none() -> bool {\n+    let None = Some(\"test\") else {\n+        return true;\n+    };\n+    false\n+}\n+\n+fn ok() -> bool {\n+    let Ok(()) = Err::<(),&'static str>(\"test\") else {\n+        return true;\n+    };\n+    false\n+}\n+\n+pub fn main() {\n+    let x = Some(3);\n+    let Some(y) = x else {\n+        panic!(\"let-else panicked\");\n+    };\n+    assert_eq!(y, 3);\n+    let Some(_) = x else {\n+        panic!(\"bad match\");\n+    };\n+    assert!(none());\n+    assert!(ok());\n+\n+    assert!((|| {\n+        let 1 = 2 else {\n+            return true;\n+        };\n+        false\n+    })());\n+\n+    enum Foo {\n+        One,\n+        Two(usize),\n+        Three(String, isize),\n+    }\n+\n+    let foo = Foo::Three(\"three\".to_string(), 42);\n+    let one = || {\n+        let Foo::One = foo else {\n+            return true;\n+        };\n+        false\n+    };\n+    assert!(one());\n+    let two = || {\n+        let Foo::Two(_x) = foo else {\n+            return true;\n+        };\n+        false\n+    };\n+    assert!(two());\n+    let three = || {\n+        let Foo::Three(s, _x) = foo else {\n+            return false;\n+        };\n+        s == \"three\"\n+    };\n+    assert!(three());\n+\n+    let a@Foo::Two(_) = Foo::Two(42_usize) else {\n+        panic!(\"bad match\")\n+    };\n+    let Foo::Two(b) = a else {\n+        panic!(\"panic in nested `if let`\");\n+    };\n+    assert_eq!(b, 42_usize);\n+}"}, {"sha": "65d88a6d82827bacf03f95b9cfbcbe8c4a96459c", "filename": "src/test/ui/let-else/let-else-deref-coercion-annotated.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion-annotated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion-annotated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion-annotated.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,77 @@\n+// check-pass\n+//\n+// Taken from https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/compiler/rustc_typeck/src/check/_match.rs#L445-L462\n+//\n+// We attempt to `let Bar::Present(_): &mut Bar = foo else { ... }` where foo is meant to\n+// Deref/DerefMut to Bar. You can do this with an irrefutable binding, so it should work with\n+// let-else too.\n+\n+#![feature(let_else)]\n+use std::ops::{Deref, DerefMut};\n+\n+struct Foo(Bar);\n+\n+enum Bar {\n+    Present(u32),\n+    Absent,\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Bar {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Bar {\n+        &mut self.0\n+    }\n+}\n+impl Bar {\n+    fn bar(&self) -> Option<u32> {\n+        let Bar::Present(z): &Bar = self else {\n+            return None;\n+        };\n+        return Some(*z);\n+    }\n+}\n+impl Foo {\n+    fn set_bar_annotated(&mut self, value: u32) {\n+        let Bar::Present(z): &mut Bar = self else { // OK\n+            return;\n+        };\n+        *z = value;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(Bar::Present(1));\n+    foo.set_bar_annotated(42);\n+    assert_eq!(foo.bar(), Some(42));\n+    irrefutable::inner();\n+}\n+\n+// The original, to show it works for irrefutable let decls\n+mod irrefutable {\n+    use std::ops::{Deref, DerefMut};\n+    struct Foo(Bar);\n+    struct Bar(u32);\n+    impl Deref for Foo {\n+        type Target = Bar;\n+        fn deref(&self) -> &Bar {\n+            &self.0\n+        }\n+    }\n+    impl DerefMut for Foo {\n+        fn deref_mut(&mut self) -> &mut Bar {\n+            &mut self.0\n+        }\n+    }\n+    fn foo(x: &mut Foo) {\n+        let Bar(z): &mut Bar = x; // OK\n+        *z = 42;\n+        assert_eq!((x.0).0, 42);\n+    }\n+    pub fn inner() {\n+        foo(&mut Foo(Bar(1)));\n+    }\n+}"}, {"sha": "87489d84bbf3d63f5f459aa2646e683740bbc29d", "filename": "src/test/ui/let-else/let-else-deref-coercion.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,75 @@\n+// Taken from https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/compiler/rustc_typeck/src/check/_match.rs#L445-L462\n+//\n+// We attempt to `let Bar::Present(_) = foo else { ... }` where foo is meant to Deref/DerefMut to\n+// Bar. This fails, you must add a type annotation like `let _: &mut Bar = _ else { ... }`\n+\n+#![feature(let_else)]\n+use std::ops::{Deref, DerefMut};\n+\n+struct Foo(Bar);\n+\n+enum Bar {\n+    Present(u32),\n+    Absent,\n+}\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Bar {\n+        &self.0\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut Bar {\n+        &mut self.0\n+    }\n+}\n+impl Bar {\n+    fn bar(&self) -> Option<u32> {\n+        let Bar::Present(z): &Bar = self else {\n+            return None;\n+        };\n+        return Some(*z);\n+    }\n+}\n+impl Foo {\n+    // Try without the type annotation\n+    fn set_bar_unannotated(&mut self, value: u32) {\n+        let Bar::Present(z) = self else { //~ ERROR mismatched types\n+            return;\n+        };\n+        *z = value;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(Bar::Present(1));\n+    foo.set_bar_unannotated(54);\n+    assert_eq!(foo.bar(), Some(54));\n+    irrefutable::inner();\n+}\n+\n+// The original, to show it fails for irrefutable let decls\n+mod irrefutable {\n+    use std::ops::{Deref, DerefMut};\n+    struct Foo(Bar);\n+    struct Bar(u32);\n+    impl Deref for Foo {\n+        type Target = Bar;\n+        fn deref(&self) -> &Bar {\n+            &self.0\n+        }\n+    }\n+    impl DerefMut for Foo {\n+        fn deref_mut(&mut self) -> &mut Bar {\n+            &mut self.0\n+        }\n+    }\n+    fn foo(x: &mut Foo) {\n+        let Bar(z) = x; //~ ERROR mismatched types\n+        *z = 54;\n+        assert_eq!((x.0).0, 54);\n+    }\n+    pub fn inner() {\n+        foo(&mut Foo(Bar(1)));\n+    }\n+}"}, {"sha": "addcd798f4ffb8f54cfa21d2345e7969138caf6b", "filename": "src/test/ui/let-else/let-else-deref-coercion.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-deref-coercion.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-deref-coercion.rs:37:13\n+   |\n+LL |         let Bar::Present(z) = self else {\n+   |             ^^^^^^^^^^^^^^^   ---- this expression has type `&mut Foo`\n+   |             |\n+   |             expected struct `Foo`, found enum `Bar`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-deref-coercion.rs:68:13\n+   |\n+LL |         let Bar(z) = x;\n+   |             ^^^^^^   - this expression has type `&mut irrefutable::Foo`\n+   |             |\n+   |             expected struct `irrefutable::Foo`, found struct `irrefutable::Bar`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "35dcdd3f6be3c1cb842c2c78ead0a3cc3db04d9b", "filename": "src/test/ui/let-else/let-else-no-double-error.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-no-double-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-no-double-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-no-double-error.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,12 @@\n+// from rfc2005 test suite\n+\n+#![feature(let_else)]\n+\n+// Without caching type lookups in FnCtxt.resolve_ty_and_def_ufcs\n+// the error below would be reported twice (once when checking\n+// for a non-ref pattern, once when processing the pattern).\n+\n+fn main() {\n+    let foo = 22;\n+    let u32::XXX = foo else { return }; //~ ERROR: no associated item named `XXX` found for type `u32` in the current scope [E0599]\n+}"}, {"sha": "941e588b1768d3092dd06583e144ba4d91b827d3", "filename": "src/test/ui/let-else/let-else-no-double-error.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-no-double-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-no-double-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-no-double-error.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,9 @@\n+error[E0599]: no associated item named `XXX` found for type `u32` in the current scope\n+  --> $DIR/let-else-no-double-error.rs:11:14\n+   |\n+LL |     let u32::XXX = foo else { return };\n+   |              ^^^ associated item not found in `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "79ed82dd124bd8f83a9241f54f7101945b99908f", "filename": "src/test/ui/let-else/let-else-non-copy.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-copy.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+//\n+// This is derived from a change to compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs, in\n+// preparation for adopting let-else within the compiler (thanks @est31):\n+//\n+// ```\n+// -    let place = if let mir::VarDebugInfoContents::Place(p) = var.value { p } else { continue };\n+// +    let mir::VarDebugInfoContents::Place(place) = var.value else { continue };\n+// ```\n+//\n+// The move was due to mir::Place being Copy, but mir::VarDebugInfoContents not being Copy.\n+\n+#![feature(let_else)]\n+\n+#[derive(Copy, Clone)]\n+struct Copyable;\n+\n+enum NonCopy {\n+    Thing(Copyable),\n+    #[allow(unused)]\n+    Other,\n+}\n+\n+struct Wrapper {\n+    field: NonCopy,\n+}\n+\n+fn let_else() {\n+    let vec = vec![Wrapper { field: NonCopy::Thing(Copyable) }];\n+    for item in &vec {\n+        let NonCopy::Thing(_copyable) = item.field else { continue };\n+    }\n+}\n+\n+fn if_let() {\n+    let vec = vec![Wrapper { field: NonCopy::Thing(Copyable) }];\n+    for item in &vec {\n+        let _copyable = if let NonCopy::Thing(copyable) = item.field { copyable } else { continue };\n+    }\n+}\n+\n+fn main() {\n+    let_else();\n+    if_let();\n+}"}, {"sha": "f4abd6cc2df250d1956fd9cf51e0b87f4791c000", "filename": "src/test/ui/let-else/let-else-ref-bindings-pass.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings-pass.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,71 @@\n+// check-pass\n+\n+#![feature(let_else)]\n+#![allow(unused_variables)]\n+\n+fn ref_() {\n+    let bytes: Vec<u8> = b\"Hello\"[..].to_vec();\n+    let some = Some(bytes);\n+\n+    let Some(ref a) = Some(()) else { return };\n+\n+    // | ref | type annotation | & |\n+    // | --- | --------------- | - |\n+    // | x   | x               |   | error\n+    // | x   | x               | x | error\n+    // |     | x               |   | error\n+    // |     | x               | x | error\n+    // | x   |                 |   |\n+    let Some(ref a) = some else { return }; // OK\n+    let b: &[u8] = a;\n+\n+    // | x   |                 | x |\n+    let Some(ref a) = &some else { return }; // OK\n+    let b: &[u8] = a;\n+\n+\n+    // |     |                 | x |\n+    let Some(a) = &some else { return }; // OK\n+    let b: &[u8] = a;\n+\n+    let Some(a): Option<&[u8]> = some.as_deref() else { return }; // OK\n+    let b: &[u8] = a;\n+    let Some(ref  a): Option<&[u8]> = some.as_deref() else { return }; // OK\n+    let b: &[u8] = a;\n+}\n+\n+fn ref_mut() {\n+    // This `ref mut` case had an ICE, see issue #89960\n+    let Some(ref mut a) = Some(()) else { return };\n+\n+    let bytes: Vec<u8> = b\"Hello\"[..].to_vec();\n+    let mut some = Some(bytes);\n+\n+    // | ref mut | type annotation | &mut |\n+    // | ------- | --------------- | ---- |\n+    // | x       | x               |      | error\n+    // | x       | x               | x    | error\n+    // |         | x               |      | error\n+    // |         | x               | x    | error\n+    // | x       |                 |      |\n+    let Some(ref mut a) = some else { return }; // OK\n+    let b: &mut [u8] = a;\n+\n+    // | x       |                 | x    |\n+    let Some(ref mut a) = &mut some else { return }; // OK\n+    let b: &mut [u8] = a;\n+\n+    // |         |                 | x    |\n+    let Some(a) = &mut some else { return }; // OK\n+    let b: &mut [u8] = a;\n+\n+    let Some(a): Option<&mut [u8]> = some.as_deref_mut() else { return }; // OK\n+    let b: &mut [u8] = a;\n+    let Some(ref mut a): Option<&mut [u8]> = some.as_deref_mut() else { return }; // OK\n+    let b: &mut [u8] = a;\n+}\n+\n+fn main() {\n+    ref_();\n+    ref_mut();\n+}"}, {"sha": "a4cd8e8c47d4657dde6bae86988b32a6ecfc665c", "filename": "src/test/ui/let-else/let-else-ref-bindings.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,62 @@\n+#![feature(let_else)]\n+#![allow(unused_variables)]\n+\n+fn ref_() {\n+    let bytes: Vec<u8> = b\"Hello\"[..].to_vec();\n+    let some = Some(bytes);\n+\n+    let Some(ref a) = Some(()) else { return };\n+\n+    // | ref | type annotation | & |\n+    // | --- | --------------- | - |\n+    // | x   |                 |   | OK\n+    // | x   |                 | x | OK\n+    // |     |                 | x | OK\n+    // | x   | x               |   |\n+    let Some(ref a): Option<&[u8]> = some else { return }; //~ ERROR mismatched types\n+    let b: & [u8] = a;\n+\n+    // | x   | x               | x |\n+    let Some(ref a): Option<&[u8]> = &some else { return }; //~ ERROR mismatched types\n+    let b: & [u8] = a;\n+\n+    // |     | x               |   |\n+    let Some(a): Option<&[u8]> = some else { return }; //~ ERROR mismatched types\n+    let b: &[u8] = a;\n+    // |     | x               | x |\n+    let Some(a): Option<&[u8]> = &some else { return }; //~ ERROR mismatched types\n+    let b: &[u8] = a;\n+}\n+\n+fn ref_mut() {\n+    // This `ref mut` case had an ICE, see issue #89960\n+    let Some(ref mut a) = Some(()) else { return };\n+\n+    let bytes: Vec<u8> = b\"Hello\"[..].to_vec();\n+    let mut some = Some(bytes);\n+\n+    // | ref mut | type annotation | &mut |\n+    // | ------- | --------------- | ---- |\n+    // | x       |                 |      | OK\n+    // | x       |                 | x    | OK\n+    // |         |                 | x    | OK\n+    // | x       | x               |      |\n+    let Some(ref mut a): Option<&mut [u8]> = some else { return }; //~ ERROR mismatched types\n+    let b: &mut [u8] = a;\n+\n+    // | x       | x               | x    | (nope)\n+    let Some(ref mut a): Option<&mut [u8]> = &mut some else { return }; //~ ERROR mismatched types\n+    let b: &mut [u8] = a;\n+\n+    // |         | x               |      |\n+    let Some(a): Option<&mut [u8]> = some else { return }; //~ ERROR mismatched types\n+    let b: &mut [u8] = a;\n+    // |         | x               | x    |\n+    let Some(a): Option<&mut [u8]> = &mut some else { return }; //~ ERROR mismatched types\n+    let b: &mut [u8] = a;\n+}\n+\n+fn main() {\n+    ref_();\n+    ref_mut();\n+}"}, {"sha": "650f4ec5e779f21759ae93abce7236737c2d879f", "filename": "src/test/ui/let-else/let-else-ref-bindings.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,75 @@\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:16:38\n+   |\n+LL |     let Some(ref a): Option<&[u8]> = some else { return };\n+   |                                      ^^^^ expected `&[u8]`, found struct `Vec`\n+   |\n+   = note: expected enum `Option<&[u8]>`\n+              found enum `Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:20:38\n+   |\n+LL |     let Some(ref a): Option<&[u8]> = &some else { return };\n+   |                                      ^^^^^ expected enum `Option`, found `&Option<Vec<u8>>`\n+   |\n+   = note:   expected enum `Option<&[u8]>`\n+           found reference `&Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:24:34\n+   |\n+LL |     let Some(a): Option<&[u8]> = some else { return };\n+   |                                  ^^^^ expected `&[u8]`, found struct `Vec`\n+   |\n+   = note: expected enum `Option<&[u8]>`\n+              found enum `Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:27:34\n+   |\n+LL |     let Some(a): Option<&[u8]> = &some else { return };\n+   |                                  ^^^^^ expected enum `Option`, found `&Option<Vec<u8>>`\n+   |\n+   = note:   expected enum `Option<&[u8]>`\n+           found reference `&Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:44:46\n+   |\n+LL |     let Some(ref mut a): Option<&mut [u8]> = some else { return };\n+   |                                              ^^^^ expected `&mut [u8]`, found struct `Vec`\n+   |\n+   = note: expected enum `Option<&mut [u8]>`\n+              found enum `Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:48:46\n+   |\n+LL |     let Some(ref mut a): Option<&mut [u8]> = &mut some else { return };\n+   |                                              ^^^^^^^^^ expected enum `Option`, found mutable reference\n+   |\n+   = note:           expected enum `Option<&mut [u8]>`\n+           found mutable reference `&mut Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:52:38\n+   |\n+LL |     let Some(a): Option<&mut [u8]> = some else { return };\n+   |                                      ^^^^ expected `&mut [u8]`, found struct `Vec`\n+   |\n+   = note: expected enum `Option<&mut [u8]>`\n+              found enum `Option<Vec<u8>>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/let-else-ref-bindings.rs:55:38\n+   |\n+LL |     let Some(a): Option<&mut [u8]> = &mut some else { return };\n+   |                                      ^^^^^^^^^ expected enum `Option`, found mutable reference\n+   |\n+   = note:           expected enum `Option<&mut [u8]>`\n+           found mutable reference `&mut Option<Vec<u8>>`\n+\n+error: aborting due to 8 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2aa17ae8ceb1a4b920c209071ca30c72545bfab0", "filename": "src/test/ui/let-else/let-else-source-expr-nomove-pass.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-source-expr-nomove-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftest%2Fui%2Flet-else%2Flet-else-source-expr-nomove-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-source-expr-nomove-pass.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+// issue #89688\n+\n+#![feature(let_else)]\n+\n+fn example_let_else(value: Option<String>) {\n+    let Some(inner) = value else {\n+        println!(\"other: {:?}\", value); // OK\n+        return;\n+    };\n+    println!(\"inner: {}\", inner);\n+}\n+\n+fn main() {\n+    example_let_else(Some(\"foo\".into()));\n+    example_let_else(None);\n+}"}, {"sha": "06d128f5527b5d8ba3d965b65853c1a0507cf153", "filename": "src/tools/clippy/clippy_lints/src/equatable_if_let.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fequatable_if_let.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -67,20 +67,20 @@ fn is_structural_partial_eq(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx\n impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n-            if let ExprKind::Let(pat, exp, _) = expr.kind;\n-            if unary_pattern(pat);\n-            let exp_ty = cx.typeck_results().expr_ty(exp);\n-            let pat_ty = cx.typeck_results().pat_ty(pat);\n+            if let ExprKind::Let(let_expr) = expr.kind;\n+            if unary_pattern(let_expr.pat);\n+            let exp_ty = cx.typeck_results().expr_ty(let_expr.init);\n+            let pat_ty = cx.typeck_results().pat_ty(let_expr.pat);\n             if is_structural_partial_eq(cx, exp_ty, pat_ty);\n             then {\n \n                 let mut applicability = Applicability::MachineApplicable;\n-                let pat_str = match pat.kind {\n+                let pat_str = match let_expr.pat.kind {\n                     PatKind::Struct(..) => format!(\n                         \"({})\",\n-                        snippet_with_context(cx, pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                        snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n                     ),\n-                    _ => snippet_with_context(cx, pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n+                    _ => snippet_with_context(cx, let_expr.pat.span, expr.span.ctxt(), \"..\", &mut applicability).0.to_string(),\n                 };\n                 span_lint_and_sugg(\n                     cx,\n@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternEquality {\n                     \"try\",\n                     format!(\n                         \"{} == {}\",\n-                        snippet_with_context(cx, exp.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n+                        snippet_with_context(cx, let_expr.init.span, expr.span.ctxt(), \"..\", &mut applicability).0,\n                         pat_str,\n                     ),\n                     applicability,"}, {"sha": "a3aa6be6afd645ccd94a717d431c481af8c1ed5d", "filename": "src/tools/clippy/clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -115,12 +115,12 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Unary(_, e)\n         | ExprKind::Cast(e, _)\n         | ExprKind::Type(e, _)\n-        | ExprKind::Let(_, e, _)\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Struct(_, _, Some(e))\n         | ExprKind::Repeat(e, _)\n         | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n         ExprKind::Array(es) | ExprKind::MethodCall(_, _, es, _) | ExprKind::Tup(es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },"}, {"sha": "5a2a965716cc6bc457454f304ae9157db0970b9a", "filename": "src/tools/clippy/clippy_lints/src/manual_assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_assert.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -50,7 +50,7 @@ impl LateLintPass<'_> for ManualAssert {\n                 ..\n             } = &expr;\n             if is_expn_of(stmt.span, \"panic\").is_some();\n-            if !matches!(cond.kind, ExprKind::Let(_, _, _));\n+            if !matches!(cond.kind, ExprKind::Let(_));\n             if let StmtKind::Semi(semi) = stmt.kind;\n             if !cx.tcx.sess.source_map().is_multiline(cond.span);\n "}, {"sha": "be319ee110d24e94538dabc37a08ddda763a4b4b", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use rustc_hir::{\n-    intravisit, Body, Expr, ExprKind, FnDecl, HirId, LocalSource, Mutability, Pat, PatKind, Stmt, StmtKind,\n+    intravisit, Body, Expr, ExprKind, FnDecl, HirId, Let, LocalSource, Mutability, Pat, PatKind, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -104,8 +104,8 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n                 }\n             }\n         }\n-        if let ExprKind::Let(let_pat, ..) = expr.kind {\n-            apply_lint(cx, let_pat, DerefPossible::Possible);\n+        if let ExprKind::Let(Let { pat, .. }) = expr.kind {\n+            apply_lint(cx, pat, DerefPossible::Possible);\n         }\n     }\n "}, {"sha": "c1b811c2174405ca3c11e7bd68e90d545999b26f", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -373,11 +373,18 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n         }\n \n         match expr.value.kind {\n-            ExprKind::Let(pat, expr, _) => {\n-                bind!(self, pat, expr);\n-                kind!(\"Let({pat}, {expr}, _)\");\n-                self.pat(pat);\n-                self.expr(expr);\n+            ExprKind::Let(let_expr) => {\n+                bind!(self, let_expr);\n+                kind!(\"Let({let_expr})\");\n+                self.pat(field!(let_expr.pat));\n+                // Does what ExprKind::Cast does, only adds a clause for the type\n+                // if it's a path\n+                if let Some(TyKind::Path(ref qpath)) = let_expr.value.ty.as_ref().map(|ty| &ty.kind) {\n+                    bind!(self, qpath);\n+                    out!(\"if let TyKind::Path(ref {qpath}) = {let_expr}.ty.kind;\");\n+                    self.qpath(qpath);\n+                }\n+                self.expr(field!(let_expr.init));\n             },\n             ExprKind::Box(inner) => {\n                 bind!(self, inner);"}, {"sha": "abf4826a06917bc5991b4d2514e025ac90d30f20", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -142,9 +142,12 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::Let(pat, expr, _) => {\n+        hir::ExprKind::Let(hir::Let { pat, init, ty, .. }) => {\n             print_pat(cx, pat, indent + 1);\n-            print_expr(cx, expr, indent + 1);\n+            if let Some(ty) = ty {\n+                println!(\"{}  type annotation: {:?}\", ind, ty);\n+            }\n+            print_expr(cx, init, indent + 1);\n         },\n         hir::ExprKind::MethodCall(path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);"}, {"sha": "c764c35d444fb4ec1c96512a7a5969283e054838", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -101,7 +101,12 @@ impl<'hir> IfLet<'hir> {\n     pub fn hir(cx: &LateContext<'_>, expr: &Expr<'hir>) -> Option<Self> {\n         if let ExprKind::If(\n             Expr {\n-                kind: ExprKind::Let(let_pat, let_expr, _),\n+                kind:\n+                    ExprKind::Let(hir::Let {\n+                        pat: let_pat,\n+                        init: let_expr,\n+                        ..\n+                    }),\n                 ..\n             },\n             if_then,\n@@ -368,7 +373,12 @@ impl<'hir> WhileLet<'hir> {\n                         kind:\n                             ExprKind::If(\n                                 Expr {\n-                                    kind: ExprKind::Let(let_pat, let_expr, _),\n+                                    kind:\n+                                        ExprKind::Let(hir::Let {\n+                                            pat: let_pat,\n+                                            init: let_expr,\n+                                            ..\n+                                        }),\n                                     ..\n                                 },\n                                 if_then,"}, {"sha": "ad50759effaf85d2f65d2ee330986631b674abe9", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def::Res;\n use rustc_hir::HirIdMap;\n use rustc_hir::{\n     BinOpKind, Block, BodyId, Expr, ExprField, ExprKind, FnRetTy, GenericArg, GenericArgs, Guard, HirId,\n-    InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath, Stmt,\n+    InlineAsmOperand, Let, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path, PathSegment, QPath, Stmt,\n     StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lexer::{tokenize, TokenKind};\n@@ -234,7 +234,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n-            (&ExprKind::Let(lp, le, _), &ExprKind::Let(rp, re, _)) => self.eq_pat(lp, rp) && self.eq_expr(le, re),\n+            (&ExprKind::Let(l), &ExprKind::Let(r)) => {\n+                self.eq_pat(l.pat, r.pat) && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r)) && self.eq_expr(l.init, r.init)\n+            },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n@@ -668,8 +670,11 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ExprKind::Let(pat, expr, _) => {\n-                self.hash_expr(expr);\n+            ExprKind::Let(Let { pat, init, ty, .. }) => {\n+                self.hash_expr(init);\n+                if let Some(ty) = ty {\n+                    self.hash_ty(ty);\n+                }\n                 self.hash_pat(pat);\n             },\n             ExprKind::LlvmInlineAsm(..) | ExprKind::Err => {},"}, {"sha": "7e054a54c3c02c55dffa84ffe2aed159856d7616", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -870,8 +870,8 @@ pub fn capture_local_usage(cx: &LateContext<'tcx>, e: &Expr<'_>) -> CaptureKind\n                         capture_expr_ty = e;\n                     }\n                 },\n-                ExprKind::Let(pat, ..) => {\n-                    let mutability = match pat_capture_kind(cx, pat) {\n+                ExprKind::Let(let_expr) => {\n+                    let mutability = match pat_capture_kind(cx, let_expr.pat) {\n                         CaptureKind::Value => Mutability::Not,\n                         CaptureKind::Ref(m) => m,\n                     };"}, {"sha": "8d92849b3668f4ea410eadcf293e93bbb1db1632", "filename": "src/tools/clippy/tests/ui/author/if.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/dde825db464b08d6f572766579dfb629b837368c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fauthor%2Fif.stdout?ref=dde825db464b08d6f572766579dfb629b837368c", "patch": "@@ -32,11 +32,11 @@ if_chain! {\n }\n if_chain! {\n     if let ExprKind::If(cond, then, Some(else_expr)) = expr.kind;\n-    if let ExprKind::Let(pat, expr1, _) = cond.kind;\n-    if let PatKind::Lit(lit_expr) = pat.kind;\n+    if let ExprKind::Let(let_expr) = cond.kind;\n+    if let PatKind::Lit(lit_expr) = let_expr.pat.kind;\n     if let ExprKind::Lit(ref lit) = lit_expr.kind;\n     if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Path(ref qpath) = expr1.kind;\n+    if let ExprKind::Path(ref qpath) = let_expr.init.kind;\n     if match_qpath(qpath, &[\"a\"]);\n     if let ExprKind::Block(block, None) = then.kind;\n     if block.stmts.is_empty();"}]}