{"sha": "5d9bce6e88626ec5f36b562803686c848fdf7b66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOWJjZTZlODg2MjZlYzVmMzZiNTYyODAzNjg2Yzg0OGZkZjdiNjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-16T13:17:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-16T13:17:20Z"}, "message": "Merge #2274\n\n2274: Chalk upgrade & dyn/impl support r=matklad a=flodiebold\n\n - upgrade Chalk, which is a bit more involved than usual this time -- associated type values (in impls) are now a separate entity in Chalk, so we have to intern separate IDs for them...\r\n - use Chalk's dyn/impl Trait support\r\n - fix our handling of binders/bound variables -- before, we didn't use them for anything except Chalk queries, but now that we use them in dyn/impl Trait types and pass that to Chalk, we have to be a bit more careful\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "89f19c9649f8cc60e9e8c35cd50e8c87a0198247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89f19c9649f8cc60e9e8c35cd50e8c87a0198247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d9bce6e88626ec5f36b562803686c848fdf7b66", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdz/bgCRBK7hj4Ov3rIwAAdHIIAACmX5kUvTaSrJH+xgNuADMx\nJJnxuIIKpufwkPOBbGmLXIL7UjwXy4cODBWChe8DAT2Nk0omPJhg3PlR6clJhJWe\nvLnTh+jlWcBzPTK1FK2XEEmaUlXTyzJNG+seIuEi2I2JCoZ+INjSALpwz5cDYVBh\nEcw3/1IlRoJKrqXYfzF1Iur3DamApJ+XZln6VksobnV0UBWUqboedR0bw1/Z2gFk\nTtMTrJZL2BSuMuQ7ofg7SJvbToPrY3WcJGlltQHl1os85sbS++fXZWT+TGdXSs2S\n1hfXWdCwnnCnGMvDhrBJNv6lSwQXC/bzMaQ5cdudgn4Wm0cFVY6LVvNEIX2/CNE=\n=DQdz\n-----END PGP SIGNATURE-----\n", "payload": "tree 89f19c9649f8cc60e9e8c35cd50e8c87a0198247\nparent 7ad44610819d0bc69d4a2e0b9a74672ebb0fd585\nparent ee190388ab9068167f665bec39edd4546336ee3d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1573910240 +0000\ncommitter GitHub <noreply@github.com> 1573910240 +0000\n\nMerge #2274\n\n2274: Chalk upgrade & dyn/impl support r=matklad a=flodiebold\n\n - upgrade Chalk, which is a bit more involved than usual this time -- associated type values (in impls) are now a separate entity in Chalk, so we have to intern separate IDs for them...\r\n - use Chalk's dyn/impl Trait support\r\n - fix our handling of binders/bound variables -- before, we didn't use them for anything except Chalk queries, but now that we use them in dyn/impl Trait types and pass that to Chalk, we have to be a bit more careful\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9bce6e88626ec5f36b562803686c848fdf7b66", "html_url": "https://github.com/rust-lang/rust/commit/5d9bce6e88626ec5f36b562803686c848fdf7b66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d9bce6e88626ec5f36b562803686c848fdf7b66/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ad44610819d0bc69d4a2e0b9a74672ebb0fd585", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ad44610819d0bc69d4a2e0b9a74672ebb0fd585", "html_url": "https://github.com/rust-lang/rust/commit/7ad44610819d0bc69d4a2e0b9a74672ebb0fd585"}, {"sha": "ee190388ab9068167f665bec39edd4546336ee3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee190388ab9068167f665bec39edd4546336ee3d", "html_url": "https://github.com/rust-lang/rust/commit/ee190388ab9068167f665bec39edd4546336ee3d"}], "stats": {"total": 617, "additions": 401, "deletions": 216}, "files": [{"sha": "16fbe750202c153e702a9a671149595cb6f37f1a", "filename": "Cargo.lock", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -123,7 +123,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"chalk-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n  \"proc-macro2 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -133,52 +133,53 @@ dependencies = [\n [[package]]\n name = \"chalk-engine\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stacker 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-macros\"\n version = \"0.1.1\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n  \"lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"chalk-rust-ir\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05#50f9f636123bd88d0cc1b958749981d6702e4d05\"\n+source = \"git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478#a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\"\n dependencies = [\n- \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"petgraph 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1016,9 +1017,9 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n- \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\",\n+ \"chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n+ \"chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\",\n  \"ena 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lalrpop-intern 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1873,12 +1874,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d2d1617e838936c0d2323a65cc151e03ae19a7678dd24f72bccf27119b90a5d\"\n \"checksum cc 1.0.47 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa87058dce70a3ff5621797f1506cb837edd02ac4c0ae642b4542dce802908b8\"\n \"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n-\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=50f9f636123bd88d0cc1b958749981d6702e4d05)\" = \"<none>\"\n+\"checksum chalk-derive 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-engine 0.9.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-macros 0.1.1 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-rust-ir 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n+\"checksum chalk-solve 0.1.0 (git+https://github.com/rust-lang/chalk.git?rev=a88cad7f0a69e05ba8f40b74c58a1c229c1b2478)\" = \"<none>\"\n \"checksum chrono 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e8493056968583b0193c1bb04d6f7684586f3726992d6c573261941a895dbd68\"\n \"checksum clicolors-control 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90082ee5dcdd64dc4e9e0d37fbf3ee325419e39c0092191e0393df65518f741e\"\n \"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\""}, {"sha": "20f6e3649b2c1407a896bc336de0cd5d757b80fc", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -23,9 +23,9 @@ hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n test_utils = { path = \"../test_utils\" }\n ra_prof = { path = \"../ra_prof\" }\n \n-chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n-chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n-chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"50f9f636123bd88d0cc1b958749981d6702e4d05\" }\n+chalk-solve = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n+chalk-rust-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n+chalk-ir = { git = \"https://github.com/rust-lang/chalk.git\", rev = \"a88cad7f0a69e05ba8f40b74c58a1c229c1b2478\" }\n lalrpop-intern = \"0.15.1\"\n \n [dev-dependencies]"}, {"sha": "d75d71d6659344e3ab480dadfe337a97f03f0716", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -13,8 +13,10 @@ use crate::{\n     lang_item::{LangItemTarget, LangItems},\n     traits::TraitData,\n     ty::{\n-        method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n-        InferenceResult, Namespace, Substs, Ty, TypableDef, TypeCtor,\n+        method_resolution::CrateImplBlocks,\n+        traits::{AssocTyValue, Impl},\n+        CallableDef, FnSig, GenericPredicate, InferenceResult, Namespace, Substs, Ty, TypableDef,\n+        TypeCtor,\n     },\n     type_alias::TypeAliasData,\n     Const, ConstData, Crate, DefWithBody, FnData, Function, ImplBlock, Module, Static, StructField,\n@@ -119,26 +121,42 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     fn intern_type_ctor(&self, type_ctor: TypeCtor) -> ids::TypeCtorId;\n     #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> ids::GlobalImplId;\n+    #[salsa::interned]\n+    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> ids::AssocTyValueId;\n \n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n-    fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;\n+    fn associated_ty_data(\n+        &self,\n+        id: chalk_ir::TypeId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::chalk::trait_datum_query)]\n     fn trait_datum(\n         &self,\n         krate: Crate,\n         trait_id: chalk_ir::TraitId,\n-    ) -> Arc<chalk_rust_ir::TraitDatum>;\n+    ) -> Arc<chalk_rust_ir::TraitDatum<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::chalk::struct_datum_query)]\n     fn struct_datum(\n         &self,\n         krate: Crate,\n         struct_id: chalk_ir::StructId,\n-    ) -> Arc<chalk_rust_ir::StructDatum>;\n+    ) -> Arc<chalk_rust_ir::StructDatum<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n-    fn impl_datum(&self, krate: Crate, impl_id: chalk_ir::ImplId) -> Arc<chalk_rust_ir::ImplDatum>;\n+    fn impl_datum(\n+        &self,\n+        krate: Crate,\n+        impl_id: chalk_ir::ImplId,\n+    ) -> Arc<chalk_rust_ir::ImplDatum<chalk_ir::family::ChalkIr>>;\n+\n+    #[salsa::invoke(crate::ty::traits::chalk::associated_ty_value_query)]\n+    fn associated_ty_value(\n+        &self,\n+        krate: Crate,\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue<chalk_ir::family::ChalkIr>>;\n \n     #[salsa::invoke(crate::ty::traits::trait_solve_query)]\n     fn trait_solve("}, {"sha": "2b59365fb6a43a3ffa45286bb2fe628998075789", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -37,3 +37,9 @@ impl_intern_key!(TypeCtorId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct GlobalImplId(salsa::InternId);\n impl_intern_key!(GlobalImplId);\n+\n+/// This exists just for Chalk, because it needs a unique ID for each associated\n+/// type value in an impl (even synthetic ones).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AssocTyValueId(salsa::InternId);\n+impl_intern_key!(AssocTyValueId);"}, {"sha": "a5413518806f6fedbf3560e9e31b5089af29932b", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -224,8 +224,8 @@ impl TypeWalk for ProjectionTy {\n         self.parameters.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.parameters.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.parameters.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -291,6 +291,20 @@ pub enum Ty {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n \n+impl TypeWalk for Substs {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        for t in make_mut_slice(&mut self.0) {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n impl Substs {\n     pub fn empty() -> Substs {\n         Substs(Arc::new([]))\n@@ -304,18 +318,6 @@ impl Substs {\n         Substs(self.0[..std::cmp::min(self.0.len(), n)].into())\n     }\n \n-    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        for t in self.0.iter() {\n-            t.walk(f);\n-        }\n-    }\n-\n-    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        for t in make_mut_slice(&mut self.0) {\n-            t.walk_mut(f);\n-        }\n-    }\n-\n     pub fn as_single(&self) -> &Ty {\n         if self.0.len() != 1 {\n             panic!(\"expected substs of len 1, got {:?}\", self);\n@@ -440,8 +442,8 @@ impl TypeWalk for TraitRef {\n         self.substs.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.substs.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.substs.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -491,10 +493,12 @@ impl TypeWalk for GenericPredicate {\n         }\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         match self {\n-            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n-            GenericPredicate::Projection(projection_pred) => projection_pred.walk_mut(f),\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut_binders(f, binders),\n+            GenericPredicate::Projection(projection_pred) => {\n+                projection_pred.walk_mut_binders(f, binders)\n+            }\n             GenericPredicate::Error => {}\n         }\n     }\n@@ -544,9 +548,9 @@ impl TypeWalk for FnSig {\n         }\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         for t in make_mut_slice(&mut self.params_and_return) {\n-            t.walk_mut(f);\n+            t.walk_mut_binders(f, binders);\n         }\n     }\n }\n@@ -671,7 +675,20 @@ impl Ty {\n /// types, similar to Chalk's `Fold` trait.\n pub trait TypeWalk {\n     fn walk(&self, f: &mut impl FnMut(&Ty));\n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty));\n+    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.walk_mut_binders(&mut |ty, _binders| f(ty), 0);\n+    }\n+    /// Walk the type, counting entered binders.\n+    ///\n+    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// to the innermost binder, 1 to the next, etc.. So when we want to\n+    /// substitute a certain bound variable, we can't just walk the whole type\n+    /// and blindly replace each instance of a certain index; when we 'enter'\n+    /// things that introduce new bound variables, we have to keep track of\n+    /// that. Currently, the only thing that introduces bound variables on our\n+    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n+    /// variable for the self type.\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize);\n \n     fn fold(mut self, f: &mut impl FnMut(Ty) -> Ty) -> Self\n     where\n@@ -700,14 +717,22 @@ pub trait TypeWalk {\n     }\n \n     /// Substitutes `Ty::Bound` vars (as opposed to type parameters).\n-    fn subst_bound_vars(self, substs: &Substs) -> Self\n+    fn subst_bound_vars(mut self, substs: &Substs) -> Self\n     where\n         Self: Sized,\n     {\n-        self.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => substs.get(idx as usize).cloned().unwrap_or_else(|| Ty::Bound(idx)),\n-            ty => ty,\n-        })\n+        self.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < substs.len() {\n+                        *ty = substs.0[idx as usize - binders].clone();\n+                    }\n+                }\n+                _ => {}\n+            },\n+            0,\n+        );\n+        self\n     }\n \n     /// Shifts up `Ty::Bound` vars by `n`.\n@@ -748,22 +773,22 @@ impl TypeWalk for Ty {\n         f(self);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n         match self {\n             Ty::Apply(a_ty) => {\n-                a_ty.parameters.walk_mut(f);\n+                a_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Projection(p_ty) => {\n-                p_ty.parameters.walk_mut(f);\n+                p_ty.parameters.walk_mut_binders(f, binders);\n             }\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 for p in make_mut_slice(predicates) {\n-                    p.walk_mut(f);\n+                    p.walk_mut_binders(f, binders + 1);\n                 }\n             }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n-        f(self);\n+        f(self, binders);\n     }\n }\n "}, {"sha": "64d9394cf73b8d466d96b2dfc768b48ddf01220f", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -134,17 +134,19 @@ where\n }\n \n impl<T> Canonicalized<T> {\n-    pub fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Bound(idx) => {\n-                if (idx as usize) < self.free_vars.len() {\n-                    Ty::Infer(self.free_vars[idx as usize])\n-                } else {\n-                    Ty::Bound(idx)\n+    pub fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n+        ty.walk_mut_binders(\n+            &mut |ty, binders| match ty {\n+                &mut Ty::Bound(idx) => {\n+                    if idx as usize >= binders && (idx as usize - binders) < self.free_vars.len() {\n+                        *ty = Ty::Infer(self.free_vars[idx as usize - binders]);\n+                    }\n                 }\n-            }\n-            ty => ty,\n-        })\n+                _ => {}\n+            },\n+            0,\n+        );\n+        ty\n     }\n \n     pub fn apply_solution("}, {"sha": "d20aeaacf281bc608520f0f14f78224594a8d847", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -228,14 +228,10 @@ fn iterate_trait_method_candidates<T>(\n     'traits: for t in traits {\n         let data = t.trait_data(db);\n \n-        // FIXME this is a bit of a hack, since Chalk should say the same thing\n-        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n-        let inherently_implemented = ty.value.inherent_trait() == Some(t);\n-\n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n-        let mut known_implemented = inherently_implemented;\n+        let mut known_implemented = false;\n         for &item in data.items() {\n             if !is_valid_candidate(db, name, mode, item) {\n                 continue;"}, {"sha": "ca16936796b57045170d13f606d5900d7fac8b32", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -3983,11 +3983,11 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n     [180; 183) 'bar': fn bar() -> impl Trait<u64>\n     [180; 185) 'bar()': impl Trait<u64>\n     [191; 192) 'x': impl Trait<u64>\n-    [191; 198) 'x.foo()': {unknown}\n+    [191; 198) 'x.foo()': u64\n     [204; 205) 'y': &impl Trait<u64>\n-    [204; 211) 'y.foo()': {unknown}\n+    [204; 211) 'y.foo()': u64\n     [217; 218) 'z': impl Trait<u64>\n-    [217; 224) 'z.foo()': {unknown}\n+    [217; 224) 'z.foo()': u64\n     [230; 231) 'x': impl Trait<u64>\n     [230; 238) 'x.foo2()': i64\n     [244; 245) 'y': &impl Trait<u64>\n@@ -4033,11 +4033,11 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n     [177; 180) 'bar': fn bar() -> dyn Trait<u64>\n     [177; 182) 'bar()': dyn Trait<u64>\n     [188; 189) 'x': dyn Trait<u64>\n-    [188; 195) 'x.foo()': {unknown}\n+    [188; 195) 'x.foo()': u64\n     [201; 202) 'y': &dyn Trait<u64>\n-    [201; 208) 'y.foo()': {unknown}\n+    [201; 208) 'y.foo()': u64\n     [214; 215) 'z': dyn Trait<u64>\n-    [214; 221) 'z.foo()': {unknown}\n+    [214; 221) 'z.foo()': u64\n     [227; 228) 'x': dyn Trait<u64>\n     [227; 235) 'x.foo2()': i64\n     [241; 242) 'y': &dyn Trait<u64>\n@@ -4184,6 +4184,49 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     );\n }\n \n+#[test]\n+fn impl_trait_assoc_binding_projection_bug() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:std\n+pub trait Language {\n+    type Kind;\n+}\n+pub enum RustLanguage {}\n+impl Language for RustLanguage {\n+    type Kind = SyntaxKind;\n+}\n+struct SyntaxNode<L> {}\n+fn foo() -> impl Iterator<Item = SyntaxNode<RustLanguage>> {}\n+\n+trait Clone {\n+    fn clone(&self) -> Self;\n+}\n+\n+fn api_walkthrough() {\n+    for node in foo() {\n+        node.clone()<|>;\n+    }\n+}\n+\n+//- /std.rs crate:std\n+#[prelude_import] use iter::*;\n+mod iter {\n+    trait IntoIterator {\n+        type Item;\n+    }\n+    trait Iterator {\n+        type Item;\n+    }\n+    impl<T: Iterator> IntoIterator for T {\n+        type Item = <T as Iterator>::Item;\n+    }\n+}\n+\"#,\n+    );\n+    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn projection_eq_within_chalk() {\n     // std::env::set_var(\"CHALK_DEBUG\", \"1\");"}, {"sha": "45f72543808791b062749e9e29d13254f1b3a4ba", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -8,7 +8,7 @@ use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n-use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait};\n+use crate::{db::HirDatabase, expr::ExprId, Crate, DefWithBody, ImplBlock, Trait, TypeAlias};\n \n use self::chalk::{from_chalk, ToChalk};\n \n@@ -17,7 +17,7 @@ pub(crate) mod chalk;\n #[derive(Debug, Clone)]\n pub struct TraitSolver {\n     krate: Crate,\n-    inner: Arc<Mutex<chalk_solve::Solver>>,\n+    inner: Arc<Mutex<chalk_solve::Solver<ChalkIr>>>,\n }\n \n /// We need eq for salsa\n@@ -34,7 +34,7 @@ impl TraitSolver {\n         &self,\n         db: &impl HirDatabase,\n         goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<ChalkIr>>>,\n-    ) -> Option<chalk_solve::Solution> {\n+    ) -> Option<chalk_solve::Solution<ChalkIr>> {\n         let context = ChalkContext { db, krate: self.krate };\n         debug!(\"solve goal: {:?}\", goal);\n         let mut solver = match self.inner.lock() {\n@@ -165,9 +165,9 @@ impl TypeWalk for ProjectionPredicate {\n         self.ty.walk(f);\n     }\n \n-    fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        self.projection_ty.walk_mut(f);\n-        self.ty.walk_mut(f);\n+    fn walk_mut_binders(&mut self, f: &mut impl FnMut(&mut Ty, usize), binders: usize) {\n+        self.projection_ty.walk_mut_binders(f, binders);\n+        self.ty.walk_mut_binders(f, binders);\n     }\n }\n \n@@ -188,14 +188,18 @@ pub(crate) fn trait_solve_query(\n     }\n \n     let canonical = goal.to_chalk(db).cast();\n+\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n     let solution = db.trait_solver(krate).solve(db, &u_canonical);\n     solution.map(|solution| solution_from_chalk(db, solution))\n }\n \n-fn solution_from_chalk(db: &impl HirDatabase, solution: chalk_solve::Solution) -> Solution {\n+fn solution_from_chalk(\n+    db: &impl HirDatabase,\n+    solution: chalk_solve::Solution<ChalkIr>,\n+) -> Solution {\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<ChalkIr>>| {\n         let value = subst\n             .value\n@@ -300,3 +304,14 @@ pub enum Impl {\n     /// Closure types implement the Fn traits synthetically.\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n }\n+\n+/// An associated type value. Usually this comes from a `type` declaration\n+/// inside an impl block, but for built-in impls we have to synthesize it.\n+/// (We only need this because Chalk wants a unique ID for each of these.)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AssocTyValue {\n+    /// A normal assoc type value from an impl block.\n+    TypeAlias(TypeAlias),\n+    /// The output type of the Fn trait implementation.\n+    ClosureFnTraitImplOutput(ClosureFnTraitImplData),\n+}"}, {"sha": "9bf93981a08c3133fed5f0e0b06f8b23881b84d2", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 199, "deletions": 120, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d9bce6e88626ec5f36b562803686c848fdf7b66/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=5d9bce6e88626ec5f36b562803686c848fdf7b66", "patch": "@@ -7,22 +7,19 @@ use chalk_ir::{\n     cast::Cast, family::ChalkIr, Identifier, ImplId, Parameter, PlaceholderIndex, TypeId,\n     TypeKindId, TypeName, UniverseIndex,\n };\n-use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n+use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n \n-use super::{Canonical, ChalkContext, Impl, Obligation};\n+use super::{AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase,\n     generics::{GenericDef, HasGenericParams},\n     ty::display::HirDisplay,\n-    ty::{\n-        ApplicationTy, GenericPredicate, Namespace, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n-    },\n-    AssocItem, Crate, HasBody, ImplBlock, Trait, TypeAlias,\n+    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n+    Crate, HasBody, ImplBlock, Trait, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -59,29 +56,36 @@ impl ToChalk for Ty {\n                     }\n                 };\n                 let parameters = apply_ty.parameters.to_chalk(db);\n-                chalk_ir::ApplicationTy { name, parameters }.cast()\n+                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n             Ty::Projection(proj_ty) => {\n                 let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n                 let parameters = proj_ty.parameters.to_chalk(db);\n-                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast()\n+                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast().intern()\n             }\n             Ty::Param { idx, .. } => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty::<ChalkIr>()\n             }\n-            Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n+            Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n-            // FIXME use Chalk's Dyn/Opaque once the bugs with that are fixed\n-            Ty::Unknown | Ty::Dyn(_) | Ty::Opaque(_) => {\n+            Ty::Dyn(predicates) => {\n+                let where_clauses = predicates.iter().cloned().map(|p| p.to_chalk(db)).collect();\n+                chalk_ir::TyData::Dyn(make_binders(where_clauses, 1)).intern()\n+            }\n+            Ty::Opaque(predicates) => {\n+                let where_clauses = predicates.iter().cloned().map(|p| p.to_chalk(db)).collect();\n+                chalk_ir::TyData::Opaque(make_binders(where_clauses, 1)).intern()\n+            }\n+            Ty::Unknown => {\n                 let parameters = Vec::new();\n                 let name = TypeName::Error;\n-                chalk_ir::ApplicationTy { name, parameters }.cast()\n+                chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n         }\n     }\n     fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<ChalkIr>) -> Self {\n-        match chalk {\n-            chalk_ir::Ty::Apply(apply_ty) => {\n+        match chalk.data().clone() {\n+            chalk_ir::TyData::Apply(apply_ty) => {\n                 // FIXME this is kind of hacky due to the fact that\n                 // TypeName::Placeholder is a Ty::Param on our side\n                 match apply_ty.name {\n@@ -104,21 +108,21 @@ impl ToChalk for Ty {\n                     }\n                 }\n             }\n-            chalk_ir::Ty::Projection(proj) => {\n+            chalk_ir::TyData::Projection(proj) => {\n                 let associated_ty = from_chalk(db, proj.associated_ty_id);\n                 let parameters = from_chalk(db, proj.parameters);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::Ty::ForAll(_) => unimplemented!(),\n-            chalk_ir::Ty::BoundVar(idx) => Ty::Bound(idx as u32),\n-            chalk_ir::Ty::InferenceVar(_iv) => Ty::Unknown,\n-            chalk_ir::Ty::Dyn(where_clauses) => {\n+            chalk_ir::TyData::ForAll(_) => unimplemented!(),\n+            chalk_ir::TyData::BoundVar(idx) => Ty::Bound(idx as u32),\n+            chalk_ir::TyData::InferenceVar(_iv) => Ty::Unknown,\n+            chalk_ir::TyData::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.binders.len(), 1);\n                 let predicates =\n                     where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n                 Ty::Dyn(predicates)\n             }\n-            chalk_ir::Ty::Opaque(where_clauses) => {\n+            chalk_ir::TyData::Opaque(where_clauses) => {\n                 assert_eq!(where_clauses.binders.len(), 1);\n                 let predicates =\n                     where_clauses.value.into_iter().map(|c| from_chalk(db, c)).collect();\n@@ -211,6 +215,21 @@ impl ToChalk for TypeAlias {\n     }\n }\n \n+impl ToChalk for AssocTyValue {\n+    type Chalk = chalk_rust_ir::AssociatedTyValueId;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValueId {\n+        db.intern_assoc_ty_value(self).into()\n+    }\n+\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        assoc_ty_value_id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> AssocTyValue {\n+        db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n+    }\n+}\n+\n impl ToChalk for GenericPredicate {\n     type Chalk = chalk_ir::QuantifiedWhereClause<ChalkIr>;\n \n@@ -399,20 +418,20 @@ fn convert_where_clauses(\n     result\n }\n \n-impl<'a, DB> chalk_solve::RustIrDatabase for ChalkContext<'a, DB>\n+impl<'a, DB> chalk_solve::RustIrDatabase<ChalkIr> for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n {\n-    fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum> {\n+    fn associated_ty_data(&self, id: TypeId) -> Arc<AssociatedTyDatum<ChalkIr>> {\n         self.db.associated_ty_data(id)\n     }\n-    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum> {\n+    fn trait_datum(&self, trait_id: chalk_ir::TraitId) -> Arc<TraitDatum<ChalkIr>> {\n         self.db.trait_datum(self.krate, trait_id)\n     }\n-    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum> {\n+    fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum<ChalkIr>> {\n         self.db.struct_datum(self.krate, struct_id)\n     }\n-    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum> {\n+    fn impl_datum(&self, impl_id: ImplId) -> Arc<ImplDatum<ChalkIr>> {\n         self.db.impl_datum(self.krate, impl_id)\n     }\n     fn impls_for_trait(\n@@ -462,13 +481,11 @@ where\n     fn type_name(&self, _id: TypeKindId) -> Identifier {\n         unimplemented!()\n     }\n-    fn split_projection<'p>(\n+    fn associated_ty_value(\n         &self,\n-        projection: &'p chalk_ir::ProjectionTy<ChalkIr>,\n-    ) -> (Arc<AssociatedTyDatum>, &'p [Parameter<ChalkIr>], &'p [Parameter<ChalkIr>]) {\n-        debug!(\"split_projection {:?}\", projection);\n-        // we don't support GATs, so I think this should always be correct currently\n-        (self.db.associated_ty_data(projection.associated_ty_id), &projection.parameters, &[])\n+        id: chalk_rust_ir::AssociatedTyValueId,\n+    ) -> Arc<AssociatedTyValue<ChalkIr>> {\n+        self.db.associated_ty_value(self.krate, id)\n     }\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n         vec![]\n@@ -485,27 +502,24 @@ where\n pub(crate) fn associated_ty_data_query(\n     db: &impl HirDatabase,\n     id: TypeId,\n-) -> Arc<AssociatedTyDatum> {\n+) -> Arc<AssociatedTyDatum<ChalkIr>> {\n     debug!(\"associated_ty_data {:?}\", id);\n     let type_alias: TypeAlias = from_chalk(db, id);\n     let trait_ = match type_alias.container(db) {\n         Some(crate::Container::Trait(t)) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n     let generic_params = type_alias.generic_params(db);\n-    let parameter_kinds = generic_params\n-        .params_including_parent()\n-        .into_iter()\n-        .map(|p| chalk_ir::ParameterKind::Ty(lalrpop_intern::intern(&p.name.to_string())))\n-        .collect();\n+    let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n+        // FIXME add bounds and where clauses\n+        bounds: vec![],\n+        where_clauses: vec![],\n+    };\n     let datum = AssociatedTyDatum {\n         trait_id: trait_.to_chalk(db),\n         id,\n         name: lalrpop_intern::intern(&type_alias.name(db).to_string()),\n-        parameter_kinds,\n-        // FIXME add bounds and where clauses\n-        bounds: vec![],\n-        where_clauses: vec![],\n+        binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n     };\n     Arc::new(datum)\n }\n@@ -514,36 +528,35 @@ pub(crate) fn trait_datum_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n     trait_id: chalk_ir::TraitId,\n-) -> Arc<TraitDatum> {\n+) -> Arc<TraitDatum<ChalkIr>> {\n     debug!(\"trait_datum {:?}\", trait_id);\n     if trait_id == UNKNOWN_TRAIT {\n-        let trait_datum_bound = chalk_rust_ir::TraitDatumBound {\n-            trait_ref: chalk_ir::TraitRef {\n-                trait_id: UNKNOWN_TRAIT,\n-                parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-            },\n-            associated_ty_ids: Vec::new(),\n-            where_clauses: Vec::new(),\n-        };\n+        let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses: Vec::new() };\n \n         let flags = chalk_rust_ir::TraitFlags {\n             auto: false,\n             marker: false,\n             upstream: true,\n             fundamental: false,\n             non_enumerable: true,\n+            coinductive: false,\n         };\n-        return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1), flags });\n+        return Arc::new(TraitDatum {\n+            id: trait_id,\n+            binders: make_binders(trait_datum_bound, 1),\n+            flags,\n+            associated_ty_ids: vec![],\n+        });\n     }\n     let trait_: Trait = from_chalk(db, trait_id);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n     let generic_params = trait_.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = trait_.trait_ref(db).subst(&bound_vars).to_chalk(db);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_.is_auto(db),\n         upstream: trait_.module(db).krate() != krate,\n         non_enumerable: true,\n+        coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n         marker: false,\n         fundamental: false,\n@@ -558,18 +571,21 @@ pub(crate) fn trait_datum_query(\n         })\n         .map(|type_alias| type_alias.to_chalk(db))\n         .collect();\n-    let trait_datum_bound =\n-        chalk_rust_ir::TraitDatumBound { trait_ref, where_clauses, associated_ty_ids };\n-    let trait_datum =\n-        TraitDatum { binders: make_binders(trait_datum_bound, bound_vars.len()), flags };\n+    let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n+    let trait_datum = TraitDatum {\n+        id: trait_id,\n+        binders: make_binders(trait_datum_bound, bound_vars.len()),\n+        flags,\n+        associated_ty_ids,\n+    };\n     Arc::new(trait_datum)\n }\n \n pub(crate) fn struct_datum_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n     struct_id: chalk_ir::StructId,\n-) -> Arc<StructDatum> {\n+) -> Arc<StructDatum<ChalkIr>> {\n     debug!(\"struct_datum {:?}\", struct_id);\n     let type_ctor: TypeCtor = from_chalk(db, struct_id);\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n@@ -588,48 +604,40 @@ pub(crate) fn struct_datum_query(\n         // FIXME set fundamental flag correctly\n         fundamental: false,\n     };\n-    let self_ty = chalk_ir::ApplicationTy {\n-        name: TypeName::TypeKindId(type_ctor.to_chalk(db).into()),\n-        parameters: (0..num_params).map(|i| chalk_ir::Ty::BoundVar(i).cast()).collect(),\n-    };\n     let struct_datum_bound = chalk_rust_ir::StructDatumBound {\n-        self_ty,\n         fields: Vec::new(), // FIXME add fields (only relevant for auto traits)\n         where_clauses,\n-        flags,\n     };\n-    let struct_datum = StructDatum { binders: make_binders(struct_datum_bound, num_params) };\n+    let struct_datum =\n+        StructDatum { id: struct_id, binders: make_binders(struct_datum_bound, num_params), flags };\n     Arc::new(struct_datum)\n }\n \n pub(crate) fn impl_datum_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n     impl_id: ImplId,\n-) -> Arc<ImplDatum> {\n+) -> Arc<ImplDatum<ChalkIr>> {\n     let _p = ra_prof::profile(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n     let impl_: Impl = from_chalk(db, impl_id);\n     match impl_ {\n         Impl::ImplBlock(impl_block) => impl_block_datum(db, krate, impl_id, impl_block),\n-        Impl::ClosureFnTraitImpl(data) => {\n-            closure_fn_trait_impl_datum(db, krate, impl_id, data).unwrap_or_else(invalid_impl_datum)\n-        }\n+        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n     }\n+    .unwrap_or_else(invalid_impl_datum)\n }\n \n fn impl_block_datum(\n     db: &impl HirDatabase,\n     krate: Crate,\n     impl_id: ImplId,\n     impl_block: ImplBlock,\n-) -> Arc<ImplDatum> {\n+) -> Option<Arc<ImplDatum<ChalkIr>>> {\n     let generic_params = impl_block.generic_params(db);\n     let bound_vars = Substs::bound_vars(&generic_params);\n-    let trait_ref = impl_block\n-        .target_trait_ref(db)\n-        .expect(\"FIXME handle unresolved impl block trait ref\")\n-        .subst(&bound_vars);\n+    let trait_ref = impl_block.target_trait_ref(db)?.subst(&bound_vars);\n+    let trait_ = trait_ref.trait_;\n     let impl_type = if impl_block.krate(db) == krate {\n         chalk_rust_ir::ImplType::Local\n     } else {\n@@ -644,76 +652,69 @@ fn impl_block_datum(\n         trait_ref.display(db),\n         where_clauses\n     );\n-    let trait_ = trait_ref.trait_;\n     let trait_ref = trait_ref.to_chalk(db);\n-    let associated_ty_values = impl_block\n-        .items(db)\n-        .into_iter()\n-        .filter_map(|item| match item {\n-            AssocItem::TypeAlias(t) => Some(t),\n-            _ => None,\n-        })\n-        .filter_map(|t| {\n-            let assoc_ty = trait_.associated_type_by_name(db, &t.name(db))?;\n-            let ty = db.type_for_def(t.into(), Namespace::Types).subst(&bound_vars);\n-            Some(chalk_rust_ir::AssociatedTyValue {\n-                impl_id,\n-                associated_ty_id: assoc_ty.to_chalk(db),\n-                value: chalk_ir::Binders {\n-                    value: chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) },\n-                    binders: vec![], // we don't support GATs yet\n-                },\n-            })\n-        })\n-        .collect();\n \n     let polarity = if negative {\n         chalk_rust_ir::Polarity::Negative\n     } else {\n         chalk_rust_ir::Polarity::Positive\n     };\n \n-    let impl_datum_bound =\n-        chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses, associated_ty_values };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n+    let associated_ty_value_ids = impl_block\n+        .items(db)\n+        .into_iter()\n+        .filter_map(|item| match item {\n+            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias),\n+            _ => None,\n+        })\n+        .filter(|type_alias| {\n+            // don't include associated types that don't exist in the trait\n+            trait_.associated_type_by_name(db, &type_alias.name(db)).is_some()\n+        })\n+        .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n+        .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, bound_vars.len()),\n         impl_type,\n         polarity,\n+        associated_ty_value_ids,\n     };\n-    Arc::new(impl_datum)\n+    Some(Arc::new(impl_datum))\n }\n \n-fn invalid_impl_datum() -> Arc<ImplDatum> {\n+fn invalid_impl_datum() -> Arc<ImplDatum<ChalkIr>> {\n     let trait_ref = chalk_ir::TraitRef {\n         trait_id: UNKNOWN_TRAIT,\n-        parameters: vec![chalk_ir::Ty::BoundVar(0).cast()],\n-    };\n-    let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        associated_ty_values: Vec::new(),\n+        parameters: vec![chalk_ir::TyData::BoundVar(0).cast().intern().cast()],\n     };\n+    let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses: Vec::new() };\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, 1),\n         impl_type: chalk_rust_ir::ImplType::External,\n         polarity: chalk_rust_ir::Polarity::Positive,\n+        associated_ty_value_ids: Vec::new(),\n     };\n     Arc::new(impl_datum)\n }\n \n fn closure_fn_trait_impl_datum(\n     db: &impl HirDatabase,\n     krate: Crate,\n-    impl_id: ImplId,\n     data: super::ClosureFnTraitImplData,\n-) -> Option<Arc<ImplDatum>> {\n+) -> Option<Arc<ImplDatum<ChalkIr>>> {\n     // for some closure |X, Y| -> Z:\n     // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n \n-    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n     let trait_ = get_fn_trait(db, krate, data.fn_trait)?; // get corresponding fn trait\n \n+    // validate FnOnce trait, since we need it in the assoc ty value definition\n+    // and don't want to return a valid value only to find out later that FnOnce\n+    // is broken\n+    let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n+    fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n+\n     let num_args: u16 = match &data.def.body(db)[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n         _ => {\n@@ -726,7 +727,6 @@ fn closure_fn_trait_impl_datum(\n         TypeCtor::Tuple { cardinality: num_args },\n         Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n     );\n-    let output_ty = Ty::Bound(num_args.into());\n     let sig_ty = Ty::apply(\n         TypeCtor::FnPtr { num_args },\n         Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n@@ -739,32 +739,99 @@ fn closure_fn_trait_impl_datum(\n         substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n-    let output_ty_id = fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n-\n-    let output_ty_value = chalk_rust_ir::AssociatedTyValue {\n-        associated_ty_id: output_ty_id.to_chalk(db),\n-        impl_id,\n-        value: make_binders(\n-            chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) },\n-            0,\n-        ),\n-    };\n+    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone()).to_chalk(db);\n \n     let impl_type = chalk_rust_ir::ImplType::External;\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound {\n         trait_ref: trait_ref.to_chalk(db),\n         where_clauses: Vec::new(),\n-        associated_ty_values: vec![output_ty_value],\n     };\n     let impl_datum = ImplDatum {\n         binders: make_binders(impl_datum_bound, num_args as usize + 1),\n         impl_type,\n         polarity: chalk_rust_ir::Polarity::Positive,\n+        associated_ty_value_ids: vec![output_ty_id],\n     };\n     Some(Arc::new(impl_datum))\n }\n \n+pub(crate) fn associated_ty_value_query(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    id: chalk_rust_ir::AssociatedTyValueId,\n+) -> Arc<chalk_rust_ir::AssociatedTyValue<ChalkIr>> {\n+    let data: AssocTyValue = from_chalk(db, id);\n+    match data {\n+        AssocTyValue::TypeAlias(type_alias) => {\n+            type_alias_associated_ty_value(db, krate, type_alias)\n+        }\n+        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n+            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n+        }\n+    }\n+}\n+\n+fn type_alias_associated_ty_value(\n+    db: &impl HirDatabase,\n+    _krate: Crate,\n+    type_alias: TypeAlias,\n+) -> Arc<AssociatedTyValue<ChalkIr>> {\n+    let impl_block = type_alias.impl_block(db).expect(\"assoc ty value should be in impl\");\n+    let impl_id = Impl::ImplBlock(impl_block).to_chalk(db);\n+    let trait_ = impl_block\n+        .target_trait_ref(db)\n+        .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n+        .trait_;\n+    let assoc_ty = trait_\n+        .associated_type_by_name(db, &type_alias.name(db))\n+        .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n+    let generic_params = impl_block.generic_params(db);\n+    let bound_vars = Substs::bound_vars(&generic_params);\n+    let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };\n+    let value = chalk_rust_ir::AssociatedTyValue {\n+        impl_id,\n+        associated_ty_id: assoc_ty.to_chalk(db),\n+        value: make_binders(value_bound, bound_vars.len()),\n+    };\n+    Arc::new(value)\n+}\n+\n+fn closure_fn_trait_output_assoc_ty_value(\n+    db: &impl HirDatabase,\n+    krate: Crate,\n+    data: super::ClosureFnTraitImplData,\n+) -> Arc<AssociatedTyValue<ChalkIr>> {\n+    let impl_id = Impl::ClosureFnTraitImpl(data.clone()).to_chalk(db);\n+\n+    let num_args: u16 = match &data.def.body(db)[data.expr] {\n+        crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n+        _ => {\n+            log::warn!(\"closure for closure type {:?} not found\", data);\n+            0\n+        }\n+    };\n+\n+    let output_ty = Ty::Bound(num_args.into());\n+\n+    let fn_once_trait =\n+        get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n+\n+    let output_ty_id = fn_once_trait\n+        .associated_type_by_name(db, &name::OUTPUT_TYPE)\n+        .expect(\"assoc ty value should not exist\");\n+\n+    let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n+\n+    let value = chalk_rust_ir::AssociatedTyValue {\n+        associated_ty_id: output_ty_id.to_chalk(db),\n+        impl_id,\n+        value: make_binders(value_bound, num_args as usize + 1),\n+    };\n+    Arc::new(value)\n+}\n+\n fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n     let target = db.lang_item(krate, fn_trait.lang_item_name().into())?;\n     match target {\n@@ -803,3 +870,15 @@ impl From<crate::ids::GlobalImplId> for chalk_ir::ImplId {\n         chalk_ir::ImplId(id_to_chalk(impl_id))\n     }\n }\n+\n+impl From<chalk_rust_ir::AssociatedTyValueId> for crate::ids::AssocTyValueId {\n+    fn from(id: chalk_rust_ir::AssociatedTyValueId) -> Self {\n+        id_from_chalk(id.0)\n+    }\n+}\n+\n+impl From<crate::ids::AssocTyValueId> for chalk_rust_ir::AssociatedTyValueId {\n+    fn from(assoc_ty_value_id: crate::ids::AssocTyValueId) -> Self {\n+        chalk_rust_ir::AssociatedTyValueId(id_to_chalk(assoc_ty_value_id))\n+    }\n+}"}]}