{"sha": "69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZjRlMzE4YTAyODBkM2NmZmRhOWZkOWNhNjBiYTA4NGM1YTI3ZmQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-05-05T21:35:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-05T21:35:25Z"}, "message": "Rollup merge of #41512 - alexcrichton:fix-windows-tls-deadlock, r=BurntSushi\n\nstd: Avoid locks during TLS destruction on Windows\n\nGecko recently had a bug reported [1] with a deadlock in the Rust TLS\nimplementation for Windows. TLS destructors are implemented in a sort of ad-hoc\nfashion on Windows as it doesn't natively support destructors for TLS keys. To\nwork around this the runtime manages a list of TLS destructors and registers a\nhook to get run whenever a thread exits. When a thread exits it takes a look at\nthe list and runs all destructors.\n\nUnfortunately it turns out that there's a lock which is held when our \"at thread\nexit\" callback is run. The callback then attempts to acquire a lock protecting\nthe list of TLS destructors. Elsewhere in the codebase while we hold a lock over\nthe TLS destructors we try to acquire the same lock held first before our\nspecial callback is run. And as a result, deadlock!\n\nThis commit sidesteps the issue with a few small refactorings:\n\n* Removed support for destroying a TLS key on Windows. We don't actually ever\n  exercise this as a public-facing API, and it's only used during `lazy_init`\n  during racy situations. To handle that we just synchronize `lazy_init`\n  globally on Windows so we never have to call `destroy`.\n\n* With no need to support removal the global synchronized `Vec` was tranformed\n  to a lock-free linked list. With the removal of locks this means that\n  iteration no long requires a lock and as such we won't run into the deadlock\n  problem mentioned above.\n\nNote that it's still a general problem that you have to be extra super careful\nin TLS destructors. For example no code which runs a TLS destructor on Windows\ncan call back into the Windows API to do a dynamic library lookup. Unfortunately\nI don't know of a great way around that, but this at least fixes the immediate\nproblem that Gecko was seeing which is that with \"well behaved\" destructors the\nsystem would still deadlock!\n\n[1]: https://bugzilla.mozilla.org/show_bug.cgi?id=1358151", "tree": {"sha": "684d5a1c4abf59774166e9d31e8f7463088ffa7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/684d5a1c4abf59774166e9d31e8f7463088ffa7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "html_url": "https://github.com/rust-lang/rust/commit/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31a4d73e735ed0f9dceca3e44d4d46016efb13d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/31a4d73e735ed0f9dceca3e44d4d46016efb13d0", "html_url": "https://github.com/rust-lang/rust/commit/31a4d73e735ed0f9dceca3e44d4d46016efb13d0"}, {"sha": "495c998508039764b07a64303ae2c9461ec86a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/495c998508039764b07a64303ae2c9461ec86a7b", "html_url": "https://github.com/rust-lang/rust/commit/495c998508039764b07a64303ae2c9461ec86a7b"}], "stats": {"total": 208, "additions": 93, "deletions": 115}, "files": [{"sha": "2487f6bcaf74f0861e48f65492eb90ce18bc8296", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "patch": "@@ -38,3 +38,8 @@ pub unsafe fn destroy(key: Key) {\n     let r = libc::pthread_key_delete(key);\n     debug_assert_eq!(r, 0);\n }\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    false\n+}"}, {"sha": "4e08c7a01256294f5db81fd53b49b05263661862", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "patch": "@@ -935,7 +935,6 @@ extern \"system\" {\n                           args: *const c_void)\n                           -> DWORD;\n     pub fn TlsAlloc() -> DWORD;\n-    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n     pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n     pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n     pub fn GetLastError() -> DWORD;"}, {"sha": "ad57f87dc1ff991b68b029c0884862d1c795142a", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 66, "deletions": 99, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use mem;\n use ptr;\n+use sync::atomic::AtomicPtr;\n+use sync::atomic::Ordering::SeqCst;\n use sys::c;\n-use sys_common::mutex::Mutex;\n-use sys_common;\n \n pub type Key = c::DWORD;\n pub type Dtor = unsafe extern fn(*mut u8);\n@@ -34,8 +35,6 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // * All TLS destructors are tracked by *us*, not the windows runtime. This\n //   means that we have a global list of destructors for each TLS key that\n //   we know about.\n-// * When a TLS key is destroyed, we're sure to remove it from the dtor list\n-//   if it's in there.\n // * When a thread exits, we run over the entire list and run dtors for all\n //   non-null keys. This attempts to match Unix semantics in this regard.\n //\n@@ -50,13 +49,6 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n //                        /threading/thread_local_storage_win.cc#L42\n \n-// NB these are specifically not types from `std::sync` as they currently rely\n-// on poisoning and this module needs to operate at a lower level than requiring\n-// the thread infrastructure to be in place (useful on the borders of\n-// initialization/destruction).\n-static DTOR_LOCK: Mutex = Mutex::new();\n-static mut DTORS: *mut Vec<(Key, Dtor)> = ptr::null_mut();\n-\n // -------------------------------------------------------------------------\n // Native bindings\n //\n@@ -85,81 +77,64 @@ pub unsafe fn get(key: Key) -> *mut u8 {\n }\n \n #[inline]\n-pub unsafe fn destroy(key: Key) {\n-    if unregister_dtor(key) {\n-        // FIXME: Currently if a key has a destructor associated with it we\n-        // can't actually ever unregister it. If we were to\n-        // unregister it, then any key destruction would have to be\n-        // serialized with respect to actually running destructors.\n-        //\n-        // We want to avoid a race where right before run_dtors runs\n-        // some destructors TlsFree is called. Allowing the call to\n-        // TlsFree would imply that the caller understands that *all\n-        // known threads* are not exiting, which is quite a difficult\n-        // thing to know!\n-        //\n-        // For now we just leak all keys with dtors to \"fix\" this.\n-        // Note that source [2] above shows precedent for this sort\n-        // of strategy.\n-    } else {\n-        let r = c::TlsFree(key);\n-        debug_assert!(r != 0);\n-    }\n+pub unsafe fn destroy(_key: Key) {\n+    rtabort!(\"can't destroy tls keys on windows\")\n+}\n+\n+#[inline]\n+pub fn requires_synchronized_create() -> bool {\n+    true\n }\n \n // -------------------------------------------------------------------------\n // Dtor registration\n //\n-// These functions are associated with registering and unregistering\n-// destructors. They're pretty simple, they just push onto a vector and scan\n-// a vector currently.\n+// Windows has no native support for running destructors so we manage our own\n+// list of destructors to keep track of how to destroy keys. We then install a\n+// callback later to get invoked whenever a thread exits, running all\n+// appropriate destructors.\n //\n-// FIXME: This could probably be at least a little faster with a BTree.\n-\n-unsafe fn init_dtors() {\n-    if !DTORS.is_null() { return }\n+// Currently unregistration from this list is not supported. A destructor can be\n+// registered but cannot be unregistered. There's various simplifying reasons\n+// for doing this, the big ones being:\n+//\n+// 1. Currently we don't even support deallocating TLS keys, so normal operation\n+//    doesn't need to deallocate a destructor.\n+// 2. There is no point in time where we know we can unregister a destructor\n+//    because it could always be getting run by some remote thread.\n+//\n+// Typically processes have a statically known set of TLS keys which is pretty\n+// small, and we'd want to keep this memory alive for the whole process anyway\n+// really.\n+//\n+// Perhaps one day we can fold the `Box` here into a static allocation,\n+// expanding the `StaticKey` structure to contain not only a slot for the TLS\n+// key but also a slot for the destructor queue on windows. An optimization for\n+// another day!\n \n-    let dtors = box Vec::<(Key, Dtor)>::new();\n+static DTORS: AtomicPtr<Node> = AtomicPtr::new(ptr::null_mut());\n \n-    let res = sys_common::at_exit(move|| {\n-        DTOR_LOCK.lock();\n-        let dtors = DTORS;\n-        DTORS = 1 as *mut _;\n-        Box::from_raw(dtors);\n-        assert!(DTORS as usize == 1); // can't re-init after destructing\n-        DTOR_LOCK.unlock();\n-    });\n-    if res.is_ok() {\n-        DTORS = Box::into_raw(dtors);\n-    } else {\n-        DTORS = 1 as *mut _;\n-    }\n+struct Node {\n+    dtor: Dtor,\n+    key: Key,\n+    next: *mut Node,\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n-    DTOR_LOCK.lock();\n-    init_dtors();\n-    assert!(DTORS as usize != 0);\n-    assert!(DTORS as usize != 1,\n-            \"cannot create new TLS keys after the main thread has exited\");\n-    (*DTORS).push((key, dtor));\n-    DTOR_LOCK.unlock();\n-}\n+    let mut node = Box::new(Node {\n+        key: key,\n+        dtor: dtor,\n+        next: ptr::null_mut(),\n+    });\n \n-unsafe fn unregister_dtor(key: Key) -> bool {\n-    DTOR_LOCK.lock();\n-    init_dtors();\n-    assert!(DTORS as usize != 0);\n-    assert!(DTORS as usize != 1,\n-            \"cannot unregister destructors after the main thread has exited\");\n-    let ret = {\n-        let dtors = &mut *DTORS;\n-        let before = dtors.len();\n-        dtors.retain(|&(k, _)| k != key);\n-        dtors.len() != before\n-    };\n-    DTOR_LOCK.unlock();\n-    ret\n+    let mut head = DTORS.load(SeqCst);\n+    loop {\n+        node.next = head;\n+        match DTORS.compare_exchange(head, &mut *node, SeqCst, SeqCst) {\n+            Ok(_) => return mem::forget(node),\n+            Err(cur) => head = cur,\n+        }\n+    }\n }\n \n // -------------------------------------------------------------------------\n@@ -196,16 +171,12 @@ unsafe fn unregister_dtor(key: Key) -> bool {\n // # Ok, what's up with running all these destructors?\n //\n // This will likely need to be improved over time, but this function\n-// attempts a \"poor man's\" destructor callback system. To do this we clone a\n-// local copy of the dtor list to start out with. This is our fudgy attempt\n-// to not hold the lock while destructors run and not worry about the list\n-// changing while we're looking at it.\n-//\n-// Once we've got a list of what to run, we iterate over all keys, check\n-// their values, and then run destructors if the values turn out to be non\n-// null (setting them to null just beforehand). We do this a few times in a\n-// loop to basically match Unix semantics. If we don't reach a fixed point\n-// after a short while then we just inevitably leak something most likely.\n+// attempts a \"poor man's\" destructor callback system. Once we've got a list\n+// of what to run, we iterate over all keys, check their values, and then run\n+// destructors if the values turn out to be non null (setting them to null just\n+// beforehand). We do this a few times in a loop to basically match Unix\n+// semantics. If we don't reach a fixed point after a short while then we just\n+// inevitably leak something most likely.\n //\n // # The article mentions weird stuff about \"/INCLUDE\"?\n //\n@@ -259,25 +230,21 @@ unsafe extern \"system\" fn on_tls_callback(h: c::LPVOID,\n unsafe fn run_dtors() {\n     let mut any_run = true;\n     for _ in 0..5 {\n-        if !any_run { break }\n+        if !any_run {\n+            break\n+        }\n         any_run = false;\n-        let dtors = {\n-            DTOR_LOCK.lock();\n-            let ret = if DTORS as usize <= 1 {\n-                Vec::new()\n-            } else {\n-                (*DTORS).iter().map(|s| *s).collect()\n-            };\n-            DTOR_LOCK.unlock();\n-            ret\n-        };\n-        for &(key, dtor) in &dtors {\n-            let ptr = c::TlsGetValue(key);\n+        let mut cur = DTORS.load(SeqCst);\n+        while !cur.is_null() {\n+            let ptr = c::TlsGetValue((*cur).key);\n+\n             if !ptr.is_null() {\n-                c::TlsSetValue(key, ptr::null_mut());\n-                dtor(ptr as *mut _);\n+                c::TlsSetValue((*cur).key, ptr::null_mut());\n+                ((*cur).dtor)(ptr as *mut _);\n                 any_run = true;\n             }\n+\n+            cur = (*cur).next;\n         }\n     }\n }"}, {"sha": "0ade90e64c307e66e98edce22e3923ae9a74f1ef", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f4e318a0280d3cffda9fd9ca60ba084c5a27fd/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=69f4e318a0280d3cffda9fd9ca60ba084c5a27fd", "patch": "@@ -61,6 +61,7 @@\n use sync::atomic::{self, AtomicUsize, Ordering};\n \n use sys::thread_local as imp;\n+use sys_common::mutex::Mutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -145,20 +146,6 @@ impl StaticKey {\n     #[inline]\n     pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }\n \n-    /// Deallocates this OS TLS key.\n-    ///\n-    /// This function is unsafe as there is no guarantee that the key is not\n-    /// currently in use by other threads or will not ever be used again.\n-    ///\n-    /// Note that this does *not* run the user-provided destructor if one was\n-    /// specified at definition time. Doing so must be done manually.\n-    pub unsafe fn destroy(&self) {\n-        match self.key.swap(0, Ordering::SeqCst) {\n-            0 => {}\n-            n => { imp::destroy(n as imp::Key) }\n-        }\n-    }\n-\n     #[inline]\n     unsafe fn key(&self) -> imp::Key {\n         match self.key.load(Ordering::Relaxed) {\n@@ -168,6 +155,24 @@ impl StaticKey {\n     }\n \n     unsafe fn lazy_init(&self) -> usize {\n+        // Currently the Windows implementation of TLS is pretty hairy, and\n+        // it greatly simplifies creation if we just synchronize everything.\n+        //\n+        // Additionally a 0-index of a tls key hasn't been seen on windows, so\n+        // we just simplify the whole branch.\n+        if imp::requires_synchronized_create() {\n+            static INIT_LOCK: Mutex = Mutex::new();\n+            INIT_LOCK.lock();\n+            let mut key = self.key.load(Ordering::SeqCst);\n+            if key == 0 {\n+                key = imp::create(self.dtor) as usize;\n+                self.key.store(key, Ordering::SeqCst);\n+            }\n+            INIT_LOCK.unlock();\n+            assert!(key != 0);\n+            return key\n+        }\n+\n         // POSIX allows the key created here to be 0, but the compare_and_swap\n         // below relies on using 0 as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n@@ -227,7 +232,9 @@ impl Key {\n \n impl Drop for Key {\n     fn drop(&mut self) {\n-        unsafe { imp::destroy(self.key) }\n+        // Right now Windows doesn't support TLS key destruction, but this also\n+        // isn't used anywhere other than tests, so just leak the TLS key.\n+        // unsafe { imp::destroy(self.key) }\n     }\n }\n "}]}