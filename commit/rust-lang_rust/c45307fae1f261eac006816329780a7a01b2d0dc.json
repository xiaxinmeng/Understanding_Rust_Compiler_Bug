{"sha": "c45307fae1f261eac006816329780a7a01b2d0dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NTMwN2ZhZTFmMjYxZWFjMDA2ODE2MzI5NzgwYTdhMDFiMmQwZGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-12T10:25:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:13Z"}, "message": "extract the code to create `OutlivesBounds` into its own module\n\nNow it can be reused by the NLL code.", "tree": {"sha": "83ea1dde39a24d6c6b79c7c5480b2156b8253d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ea1dde39a24d6c6b79c7c5480b2156b8253d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c45307fae1f261eac006816329780a7a01b2d0dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c45307fae1f261eac006816329780a7a01b2d0dc", "html_url": "https://github.com/rust-lang/rust/commit/c45307fae1f261eac006816329780a7a01b2d0dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c45307fae1f261eac006816329780a7a01b2d0dc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f33145ae91cbe095616c92ace63c93b61e5b4e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f33145ae91cbe095616c92ace63c93b61e5b4e9", "html_url": "https://github.com/rust-lang/rust/commit/1f33145ae91cbe095616c92ace63c93b61e5b4e9"}], "stats": {"total": 208, "additions": 110, "deletions": 98}, "files": [{"sha": "43e782ac13018e4bc151c22a50c97eded278881f", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 47, "deletions": 58, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c45307fae1f261eac006816329780a7a01b2d0dc/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45307fae1f261eac006816329780a7a01b2d0dc/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=c45307fae1f261eac006816329780a7a01b2d0dc", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use infer::{InferCtxt, GenericKind};\n+use infer::{GenericKind, InferCtxt};\n use infer::outlives::free_region_map::FreeRegionMap;\n-use infer::outlives::implied_bounds::ImpliedBound;\n+use infer::outlives::implied_bounds::{self, OutlivesBound};\n use ty::{self, Ty};\n \n use syntax::ast;\n@@ -50,7 +50,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: vec![],\n         };\n \n-        env.init_free_regions_from_predicates();\n+        env.add_outlives_bounds(None, implied_bounds::explicit_outlives_bounds(param_env));\n \n         env\n     }\n@@ -144,65 +144,54 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = infcx.resolve_type_vars_if_possible(&ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n-            let implied_bounds = infcx.implied_bounds(self.param_env, body_id, ty, span);\n-\n-            // But also record other relationships, such as `T:'x`,\n-            // that don't go into the free-region-map but which we use\n-            // here.\n-            for implication in implied_bounds {\n-                debug!(\"add_implied_bounds: implication={:?}\", implication);\n-                match implication {\n-                    ImpliedBound::RegionSubRegion(\n-                        r_a @ &ty::ReEarlyBound(_),\n-                        &ty::ReVar(vid_b),\n-                    ) |\n-                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n-                        infcx.add_given(r_a, vid_b);\n-                    }\n-                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n-                        self.region_bound_pairs\n-                            .push((r_a, GenericKind::Param(param_b)));\n-                    }\n-                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n-                        self.region_bound_pairs\n-                            .push((r_a, GenericKind::Projection(projection_b)));\n-                    }\n-                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        self.free_region_map.relate_regions(r_a, r_b);\n-                    }\n-                }\n-            }\n+            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n+            self.add_outlives_bounds(Some(infcx), implied_bounds)\n         }\n     }\n \n-    fn init_free_regions_from_predicates(&mut self) {\n-        debug!(\"init_free_regions_from_predicates()\");\n-        for predicate in self.param_env.caller_bounds {\n-            debug!(\"init_free_regions_from_predicates: predicate={:?}\", predicate);\n-            match *predicate {\n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n-                ty::Predicate::Equate(..) |\n-                ty::Predicate::Subtype(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::ConstEvaluatable(..) => {\n-                    // No region bounds here\n+    /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n+    ///\n+    /// The `infcx` parameter is optional; if the implied bounds may\n+    /// contain inference variables, it should be supplied, in which\n+    /// case we will register \"givens\" on the inference context. (See\n+    /// `RegionConstraintData`.)\n+    fn add_outlives_bounds<I>(\n+        &mut self,\n+        infcx: Option<&InferCtxt<'a, 'gcx, 'tcx>>,\n+        outlives_bounds: I,\n+    ) where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        // But also record other relationships, such as `T:'x`,\n+        // that don't go into the free-region-map but which we use\n+        // here.\n+        for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_), &ty::ReVar(vid_b)) |\n+                OutlivesBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n+                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, vid_b);\n+                }\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n+                }\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n                 }\n-                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n-                    self.free_region_map.relate_regions(r_b, r_a);\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n+                    // In principle, we could record (and take\n+                    // advantage of) every relationship here, but\n+                    // we are also free not to -- it simply means\n+                    // strictly less that we can successfully type\n+                    // check. Right now we only look for things\n+                    // relationships between free regions. (It may\n+                    // also be that we should revise our inference\n+                    // system to be more general and to make use\n+                    // of *every* relationship that arises here,\n+                    // but presently we do not.)\n+                    self.free_region_map.relate_regions(r_a, r_b);\n                 }\n             }\n         }"}, {"sha": "8a562471ac5d038b7d5211eb06bc992910372e66", "filename": "src/librustc/infer/outlives/implied_bounds.rs", "status": "modified", "additions": 63, "deletions": 40, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c45307fae1f261eac006816329780a7a01b2d0dc/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c45307fae1f261eac006816329780a7a01b2d0dc/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fimplied_bounds.rs?ref=c45307fae1f261eac006816329780a7a01b2d0dc", "patch": "@@ -16,28 +16,32 @@ use ty::{self, Ty, TypeFoldable};\n use ty::outlives::Component;\n use ty::wf;\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+/// Outlives bounds are relationships between generic parameters,\n+/// whether they both be regions (`'a: 'b`) or whether types are\n+/// involved (`T: 'a`).  These relationships can be extracted from the\n+/// full set of predicates we understand or also from types (in which\n+/// case they are called implied bounds). They are fed to the\n+/// `OutlivesEnv` which in turn is supplied to the region checker and\n+/// other parts of the inference system.\n #[derive(Debug)]\n-pub enum ImpliedBound<'tcx> {\n+pub enum OutlivesBound<'tcx> {\n     RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n     RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n     RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n }\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n-    /// Compute the implied bounds that a callee/impl can assume based on\n-    /// the fact that caller/projector has ensured that `ty` is WF.  See\n-    /// the `ImpliedBound` type for more details.\n+    /// Implied bounds are region relationships that we deduce\n+    /// automatically.  The idea is that (e.g.) a caller must check that a\n+    /// function's argument types are well-formed immediately before\n+    /// calling that fn, and hence the *callee* can assume that its\n+    /// argument types are well-formed. This may imply certain relationships\n+    /// between generic parameters. For example:\n+    ///\n+    ///     fn foo<'a,T>(x: &'a T)\n+    ///\n+    /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+    /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n     ///\n     /// # Parameters\n     ///\n@@ -48,13 +52,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// - `ty`, the type that we are supposed to assume is WF.\n     /// - `span`, a span to use when normalizing, hopefully not important,\n     ///   might be useful if a `bug!` occurs.\n-    pub fn implied_bounds(\n+    pub fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: ast::NodeId,\n         ty: Ty<'tcx>,\n         span: Span,\n-    ) -> Vec<ImpliedBound<'tcx>> {\n+    ) -> Vec<OutlivesBound<'tcx>> {\n         let tcx = self.tcx;\n \n         // Sometimes when we ask what it takes for T: WF, we get back that\n@@ -76,8 +80,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             // than the ultimate set. (Note: normally there won't be\n             // unresolved inference variables here anyway, but there might be\n             // during typeck under some circumstances.)\n-            let obligations =\n-                wf::obligations(self, param_env, body_id, ty, span).unwrap_or(vec![]);\n+            let obligations = wf::obligations(self, param_env, body_id, ty, span).unwrap_or(vec![]);\n \n             // NB: All of these predicates *ought* to be easily proven\n             // true. In fact, their correctness is (mostly) implied by\n@@ -105,7 +108,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 obligations\n                     .iter()\n                     .filter(|o| o.predicate.has_infer_types())\n-                    .cloned());\n+                    .cloned(),\n+            );\n \n             // From the full set of obligations, just filter down to the\n             // region relationships.\n@@ -125,25 +129,21 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                         vec![]\n                     }\n \n-                    ty::Predicate::RegionOutlives(ref data) => {\n-                        match data.no_late_bound_regions() {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n-                            }\n+                    ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n+                        None => vec![],\n+                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                            vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                         }\n-                    }\n+                    },\n \n-                    ty::Predicate::TypeOutlives(ref data) => {\n-                        match data.no_late_bound_regions() {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n-                                let components = tcx.outlives_components(ty_a);\n-                                Self::implied_bounds_from_components(r_b, components)\n-                            }\n+                    ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n+                        None => vec![],\n+                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                            let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n+                            let components = tcx.outlives_components(ty_a);\n+                            Self::implied_bounds_from_components(r_b, components)\n                         }\n-                    }\n+                    },\n                 }\n             }));\n         }\n@@ -165,17 +165,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     fn implied_bounds_from_components(\n         sub_region: ty::Region<'tcx>,\n         sup_components: Vec<Component<'tcx>>,\n-    ) -> Vec<ImpliedBound<'tcx>> {\n+    ) -> Vec<OutlivesBound<'tcx>> {\n         sup_components\n             .into_iter()\n             .flat_map(|component| {\n                 match component {\n                     Component::Region(r) =>\n-                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n+                        vec![OutlivesBound::RegionSubRegion(sub_region, r)],\n                     Component::Param(p) =>\n-                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n+                        vec![OutlivesBound::RegionSubParam(sub_region, p)],\n                     Component::Projection(p) =>\n-                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n+                        vec![OutlivesBound::RegionSubProjection(sub_region, p)],\n                     Component::EscapingProjection(_) =>\n                     // If the projection has escaping regions, don't\n                     // try to infer any implied bounds even for its\n@@ -193,3 +193,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             .collect()\n     }\n }\n+\n+pub fn explicit_outlives_bounds<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n+    debug!(\"explicit_outlives_bounds()\");\n+    param_env\n+        .caller_bounds\n+        .into_iter()\n+        .filter_map(move |predicate| match predicate {\n+            ty::Predicate::Projection(..) |\n+            ty::Predicate::Trait(..) |\n+            ty::Predicate::Equate(..) |\n+            ty::Predicate::Subtype(..) |\n+            ty::Predicate::WellFormed(..) |\n+            ty::Predicate::ObjectSafe(..) |\n+            ty::Predicate::ClosureKind(..) |\n+            ty::Predicate::TypeOutlives(..) |\n+            ty::Predicate::ConstEvaluatable(..) => None,\n+            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n+                |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n+            ),\n+        })\n+}"}]}