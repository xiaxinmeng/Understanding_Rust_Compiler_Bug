{"sha": "e7a68c8f55e0770fdeae508a1710509c13aaffa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTY4YzhmNTVlMDc3MGZkZWFlNTA4YTE3MTA1MDljMTNhYWZmYTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-11T15:55:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-11T15:55:26Z"}, "message": "Merge #3949\n\n3949: Cleanup cfg handling in items r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "56227291b99e0bdccf2b41c911d797794908d3c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56227291b99e0bdccf2b41c911d797794908d3c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a68c8f55e0770fdeae508a1710509c13aaffa1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekehuCRBK7hj4Ov3rIwAAdHIIAGEFUaYySWBhuk850NCtsxMs\nZwUlIRSwkRjsfv/qlBy3oRslKi6u9EnK4f9dBqC1b6BuMtMdT9LLFYmCoKi/feJD\n3LB5bFfnesZelao1310jNhBZp0AHbjU6Z0F/uAsdjQQ1AChUf6LopxK518j1vdPY\nYyQp42okiTbsmEonIrkeZvZ/IeQvxkk+Fmrjkrm2YJ85BSL2CWElFD2D0fUEvGPf\n1Xj4c1k52IGEtFdYPdC4JFgGYGg9UJEXmcAxO6ipJ7EQaH2OwKLFtbShdCy20e3y\nrV/tUJnrCqil4056WctRRpvbzMyY9m8ZJxHMjgbop9HIFz8gAVmW3ZvOSeldIdM=\n=8xkv\n-----END PGP SIGNATURE-----\n", "payload": "tree 56227291b99e0bdccf2b41c911d797794908d3c4\nparent 997c959d4f373df0cbba09609c5e4d8215d3d0c7\nparent f980b0752994a1b823499f6edb10fd9c4c285c42\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586620526 +0000\ncommitter GitHub <noreply@github.com> 1586620526 +0000\n\nMerge #3949\n\n3949: Cleanup cfg handling in items r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a68c8f55e0770fdeae508a1710509c13aaffa1", "html_url": "https://github.com/rust-lang/rust/commit/e7a68c8f55e0770fdeae508a1710509c13aaffa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a68c8f55e0770fdeae508a1710509c13aaffa1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "997c959d4f373df0cbba09609c5e4d8215d3d0c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/997c959d4f373df0cbba09609c5e4d8215d3d0c7", "html_url": "https://github.com/rust-lang/rust/commit/997c959d4f373df0cbba09609c5e4d8215d3d0c7"}, {"sha": "f980b0752994a1b823499f6edb10fd9c4c285c42", "url": "https://api.github.com/repos/rust-lang/rust/commits/f980b0752994a1b823499f6edb10fd9c4c285c42", "html_url": "https://github.com/rust-lang/rust/commit/f980b0752994a1b823499f6edb10fd9c4c285c42"}], "stats": {"total": 155, "additions": 102, "deletions": 53}, "files": [{"sha": "7c0d936910270c08ff02afab3c948592a4bc899a", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -4,7 +4,6 @@ use std::sync::Arc;\n \n use either::Either;\n use hir_expand::{\n-    hygiene::Hygiene,\n     name::{AsName, Name},\n     InFile,\n };\n@@ -13,7 +12,7 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    attr::Attrs, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n+    body::CfgExpander, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n     type_ref::TypeRef, visibility::RawVisibility, EnumId, HasModule, LocalEnumVariantId,\n     LocalStructFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n };\n@@ -125,8 +124,9 @@ fn lower_enum(\n \n impl VariantData {\n     fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>, module_id: ModuleId) -> Self {\n+        let mut expander = CfgExpander::new(db, flavor.file_id, module_id.krate);\n         let mut trace = Trace::new_for_arena();\n-        match lower_struct(db, &mut trace, &flavor, module_id) {\n+        match lower_struct(db, &mut expander, &mut trace, &flavor) {\n             StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n             StructKind::Record => VariantData::Record(trace.into_arena()),\n             StructKind::Unit => VariantData::Unit,\n@@ -178,8 +178,9 @@ impl HasChildSource for VariantId {\n                 it.lookup(db).container.module(db),\n             ),\n         };\n+        let mut expander = CfgExpander::new(db, src.file_id, module_id.krate);\n         let mut trace = Trace::new_for_map();\n-        lower_struct(db, &mut trace, &src, module_id);\n+        lower_struct(db, &mut expander, &mut trace, &src);\n         src.with_value(trace.into_map())\n     }\n }\n@@ -193,16 +194,15 @@ pub enum StructKind {\n \n fn lower_struct(\n     db: &dyn DefDatabase,\n+    expander: &mut CfgExpander,\n     trace: &mut Trace<StructFieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n     ast: &InFile<ast::StructKind>,\n-    module_id: ModuleId,\n ) -> StructKind {\n-    let crate_graph = db.crate_graph();\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n-                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n-                if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                let attrs = expander.parse_attrs(&fd);\n+                if !expander.is_cfg_enabled(&attrs) {\n                     continue;\n                 }\n \n@@ -219,8 +219,8 @@ fn lower_struct(\n         }\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n-                let attrs = Attrs::new(&fd, &Hygiene::new(db.upcast(), ast.file_id));\n-                if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                let attrs = expander.parse_attrs(&fd);\n+                if !expander.is_cfg_enabled(&attrs) {\n                     continue;\n                 }\n "}, {"sha": "2f2e3e5ba2c0510c67ceeba22379595c4804c0a4", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -93,6 +93,7 @@ impl Attrs {\n     }\n \n     pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+        // FIXME: handle cfg_attr :-)\n         self.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n     }\n }"}, {"sha": "7fac6ce66e3e9d7cdbce57d309cc82634d3b8087", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -14,6 +14,7 @@ use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n use crate::{\n+    attr::Attrs,\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n@@ -23,26 +24,62 @@ use crate::{\n     src::HasSource,\n     AsMacroCall, DefWithBodyId, HasModule, Lookup, ModuleId,\n };\n+use ra_cfg::CfgOptions;\n+use ra_db::CrateId;\n+\n+/// A subser of Exander that only deals with cfg attributes. We only need it to\n+/// avoid cyclic queries in crate def map during enum processing.\n+pub(crate) struct CfgExpander {\n+    cfg_options: CfgOptions,\n+    hygiene: Hygiene,\n+}\n \n pub(crate) struct Expander {\n+    cfg_expander: CfgExpander,\n     crate_def_map: Arc<CrateDefMap>,\n     current_file_id: HirFileId,\n-    hygiene: Hygiene,\n     ast_id_map: Arc<AstIdMap>,\n     module: ModuleId,\n     recursive_limit: usize,\n }\n \n+impl CfgExpander {\n+    pub(crate) fn new(\n+        db: &dyn DefDatabase,\n+        current_file_id: HirFileId,\n+        krate: CrateId,\n+    ) -> CfgExpander {\n+        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n+        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        CfgExpander { cfg_options, hygiene }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, owner: &dyn ast::AttrsOwner) -> Attrs {\n+        Attrs::new(owner, &self.hygiene)\n+    }\n+\n+    pub(crate) fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n+        attrs.is_cfg_enabled(&self.cfg_options)\n+    }\n+}\n+\n impl Expander {\n     pub(crate) fn new(\n         db: &dyn DefDatabase,\n         current_file_id: HirFileId,\n         module: ModuleId,\n     ) -> Expander {\n+        let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n         let crate_def_map = db.crate_def_map(module.krate);\n-        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n         let ast_id_map = db.ast_id_map(current_file_id);\n-        Expander { crate_def_map, current_file_id, hygiene, ast_id_map, module, recursive_limit: 0 }\n+        Expander {\n+            cfg_expander,\n+            crate_def_map,\n+            current_file_id,\n+            ast_id_map,\n+            module,\n+            recursive_limit: 0,\n+        }\n     }\n \n     pub(crate) fn enter_expand<T: ast::AstNode>(\n@@ -75,7 +112,7 @@ impl Expander {\n                         ast_id_map: mem::take(&mut self.ast_id_map),\n                         bomb: DropBomb::new(\"expansion mark dropped\"),\n                     };\n-                    self.hygiene = Hygiene::new(db.upcast(), file_id);\n+                    self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n                     self.current_file_id = file_id;\n                     self.ast_id_map = db.ast_id_map(file_id);\n                     self.recursive_limit += 1;\n@@ -91,7 +128,7 @@ impl Expander {\n     }\n \n     pub(crate) fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n-        self.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n+        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n         self.ast_id_map = mem::take(&mut mark.ast_id_map);\n         self.recursive_limit -= 1;\n@@ -102,8 +139,16 @@ impl Expander {\n         InFile { file_id: self.current_file_id, value }\n     }\n \n+    pub(crate) fn parse_attrs(&self, owner: &dyn ast::AttrsOwner) -> Attrs {\n+        self.cfg_expander.parse_attrs(owner)\n+    }\n+\n+    pub(crate) fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n+        self.cfg_expander.is_cfg_enabled(attrs)\n+    }\n+\n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        Path::from_src(path, &self.hygiene)\n+        Path::from_src(path, &self.cfg_expander.hygiene)\n     }\n \n     fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroDefId> {"}, {"sha": "c1d7eb826a7904638e643b361595a55d001376aa", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -2,9 +2,7 @@\n //! representation.\n \n use either::Either;\n-\n use hir_expand::{\n-    hygiene::Hygiene,\n     name::{name, AsName, Name},\n     MacroDefId, MacroDefKind,\n };\n@@ -18,10 +16,8 @@ use ra_syntax::{\n };\n use test_utils::tested_by;\n \n-use super::{ExprSource, PatSource};\n use crate::{\n     adt::StructKind,\n-    attr::Attrs,\n     body::{Body, BodySourceMap, Expander, PatPtr, SyntheticSyntax},\n     builtin_type::{BuiltinFloat, BuiltinInt},\n     db::DefDatabase,\n@@ -33,10 +29,12 @@ use crate::{\n     path::GenericArgs,\n     path::Path,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, HasModule, Intern,\n-    ModuleDefId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n+    StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n };\n \n+use super::{ExprSource, PatSource};\n+\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     def: DefWithBodyId,\n@@ -300,21 +298,15 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n-                let crate_graph = self.db.crate_graph();\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n                 let record_lit = if let Some(nfl) = e.record_field_list() {\n                     let fields = nfl\n                         .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(field)))\n                         .filter_map(|field| {\n-                            let module_id = ContainerId::DefWithBodyId(self.def).module(self.db);\n-                            let attrs = Attrs::new(\n-                                &field,\n-                                &Hygiene::new(self.db.upcast(), self.expander.current_file_id),\n-                            );\n-\n-                            if !attrs.is_cfg_enabled(&crate_graph[module_id.krate].cfg_options) {\n+                            let attrs = self.expander.parse_attrs(&field);\n+                            if !self.expander.is_cfg_enabled(&attrs) {\n                                 return None;\n                             }\n "}, {"sha": "56a20c5bd18fa3355841e7d9e69fc50b3daf8109", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocContainerId, AssocItemId, ConstId, ConstLoc, Expander, FunctionId, FunctionLoc, HasModule,\n-    ImplId, Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    ImplId, Intern, Lookup, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -218,10 +218,17 @@ impl ImplData {\n         let mut items = Vec::new();\n \n         if let Some(item_list) = src.value.item_list() {\n-            items.extend(collect_impl_items(db, item_list.impl_items(), src.file_id, id));\n+            let mut expander = Expander::new(db, impl_loc.ast_id.file_id, module_id);\n+            items.extend(collect_impl_items(\n+                db,\n+                &mut expander,\n+                item_list.impl_items(),\n+                src.file_id,\n+                id,\n+            ));\n             items.extend(collect_impl_items_in_macros(\n                 db,\n-                module_id,\n+                &mut expander,\n                 &src.with_value(item_list),\n                 id,\n             ));\n@@ -268,18 +275,17 @@ impl ConstData {\n \n fn collect_impl_items_in_macros(\n     db: &dyn DefDatabase,\n-    module_id: ModuleId,\n+    expander: &mut Expander,\n     impl_def: &InFile<ast::ItemList>,\n     id: ImplId,\n ) -> Vec<AssocItemId> {\n-    let mut expander = Expander::new(db, impl_def.file_id, module_id);\n     let mut res = Vec::new();\n \n     // We set a limit to protect against infinite recursion\n     let limit = 100;\n \n     for m in impl_def.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-        res.extend(collect_impl_items_in_macro(db, &mut expander, m, id, limit))\n+        res.extend(collect_impl_items_in_macro(db, expander, m, id, limit))\n     }\n \n     res\n@@ -300,6 +306,7 @@ fn collect_impl_items_in_macro(\n         let items: InFile<ast::MacroItems> = expander.to_source(items);\n         let mut res = collect_impl_items(\n             db,\n+            expander,\n             items.value.items().filter_map(|it| ImplItem::cast(it.syntax().clone())),\n             items.file_id,\n             id,\n@@ -319,32 +326,26 @@ fn collect_impl_items_in_macro(\n \n fn collect_impl_items(\n     db: &dyn DefDatabase,\n+    expander: &mut Expander,\n     impl_items: impl Iterator<Item = ImplItem>,\n     file_id: crate::HirFileId,\n     id: ImplId,\n ) -> Vec<AssocItemId> {\n     let items = db.ast_id_map(file_id);\n-    let crate_graph = db.crate_graph();\n-    let module_id = id.lookup(db).container.module(db);\n \n     impl_items\n         .filter_map(|item_node| match item_node {\n             ast::ImplItem::FnDef(it) => {\n+                let attrs = expander.parse_attrs(&it);\n+                if !expander.is_cfg_enabled(&attrs) {\n+                    return None;\n+                }\n                 let def = FunctionLoc {\n                     container: AssocContainerId::ImplId(id),\n                     ast_id: AstId::new(file_id, items.ast_id(&it)),\n                 }\n                 .intern(db);\n-\n-                if !db\n-                    .function_data(def)\n-                    .attrs\n-                    .is_cfg_enabled(&crate_graph[module_id.krate].cfg_options)\n-                {\n-                    None\n-                } else {\n-                    Some(def.into())\n-                }\n+                Some(def.into())\n             }\n             ast::ImplItem::ConstDef(it) => {\n                 let def = ConstLoc {"}, {"sha": "98c74fe257b4bab593adbd5e0def01663cd4e4ea", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -462,6 +462,14 @@ impl DefCollector<'_> {\n                 Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n                     tested_by!(glob_enum);\n                     // glob import from enum => just import all the variants\n+\n+                    // XXX: urgh, so this works by accident! Here, we look at\n+                    // the enum data, and, in theory, this might require us to\n+                    // look back at the crate_def_map, creating a cycle. For\n+                    // example, `enum E { crate::some_macro!(); }`. Luckely, the\n+                    // only kind of macro that is allowed inside enum is a\n+                    // `cfg_macro`, and we don't need to run name resolution for\n+                    // it, but this is sheer luck!\n                     let enum_data = self.db.enum_data(e);\n                     let resolutions = enum_data\n                         .variants\n@@ -977,11 +985,7 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n-        // FIXME: handle cfg_attr :-)\n-        attrs\n-            .by_key(\"cfg\")\n-            .tt_values()\n-            .all(|tt| self.def_collector.cfg_options.is_cfg_enabled(tt) != Some(false))\n+        attrs.is_cfg_enabled(self.def_collector.cfg_options)\n     }\n }\n "}, {"sha": "87165ac33a60f028ff101849ed3c94e124c3c738", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a68c8f55e0770fdeae508a1710509c13aaffa1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=e7a68c8f55e0770fdeae508a1710509c13aaffa1", "patch": "@@ -32,6 +32,9 @@ fn typing_inside_a_function_should_not_invalidate_def_map() {\n \n         use crate::foo::bar::Baz;\n \n+        enum E { A, B }\n+        use E::*;\n+\n         fn foo() -> i32 {\n             1 + 1\n         }\n@@ -46,6 +49,9 @@ fn typing_inside_a_function_should_not_invalidate_def_map() {\n \n         use crate::foo::bar::Baz;\n \n+        enum E { A, B }\n+        use E::*;\n+\n         fn foo() -> i32 { 92 }\n         \",\n     );"}]}