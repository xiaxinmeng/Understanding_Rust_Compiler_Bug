{"sha": "8b0c292a728c113aaf1f27f079aae6a28110c587", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMGMyOTJhNzI4YzExM2FhZjFmMjdmMDc5YWFlNmEyODExMGM1ODc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-16T03:39:52Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-19T10:03:06Z"}, "message": "Improve `$crate`.", "tree": {"sha": "f495cf8a4abcd8f483d79b29727ab1e5498354fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f495cf8a4abcd8f483d79b29727ab1e5498354fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b0c292a728c113aaf1f27f079aae6a28110c587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b0c292a728c113aaf1f27f079aae6a28110c587", "html_url": "https://github.com/rust-lang/rust/commit/8b0c292a728c113aaf1f27f079aae6a28110c587", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b0c292a728c113aaf1f27f079aae6a28110c587/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b81106a8525f96d5a5890720cee265e49e77028", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b81106a8525f96d5a5890720cee265e49e77028", "html_url": "https://github.com/rust-lang/rust/commit/7b81106a8525f96d5a5890720cee265e49e77028"}], "stats": {"total": 123, "additions": 47, "deletions": 76}, "files": [{"sha": "f19afd67faa212da8442ac9688c3d9c54ab60288", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -37,6 +37,7 @@ use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::{SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::feature_gate::{self, emit_feature_err};\n use syntax::ext::tt::macro_rules;\n@@ -207,11 +208,16 @@ impl<'b> Resolver<'b> {\n                 };\n \n                 let mut custom_derive_crate = false;\n+                // The mark of the expansion that generates the loaded macros.\n+                let mut opt_mark = None;\n                 for loaded_macro in self.crate_loader.load_macros(item, is_crate_root) {\n+                    let mark = opt_mark.unwrap_or_else(Mark::fresh);\n+                    opt_mark = Some(mark);\n                     match loaded_macro.kind {\n                         LoadedMacroKind::Def(mut def) => {\n                             if def.use_locally {\n                                 self.macro_names.insert(def.ident.name);\n+                                def.body = mark_tts(&def.body, mark);\n                                 let ext = macro_rules::compile(&self.session.parse_sess, &def);\n                                 import_macro(self, def.ident.name, ext, loaded_macro.import_site);\n                             }\n@@ -249,6 +255,17 @@ impl<'b> Resolver<'b> {\n                     });\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n+                    if let Some(mark) = opt_mark {\n+                        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+                            module: Cell::new(module),\n+                            def_index: CRATE_DEF_INDEX,\n+                            const_integer: false,\n+                            legacy_scope: Cell::new(LegacyScope::Empty),\n+                            expansion: Cell::new(LegacyScope::Empty),\n+                        });\n+                        self.invocations.insert(mark, invocation);\n+                    }\n+\n                     self.populate_module_if_necessary(module);\n                 } else if custom_derive_crate {\n                     // Define an empty module"}, {"sha": "7091d7d2a632171f89eefbfd665dd702c2c11456", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -53,7 +53,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext::hygiene::Mark;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -1579,6 +1579,17 @@ impl<'a> Resolver<'a> {\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n+        if &*module_path[0].name.as_str() == \"$crate\" {\n+            let mut ctxt = module_path[0].ctxt;\n+            while ctxt.source().0 != SyntaxContext::empty() {\n+                ctxt = ctxt.source().0;\n+            }\n+            let module = self.invocations[&ctxt.source().1].module.get();\n+            let crate_root =\n+                if module.def_id().unwrap().is_local() { self.graph_root } else { module };\n+            return Success(PrefixFound(crate_root, 1))\n+        }\n+\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut i = match &*module_path[0].name.as_str() {"}, {"sha": "0f42b4520c9b7a17a890e225f94c4cb1aa845caf", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -29,10 +29,10 @@ use syntax_pos::Span;\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n-    def_index: DefIndex,\n+    pub def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n     // c.f. `DefCollector::visit_ast_const_integer`.\n-    const_integer: bool,\n+    pub const_integer: bool,\n     // The scope in which the invocation path is resolved.\n     pub legacy_scope: Cell<LegacyScope<'a>>,\n     // The smallest scope that includes this invocation's expansion,"}, {"sha": "bd47b1e7c121c4ca93d282958e048ec372d6f470", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -295,7 +295,9 @@ impl<'a> Classifier<'a> {\n                     \"Option\" | \"Result\" => Class::PreludeTy,\n                     \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n \n+                    \"$crate\" => Class::KeyWord,\n                     _ if tas.tok.is_any_keyword() => Class::KeyWord,\n+\n                     _ => {\n                         if self.in_macro_nonterminal {\n                             self.in_macro_nonterminal = false;\n@@ -310,9 +312,6 @@ impl<'a> Classifier<'a> {\n                 }\n             }\n \n-            // Special macro vars are like keywords.\n-            token::SpecialVarNt(_) => Class::KeyWord,\n-\n             token::Lifetime(..) => Class::Lifetime,\n \n             token::Underscore | token::Eof | token::Interpolated(..) |"}, {"sha": "e84a9208029a5e7e2a4379a0be9e275f8d5154f4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -939,6 +939,6 @@ impl Folder for Marker {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n+pub fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }"}, {"sha": "5496d27c087409ed8f8f95b1b74c1660912581ed", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -58,7 +58,6 @@ impl<'a> ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n-    imported_from: Option<ast::Ident>,\n     lhses: Vec<TokenTree>,\n     rhses: Vec<TokenTree>,\n     valid: bool,\n@@ -76,7 +75,6 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n-                          self.imported_from,\n                           arg,\n                           &self.lhses,\n                           &self.rhses)\n@@ -87,7 +85,6 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: ast::Ident,\n-                          imported_from: Option<ast::Ident>,\n                           arg: &[TokenTree],\n                           lhses: &[TokenTree],\n                           rhses: &[TokenTree])\n@@ -116,10 +113,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let trncbr = new_tt_reader(&cx.parse_sess.span_diagnostic,\n-                                           Some(named_matches),\n-                                           imported_from,\n-                                           rhs);\n+                let trncbr =\n+                    new_tt_reader(&cx.parse_sess.span_diagnostic, Some(named_matches), rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg().clone(), Box::new(trncbr));\n                 p.directory = cx.current_expansion.module.directory.clone();\n                 p.restrictions = match cx.current_expansion.no_noninline_mod {\n@@ -223,7 +218,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     ];\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(&sess.span_diagnostic, None, None, def.body.clone());\n+    let arg_reader = new_tt_reader(&sess.span_diagnostic, None, def.body.clone());\n \n     let argument_map = match parse(sess, &Vec::new(), arg_reader, &argument_gram) {\n         Success(m) => m,\n@@ -269,7 +264,6 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n \n     let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n-        imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n         valid: valid,"}, {"sha": "38a926b6e87c9ce1f9d00f430a2b1982d3592b1f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::{Handler, DiagnosticBuilder};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n-use parse::token::{Token, Interpolated, NtIdent, NtTT, SpecialMacroVar};\n+use parse::token::{Token, Interpolated, NtIdent, NtTT};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n use tokenstream::{self, TokenTree};\n@@ -39,10 +39,7 @@ pub struct TtReader<'a> {\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n     interpolations: HashMap<Ident, Rc<NamedMatch>>,\n-    imported_from: Option<Ident>,\n \n-    // Some => return imported_from as the next token\n-    crate_name_next: Option<Span>,\n     repeat_idx: Vec<usize>,\n     repeat_len: Vec<usize>,\n     /* cached: */\n@@ -59,10 +56,9 @@ pub struct TtReader<'a> {\n /// (and should) be None.\n pub fn new_tt_reader(sp_diag: &Handler,\n                      interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n-                     imported_from: Option<Ident>,\n                      src: Vec<tokenstream::TokenTree>)\n                      -> TtReader {\n-    new_tt_reader_with_doc_flag(sp_diag, interp, imported_from, src, false)\n+    new_tt_reader_with_doc_flag(sp_diag, interp, src, false)\n }\n \n /// The extra `desugar_doc_comments` flag enables reading doc comments\n@@ -73,7 +69,6 @@ pub fn new_tt_reader(sp_diag: &Handler,\n /// (and should) be None.\n pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n                                    interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n-                                   imported_from: Option<Ident>,\n                                    src: Vec<tokenstream::TokenTree>,\n                                    desugar_doc_comments: bool)\n                                    -> TtReader {\n@@ -93,8 +88,6 @@ pub fn new_tt_reader_with_doc_flag(sp_diag: &Handler,\n             None => HashMap::new(),\n             Some(x) => x,\n         },\n-        imported_from: imported_from,\n-        crate_name_next: None,\n         repeat_idx: Vec::new(),\n         repeat_len: Vec::new(),\n         desugar_doc_comments: desugar_doc_comments,\n@@ -189,14 +182,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         sp: r.cur_span.clone(),\n     };\n     loop {\n-        match r.crate_name_next.take() {\n-            None => (),\n-            Some(sp) => {\n-                r.cur_span = sp;\n-                r.cur_tok = token::Ident(r.imported_from.unwrap());\n-                return ret_val;\n-            },\n-        }\n         let should_pop = match r.stack.last() {\n             None => {\n                 assert_eq!(ret_val.tok, token::Eof);\n@@ -346,18 +331,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                    sep: None\n                 });\n             }\n-            TokenTree::Token(sp, token::SpecialVarNt(SpecialMacroVar::CrateMacroVar)) => {\n-                r.stack.last_mut().unwrap().idx += 1;\n-\n-                if r.imported_from.is_some() {\n-                    r.cur_span = sp;\n-                    r.cur_tok = token::ModSep;\n-                    r.crate_name_next = Some(sp);\n-                    return ret_val;\n-                }\n-\n-                // otherwise emit nothing and proceed to the next token\n-            }\n             TokenTree::Token(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;"}, {"sha": "1a84a750463c8ad31cb2e3f68f0fbdcbf97618ba", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -276,7 +276,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<tokenstream::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n-    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n+    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n     let mut p = Parser::new(sess, cfg, Box::new(trdr));\n     p.check_unknown_macro_variable();\n     p"}, {"sha": "eac78f5e6c68c66b415fad127bdbfe6f1647b240", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -48,8 +48,7 @@ use parse::classify;\n use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n-use parse::token::{self, intern, MatchNt, SubstNt, SpecialVarNt, InternedString};\n-use parse::token::{keywords, SpecialMacroVar};\n+use parse::token::{self, intern, keywords, MatchNt, SubstNt, InternedString};\n use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n@@ -2653,8 +2652,12 @@ impl<'a> Parser<'a> {\n                                           num_captures: name_num\n                                       })));\n                 } else if self.token.is_keyword(keywords::Crate) {\n+                    let ident = match self.token {\n+                        token::Ident(id) => ast::Ident { name: token::intern(\"$crate\"), ..id },\n+                        _ => unreachable!(),\n+                    };\n                     self.bump();\n-                    return Ok(TokenTree::Token(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar)));\n+                    return Ok(TokenTree::Token(sp, token::Ident(ident)));\n                 } else {\n                     sp = mk_sp(sp.lo, self.span.hi);\n                     self.parse_ident().unwrap_or_else(|mut e| {"}, {"sha": "26b5b99c8cce669542a145e0c81e08bdd21818c0", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -52,21 +52,6 @@ pub enum DelimToken {\n     NoDelim,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n-pub enum SpecialMacroVar {\n-    /// `$crate` will be filled in with the name of the crate a macro was\n-    /// imported from, if any.\n-    CrateMacroVar,\n-}\n-\n-impl SpecialMacroVar {\n-    pub fn as_str(self) -> &'static str {\n-        match self {\n-            SpecialMacroVar::CrateMacroVar => \"crate\",\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n@@ -148,8 +133,6 @@ pub enum Token {\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n     SubstNt(ast::Ident),\n-    /// A macro variable with special meaning.\n-    SpecialVarNt(SpecialMacroVar),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for"}, {"sha": "c6f63d772426a1d61be5bac0eab8213cf6262848", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -285,8 +285,6 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n-        token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n-\n         token::Interpolated(ref nt) => match *nt {\n             token::NtExpr(ref e)        => expr_to_string(&e),\n             token::NtMeta(ref e)        => meta_item_to_string(&e),"}, {"sha": "f22f920a7fa0e2c390fd20e6e028e18edbfe22eb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -134,7 +134,6 @@ impl TokenTree {\n                     AttrStyle::Inner => 3,\n                 }\n             }\n-            TokenTree::Token(_, token::SpecialVarNt(..)) => 2,\n             TokenTree::Token(_, token::MatchNt(..)) => 3,\n             TokenTree::Token(_, token::Interpolated(Nonterminal::NtTT(..))) => 1,\n             TokenTree::Delimited(_, ref delimed) => delimed.tts.len() + 2,\n@@ -188,11 +187,6 @@ impl TokenTree {\n                 }\n                 delimed.tts[index - 1].clone()\n             }\n-            (&TokenTree::Token(sp, token::SpecialVarNt(var)), _) => {\n-                let v = [TokenTree::Token(sp, token::Dollar),\n-                         TokenTree::Token(sp, token::Ident(token::str_to_ident(var.as_str())))];\n-                v[index].clone()\n-            }\n             (&TokenTree::Token(sp, token::MatchNt(name, kind)), _) => {\n                 let v = [TokenTree::Token(sp, token::SubstNt(name)),\n                          TokenTree::Token(sp, token::Colon),\n@@ -223,7 +217,6 @@ impl TokenTree {\n                  -> macro_parser::NamedParseResult {\n         // `None` is because we're not interpolating\n         let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n-                                                         None,\n                                                          None,\n                                                          tts.iter().cloned().collect(),\n                                                          true);"}, {"sha": "40ff4852e3856b159f273819fc107cff3b7c139d", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/8b0c292a728c113aaf1f27f079aae6a28110c587/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=8b0c292a728c113aaf1f27f079aae6a28110c587", "patch": "@@ -38,7 +38,7 @@\n \n \n \n-    ((::std::fmt::format as\n+    (($crate::fmt::format as\n          fn(std::fmt::Arguments<'_>) -> std::string::String {std::fmt::format})(((::std::fmt::Arguments::new_v1\n                                                                                      as\n                                                                                      fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})(({"}]}