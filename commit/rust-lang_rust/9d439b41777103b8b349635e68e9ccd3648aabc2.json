{"sha": "9d439b41777103b8b349635e68e9ccd3648aabc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNDM5YjQxNzc3MTAzYjhiMzQ5NjM1ZTY4ZTljY2QzNjQ4YWFiYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-24T05:09:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-24T05:09:31Z"}, "message": "Auto merge of #24759 - Manishearth:rollup2, r=Manishearth\n\nr? @Manishearth", "tree": {"sha": "d9eb7bf9fc542040af85ab1e962e8bf71c2d600e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9eb7bf9fc542040af85ab1e962e8bf71c2d600e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d439b41777103b8b349635e68e9ccd3648aabc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d439b41777103b8b349635e68e9ccd3648aabc2", "html_url": "https://github.com/rust-lang/rust/commit/9d439b41777103b8b349635e68e9ccd3648aabc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d439b41777103b8b349635e68e9ccd3648aabc2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21f278a6877b3a66f665d86402c6ae057827a610", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f278a6877b3a66f665d86402c6ae057827a610", "html_url": "https://github.com/rust-lang/rust/commit/21f278a6877b3a66f665d86402c6ae057827a610"}, {"sha": "131b5aca5a8c04f7a565e5f2c95eccbf9b75970f", "url": "https://api.github.com/repos/rust-lang/rust/commits/131b5aca5a8c04f7a565e5f2c95eccbf9b75970f", "html_url": "https://github.com/rust-lang/rust/commit/131b5aca5a8c04f7a565e5f2c95eccbf9b75970f"}], "stats": {"total": 214, "additions": 122, "deletions": 92}, "files": [{"sha": "a61d635af7df9381756c1295552d7fdfaa3a3703", "filename": "src/doc/reference.md", "status": "modified", "additions": 115, "deletions": 83, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=9d439b41777103b8b349635e68e9ccd3648aabc2", "patch": "@@ -29,7 +29,7 @@ You may also be interested in the [grammar].\n \n # Notation\n \n-Rust's grammar is defined over Unicode codepoints, each conventionally denoted\n+Rust's grammar is defined over Unicode code points, each conventionally denoted\n `U+XXXX`, for 4 or more hexadecimal digits `X`. _Most_ of Rust's grammar is\n confined to the ASCII range of Unicode, and is described in this document by a\n dialect of Extended Backus-Naur Form (EBNF), specifically a dialect of EBNF\n@@ -53,7 +53,7 @@ Where:\n - Square brackets are used to group rules.\n - `LITERAL` is a single printable ASCII character, or an escaped hexadecimal\n   ASCII code of the form `\\xQQ`, in single quotes, denoting the corresponding\n-  Unicode codepoint `U+00QQ`.\n+  Unicode code point `U+00QQ`.\n - `IDENTIFIER` is a nonempty string of ASCII letters and underscores.\n - The `repeat` forms apply to the adjacent `element`, and are as follows:\n   - `?` means zero or one repetition\n@@ -66,9 +66,9 @@ This EBNF dialect should hopefully be familiar to many readers.\n \n ## Unicode productions\n \n-A few productions in Rust's grammar permit Unicode codepoints outside the ASCII\n+A few productions in Rust's grammar permit Unicode code points outside the ASCII\n range. We define these productions in terms of character properties specified\n-in the Unicode standard, rather than in terms of ASCII-range codepoints. The\n+in the Unicode standard, rather than in terms of ASCII-range code points. The\n section [Special Unicode Productions](#special-unicode-productions) lists these\n productions.\n \n@@ -91,10 +91,10 @@ production. See [tokens](#tokens) for more information.\n \n ## Input format\n \n-Rust input is interpreted as a sequence of Unicode codepoints encoded in UTF-8.\n+Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8.\n Most Rust grammar rules are defined in terms of printable ASCII-range\n-codepoints, but a small number are defined in terms of Unicode properties or\n-explicit codepoint lists. [^inputformat]\n+code points, but a small number are defined in terms of Unicode properties or\n+explicit code point lists. [^inputformat]\n \n [^inputformat]: Substitute definitions for the special Unicode productions are\n   provided to the grammar verifier, restricted to ASCII range, when verifying the\n@@ -147,11 +147,13 @@ comments beginning with exactly one repeated asterisk in the block-open\n sequence (`/**`), are interpreted as a special syntax for `doc`\n [attributes](#attributes). That is, they are equivalent to writing\n `#[doc=\"...\"]` around the body of the comment (this includes the comment\n-characters themselves, ie `/// Foo` turns into `#[doc=\"/// Foo\"]`).\n+characters themselves, i.e. `/// Foo` turns into `#[doc=\"/// Foo\"]`).\n \n-`//!` comments apply to the parent of the comment, rather than the item that\n-follows. `//!` comments are usually used to display information on the crate\n-index page.\n+Line comments beginning with `//!` and block comments beginning with `/*!` are\n+doc comments that apply to the parent of the comment, rather than the item\n+that follows.  That is, they are equivalent to writing `#![doc=\"...\"]` around\n+the body of the comment. `//!` comments are usually used to display\n+information on the crate index page.\n \n Non-doc comments are interpreted as a form of whitespace.\n \n@@ -196,10 +198,11 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n | fn       | for      | if       | impl     | in      |\n | let      | loop     | macro    | match    | mod     |\n | move     | mut      | offsetof | override | priv    |\n-| pub      | pure     | ref      | return   | sizeof  |\n-| static   | self     | struct   | super    | true    |\n-| trait    | type     | typeof   | unsafe   | unsized |\n-| use      | virtual  | where    | while    | yield   |\n+| proc     | pub      | pure     | ref      | return  |\n+| Self     | self     | sizeof   | static   | struct  |\n+| super    | trait    | true     | type     | typeof  |\n+| unsafe   | unsized  | use      | virtual  | where   |\n+| while    | yield    |          |          |         |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -330,14 +333,14 @@ Some additional _escapes_ are available in either character or non-raw string\n literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n following forms:\n \n-* An _8-bit codepoint escape_ escape starts with `U+0078` (`x`) and is\n-  followed by exactly two _hex digits_. It denotes the Unicode codepoint\n+* An _8-bit code point escape_ starts with `U+0078` (`x`) and is\n+  followed by exactly two _hex digits_. It denotes the Unicode code point\n   equal to the provided hex value.\n-* A _24-bit codepoint escape_ starts with `U+0075` (`u`) and is followed\n+* A _24-bit code point escape_ starts with `U+0075` (`u`) and is followed\n   by up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D`\n-  (`}`). It denotes the Unicode codepoint equal to the provided hex value.\n+  (`}`). It denotes the Unicode code point equal to the provided hex value.\n * A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n-  (`r`), or `U+0074` (`t`), denoting the unicode values `U+000A` (LF),\n+  (`r`), or `U+0074` (`t`), denoting the Unicode values `U+000A` (LF),\n   `U+000D` (CR) or `U+0009` (HT) respectively.\n * The _backslash escape_ is the character `U+005C` (`\\`) which must be\n   escaped in order to denote *itself*.\n@@ -407,7 +410,7 @@ Some additional _escapes_ are available in either byte or non-raw byte string\n literals. An escape starts with a `U+005C` (`\\`) and continues with one of the\n following forms:\n \n-* An _byte escape_ escape starts with `U+0078` (`x`) and is\n+* A _byte escape_ escape starts with `U+0078` (`x`) and is\n   followed by exactly two _hex digits_. It denotes the byte\n   equal to the provided hex value.\n * A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`\n@@ -697,9 +700,9 @@ in macro rules). In the transcriber, the designator is already known, and so\n only the name of a matched nonterminal comes after the dollar sign.\n \n In both the matcher and transcriber, the Kleene star-like operator indicates\n-repetition. The Kleene star operator consists of `$` and parens, optionally\n+repetition. The Kleene star operator consists of `$` and parentheses, optionally\n followed by a separator token, followed by `*` or `+`. `*` means zero or more\n-repetitions, `+` means at least one repetition. The parens are not matched or\n+repetitions, `+` means at least one repetition. The parentheses are not matched or\n transcribed. On the matcher side, a name is bound to _all_ of the names it\n matches, in a structure that mimics the structure of the repetition encountered\n on a successful match. The job of the transcriber is to sort that structure\n@@ -1099,40 +1102,31 @@ signature. Each type parameter must be explicitly declared, in an\n angle-bracket-enclosed, comma-separated list following the function name.\n \n ```{.ignore}\n-fn iter<T>(seq: &[T], f: |T|) {\n-    for elt in seq.iter() { f(elt); }\n+fn iter<T, F>(seq: &[T], f: F) where T: Copy, F: Fn(T) {\n+    for elt in seq { f(*elt); }\n }\n-fn map<T, U>(seq: &[T], f: |T| -> U) -> Vec<U> {\n+fn map<T, U, F>(seq: &[T], f: F) -> Vec<U> where T: Copy, U: Copy, F: Fn(T) -> U {\n     let mut acc = vec![];\n-    for elt in seq.iter() { acc.push(f(elt)); }\n+    for elt in seq { acc.push(f(*elt)); }\n     acc\n }\n ```\n \n Inside the function signature and body, the name of the type parameter can be\n-used as a type name.\n+used as a type name. [Trait](#traits) bounds can be specified for type parameters\n+to allow methods with that trait to be called on values of that type. This is\n+specified using the `where` syntax, as in the above example.\n \n When a generic function is referenced, its type is instantiated based on the\n context of the reference. For example, calling the `iter` function defined\n above on `[1, 2]` will instantiate type parameter `T` with `i32`, and require\n-the closure parameter to have type `fn(i32)`.\n+the closure parameter to have type `Fn(i32)`.\n \n The type parameters can also be explicitly supplied in a trailing\n [path](#paths) component after the function name. This might be necessary if\n there is not sufficient context to determine the type parameters. For example,\n `mem::size_of::<u32>() == 4`.\n \n-Since a parameter type is opaque to the generic function, the set of operations\n-that can be performed on it is limited. Values of parameter type can only be\n-moved, not copied.\n-\n-```\n-fn id<T>(x: T) -> T { x }\n-```\n-\n-Similarly, [trait](#traits) bounds can be specified for type parameters to\n-allow methods with that trait to be called on values of that type.\n-\n #### Unsafety\n \n Unsafe operations are those that potentially violate the memory-safety\n@@ -1209,9 +1203,9 @@ the guarantee that these issues are never caused by safe code.\n \n [noalias]: http://llvm.org/docs/LangRef.html#noalias\n \n-##### Behaviour not considered unsafe\n+##### Behavior not considered unsafe\n \n-This is a list of behaviour not considered *unsafe* in Rust terms, but that may\n+This is a list of behavior not considered *unsafe* in Rust terms, but that may\n be undesired.\n \n * Deadlocks\n@@ -1304,7 +1298,7 @@ specific type, but may implement several different traits, or be compatible with\n several different type constraints.\n \n For example, the following defines the type `Point` as a synonym for the type\n-`(u8, u8)`, the type of pairs of unsigned 8 bit integers.:\n+`(u8, u8)`, the type of pairs of unsigned 8 bit integers:\n \n ```\n type Point = (u8, u8);\n@@ -1555,7 +1549,7 @@ fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n }\n ```\n \n-Traits also define an [object type](#object-types) with the same name as the\n+Traits also define an [trait object](#trait-objects) with the same name as the\n trait. Values of this type are created by [casting](#type-cast-expressions)\n pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n@@ -1958,7 +1952,7 @@ type int8_t = i8;\n \n ### Crate-only attributes\n \n-- `crate_name` - specify the this crate's crate name.\n+- `crate_name` - specify the crate's crate name.\n - `crate_type` - see [linkage](#linkage).\n - `feature` - see [compiler features](#compiler-features).\n - `no_builtins` - disable optimizing certain code patterns to invocations of\n@@ -2146,7 +2140,7 @@ The following configurations must be defined by the implementation:\n   `\"unix\"` or `\"windows\"`. The value of this configuration option is defined\n   as a configuration itself, like `unix` or `windows`.\n * `target_os = \"...\"`. Operating system of the target, examples include\n-  `\"win32\"`, `\"macos\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"`, `\"dragonfly\"`,\n+  `\"windows\"`, `\"macos\"`, `\"ios\"`, `\"linux\"`, `\"android\"`, `\"freebsd\"`, `\"dragonfly\"`,\n   `\"bitrig\"` or `\"openbsd\"`.\n * `target_pointer_width = \"...\"`. Target pointer width in bits. This is set\n   to `\"32\"` for targets with 32-bit pointers, and likewise set to `\"64\"` for\n@@ -2744,7 +2738,7 @@ A _method call_ consists of an expression followed by a single dot, an\n identifier, and a parenthesized expression-list. Method calls are resolved to\n methods on specific traits, either statically dispatching to a method if the\n exact `self`-type of the left-hand-side is known, or dynamically dispatching if\n-the left-hand-side expression is an indirect [object type](#object-types).\n+the left-hand-side expression is an indirect [trait object](#trait-objects).\n \n ### Field expressions\n \n@@ -2812,6 +2806,33 @@ _panicked state_.\n ([\"a\", \"b\"])[10]; // panics\n ```\n \n+### Range expressions\n+\n+```{.ebnf .gram}\n+range_expr : expr \"..\" expr |\n+             expr \"..\" |\n+             \"..\" expr |\n+             \"..\" ;\n+```\n+\n+The `..` operator will construct an object of one of the `std::ops::Range` variants.\n+\n+```\n+1..2;   // std::ops::Range\n+3..;    // std::ops::RangeFrom\n+..4;    // std::ops::RangeTo\n+..;     // std::ops::RangeFull\n+```\n+\n+The following expressions are equivalent.\n+\n+```\n+let x = std::ops::Range {start: 0, end: 10};\n+let y = 0..10;\n+\n+assert_eq!(x,y);\n+```\n+\n ### Unary operator expressions\n \n Rust defines three unary operators. They are all written as prefix operators,\n@@ -3078,28 +3099,6 @@ fn ten_times<F>(f: F) where F: Fn(i32) {\n ten_times(|j| println!(\"hello, {}\", j));\n ```\n \n-### While loops\n-\n-```{.ebnf .gram}\n-while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n-```\n-\n-A `while` loop begins by evaluating the boolean loop conditional expression.\n-If the loop conditional expression evaluates to `true`, the loop body block\n-executes and control returns to the loop conditional expression. If the loop\n-conditional expression evaluates to `false`, the `while` expression completes.\n-\n-An example:\n-\n-```\n-let mut i = 0;\n-\n-while i < 10 {\n-    println!(\"hello\");\n-    i = i + 1;\n-}\n-```\n-\n ### Infinite loops\n \n A `loop` expression denotes an infinite loop.\n@@ -3108,10 +3107,11 @@ A `loop` expression denotes an infinite loop.\n loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n ```\n \n-A `loop` expression may optionally have a _label_. If a label is present, then\n-labeled `break` and `continue` expressions nested within this loop may exit out\n-of this loop or return control to its head. See [Break\n-expressions](#break-expressions) and [Continue\n+A `loop` expression may optionally have a _label_. The label is written as\n+a lifetime preceding the loop expression, as in `'foo: loop{ }`. If a\n+label is present, then labeled `break` and `continue` expressions nested\n+within this loop may exit out of this loop or return control to its head.\n+See [Break expressions](#break-expressions) and [Continue\n expressions](#continue-expressions).\n \n ### Break expressions\n@@ -3123,7 +3123,7 @@ break_expr : \"break\" [ lifetime ];\n A `break` expression has an optional _label_. If the label is absent, then\n executing a `break` expression immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop. If the label is\n-present, then `break foo` terminates the loop with label `foo`, which need not\n+present, then `break 'foo` terminates the loop with label `'foo`, which need not\n be the innermost label enclosing the `break` expression, but must enclose it.\n \n ### Continue expressions\n@@ -3137,12 +3137,39 @@ executing a `continue` expression immediately terminates the current iteration\n of the innermost loop enclosing it, returning control to the loop *head*. In\n the case of a `while` loop, the head is the conditional expression controlling\n the loop. In the case of a `for` loop, the head is the call-expression\n-controlling the loop. If the label is present, then `continue foo` returns\n-control to the head of the loop with label `foo`, which need not be the\n+controlling the loop. If the label is present, then `continue 'foo` returns\n+control to the head of the loop with label `'foo`, which need not be the\n innermost label enclosing the `break` expression, but must enclose it.\n \n A `continue` expression is only permitted in the body of a loop.\n \n+### While loops\n+\n+```{.ebnf .gram}\n+while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n+```\n+\n+A `while` loop begins by evaluating the boolean loop conditional expression.\n+If the loop conditional expression evaluates to `true`, the loop body block\n+executes and control returns to the loop conditional expression. If the loop\n+conditional expression evaluates to `false`, the `while` expression completes.\n+\n+An example:\n+\n+```\n+let mut i = 0;\n+\n+while i < 10 {\n+    println!(\"hello\");\n+    i = i + 1;\n+}\n+```\n+\n+Like `loop` expressions, `while` loops can be controlled with `break` or\n+`continue`, and may optionally have a _label_. See [infinite\n+loops](#infinite-loops), [break expressions](#break-expressions), and\n+[continue expressions](#continue-expressions) for more information.\n+\n ### For expressions\n \n ```{.ebnf .gram}\n@@ -3177,6 +3204,11 @@ for i in 0..256 {\n }\n ```\n \n+Like `loop` expressions, `for` loops can be controlled with `break` or\n+`continue`, and may optionally have a _label_. See [infinite\n+loops](#infinite-loops), [break expressions](#break-expressions), and\n+[continue expressions](#continue-expressions) for more information.\n+\n ### If expressions\n \n ```{.ebnf .gram}\n@@ -3432,7 +3464,7 @@ is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to\n UTF-32 string.\n \n A value of type `str` is a Unicode string, represented as an array of 8-bit\n-unsigned bytes holding a sequence of UTF-8 codepoints. Since `str` is of\n+unsigned bytes holding a sequence of UTF-8 code points. Since `str` is of\n unknown size, it is not a _first-class_ type, but can only be instantiated\n through a pointer type, such as `&str` or `String`.\n \n@@ -3649,23 +3681,23 @@ call_closure(closure_no_args, closure_args);\n \n ```\n \n-### Object types\n+### Trait objects\n \n Every trait item (see [traits](#traits)) defines a type with the same name as\n-the trait. This type is called the _object type_ of the trait. Object types\n+the trait. This type is called the _trait object_ of the trait. Trait objects\n permit \"late binding\" of methods, dispatched using _virtual method tables_\n (\"vtables\"). Whereas most calls to trait methods are \"early bound\" (statically\n resolved) to specific implementations at compile time, a call to a method on an\n-object type is only resolved to a vtable entry at compile time. The actual\n+trait objects is only resolved to a vtable entry at compile time. The actual\n implementation for each vtable entry can vary on an object-by-object basis.\n \n Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n implements trait `R`, casting `E` to the corresponding pointer type `&R` or\n-`Box<R>` results in a value of the _object type_ `R`. This result is\n+`Box<R>` results in a value of the _trait object_ `R`. This result is\n represented as a pair of pointers: the vtable pointer for the `T`\n implementation of `R`, and the pointer value of `E`.\n \n-An example of an object type:\n+An example of a trait object:\n \n ```\n trait Printable {\n@@ -3685,7 +3717,7 @@ fn main() {\n }\n ```\n \n-In this example, the trait `Printable` occurs as an object type in both the\n+In this example, the trait `Printable` occurs as a trait object in both the\n type signature of `print`, and the cast expression in `main`.\n \n ### Type parameters"}, {"sha": "9d01f104ddaafcdcb824ccf4241189c743667c58", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=9d439b41777103b8b349635e68e9ccd3648aabc2", "patch": "@@ -57,8 +57,7 @@ let x: Vec<u32> = {\n We can implement this shorthand, using a macro: [^actual]\n \n [^actual]: The actual definition of `vec!` in libcollections differs from the\n-           one presented here, for reasons of efficiency and reusability. Some\n-           of these are mentioned in the [advanced macros chapter][].\n+           one presented here, for reasons of efficiency and reusability.\n \n ```rust\n macro_rules! vec {\n@@ -106,7 +105,7 @@ These have [their own little grammar] within the language.\n \n The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n to the \u2018metavariable\u2019 `$x`. The identifier `expr` is a \u2018fragment specifier\u2019;\n-the full possibilities are enumerated in the [advanced macros chapter][].\n+the full possibilities are enumerated later in this chapter.\n Surrounding the matcher with `$(...),*` will match zero or more expressions,\n separated by commas.\n \n@@ -566,7 +565,7 @@ When this library is loaded with `#[macro_use] extern crate`, only `m2` will\n be imported.\n \n The Rust Reference has a [listing of macro-related\n-attributes](../reference.html#macro--and-plugin-related-attributes).\n+attributes](../reference.html#macro-related-attributes).\n \n # The variable `$crate`\n "}, {"sha": "68006a8979a6468c702fe7d0497a869d830c9e52", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9d439b41777103b8b349635e68e9ccd3648aabc2", "patch": "@@ -1151,8 +1151,8 @@ impl<'a> Parser<'a> {\n             &token::CloseDelim(token::Brace),\n             seq_sep_none(),\n             |p| {\n-            let lo = p.span.lo;\n             let mut attrs = p.parse_outer_attributes();\n+            let lo = p.span.lo;\n \n             let (name, node) = if try!(p.eat_keyword(keywords::Type)) {\n                 let TyParam {ident, bounds, default, ..} = try!(p.parse_ty_param());\n@@ -3409,8 +3409,8 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let lo = self.span.lo;\n         let attrs = self.parse_outer_attributes();\n+        let lo = self.span.lo;\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n             check_expected_item(self, &attrs);\n@@ -4304,8 +4304,8 @@ impl<'a> Parser<'a> {\n \n     /// Parse an impl item.\n     pub fn parse_impl_item(&mut self) -> PResult<P<ImplItem>> {\n-        let lo = self.span.lo;\n         let mut attrs = self.parse_outer_attributes();\n+        let lo = self.span.lo;\n         let vis = try!(self.parse_visibility());\n         let (name, node) = if try!(self.eat_keyword(keywords::Type)) {\n             let name = try!(self.parse_ident());\n@@ -5380,9 +5380,8 @@ impl<'a> Parser<'a> {\n \n     /// Parse a foreign item.\n     fn parse_foreign_item(&mut self) -> PResult<Option<P<ForeignItem>>> {\n-        let lo = self.span.lo;\n-\n         let attrs = self.parse_outer_attributes();\n+        let lo = self.span.lo;\n         let visibility = try!(self.parse_visibility());\n \n         if self.check_keyword(keywords::Static) {"}]}