{"sha": "242a252687264e1115dbfa5f2b4890a35d224a05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MmEyNTI2ODcyNjRlMTExNWRiZmE1ZjJiNDg5MGEzNWQyMjRhMDU=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-12-30T20:56:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-30T20:56:45Z"}, "message": "Rollup merge of #78934 - DeveloperC286:issue_60302_vec, r=m-ou-se\n\nrefactor: removing library/alloc/src/vec/mod.rs ignore-tidy-filelength\n\nThis PR removes the need for ignore-tidy-filelength for library/alloc/src/vec/mod.rs which is part of the issue #60302\n\nIt is probably easiest to review this PR by looking at it commit by commit rather than looking at the overall diff.", "tree": {"sha": "002a1b284b145f6bb65ef5bdcf18870be0c284b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/002a1b284b145f6bb65ef5bdcf18870be0c284b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/242a252687264e1115dbfa5f2b4890a35d224a05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf7OmNCRBK7hj4Ov3rIwAAdHIIAIY9YsOZAYncOeZjebtLK7it\nrMhyPYHjkg5C/PJCdLez7SfyPGhjLBdkXHSKTdc658YavgCn5s+sAuLf8n2FRs56\nVurTilifVLl5NQXw1bwTOAUhU91VCVEtPjqBpBp5T8alQ97W1uXP201OE9Lrwc+M\n2p/ZASzTDiIbT9U6qL/vZijQLO91uMWwfFyd7n9Nw7oVPlKiB0CmVHzpy0IU/Trf\ngtNQFw4HNZglh2ztC9jgKS0hcWtTvCJqU+kQd93sQgkoVmuD81iR6BTpkd5zJaOJ\n392U8g6HaK8YOLWkLMMO6/9H5UOEwDxeNIt7FSquQV/+195d+2nSwL8+GExVyMY=\n=w97l\n-----END PGP SIGNATURE-----\n", "payload": "tree 002a1b284b145f6bb65ef5bdcf18870be0c284b0\nparent 507bff92fadf1f25a830da5065a5a87113345163\nparent 16834a8f52853be76cf4a96de120042f2a4a96a2\nauthor Mara Bos <m-ou.se@m-ou.se> 1609361805 +0000\ncommitter GitHub <noreply@github.com> 1609361805 +0000\n\nRollup merge of #78934 - DeveloperC286:issue_60302_vec, r=m-ou-se\n\nrefactor: removing library/alloc/src/vec/mod.rs ignore-tidy-filelength\n\nThis PR removes the need for ignore-tidy-filelength for library/alloc/src/vec/mod.rs which is part of the issue #60302\n\nIt is probably easiest to review this PR by looking at it commit by commit rather than looking at the overall diff.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/242a252687264e1115dbfa5f2b4890a35d224a05", "html_url": "https://github.com/rust-lang/rust/commit/242a252687264e1115dbfa5f2b4890a35d224a05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/242a252687264e1115dbfa5f2b4890a35d224a05/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "507bff92fadf1f25a830da5065a5a87113345163", "url": "https://api.github.com/repos/rust-lang/rust/commits/507bff92fadf1f25a830da5065a5a87113345163", "html_url": "https://github.com/rust-lang/rust/commit/507bff92fadf1f25a830da5065a5a87113345163"}, {"sha": "16834a8f52853be76cf4a96de120042f2a4a96a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/16834a8f52853be76cf4a96de120042f2a4a96a2", "html_url": "https://github.com/rust-lang/rust/commit/16834a8f52853be76cf4a96de120042f2a4a96a2"}], "stats": {"total": 2650, "additions": 1378, "deletions": 1272}, "files": [{"sha": "73d15d3064789356264705c5ed125704bdacd2ea", "filename": "library/alloc/src/vec/cow.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fcow.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,35 @@\n+use crate::borrow::Cow;\n+use core::iter::FromIterator;\n+\n+use super::Vec;\n+\n+#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n+    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n+        Cow::Borrowed(s)\n+    }\n+}\n+\n+#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n+impl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n+    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n+        Cow::Owned(v)\n+    }\n+}\n+\n+#[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\n+impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n+    fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n+        Cow::Borrowed(v.as_slice())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T> FromIterator<T> for Cow<'a, [T]>\n+where\n+    T: Clone,\n+{\n+    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n+        Cow::Owned(FromIterator::from_iter(it))\n+    }\n+}"}, {"sha": "fb32d144f872c001b2f4c0ad4a626b248a27d8c1", "filename": "library/alloc/src/vec/drain.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,155 @@\n+use crate::alloc::{Allocator, Global};\n+use core::fmt;\n+use core::iter::{FusedIterator, TrustedLen};\n+use core::mem::{self};\n+use core::ptr::{self, NonNull};\n+use core::slice::{self};\n+\n+use super::Vec;\n+\n+/// A draining iterator for `Vec<T>`.\n+///\n+/// This `struct` is created by [`Vec::drain`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::Drain<_> = v.drain(..);\n+/// ```\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub struct Drain<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n+> {\n+    /// Index of tail to preserve\n+    pub(super) tail_start: usize,\n+    /// Length of tail\n+    pub(super) tail_len: usize,\n+    /// Current remaining range to remove\n+    pub(super) iter: slice::Iter<'a, T>,\n+    pub(super) vec: NonNull<Vec<T, A>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n+    }\n+}\n+\n+impl<'a, T, A: Allocator> Drain<'a, T, A> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec!['a', 'b', 'c'];\n+    /// let mut drain = vec.drain(..);\n+    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = drain.next().unwrap();\n+    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        self.iter.as_slice()\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        unsafe { self.vec.as_ref().allocator() }\n+    }\n+}\n+\n+#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n+impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n+    fn drop(&mut self) {\n+        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n+        /// un-`Drain`ed elements to restore the original `Vec`.\n+        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n+\n+        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we have below. If the loop already finished, this does\n+                // nothing.\n+                self.0.for_each(drop);\n+\n+                if self.0.tail_len > 0 {\n+                    unsafe {\n+                        let source_vec = self.0.vec.as_mut();\n+                        // memmove back untouched tail, update to new length\n+                        let start = source_vec.len();\n+                        let tail = self.0.tail_start;\n+                        if tail != start {\n+                            let src = source_vec.as_ptr().add(tail);\n+                            let dst = source_vec.as_mut_ptr().add(start);\n+                            ptr::copy(src, dst, self.0.tail_len);\n+                        }\n+                        source_vec.set_len(start + self.0.tail_len);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // exhaust self first\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n+        DropGuard(self);\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}"}, {"sha": "3c37c92ae44b0cbdbe68a8c0cea948afbaa352ef", "filename": "library/alloc/src/vec/drain_filter.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fdrain_filter.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,143 @@\n+use crate::alloc::{Allocator, Global};\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::Vec;\n+\n+/// An iterator which uses a closure to determine if an element should be removed.\n+///\n+/// This struct is created by [`Vec::drain_filter`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(drain_filter)]\n+///\n+/// let mut v = vec![0, 1, 2];\n+/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n+/// ```\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+#[derive(Debug)]\n+pub struct DrainFilter<\n+    'a,\n+    T,\n+    F,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    pub(super) vec: &'a mut Vec<T, A>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n+    pub(super) idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n+    pub(super) del: usize,\n+    /// The original length of `vec` prior to draining.\n+    pub(super) old_len: usize,\n+    /// The filter test predicate.\n+    pub(super) pred: F,\n+    /// A flag that indicates a panic has occurred in the filter test predicate.\n+    /// This is used as a hint in the drop implementation to prevent consumption\n+    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n+    pub(super) panic_flag: bool,\n+}\n+\n+impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        self.vec.allocator()\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        unsafe {\n+            while self.idx < self.old_len {\n+                let i = self.idx;\n+                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n+                if drained {\n+                    self.del += 1;\n+                    return Some(ptr::read(&v[i]));\n+                } else if self.del > 0 {\n+                    let del = self.del;\n+                    let src: *const T = &v[i];\n+                    let dst: *mut T = &mut v[i - del];\n+                    ptr::copy_nonoverlapping(src, dst, 1);\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(self.old_len - self.idx))\n+    }\n+}\n+\n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n+where\n+    F: FnMut(&mut T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n+        where\n+            F: FnMut(&mut T) -> bool,\n+        {\n+            drain: &'b mut DrainFilter<'a, T, F, A>,\n+        }\n+\n+        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n+        where\n+            F: FnMut(&mut T) -> bool,\n+        {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n+                        // This is a pretty messed up state, and there isn't really an\n+                        // obviously right thing to do. We don't want to keep trying\n+                        // to execute `pred`, so we just backshift all the unprocessed\n+                        // elements and tell the vec that they still exist. The backshift\n+                        // is required to prevent a double-drop of the last successfully\n+                        // drained item prior to a panic in the predicate.\n+                        let ptr = self.drain.vec.as_mut_ptr();\n+                        let src = ptr.add(self.drain.idx);\n+                        let dst = src.sub(self.drain.del);\n+                        let tail_len = self.drain.old_len - self.drain.idx;\n+                        src.copy_to(dst, tail_len);\n+                    }\n+                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n+                }\n+            }\n+        }\n+\n+        let backshift = BackshiftOnDrop { drain: self };\n+\n+        // Attempt to consume any remaining elements if the filter predicate\n+        // has not yet panicked. We'll backshift any remaining elements\n+        // whether we've already panicked or if the consumption here panics.\n+        if !backshift.drain.panic_flag {\n+            backshift.drain.for_each(drop);\n+        }\n+    }\n+}"}, {"sha": "354d25c2389fbd515a541ff274de48200b4a6f66", "filename": "library/alloc/src/vec/in_place_drop.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_drop.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,24 @@\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+// A helper struct for in-place iteration that drops the destination slice of iteration,\n+// i.e. the head. The source slice (the tail) is dropped by IntoIter.\n+pub(super) struct InPlaceDrop<T> {\n+    pub(super) inner: *mut T,\n+    pub(super) dst: *mut T,\n+}\n+\n+impl<T> InPlaceDrop<T> {\n+    fn len(&self) -> usize {\n+        unsafe { self.dst.offset_from(self.inner) as usize }\n+    }\n+}\n+\n+impl<T> Drop for InPlaceDrop<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            ptr::drop_in_place(slice::from_raw_parts_mut(self.inner, self.len()));\n+        }\n+    }\n+}"}, {"sha": "f131d06bb18f9ded903cd553f506027c858c0d54", "filename": "library/alloc/src/vec/into_iter.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,283 @@\n+use crate::alloc::{Allocator, Global};\n+use crate::raw_vec::RawVec;\n+use core::fmt;\n+use core::intrinsics::arith_offset;\n+use core::iter::{FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess};\n+use core::marker::PhantomData;\n+use core::mem::{self};\n+use core::ptr::{self, NonNull};\n+use core::slice::{self};\n+\n+/// An iterator that moves out of a vector.\n+///\n+/// This `struct` is created by the `into_iter` method on [`Vec`](super::Vec)\n+/// (provided by the [`IntoIterator`] trait).\n+///\n+/// # Example\n+///\n+/// ```\n+/// let v = vec![0, 1, 2];\n+/// let iter: std::vec::IntoIter<_> = v.into_iter();\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    pub(super) buf: NonNull<T>,\n+    pub(super) phantom: PhantomData<T>,\n+    pub(super) cap: usize,\n+    pub(super) alloc: A,\n+    pub(super) ptr: *const T,\n+    pub(super) end: *const T,\n+}\n+\n+#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n+    }\n+}\n+\n+impl<T, A: Allocator> IntoIter<T, A> {\n+    /// Returns the remaining items of this iterator as a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// let mut into_iter = vec.into_iter();\n+    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n+    /// let _ = into_iter.next().unwrap();\n+    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n+    /// ```\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n+    }\n+\n+    /// Returns the remaining items of this iterator as a mutable slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// let mut into_iter = vec.into_iter();\n+    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n+    /// into_iter.as_mut_slice()[2] = 'z';\n+    /// assert_eq!(into_iter.next().unwrap(), 'a');\n+    /// assert_eq!(into_iter.next().unwrap(), 'b');\n+    /// assert_eq!(into_iter.next().unwrap(), 'z');\n+    /// ```\n+    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n+    pub fn as_mut_slice(&mut self) -> &mut [T] {\n+        unsafe { &mut *self.as_raw_mut_slice() }\n+    }\n+\n+    /// Returns a reference to the underlying allocator.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn allocator(&self) -> &A {\n+        &self.alloc\n+    }\n+\n+    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n+        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n+    }\n+\n+    pub(super) fn drop_remaining(&mut self) {\n+        unsafe {\n+            ptr::drop_in_place(self.as_mut_slice());\n+        }\n+        self.ptr = self.end;\n+    }\n+\n+    /// Relinquishes the backing allocation, equivalent to\n+    /// `ptr::write(&mut self, Vec::new().into_iter())`\n+    pub(super) fn forget_allocation(&mut self) {\n+        self.cap = 0;\n+        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n+        self.ptr = self.buf.as_ptr();\n+        self.end = self.buf.as_ptr();\n+    }\n+}\n+\n+#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n+impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        if self.ptr as *const _ == self.end {\n+            None\n+        } else if mem::size_of::<T>() == 0 {\n+            // purposefully don't use 'ptr.offset' because for\n+            // vectors with 0-size elements this would return the\n+            // same pointer.\n+            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n+\n+            // Make up a value of this ZST.\n+            Some(unsafe { mem::zeroed() })\n+        } else {\n+            let old = self.ptr;\n+            self.ptr = unsafe { self.ptr.offset(1) };\n+\n+            Some(unsafe { ptr::read(old) })\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = if mem::size_of::<T>() == 0 {\n+            (self.end as usize).wrapping_sub(self.ptr as usize)\n+        } else {\n+            unsafe { self.end.offset_from(self.ptr) as usize }\n+        };\n+        (exact, Some(exact))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must guarantee that `i` is in bounds of the\n+        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n+        // is guaranteed to pointer to an element of the `Vec<T>` and\n+        // thus guaranteed to be valid to dereference.\n+        //\n+        // Also note the implementation of `Self: TrustedRandomAccess` requires\n+        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n+        // them for `Drop`.\n+        unsafe {\n+            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        if self.end == self.ptr {\n+            None\n+        } else if mem::size_of::<T>() == 0 {\n+            // See above for why 'ptr.offset' isn't used\n+            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n+\n+            // Make up a value of this ZST.\n+            Some(unsafe { mem::zeroed() })\n+        } else {\n+            self.end = unsafe { self.end.offset(-1) };\n+\n+            Some(unsafe { ptr::read(self.end) })\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n+    fn is_empty(&self) -> bool {\n+        self.ptr == self.end\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n+\n+#[doc(hidden)]\n+#[unstable(issue = \"none\", feature = \"std_internals\")]\n+// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n+// and thus we can't implement drop-handling\n+unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n+where\n+    T: Copy,\n+{\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n+impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n+    #[cfg(not(test))]\n+    fn clone(&self) -> Self {\n+        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n+    }\n+    #[cfg(test)]\n+    fn clone(&self) -> Self {\n+        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n+    fn drop(&mut self) {\n+        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n+\n+        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    // `IntoIter::alloc` is not used anymore after this\n+                    let alloc = ptr::read(&self.0.alloc);\n+                    // RawVec handles deallocation\n+                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n+                }\n+            }\n+        }\n+\n+        let guard = DropGuard(self);\n+        // destroy the remaining elements\n+        unsafe {\n+            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n+        }\n+        // now `guard` will be dropped and do the rest\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n+    type Source = Self;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n+        self\n+    }\n+}\n+\n+// internal helper trait for in-place iteration specialization.\n+#[rustc_specialization_trait]\n+pub(crate) trait AsIntoIter {\n+    type Item;\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n+}\n+\n+impl<T> AsIntoIter for IntoIter<T> {\n+    type Item = T;\n+\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {\n+        self\n+    }\n+}"}, {"sha": "b5739970b6ea469306eef375d3fe223f49363f10", "filename": "library/alloc/src/vec/is_zero.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,71 @@\n+use crate::boxed::Box;\n+\n+#[rustc_specialization_trait]\n+pub(super) unsafe trait IsZero {\n+    /// Whether this value is zero\n+    fn is_zero(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_zero {\n+    ($t:ty, $is_zero:expr) => {\n+        unsafe impl IsZero for $t {\n+            #[inline]\n+            fn is_zero(&self) -> bool {\n+                $is_zero(*self)\n+            }\n+        }\n+    };\n+}\n+\n+impl_is_zero!(i16, |x| x == 0);\n+impl_is_zero!(i32, |x| x == 0);\n+impl_is_zero!(i64, |x| x == 0);\n+impl_is_zero!(i128, |x| x == 0);\n+impl_is_zero!(isize, |x| x == 0);\n+\n+impl_is_zero!(u16, |x| x == 0);\n+impl_is_zero!(u32, |x| x == 0);\n+impl_is_zero!(u64, |x| x == 0);\n+impl_is_zero!(u128, |x| x == 0);\n+impl_is_zero!(usize, |x| x == 0);\n+\n+impl_is_zero!(bool, |x| x == false);\n+impl_is_zero!(char, |x| x == '\\0');\n+\n+impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n+impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n+\n+unsafe impl<T> IsZero for *const T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n+\n+unsafe impl<T> IsZero for *mut T {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        (*self).is_null()\n+    }\n+}\n+\n+// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n+// variant are padding in the `None` variant, so ignoring them and\n+// zero-initializing instead is ok.\n+// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n+// `SpecFromElem`.\n+\n+unsafe impl<T: ?Sized> IsZero for Option<&T> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n+    #[inline]\n+    fn is_zero(&self) -> bool {\n+        self.is_none()\n+    }\n+}"}, {"sha": "2a83eb33fe3eca2979cc530f5684bf5741944ff9", "filename": "library/alloc/src/vec/mod.rs", "status": "renamed", "additions": 56, "deletions": 1268, "changes": 1324, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! A contiguous growable array type with heap-allocated contents, written\n //! `Vec<T>`.\n //!\n@@ -59,9 +58,7 @@ use core::convert::TryFrom;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{\n-    FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess,\n-};\n+use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::{self, Index, IndexMut, Range, RangeBounds};\n@@ -74,6 +71,61 @@ use crate::boxed::Box;\n use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n \n+#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n+pub use self::drain_filter::DrainFilter;\n+\n+mod drain_filter;\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+pub use self::splice::Splice;\n+\n+mod splice;\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub use self::drain::Drain;\n+\n+mod drain;\n+\n+mod cow;\n+\n+pub(crate) use self::into_iter::AsIntoIter;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::into_iter::IntoIter;\n+\n+mod into_iter;\n+\n+use self::is_zero::IsZero;\n+\n+mod is_zero;\n+\n+mod source_iter_marker;\n+\n+mod partial_eq;\n+\n+use self::spec_from_elem::SpecFromElem;\n+\n+mod spec_from_elem;\n+\n+use self::set_len_on_drop::SetLenOnDrop;\n+\n+mod set_len_on_drop;\n+\n+use self::in_place_drop::InPlaceDrop;\n+\n+mod in_place_drop;\n+\n+use self::spec_from_iter_nested::SpecFromIterNested;\n+\n+mod spec_from_iter_nested;\n+\n+use self::spec_from_iter::SpecFromIter;\n+\n+mod spec_from_iter;\n+\n+use self::spec_extend::SpecExtend;\n+\n+mod spec_extend;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -1876,35 +1928,6 @@ impl<T, A: Allocator> Vec<T, A> {\n     }\n }\n \n-// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n-//\n-// The idea is: The length field in SetLenOnDrop is a local variable\n-// that the optimizer will see does not alias with any stores through the Vec's data\n-// pointer. This is a workaround for alias analysis issue #32155\n-struct SetLenOnDrop<'a> {\n-    len: &'a mut usize,\n-    local_len: usize,\n-}\n-\n-impl<'a> SetLenOnDrop<'a> {\n-    #[inline]\n-    fn new(len: &'a mut usize) -> Self {\n-        SetLenOnDrop { local_len: *len, len }\n-    }\n-\n-    #[inline]\n-    fn increment_len(&mut self, increment: usize) {\n-        self.local_len += increment;\n-    }\n-}\n-\n-impl Drop for SetLenOnDrop<'_> {\n-    #[inline]\n-    fn drop(&mut self) {\n-        *self.len = self.local_len;\n-    }\n-}\n-\n impl<T: PartialEq, A: Allocator> Vec<T, A> {\n     /// Removes consecutive repeated elements in the vector according to the\n     /// [`PartialEq`] trait implementation.\n@@ -1964,131 +1987,6 @@ pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<\n     <T as SpecFromElem>::from_elem(elem, n, alloc)\n }\n \n-// Specialization trait used for Vec::from_elem\n-trait SpecFromElem: Sized {\n-    fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n-}\n-\n-impl<T: Clone> SpecFromElem for T {\n-    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n-        let mut v = Vec::with_capacity_in(n, alloc);\n-        v.extend_with(n, ExtendElement(elem));\n-        v\n-    }\n-}\n-\n-impl SpecFromElem for i8 {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n-        if elem == 0 {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        unsafe {\n-            let mut v = Vec::with_capacity_in(n, alloc);\n-            ptr::write_bytes(v.as_mut_ptr(), elem as u8, n);\n-            v.set_len(n);\n-            v\n-        }\n-    }\n-}\n-\n-impl SpecFromElem for u8 {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n-        if elem == 0 {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        unsafe {\n-            let mut v = Vec::with_capacity_in(n, alloc);\n-            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n-            v.set_len(n);\n-            v\n-        }\n-    }\n-}\n-\n-impl<T: Clone + IsZero> SpecFromElem for T {\n-    #[inline]\n-    fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n-        if elem.is_zero() {\n-            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n-        }\n-        let mut v = Vec::with_capacity_in(n, alloc);\n-        v.extend_with(n, ExtendElement(elem));\n-        v\n-    }\n-}\n-\n-#[rustc_specialization_trait]\n-unsafe trait IsZero {\n-    /// Whether this value is zero\n-    fn is_zero(&self) -> bool;\n-}\n-\n-macro_rules! impl_is_zero {\n-    ($t:ty, $is_zero:expr) => {\n-        unsafe impl IsZero for $t {\n-            #[inline]\n-            fn is_zero(&self) -> bool {\n-                $is_zero(*self)\n-            }\n-        }\n-    };\n-}\n-\n-impl_is_zero!(i16, |x| x == 0);\n-impl_is_zero!(i32, |x| x == 0);\n-impl_is_zero!(i64, |x| x == 0);\n-impl_is_zero!(i128, |x| x == 0);\n-impl_is_zero!(isize, |x| x == 0);\n-\n-impl_is_zero!(u16, |x| x == 0);\n-impl_is_zero!(u32, |x| x == 0);\n-impl_is_zero!(u64, |x| x == 0);\n-impl_is_zero!(u128, |x| x == 0);\n-impl_is_zero!(usize, |x| x == 0);\n-\n-impl_is_zero!(bool, |x| x == false);\n-impl_is_zero!(char, |x| x == '\\0');\n-\n-impl_is_zero!(f32, |x: f32| x.to_bits() == 0);\n-impl_is_zero!(f64, |x: f64| x.to_bits() == 0);\n-\n-unsafe impl<T> IsZero for *const T {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        (*self).is_null()\n-    }\n-}\n-\n-unsafe impl<T> IsZero for *mut T {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        (*self).is_null()\n-    }\n-}\n-\n-// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n-// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n-// variant are padding in the `None` variant, so ignoring them and\n-// zero-initializing instead is ok.\n-// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n-// `SpecFromElem`.\n-\n-unsafe impl<T: ?Sized> IsZero for Option<&T> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n-unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n@@ -2263,351 +2161,6 @@ impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n     }\n }\n \n-/// Specialization trait used for Vec::from_iter\n-///\n-/// ## The delegation graph:\n-///\n-/// ```text\n-/// +-------------+\n-/// |FromIterator |\n-/// +-+-----------+\n-///   |\n-///   v\n-/// +-+-------------------------------+  +---------------------+\n-/// |SpecFromIter                  +---->+SpecFromIterNested   |\n-/// |where I:                      |  |  |where I:             |\n-/// |  Iterator (default)----------+  |  |  Iterator (default) |\n-/// |  vec::IntoIter               |  |  |  TrustedLen         |\n-/// |  SourceIterMarker---fallback-+  |  |                     |\n-/// |  slice::Iter                    |  |                     |\n-/// |  Iterator<Item = &Clone>        |  +---------------------+\n-/// +---------------------------------+\n-/// ```\n-trait SpecFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n-}\n-\n-/// Another specialization trait for Vec::from_iter\n-/// necessary to manually prioritize overlapping specializations\n-/// see [`SpecFromIter`] for details.\n-trait SpecFromIterNested<T, I> {\n-    fn from_iter(iter: I) -> Self;\n-}\n-\n-impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn from_iter(mut iterator: I) -> Self {\n-        // Unroll the first iteration, as the vector is going to be\n-        // expanded on this iteration in every case when the iterable is not\n-        // empty, but the loop in extend_desugared() is not going to see the\n-        // vector being full in the few subsequent loop iterations.\n-        // So we get better branch prediction.\n-        let mut vector = match iterator.next() {\n-            None => return Vec::new(),\n-            Some(element) => {\n-                let (lower, _) = iterator.size_hint();\n-                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n-                unsafe {\n-                    ptr::write(vector.as_mut_ptr(), element);\n-                    vector.set_len(1);\n-                }\n-                vector\n-            }\n-        };\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n-        vector\n-    }\n-}\n-\n-impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n-where\n-    I: TrustedLen<Item = T>,\n-{\n-    fn from_iter(iterator: I) -> Self {\n-        let mut vector = match iterator.size_hint() {\n-            (_, Some(upper)) => Vec::with_capacity(upper),\n-            _ => Vec::new(),\n-        };\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        vector.spec_extend(iterator);\n-        vector\n-    }\n-}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIterNested::from_iter(iterator)\n-    }\n-}\n-\n-// A helper struct for in-place iteration that drops the destination slice of iteration,\n-// i.e. the head. The source slice (the tail) is dropped by IntoIter.\n-struct InPlaceDrop<T> {\n-    inner: *mut T,\n-    dst: *mut T,\n-}\n-\n-impl<T> InPlaceDrop<T> {\n-    fn len(&self) -> usize {\n-        unsafe { self.dst.offset_from(self.inner) as usize }\n-    }\n-}\n-\n-impl<T> Drop for InPlaceDrop<T> {\n-    #[inline]\n-    fn drop(&mut self) {\n-        unsafe {\n-            ptr::drop_in_place(slice::from_raw_parts_mut(self.inner, self.len()));\n-        }\n-    }\n-}\n-\n-impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n-    fn from_iter(iterator: IntoIter<T>) -> Self {\n-        // A common case is passing a vector into a function which immediately\n-        // re-collects into a vector. We can short circuit this if the IntoIter\n-        // has not been advanced at all.\n-        // When it has been advanced We can also reuse the memory and move the data to the front.\n-        // But we only do so when the resulting Vec wouldn't have more unused capacity\n-        // than creating it through the generic FromIterator implementation would. That limitation\n-        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n-        // But it is a conservative choice.\n-        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n-        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n-            unsafe {\n-                let it = ManuallyDrop::new(iterator);\n-                if has_advanced {\n-                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n-                }\n-                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n-            }\n-        }\n-\n-        let mut vec = Vec::new();\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        vec.spec_extend(iterator);\n-        vec\n-    }\n-}\n-\n-fn write_in_place_with_drop<T>(\n-    src_end: *const T,\n-) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n-    move |mut sink, item| {\n-        unsafe {\n-            // the InPlaceIterable contract cannot be verified precisely here since\n-            // try_fold has an exclusive reference to the source pointer\n-            // all we can do is check if it's still in range\n-            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n-            ptr::write(sink.dst, item);\n-            sink.dst = sink.dst.add(1);\n-        }\n-        Ok(sink)\n-    }\n-}\n-\n-/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n-/// source allocation, i.e. executing the pipeline in place.\n-///\n-/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n-/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n-/// additional bounds on the impl.\n-#[rustc_unsafe_specialization_marker]\n-trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n-\n-// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n-// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n-// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n-// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n-// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n-// several other specializations already depend on.\n-impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T> + SourceIterMarker,\n-{\n-    default fn from_iter(mut iterator: I) -> Self {\n-        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n-        // instead:\n-        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n-        // b) size match as required by Alloc contract\n-        // c) alignments match as required by Alloc contract\n-        if mem::size_of::<T>() == 0\n-            || mem::size_of::<T>()\n-                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-            || mem::align_of::<T>()\n-                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-        {\n-            // fallback to more generic implementations\n-            return SpecFromIterNested::from_iter(iterator);\n-        }\n-\n-        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n-            let inner = iterator.as_inner().as_into_iter();\n-            (\n-                inner.buf.as_ptr(),\n-                inner.ptr,\n-                inner.buf.as_ptr() as *mut T,\n-                inner.end as *const T,\n-                inner.cap,\n-            )\n-        };\n-\n-        // use try-fold since\n-        // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods, it only takes a &mut self\n-        // - it lets us thread the write pointer through its innards and get it back in the end\n-        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        let sink = iterator\n-            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n-            .unwrap();\n-        // iteration succeeded, don't drop head\n-        let dst = ManuallyDrop::new(sink).dst;\n-\n-        let src = unsafe { iterator.as_inner().as_into_iter() };\n-        // check if SourceIter contract was upheld\n-        // caveat: if they weren't we may not even make it to this point\n-        debug_assert_eq!(src_buf, src.buf.as_ptr());\n-        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n-        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n-        // then the source pointer will stay in its initial position and we can't use it as reference\n-        if src.ptr != src_ptr {\n-            debug_assert!(\n-                dst as *const _ <= src.ptr,\n-                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n-            );\n-        }\n-\n-        // drop any remaining values at the tail of the source\n-        src.drop_remaining();\n-        // but prevent drop of the allocation itself once IntoIter goes out of scope\n-        src.forget_allocation();\n-\n-        let vec = unsafe {\n-            let len = dst.offset_from(dst_buf) as usize;\n-            Vec::from_raw_parts(dst_buf, len, cap)\n-        };\n-\n-        vec\n-    }\n-}\n-\n-impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIter::from_iter(iterator.cloned())\n-    }\n-}\n-\n-// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n-// must take more steps to reason about the final capacity + length\n-// and thus do more work. `to_vec()` directly allocates the correct amount\n-// and fills it exactly.\n-impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n-    #[cfg(not(test))]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        iterator.as_slice().to_vec()\n-    }\n-\n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n-    // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n-    // NB see the slice::hack module in slice.rs for more information\n-    #[cfg(test)]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        crate::slice::to_vec(iterator.as_slice(), Global)\n-    }\n-}\n-\n-// Specialization trait used for Vec::extend\n-trait SpecExtend<T, I> {\n-    fn spec_extend(&mut self, iter: I);\n-}\n-\n-impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn spec_extend(&mut self, iter: I) {\n-        self.extend_desugared(iter)\n-    }\n-}\n-\n-impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n-where\n-    I: TrustedLen<Item = T>,\n-{\n-    default fn spec_extend(&mut self, iterator: I) {\n-        // This is the case for a TrustedLen iterator.\n-        let (low, high) = iterator.size_hint();\n-        if let Some(high_value) = high {\n-            debug_assert_eq!(\n-                low,\n-                high_value,\n-                \"TrustedLen iterator's size hint is not exact: {:?}\",\n-                (low, high)\n-            );\n-        }\n-        if let Some(additional) = high {\n-            self.reserve(additional);\n-            unsafe {\n-                let mut ptr = self.as_mut_ptr().add(self.len());\n-                let mut local_len = SetLenOnDrop::new(&mut self.len);\n-                iterator.for_each(move |element| {\n-                    ptr::write(ptr, element);\n-                    ptr = ptr.offset(1);\n-                    // NB can't overflow since we would have had to alloc the address space\n-                    local_len.increment_len(1);\n-                });\n-            }\n-        } else {\n-            self.extend_desugared(iterator)\n-        }\n-    }\n-}\n-\n-impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n-    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n-        unsafe {\n-            self.append_elements(iterator.as_slice() as _);\n-        }\n-        iterator.ptr = iterator.end;\n-    }\n-}\n-\n-impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn spec_extend(&mut self, iterator: I) {\n-        self.spec_extend(iterator.cloned())\n-    }\n-}\n-\n-impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n-where\n-    T: Copy,\n-{\n-    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n-        let slice = iterator.as_slice();\n-        unsafe { self.append_elements(slice) };\n-    }\n-}\n-\n impl<T, A: Allocator> Vec<T, A> {\n     // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n     // they have no further optimizations to apply\n@@ -2759,45 +2312,6 @@ impl<'a, T: Copy + 'a, A: Allocator + 'a> Extend<&'a T> for Vec<T, A> {\n     }\n }\n \n-macro_rules! __impl_slice_eq1 {\n-    ([$($vars:tt)*] $lhs:ty, $rhs:ty $(where $ty:ty: $bound:ident)?, #[$stability:meta]) => {\n-        #[$stability]\n-        impl<T, U, $($vars)*> PartialEq<$rhs> for $lhs\n-        where\n-            T: PartialEq<U>,\n-            $($ty: $bound)?\n-        {\n-            #[inline]\n-            fn eq(&self, other: &$rhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$rhs) -> bool { self[..] != other[..] }\n-        }\n-    }\n-}\n-\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n-__impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n-__impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n-\n-// NOTE: some less important impls are omitted to reduce code bloat\n-// FIXME(Centril): Reconsider this?\n-//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], }\n-//__impl_slice_eq1! { [const N: usize] [A; N], Vec<B>, }\n-//__impl_slice_eq1! { [const N: usize] &[A; N], Vec<B>, }\n-//__impl_slice_eq1! { [const N: usize] &mut [A; N], Vec<B>, }\n-//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], }\n-//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], }\n-//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], }\n-\n /// Implements comparison of vectors, [lexicographically](core::cmp::Ord#lexicographical-comparison).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: PartialOrd, A: Allocator> PartialOrd for Vec<T, A> {\n@@ -2997,729 +2511,3 @@ impl<T, A: Allocator, const N: usize> TryFrom<Vec<T, A>> for [T; N] {\n         Ok(array)\n     }\n }\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Clone-on-write\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Cow<'a, [T]> {\n-    fn from(s: &'a [T]) -> Cow<'a, [T]> {\n-        Cow::Borrowed(s)\n-    }\n-}\n-\n-#[stable(feature = \"cow_from_vec\", since = \"1.8.0\")]\n-impl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n-    fn from(v: Vec<T>) -> Cow<'a, [T]> {\n-        Cow::Owned(v)\n-    }\n-}\n-\n-#[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\n-impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n-    fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n-        Cow::Borrowed(v.as_slice())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> FromIterator<T> for Cow<'a, [T]>\n-where\n-    T: Clone,\n-{\n-    fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n-        Cow::Owned(FromIterator::from_iter(it))\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Iterators\n-////////////////////////////////////////////////////////////////////////////////\n-\n-/// An iterator that moves out of a vector.\n-///\n-/// This `struct` is created by the `into_iter` method on [`Vec`] (provided\n-/// by the [`IntoIterator`] trait).\n-///\n-/// # Example\n-///\n-/// ```\n-/// let v = vec![0, 1, 2];\n-/// let iter: std::vec::IntoIter<_> = v.into_iter();\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<\n-    T,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> {\n-    buf: NonNull<T>,\n-    phantom: PhantomData<T>,\n-    cap: usize,\n-    alloc: A,\n-    ptr: *const T,\n-    end: *const T,\n-}\n-\n-#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"IntoIter\").field(&self.as_slice()).finish()\n-    }\n-}\n-\n-impl<T, A: Allocator> IntoIter<T, A> {\n-    /// Returns the remaining items of this iterator as a slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = vec!['a', 'b', 'c'];\n-    /// let mut into_iter = vec.into_iter();\n-    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n-    /// let _ = into_iter.next().unwrap();\n-    /// assert_eq!(into_iter.as_slice(), &['b', 'c']);\n-    /// ```\n-    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_slice(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.ptr, self.len()) }\n-    }\n-\n-    /// Returns the remaining items of this iterator as a mutable slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let vec = vec!['a', 'b', 'c'];\n-    /// let mut into_iter = vec.into_iter();\n-    /// assert_eq!(into_iter.as_slice(), &['a', 'b', 'c']);\n-    /// into_iter.as_mut_slice()[2] = 'z';\n-    /// assert_eq!(into_iter.next().unwrap(), 'a');\n-    /// assert_eq!(into_iter.next().unwrap(), 'b');\n-    /// assert_eq!(into_iter.next().unwrap(), 'z');\n-    /// ```\n-    #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe { &mut *self.as_raw_mut_slice() }\n-    }\n-\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        &self.alloc\n-    }\n-\n-    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n-        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n-    }\n-\n-    fn drop_remaining(&mut self) {\n-        unsafe {\n-            ptr::drop_in_place(self.as_mut_slice());\n-        }\n-        self.ptr = self.end;\n-    }\n-\n-    /// Relinquishes the backing allocation, equivalent to\n-    /// `ptr::write(&mut self, Vec::new().into_iter())`\n-    fn forget_allocation(&mut self) {\n-        self.cap = 0;\n-        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n-        self.ptr = self.buf.as_ptr();\n-        self.end = self.buf.as_ptr();\n-    }\n-}\n-\n-#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n-impl<T, A: Allocator> AsRef<[T]> for IntoIter<T, A> {\n-    fn as_ref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send, A: Allocator + Send> Send for IntoIter<T, A> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync, A: Allocator> Sync for IntoIter<T, A> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        if self.ptr as *const _ == self.end {\n-            None\n-        } else if mem::size_of::<T>() == 0 {\n-            // purposefully don't use 'ptr.offset' because for\n-            // vectors with 0-size elements this would return the\n-            // same pointer.\n-            self.ptr = unsafe { arith_offset(self.ptr as *const i8, 1) as *mut T };\n-\n-            // Make up a value of this ZST.\n-            Some(unsafe { mem::zeroed() })\n-        } else {\n-            let old = self.ptr;\n-            self.ptr = unsafe { self.ptr.offset(1) };\n-\n-            Some(unsafe { ptr::read(old) })\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let exact = if mem::size_of::<T>() == 0 {\n-            (self.end as usize).wrapping_sub(self.ptr as usize)\n-        } else {\n-            unsafe { self.end.offset_from(self.ptr) as usize }\n-        };\n-        (exact, Some(exact))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.len()\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, i: usize) -> Self::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must guarantee that `i` is in bounds of the\n-        // `Vec<T>`, so `i` cannot overflow an `isize`, and the `self.ptr.add(i)`\n-        // is guaranteed to pointer to an element of the `Vec<T>` and\n-        // thus guaranteed to be valid to dereference.\n-        //\n-        // Also note the implementation of `Self: TrustedRandomAccess` requires\n-        // that `T: Copy` so reading elements from the buffer doesn't invalidate\n-        // them for `Drop`.\n-        unsafe {\n-            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        if self.end == self.ptr {\n-            None\n-        } else if mem::size_of::<T>() == 0 {\n-            // See above for why 'ptr.offset' isn't used\n-            self.end = unsafe { arith_offset(self.end as *const i8, -1) as *mut T };\n-\n-            // Make up a value of this ZST.\n-            Some(unsafe { mem::zeroed() })\n-        } else {\n-            self.end = unsafe { self.end.offset(-1) };\n-\n-            Some(unsafe { ptr::read(self.end) })\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {\n-    fn is_empty(&self) -> bool {\n-        self.ptr == self.end\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: Allocator> TrustedLen for IntoIter<T, A> {}\n-\n-#[doc(hidden)]\n-#[unstable(issue = \"none\", feature = \"std_internals\")]\n-// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n-// and thus we can't implement drop-handling\n-unsafe impl<T, A: Allocator> TrustedRandomAccess for IntoIter<T, A>\n-where\n-    T: Copy,\n-{\n-    fn may_have_side_effect() -> bool {\n-        false\n-    }\n-}\n-\n-#[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n-impl<T: Clone, A: Allocator + Clone> Clone for IntoIter<T, A> {\n-    #[cfg(not(test))]\n-    fn clone(&self) -> Self {\n-        self.as_slice().to_vec_in(self.alloc.clone()).into_iter()\n-    }\n-    #[cfg(test)]\n-    fn clone(&self) -> Self {\n-        crate::slice::to_vec(self.as_slice(), self.alloc.clone()).into_iter()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n-    fn drop(&mut self) {\n-        struct DropGuard<'a, T, A: Allocator>(&'a mut IntoIter<T, A>);\n-\n-        impl<T, A: Allocator> Drop for DropGuard<'_, T, A> {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    // `IntoIter::alloc` is not used anymore after this\n-                    let alloc = ptr::read(&self.0.alloc);\n-                    // RawVec handles deallocation\n-                    let _ = RawVec::from_raw_parts_in(self.0.buf.as_ptr(), self.0.cap, alloc);\n-                }\n-            }\n-        }\n-\n-        let guard = DropGuard(self);\n-        // destroy the remaining elements\n-        unsafe {\n-            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n-        }\n-        // now `guard` will be dropped and do the rest\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n-    type Source = Self;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n-        self\n-    }\n-}\n-\n-// internal helper trait for in-place iteration specialization.\n-#[rustc_specialization_trait]\n-pub(crate) trait AsIntoIter {\n-    type Item;\n-    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n-}\n-\n-impl<T> AsIntoIter for IntoIter<T> {\n-    type Item = T;\n-\n-    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {\n-        self\n-    }\n-}\n-\n-/// A draining iterator for `Vec<T>`.\n-///\n-/// This `struct` is created by [`Vec::drain`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::Drain<_> = v.drain(..);\n-/// ```\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<\n-    'a,\n-    T: 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n-> {\n-    /// Index of tail to preserve\n-    tail_start: usize,\n-    /// Length of tail\n-    tail_len: usize,\n-    /// Current remaining range to remove\n-    iter: slice::Iter<'a, T>,\n-    vec: NonNull<Vec<T, A>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug, A: Allocator> fmt::Debug for Drain<'_, T, A> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Drain\").field(&self.iter.as_slice()).finish()\n-    }\n-}\n-\n-impl<'a, T, A: Allocator> Drain<'a, T, A> {\n-    /// Returns the remaining items of this iterator as a slice.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec!['a', 'b', 'c'];\n-    /// let mut drain = vec.drain(..);\n-    /// assert_eq!(drain.as_slice(), &['a', 'b', 'c']);\n-    /// let _ = drain.next().unwrap();\n-    /// assert_eq!(drain.as_slice(), &['b', 'c']);\n-    /// ```\n-    #[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-    pub fn as_slice(&self) -> &[T] {\n-        self.iter.as_slice()\n-    }\n-\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        unsafe { self.vec.as_ref().allocator() }\n-    }\n-}\n-\n-#[stable(feature = \"vec_drain_as_slice\", since = \"1.46.0\")]\n-impl<'a, T, A: Allocator> AsRef<[T]> for Drain<'a, T, A> {\n-    fn as_ref(&self) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync, A: Sync + Allocator> Sync for Drain<'_, T, A> {}\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send, A: Send + Allocator> Send for Drain<'_, T, A> {}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> Iterator for Drain<'_, T, A> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const _) })\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> DoubleEndedIterator for Drain<'_, T, A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> Drop for Drain<'_, T, A> {\n-    fn drop(&mut self) {\n-        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n-        /// un-`Drain`ed elements to restore the original `Vec`.\n-        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n-\n-        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n-            fn drop(&mut self) {\n-                // Continue the same loop we have below. If the loop already finished, this does\n-                // nothing.\n-                self.0.for_each(drop);\n-\n-                if self.0.tail_len > 0 {\n-                    unsafe {\n-                        let source_vec = self.0.vec.as_mut();\n-                        // memmove back untouched tail, update to new length\n-                        let start = source_vec.len();\n-                        let tail = self.0.tail_start;\n-                        if tail != start {\n-                            let src = source_vec.as_ptr().add(tail);\n-                            let dst = source_vec.as_mut_ptr().add(start);\n-                            ptr::copy(src, dst, self.0.tail_len);\n-                        }\n-                        source_vec.set_len(start + self.0.tail_len);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // exhaust self first\n-        while let Some(item) = self.next() {\n-            let guard = DropGuard(self);\n-            drop(item);\n-            mem::forget(guard);\n-        }\n-\n-        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n-        DropGuard(self);\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T, A: Allocator> ExactSizeIterator for Drain<'_, T, A> {\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, A: Allocator> TrustedLen for Drain<'_, T, A> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T, A: Allocator> FusedIterator for Drain<'_, T, A> {}\n-\n-/// A splicing iterator for `Vec`.\n-///\n-/// This struct is created by [`Vec::splice()`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// let mut v = vec![0, 1, 2];\n-/// let new = [7, 8];\n-/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-pub struct Splice<\n-    'a,\n-    I: Iterator + 'a,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n-> {\n-    drain: Drain<'a, I::Item, A>,\n-    replace_with: I,\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n-    type Item = I::Item;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.drain.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.drain.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.drain.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n-\n-#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n-    fn drop(&mut self) {\n-        self.drain.by_ref().for_each(drop);\n-\n-        unsafe {\n-            if self.drain.tail_len == 0 {\n-                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n-                return;\n-            }\n-\n-            // First fill the range left by drain().\n-            if !self.drain.fill(&mut self.replace_with) {\n-                return;\n-            }\n-\n-            // There may be more elements. Use the lower bound as an estimate.\n-            // FIXME: Is the upper bound a better guess? Or something else?\n-            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n-            if lower_bound > 0 {\n-                self.drain.move_tail(lower_bound);\n-                if !self.drain.fill(&mut self.replace_with) {\n-                    return;\n-                }\n-            }\n-\n-            // Collect any remaining elements.\n-            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n-            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n-            // Now we have an exact count.\n-            if collected.len() > 0 {\n-                self.drain.move_tail(collected.len());\n-                let filled = self.drain.fill(&mut collected);\n-                debug_assert!(filled);\n-                debug_assert_eq!(collected.len(), 0);\n-            }\n-        }\n-        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n-    }\n-}\n-\n-/// Private helper methods for `Splice::drop`\n-impl<T, A: Allocator> Drain<'_, T, A> {\n-    /// The range from `self.vec.len` to `self.tail_start` contains elements\n-    /// that have been moved out.\n-    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n-    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = unsafe { self.vec.as_mut() };\n-        let range_start = vec.len;\n-        let range_end = self.tail_start;\n-        let range_slice = unsafe {\n-            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n-        };\n-\n-        for place in range_slice {\n-            if let Some(new_item) = replace_with.next() {\n-                unsafe { ptr::write(place, new_item) };\n-                vec.len += 1;\n-            } else {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    /// Makes room for inserting more elements before the tail.\n-    unsafe fn move_tail(&mut self, additional: usize) {\n-        let vec = unsafe { self.vec.as_mut() };\n-        let len = self.tail_start + self.tail_len;\n-        vec.buf.reserve(len, additional);\n-\n-        let new_tail_start = self.tail_start + additional;\n-        unsafe {\n-            let src = vec.as_ptr().add(self.tail_start);\n-            let dst = vec.as_mut_ptr().add(new_tail_start);\n-            ptr::copy(src, dst, self.tail_len);\n-        }\n-        self.tail_start = new_tail_start;\n-    }\n-}\n-\n-/// An iterator which uses a closure to determine if an element should be removed.\n-///\n-/// This struct is created by [`Vec::drain_filter`].\n-/// See its documentation for more.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #![feature(drain_filter)]\n-///\n-/// let mut v = vec![0, 1, 2];\n-/// let iter: std::vec::DrainFilter<_, _> = v.drain_filter(|x| *x % 2 == 0);\n-/// ```\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-#[derive(Debug)]\n-pub struct DrainFilter<\n-    'a,\n-    T,\n-    F,\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n-> where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    vec: &'a mut Vec<T, A>,\n-    /// The index of the item that will be inspected by the next call to `next`.\n-    idx: usize,\n-    /// The number of items that have been drained (removed) thus far.\n-    del: usize,\n-    /// The original length of `vec` prior to draining.\n-    old_len: usize,\n-    /// The filter test predicate.\n-    pred: F,\n-    /// A flag that indicates a panic has occurred in the filter test predicate.\n-    /// This is used as a hint in the drop implementation to prevent consumption\n-    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n-    /// backshifted in the `vec`, but no further items will be dropped or\n-    /// tested by the filter predicate.\n-    panic_flag: bool,\n-}\n-\n-impl<T, F, A: Allocator> DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    /// Returns a reference to the underlying allocator.\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    #[inline]\n-    pub fn allocator(&self) -> &A {\n-        self.vec.allocator()\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        unsafe {\n-            while self.idx < self.old_len {\n-                let i = self.idx;\n-                let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                self.panic_flag = true;\n-                let drained = (self.pred)(&mut v[i]);\n-                self.panic_flag = false;\n-                // Update the index *after* the predicate is called. If the index\n-                // is updated prior and the predicate panics, the element at this\n-                // index would be leaked.\n-                self.idx += 1;\n-                if drained {\n-                    self.del += 1;\n-                    return Some(ptr::read(&v[i]));\n-                } else if self.del > 0 {\n-                    let del = self.del;\n-                    let src: *const T = &v[i];\n-                    let dst: *mut T = &mut v[i - del];\n-                    ptr::copy_nonoverlapping(src, dst, 1);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.old_len - self.idx))\n-    }\n-}\n-\n-#[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n-where\n-    F: FnMut(&mut T) -> bool,\n-{\n-    fn drop(&mut self) {\n-        struct BackshiftOnDrop<'a, 'b, T, F, A: Allocator>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            drain: &'b mut DrainFilter<'a, T, F, A>,\n-        }\n-\n-        impl<'a, 'b, T, F, A: Allocator> Drop for BackshiftOnDrop<'a, 'b, T, F, A>\n-        where\n-            F: FnMut(&mut T) -> bool,\n-        {\n-            fn drop(&mut self) {\n-                unsafe {\n-                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n-                        // This is a pretty messed up state, and there isn't really an\n-                        // obviously right thing to do. We don't want to keep trying\n-                        // to execute `pred`, so we just backshift all the unprocessed\n-                        // elements and tell the vec that they still exist. The backshift\n-                        // is required to prevent a double-drop of the last successfully\n-                        // drained item prior to a panic in the predicate.\n-                        let ptr = self.drain.vec.as_mut_ptr();\n-                        let src = ptr.add(self.drain.idx);\n-                        let dst = src.sub(self.drain.del);\n-                        let tail_len = self.drain.old_len - self.drain.idx;\n-                        src.copy_to(dst, tail_len);\n-                    }\n-                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n-                }\n-            }\n-        }\n-\n-        let backshift = BackshiftOnDrop { drain: self };\n-\n-        // Attempt to consume any remaining elements if the filter predicate\n-        // has not yet panicked. We'll backshift any remaining elements\n-        // whether we've already panicked or if the consumption here panics.\n-        if !backshift.drain.panic_flag {\n-            backshift.drain.for_each(drop);\n-        }\n-    }\n-}", "previous_filename": "library/alloc/src/vec.rs"}, {"sha": "ff90b6caf4601d92818dd2f5065602ec2bfc73a6", "filename": "library/alloc/src/vec/partial_eq.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fpartial_eq.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,43 @@\n+use crate::alloc::Allocator;\n+use crate::borrow::Cow;\n+\n+use super::Vec;\n+\n+macro_rules! __impl_slice_eq1 {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty $(where $ty:ty: $bound:ident)?, #[$stability:meta]) => {\n+        #[$stability]\n+        impl<T, U, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            T: PartialEq<U>,\n+            $($ty: $bound)?\n+        {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { self[..] == other[..] }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { self[..] != other[..] }\n+        }\n+    }\n+}\n+\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, Vec<U, A>, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &[U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, &mut [U], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator] &[T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: Allocator] &mut [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_ref_slice\", since = \"1.46.0\")] }\n+__impl_slice_eq1! { [A: Allocator] Vec<T, A>, [U], #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: Allocator] [T], Vec<U, A>, #[stable(feature = \"partialeq_vec_for_slice\", since = \"1.48.0\")]  }\n+__impl_slice_eq1! { [A: Allocator] Cow<'_, [T]>, Vec<U, A> where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [] Cow<'_, [T]>, &[U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [] Cow<'_, [T]>, &mut [U] where T: Clone, #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, [U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+__impl_slice_eq1! { [A: Allocator, const N: usize] Vec<T, A>, &[U; N], #[stable(feature = \"rust1\", since = \"1.0.0\")] }\n+\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// FIXME(Centril): Reconsider this?\n+//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], }\n+//__impl_slice_eq1! { [const N: usize] [A; N], Vec<B>, }\n+//__impl_slice_eq1! { [const N: usize] &[A; N], Vec<B>, }\n+//__impl_slice_eq1! { [const N: usize] &mut [A; N], Vec<B>, }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], }"}, {"sha": "8b66bc812129694e4976f140a1e18afed0c1aee1", "filename": "library/alloc/src/vec/set_len_on_drop.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fset_len_on_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fset_len_on_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fset_len_on_drop.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,28 @@\n+// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+//\n+// The idea is: The length field in SetLenOnDrop is a local variable\n+// that the optimizer will see does not alias with any stores through the Vec's data\n+// pointer. This is a workaround for alias analysis issue #32155\n+pub(super) struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    pub(super) fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len }\n+    }\n+\n+    #[inline]\n+    pub(super) fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl Drop for SetLenOnDrop<'_> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}"}, {"sha": "8c0e95559fa15e83fc4a07fea4951a533a233ed5", "filename": "library/alloc/src/vec/source_iter_marker.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,108 @@\n+use core::iter::{InPlaceIterable, SourceIter};\n+use core::mem::{self, ManuallyDrop};\n+use core::ptr::{self};\n+\n+use super::{AsIntoIter, InPlaceDrop, SpecFromIter, SpecFromIterNested, Vec};\n+\n+/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n+/// source allocation, i.e. executing the pipeline in place.\n+///\n+/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n+/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n+/// additional bounds on the impl.\n+#[rustc_unsafe_specialization_marker]\n+pub(super) trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n+\n+// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n+// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n+// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n+// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n+// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n+// several other specializations already depend on.\n+impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T> + SourceIterMarker,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n+        // instead:\n+        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n+        // b) size match as required by Alloc contract\n+        // c) alignments match as required by Alloc contract\n+        if mem::size_of::<T>() == 0\n+            || mem::size_of::<T>()\n+                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+            || mem::align_of::<T>()\n+                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+        {\n+            // fallback to more generic implementations\n+            return SpecFromIterNested::from_iter(iterator);\n+        }\n+\n+        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n+            let inner = iterator.as_inner().as_into_iter();\n+            (\n+                inner.buf.as_ptr(),\n+                inner.ptr,\n+                inner.buf.as_ptr() as *mut T,\n+                inner.end as *const T,\n+                inner.cap,\n+            )\n+        };\n+\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods, it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink = iterator\n+            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n+            .unwrap();\n+        // iteration succeeded, don't drop head\n+        let dst = ManuallyDrop::new(sink).dst;\n+\n+        let src = unsafe { iterator.as_inner().as_into_iter() };\n+        // check if SourceIter contract was upheld\n+        // caveat: if they weren't we may not even make it to this point\n+        debug_assert_eq!(src_buf, src.buf.as_ptr());\n+        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n+        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n+        // then the source pointer will stay in its initial position and we can't use it as reference\n+        if src.ptr != src_ptr {\n+            debug_assert!(\n+                dst as *const _ <= src.ptr,\n+                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n+            );\n+        }\n+\n+        // drop any remaining values at the tail of the source\n+        src.drop_remaining();\n+        // but prevent drop of the allocation itself once IntoIter goes out of scope\n+        src.forget_allocation();\n+\n+        let vec = unsafe {\n+            let len = dst.offset_from(dst_buf) as usize;\n+            Vec::from_raw_parts(dst_buf, len, cap)\n+        };\n+\n+        vec\n+    }\n+}\n+\n+fn write_in_place_with_drop<T>(\n+    src_end: *const T,\n+) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n+    move |mut sink, item| {\n+        unsafe {\n+            // the InPlaceIterable contract cannot be verified precisely here since\n+            // try_fold has an exclusive reference to the source pointer\n+            // all we can do is check if it's still in range\n+            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(sink.dst, item);\n+            sink.dst = sink.dst.add(1);\n+        }\n+        Ok(sink)\n+    }\n+}"}, {"sha": "b6186a7ebaf730ba1dba44df5f04f61587bbda0d", "filename": "library/alloc/src/vec/spec_extend.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_extend.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,82 @@\n+use crate::alloc::Allocator;\n+use core::iter::TrustedLen;\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{IntoIter, SetLenOnDrop, Vec};\n+\n+// Specialization trait used for Vec::extend\n+pub(super) trait SpecExtend<T, I> {\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter)\n+    }\n+}\n+\n+impl<T, I, A: Allocator> SpecExtend<T, I> for Vec<T, A>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iterator: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iterator.size_hint();\n+        if let Some(high_value) = high {\n+            debug_assert_eq!(\n+                low,\n+                high_value,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+        }\n+        if let Some(additional) = high {\n+            self.reserve(additional);\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len());\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n+                iterator.for_each(move |element| {\n+                    ptr::write(ptr, element);\n+                    ptr = ptr.offset(1);\n+                    // NB can't overflow since we would have had to alloc the address space\n+                    local_len.increment_len(1);\n+                });\n+            }\n+        } else {\n+            self.extend_desugared(iterator)\n+        }\n+    }\n+}\n+\n+impl<T, A: Allocator> SpecExtend<T, IntoIter<T>> for Vec<T, A> {\n+    fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n+        unsafe {\n+            self.append_elements(iterator.as_slice() as _);\n+        }\n+        iterator.ptr = iterator.end;\n+    }\n+}\n+\n+impl<'a, T: 'a, I, A: Allocator + 'a> SpecExtend<&'a T, I> for Vec<T, A>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    default fn spec_extend(&mut self, iterator: I) {\n+        self.spec_extend(iterator.cloned())\n+    }\n+}\n+\n+impl<'a, T: 'a, A: Allocator + 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T, A>\n+where\n+    T: Copy,\n+{\n+    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n+        let slice = iterator.as_slice();\n+        unsafe { self.append_elements(slice) };\n+    }\n+}"}, {"sha": "de610174783c4b51b2e61493d26ca696faaaa1b3", "filename": "library/alloc/src/vec/spec_from_elem.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_elem.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,60 @@\n+use crate::alloc::Allocator;\n+use crate::raw_vec::RawVec;\n+use core::ptr::{self};\n+\n+use super::{ExtendElement, IsZero, Vec};\n+\n+// Specialization trait used for Vec::from_elem\n+pub(super) trait SpecFromElem: Sized {\n+    fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A>;\n+}\n+\n+impl<T: Clone> SpecFromElem for T {\n+    default fn from_elem<A: Allocator>(elem: Self, n: usize, alloc: A) -> Vec<Self, A> {\n+        let mut v = Vec::with_capacity_in(n, alloc);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}\n+\n+impl SpecFromElem for i8 {\n+    #[inline]\n+    fn from_elem<A: Allocator>(elem: i8, n: usize, alloc: A) -> Vec<i8, A> {\n+        if elem == 0 {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        unsafe {\n+            let mut v = Vec::with_capacity_in(n, alloc);\n+            ptr::write_bytes(v.as_mut_ptr(), elem as u8, n);\n+            v.set_len(n);\n+            v\n+        }\n+    }\n+}\n+\n+impl SpecFromElem for u8 {\n+    #[inline]\n+    fn from_elem<A: Allocator>(elem: u8, n: usize, alloc: A) -> Vec<u8, A> {\n+        if elem == 0 {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        unsafe {\n+            let mut v = Vec::with_capacity_in(n, alloc);\n+            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n+            v.set_len(n);\n+            v\n+        }\n+    }\n+}\n+\n+impl<T: Clone + IsZero> SpecFromElem for T {\n+    #[inline]\n+    fn from_elem<A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<T, A> {\n+        if elem.is_zero() {\n+            return Vec { buf: RawVec::with_capacity_zeroed_in(n, alloc), len: n };\n+        }\n+        let mut v = Vec::with_capacity_in(n, alloc);\n+        v.extend_with(n, ExtendElement(elem));\n+        v\n+    }\n+}"}, {"sha": "bbfcc68daeff43e2585dc8d01997857c1bd73a3e", "filename": "library/alloc/src/vec/spec_from_iter.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,97 @@\n+use core::mem::ManuallyDrop;\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{IntoIter, SpecExtend, SpecFromIterNested, Vec};\n+\n+/// Specialization trait used for Vec::from_iter\n+///\n+/// ## The delegation graph:\n+///\n+/// ```text\n+/// +-------------+\n+/// |FromIterator |\n+/// +-+-----------+\n+///   |\n+///   v\n+/// +-+-------------------------------+  +---------------------+\n+/// |SpecFromIter                  +---->+SpecFromIterNested   |\n+/// |where I:                      |  |  |where I:             |\n+/// |  Iterator (default)----------+  |  |  Iterator (default) |\n+/// |  vec::IntoIter               |  |  |  TrustedLen         |\n+/// |  SourceIterMarker---fallback-+  |  |                     |\n+/// |  slice::Iter                    |  |                     |\n+/// |  Iterator<Item = &Clone>        |  +---------------------+\n+/// +---------------------------------+\n+/// ```\n+pub(super) trait SpecFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIterNested::from_iter(iterator)\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n+    fn from_iter(iterator: IntoIter<T>) -> Self {\n+        // A common case is passing a vector into a function which immediately\n+        // re-collects into a vector. We can short circuit this if the IntoIter\n+        // has not been advanced at all.\n+        // When it has been advanced We can also reuse the memory and move the data to the front.\n+        // But we only do so when the resulting Vec wouldn't have more unused capacity\n+        // than creating it through the generic FromIterator implementation would. That limitation\n+        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n+        // But it is a conservative choice.\n+        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n+        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n+            unsafe {\n+                let it = ManuallyDrop::new(iterator);\n+                if has_advanced {\n+                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n+                }\n+                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n+            }\n+        }\n+\n+        let mut vec = Vec::new();\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vec.spec_extend(iterator);\n+        vec\n+    }\n+}\n+\n+impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIter::from_iter(iterator.cloned())\n+    }\n+}\n+\n+// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n+// must take more steps to reason about the final capacity + length\n+// and thus do more work. `to_vec()` directly allocates the correct amount\n+// and fills it exactly.\n+impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n+    #[cfg(not(test))]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        iterator.as_slice().to_vec()\n+    }\n+\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n+    // required for this method definition, is not available. Instead use the\n+    // `slice::to_vec`  function which is only available with cfg(test)\n+    // NB see the slice::hack module in slice.rs for more information\n+    #[cfg(test)]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        crate::slice::to_vec(iterator.as_slice(), crate::alloc::Global)\n+    }\n+}"}, {"sha": "6abd4ff2a3f0a8c2812ae49b364a2c895a89db76", "filename": "library/alloc/src/vec/spec_from_iter_nested.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter_nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter_nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter_nested.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,56 @@\n+use core::iter::TrustedLen;\n+use core::ptr::{self};\n+\n+use super::{SpecExtend, Vec};\n+\n+/// Another specialization trait for Vec::from_iter\n+/// necessary to manually prioritize overlapping specializations\n+/// see [`SpecFromIter`] for details.\n+pub(super) trait SpecFromIterNested<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Unroll the first iteration, as the vector is going to be\n+        // expanded on this iteration in every case when the iterable is not\n+        // empty, but the loop in extend_desugared() is not going to see the\n+        // vector being full in the few subsequent loop iterations.\n+        // So we get better branch prediction.\n+        let mut vector = match iterator.next() {\n+            None => return Vec::new(),\n+            Some(element) => {\n+                let (lower, _) = iterator.size_hint();\n+                let mut vector = Vec::with_capacity(lower.saturating_add(1));\n+                unsafe {\n+                    ptr::write(vector.as_mut_ptr(), element);\n+                    vector.set_len(1);\n+                }\n+                vector\n+            }\n+        };\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n+        vector\n+    }\n+}\n+\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n+    fn from_iter(iterator: I) -> Self {\n+        let mut vector = match iterator.size_hint() {\n+            (_, Some(upper)) => Vec::with_capacity(upper),\n+            _ => Vec::new(),\n+        };\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vector.spec_extend(iterator);\n+        vector\n+    }\n+}"}, {"sha": "0a27b5b62ecf509830473fda17af573a1e2e51c2", "filename": "library/alloc/src/vec/splice.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsplice.rs?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -0,0 +1,133 @@\n+use crate::alloc::{Allocator, Global};\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{Drain, Vec};\n+\n+/// A splicing iterator for `Vec`.\n+///\n+/// This struct is created by [`Vec::splice()`].\n+/// See its documentation for more.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let mut v = vec![0, 1, 2];\n+/// let new = [7, 8];\n+/// let iter: std::vec::Splice<_> = v.splice(1.., new.iter().cloned());\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+pub struct Splice<\n+    'a,\n+    I: Iterator + 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + 'a = Global,\n+> {\n+    pub(super) drain: Drain<'a, I::Item, A>,\n+    pub(super) replace_with: I,\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> Iterator for Splice<'_, I, A> {\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.drain.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.drain.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> DoubleEndedIterator for Splice<'_, I, A> {\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.drain.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> ExactSizeIterator for Splice<'_, I, A> {}\n+\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n+impl<I: Iterator, A: Allocator> Drop for Splice<'_, I, A> {\n+    fn drop(&mut self) {\n+        self.drain.by_ref().for_each(drop);\n+\n+        unsafe {\n+            if self.drain.tail_len == 0 {\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n+                return;\n+            }\n+\n+            // First fill the range left by drain().\n+            if !self.drain.fill(&mut self.replace_with) {\n+                return;\n+            }\n+\n+            // There may be more elements. Use the lower bound as an estimate.\n+            // FIXME: Is the upper bound a better guess? Or something else?\n+            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n+            if lower_bound > 0 {\n+                self.drain.move_tail(lower_bound);\n+                if !self.drain.fill(&mut self.replace_with) {\n+                    return;\n+                }\n+            }\n+\n+            // Collect any remaining elements.\n+            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n+            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n+            // Now we have an exact count.\n+            if collected.len() > 0 {\n+                self.drain.move_tail(collected.len());\n+                let filled = self.drain.fill(&mut collected);\n+                debug_assert!(filled);\n+                debug_assert_eq!(collected.len(), 0);\n+            }\n+        }\n+        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n+    }\n+}\n+\n+/// Private helper methods for `Splice::drop`\n+impl<T, A: Allocator> Drain<'_, T, A> {\n+    /// The range from `self.vec.len` to `self.tail_start` contains elements\n+    /// that have been moved out.\n+    /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    unsafe fn fill<I: Iterator<Item = T>>(&mut self, replace_with: &mut I) -> bool {\n+        let vec = unsafe { self.vec.as_mut() };\n+        let range_start = vec.len;\n+        let range_end = self.tail_start;\n+        let range_slice = unsafe {\n+            slice::from_raw_parts_mut(vec.as_mut_ptr().add(range_start), range_end - range_start)\n+        };\n+\n+        for place in range_slice {\n+            if let Some(new_item) = replace_with.next() {\n+                unsafe { ptr::write(place, new_item) };\n+                vec.len += 1;\n+            } else {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Makes room for inserting more elements before the tail.\n+    unsafe fn move_tail(&mut self, additional: usize) {\n+        let vec = unsafe { self.vec.as_mut() };\n+        let len = self.tail_start + self.tail_len;\n+        vec.buf.reserve(len, additional);\n+\n+        let new_tail_start = self.tail_start + additional;\n+        unsafe {\n+            let src = vec.as_ptr().add(self.tail_start);\n+            let dst = vec.as_mut_ptr().add(new_tail_start);\n+            ptr::copy(src, dst, self.tail_len);\n+        }\n+        self.tail_start = new_tail_start;\n+    }\n+}"}, {"sha": "d4fa5be742ff3486dab53e8773b600c9fa3f410b", "filename": "src/test/ui/associated-types/defaults-wf.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the size for values of type `[u8]` cannot be known at compilation\n LL |     type Ty = Vec<[u8]>;\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`"}, {"sha": "260d78b543a4ca53a791f8b8f90c1d40ecd2289d", "filename": "src/test/ui/bad/bad-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -15,7 +15,7 @@ error[E0277]: the size for values of type `dyn Trait` cannot be known at compila\n LL |     let x: Vec<dyn Trait + Sized> = Vec::new();\n    |            ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`"}, {"sha": "5fed02164b5b704b482f1026f53e7024ceaeb6f4", "filename": "src/test/ui/issues/issue-20433.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20433.stderr?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the size for values of type `[i32]` cannot be known at compilation\n LL |     fn iceman(c: Vec<[i32]>) {}\n    |                  ^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  ::: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | pub struct Vec<T, #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global> {\n    |                - required by this bound in `Vec`"}, {"sha": "3973af540c81f181ecd929386cc312e2b7f766f2", "filename": "src/test/ui/lint/lint-const-item-mutation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/242a252687264e1115dbfa5f2b4890a35d224a05/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-const-item-mutation.stderr?ref=242a252687264e1115dbfa5f2b4890a35d224a05", "patch": "@@ -107,7 +107,7 @@ LL |     VEC.push(0);\n    = note: each usage of a `const` item creates a new temporary\n    = note: the mutable reference will refer to this temporary, not the original `const` item\n note: mutable reference created due to call to this method\n-  --> $SRC_DIR/alloc/src/vec.rs:LL:COL\n+  --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n    |\n LL | /     pub fn push(&mut self, value: T) {\n LL | |         // This will panic or abort if we would allocate > isize::MAX bytes"}]}