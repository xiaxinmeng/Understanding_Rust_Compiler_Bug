{"sha": "1915bf122e488ce540cdb7782550e907f269b9e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MTViZjEyMmU0ODhjZTU0MGNkYjc3ODI1NTBlOTA3ZjI2OWI5ZTM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-07T15:49:13Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-07T15:59:56Z"}, "message": "resolve: `ImportDirective` -> `Import`\n\n`ImportDirectiveSubclass` -> `ImportKind`\n`ImportKind::SingleImport` -> `ImportKind::Single`\n`ImportKind::GlobImport` -> `ImportKind::Glob`", "tree": {"sha": "7f330873e2d9d9d7c80070cd32824275e3e17e89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f330873e2d9d9d7c80070cd32824275e3e17e89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1915bf122e488ce540cdb7782550e907f269b9e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1915bf122e488ce540cdb7782550e907f269b9e3", "html_url": "https://github.com/rust-lang/rust/commit/1915bf122e488ce540cdb7782550e907f269b9e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1915bf122e488ce540cdb7782550e907f269b9e3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a03921701cdfe0b2c5422240f3ae370ab21069f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03921701cdfe0b2c5422240f3ae370ab21069f1", "html_url": "https://github.com/rust-lang/rust/commit/a03921701cdfe0b2c5422240f3ae370ab21069f1"}], "stats": {"total": 230, "additions": 105, "deletions": 125}, "files": [{"sha": "32cf1af60ecdaa7b9edd23067382e3d6d4cc9d01", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1915bf122e488ce540cdb7782550e907f269b9e3", "patch": "@@ -6,8 +6,7 @@\n //! Imports are also considered items and placed into modules here, but not resolved yet.\n \n use crate::def_collector::collect_definitions;\n-use crate::imports::ImportDirective;\n-use crate::imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n+use crate::imports::{Import, ImportKind};\n use crate::macros::{LegacyBinding, LegacyScope};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n@@ -312,7 +311,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn add_import_directive(\n         &mut self,\n         module_path: Vec<Segment>,\n-        subclass: ImportDirectiveSubclass<'a>,\n+        kind: ImportKind<'a>,\n         span: Span,\n         id: NodeId,\n         item: &ast::Item,\n@@ -321,11 +320,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         vis: ty::Visibility,\n     ) {\n         let current_module = self.parent_scope.module;\n-        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+        let directive = self.r.arenas.alloc_import_directive(Import {\n+            kind,\n             parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n-            subclass,\n             span,\n             id,\n             use_span: item.span,\n@@ -340,10 +339,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         debug!(\"add_import_directive({:?})\", directive);\n \n         self.r.indeterminate_imports.push(directive);\n-        match directive.subclass {\n+        match directive.kind {\n             // Don't add unresolved underscore imports to modules\n-            SingleImport { target: Ident { name: kw::Underscore, .. }, .. } => {}\n-            SingleImport { target, type_ns_only, .. } => {\n+            ImportKind::Single { target: Ident { name: kw::Underscore, .. }, .. } => {}\n+            ImportKind::Single { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| {\n                     if !type_ns_only || ns == TypeNS {\n                         let key = this.new_key(target, ns);\n@@ -354,8 +353,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n-            GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n+            ImportKind::Glob { is_prelude: true, .. } => {}\n+            ImportKind::Glob { .. } => current_module.globs.borrow_mut().push(directive),\n             _ => unreachable!(),\n         }\n     }\n@@ -480,7 +479,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     );\n                 }\n \n-                let subclass = SingleImport {\n+                let kind = ImportKind::Single {\n                     source: source.ident,\n                     target: ident,\n                     source_bindings: PerNS {\n@@ -498,7 +497,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 };\n                 self.add_import_directive(\n                     module_path,\n-                    subclass,\n+                    kind,\n                     use_tree.span,\n                     id,\n                     item,\n@@ -508,13 +507,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n-                let subclass = GlobImport {\n+                let kind = ImportKind::Glob {\n                     is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n                     prefix,\n-                    subclass,\n+                    kind,\n                     use_tree.span,\n                     id,\n                     item,\n@@ -637,15 +636,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n-                let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+                let directive = self.r.arenas.alloc_import_directive(Import {\n+                    kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n                     root_id: item.id,\n                     id: item.id,\n                     parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                    subclass: ImportDirectiveSubclass::ExternCrate {\n-                        source: orig_name,\n-                        target: ident,\n-                    },\n                     has_attributes: !item.attrs.is_empty(),\n                     use_span_with_attributes: item.span_with_attributes(),\n                     use_span: item.span,\n@@ -993,12 +989,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         let macro_use_directive = |this: &Self, span| {\n-            this.r.arenas.alloc_import_directive(ImportDirective {\n+            this.r.arenas.alloc_import_directive(Import {\n+                kind: ImportKind::MacroUse,\n                 root_id: item.id,\n                 id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                subclass: ImportDirectiveSubclass::MacroUse,\n                 use_span_with_attributes: item.span_with_attributes(),\n                 has_attributes: !item.attrs.is_empty(),\n                 use_span: item.span,"}, {"sha": "5d45fcb39343d893fe0000fe78f747509cc27335", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=1915bf122e488ce540cdb7782550e907f269b9e3", "patch": "@@ -23,7 +23,7 @@\n //  - `check_crate` finally emits the diagnostics based on the data generated\n //    in the last step\n \n-use crate::imports::ImportDirectiveSubclass;\n+use crate::imports::ImportKind;\n use crate::Resolver;\n \n use rustc::{lint, ty};\n@@ -224,12 +224,12 @@ fn calc_unused_spans(\n impl Resolver<'_> {\n     crate fn check_unused(&mut self, krate: &ast::Crate) {\n         for directive in self.potentially_unused_imports.iter() {\n-            match directive.subclass {\n+            match directive.kind {\n                 _ if directive.used.get()\n                     || directive.vis.get() == ty::Visibility::Public\n                     || directive.span.is_dummy() =>\n                 {\n-                    if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n+                    if let ImportKind::MacroUse = directive.kind {\n                         if !directive.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 lint::builtin::MACRO_USE_EXTERN_CRATE,\n@@ -243,10 +243,10 @@ impl Resolver<'_> {\n                         }\n                     }\n                 }\n-                ImportDirectiveSubclass::ExternCrate { .. } => {\n+                ImportKind::ExternCrate { .. } => {\n                     self.maybe_unused_extern_crates.push((directive.id, directive.span));\n                 }\n-                ImportDirectiveSubclass::MacroUse => {\n+                ImportKind::MacroUse => {\n                     let lint = lint::builtin::UNUSED_IMPORTS;\n                     let msg = \"unused `#[macro_use]` import\";\n                     self.lint_buffer.buffer_lint(lint, directive.id, directive.span, msg);"}, {"sha": "52d50b950005bef89dc8ad0b91f42c80c4177bb9", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1915bf122e488ce540cdb7782550e907f269b9e3", "patch": "@@ -18,7 +18,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n \n-use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n+use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n@@ -1126,7 +1126,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n         &mut self,\n-        directive: &'b ImportDirective<'b>,\n+        directive: &'b Import<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n     ) -> Option<(Option<Suggestion>, Vec<String>)> {\n@@ -1151,10 +1151,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n-            let import = match directive.subclass {\n-                ImportDirectiveSubclass::SingleImport { source, target, .. }\n-                    if source != target =>\n-                {\n+            let import = match directive.kind {\n+                ImportKind::Single { source, target, .. } if source != target => {\n                     format!(\"{} as {}\", source, target)\n                 }\n                 _ => format!(\"{}\", ident),"}, {"sha": "a43ef4ffee46f797c240fe7f52be3c4ab4a76c1d", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 61, "deletions": 71, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=1915bf122e488ce540cdb7782550e907f269b9e3", "patch": "@@ -1,7 +1,5 @@\n //! A bunch of methods and structures more or less related to resolving imports.\n \n-use ImportDirectiveSubclass::*;\n-\n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, MacroNS, TypeNS};\n@@ -38,8 +36,8 @@ type Res = def::Res<NodeId>;\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n-pub enum ImportDirectiveSubclass<'a> {\n-    SingleImport {\n+pub enum ImportKind<'a> {\n+    Single {\n         /// `source` in `use prefix::source as target`.\n         source: Ident,\n         /// `target` in `use prefix::source as target`.\n@@ -53,7 +51,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n     },\n-    GlobImport {\n+    Glob {\n         is_prelude: bool,\n         max_vis: Cell<ty::Visibility>, // The visibility of the greatest re-export.\n                                        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n@@ -67,10 +65,12 @@ pub enum ImportDirectiveSubclass<'a> {\n \n /// One import directive.\n #[derive(Debug, Clone)]\n-crate struct ImportDirective<'a> {\n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `ImportDirective`.\n+crate struct Import<'a> {\n+    pub kind: ImportKind<'a>,\n+\n+    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n     ///\n-    /// In the case where the `ImportDirective` was expanded from a \"nested\" use tree,\n+    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n     /// this id is the ID of the leaf tree. For example:\n     ///\n     /// ```ignore (pacify the mercilous tidy)\n@@ -107,22 +107,21 @@ crate struct ImportDirective<'a> {\n     pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n-    pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub used: Cell<bool>,\n }\n \n-impl<'a> ImportDirective<'a> {\n+impl<'a> Import<'a> {\n     pub fn is_glob(&self) -> bool {\n-        match self.subclass {\n-            ImportDirectiveSubclass::GlobImport { .. } => true,\n+        match self.kind {\n+            ImportKind::Glob { .. } => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_nested(&self) -> bool {\n-        match self.subclass {\n-            ImportDirectiveSubclass::SingleImport { nested, .. } => nested,\n+        match self.kind {\n+            ImportKind::Single { nested, .. } => nested,\n             _ => false,\n         }\n     }\n@@ -137,7 +136,7 @@ impl<'a> ImportDirective<'a> {\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Import directives are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<PtrKey<'a, ImportDirective<'a>>>,\n+    single_imports: FxHashSet<PtrKey<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n@@ -155,7 +154,7 @@ impl<'a> NameResolution<'a> {\n         })\n     }\n \n-    crate fn add_single_import(&mut self, directive: &'a ImportDirective<'a>) {\n+    crate fn add_single_import(&mut self, directive: &'a Import<'a>) {\n         self.single_imports.insert(PtrKey(directive));\n     }\n }\n@@ -348,8 +347,8 @@ impl<'a> Resolver<'a> {\n                 single_import.imported_module.get(),\n                 return Err((Undetermined, Weak::No))\n             );\n-            let ident = match single_import.subclass {\n-                SingleImport { source, .. } => source,\n+            let ident = match single_import.kind {\n+                ImportKind::Single { source, .. } => source,\n                 _ => unreachable!(),\n             };\n             match self.resolve_ident_in_module(\n@@ -456,7 +455,7 @@ impl<'a> Resolver<'a> {\n     crate fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n-        directive: &'a ImportDirective<'a>,\n+        directive: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      // cf. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n@@ -467,7 +466,7 @@ impl<'a> Resolver<'a> {\n             binding.pseudo_vis()\n         };\n \n-        if let GlobImport { ref max_vis, .. } = directive.subclass {\n+        if let ImportKind::Glob { ref max_vis, .. } = directive.kind {\n             if vis == directive.vis.get() || vis.is_at_least(max_vis.get(), self) {\n                 max_vis.set(vis)\n             }\n@@ -596,8 +595,8 @@ impl<'a> Resolver<'a> {\n \n     // Define a \"dummy\" resolution containing a Res::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n-        if let SingleImport { target, .. } = directive.subclass {\n+    fn import_dummy_binding(&mut self, directive: &'a Import<'a>) {\n+        if let ImportKind::Single { target, .. } = directive.kind {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n@@ -671,7 +670,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             .chain(indeterminate_imports.into_iter().map(|i| (true, i)))\n         {\n             if let Some(err) = self.finalize_import(import) {\n-                if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n+                if let ImportKind::Single { source, ref source_bindings, .. } = import.kind {\n                     if source.name == kw::SelfLower {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n@@ -695,7 +694,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if seen_spans.insert(err.span) {\n                     let path = import_path_to_string(\n                         &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                        &import.subclass,\n+                        &import.kind,\n                         err.span,\n                     );\n                     errors.push((path, err));\n@@ -706,7 +705,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 self.r.used_imports.insert((import.id, TypeNS));\n                 let path = import_path_to_string(\n                     &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                    &import.subclass,\n+                    &import.kind,\n                     import.span,\n                 );\n                 let err = UnresolvedImportError {\n@@ -767,7 +766,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n+    fn resolve_import(&mut self, directive: &'b Import<'b>) -> bool {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n             Segment::names_to_string(&directive.module_path),\n@@ -798,22 +797,22 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         };\n \n         directive.imported_module.set(Some(module));\n-        let (source, target, source_bindings, target_bindings, type_ns_only) =\n-            match directive.subclass {\n-                SingleImport {\n-                    source,\n-                    target,\n-                    ref source_bindings,\n-                    ref target_bindings,\n-                    type_ns_only,\n-                    ..\n-                } => (source, target, source_bindings, target_bindings, type_ns_only),\n-                GlobImport { .. } => {\n-                    self.resolve_glob_import(directive);\n-                    return true;\n-                }\n-                _ => unreachable!(),\n-            };\n+        let (source, target, source_bindings, target_bindings, type_ns_only) = match directive.kind\n+        {\n+            ImportKind::Single {\n+                source,\n+                target,\n+                ref source_bindings,\n+                ref target_bindings,\n+                type_ns_only,\n+                ..\n+            } => (source, target, source_bindings, target_bindings, type_ns_only),\n+            ImportKind::Glob { .. } => {\n+                self.resolve_glob_import(directive);\n+                return true;\n+            }\n+            _ => unreachable!(),\n+        };\n \n         let mut indeterminate = false;\n         self.r.per_ns(|this, ns| {\n@@ -873,10 +872,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n-    fn finalize_import(\n-        &mut self,\n-        directive: &'b ImportDirective<'b>,\n-    ) -> Option<UnresolvedImportError> {\n+    fn finalize_import(&mut self, directive: &'b Import<'b>) -> Option<UnresolvedImportError> {\n         let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n         let path_res = self.r.resolve_path(\n@@ -957,18 +953,16 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match directive\n-            .subclass\n-        {\n-            SingleImport {\n+        let (ident, target, source_bindings, target_bindings, type_ns_only) = match directive.kind {\n+            ImportKind::Single {\n                 source,\n                 target,\n                 ref source_bindings,\n                 ref target_bindings,\n                 type_ns_only,\n                 ..\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            GlobImport { is_prelude, ref max_vis } => {\n+            ImportKind::Glob { is_prelude, ref max_vis } => {\n                 if directive.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n@@ -1272,7 +1266,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     fn check_for_redundant_imports(\n         &mut self,\n         ident: Ident,\n-        directive: &'b ImportDirective<'b>,\n+        directive: &'b Import<'b>,\n         source_bindings: &PerNS<Cell<Result<&'b NameBinding<'b>, Determinacy>>>,\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n@@ -1337,7 +1331,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n+    fn resolve_glob_import(&mut self, directive: &'b Import<'b>) {\n         let module = match directive.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n             _ => {\n@@ -1351,7 +1345,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             return;\n         } else if module.def_id() == directive.parent_scope.module.def_id() {\n             return;\n-        } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n+        } else if let ImportKind::Glob { is_prelude: true, .. } = directive.kind {\n             self.r.prelude = Some(module);\n             return;\n         }\n@@ -1412,11 +1406,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     && orig_binding.is_variant()\n                     && !orig_binding.vis.is_at_least(binding.vis, &*this)\n                 {\n-                    let msg = match directive.subclass {\n-                        ImportDirectiveSubclass::SingleImport { .. } => {\n+                    let msg = match directive.kind {\n+                        ImportKind::Single { .. } => {\n                             format!(\"variant `{}` is private and cannot be re-exported\", ident)\n                         }\n-                        ImportDirectiveSubclass::GlobImport { .. } => {\n+                        ImportKind::Glob { .. } => {\n                             let msg = \"enum is private and its variants \\\n                                            cannot be re-exported\"\n                                 .to_owned();\n@@ -1432,7 +1426,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             }\n                             msg\n                         }\n-                        ref s => bug!(\"unexpected import subclass {:?}\", s),\n+                        ref s => bug!(\"unexpected import kind {:?}\", s),\n                     };\n                     let mut err = this.session.struct_span_err(binding.span, &msg);\n \n@@ -1481,11 +1475,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(\n-    names: &[Ident],\n-    subclass: &ImportDirectiveSubclass<'_>,\n-    span: Span,\n-) -> String {\n+fn import_path_to_string(names: &[Ident], import_kind: &ImportKind<'_>, span: Span) -> String {\n     let pos = names.iter().position(|p| span == p.span && p.name != kw::PathRoot);\n     let global = !names.is_empty() && names[0].name == kw::PathRoot;\n     if let Some(pos) = pos {\n@@ -1494,22 +1484,22 @@ fn import_path_to_string(\n     } else {\n         let names = if global { &names[1..] } else { names };\n         if names.is_empty() {\n-            import_directive_subclass_to_string(subclass)\n+            import_directive_subclass_to_string(import_kind)\n         } else {\n             format!(\n                 \"{}::{}\",\n                 names_to_string(&names.iter().map(|ident| ident.name).collect::<Vec<_>>()),\n-                import_directive_subclass_to_string(subclass),\n+                import_directive_subclass_to_string(import_kind),\n             )\n         }\n     }\n }\n \n-fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass<'_>) -> String {\n-    match *subclass {\n-        SingleImport { source, .. } => source.to_string(),\n-        GlobImport { .. } => \"*\".to_string(),\n-        ExternCrate { .. } => \"<extern crate>\".to_string(),\n-        MacroUse => \"#[macro_use]\".to_string(),\n+fn import_directive_subclass_to_string(import_kind: &ImportKind<'_>) -> String {\n+    match import_kind {\n+        ImportKind::Single { source, .. } => source.to_string(),\n+        ImportKind::Glob { .. } => \"*\".to_string(),\n+        ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n+        ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n     }\n }"}, {"sha": "2ffcf340b9a91b8eb3aaea918d37c862e8c08fb3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1915bf122e488ce540cdb7782550e907f269b9e3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1915bf122e488ce540cdb7782550e907f269b9e3", "patch": "@@ -56,7 +56,7 @@ use std::{cmp, fmt, iter, ptr};\n \n use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, Suggestion};\n-use imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver, NameResolution};\n+use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n use macros::{LegacyBinding, LegacyScope};\n \n@@ -456,8 +456,8 @@ pub struct ModuleData<'a> {\n \n     no_implicit_prelude: bool,\n \n-    glob_importers: RefCell<Vec<&'a ImportDirective<'a>>>,\n-    globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n+    glob_importers: RefCell<Vec<&'a Import<'a>>>,\n+    globs: RefCell<Vec<&'a Import<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n@@ -584,7 +584,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n enum NameBindingKind<'a> {\n     Res(Res, /* is_macro_export */ bool),\n     Module(Module<'a>),\n-    Import { binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>, used: Cell<bool> },\n+    Import { binding: &'a NameBinding<'a>, directive: &'a Import<'a>, used: Cell<bool> },\n }\n \n impl<'a> NameBindingKind<'a> {\n@@ -713,8 +713,7 @@ impl<'a> NameBinding<'a> {\n     fn is_extern_crate(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import {\n-                directive:\n-                    &ImportDirective { subclass: ImportDirectiveSubclass::ExternCrate { .. }, .. },\n+                directive: &Import { kind: ImportKind::ExternCrate { .. }, .. },\n                 ..\n             } => true,\n             NameBindingKind::Module(&ModuleData {\n@@ -839,10 +838,10 @@ pub struct Resolver<'a> {\n     field_names: FxHashMap<DefId, Vec<Spanned<Name>>>,\n \n     /// All imports known to succeed or fail.\n-    determined_imports: Vec<&'a ImportDirective<'a>>,\n+    determined_imports: Vec<&'a Import<'a>>,\n \n     /// All non-determined imports.\n-    indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n+    indeterminate_imports: Vec<&'a Import<'a>>,\n \n     /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n     /// We are resolving a last import segment during import validation.\n@@ -947,7 +946,7 @@ pub struct Resolver<'a> {\n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n \n-    potentially_unused_imports: Vec<&'a ImportDirective<'a>>,\n+    potentially_unused_imports: Vec<&'a Import<'a>>,\n \n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n@@ -971,7 +970,7 @@ pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n-    import_directives: arena::TypedArena<ImportDirective<'a>>,\n+    import_directives: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n@@ -991,10 +990,7 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n-    fn alloc_import_directive(\n-        &'a self,\n-        import_directive: ImportDirective<'a>,\n-    ) -> &'a ImportDirective<'_> {\n+    fn alloc_import_directive(&'a self, import_directive: Import<'a>) -> &'a Import<'_> {\n         self.import_directives.alloc(import_directive)\n     }\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n@@ -1431,7 +1427,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[inline]\n-    fn add_to_glob_map(&mut self, directive: &ImportDirective<'_>, ident: Ident) {\n+    fn add_to_glob_map(&mut self, directive: &Import<'_>, ident: Ident) {\n         if directive.is_glob() {\n             self.glob_map.entry(directive.id).or_default().insert(ident.name);\n         }\n@@ -2261,7 +2257,7 @@ impl<'a> Resolver<'a> {\n             if let NameBindingKind::Import { directive: d, .. } = binding.kind {\n                 // Careful: we still want to rewrite paths from\n                 // renamed extern crates.\n-                if let ImportDirectiveSubclass::ExternCrate { source: None, .. } = d.subclass {\n+                if let ImportKind::ExternCrate { source: None, .. } = d.kind {\n                     return;\n                 }\n             }\n@@ -2639,7 +2635,7 @@ impl<'a> Resolver<'a> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         name: Name,\n-        directive: &ImportDirective<'_>,\n+        directive: &Import<'_>,\n         binding_span: Span,\n     ) {\n         let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n@@ -2649,11 +2645,11 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut suggestion = None;\n-        match directive.subclass {\n-            ImportDirectiveSubclass::SingleImport { type_ns_only: true, .. } => {\n+        match directive.kind {\n+            ImportKind::Single { type_ns_only: true, .. } => {\n                 suggestion = Some(format!(\"self as {}\", suggested_name))\n             }\n-            ImportDirectiveSubclass::SingleImport { source, .. } => {\n+            ImportKind::Single { source, .. } => {\n                 if let Some(pos) =\n                     source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n                 {\n@@ -2669,7 +2665,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportDirectiveSubclass::ExternCrate { source, target, .. } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),\n@@ -2717,7 +2713,7 @@ impl<'a> Resolver<'a> {\n     fn add_suggestion_for_duplicate_nested_use(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        directive: &ImportDirective<'_>,\n+        directive: &Import<'_>,\n         binding_span: Span,\n     ) {\n         assert!(directive.is_nested());"}]}