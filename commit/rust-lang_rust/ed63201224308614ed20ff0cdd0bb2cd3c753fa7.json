{"sha": "ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "node_id": "C_kwDOAAsO6NoAKGVkNjMyMDEyMjQzMDg2MTRlZDIwZmYwY2RkMGJiMmNkM2M3NTNmYTc", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-03-16T14:58:26Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-03-16T14:58:35Z"}, "message": "replace usage of `evaluate_goal` with a new `add_goal`", "tree": {"sha": "ea105d41d2d02938ac6bc69200a9d9b38083ba76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea105d41d2d02938ac6bc69200a9d9b38083ba76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "html_url": "https://github.com/rust-lang/rust/commit/ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13", "html_url": "https://github.com/rust-lang/rust/commit/7ac4b82ddd596a218cac8cd6b88a91b54fcdcf13"}], "stats": {"total": 590, "additions": 336, "deletions": 254}, "files": [{"sha": "76cde1a669225247c8d2077e6f988a7b0facb7a9", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -224,7 +224,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         if goal.predicate.self_ty().is_ty_var() {\n             return vec![Candidate {\n                 source: CandidateSource::BuiltinImpl,\n-                result: self.make_canonical_response(Certainty::AMBIGUOUS).unwrap(),\n+                result: self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap(),\n             }];\n         }\n \n@@ -261,37 +263,26 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n-        self.probe(|this| {\n-            let normalized_ty = this.next_ty_infer();\n+\n+        self.probe(|ecx| {\n+            let normalized_ty = ecx.next_ty_infer();\n             let normalizes_to_goal = goal.with(\n                 tcx,\n                 ty::Binder::dummy(ty::ProjectionPredicate {\n                     projection_ty,\n                     term: normalized_ty.into(),\n                 }),\n             );\n-            let normalization_certainty = match this.evaluate_goal(normalizes_to_goal) {\n-                Ok((_, certainty)) => certainty,\n-                Err(NoSolution) => return,\n-            };\n-            let normalized_ty = this.resolve_vars_if_possible(normalized_ty);\n-\n-            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-            // This doesn't work as long as we use `CandidateSource` in winnowing.\n-            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-            let normalized_candidates = this.assemble_and_evaluate_candidates(goal);\n-            for mut normalized_candidate in normalized_candidates {\n-                normalized_candidate.result =\n-                    normalized_candidate.result.unchecked_map(|mut response| {\n-                        // FIXME: This currently hides overflow in the normalization step of the self type\n-                        // which is probably wrong. Maybe `unify_and` should actually keep overflow as\n-                        // we treat it as non-fatal anyways.\n-                        response.certainty = response.certainty.unify_and(normalization_certainty);\n-                        response\n-                    });\n-                candidates.push(normalized_candidate);\n+            ecx.add_goal(normalizes_to_goal);\n+            if let Ok(_) = ecx.try_evaluate_added_goals() {\n+                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+\n+                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+                // This doesn't work as long as we use `CandidateSource` in winnowing.\n+                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n             }\n-        })\n+        });\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n@@ -516,7 +507,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 } else {\n                     Certainty::AMBIGUOUS\n                 };\n-                return self.make_canonical_response(certainty);\n+                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n             }\n         }\n \n@@ -538,14 +529,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn discard_reservation_impl(&self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n         if let CandidateSource::Impl(def_id) = candidate.source {\n             if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n                 debug!(\"Selected reservation impl\");\n                 // We assemble all candidates inside of a probe so by\n                 // making a new canonical response here our result will\n                 // have no constraints.\n-                candidate.result = self.make_canonical_response(Certainty::AMBIGUOUS).unwrap();\n+                candidate.result = self\n+                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    .unwrap();\n             }\n         }\n "}, {"sha": "01a011a000eff8dec7a834542dfb7e07d86ee999", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -48,7 +48,20 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// - `external_constraints`: additional constraints which aren't expressable\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+    pub(super) fn evaluate_added_goals_and_make_canonical_response(\n+        &mut self,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let goals_certainty = self.try_evaluate_added_goals()?;\n+        let certainty = certainty.unify_and(goals_certainty);\n+\n+        if let Certainty::Yes = certainty {\n+            assert!(\n+                self.nested_goals.is_empty(),\n+                \"Cannot be certain of query response if unevaluated goals exist\"\n+            );\n+        }\n+\n         let external_constraints = self.compute_external_query_constraints()?;\n \n         let response = Response { var_values: self.var_values, external_constraints, certainty };\n@@ -209,7 +222,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n             // some point. We can figure out how to deal with this once we actually have\n             // an ICE.\n-            let nested_goals = self.eq(param_env, orig, response)?;\n+            let nested_goals = self.eq_and_get_goals(param_env, orig, response)?;\n             assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n         }\n "}, {"sha": "1e481f165bec16a75c14fb07b5a276677c4f876c", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -13,8 +13,7 @@ use rustc_middle::ty::{\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n-use super::search_graph::SearchGraph;\n-use super::Goal;\n+use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n@@ -33,14 +32,35 @@ pub struct EvalCtxt<'a, 'tcx> {\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n \n-    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    pub in_projection_eq_hack: bool,\n+    pub(super) nested_goals: NestedGoals<'tcx>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(super) struct NestedGoals<'tcx> {\n+    pub(super) projection_eq_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+}\n+\n+impl NestedGoals<'_> {\n+    pub(super) fn new() -> Self {\n+        Self { projection_eq_hack_goal: None, goals: Vec::new() }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.projection_eq_hack_goal.is_none() && self.goals.is_empty()\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn probe<T>(&mut self, f: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> T) -> T {\n-        self.infcx.probe(|_| f(self))\n+        let mut ecx = EvalCtxt {\n+            infcx: self.infcx,\n+            var_values: self.var_values,\n+            max_input_universe: self.max_input_universe,\n+            search_graph: self.search_graph,\n+            nested_goals: self.nested_goals.clone(),\n+        };\n+        self.infcx.probe(|_| f(&mut ecx))\n     }\n \n     pub(super) fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -61,6 +81,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         )\n     }\n \n+    /// Returns a ty infer or a const infer depending on whether `kind` is a `Ty` or `Const`.\n+    /// If `kind` is an integer inference variable this will still return a ty infer var.\n+    pub(super) fn next_term_infer_of_kind(&self, kind: ty::Term<'tcx>) -> ty::Term<'tcx> {\n+        match kind.unpack() {\n+            ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n+            ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n+        }\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe\n@@ -137,6 +166,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self, param_env), ret)]\n     pub(super) fn eq<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to equate\");\n+                NoSolution\n+            })\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn eq_and_get_goals<T: ToTrace<'tcx>>(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         lhs: T,"}, {"sha": "79e295f6b5349fb4c21e1d189524f886c9f7e3fa", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 130, "deletions": 57, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -45,6 +45,8 @@ mod trait_goals;\n pub use eval_ctxt::EvalCtxt;\n pub use fulfill::FulfillmentCtxt;\n \n+use self::eval_ctxt::NestedGoals;\n+\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -69,6 +71,7 @@ pub trait InferCtxtEvalExt<'tcx> {\n }\n \n impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n+    #[instrument(level = \"debug\", skip(self))]\n     fn evaluate_root_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n@@ -81,9 +84,9 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n             // Only relevant when canonicalizing the response.\n             max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n-            in_projection_eq_hack: false,\n+            nested_goals: NestedGoals::new(),\n         }\n-        .evaluate_goal(goal);\n+        .evaluate_goal(false, goal);\n \n         assert!(search_graph.is_empty());\n         result\n@@ -117,7 +120,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 var_values,\n                 max_input_universe: canonical_goal.max_universe,\n                 search_graph,\n-                in_projection_eq_hack: false,\n+                nested_goals: NestedGoals::new(),\n             };\n             ecx.compute_goal(goal)\n         })\n@@ -127,6 +130,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     /// been constrained and the certainty of the result.\n     fn evaluate_goal(\n         &mut self,\n+        is_projection_eq_hack_goal: bool,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n         let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n@@ -149,10 +153,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         // solver cycle.\n         if cfg!(debug_assertions)\n             && has_changed\n-            && !self.in_projection_eq_hack\n+            && !is_projection_eq_hack_goal\n             && !self.search_graph.in_cycle()\n-            && false\n         {\n+            debug!(\"rerunning goal to check result is stable\");\n             let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n@@ -202,10 +206,12 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::WellFormed(arg) => {\n                     self.compute_well_formed_goal(Goal { param_env, predicate: arg })\n                 }\n-                ty::PredicateKind::Ambiguous => self.make_canonical_response(Certainty::AMBIGUOUS),\n+                ty::PredicateKind::Ambiguous => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                }\n                 // FIXME: implement these predicates :)\n                 ty::PredicateKind::ConstEvaluatable(_) | ty::PredicateKind::ConstEquate(_, _) => {\n-                    self.make_canonical_response(Certainty::Yes)\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n@@ -217,20 +223,25 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         } else {\n             let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n             let goal = goal.with(self.tcx(), ty::Binder::dummy(kind));\n-            let (_, certainty) = self.evaluate_goal(goal)?;\n-            self.make_canonical_response(certainty)\n+            // `false` is fine to use as if this were a projection goal from the hack there would not be\n+            // a binder as the real projection goal that is the parent of the hack goal would have already\n+            // had its binder replaced with placeholders.\n+            let (_, certainty) = self.evaluate_goal(false, goal)?;\n+            self.evaluate_added_goals_and_make_canonical_response(certainty)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_type_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n         self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_region_outlives_goal(\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n@@ -239,9 +250,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             &ObligationCause::dummy(),\n             ty::Binder::dummy(goal.predicate),\n         );\n-        self.make_canonical_response(Certainty::Yes)\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_coerce_goal(\n         &mut self,\n         goal: Goal<'tcx, CoercePredicate<'tcx>>,\n@@ -256,25 +268,26 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_subtype_goal(\n         &mut self,\n         goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n             // FIXME: Do we want to register a subtype relation between these vars?\n             // That won't actually reflect in the query response, so it seems moot.\n-            self.make_canonical_response(Certainty::AMBIGUOUS)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n                 .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|pred| pred.into()).collect(),\n-            )\n+            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_closure_kind_goal(\n         &mut self,\n         goal: Goal<'tcx, (DefId, ty::SubstsRef<'tcx>, ty::ClosureKind)>,\n@@ -283,23 +296,25 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let found_kind = substs.as_closure().kind_ty().to_opt_closure_kind();\n \n         let Some(found_kind) = found_kind else {\n-            return self.make_canonical_response(Certainty::AMBIGUOUS);\n+            return self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         };\n         if found_kind.extends(expected_kind) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_object_safe_goal(&mut self, trait_def_id: DefId) -> QueryResult<'tcx> {\n         if self.tcx().check_is_object_safe(trait_def_id) {\n-            self.make_canonical_response(Certainty::Yes)\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn compute_well_formed_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n@@ -309,10 +324,11 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             goal.param_env,\n             goal.predicate,\n         ) {\n-            Some(obligations) => self.evaluate_all_and_make_canonical_response(\n-                obligations.into_iter().map(|o| o.into()).collect(),\n-            ),\n-            None => self.make_canonical_response(Certainty::AMBIGUOUS),\n+            Some(obligations) => {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),\n         }\n     }\n \n@@ -326,14 +342,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n             debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n             let r = ecx.probe(|ecx| {\n-                let (_, certainty) = ecx.evaluate_goal(goal.with(\n+                ecx.add_goal(goal.with(\n                     tcx,\n                     ty::Binder::dummy(ty::ProjectionPredicate {\n                         projection_ty: alias,\n                         term: other,\n                     }),\n-                ))?;\n-                ecx.make_canonical_response(certainty)\n+                ));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             });\n             debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n             r\n@@ -360,10 +376,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 // Evaluate all 3 potential candidates for the alias' being equal\n                 candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n                 candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|this| {\n+                candidates.push(self.probe(|ecx| {\n                     debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    let nested_goals = this.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    this.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }));\n \n                 debug!(?candidates);\n@@ -379,25 +395,92 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, (ty::Const<'tcx>, Ty<'tcx>)>,\n     ) -> QueryResult<'tcx> {\n         let (ct, ty) = goal.predicate;\n-        let nested_goals = self.eq(goal.param_env, ct.ty(), ty)?;\n-        self.evaluate_all_and_make_canonical_response(nested_goals)\n+        self.eq(goal.param_env, ct.ty(), ty)?;\n+        self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n-    // Recursively evaluates a list of goals to completion, returning the certainty\n-    // of all of the goals.\n-    fn evaluate_all(\n-        &mut self,\n-        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> Result<Certainty, NoSolution> {\n-        let mut new_goals = Vec::new();\n-        self.repeat_while_none(\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn set_projection_eq_hack_goal(&mut self, goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>) {\n+        assert!(\n+            self.nested_goals.projection_eq_hack_goal.is_none(),\n+            \"attempted to set the projection eq hack goal when one already exists\"\n+        );\n+        self.nested_goals.projection_eq_hack_goal = Some(goal);\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn add_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) {\n+        self.nested_goals.goals.push(goal);\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, goals))]\n+    fn add_goals(&mut self, goals: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>) {\n+        let current_len = self.nested_goals.goals.len();\n+        self.nested_goals.goals.extend(goals);\n+        debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n+    }\n+\n+    // Recursively evaluates all the goals added to this `EvalCtxt` to completion, returning\n+    // the certainty of all the goals.\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn try_evaluate_added_goals(&mut self) -> Result<Certainty, NoSolution> {\n+        let mut goals = core::mem::replace(&mut self.nested_goals, NestedGoals::new());\n+        let mut new_goals = NestedGoals::new();\n+\n+        let response = self.repeat_while_none(\n             |_| Ok(Certainty::Maybe(MaybeCause::Overflow)),\n             |this| {\n                 let mut has_changed = Err(Certainty::Yes);\n-                for goal in goals.drain(..) {\n-                    let (changed, certainty) = match this.evaluate_goal(goal) {\n+\n+                if let Some(goal) = goals.projection_eq_hack_goal.take() {\n+                    let (_, certainty) = match this.evaluate_goal(\n+                        true,\n+                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    ) {\n+                        Ok(r) => r,\n+                        Err(NoSolution) => return Some(Err(NoSolution)),\n+                    };\n+\n+                    if goal.predicate.projection_ty\n+                        != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n+                    {\n+                        has_changed = Ok(())\n+                    }\n+\n+                    match certainty {\n+                        Certainty::Yes => {}\n+                        Certainty::Maybe(_) => {\n+                            let goal = this.resolve_vars_if_possible(goal);\n+\n+                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n+                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n+                            // regardless of the rhs.\n+                            //\n+                            // However it is important not to unconditionally replace the rhs with a new infer var\n+                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n+                            // and never propagate any constraints on the new var back to the original var.\n+                            let term = this\n+                                .term_is_fully_unconstrained(goal)\n+                                .then_some(goal.predicate.term)\n+                                .unwrap_or_else(|| {\n+                                    this.next_term_infer_of_kind(goal.predicate.term)\n+                                });\n+                            let projection_pred = ty::ProjectionPredicate {\n+                                term,\n+                                projection_ty: goal.predicate.projection_ty,\n+                            };\n+                            new_goals.projection_eq_hack_goal =\n+                                Some(goal.with(this.tcx(), projection_pred));\n+\n+                            has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                        }\n+                    }\n+                }\n+\n+                for nested_goal in goals.goals.drain(..) {\n+                    let (changed, certainty) = match this.evaluate_goal(false, nested_goal) {\n                         Ok(result) => result,\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n@@ -409,32 +492,22 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            new_goals.push(goal);\n+                            new_goals.goals.push(nested_goal);\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }\n                 }\n \n+                mem::swap(&mut new_goals, &mut goals);\n                 match has_changed {\n-                    Ok(()) => {\n-                        mem::swap(&mut new_goals, &mut goals);\n-                        None\n-                    }\n+                    Ok(()) => None,\n                     Err(certainty) => Some(Ok(certainty)),\n                 }\n             },\n-        )\n-    }\n+        );\n \n-    // Recursively evaluates a list of goals to completion, making a query response.\n-    //\n-    // This is just a convenient way of calling [`EvalCtxt::evaluate_all`],\n-    // then [`EvalCtxt::make_canonical_response`].\n-    fn evaluate_all_and_make_canonical_response(\n-        &mut self,\n-        goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx> {\n-        self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n+        self.nested_goals = goals;\n+        response\n     }\n \n     fn try_merge_responses(\n@@ -466,7 +539,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         });\n         // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n         // responses and use that for the constraints of this ambiguous response.\n-        let response = self.make_canonical_response(certainty);\n+        let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n         if let Ok(response) = &response {\n             assert!(response.has_no_inference_or_external_constraints());\n         }"}, {"sha": "b054a2bda1fe2e166d200db596e3dc26c2834d3f", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 55, "deletions": 96, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -20,6 +20,7 @@ use rustc_span::{sym, DUMMY_SP};\n use std::iter;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn compute_projection_goal(\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -36,53 +37,17 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             self.merge_candidates_and_discard_reservation_impls(candidates)\n         } else {\n             let predicate = goal.predicate;\n-            let unconstrained_rhs = match predicate.term.unpack() {\n-                ty::TermKind::Ty(_) => self.next_ty_infer().into(),\n-                ty::TermKind::Const(ct) => self.next_const_infer(ct.ty()).into(),\n-            };\n-            let unconstrained_predicate = ty::Clause::Projection(ProjectionPredicate {\n+            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n+            let unconstrained_predicate = ProjectionPredicate {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n-            });\n-            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n-                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n-            })?;\n-\n-            let nested_eq_goals = self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n-            let eval_certainty = self.evaluate_all(nested_eq_goals)?;\n-            self.make_canonical_response(normalize_certainty.unify_and(eval_certainty))\n-        }\n-    }\n-\n-    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n-    /// see the comment in that method for more details.\n-    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n-        self.in_projection_eq_hack = true;\n-        let result = f(self);\n-        self.in_projection_eq_hack = false;\n-        result\n-    }\n-\n-    /// After normalizing the projection to `normalized_alias` with the given\n-    /// `normalization_certainty`, constrain the inference variable `term` to it\n-    /// and return a query response.\n-    fn eq_term_and_make_canonical_response(\n-        &mut self,\n-        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n-        normalization_certainty: Certainty,\n-        normalized_alias: impl Into<ty::Term<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        // The term of our goal should be fully unconstrained, so this should never fail.\n-        //\n-        // It can however be ambiguous when the `normalized_alias` contains a projection.\n-        let nested_goals = self\n-            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n-            .expect(\"failed to unify with unconstrained term\");\n-\n-        let unify_certainty =\n-            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+            };\n \n-        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n+            self.set_projection_eq_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n+            self.try_evaluate_added_goals()?;\n+            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        }\n     }\n }\n \n@@ -111,19 +76,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n-                nested_goals.extend(requirements);\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -139,36 +99,31 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n         {\n             ecx.probe(|ecx| {\n+                let tcx = ecx.tcx();\n+\n                 let assumption_projection_pred =\n                     ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.projection_ty,\n                     assumption_projection_pred.projection_ty,\n                 )?;\n \n-                let tcx = ecx.tcx();\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.projection_ty.trait_ref(tcx),\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty,\n-                    assumption_projection_pred.term,\n-                )\n+                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -195,16 +150,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals = ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal_trait_ref, impl_trait_ref)?;\n+\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-\n-            nested_goals.extend(where_clause_bounds);\n-            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n+            ecx.add_goals(where_clause_bounds);\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -216,7 +170,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -263,7 +217,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n+            ecx.eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -308,14 +263,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        let Some(tupled_inputs_and_output) =\n-        structural_traits::extract_tupled_inputs_and_output_from_callable(\n-            tcx,\n-            goal.predicate.self_ty(),\n-            goal_kind,\n-        )? else {\n-        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n-    };\n+        let tupled_inputs_and_output =\n+            match structural_traits::extract_tupled_inputs_and_output_from_callable(\n+                tcx,\n+                goal.predicate.self_ty(),\n+                goal_kind,\n+            )? {\n+                Some(tupled_inputs_and_output) => tupled_inputs_and_output,\n+                None => {\n+                    return ecx\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+            };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n \n@@ -380,26 +339,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let (_, is_sized_certainty) =\n-                        ecx.evaluate_goal(goal.with(tcx, sized_predicate))?;\n-                    return ecx.eq_term_and_make_canonical_response(\n-                        goal,\n-                        is_sized_certainty,\n-                        tcx.types.unit,\n-                    );\n+                    ecx.add_goal(goal.with(tcx, sized_predicate));\n+                    ecx.eq(goal.param_env, goal.predicate.term, tcx.types.unit.into())?;\n+                    return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n                     match def.non_enum_variant().fields.last() {\n                         None => tcx.types.unit,\n                         Some(field_def) => {\n                             let self_ty = field_def.ty(tcx, substs);\n-                            let new_goal = goal.with(\n+                            ecx.add_goal(goal.with(\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                            );\n-                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                            return ecx.make_canonical_response(certainty);\n+                            ));\n+                            return ecx\n+                                .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                         }\n                     }\n                 }\n@@ -408,12 +363,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty::Tuple(elements) => match elements.last() {\n                     None => tcx.types.unit,\n                     Some(&self_ty) => {\n-                        let new_goal = goal.with(\n+                        ecx.add_goal(goal.with(\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n-                        );\n-                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n-                        return ecx.make_canonical_response(certainty);\n+                        ));\n+                        return ecx\n+                            .evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n                     }\n                 },\n \n@@ -426,7 +381,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n+            ecx.eq(goal.param_env, goal.predicate.term, metadata_ty.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -522,7 +478,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n-        ecx.probe(|ecx| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+        ecx.probe(|ecx| {\n+            ecx.eq(goal.param_env, goal.predicate.term, discriminant.into())?;\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n     }\n }\n "}, {"sha": "83d77a69c0020e950d7dc24dbb3091fb884f178a", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -39,9 +39,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     }\n \n     pub(super) fn is_empty(&self) -> bool {\n-        self.stack.is_empty()\n-            && self.provisional_cache.is_empty()\n-            && !self.overflow_data.did_overflow()\n+        self.stack.is_empty() && self.provisional_cache.is_empty()\n     }\n \n     /// Whether we're currently in a cycle. This should only be used"}, {"sha": "108e1d0b13ff1c8828e3f9652010660ee3d08845", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -47,16 +47,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n \n-            let mut nested_goals =\n-                ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n+            ecx.eq(goal.param_env, goal.predicate.trait_ref, impl_trait_ref)?;\n             let where_clause_bounds = tcx\n                 .predicates_of(impl_def_id)\n                 .instantiate(tcx, impl_substs)\n                 .predicates\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n-            nested_goals.extend(where_clause_bounds);\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.add_goals(where_clause_bounds);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -73,13 +72,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                nested_goals.extend(requirements);\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.add_goals(requirements);\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -98,7 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                let mut nested_goals = ecx.eq(\n+                ecx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n@@ -108,18 +107,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n                     bug!(\"expected object type in `consider_object_bound_candidate`\");\n                 };\n-                nested_goals.extend(\n+                ecx.add_goals(\n                     structural_traits::predicates_for_object_candidate(\n-                        ecx,\n+                        &ecx,\n                         goal.param_env,\n                         goal.predicate.trait_ref,\n                         bounds,\n                     )\n                     .into_iter()\n                     .map(|pred| goal.with(tcx, pred)),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         } else {\n             Err(NoSolution)\n@@ -166,9 +164,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             let nested_obligations = tcx\n                 .predicates_of(goal.predicate.def_id())\n                 .instantiate(tcx, goal.predicate.trait_ref.substs);\n-            ecx.evaluate_all_and_make_canonical_response(\n-                nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)).collect(),\n-            )\n+            ecx.add_goals(nested_obligations.predicates.into_iter().map(|p| goal.with(tcx, p)));\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n@@ -197,7 +194,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.self_ty().has_non_region_infer() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n         let tcx = ecx.tcx();\n@@ -209,7 +206,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             && layout.layout.align().abi == usize_layout.align().abi\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -227,7 +224,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 goal.predicate.self_ty(),\n                 goal_kind,\n             )? else {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         };\n         let output_is_sized_pred = tupled_inputs_and_output\n             .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n@@ -247,7 +244,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n-            ecx.make_canonical_response(Certainty::Yes)\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n             Err(NoSolution)\n         }\n@@ -257,7 +254,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_future_candidate(\n@@ -277,7 +274,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         // Async generator unconditionally implement `Future`\n         // Technically, we need to check that the future output type is Sized,\n         // but that's already proven by the generator being WF.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_generator_candidate(\n@@ -317,7 +314,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let a_ty = goal.predicate.self_ty();\n         let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n         if b_ty.is_ty_var() {\n-            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+            return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n         ecx.probe(|ecx| {\n             match (a_ty.kind(), b_ty.kind()) {\n@@ -326,7 +323,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Dyn upcasting is handled separately, since due to upcasting,\n                     // when there are two supertraits that differ by substs, we\n                     // may return more than one query response.\n-                    return Err(NoSolution);\n+                    Err(NoSolution)\n                 }\n                 // `T` -> `dyn Trait` unsizing\n                 (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n@@ -341,29 +338,31 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n                         return Err(NoSolution);\n                     };\n-                    let nested_goals: Vec<_> = data\n-                        .iter()\n-                        // Check that the type implements all of the predicates of the def-id.\n-                        // (i.e. the principal, all of the associated types match, and any auto traits)\n-                        .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n-                        .chain([\n-                            // The type must be Sized to be unsized.\n-                            goal.with(\n-                                tcx,\n-                                ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n-                            ),\n-                            // The type must outlive the lifetime of the `dyn` we're unsizing into.\n-                            goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n-                        ])\n-                        .collect();\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.add_goals(\n+                        data.iter()\n+                            // Check that the type implements all of the predicates of the def-id.\n+                            // (i.e. the principal, all of the associated types match, and any auto traits)\n+                            .map(|pred| goal.with(tcx, pred.with_self_ty(tcx, a_ty)))\n+                            .chain([\n+                                // The type must be Sized to be unsized.\n+                                goal.with(\n+                                    tcx,\n+                                    ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n+                                ),\n+                                // The type must outlive the lifetime of the `dyn` we're unsizing into.\n+                                goal.with(\n+                                    tcx,\n+                                    ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region)),\n+                                ),\n+                            ]),\n+                    );\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // `[T; n]` -> `[T]` unsizing\n                 (&ty::Array(a_elem_ty, ..), &ty::Slice(b_elem_ty)) => {\n                     // We just require that the element type stays the same\n-                    let nested_goals = ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.eq(goal.param_env, a_elem_ty, b_elem_ty)?;\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Struct unsizing `Struct<T>` -> `Struct<U>` where `T: Unsize<U>`\n                 (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n@@ -397,15 +396,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n                     // Finally, we require that `TailA: Unsize<TailB>` for the tail field\n                     // types.\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n-                    nested_goals.push(goal.with(\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [a_tail_ty, b_tail_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 // Tuple unsizing `(.., T)` -> `(.., U)` where `T: Unsize<U>`\n                 (&ty::Tuple(a_tys), &ty::Tuple(b_tys))\n@@ -417,17 +415,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Substitute just the tail field of B., and require that they're equal.\n                     let unsized_a_ty =\n                         tcx.mk_tup_from_iter(a_rest_tys.iter().chain([b_last_ty]).copied());\n-                    let mut nested_goals = ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n+                    ecx.eq(goal.param_env, unsized_a_ty, b_ty)?;\n \n                     // Similar to ADTs, require that the rest of the fields are equal.\n-                    nested_goals.push(goal.with(\n+                    ecx.add_goal(goal.with(\n                         tcx,\n                         ty::Binder::dummy(\n                             tcx.mk_trait_ref(goal.predicate.def_id(), [*a_last_ty, *b_last_ty]),\n                         ),\n                     ));\n-\n-                    ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n                 }\n                 _ => Err(NoSolution),\n             }\n@@ -477,12 +474,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n \n                 // We also require that A's lifetime outlives B's lifetime.\n-                let mut nested_obligations = ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n-                nested_obligations.push(\n+                ecx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                ecx.add_goal(\n                     goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n                 );\n-\n-                ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             })\n         };\n \n@@ -516,7 +512,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         _goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n         // `DiscriminantKind` is automatically implemented for every type.\n-        ecx.make_canonical_response(Certainty::Yes)\n+        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n }\n \n@@ -530,21 +526,23 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n         constituent_tys: impl Fn(&EvalCtxt<'_, 'tcx>, Ty<'tcx>) -> Result<Vec<Ty<'tcx>>, NoSolution>,\n     ) -> QueryResult<'tcx> {\n-        self.probe(|this| {\n-            this.evaluate_all_and_make_canonical_response(\n-                constituent_tys(this, goal.predicate.self_ty())?\n+        self.probe(|ecx| {\n+            ecx.add_goals(\n+                constituent_tys(ecx, goal.predicate.self_ty())?\n                     .into_iter()\n                     .map(|ty| {\n                         goal.with(\n-                            this.tcx(),\n-                            ty::Binder::dummy(goal.predicate.with_self_ty(this.tcx(), ty)),\n+                            ecx.tcx(),\n+                            ty::Binder::dummy(goal.predicate.with_self_ty(ecx.tcx(), ty)),\n                         )\n                     })\n-                    .collect(),\n-            )\n+                    .collect::<Vec<_>>(),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     pub(super) fn compute_trait_goal(\n         &mut self,\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,"}, {"sha": "871e7c2cc5ac139d62caaa4188d0093460f36f7c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed63201224308614ed20ff0cdd0bb2cd3c753fa7/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=ed63201224308614ed20ff0cdd0bb2cd3c753fa7", "patch": "@@ -333,7 +333,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'_, 'tcx> {\n             // FIXME: Technically this folder could be fallible?\n             let nested = self\n                 .ecx\n-                .eq(self.param_env, alias_ty, proj.projection_ty)\n+                .eq_and_get_goals(self.param_env, alias_ty, proj.projection_ty)\n                 .expect(\"expected to be able to unify goal projection with dyn's projection\");\n             // FIXME: Technically we could register these too..\n             assert!(nested.is_empty(), \"did not expect unification to have any nested goals\");"}]}