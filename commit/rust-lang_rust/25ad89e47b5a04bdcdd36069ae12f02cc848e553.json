{"sha": "25ad89e47b5a04bdcdd36069ae12f02cc848e553", "node_id": "C_kwDOAAsO6NoAKDI1YWQ4OWU0N2I1YTA0YmRjZGQzNjA2OWFlMTJmMDJjYzg0OGU1NTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-20T02:19:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-20T02:19:41Z"}, "message": "Auto merge of #94174 - matthiaskrgr:rollup-snyrlhy, r=matthiaskrgr\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #93580 (Stabilize pin_static_ref.)\n - #93639 (Release notes for 1.59)\n - #93686 (core: Implement ASCII trim functions on byte slices)\n - #94002 (rustdoc: Avoid duplicating macros in sidebar)\n - #94019 (removing architecture requirements for RustyHermit)\n - #94023 (adapt static-nobundle test to use llvm-nm)\n - #94091 (Fix rustdoc const computed value)\n - #94093 (Fix pretty printing of enums without variants)\n - #94097 (Add module-level docs for `rustc_middle::query`)\n - #94112 (Optimize char_try_from_u32)\n - #94113 (document rustc_middle::mir::Field)\n - #94122 (Fix miniz_oxide types showing up in std docs)\n - #94142 (rustc_typeck: adopt let else in more places)\n - #94146 (Adopt let else in more places)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "01d95cce6d471bbb63cec92ac498dde3ebc6105a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d95cce6d471bbb63cec92ac498dde3ebc6105a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25ad89e47b5a04bdcdd36069ae12f02cc848e553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25ad89e47b5a04bdcdd36069ae12f02cc848e553", "html_url": "https://github.com/rust-lang/rust/commit/25ad89e47b5a04bdcdd36069ae12f02cc848e553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25ad89e47b5a04bdcdd36069ae12f02cc848e553/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26904687275a55864f32f3a7ba87b7711d063fd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/26904687275a55864f32f3a7ba87b7711d063fd5", "html_url": "https://github.com/rust-lang/rust/commit/26904687275a55864f32f3a7ba87b7711d063fd5"}, {"sha": "f2d6770f779051f1f5a28451b68784d2103bca32", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2d6770f779051f1f5a28451b68784d2103bca32", "html_url": "https://github.com/rust-lang/rust/commit/f2d6770f779051f1f5a28451b68784d2103bca32"}], "stats": {"total": 2301, "additions": 1105, "deletions": 1196}, "files": [{"sha": "152689953b8a960d314cc9dba05f08bc651536aa", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -154,7 +154,7 @@ version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n dependencies = [\n- \"hermit-abi\",\n+ \"hermit-abi 0.1.19\",\n  \"libc\",\n  \"winapi\",\n ]\n@@ -1610,6 +1610,15 @@ name = \"hermit-abi\"\n version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ab7905ea95c6d9af62940f9d7dd9596d54c334ae2c15300c482051292d5637f\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -2396,7 +2405,7 @@ version = \"1.13.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1\"\n dependencies = [\n- \"hermit-abi\",\n+ \"hermit-abi 0.1.19\",\n  \"libc\",\n ]\n \n@@ -4782,7 +4791,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown 0.12.0\",\n- \"hermit-abi\",\n+ \"hermit-abi 0.2.0\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object 0.26.2\","}, {"sha": "96da1660c0febf534f086714588895dbf45a912e", "filename": "RELEASES.md", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1,3 +1,168 @@\n+Version 1.59.0 (2022-02-24)\n+==========================\n+\n+Language\n+--------\n+\n+- [Stabilize default arguments for const generics][90207]\n+- [Stabilize destructuring assignment][90521]\n+- [Relax private in public lint on generic bounds and where clauses of trait impls][90586]\n+- [Stabilize asm! and global_asm! for x86, x86_64, ARM, Aarch64, and RISC-V][91728]\n+\n+Compiler\n+--------\n+\n+- [Stabilize new symbol mangling format, leaving it opt-in (-Csymbol-mangling-version=v0)][90128]\n+- [Emit LLVM optimization remarks when enabled with `-Cremark`][90833]\n+- [Fix sparc64 ABI for aggregates with floating point members][91003]\n+- [Warn when a `#[test]`-like built-in attribute macro is present multiple times.][91172]\n+- [Add support for riscv64gc-unknown-freebsd][91284]\n+- [Stabilize `-Z emit-future-incompat` as `--json future-incompat`][91535]\n+\n+Libraries\n+---------\n+\n+- [Remove unnecessary bounds for some Hash{Map,Set} methods][91593]\n+\n+Stabilized APIs\n+---------------\n+\n+- [`std::thread::available_parallelism`][available_parallelism]\n+- [`Result::copied`][result-copied]\n+- [`Result::cloned`][result-cloned]\n+- [`arch::asm!`][asm]\n+- [`arch::global_asm!`][global_asm]\n+- [`ops::ControlFlow::is_break`][is_break]\n+- [`ops::ControlFlow::is_continue`][is_continue]\n+- [`TryFrom<char> for u8`][try_from_char_u8]\n+- [`char::TryFromCharError`][try_from_char_err]\n+  implementing `Clone`, `Debug`, `Display`, `PartialEq`, `Copy`, `Eq`, `Error`\n+- [`iter::zip`][zip]\n+- [`NonZeroU8::is_power_of_two`][is_power_of_two8]\n+- [`NonZeroU16::is_power_of_two`][is_power_of_two16]\n+- [`NonZeroU32::is_power_of_two`][is_power_of_two32]\n+- [`NonZeroU64::is_power_of_two`][is_power_of_two64]\n+- [`NonZeroU128::is_power_of_two`][is_power_of_two128]\n+- [`DoubleEndedIterator for ToLowercase`][lowercase]\n+- [`DoubleEndedIterator for ToUppercase`][uppercase]\n+- [`TryFrom<&mut [T]> for [T; N]`][tryfrom_ref_arr]\n+- [`UnwindSafe for Once`][unwindsafe_once]\n+- [`RefUnwindSafe for Once`][refunwindsafe_once]\n+- [armv8 neon intrinsics for aarch64][stdarch/1266]\n+\n+Const-stable:\n+\n+- [`mem::MaybeUninit::as_ptr`][muninit_ptr]\n+- [`mem::MaybeUninit::assume_init`][muninit_init]\n+- [`mem::MaybeUninit::assume_init_ref`][muninit_init_ref]\n+- [`ffi::CStr::from_bytes_with_nul_unchecked`][cstr_from_bytes]\n+\n+Cargo\n+-----\n+\n+- [Stabilize the `strip` profile option][cargo/10088]\n+- [Stabilize future-incompat-report][cargo/10165]\n+- [Support abbreviating `--release` as `-r`][cargo/10133]\n+- [Support `term.quiet` configuration][cargo/10152]\n+- [Remove `--host` from cargo {publish,search,login}][cargo/10145]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Refactor weak symbols in std::sys::unix][90846]\n+  This may add new, versioned, symbols when building with a newer glibc, as the\n+  standard library uses weak linkage rather than dynamically attempting to load\n+  certain symbols at runtime.\n+- [Deprecate crate_type and crate_name nested inside `#![cfg_attr]`][83744]\n+  This adds a future compatibility lint to supporting the use of cfg_attr\n+  wrapping either crate_type or crate_name specification within Rust files;\n+  it is recommended that users migrate to setting the equivalent command line\n+  flags.\n+- [Remove effect of `#[no_link]` attribute on name resolution][92034]\n+  This may expose new names, leading to conflicts with preexisting names in a\n+  given namespace and a compilation failure.\n+- [Cargo will document libraries before binaries.][cargo/10172]\n+- [Respect doc=false in dependencies, not just the root crate][cargo/10201]\n+- [Weaken guarantee around advancing underlying iterators in zip][83791]\n+- [Make split_inclusive() on an empty slice yield an empty output][89825]\n+- [Update std::env::temp_dir to use GetTempPath2 on Windows when available.][89999]\n+\n+Internal Changes\n+----------------\n+\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc\n+and related tools.\n+\n+- [Fix many cases of normalization-related ICEs][91255]\n+- [Replace dominators algorithm with simple Lengauer-Tarjan][85013]\n+- [Store liveness in interval sets for region inference][90637]\n+\n+- [Remove `in_band_lifetimes` from the compiler and standard library, in preparation for removing this\n+  unstable feature.][91867]\n+\n+[91867]: https://github.com/rust-lang/rust/issues/91867\n+[83744]: https://github.com/rust-lang/rust/pull/83744/\n+[83791]: https://github.com/rust-lang/rust/pull/83791/\n+[85013]: https://github.com/rust-lang/rust/pull/85013/\n+[89825]: https://github.com/rust-lang/rust/pull/89825/\n+[89999]: https://github.com/rust-lang/rust/pull/89999/\n+[90128]: https://github.com/rust-lang/rust/pull/90128/\n+[90207]: https://github.com/rust-lang/rust/pull/90207/\n+[90521]: https://github.com/rust-lang/rust/pull/90521/\n+[90586]: https://github.com/rust-lang/rust/pull/90586/\n+[90637]: https://github.com/rust-lang/rust/pull/90637/\n+[90833]: https://github.com/rust-lang/rust/pull/90833/\n+[90846]: https://github.com/rust-lang/rust/pull/90846/\n+[91003]: https://github.com/rust-lang/rust/pull/91003/\n+[91172]: https://github.com/rust-lang/rust/pull/91172/\n+[91255]: https://github.com/rust-lang/rust/pull/91255/\n+[91284]: https://github.com/rust-lang/rust/pull/91284/\n+[91535]: https://github.com/rust-lang/rust/pull/91535/\n+[91593]: https://github.com/rust-lang/rust/pull/91593/\n+[91728]: https://github.com/rust-lang/rust/pull/91728/\n+[91878]: https://github.com/rust-lang/rust/pull/91878/\n+[91896]: https://github.com/rust-lang/rust/pull/91896/\n+[91926]: https://github.com/rust-lang/rust/pull/91926/\n+[91984]: https://github.com/rust-lang/rust/pull/91984/\n+[92020]: https://github.com/rust-lang/rust/pull/92020/\n+[92034]: https://github.com/rust-lang/rust/pull/92034/\n+[92483]: https://github.com/rust-lang/rust/pull/92483/\n+[cargo/10088]: https://github.com/rust-lang/cargo/pull/10088/\n+[cargo/10133]: https://github.com/rust-lang/cargo/pull/10133/\n+[cargo/10145]: https://github.com/rust-lang/cargo/pull/10145/\n+[cargo/10152]: https://github.com/rust-lang/cargo/pull/10152/\n+[cargo/10165]: https://github.com/rust-lang/cargo/pull/10165/\n+[cargo/10172]: https://github.com/rust-lang/cargo/pull/10172/\n+[cargo/10201]: https://github.com/rust-lang/cargo/pull/10201/\n+[cargo/10269]: https://github.com/rust-lang/cargo/pull/10269/\n+\n+[cstr_from_bytes]: https://doc.rust-lang.org/stable/std/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked\n+[muninit_ptr]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_ptr\n+[muninit_init]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init\n+[muninit_init_ref]: https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_ref\n+[unwindsafe_once]: https://doc.rust-lang.org/stable/std/sync/struct.Once.html#impl-UnwindSafe\n+[refunwindsafe_once]: https://doc.rust-lang.org/stable/std/sync/struct.Once.html#impl-RefUnwindSafe\n+[tryfrom_ref_arr]: https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html#impl-TryFrom%3C%26%27_%20mut%20%5BT%5D%3E\n+[lowercase]: https://doc.rust-lang.org/stable/std/char/struct.ToLowercase.html#impl-DoubleEndedIterator\n+[uppercase]: https://doc.rust-lang.org/stable/std/char/struct.ToUppercase.html#impl-DoubleEndedIterator\n+[try_from_char_err]: https://doc.rust-lang.org/stable/std/char/struct.TryFromCharError.html\n+[available_parallelism]: https://doc.rust-lang.org/stable/std/thread/fn.available_parallelism.html\n+[result-copied]: https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.copied\n+[result-cloned]: https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.cloned\n+[asm]: https://doc.rust-lang.org/stable/core/arch/macro.asm.html\n+[global_asm]: https://doc.rust-lang.org/stable/core/arch/macro.global_asm.html\n+[is_break]: https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html#method.is_break\n+[is_continue]: https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html#method.is_continue\n+[try_from_char_u8]: https://doc.rust-lang.org/stable/std/primitive.char.html#impl-TryFrom%3Cchar%3E\n+[zip]: https://doc.rust-lang.org/stable/std/iter/fn.zip.html\n+[is_power_of_two8]: https://doc.rust-lang.org/stable/core/num/struct.NonZeroU8.html#method.is_power_of_two\n+[is_power_of_two16]: https://doc.rust-lang.org/stable/core/num/struct.NonZeroU16.html#method.is_power_of_two\n+[is_power_of_two32]: https://doc.rust-lang.org/stable/core/num/struct.NonZeroU32.html#method.is_power_of_two\n+[is_power_of_two64]: https://doc.rust-lang.org/stable/core/num/struct.NonZeroU64.html#method.is_power_of_two\n+[is_power_of_two128]: https://doc.rust-lang.org/stable/core/num/struct.NonZeroU128.html#method.is_power_of_two\n+[stdarch/1266]: https://github.com/rust-lang/stdarch/pull/1266\n+\n Version 1.58.1 (2022-01-19)\n ===========================\n "}, {"sha": "0211d7b3367364b91c4c3dd770ad93b82ce74c93", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -339,9 +339,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                                     let idx2 = *o.get();\n                                     let &(ref op2, op_sp2) = &operands[idx2];\n-                                    let reg2 = match op2.reg() {\n-                                        Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n-                                        _ => unreachable!(),\n+                                    let Some(asm::InlineAsmRegOrRegClass::Reg(reg2)) = op2.reg() else {\n+                                        unreachable!();\n                                     };\n \n                                     let msg = format!("}, {"sha": "d64f1a05712a9eaa902cf16289b8d2475afbfd3b", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -330,9 +330,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: Vec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n-        let path = match f.kind {\n-            ExprKind::Path(None, ref mut path) => path,\n-            _ => unreachable!(),\n+        let ExprKind::Path(None, ref mut path) = f.kind else {\n+            unreachable!();\n         };\n \n         // Split the arguments into const generics and normal arguments"}, {"sha": "e230b2dd49f73187ae2b164b107cd30be19f5900", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1376,9 +1376,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n-            let bound_pred = match *pred {\n-                WherePredicate::BoundPredicate(ref bound_pred) => bound_pred,\n-                _ => continue,\n+            let WherePredicate::BoundPredicate(ref bound_pred) = *pred else {\n+                continue;\n             };\n             let compute_is_param = || {\n                 // Check if the where clause type is a plain type parameter."}, {"sha": "20caed1b230d56a707f90a744d05fc9ad6270e31", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -482,9 +482,8 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_foreign_kind_bodyless(&self, ident: Ident, kind: &str, body: Option<Span>) {\n-        let body = match body {\n-            None => return,\n-            Some(body) => body,\n+        let Some(body) = body else {\n+            return;\n         };\n         self.err_handler()\n             .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n@@ -504,9 +503,8 @@ impl<'a> AstValidator<'a> {\n \n     /// An `fn` in `extern { ... }` cannot have a body `{ ... }`.\n     fn check_foreign_fn_bodyless(&self, ident: Ident, body: Option<&Block>) {\n-        let body = match body {\n-            None => return,\n-            Some(body) => body,\n+        let Some(body) = body else {\n+            return;\n         };\n         self.err_handler()\n             .struct_span_err(ident.span, \"incorrect function inside `extern` block\")"}, {"sha": "27637e311f48d73b6ae456bd47ca312b624d3021", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -57,9 +57,8 @@ impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n }\n \n pub fn run(span_diagnostic: &rustc_errors::Handler, mode: &str, krate: &ast::Crate) {\n-    let mode = match mode.parse().ok() {\n-        Some(mode) => mode,\n-        None => return,\n+    let Ok(mode) = mode.parse() else {\n+        return;\n     };\n     let mut v = ShowSpanVisitor { span_diagnostic, mode };\n     visit::walk_crate(&mut v, krate);"}, {"sha": "8d6c8c247851e4644bab99bf7023a89996db64cb", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -556,17 +556,14 @@ pub fn eval_condition(\n                     return false;\n                 }\n             };\n-            let min_version = match parse_version(min_version.as_str(), false) {\n-                Some(ver) => ver,\n-                None => {\n-                    sess.span_diagnostic\n-                        .struct_span_warn(\n-                            *span,\n-                            \"unknown version literal format, assuming it refers to a future version\",\n-                        )\n-                        .emit();\n-                    return false;\n-                }\n+            let Some(min_version) = parse_version(min_version.as_str(), false) else {\n+                sess.span_diagnostic\n+                    .struct_span_warn(\n+                        *span,\n+                        \"unknown version literal format, assuming it refers to a future version\",\n+                    )\n+                    .emit();\n+                return false;\n             };\n             let rustc_version = parse_version(env!(\"CFG_RELEASE\"), true).unwrap();\n \n@@ -669,9 +666,8 @@ where\n             break;\n         }\n \n-        let meta = match attr.meta() {\n-            Some(meta) => meta,\n-            None => continue,\n+        let Some(meta) = attr.meta() else {\n+            continue;\n         };\n         let mut since = None;\n         let mut note = None;"}, {"sha": "6988fbf833666ecf78082e0ec33da32c93885d60", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -2071,22 +2071,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ) = rvalue\n                         {\n                             for operand in operands {\n-                                let assigned_from = match operand {\n-                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                        assigned_from\n-                                    }\n-                                    _ => continue,\n+                                let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n+                                    continue;\n                                 };\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n                                     assigned_from\n                                 );\n \n                                 // Find the local from the operand.\n-                                let assigned_from_local = match assigned_from.local_or_deref_local()\n-                                {\n-                                    Some(local) => local,\n-                                    None => continue,\n+                                let Some(assigned_from_local) = assigned_from.local_or_deref_local() else {\n+                                    continue;\n                                 };\n \n                                 if assigned_from_local != target {\n@@ -2138,10 +2133,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n \n                         // Find the local from the rvalue.\n-                        let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                            Some(local) => local,\n-                            None => continue,\n-                        };\n+                        let Some(assigned_from_local) = assigned_from.local_or_deref_local() else { continue };\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: \\\n                              assigned_from_local={:?}\",\n@@ -2189,11 +2181,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         assigned_to, args\n                     );\n                     for operand in args {\n-                        let assigned_from = match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n-                            _ => continue,\n+                        let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n+                            continue;\n                         };\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: assigned_from={:?}\","}, {"sha": "b1e5a211cf1cb64aa9146fb03cbba276a0ffedf3", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -650,13 +650,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // The only kind of statement that we care about is assignments...\n                 if let StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n-                    let into = match place.local_or_deref_local() {\n-                        Some(into) => into,\n-                        None => {\n-                            // Continue at the next location.\n-                            queue.push(current_location.successor_within_block());\n-                            continue;\n-                        }\n+                    let Some(into) = place.local_or_deref_local() else {\n+                        // Continue at the next location.\n+                        queue.push(current_location.successor_within_block());\n+                        continue;\n                     };\n \n                     match rvalue {"}, {"sha": "5f533ddcb82bad3a73c529b50767dff6778daa7b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -444,10 +444,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     debug!(\"borrowed_content_source: init={:?}\", init);\n                     // We're only interested in statements that initialized a value, not the\n                     // initializations from arguments.\n-                    let loc = match init.location {\n-                        InitLocation::Statement(stmt) => stmt,\n-                        _ => continue,\n-                    };\n+                    let InitLocation::Statement(loc) = init.location else { continue };\n \n                     let bbd = &self.body[loc.block];\n                     let is_terminator = bbd.statements.len() == loc.statement_index;\n@@ -787,9 +784,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> UseSpans<'tcx> {\n         use self::UseSpans::*;\n \n-        let stmt = match self.body[location.block].statements.get(location.statement_index) {\n-            Some(stmt) => stmt,\n-            None => return OtherUse(self.body.source_info(location).span),\n+        let Some(stmt) = self.body[location.block].statements.get(location.statement_index) else {\n+            return OtherUse(self.body.source_info(location).span);\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);"}, {"sha": "d4f238ff71f25dd9516168d36110401201bd61fb", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -188,10 +188,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             // Error with the pattern\n             LookupResult::Exact(_) => {\n-                let mpi = match self.move_data.rev_lookup.find(move_from.as_ref()) {\n-                    LookupResult::Parent(Some(mpi)) => mpi,\n+                let LookupResult::Parent(Some(mpi)) = self.move_data.rev_lookup.find(move_from.as_ref()) else {\n                     // move_from should be a projection from match_place.\n-                    _ => unreachable!(\"Probably not unreachable...\"),\n+                    unreachable!(\"Probably not unreachable...\");\n                 };\n                 for ge in &mut *grouped_errors {\n                     if let GroupedMoveError::MovesFromValue {"}, {"sha": "719862e67c873d0b7cb63e1cf40199c99e2aab80", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1914,10 +1914,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // without going over a Deref.\n             let mut shortest_uninit_seen = None;\n             for prefix in this.prefixes(base, PrefixSet::Shallow) {\n-                let mpi = match this.move_path_for_place(prefix) {\n-                    Some(mpi) => mpi,\n-                    None => continue,\n-                };\n+                let Some(mpi) = this.move_path_for_place(prefix) else { continue };\n \n                 if maybe_uninits.contains(mpi) {\n                     debug!("}, {"sha": "b99fb00599e7fd8cb9138357c3b872daebb98aa1", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -913,9 +913,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n-        let subject = match self.try_promote_type_test_subject(infcx, generic_ty) {\n-            Some(s) => s,\n-            None => return false,\n+        let Some(subject) = self.try_promote_type_test_subject(infcx, generic_ty) else {\n+            return false;\n         };\n \n         // For each region outlived by lower_bound find a non-local,\n@@ -1623,15 +1622,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // If we have some bound universal region `'a`, then the only\n         // elements it can contain is itself -- we don't know anything\n         // else about it!\n-        let error_element = match {\n+        let Some(error_element) = ({\n             self.scc_values.elements_contained_in(longer_fr_scc).find(|element| match element {\n                 RegionElement::Location(_) => true,\n                 RegionElement::RootUniversalRegion(_) => true,\n                 RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n             })\n-        } {\n-            Some(v) => v,\n-            None => return,\n+        }) else {\n+            return;\n         };\n         debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n "}, {"sha": "89b14129d01078b35583eafaa7ddc33ec701402e", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -810,13 +810,12 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n                 ty::Generator(def_id, substs, _) => {\n                     let mut variants = substs.as_generator().state_tys(def_id, tcx);\n-                    let mut variant = match variants.nth(variant_index.into()) {\n-                        Some(v) => v,\n-                        None => bug!(\n+                    let Some(mut variant) = variants.nth(variant_index.into()) else {\n+                        bug!(\n                             \"variant_index of generator out of range: {:?}/{:?}\",\n                             variant_index,\n                             substs.as_generator().state_tys(def_id, tcx).count()\n-                        ),\n+                        );\n                     };\n                     return match variant.nth(field.index()) {\n                         Some(ty) => Ok(ty),\n@@ -2178,35 +2177,29 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(body, tcx).kind() {\n-                            ty::RawPtr(ty::TypeAndMut {\n-                                ty: ty_from,\n-                                mutbl: hir::Mutability::Mut,\n-                            }) => ty_from,\n-                            _ => {\n-                                span_mirbug!(\n-                                    self,\n-                                    rvalue,\n-                                    \"unexpected base type for cast {:?}\",\n-                                    ty,\n-                                );\n-                                return;\n-                            }\n+                        let ty::RawPtr(ty::TypeAndMut {\n+                            ty: ty_from,\n+                            mutbl: hir::Mutability::Mut,\n+                        }) = op.ty(body, tcx).kind() else {\n+                            span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"unexpected base type for cast {:?}\",\n+                                ty,\n+                            );\n+                            return;\n                         };\n-                        let ty_to = match ty.kind() {\n-                            ty::RawPtr(ty::TypeAndMut {\n-                                ty: ty_to,\n-                                mutbl: hir::Mutability::Not,\n-                            }) => ty_to,\n-                            _ => {\n-                                span_mirbug!(\n-                                    self,\n-                                    rvalue,\n-                                    \"unexpected target type for cast {:?}\",\n-                                    ty,\n-                                );\n-                                return;\n-                            }\n+                        let ty::RawPtr(ty::TypeAndMut {\n+                            ty: ty_to,\n+                            mutbl: hir::Mutability::Not,\n+                        }) = ty.kind() else {\n+                            span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"unexpected target type for cast {:?}\",\n+                                ty,\n+                            );\n+                            return;\n                         };\n                         if let Err(terr) = self.sub_types(\n                             *ty_from,\n@@ -2238,17 +2231,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             _ => None,\n                         };\n \n-                        let (ty_elem, ty_mut) = match opt_ty_elem_mut {\n-                            Some(ty_elem_mut) => ty_elem_mut,\n-                            None => {\n-                                span_mirbug!(\n-                                    self,\n-                                    rvalue,\n-                                    \"ArrayToPointer cast from unexpected type {:?}\",\n-                                    ty_from,\n-                                );\n-                                return;\n-                            }\n+                        let Some((ty_elem, ty_mut)) = opt_ty_elem_mut else {\n+                            span_mirbug!(\n+                                self,\n+                                rvalue,\n+                                \"ArrayToPointer cast from unexpected type {:?}\",\n+                                ty_from,\n+                            );\n+                            return;\n                         };\n \n                         let (ty_to, ty_to_mut) = match ty.kind() {"}, {"sha": "33e65439fd7df92d92f5de38c94d571bebc9eea2", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -641,9 +641,8 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let (&output, tuplized_inputs) =\n                     inputs_and_output.skip_binder().split_last().unwrap();\n                 assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                let inputs = match tuplized_inputs[0].kind() {\n-                    ty::Tuple(inputs) => inputs,\n-                    _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                let ty::Tuple(inputs) = tuplized_inputs[0].kind() else {\n+                    bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]);\n                 };\n \n                 ty::Binder::bind_with_vars("}, {"sha": "7b7db3eaea61387c27dbee42f51a5ada7c692f68", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -44,9 +44,8 @@ impl MultiItemModifier for Expander {\n             template,\n         );\n \n-        let path = match validate_input(ecx, meta_item) {\n-            Some(path) => path,\n-            None => return ExpandResult::Ready(Vec::new()),\n+        let Some(path) = validate_input(ecx, meta_item) else {\n+            return ExpandResult::Ready(Vec::new());\n         };\n \n         match ecx.resolver.cfg_accessible(ecx.current_expansion.id, path) {"}, {"sha": "990b88295690ca26e6f9898f4073169cc7ea70ca", "filename": "compiler/rustc_builtin_macros/src/compile_error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -9,9 +9,8 @@ pub fn expand_compile_error<'cx>(\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    let var = match get_single_str_from_tts(cx, sp, tts, \"compile_error!\") {\n-        None => return DummyResult::any(sp),\n-        Some(v) => v,\n+    let Some(var) = get_single_str_from_tts(cx, sp, tts, \"compile_error!\") else {\n+        return DummyResult::any(sp);\n     };\n \n     cx.span_err(sp, &var);"}, {"sha": "a23dd1d1213b718cd1cacc7943b13c5e901370df", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -10,9 +10,8 @@ pub fn expand_concat(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let es = match base::get_exprs_from_tts(cx, sp, tts) {\n-        Some(e) => e,\n-        None => return DummyResult::any(sp),\n+    let Some(es) = base::get_exprs_from_tts(cx, sp, tts) else {\n+        return DummyResult::any(sp);\n     };\n     let mut accumulator = String::new();\n     let mut missing_literal = vec![];"}, {"sha": "a1afec410c1c5dcbefbf14f6c36ae258edf0d974", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -121,9 +121,8 @@ pub fn expand_concat_bytes(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let es = match base::get_exprs_from_tts(cx, sp, tts) {\n-        Some(e) => e,\n-        None => return DummyResult::any(sp),\n+    let Some(es) = base::get_exprs_from_tts(cx, sp, tts) else {\n+        return DummyResult::any(sp);\n     };\n     let mut accumulator = Vec::new();\n     let mut missing_literals = vec![];"}, {"sha": "fd26a376f91aa4357ba8850c2361b78700e58531", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -196,12 +196,11 @@ fn cs_clone(\n             let fields = all_fields\n                 .iter()\n                 .map(|field| {\n-                    let ident = match field.name {\n-                        Some(i) => i,\n-                        None => cx.span_bug(\n+                    let Some(ident) = field.name else {\n+                        cx.span_bug(\n                             trait_span,\n                             &format!(\"unnamed field in normal struct in `derive({})`\", name,),\n-                        ),\n+                        );\n                     };\n                     let call = subcall(cx, field);\n                     cx.field_imm(field.span, ident, call)"}, {"sha": "2b3ac0a86c16ca29a113b4d757f6c28deb6bc007", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -83,9 +83,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n             // }\n \n             let new = {\n-                let other_f = match other_fs {\n-                    [o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n+                let [other_f] = other_fs else {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n                 };\n \n                 let args ="}, {"sha": "eead8b37024c06efe8e09c5b5736337a688f672d", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -26,9 +26,8 @@ pub fn expand_deriving_partial_eq(\n         base: bool,\n     ) -> P<Expr> {\n         let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let other_f = match other_fs {\n-                [o_f] => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n+            let [other_f] = other_fs else {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n             };\n \n             cx.expr_binary(span, op, self_f, other_f.clone())"}, {"sha": "d28ac822a1ed9eb58813a99025350e9ab5caac4d", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -86,9 +86,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n             // }\n \n             let new = {\n-                let other_f = match other_fs {\n-                    [o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                let [other_f] = other_fs else {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\");\n                 };\n \n                 let args ="}, {"sha": "ca83941f600ca439a4a825b12c9e94de59b98ded", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -101,9 +101,8 @@ fn default_enum_substructure(\n     trait_span: Span,\n     enum_def: &EnumDef,\n ) -> P<Expr> {\n-    let default_variant = match extract_default_variant(cx, enum_def, trait_span) {\n-        Ok(value) => value,\n-        Err(()) => return DummyResult::raw_expr(trait_span, true),\n+    let Ok(default_variant) = extract_default_variant(cx, enum_def, trait_span) else {\n+        return DummyResult::raw_expr(trait_span, true);\n     };\n \n     // At this point, we know that there is exactly one variant with a `#[default]` attribute. The"}, {"sha": "f1d46f03bad8f4d794f1dc7b7e74f35cf70f91ec", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -48,9 +48,8 @@ pub fn expand_deriving_hash(\n }\n \n fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let state_expr = match substr.nonself_args {\n-        [o_f] => o_f,\n-        _ => cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\"),\n+    let [state_expr] = substr.nonself_args else {\n+        cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\");\n     };\n     let call_hash = |span, thing_expr| {\n         let hash_path = {"}, {"sha": "812d86af6e8f22ee7ce148de37068bbf5f4e4fd3", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -116,9 +116,8 @@ fn inject_impl_of_structural_trait(\n     structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let item = match *item {\n-        Annotatable::Item(ref item) => item,\n-        _ => unreachable!(),\n+    let Annotatable::Item(ref item) = *item else {\n+        unreachable!();\n     };\n \n     let generics = match item.kind {"}, {"sha": "66ee93ce3c90ea4c366b7ddf01d05fa9db397193", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -16,9 +16,8 @@ pub fn expand_option_env<'cx>(\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n-        None => return DummyResult::any(sp),\n-        Some(v) => v,\n+    let Some(var) = get_single_str_from_tts(cx, sp, tts, \"option_env!\") else {\n+        return DummyResult::any(sp);\n     };\n \n     let sp = cx.with_def_site_ctxt(sp);\n@@ -62,9 +61,8 @@ pub fn expand_env<'cx>(\n         Some(exprs) => exprs.into_iter(),\n     };\n \n-    let var = match expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") {\n-        None => return DummyResult::any(sp),\n-        Some((v, _style)) => v,\n+    let Some((var, _style)) = expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") else {\n+        return DummyResult::any(sp);\n     };\n     let msg = match exprs.next() {\n         None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),"}, {"sha": "407ca2301e124417521682f8362e71865da6c576", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -103,11 +103,9 @@ impl<'a> CollectProcMacros<'a> {\n     }\n \n     fn collect_custom_derive(&mut self, item: &'a ast::Item, attr: &'a ast::Attribute) {\n-        let (trait_name, proc_attrs) =\n-            match parse_macro_name_and_helper_attrs(self.handler, attr, \"derive\") {\n-                Some(name_and_attrs) => name_and_attrs,\n-                None => return,\n-            };\n+        let Some((trait_name, proc_attrs)) = parse_macro_name_and_helper_attrs(self.handler, attr, \"derive\") else {\n+            return;\n+        };\n \n         if self.in_root && item.vis.kind.is_pub() {\n             self.macros.push(ProcMacro::Derive(ProcMacroDerive {\n@@ -219,15 +217,12 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             }\n         }\n \n-        let attr = match found_attr {\n-            None => {\n-                self.check_not_pub_in_root(&item.vis, self.source_map.guess_head_span(item.span));\n-                let prev_in_root = mem::replace(&mut self.in_root, false);\n-                visit::walk_item(self, item);\n-                self.in_root = prev_in_root;\n-                return;\n-            }\n-            Some(attr) => attr,\n+        let Some(attr) = found_attr else {\n+            self.check_not_pub_in_root(&item.vis, self.source_map.guess_head_span(item.span));\n+            let prev_in_root = mem::replace(&mut self.in_root, false);\n+            visit::walk_item(self, item);\n+            self.in_root = prev_in_root;\n+            return;\n         };\n \n         if !is_fn {"}, {"sha": "bbc8e62d68ff0ad7818f5d48ee63790e0767fda9", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -98,9 +98,8 @@ pub fn expand_include<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let sp = cx.with_def_site_ctxt(sp);\n-    let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n-        Some(f) => f,\n-        None => return DummyResult::any(sp),\n+    let Some(file) = get_single_str_from_tts(cx, sp, tts, \"include!\") else {\n+        return DummyResult::any(sp);\n     };\n     // The file will be added to the code map by the parser\n     let file = match cx.resolve_path(file, sp) {\n@@ -169,9 +168,8 @@ pub fn expand_include_str(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n     let sp = cx.with_def_site_ctxt(sp);\n-    let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n-        Some(f) => f,\n-        None => return DummyResult::any(sp),\n+    let Some(file) = get_single_str_from_tts(cx, sp, tts, \"include_str!\") else {\n+        return DummyResult::any(sp);\n     };\n     let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,\n@@ -204,9 +202,8 @@ pub fn expand_include_bytes(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n     let sp = cx.with_def_site_ctxt(sp);\n-    let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n-        Some(f) => f,\n-        None => return DummyResult::any(sp),\n+    let Some(file) = get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") else {\n+        return DummyResult::any(sp);\n     };\n     let file = match cx.resolve_path(file, sp) {\n         Ok(f) => f,"}, {"sha": "1a2cec2a0d97f53d8679969487f1d06fe7c98250", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -310,10 +310,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n             if let Some(archive) = self.src_archive() {\n                 for child in archive.iter() {\n                     let child = child.map_err(string_to_io_error)?;\n-                    let child_name = match child.name() {\n-                        Some(s) => s,\n-                        None => continue,\n-                    };\n+                    let Some(child_name) = child.name() else { continue };\n                     if removals.iter().any(|r| r == child_name) {\n                         continue;\n                     }"}, {"sha": "e60ad170434c3fa3f43b724d9027b32936b02650", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -826,20 +826,14 @@ pub(crate) unsafe fn codegen(\n                 let input =\n                     unsafe { slice::from_raw_parts(input_ptr as *const u8, input_len as usize) };\n \n-                let input = match str::from_utf8(input) {\n-                    Ok(s) => s,\n-                    Err(_) => return 0,\n-                };\n+                let Ok(input) = str::from_utf8(input) else { return 0 };\n \n                 let output = unsafe {\n                     slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n                 };\n                 let mut cursor = io::Cursor::new(output);\n \n-                let demangled = match rustc_demangle::try_demangle(input) {\n-                    Ok(d) => d,\n-                    Err(_) => return 0,\n-                };\n+                let Ok(demangled) = rustc_demangle::try_demangle(input) else { return 0 };\n \n                 if write!(cursor, \"{:#}\", demangled).is_err() {\n                     // Possible only if provided buffer is not big enough"}, {"sha": "e15b86aa84fa40056dfdf4f1552ad746b305b95a", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -138,10 +138,7 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n }\n \n pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n-    let sect = match attrs.link_section {\n-        Some(name) => name,\n-        None => return,\n-    };\n+    let Some(sect) = attrs.link_section else { return };\n     unsafe {\n         let buf = SmallCStr::new(sect.as_str());\n         llvm::LLVMSetSection(llval, buf.as_ptr());"}, {"sha": "51223697dbd8504a847b700bd09387039b85cf54", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -369,10 +369,9 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n         unsafe {\n             let attrs = self.tcx.codegen_fn_attrs(def_id);\n \n-            let (v, alloc) = match codegen_static_initializer(self, def_id) {\n-                Ok(v) => v,\n+            let Ok((v, alloc)) = codegen_static_initializer(self, def_id) else {\n                 // Error has already been reported\n-                Err(_) => return,\n+                return;\n             };\n \n             let g = self.get_static(def_id);"}, {"sha": "fd1e61f2b8aa080be441bb2053857f39d523ab49", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -766,18 +766,15 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n \n         if already_stored_in_typemap {\n             // Also make sure that we already have a `TypeMap` entry for the unique type ID.\n-            let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n-                Some(metadata) => metadata,\n-                None => {\n-                    bug!(\n-                        \"expected type metadata for unique \\\n-                               type ID '{}' to already be in \\\n-                               the `debuginfo::TypeMap` but it \\\n-                               was not. (Ty = {})\",\n-                        type_map.get_unique_type_id_as_string(unique_type_id),\n-                        t\n-                    );\n-                }\n+            let Some(metadata_for_uid) = type_map.find_metadata_for_unique_id(unique_type_id) else {\n+                bug!(\n+                    \"expected type metadata for unique \\\n+                            type ID '{}' to already be in \\\n+                            the `debuginfo::TypeMap` but it \\\n+                            was not. (Ty = {})\",\n+                    type_map.get_unique_type_id_as_string(unique_type_id),\n+                    t\n+                );\n             };\n \n             match type_map.find_metadata_for_type(t) {"}, {"sha": "f471f461e8639ed9695fc43b25a372eb02521f63", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -88,9 +88,8 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         let tcx = self.tcx;\n         let callee_ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n \n-        let (def_id, substs) = match *callee_ty.kind() {\n-            ty::FnDef(def_id, substs) => (def_id, substs),\n-            _ => bug!(\"expected fn item type, found {}\", callee_ty),\n+        let ty::FnDef(def_id, substs) = *callee_ty.kind() else {\n+            bug!(\"expected fn item type, found {}\", callee_ty);\n         };\n \n         let sig = callee_ty.fn_sig(tcx);\n@@ -1000,9 +999,8 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 }\n             })\n             .collect();\n-        let indices = match indices {\n-            Some(i) => i,\n-            None => return Ok(bx.const_null(llret_ty)),\n+        let Some(indices) = indices else {\n+            return Ok(bx.const_null(llret_ty));\n         };\n \n         return Ok(bx.shuffle_vector("}, {"sha": "dc2df8849f8aed5c7d5ca85577e5abf9f4fa69c8", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -339,9 +339,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             _ => {}\n         }\n \n-        let (a, b) = match self.abi {\n-            Abi::ScalarPair(a, b) => (a, b),\n-            _ => bug!(\"TyAndLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n+        let Abi::ScalarPair(a, b) = self.abi else {\n+            bug!(\"TyAndLayout::scalar_pair_element_llty({:?}): not applicable\", self);\n         };\n         let scalar = [a, b][index];\n "}, {"sha": "5a07b23f3f989174633d333f3692e46f767f6373", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -674,9 +674,8 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     loop {\n         i += 1;\n         prog = sess.time(\"run_linker\", || exec_linker(sess, &cmd, out_filename, tmpdir));\n-        let output = match prog {\n-            Ok(ref output) => output,\n-            Err(_) => break,\n+        let Ok(ref output) = prog else {\n+            break;\n         };\n         if output.status.success() {\n             break;\n@@ -2025,9 +2024,8 @@ fn add_local_native_libraries(\n     let search_path = OnceCell::new();\n     let mut last = (NativeLibKind::Unspecified, None);\n     for lib in relevant_libs {\n-        let name = match lib.name {\n-            Some(l) => l,\n-            None => continue,\n+        let Some(name) = lib.name else {\n+            continue;\n         };\n \n         // Skip if this library is the same as the last.\n@@ -2382,9 +2380,8 @@ fn add_upstream_native_libraries(\n     let mut last = (NativeLibKind::Unspecified, None);\n     for &cnum in &codegen_results.crate_info.used_crates {\n         for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let name = match lib.name {\n-                Some(l) => l,\n-                None => continue,\n+            let Some(name) = lib.name else {\n+                continue;\n             };\n             if !relevant_lib(sess, &lib) {\n                 continue;"}, {"sha": "39d39ad13655a3038e322a310f760290bc40ce02", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -79,15 +79,14 @@ fn search_for_metadata<'a>(\n     bytes: &'a [u8],\n     section: &str,\n ) -> Result<&'a [u8], String> {\n-    let file = match object::File::parse(bytes) {\n-        Ok(f) => f,\n+    let Ok(file) = object::File::parse(bytes) else {\n         // The parse above could fail for odd reasons like corruption, but for\n         // now we just interpret it as this target doesn't support metadata\n         // emission in object files so the entire byte slice itself is probably\n         // a metadata file. Ideally though if necessary we could at least check\n         // the prefix of bytes to see if it's an actual metadata object and if\n         // not forward the error along here.\n-        Err(_) => return Ok(bytes),\n+        return Ok(bytes);\n     };\n     file.section_by_name(section)\n         .ok_or_else(|| format!(\"no `{}` section in '{}'\", section, path.display()))?"}, {"sha": "8191d8b5e4924e5c321ce42e3adc0382682a6a16", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -448,10 +448,7 @@ fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, S\n     let mut ret = FxHashMap::default();\n     for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n         let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n-        let module = match module {\n-            Some(s) => s,\n-            None => continue,\n-        };\n+        let Some(module) = module else { continue };\n         ret.extend(lib.foreign_items.iter().map(|id| {\n             assert_eq!(id.krate, cnum);\n             (*id, module.to_string())"}, {"sha": "ed6c156547e29f69ba60e971d86ef074f1d94289", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -409,18 +409,15 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         // listing.\n         let main_ret_ty = cx.tcx().erase_regions(main_ret_ty.no_bound_vars().unwrap());\n \n-        let llfn = match cx.declare_c_main(llfty) {\n-            Some(llfn) => llfn,\n-            None => {\n-                // FIXME: We should be smart and show a better diagnostic here.\n-                let span = cx.tcx().def_span(rust_main_def_id);\n-                cx.sess()\n-                    .struct_span_err(span, \"entry symbol `main` declared multiple times\")\n-                    .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                    .emit();\n-                cx.sess().abort_if_errors();\n-                bug!();\n-            }\n+        let Some(llfn) = cx.declare_c_main(llfty) else {\n+            // FIXME: We should be smart and show a better diagnostic here.\n+            let span = cx.tcx().def_span(rust_main_def_id);\n+            cx.sess()\n+                .struct_span_err(span, \"entry symbol `main` declared multiple times\")\n+                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n+                .emit();\n+            cx.sess().abort_if_errors();\n+            bug!();\n         };\n \n         // `main` should respect same config for frame pointer elimination as rest of code"}, {"sha": "ae54442e884a879548266ac852446bd9f2c8fe2e", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -202,11 +202,8 @@ pub fn asm_const_to_str<'tcx>(\n     const_value: ConstValue<'tcx>,\n     ty_and_layout: TyAndLayout<'tcx>,\n ) -> String {\n-    let scalar = match const_value {\n-        ConstValue::Scalar(s) => s,\n-        _ => {\n-            span_bug!(sp, \"expected Scalar for promoted asm const, but got {:#?}\", const_value)\n-        }\n+    let ConstValue::Scalar(scalar) = const_value else {\n+        span_bug!(sp, \"expected Scalar for promoted asm const, but got {:#?}\", const_value)\n     };\n     let value = scalar.assert_bits(ty_and_layout.size);\n     match ty_and_layout.ty.kind() {"}, {"sha": "479b2b05f43059362529dbd8874c7dda777837c5", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -67,9 +67,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     .map(|field| {\n                         if let Some(prim) = field.val().try_to_scalar() {\n                             let layout = bx.layout_of(field_ty);\n-                            let scalar = match layout.abi {\n-                                Abi::Scalar(x) => x,\n-                                _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n+                            let Abi::Scalar(scalar) = layout.abi else {\n+                                bug!(\"from_const: invalid ByVal layout: {:#?}\", layout);\n                             };\n                             bx.scalar_to_backend(prim, scalar, bx.immediate_backend_type(layout))\n                         } else {"}, {"sha": "bb53c722a244a2d3a5ba8c596744d4e45ac8adb2", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -258,14 +258,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let vars = vars.iter().copied().chain(fallback_var);\n \n         for var in vars {\n-            let dbg_var = match var.dbg_var {\n-                Some(dbg_var) => dbg_var,\n-                None => continue,\n-            };\n-            let dbg_loc = match self.dbg_loc(var.source_info) {\n-                Some(dbg_loc) => dbg_loc,\n-                None => continue,\n-            };\n+            let Some(dbg_var) = var.dbg_var else { continue };\n+            let Some(dbg_loc) = self.dbg_loc(var.source_info) else { continue };\n \n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n@@ -410,10 +404,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n                 mir::VarDebugInfoContents::Const(c) => {\n                     if let Some(dbg_var) = dbg_var {\n-                        let dbg_loc = match self.dbg_loc(var.source_info) {\n-                            Some(dbg_loc) => dbg_loc,\n-                            None => continue,\n-                        };\n+                        let Some(dbg_loc) = self.dbg_loc(var.source_info) else { continue };\n \n                         if let Ok(operand) = self.eval_mir_constant_to_operand(bx, &c) {\n                             let base = Self::spill_operand_to_stack("}, {"sha": "f15c469ae57419ca46e2a694e2857327eea13317", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -58,9 +58,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) {\n         let callee_ty = instance.ty(bx.tcx(), ty::ParamEnv::reveal_all());\n \n-        let (def_id, substs) = match *callee_ty.kind() {\n-            ty::FnDef(def_id, substs) => (def_id, substs),\n-            _ => bug!(\"expected fn item type, found {}\", callee_ty),\n+        let ty::FnDef(def_id, substs) = *callee_ty.kind() else {\n+            bug!(\"expected fn item type, found {}\", callee_ty);\n         };\n \n         let sig = callee_ty.fn_sig(bx.tcx());\n@@ -338,21 +337,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     );\n                     return;\n                 }\n-                let (_width, signed) = match int_type_width_signed(ret_ty, bx.tcx()) {\n-                    Some(pair) => pair,\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                      intrinsic:  expected basic integer type, \\\n-                                      found `{}`\",\n-                                ret_ty\n-                            ),\n-                        );\n-                        return;\n-                    }\n+                let Some((_width, signed)) = int_type_width_signed(ret_ty, bx.tcx()) else {\n+                    span_invalid_monomorphization_error(\n+                        bx.tcx().sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `float_to_int_unchecked` \\\n+                                    intrinsic:  expected basic integer type, \\\n+                                    found `{}`\",\n+                            ret_ty\n+                        ),\n+                    );\n+                    return;\n                 };\n                 if signed {\n                     bx.fptosi(args[0].immediate(), llret_ty)"}, {"sha": "adb856ef42e2fbc2303f3fc5d183f585727a8649", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -285,9 +285,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // individual LLVM function arguments.\n \n                 let arg_ty = fx.monomorphize(arg_decl.ty);\n-                let tupled_arg_tys = match arg_ty.kind() {\n-                    ty::Tuple(tys) => tys,\n-                    _ => bug!(\"spread argument isn't a tuple?!\"),\n+                let ty::Tuple(tupled_arg_tys) = arg_ty.kind() else {\n+                    bug!(\"spread argument isn't a tuple?!\");\n                 };\n \n                 let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));"}, {"sha": "66be58cf62ca03ac6abbb5778a6225e39909543f", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -78,17 +78,15 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n \n         let val = match val {\n             ConstValue::Scalar(x) => {\n-                let scalar = match layout.abi {\n-                    Abi::Scalar(x) => x,\n-                    _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout),\n+                let Abi::Scalar(scalar) = layout.abi else {\n+                    bug!(\"from_const: invalid ByVal layout: {:#?}\", layout);\n                 };\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n             ConstValue::Slice { data, start, end } => {\n-                let a_scalar = match layout.abi {\n-                    Abi::ScalarPair(a, _) => a,\n-                    _ => bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout),\n+                let Abi::ScalarPair(a_scalar, _) = layout.abi else {\n+                    bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout);\n                 };\n                 let a = Scalar::from_pointer(\n                     Pointer::new(bx.tcx().create_memory_alloc(data), Size::from_bytes(start)),\n@@ -307,9 +305,8 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n                 bx.store_with_flags(val, dest.llval, dest.align, flags);\n             }\n             OperandValue::Pair(a, b) => {\n-                let (a_scalar, b_scalar) = match dest.layout.abi {\n-                    Abi::ScalarPair(a, b) => (a, b),\n-                    _ => bug!(\"store_with_flags: invalid ScalarPair layout: {:#?}\", dest.layout),\n+                let Abi::ScalarPair(a_scalar, b_scalar) = dest.layout.abi else {\n+                    bug!(\"store_with_flags: invalid ScalarPair layout: {:#?}\", dest.layout);\n                 };\n                 let ty = bx.backend_type(dest.layout);\n                 let b_offset = a_scalar.value.size(bx).align_to(b_scalar.value.align(bx).abi);"}, {"sha": "724f92243d07ee73116b46cfd0c5c6ffa18fe68a", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -147,6 +147,10 @@ pub(crate) fn try_destructure_const<'tcx>(\n     // We go to `usize` as we cannot allocate anything bigger anyway.\n     let (field_count, variant, down) = match val.ty().kind() {\n         ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n+        // Checks if we have any variants, to avoid downcasting to a non-existing variant (when\n+        // there are no variants `read_discriminant` successfully returns a non-existing variant\n+        // index).\n+        ty::Adt(def, _) if def.variants.is_empty() => throw_ub!(Unreachable),\n         ty::Adt(def, _) => {\n             let variant = ecx.read_discriminant(&op)?.1;\n             let down = ecx.operand_downcast(&op, variant)?;"}, {"sha": "d40172a2e2fe850f070abac546eb29d200853729", "filename": "compiler/rustc_data_structures/src/binary_search_util/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -10,9 +10,8 @@ pub fn binary_search_slice<'d, E, K>(data: &'d [E], key_fn: impl Fn(&E) -> K, ke\n where\n     K: Ord,\n {\n-    let mid = match data.binary_search_by_key(key, &key_fn) {\n-        Ok(mid) => mid,\n-        Err(_) => return &[],\n+    let Ok(mid) = data.binary_search_by_key(key, &key_fn) else {\n+        return &[];\n     };\n     let size = data.len();\n "}, {"sha": "ea02a73c42204154b52644f45b731d423f0f880d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -14,6 +14,7 @@\n #![feature(control_flow_enum)]\n #![feature(core_intrinsics)]\n #![feature(extend_one)]\n+#![feature(let_else)]\n #![feature(hash_raw_entry)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]"}, {"sha": "0af571610fe9510c553551e3f599caf4affaf85e", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -190,11 +190,8 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     ///\n     /// Note that this set can, in principle, have any size.\n     pub fn minimal_upper_bounds(&self, a: &T, b: &T) -> Vec<&T> {\n-        let (mut a, mut b) = match (self.index(a), self.index(b)) {\n-            (Some(a), Some(b)) => (a, b),\n-            (None, _) | (_, None) => {\n-                return vec![];\n-            }\n+        let (Some(mut a), Some(mut b)) = (self.index(a), self.index(b)) else {\n+            return vec![];\n         };\n \n         // in some cases, there are some arbitrary choices to be made;\n@@ -294,9 +291,8 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     /// then `parents(a)` returns `[b, c]`. The `postdom_parent` function\n     /// would further reduce this to just `f`.\n     pub fn parents(&self, a: &T) -> Vec<&T> {\n-        let a = match self.index(a) {\n-            Some(a) => a,\n-            None => return vec![],\n+        let Some(a) = self.index(a) else {\n+            return vec![];\n         };\n \n         // Steal the algorithm for `minimal_upper_bounds` above, but"}, {"sha": "563ec8b0e3a70fceee51d8eabca767c1653b6d57", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(nll)]\n+#![feature(let_else)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n@@ -203,10 +204,7 @@ fn run_compiler(\n     let args = args::arg_expand_all(at_args);\n \n     let diagnostic_output = emitter.map_or(DiagnosticOutput::Default, DiagnosticOutput::Raw);\n-    let matches = match handle_options(&args) {\n-        Some(matches) => matches,\n-        None => return Ok(()),\n-    };\n+    let Some(matches) = handle_options(&args) else { return Ok(()) };\n \n     let sopts = config::build_session_options(&matches);\n "}, {"sha": "bfed9211cec346c788d6bb5d8345b7f2d08328d3", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1138,9 +1138,8 @@ impl EmitterWriter {\n     }\n \n     fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n-        let sm = match self.sm {\n-            Some(ref sm) => sm,\n-            None => return 0,\n+        let Some(ref sm) = self.sm else {\n+            return 0;\n         };\n \n         let mut max = 0;\n@@ -1590,9 +1589,8 @@ impl EmitterWriter {\n         level: &Level,\n         max_line_num_len: usize,\n     ) -> io::Result<()> {\n-        let sm = match self.sm {\n-            Some(ref sm) => sm,\n-            None => return Ok(()),\n+        let Some(ref sm) = self.sm else {\n+            return Ok(());\n         };\n \n         // Render the replacements for each suggestion"}, {"sha": "2bdf3b391261915955e7a40c4fefab2f0970bfa9", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1299,20 +1299,16 @@ pub fn parse_macro_name_and_helper_attrs(\n     // Once we've located the `#[proc_macro_derive]` attribute, verify\n     // that it's of the form `#[proc_macro_derive(Foo)]` or\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n-    let list = match attr.meta_item_list() {\n-        Some(list) => list,\n-        None => return None,\n+    let Some(list) = attr.meta_item_list() else {\n+        return None;\n     };\n     if list.len() != 1 && list.len() != 2 {\n         diag.span_err(attr.span, \"attribute must have either one or two arguments\");\n         return None;\n     }\n-    let trait_attr = match list[0].meta_item() {\n-        Some(meta_item) => meta_item,\n-        _ => {\n-            diag.span_err(list[0].span(), \"not a meta item\");\n-            return None;\n-        }\n+    let Some(trait_attr) = list[0].meta_item() else {\n+        diag.span_err(list[0].span(), \"not a meta item\");\n+        return None;\n     };\n     let trait_ident = match trait_attr.ident() {\n         Some(trait_ident) if trait_attr.is_word() => trait_ident,\n@@ -1341,12 +1337,9 @@ pub fn parse_macro_name_and_helper_attrs(\n             })\n             .iter()\n             .filter_map(|attr| {\n-                let attr = match attr.meta_item() {\n-                    Some(meta_item) => meta_item,\n-                    _ => {\n-                        diag.span_err(attr.span(), \"not a meta item\");\n-                        return None;\n-                    }\n+                let Some(attr) = attr.meta_item() else {\n+                    diag.span_err(attr.span(), \"not a meta item\");\n+                    return None;\n                 };\n \n                 let ident = match attr.ident() {"}, {"sha": "c0d7bc359bf4415ef9a79096d381996fa9dd1ed0", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -79,9 +79,8 @@ fn get_features(\n             continue;\n         }\n \n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => continue,\n+        let Some(list) = attr.meta_item_list() else {\n+            continue;\n         };\n \n         for mi in list {\n@@ -112,9 +111,8 @@ fn get_features(\n             continue;\n         }\n \n-        let list = match attr.meta_item_list() {\n-            Some(list) => list,\n-            None => continue,\n+        let Some(list) = attr.meta_item_list() else {\n+            continue;\n         };\n \n         let bad_input = |span| {\n@@ -340,10 +338,9 @@ impl<'a> StripUnconfigured<'a> {\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n     crate fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n-        let (cfg_predicate, expanded_attrs) =\n-            match rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) {\n-                None => return vec![],\n-                Some(r) => r,\n+        let Some((cfg_predicate, expanded_attrs)) =\n+            rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) else {\n+                return vec![];\n             };\n \n         // Lint on zero attributes in source.\n@@ -389,18 +386,16 @@ impl<'a> StripUnconfigured<'a> {\n         // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n         // for `attr` when we expand it to `#[attr]`\n         let mut orig_trees = orig_tokens.trees();\n-        let pound_token = match orig_trees.next().unwrap() {\n-            TokenTree::Token(token @ Token { kind: TokenKind::Pound, .. }) => token,\n-            _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n+        let TokenTree::Token(pound_token @ Token { kind: TokenKind::Pound, .. }) = orig_trees.next().unwrap() else {\n+            panic!(\"Bad tokens for attribute {:?}\", attr);\n         };\n         let pound_span = pound_token.span;\n \n         let mut trees = vec![(AttrAnnotatedTokenTree::Token(pound_token), Spacing::Alone)];\n         if attr.style == AttrStyle::Inner {\n             // For inner attributes, we do the same thing for the `!` in `#![some_attr]`\n-            let bang_token = match orig_trees.next().unwrap() {\n-                TokenTree::Token(token @ Token { kind: TokenKind::Not, .. }) => token,\n-                _ => panic!(\"Bad tokens for attribute {:?}\", attr),\n+            let TokenTree::Token(bang_token @ Token { kind: TokenKind::Not, .. }) = orig_trees.next().unwrap() else {\n+                panic!(\"Bad tokens for attribute {:?}\", attr);\n             };\n             trees.push((AttrAnnotatedTokenTree::Token(bang_token), Spacing::Alone));\n         }"}, {"sha": "bdc9c064a6f9ca8d99e79440b57e58d9cc7cc8a0", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -641,9 +641,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n-                    let tok_result = match expander.expand(self.cx, span, mac.args.inner_tokens()) {\n-                        Err(_) => return ExpandResult::Ready(fragment_kind.dummy(span)),\n-                        Ok(ts) => ts,\n+                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.inner_tokens()) else {\n+                        return ExpandResult::Ready(fragment_kind.dummy(span));\n                     };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n@@ -698,9 +697,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n                     let inner_tokens = attr_item.args.inner_tokens();\n-                    let tok_result = match expander.expand(self.cx, span, inner_tokens, tokens) {\n-                        Err(_) => return ExpandResult::Ready(fragment_kind.dummy(span)),\n-                        Ok(ts) => ts,\n+                    let Ok(tok_result) = expander.expand(self.cx, span, inner_tokens, tokens) else {\n+                        return ExpandResult::Ready(fragment_kind.dummy(span));\n                     };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &attr_item.path, span)\n                 }"}, {"sha": "aa54bdbd3a73d559fbb27ecc7a2151e341981f26", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -170,23 +170,20 @@ fn mod_file_path_from_attr(\n ) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n     let first_path = attrs.iter().find(|at| at.has_name(sym::path))?;\n-    let path_sym = match first_path.value_str() {\n-        Some(s) => s,\n-        None => {\n-            // This check is here mainly to catch attempting to use a macro,\n-            // such as #[path = concat!(...)]. This isn't currently supported\n-            // because otherwise the InvocationCollector would need to defer\n-            // loading a module until the #[path] attribute was expanded, and\n-            // it doesn't support that (and would likely add a bit of\n-            // complexity). Usually bad forms are checked in AstValidator (via\n-            // `check_builtin_attribute`), but by the time that runs the macro\n-            // is expanded, and it doesn't give an error.\n-            validate_attr::emit_fatal_malformed_builtin_attribute(\n-                &sess.parse_sess,\n-                first_path,\n-                sym::path,\n-            );\n-        }\n+    let Some(path_sym) = first_path.value_str() else {\n+        // This check is here mainly to catch attempting to use a macro,\n+        // such as #[path = concat!(...)]. This isn't currently supported\n+        // because otherwise the InvocationCollector would need to defer\n+        // loading a module until the #[path] attribute was expanded, and\n+        // it doesn't support that (and would likely add a bit of\n+        // complexity). Usually bad forms are checked in AstValidator (via\n+        // `check_builtin_attribute`), but by the time that runs the macro\n+        // is expanded, and it doesn't give an error.\n+        validate_attr::emit_fatal_malformed_builtin_attribute(\n+            &sess.parse_sess,\n+            first_path,\n+            sym::path,\n+        );\n     };\n \n     let path_str = path_sym.as_str();"}, {"sha": "99a945b1c913b155a76e992da313f138f946bb25", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -596,9 +596,8 @@ impl server::Literal for Rustc<'_, '_> {\n         let minus_present = parser.eat(&token::BinOp(token::Minus));\n \n         let lit_span = parser.token.span.data();\n-        let mut lit = match parser.token.kind {\n-            token::Literal(lit) => lit,\n-            _ => return Err(()),\n+        let token::Literal(mut lit) = parser.token.kind else {\n+            return Err(());\n         };\n \n         // Check no comment or whitespace surrounding the (possibly negative)"}, {"sha": "255e661652db97395acebc9de90e12310a4645cd", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -635,9 +635,8 @@ pub struct WhereBoundPredicate<'hir> {\n impl<'hir> WhereBoundPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: DefId) -> bool {\n-        let path = match self.bounded_ty.kind {\n-            TyKind::Path(QPath::Resolved(None, path)) => path,\n-            _ => return false,\n+        let TyKind::Path(QPath::Resolved(None, path)) = self.bounded_ty.kind else {\n+            return false;\n         };\n         match path.res {\n             Res::Def(DefKind::TyParam, def_id)"}, {"sha": "ba3eeb91fe95f8b88b3e94b474807f6ccebffa6c", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -5,6 +5,7 @@\n #![feature(associated_type_defaults)]\n #![feature(const_btree_new)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_else)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "8a4ed02f6aea16220601c3f4af2759cec8dbd966", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -368,9 +368,8 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     fn check_item(&mut self, item_id: LocalDefId, item_span: Span) {\n         let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n         for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n-            let assertion = match self.assertion_maybe(item_id, attr) {\n-                Some(a) => a,\n-                None => continue,\n+            let Some(assertion) = self.assertion_maybe(item_id, attr) else {\n+                continue;\n             };\n             self.checked_attrs.insert(attr.id);\n             for label in assertion.clean {"}, {"sha": "a6da4b0bab6834aca0b1a00ceb79c265238c8713", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -421,9 +421,8 @@ fn copy_files(sess: &Session, target_dir: &Path, source_dir: &Path) -> Result<bo\n         return Err(());\n     };\n \n-    let source_dir_iterator = match source_dir.read_dir() {\n-        Ok(it) => it,\n-        Err(_) => return Err(()),\n+    let Ok(source_dir_iterator) = source_dir.read_dir() else {\n+        return Err(());\n     };\n \n     let mut files_linked = 0;\n@@ -700,12 +699,9 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     let mut lock_files = FxHashSet::default();\n \n     for dir_entry in crate_directory.read_dir()? {\n-        let dir_entry = match dir_entry {\n-            Ok(dir_entry) => dir_entry,\n-            _ => {\n-                // Ignore any errors\n-                continue;\n-            }\n+        let Ok(dir_entry) = dir_entry else {\n+            // Ignore any errors\n+            continue;\n         };\n \n         let entry_name = dir_entry.file_name();\n@@ -740,16 +736,13 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     // be some kind of leftover\n     for (lock_file_name, directory_name) in &lock_file_to_session_dir {\n         if directory_name.is_none() {\n-            let timestamp = match extract_timestamp_from_session_dir(lock_file_name) {\n-                Ok(timestamp) => timestamp,\n-                Err(()) => {\n-                    debug!(\n-                        \"found lock-file with malformed timestamp: {}\",\n-                        crate_directory.join(&lock_file_name).display()\n-                    );\n-                    // Ignore it\n-                    continue;\n-                }\n+            let Ok(timestamp) = extract_timestamp_from_session_dir(lock_file_name) else {\n+                debug!(\n+                    \"found lock-file with malformed timestamp: {}\",\n+                    crate_directory.join(&lock_file_name).display()\n+                );\n+                // Ignore it\n+                continue;\n             };\n \n             let lock_file_path = crate_directory.join(&**lock_file_name);\n@@ -798,16 +791,13 @@ pub fn garbage_collect_session_directories(sess: &Session) -> io::Result<()> {\n     for (lock_file_name, directory_name) in &lock_file_to_session_dir {\n         debug!(\"garbage_collect_session_directories() - inspecting: {}\", directory_name);\n \n-        let timestamp = match extract_timestamp_from_session_dir(directory_name) {\n-            Ok(timestamp) => timestamp,\n-            Err(()) => {\n-                debug!(\n-                    \"found session-dir with malformed timestamp: {}\",\n-                    crate_directory.join(directory_name).display()\n-                );\n-                // Ignore it\n-                continue;\n-            }\n+        let Ok(timestamp) = extract_timestamp_from_session_dir(directory_name) else {\n+            debug!(\n+                \"found session-dir with malformed timestamp: {}\",\n+                crate_directory.join(directory_name).display()\n+            );\n+            // Ignore it\n+            continue;\n         };\n \n         if is_finalized(directory_name) {"}, {"sha": "ed504938e8aa7f6948301c5c75851a21838b47a9", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -136,12 +136,9 @@ impl<I: Idx> IntervalSet<I> {\n \n     pub fn contains(&self, needle: I) -> bool {\n         let needle = needle.index() as u32;\n-        let last = match self.map.partition_point(|r| r.0 <= needle).checked_sub(1) {\n-            Some(idx) => idx,\n-            None => {\n-                // All ranges in the map start after the new range's end\n-                return false;\n-            }\n+        let Some(last) = self.map.partition_point(|r| r.0 <= needle).checked_sub(1) else {\n+            // All ranges in the map start after the new range's end\n+            return false;\n         };\n         let (_, prev_end) = &self.map[last];\n         needle <= *prev_end\n@@ -170,12 +167,9 @@ impl<I: Idx> IntervalSet<I> {\n         if start > end {\n             return None;\n         }\n-        let last = match self.map.partition_point(|r| r.0 <= end).checked_sub(1) {\n-            Some(idx) => idx,\n-            None => {\n-                // All ranges in the map start after the new range's end\n-                return None;\n-            }\n+        let Some(last) = self.map.partition_point(|r| r.0 <= end).checked_sub(1) else {\n+            // All ranges in the map start after the new range's end\n+            return None;\n         };\n         let (_, prev_end) = &self.map[last];\n         if start <= *prev_end { Some(I::new(std::cmp::min(*prev_end, end) as usize)) } else { None }"}, {"sha": "2bc2f78261df32b749128fe8017370ebd76cc8d6", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -18,30 +18,26 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let error = self.error.as_ref()?;\n         debug!(\"try_report_mismatched_static_lifetime {:?}\", error);\n \n-        let (origin, sub, sup) = match error.clone() {\n-            RegionResolutionError::ConcreteFailure(origin, sub, sup) => (origin, sub, sup),\n-            _ => return None,\n+        let RegionResolutionError::ConcreteFailure(origin, sub, sup) = error.clone() else {\n+            return None;\n         };\n         if !sub.is_static() {\n             return None;\n         }\n-        let cause = match origin {\n-            SubregionOrigin::Subtype(box TypeTrace { ref cause, .. }) => cause,\n-            _ => return None,\n+        let SubregionOrigin::Subtype(box TypeTrace { ref cause, .. }) = origin else {\n+            return None;\n         };\n         // If we added a \"points at argument expression\" obligation, we remove it here, we care\n         // about the original obligation only.\n         let code = match cause.code() {\n             ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => &*parent_code,\n             _ => cause.code(),\n         };\n-        let (parent, impl_def_id) = match code {\n-            ObligationCauseCode::MatchImpl(parent, impl_def_id) => (parent, impl_def_id),\n-            _ => return None,\n+        let ObligationCauseCode::MatchImpl(parent, impl_def_id) = code else {\n+            return None;\n         };\n-        let binding_span = match *parent.code() {\n-            ObligationCauseCode::BindingObligation(_def_id, binding_span) => binding_span,\n-            _ => return None,\n+        let ObligationCauseCode::BindingObligation(_def_id, binding_span) = *parent.code() else {\n+            return None;\n         };\n         let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n         // FIXME: we should point at the lifetime\n@@ -55,12 +51,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             // be as helpful as possible with implicit lifetimes.\n \n             // First, let's get the hir self type of the impl\n-            let impl_self_ty = match impl_node {\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                    ..\n-                }) => self_ty,\n-                _ => bug!(\"Node not an impl.\"),\n+            let hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { self_ty: impl_self_ty, .. }),\n+                ..\n+            }) = impl_node else {\n+                bug!(\"Node not an impl.\");\n             };\n \n             // Next, let's figure out the set of trait objects with implict static bounds"}, {"sha": "8601180842cccc16f155f89d1c8de77cf91ea30d", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -490,26 +490,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let tcx = self.tcx();\n \n         // Find the method being called.\n-        let instance = match ty::Instance::resolve(\n+        let Ok(Some(instance)) = ty::Instance::resolve(\n             tcx,\n             ctxt.param_env,\n             ctxt.assoc_item.def_id,\n             self.infcx.resolve_vars_if_possible(ctxt.substs),\n-        ) {\n-            Ok(Some(instance)) => instance,\n-            _ => return false,\n+        ) else {\n+            return false;\n         };\n \n         let mut v = TraitObjectVisitor(FxHashSet::default());\n         v.visit_ty(ty);\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n-        let (ident, self_ty) =\n-            match self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) {\n-                Some((ident, self_ty)) => (ident, self_ty),\n-                None => return false,\n-            };\n+        let Some((ident, self_ty)) = self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) else {\n+            return false;\n+        };\n \n         // Find the trait object types in the argument, so we point at *only* the trait object.\n         self.suggest_constrain_dyn_trait_in_impl(err, &v.0, ident, self_ty)"}, {"sha": "c7b4a96fb785301498eaf36529cc304677284046", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -263,9 +263,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         while let Some(vid) = changes.pop() {\n             constraints[vid].retain(|&(a_vid, b_vid)| {\n-                let a_region = match *var_values.value(a_vid) {\n-                    VarValue::ErrorValue => return false,\n-                    VarValue::Value(a_region) => a_region,\n+                let VarValue::Value(a_region) = *var_values.value(a_vid) else {\n+                    return false;\n                 };\n                 let b_data = var_values.value_mut(b_vid);\n                 if self.expand_node(a_region, b_vid, b_data) {\n@@ -485,9 +484,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     let a_data = var_data.value_mut(a_vid);\n                     debug!(\"contraction: {:?} == {:?}, {:?}\", a_vid, a_data, b_region);\n \n-                    let a_region = match *a_data {\n-                        VarValue::ErrorValue => continue,\n-                        VarValue::Value(a_region) => a_region,\n+                    let VarValue::Value(a_region) = *a_data else {\n+                        continue;\n                     };\n \n                     // Do not report these errors immediately:"}, {"sha": "4af69f7cd2ee6825bf4b1731880bb8f88c0266fd", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -259,10 +259,7 @@ impl<'tcx> Queries<'tcx> {\n     /// to write UI tests that actually test that compilation succeeds without reporting\n     /// an error.\n     fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n-        let def_id = match tcx.entry_fn(()) {\n-            Some((def_id, _)) => def_id,\n-            _ => return,\n-        };\n+        let Some((def_id, _)) = tcx.entry_fn(()) else { return };\n \n         let attrs = &*tcx.get_attrs(def_id);\n         let attrs = attrs.iter().filter(|attr| attr.has_name(sym::rustc_error));"}, {"sha": "83b54810db2f2f44a34eb03d67745933eb6dc2b9", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -430,10 +430,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n     ];\n     for entry in d.filter_map(|e| e.ok()) {\n         let path = entry.path();\n-        let filename = match path.file_name().and_then(|s| s.to_str()) {\n-            Some(s) => s,\n-            None => continue,\n-        };\n+        let Some(filename) = path.file_name().and_then(|s| s.to_str()) else { continue };\n         if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n             continue;\n         }"}, {"sha": "e9996a7ef14dfe5c6aa32c0db833d0ed1f0116be", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -278,9 +278,8 @@ impl LintStore {\n     /// This lint has been renamed; warn about using the new name and apply the lint.\n     #[track_caller]\n     pub fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n-        let target = match self.by_name.get(new_name) {\n-            Some(&Id(lint_id)) => lint_id,\n-            _ => bug!(\"invalid lint renaming of {} to {}\", old_name, new_name),\n+        let Some(&Id(target)) = self.by_name.get(new_name) else {\n+            bug!(\"invalid lint renaming of {} to {}\", old_name, new_name);\n         };\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n     }"}, {"sha": "5078c240ec753b635e13a1e87916e81334c68b12", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -23,10 +23,7 @@ declare_lint_pass!(DefaultHashTypes => [DEFAULT_HASH_TYPES]);\n \n impl LateLintPass<'_> for DefaultHashTypes {\n     fn check_path(&mut self, cx: &LateContext<'_>, path: &Path<'_>, hir_id: HirId) {\n-        let def_id = match path.res {\n-            Res::Def(rustc_hir::def::DefKind::Struct, id) => id,\n-            _ => return,\n-        };\n+        let Res::Def(rustc_hir::def::DefKind::Struct, def_id) = path.res else { return };\n         if matches!(cx.tcx.hir().get(hir_id), Node::Item(Item { kind: ItemKind::Use(..), .. })) {\n             // don't lint imports, only actual usages\n             return;"}, {"sha": "35c7d885e1d74a7fdc9bb4a106f016f438366d05", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -95,9 +95,9 @@ impl<'s> LintLevelsBuilder<'s> {\n             let orig_level = level;\n             let lint_flag_val = Symbol::intern(lint_name);\n \n-            let ids = match store.find_lints(&lint_name) {\n-                Ok(ids) => ids,\n-                Err(_) => continue, // errors handled in check_lint_name_cmdline above\n+            let Ok(ids) = store.find_lints(&lint_name) else {\n+                // errors handled in check_lint_name_cmdline above\n+                continue\n             };\n             for id in ids {\n                 // ForceWarn and Forbid cannot be overriden"}, {"sha": "264a80339ccdb087a667a20ede61303bbc2a184c", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -301,10 +301,7 @@ impl EarlyLintPass for NonAsciiIdents {\n                     BTreeMap::new();\n \n                 'outerloop: for (augment_script_set, usage) in script_states {\n-                    let (mut ch_list, sp) = match usage {\n-                        ScriptSetUsage::Verified => continue,\n-                        ScriptSetUsage::Suspicious(ch_list, sp) => (ch_list, sp),\n-                    };\n+                    let ScriptSetUsage::Suspicious(mut ch_list, sp) = usage else { continue };\n \n                     if augment_script_set.is_all() {\n                         continue;"}, {"sha": "5cd3791583f9a166d3b870a03ed95350c553429e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1331,14 +1331,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n             let t = cx.tcx.type_of(it.def_id);\n             let ty = cx.tcx.erase_regions(t);\n-            let layout = match cx.layout_of(ty) {\n-                Ok(layout) => layout,\n-                Err(\n-                    ty::layout::LayoutError::Unknown(_)\n-                    | ty::layout::LayoutError::SizeOverflow(_)\n-                    | ty::layout::LayoutError::NormalizationFailure(_, _),\n-                ) => return,\n-            };\n+            let Ok(layout) = cx.layout_of(ty) else { return };\n             let Variants::Multiple {\n                     tag_encoding: TagEncoding::Direct, tag, ref variants, ..\n                 } = &layout.variants else {"}, {"sha": "7343f1465f603c23b99b5caee4755a1ab4824db7", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -475,9 +475,8 @@ impl<'a> CrateLoader<'a> {\n         locator.triple = TargetTriple::from_triple(config::host_triple());\n         locator.filesearch = self.sess.host_filesearch(path_kind);\n \n-        let host_result = match self.load(locator)? {\n-            Some(host_result) => host_result,\n-            None => return Ok(None),\n+        let Some(host_result) = self.load(locator)? else {\n+            return Ok(None);\n         };\n \n         Ok(Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n@@ -574,9 +573,8 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn load(&self, locator: &mut CrateLocator<'_>) -> Result<Option<LoadResult>, CrateError> {\n-        let library = match locator.maybe_load_library_crate()? {\n-            Some(library) => library,\n-            None => return Ok(None),\n+        let Some(library) = locator.maybe_load_library_crate()? else {\n+            return Ok(None);\n         };\n \n         // In the case that we're loading a crate, but not matching"}, {"sha": "c4ee1e191286d4aae12211f20aadd072578b0ee0", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -15,9 +15,8 @@ struct Collector {\n \n impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let items = match it.kind {\n-            hir::ItemKind::ForeignMod { items, .. } => items,\n-            _ => return,\n+        let hir::ItemKind::ForeignMod { items, .. } = it.kind else {\n+            return;\n         };\n \n         let foreign_items = items.iter().map(|it| it.id.def_id.to_def_id()).collect();"}, {"sha": "2204b44e3a10d303d1d262b59c2df95a000e85a7", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -690,14 +690,11 @@ impl<'a> CrateLocator<'a> {\n                     loc.original().clone(),\n                 ));\n             }\n-            let file = match loc.original().file_name().and_then(|s| s.to_str()) {\n-                Some(file) => file,\n-                None => {\n-                    return Err(CrateError::ExternLocationNotFile(\n-                        self.crate_name,\n-                        loc.original().clone(),\n-                    ));\n-                }\n+            let Some(file) = loc.original().file_name().and_then(|s| s.to_str()) else {\n+                return Err(CrateError::ExternLocationNotFile(\n+                    self.crate_name,\n+                    loc.original().clone(),\n+                ));\n             };\n \n             if file.starts_with(\"lib\") && (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\"))"}, {"sha": "0f10c269a04a341aaf0fe5557b9f4893ed11c865", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -33,9 +33,8 @@ struct Collector<'tcx> {\n \n impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let (abi, foreign_mod_items) = match it.kind {\n-            hir::ItemKind::ForeignMod { abi, items } => (abi, items),\n-            _ => return,\n+        let hir::ItemKind::ForeignMod { abi, items: foreign_mod_items } = it.kind else {\n+            return;\n         };\n \n         if abi == Abi::Rust || abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n@@ -45,9 +44,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         // Process all of the #[link(..)]-style arguments\n         let sess = &self.tcx.sess;\n         for m in self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| a.has_name(sym::link)) {\n-            let items = match m.meta_item_list() {\n-                Some(item) => item,\n-                None => continue,\n+            let Some(items) = m.meta_item_list() else {\n+                continue;\n             };\n             let mut lib = NativeLib {\n                 name: None,\n@@ -63,9 +61,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n             for item in items.iter() {\n                 if item.has_name(sym::kind) {\n                     kind_specified = true;\n-                    let kind = match item.value_str() {\n-                        Some(name) => name,\n-                        None => continue, // skip like historical compilers\n+                    let Some(kind) = item.value_str() else {\n+                        continue; // skip like historical compilers\n                     };\n                     lib.kind = match kind.as_str() {\n                         \"static\" => NativeLibKind::Static { bundle: None, whole_archive: None },\n@@ -101,9 +98,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                 } else if item.has_name(sym::name) {\n                     lib.name = item.value_str();\n                 } else if item.has_name(sym::cfg) {\n-                    let cfg = match item.meta_item_list() {\n-                        Some(list) => list,\n-                        None => continue, // skip like historical compilers\n+                    let Some(cfg) = item.meta_item_list() else {\n+                        continue; // skip like historical compilers\n                     };\n                     if cfg.is_empty() {\n                         sess.span_err(item.span(), \"`cfg()` must have an argument\");\n@@ -262,11 +258,8 @@ impl Collector<'_> {\n         }\n         // this just unwraps lib.name; we already established that it isn't empty above.\n         if let (NativeLibKind::RawDylib, Some(lib_name)) = (lib.kind, lib.name) {\n-            let span = match span {\n-                Some(s) => s,\n-                None => {\n-                    bug!(\"raw-dylib libraries are not supported on the command line\");\n-                }\n+            let Some(span) = span else {\n+                bug!(\"raw-dylib libraries are not supported on the command line\");\n             };\n \n             if !self.tcx.sess.target.options.is_like_windows {"}, {"sha": "ce61fd20a7b1e7d825cdd8e988c23ae558a737d9", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -249,9 +249,8 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 .iter()\n                 .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n                 .find(|lib| {\n-                    let fm_id = match lib.foreign_module {\n-                        Some(id) => id,\n-                        None => return false,\n+                    let Some(fm_id) = lib.foreign_module else {\n+                        return false;\n                     };\n                     let map = tcx.foreign_modules(id.krate);\n                     map.get(&fm_id)"}, {"sha": "6124d1407026693a5755cb855478b526e11fd0ae", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -173,9 +173,8 @@ impl Scope {\n     /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> Span {\n-        let hir_id = match self.hir_id(scope_tree) {\n-            Some(hir_id) => hir_id,\n-            None => return DUMMY_SP,\n+        let Some(hir_id) = self.hir_id(scope_tree) else {\n+            return DUMMY_SP;\n         };\n         let span = tcx.hir().span(hir_id);\n         if let ScopeData::Remainder(first_statement_index) = self.data {"}, {"sha": "aa8730bf9cddec6b4a12a4008cc4244a78d8106e", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -456,6 +456,11 @@ impl<'tcx, Tag: Provenance> Scalar<Tag> {\n         // Going through `u64` to check size and truncation.\n         Ok(Double::from_bits(self.to_u64()?.into()))\n     }\n+\n+    // FIXME: Replace current `impl Display for Scalar` with `impl LowerHex`.\n+    pub fn rustdoc_display(&self) -> String {\n+        if let Scalar::Int(int) = self { int.to_string() } else { self.to_string() }\n+    }\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]"}, {"sha": "5642d01de5d83a78a42cb13b60c397d5b56e72d9", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1841,6 +1841,15 @@ static_assert_size!(PlaceElem<'_>, 24);\n pub type ProjectionKind = ProjectionElem<(), ()>;\n \n rustc_index::newtype_index! {\n+    /// A [newtype'd][wrapper] index type in the MIR [control-flow graph][CFG]\n+    ///\n+    /// A field (e.g., `f` in `_1.f`) is one variant of [`ProjectionElem`]. Conceptually,\n+    /// rustc can identify that a field projection refers to either two different regions of memory\n+    /// or the same one between the base and the 'projection element'.\n+    /// Read more about projections in the [rustc-dev-guide][mir-datatypes]\n+    /// [wrapper]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html#newtype\n+    /// [CFG]: https://rustc-dev-guide.rust-lang.org/appendix/background.html#cfg\n+    /// [mir-datatypes]: https://rustc-dev-guide.rust-lang.org/mir/index.html#mir-data-types\n     pub struct Field {\n         derive [HashStable]\n         DEBUG_FORMAT = \"field[{}]\""}, {"sha": "7894c7fec440545cbbe604ff93942052aaf167db", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -89,9 +89,8 @@ pub fn dump_mir<'tcx, F>(\n }\n \n pub fn dump_enabled<'tcx>(tcx: TyCtxt<'tcx>, pass_name: &str, def_id: DefId) -> bool {\n-    let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n-        None => return false,\n-        Some(ref filters) => filters,\n+    let Some(ref filters) = tcx.sess.opts.debugging_opts.dump_mir else {\n+        return false;\n     };\n     let node_path = ty::print::with_forced_impl_filename_line(|| {\n         // see notes on #41697 below\n@@ -586,9 +585,8 @@ fn write_scope_tree(\n         )?;\n     }\n \n-    let children = match scope_tree.get(&parent) {\n-        Some(children) => children,\n-        None => return Ok(()),\n+    let Some(children) = scope_tree.get(&parent) else {\n+        return Ok(());\n     };\n \n     for &child in children {"}, {"sha": "be86f1e92744ee7b07d278e394469107798deb78", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1,3 +1,9 @@\n+//! Defines the various compiler queries.\n+//!\n+//! For more information on the query system, see\n+//! [\"Queries: demand-driven compilation\"](https://rustc-dev-guide.rust-lang.org/query.html).\n+//! This chapter includes instructions for adding new queries.\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way"}, {"sha": "72623ba54eeb46f97170e7d58c3202c9704d0d80", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -384,3 +384,10 @@ impl fmt::UpperHex for ScalarInt {\n         write!(f, \"{:01$X}\", { self.data }, self.size as usize * 2)\n     }\n }\n+\n+impl fmt::Display for ScalarInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.check_data();\n+        write!(f, \"{}\", { self.data })\n+    }\n+}"}, {"sha": "bb8566ea4df37829edd284ff977b2ab3731310c9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1123,9 +1123,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n         let attrs = self.get_attrs(def_id);\n         let get = |name| {\n-            let attr = match attrs.iter().find(|a| a.has_name(name)) {\n-                Some(attr) => attr,\n-                None => return Bound::Unbounded,\n+            let Some(attr) = attrs.iter().find(|a| a.has_name(name)) else {\n+                return Bound::Unbounded;\n             };\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);\n             if let Some(\n@@ -1513,9 +1512,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         scope_def_id: LocalDefId,\n     ) -> Vec<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n-        let hir_output = match self.hir().fn_decl_by_hir_id(hir_id) {\n-            Some(hir::FnDecl { output: hir::FnRetTy::Return(ty), .. }) => ty,\n-            _ => return vec![],\n+        let Some(hir::FnDecl { output: hir::FnRetTy::Return(hir_output), .. }) = self.hir().fn_decl_by_hir_id(hir_id) else {\n+            return vec![];\n         };\n \n         let mut v = TraitObjectVisitor(vec![], self.hir());"}, {"sha": "5ceabf99eda9629a6299ff66d09aaa5272805225", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -861,11 +861,10 @@ fn foo(&self) -> Self::T { String::new() }\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        let hir_id =\n-            match body_owner_def_id.as_local().map(|id| self.hir().local_def_id_to_hir_id(id)) {\n-                Some(hir_id) => hir_id,\n-                None => return false,\n-            };\n+        let Some(hir_id) = body_owner_def_id.as_local() else {\n+            return false;\n+        };\n+        let hir_id = self.hir().local_def_id_to_hir_id(hir_id);\n         // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n         // `expected` and point at it.\n         let parent_id = self.hir().get_parent_item(hir_id);"}, {"sha": "4996a13bd8c6c64ba19b5874a13e37839f766d1f", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1319,9 +1319,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n                     for (field_layouts, layout_variant) in iter::zip(&variants, &layout_variants) {\n-                        let offsets = match layout_variant.fields {\n-                            FieldsShape::Arbitrary { ref offsets, .. } => offsets,\n-                            _ => bug!(),\n+                        let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n+                            bug!();\n                         };\n                         let mut fields =\n                             iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n@@ -1571,9 +1570,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let tcx = self.tcx;\n         let subst_field = |ty: Ty<'tcx>| ty.subst(tcx, substs);\n \n-        let info = match tcx.generator_layout(def_id) {\n-            None => return Err(LayoutError::Unknown(ty)),\n-            Some(info) => info,\n+        let Some(info) = tcx.generator_layout(def_id) else {\n+            return Err(LayoutError::Unknown(ty));\n         };\n         let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&info);\n \n@@ -1676,9 +1674,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 )?;\n                 variant.variants = Variants::Single { index };\n \n-                let (offsets, memory_index) = match variant.fields {\n-                    FieldsShape::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n-                    _ => bug!(),\n+                let FieldsShape::Arbitrary { offsets, memory_index } = variant.fields else {\n+                    bug!();\n                 };\n \n                 // Now, stitch the promoted and variant-only fields back together in"}, {"sha": "fbf30b58818f31b9a73a1e2f2b086a3d3de51db5", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -415,9 +415,8 @@ pub trait PrettyPrinter<'tcx>:\n             cur_def_key = self.tcx().def_key(parent);\n         }\n \n-        let visible_parent = match visible_parent_map.get(&def_id).cloned() {\n-            Some(parent) => parent,\n-            None => return Ok((self, false)),\n+        let Some(visible_parent) = visible_parent_map.get(&def_id).cloned() else {\n+            return Ok((self, false));\n         };\n \n         let actual_parent = self.tcx().parent(def_id);"}, {"sha": "da9c4b930df47a4854a26d5bff363c60563675a6", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -126,11 +126,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &Candidate<'pat, 'tcx>,\n         variants: &mut BitSet<VariantIdx>,\n     ) -> bool {\n-        let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n-            Some(match_pair) => match_pair,\n-            _ => {\n-                return false;\n-            }\n+        let Some(match_pair) = candidate.match_pairs.iter().find(|mp| mp.place == *test_place) else {\n+            return false;\n         };\n \n         match *match_pair.pattern.kind {\n@@ -421,9 +418,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let deref_ty = match *ty.kind() {\n-            ty::Ref(_, deref_ty, _) => deref_ty,\n-            _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n+        let ty::Ref(_, deref_ty, _) = *ty.kind() else {\n+            bug!(\"non_scalar_compare called on non-reference type: {}\", ty);\n         };\n \n         let eq_def_id = self.tcx.require_lang_item(LangItem::PartialEq, None);"}, {"sha": "f2f85043df2929181e5cbd77381d76cfdc67e7dd", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -266,9 +266,8 @@ fn liberated_closure_env_ty(\n ) -> Ty<'_> {\n     let closure_ty = tcx.typeck_body(body_id).node_type(closure_expr_id);\n \n-    let (closure_def_id, closure_substs) = match *closure_ty.kind() {\n-        ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n-        _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty),\n+    let ty::Closure(closure_def_id, closure_substs) = *closure_ty.kind() else {\n+        bug!(\"closure expr does not have closure type: {:?}\", closure_ty);\n     };\n \n     let bound_vars ="}, {"sha": "72c0985a63c33144342ed861e6c354d026a8e1c5", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -62,10 +62,7 @@ fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Option<ConstVa\n     use rustc_apfloat::ieee::{Double, Single};\n     let scalar = match fty {\n         ty::FloatTy::F32 => {\n-            let rust_f = match num.parse::<f32>() {\n-                Ok(f) => f,\n-                Err(_) => return None,\n-            };\n+            let Ok(rust_f) = num.parse::<f32>() else { return None };\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n             });\n@@ -85,10 +82,7 @@ fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Option<ConstVa\n             Scalar::from_f32(f)\n         }\n         ty::FloatTy::F64 => {\n-            let rust_f = match num.parse::<f64>() {\n-                Ok(f) => f,\n-                Err(_) => return None,\n-            };\n+            let Ok(rust_f) = num.parse::<f64>() else { return None };\n             let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)\n             });"}, {"sha": "5a7e1d88dd03f9d8cb2084497fe86edb30c80a6e", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -503,13 +503,12 @@ impl<'tcx> Cx<'tcx> {\n                                 InlineAsmOperand::Const { value, span }\n                             }\n                             hir::InlineAsmOperand::Sym { ref expr } => {\n-                                let qpath = match expr.kind {\n-                                    hir::ExprKind::Path(ref qpath) => qpath,\n-                                    _ => span_bug!(\n+                                let hir::ExprKind::Path(ref qpath) = expr.kind else {\n+                                    span_bug!(\n                                         expr.span,\n                                         \"asm `sym` operand should be a path, found {:?}\",\n                                         expr.kind\n-                                    ),\n+                                    );\n                                 };\n                                 let temp_lifetime =\n                                     self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n@@ -577,9 +576,8 @@ impl<'tcx> Cx<'tcx> {\n             // Now comes the rote stuff:\n             hir::ExprKind::Repeat(ref v, _) => {\n                 let ty = self.typeck_results().expr_ty(expr);\n-                let count = match ty.kind() {\n-                    ty::Array(_, ct) => ct,\n-                    _ => span_bug!(expr.span, \"unexpected repeat expr ty: {:?}\", ty),\n+                let ty::Array(_, count) = ty.kind() else {\n+                    span_bug!(expr.span, \"unexpected repeat expr ty: {:?}\", ty);\n                 };\n \n                 ExprKind::Repeat { value: self.mirror_expr(v), count: *count }\n@@ -1007,9 +1005,8 @@ impl<'tcx> Cx<'tcx> {\n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n         // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-        let (region, mutbl) = match *self.thir[args[0]].ty.kind() {\n-            ty::Ref(region, _, mutbl) => (region, mutbl),\n-            _ => span_bug!(span, \"overloaded_place: receiver is not a reference\"),\n+        let ty::Ref(region, _, mutbl) = *self.thir[args[0]].ty.kind() else {\n+            span_bug!(span, \"overloaded_place: receiver is not a reference\");\n         };\n         let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n "}, {"sha": "1d31516e2463c7658fd7685e6d6609293ef30899", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -560,9 +560,9 @@ impl SplitVarLenSlice {\n \n     /// Pass a set of slices relative to which to split this one.\n     fn split(&mut self, slices: impl Iterator<Item = SliceKind>) {\n-        let (max_prefix_len, max_suffix_len) = match &mut self.max_slice {\n-            VarLen(prefix, suffix) => (prefix, suffix),\n-            FixedLen(_) => return, // No need to split\n+        let VarLen(max_prefix_len, max_suffix_len) = &mut self.max_slice else {\n+            // No need to split\n+            return;\n         };\n         // We grow `self.max_slice` to be larger than all slices encountered, as described above.\n         // For diagnostics, we keep the prefix and suffix lengths separate, but grow them so that\n@@ -1181,10 +1181,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         ty: Ty<'tcx>,\n         variant: &'a VariantDef,\n     ) -> impl Iterator<Item = (Field, Ty<'tcx>)> + Captures<'a> + Captures<'p> {\n-        let (adt, substs) = match ty.kind() {\n-            ty::Adt(adt, substs) => (adt, substs),\n-            _ => bug!(),\n-        };\n+        let ty::Adt(adt, substs) = ty.kind() else { bug!() };\n         // Whether we must not match the fields of this variant exhaustively.\n         let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n \n@@ -1578,9 +1575,8 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 match self_slice.kind {\n                     FixedLen(_) => bug!(\"{:?} doesn't cover {:?}\", self_slice, other_slice),\n                     VarLen(prefix, suffix) => {\n-                        let inner_ty = match *self.ty.kind() {\n-                            ty::Slice(ty) | ty::Array(ty, _) => ty,\n-                            _ => bug!(\"bad slice pattern {:?} {:?}\", self.ctor, self.ty),\n+                        let (ty::Slice(inner_ty) | ty::Array(inner_ty, _)) = *self.ty.kind() else {\n+                            bug!(\"bad slice pattern {:?} {:?}\", self.ctor, self.ty);\n                         };\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];"}, {"sha": "0c1daa519ab7c1b0c6d174fc6e28d3a4396a7b06", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -245,9 +245,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::Tuple(ref pats, ddpos) => {\n-                let tys = match ty.kind() {\n-                    ty::Tuple(ref tys) => tys,\n-                    _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n+                let ty::Tuple(ref tys) = ty.kind() else {\n+                    span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty);\n                 };\n                 let subpatterns = self.lower_tuple_subpats(pats, tys.len(), ddpos);\n                 PatKind::Leaf { subpatterns }\n@@ -294,9 +293,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n             hir::PatKind::TupleStruct(ref qpath, ref pats, ddpos) => {\n                 let res = self.typeck_results.qpath_res(qpath, pat.hir_id);\n-                let adt_def = match ty.kind() {\n-                    ty::Adt(adt_def, _) => adt_def,\n-                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT {:?}\", ty),\n+                let ty::Adt(adt_def, _) = ty.kind() else {\n+                    span_bug!(pat.span, \"tuple struct pattern not applied to an ADT {:?}\", ty);\n                 };\n                 let variant_def = adt_def.variant_of_res(res);\n                 let subpatterns = self.lower_tuple_subpats(pats, variant_def.fields.len(), ddpos);\n@@ -576,9 +574,8 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n             hir::ExprKind::Lit(ref lit) => (lit, false),\n             hir::ExprKind::Unary(hir::UnOp::Neg, ref expr) => {\n-                let lit = match expr.kind {\n-                    hir::ExprKind::Lit(ref lit) => lit,\n-                    _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+                let hir::ExprKind::Lit(ref lit) = expr.kind else {\n+                    span_bug!(expr.span, \"not a literal: {:?}\", expr);\n                 };\n                 (lit, true)\n             }"}, {"sha": "f102872cd2d064abeda1d758bde420d5b25d6c38", "filename": "compiler/rustc_mir_dataflow/src/drop_flag_effects.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fdrop_flag_effects.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -243,9 +243,8 @@ pub(crate) fn on_all_inactive_variants<'tcx>(\n     active_variant: VariantIdx,\n     mut handle_inactive_variant: impl FnMut(MovePathIndex),\n ) {\n-    let enum_mpi = match move_data.rev_lookup.find(enum_place.as_ref()) {\n-        LookupResult::Exact(mpi) => mpi,\n-        LookupResult::Parent(_) => return,\n+    let LookupResult::Exact(enum_mpi) = move_data.rev_lookup.find(enum_place.as_ref()) else {\n+        return;\n     };\n \n     let enum_path = &move_data.move_paths[enum_mpi];\n@@ -256,9 +255,8 @@ pub(crate) fn on_all_inactive_variants<'tcx>(\n         let (downcast, base_proj) = variant_path.place.projection.split_last().unwrap();\n         assert_eq!(enum_place.projection.len(), base_proj.len());\n \n-        let variant_idx = match *downcast {\n-            mir::ProjectionElem::Downcast(_, idx) => idx,\n-            _ => unreachable!(),\n+        let mir::ProjectionElem::Downcast(_, variant_idx) = *downcast else {\n+            unreachable!();\n         };\n \n         if variant_idx != active_variant {"}, {"sha": "e20358ba9896dd181bc0e6f7080c410066fc8894", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -274,11 +274,9 @@ where\n     use std::io::{self, Write};\n \n     let def_id = body.source.def_id();\n-    let attrs = match RustcMirAttrs::parse(tcx, def_id) {\n-        Ok(attrs) => attrs,\n-\n+    let Ok(attrs) = RustcMirAttrs::parse(tcx, def_id) else {\n         // Invalid `rustc_mir` attrs are reported in `RustcMirAttrs::parse`\n-        Err(()) => return Ok(()),\n+        return Ok(());\n     };\n \n     let mut file = match attrs.output_path(A::NAME) {"}, {"sha": "599b4087c78e4b94f5e20d7d0b615e397d86a4bd", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -628,9 +628,8 @@ where\n         ret\n     });\n \n-    let mut html_diff = match html_diff {\n-        Cow::Borrowed(_) => return raw_diff,\n-        Cow::Owned(s) => s,\n+    let Cow::Owned(mut html_diff) = html_diff else {\n+        return raw_diff;\n     };\n \n     if inside_font_tag {"}, {"sha": "63d935db8ca13f95298c7ff63bbdd3acddafce0d", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -385,16 +385,14 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeInitializedPlaces<'_, 'tcx> {\n             switch_on_enum_discriminant(self.tcx, &self.body, &self.body[block], discr)\n         });\n \n-        let (enum_place, enum_def) = match enum_ {\n-            Some(x) => x,\n-            None => return,\n+        let Some((enum_place, enum_def)) = enum_ else {\n+            return;\n         };\n \n         let mut discriminants = enum_def.discriminants(self.tcx);\n         edge_effects.apply(|trans, edge| {\n-            let value = match edge.value {\n-                Some(x) => x,\n-                None => return,\n+            let Some(value) = edge.value else {\n+                return;\n             };\n \n             // MIR building adds discriminants to the `values` array in the same order as they\n@@ -507,16 +505,14 @@ impl<'tcx> GenKillAnalysis<'tcx> for MaybeUninitializedPlaces<'_, 'tcx> {\n             switch_on_enum_discriminant(self.tcx, &self.body, &self.body[block], discr)\n         });\n \n-        let (enum_place, enum_def) = match enum_ {\n-            Some(x) => x,\n-            None => return,\n+        let Some((enum_place, enum_def)) = enum_ else {\n+            return;\n         };\n \n         let mut discriminants = enum_def.discriminants(self.tcx);\n         edge_effects.apply(|trans, edge| {\n-            let value = match edge.value {\n-                Some(x) => x,\n-                None => return,\n+            let Some(value) = edge.value else {\n+                return;\n             };\n \n             // MIR building adds discriminants to the `values` array in the same order as they"}, {"sha": "757dc093755847e89ffadf68b641efb43d39f2b8", "filename": "compiler/rustc_mir_transform/src/abort_unwinding_calls.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fabort_unwinding_calls.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -66,10 +66,7 @@ impl<'tcx> MirPass<'tcx> for AbortUnwindingCalls {\n             if block.is_cleanup {\n                 continue;\n             }\n-            let terminator = match &block.terminator {\n-                Some(terminator) => terminator,\n-                None => continue,\n-            };\n+            let Some(terminator) = &block.terminator else { continue };\n             let span = terminator.source_info.span;\n \n             let call_can_unwind = match &terminator.kind {"}, {"sha": "8de0aad041cc3f261fb295a8aedb56bc19fc67f4", "filename": "compiler/rustc_mir_transform/src/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_moves_for_packed_drops.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -84,9 +84,8 @@ fn add_move_for_packed_drop<'tcx>(\n     is_cleanup: bool,\n ) {\n     debug!(\"add_move_for_packed_drop({:?} @ {:?})\", terminator, loc);\n-    let (place, target, unwind) = match terminator.kind {\n-        TerminatorKind::Drop { ref place, target, unwind } => (place, target, unwind),\n-        _ => unreachable!(),\n+    let TerminatorKind::Drop { ref place, target, unwind } = terminator.kind else {\n+        unreachable!();\n     };\n \n     let source_info = terminator.source_info;"}, {"sha": "704f0901b95909723edcea3ad196b28a768b810c", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -410,12 +410,9 @@ fn check_unused_unsafe(\n ) {\n     let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().local_def_id_to_hir_id(def_id));\n \n-    let body_id = match body_id {\n-        Some(body) => body,\n-        None => {\n-            debug!(\"check_unused_unsafe({:?}) - no body found\", def_id);\n-            return;\n-        }\n+    let Some(body_id) = body_id else {\n+        debug!(\"check_unused_unsafe({:?}) - no body found\", def_id);\n+        return;\n     };\n     let body = tcx.hir().body(body_id);\n     debug!(\"check_unused_unsafe({:?}, body={:?}, used_unsafe={:?})\", def_id, body, used_unsafe);"}, {"sha": "44753c5f631ca7a05645428f1b207f00c2ad7f85", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -26,11 +26,8 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n \n                 let stmt = stmt.replace_nop();\n                 let source_info = stmt.source_info;\n-                let (lhs, kind, operands) = match stmt.kind {\n-                    StatementKind::Assign(box (lhs, Rvalue::Aggregate(kind, operands))) => {\n-                        (lhs, kind, operands)\n-                    }\n-                    _ => bug!(),\n+                let StatementKind::Assign(box (lhs, Rvalue::Aggregate(kind, operands))) = stmt.kind else {\n+                    bug!();\n                 };\n \n                 Some(expand_aggregate("}, {"sha": "a4b1d86ff610e4dadbd4da7cd074f98574e31dbd", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -98,12 +98,9 @@ fn find_dead_unwinds<'tcx>(\n \n         debug!(\"find_dead_unwinds @ {:?}: {:?}\", bb, bb_data);\n \n-        let path = match env.move_data.rev_lookup.find(place.as_ref()) {\n-            LookupResult::Exact(e) => e,\n-            LookupResult::Parent(..) => {\n-                debug!(\"find_dead_unwinds: has parent; skipping\");\n-                continue;\n-            }\n+        let LookupResult::Exact(path) = env.move_data.rev_lookup.find(place.as_ref()) else {\n+            debug!(\"find_dead_unwinds: has parent; skipping\");\n+            continue;\n         };\n \n         flow_inits.seek_before_primary_effect(body.terminator_loc(bb));"}, {"sha": "388bb7d34364aecf504778f085beaefc712455c5", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1413,22 +1413,16 @@ impl EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n \n impl<'tcx> Visitor<'tcx> for EnsureGeneratorFieldAssignmentsNeverAlias<'_> {\n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n-        let lhs = match self.assigned_local {\n-            Some(l) => l,\n-            None => {\n-                // This visitor only invokes `visit_place` for the right-hand side of an assignment\n-                // and only after setting `self.assigned_local`. However, the default impl of\n-                // `Visitor::super_body` may call `visit_place` with a `NonUseContext` for places\n-                // with debuginfo. Ignore them here.\n-                assert!(!context.is_use());\n-                return;\n-            }\n+        let Some(lhs) = self.assigned_local else {\n+            // This visitor only invokes `visit_place` for the right-hand side of an assignment\n+            // and only after setting `self.assigned_local`. However, the default impl of\n+            // `Visitor::super_body` may call `visit_place` with a `NonUseContext` for places\n+            // with debuginfo. Ignore them here.\n+            assert!(!context.is_use());\n+            return;\n         };\n \n-        let rhs = match self.saved_local_for_direct_place(*place) {\n-            Some(l) => l,\n-            None => return,\n-        };\n+        let Some(rhs) = self.saved_local_for_direct_place(*place) else { return };\n \n         if !self.storage_conflicts.contains(lhs, rhs) {\n             bug!("}, {"sha": "a00262a2201e1441b33ecd3cb143a35e21ba1c9a", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -118,9 +118,8 @@ impl<'tcx> Inliner<'tcx> {\n                 continue;\n             }\n \n-            let callsite = match self.resolve_callsite(caller_body, bb, bb_data) {\n-                None => continue,\n-                Some(it) => it,\n+            let Some(callsite) = self.resolve_callsite(caller_body, bb, bb_data) else {\n+                continue;\n             };\n \n             let span = trace_span!(\"process_blocks\", %callsite.callee, ?bb);"}, {"sha": "de93ab7059f87ecd29db70a4f46b25aa8bc46266", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -46,12 +46,9 @@ crate fn mir_callgraph_reachable<'tcx>(\n         trace!(%caller);\n         for &(callee, substs) in tcx.mir_inliner_callees(caller.def) {\n             let substs = caller.subst_mir_and_normalize_erasing_regions(tcx, param_env, substs);\n-            let callee = match ty::Instance::resolve(tcx, param_env, callee, substs).unwrap() {\n-                Some(callee) => callee,\n-                None => {\n-                    trace!(?callee, \"cannot resolve, skipping\");\n-                    continue;\n-                }\n+            let Some(callee) = ty::Instance::resolve(tcx, param_env, callee, substs).unwrap() else {\n+                trace!(?callee, \"cannot resolve, skipping\");\n+                continue;\n             };\n \n             // Found a path."}, {"sha": "684d988ee9ed2f2cfdd02a91e791db39477f1b88", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -17,9 +17,8 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n             let terminator = block.terminator.as_mut().unwrap();\n             if let TerminatorKind::Call { func, args, destination, .. } = &mut terminator.kind {\n                 let func_ty = func.ty(local_decls, tcx);\n-                let (intrinsic_name, substs) = match resolve_rust_intrinsic(tcx, func_ty) {\n-                    None => continue,\n-                    Some(it) => it,\n+                let Some((intrinsic_name, substs)) = resolve_rust_intrinsic(tcx, func_ty) else {\n+                    continue;\n                 };\n                 match intrinsic_name {\n                     sym::unreachable => {"}, {"sha": "43d1d62a21efbd3bd45b013908b730f6bf7b7819", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -61,10 +61,7 @@ fn lower_slice_len_call<'tcx>(\n             if args.len() != 1 {\n                 return;\n             }\n-            let arg = match args[0].place() {\n-                Some(arg) => arg,\n-                None => return,\n-            };\n+            let Some(arg) = args[0].place() else { return };\n             let func_ty = func.ty(local_decls, tcx);\n             match func_ty.kind() {\n                 ty::FnDef(fn_def_id, _) if fn_def_id == &slice_len_fn_item_def_id => {"}, {"sha": "ec25f298d48e0aefe62ddadba2daf99f78100f30", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -39,12 +39,9 @@ impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut mir::Body<'tcx>) {\n         let def_id = body.source.def_id();\n-        let returned_local = match local_eligible_for_nrvo(body) {\n-            Some(l) => l,\n-            None => {\n-                debug!(\"`{:?}` was ineligible for NRVO\", def_id);\n-                return;\n-            }\n+        let Some(returned_local) = local_eligible_for_nrvo(body) else {\n+            debug!(\"`{:?}` was ineligible for NRVO\", def_id);\n+            return;\n         };\n \n         if !tcx.consider_optimizing(|| format!(\"RenameReturnPlace {:?}\", def_id)) {"}, {"sha": "785716ebecc28af40190279294cb50399e121e64", "filename": "compiler/rustc_mir_transform/src/remove_zsts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_zsts.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -26,9 +26,8 @@ impl<'tcx> MirPass<'tcx> for RemoveZsts {\n                     if !maybe_zst(place_ty) {\n                         continue;\n                     }\n-                    let layout = match tcx.layout_of(param_env.and(place_ty)) {\n-                        Ok(layout) => layout,\n-                        Err(_) => continue,\n+                    let Ok(layout) = tcx.layout_of(param_env.and(place_ty)) else {\n+                        continue;\n                     };\n                     if !layout.is_zst() {\n                         continue;"}, {"sha": "837295292b9ff2d1b39846a76252871ecdd08a52", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -734,9 +734,8 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n     let sig = tcx.fn_sig(ctor_id).no_bound_vars().expect(\"LBR in ADT constructor signature\");\n     let sig = tcx.normalize_erasing_regions(param_env, sig);\n \n-    let (adt_def, substs) = match sig.output().kind() {\n-        ty::Adt(adt_def, substs) => (adt_def, substs),\n-        _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output()),\n+    let ty::Adt(adt_def, substs) = sig.output().kind() else {\n+        bug!(\"unexpected type for ADT ctor {:?}\", sig.output());\n     };\n \n     debug!(\"build_ctor: ctor_id={:?} sig={:?}\", ctor_id, sig);"}, {"sha": "d8b58ce53f838ae0acd9f86c9588f8c7259e1f80", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -172,19 +172,17 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n         let mut terminators: SmallVec<[_; 1]> = Default::default();\n         let mut current = *start;\n         while let Some(terminator) = self.take_terminator_if_simple_goto(current) {\n-            let target = match terminator {\n-                Terminator { kind: TerminatorKind::Goto { target }, .. } => target,\n-                _ => unreachable!(),\n+            let Terminator { kind: TerminatorKind::Goto { target }, .. } = terminator else {\n+                unreachable!();\n             };\n             terminators.push((current, terminator));\n             current = target;\n         }\n         let last = current;\n         *start = last;\n         while let Some((current, mut terminator)) = terminators.pop() {\n-            let target = match terminator {\n-                Terminator { kind: TerminatorKind::Goto { ref mut target }, .. } => target,\n-                _ => unreachable!(),\n+            let Terminator { kind: TerminatorKind::Goto { ref mut target }, .. } = terminator else {\n+                unreachable!();\n             };\n             *changed |= *target != last;\n             *target = last;"}, {"sha": "bd42505e3a3542e433a8036a00de32fc802cc8db", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -847,14 +847,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 debug!(?source_info);\n                 let lint_root = source_info.scope.lint_root(&self.body.source_scopes);\n                 debug!(?lint_root);\n-                let lint_root = match lint_root {\n-                    Some(lint_root) => lint_root,\n+                let Some(lint_root) = lint_root else {\n                     // This happens when the issue is in a function from a foreign crate that\n                     // we monomorphized in the current crate. We can't get a `HirId` for things\n                     // in other crates.\n                     // FIXME: Find out where to report the lint on. Maybe simply crate-level lint root\n                     // but correct span? This would make the lint at least accept crate-level lint attributes.\n-                    None => return,\n+                    return;\n                 };\n                 self.tcx.struct_span_lint_hir(\n                     LARGE_ASSIGNMENTS,\n@@ -1256,9 +1255,8 @@ impl<'v> RootCollector<'_, 'v> {\n     /// the return type of `main`. This is not needed when\n     /// the user writes their own `start` manually.\n     fn push_extra_entry_roots(&mut self) {\n-        let main_def_id = match self.entry_fn {\n-            Some((def_id, EntryFnType::Main)) => def_id,\n-            _ => return,\n+        let Some((main_def_id, EntryFnType::Main)) = self.entry_fn else {\n+            return;\n         };\n \n         let start_def_id = match self.tcx.lang_items().require(LangItem::Start) {"}, {"sha": "c2a75d2bc2c64491e9a31d931b5de6fd8757a3f4", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -338,20 +338,16 @@ pub(super) fn check_for_substitution<'a>(\n     ch: char,\n     err: &mut DiagnosticBuilder<'a>,\n ) -> Option<token::TokenKind> {\n-    let (u_name, ascii_char) = match UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) {\n-        Some(&(_u_char, u_name, ascii_char)) => (u_name, ascii_char),\n-        None => return None,\n+    let Some(&(_u_char, u_name, ascii_char)) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) else {\n+        return None;\n     };\n \n     let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n \n-    let (ascii_name, token) = match ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) {\n-        Some((_ascii_char, ascii_name, token)) => (ascii_name, token),\n-        None => {\n-            let msg = format!(\"substitution character not found for '{}'\", ch);\n-            reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n-            return None;\n-        }\n+    let Some((_ascii_char, ascii_name, token)) = ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) else {\n+        let msg = format!(\"substitution character not found for '{}'\", ch);\n+        reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n+        return None;\n     };\n \n     // special help suggestion for \"directed\" double quotes"}, {"sha": "7cb8c35b868a5c2157626ce23bfb4f091cde7fe2", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1667,9 +1667,8 @@ impl<'a> Parser<'a> {\n             Err(LitError::NotLiteral) => None,\n             Err(err) => {\n                 let span = token.span;\n-                let lit = match token.kind {\n-                    token::Literal(lit) => lit,\n-                    _ => unreachable!(),\n+                let token::Literal(lit) = token.kind else {\n+                    unreachable!();\n                 };\n                 self.bump();\n                 self.report_lit_error(err, lit, span);"}, {"sha": "20ca8a99ab7e6ef4d51c6ed137d01642be2c3e28", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -439,9 +439,8 @@ impl<'a> Parser<'a> {\n \n     /// Recover if we parsed attributes and expected an item but there was none.\n     fn recover_attrs_no_item(&mut self, attrs: &[Attribute]) -> PResult<'a, ()> {\n-        let (start, end) = match attrs {\n-            [] => return Ok(()),\n-            [x0 @ xn] | [x0, .., xn] => (x0, xn),\n+        let ([start @ end] | [start, .., end]) = attrs else {\n+            return Ok(());\n         };\n         let msg = if end.is_doc_comment() {\n             \"expected item after doc comment\""}, {"sha": "227a9e37dbcb4e422184cc2010ba4292e77b7afa", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -524,9 +524,8 @@ impl<'a> Parser<'a> {\n         // Skip looking for a trailing semicolon when we have an interpolated statement.\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n-        let mut stmt = match self.parse_stmt_without_recovery(true, ForceCollect::No)? {\n-            Some(stmt) => stmt,\n-            None => return Ok(None),\n+        let Some(mut stmt) = self.parse_stmt_without_recovery(true, ForceCollect::No)? else {\n+            return Ok(None);\n         };\n \n         let mut eat_semi = true;"}, {"sha": "3d69e8ba4e430ce67e6c171dc994623ffb4f3fa6", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1318,9 +1318,8 @@ impl CheckAttrVisitor<'_> {\n             return false;\n         }\n \n-        let list = match attr.meta_item_list() {\n-            None => return false,\n-            Some(it) => it,\n+        let Some(list) = attr.meta_item_list() else {\n+            return false;\n         };\n \n         if matches!(&list[..], &[NestedMetaItem::Literal(Lit { kind: LitKind::Int(..), .. })]) {\n@@ -1352,18 +1351,16 @@ impl CheckAttrVisitor<'_> {\n             return false;\n         }\n \n-        let list = match attr.meta_item_list() {\n+        let Some(list) = attr.meta_item_list() else {\n             // The attribute form is validated on AST.\n-            None => return false,\n-            Some(it) => it,\n+            return false;\n         };\n \n-        let (decl, generics) = match item {\n-            Some(ItemLike::Item(Item {\n-                kind: ItemKind::Fn(FnSig { decl, .. }, generics, _),\n-                ..\n-            })) => (decl, generics),\n-            _ => bug!(\"should be a function item\"),\n+        let Some(ItemLike::Item(Item {\n+            kind: ItemKind::Fn(FnSig { decl, .. }, generics, _),\n+            ..\n+        }))  = item else {\n+            bug!(\"should be a function item\");\n         };\n \n         for param in generics.params {"}, {"sha": "bd772d9975b3aa32cce0a77da9885d3163951163", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -35,10 +35,7 @@ struct ExprVisitor<'tcx> {\n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let (def, substs) = match *ty.kind() {\n-        ty::Adt(def, substs) => (def, substs),\n-        _ => return ty,\n-    };\n+    let ty::Adt(def, substs) = *ty.kind() else { return ty };\n \n     if def.variants.len() == 2 && !def.repr.c() && def.repr.int.is_none() {\n         let data_idx;\n@@ -202,18 +199,15 @@ impl<'tcx> ExprVisitor<'tcx> {\n             }\n             _ => None,\n         };\n-        let asm_ty = match asm_ty {\n-            Some(asm_ty) => asm_ty,\n-            None => {\n-                let msg = &format!(\"cannot use value of type `{}` for inline assembly\", ty);\n-                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n-                err.note(\n-                    \"only integers, floats, SIMD vectors, pointers and function pointers \\\n-                     can be used as arguments for inline assembly\",\n-                );\n-                err.emit();\n-                return None;\n-            }\n+        let Some(asm_ty) = asm_ty else {\n+            let msg = &format!(\"cannot use value of type `{}` for inline assembly\", ty);\n+            let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+            err.note(\n+                \"only integers, floats, SIMD vectors, pointers and function pointers \\\n+                 can be used as arguments for inline assembly\",\n+            );\n+            err.emit();\n+            return None;\n         };\n \n         // Check that the type implements Copy. The only case where this can\n@@ -260,27 +254,24 @@ impl<'tcx> ExprVisitor<'tcx> {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n         let reg_class = reg.reg_class();\n         let supported_tys = reg_class.supported_types(asm_arch);\n-        let feature = match supported_tys.iter().find(|&&(t, _)| t == asm_ty) {\n-            Some((_, feature)) => feature,\n-            None => {\n-                let msg = &format!(\"type `{}` cannot be used with this register class\", ty);\n-                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n-                let supported_tys: Vec<_> =\n-                    supported_tys.iter().map(|(t, _)| t.to_string()).collect();\n-                err.note(&format!(\n-                    \"register class `{}` supports these types: {}\",\n-                    reg_class.name(),\n-                    supported_tys.join(\", \"),\n+        let Some((_, feature)) = supported_tys.iter().find(|&&(t, _)| t == asm_ty) else {\n+            let msg = &format!(\"type `{}` cannot be used with this register class\", ty);\n+            let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+            let supported_tys: Vec<_> =\n+                supported_tys.iter().map(|(t, _)| t.to_string()).collect();\n+            err.note(&format!(\n+                \"register class `{}` supports these types: {}\",\n+                reg_class.name(),\n+                supported_tys.join(\", \"),\n+            ));\n+            if let Some(suggest) = reg_class.suggest_class(asm_arch, asm_ty) {\n+                err.help(&format!(\n+                    \"consider using the `{}` register class instead\",\n+                    suggest.name()\n                 ));\n-                if let Some(suggest) = reg_class.suggest_class(asm_arch, asm_ty) {\n-                    err.help(&format!(\n-                        \"consider using the `{}` register class instead\",\n-                        suggest.name()\n-                    ));\n-                }\n-                err.emit();\n-                return Some(asm_ty);\n             }\n+            err.emit();\n+            return Some(asm_ty);\n         };\n \n         // Check whether the selected type requires a target feature. Note that"}, {"sha": "a959089ebb318b6903c14442160674b416e3df7e", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1430,9 +1430,8 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     }\n \n     fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n-        let closure_min_captures = match self.closure_min_captures {\n-            None => return,\n-            Some(closure_min_captures) => closure_min_captures,\n+        let Some(closure_min_captures) = self.closure_min_captures else {\n+            return;\n         };\n \n         // If closure_min_captures is Some(), upvars must be Some() too."}, {"sha": "adbfb4fcf01cacb2e3f5622b5b64d703a3d1d619", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -354,9 +354,8 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n                 let tcx = self.tcx;\n                 self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n \n-                let trait_def_id = match trait_ref.path.res {\n-                    Res::Def(DefKind::Trait, def_id) => def_id,\n-                    _ => unreachable!(),\n+                let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n+                    unreachable!();\n                 };\n \n                 if !trait_def_id.is_local() {"}, {"sha": "a55198e6a9fb55c7a346dbbb3717f402e6594ed3", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -756,9 +756,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     return;\n                 }\n \n-                let cnum = match self.tcx.extern_mod_stmt_cnum(item.def_id) {\n-                    Some(cnum) => cnum,\n-                    None => return,\n+                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.def_id) else {\n+                    return;\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n                 self.tcx.check_stability(def_id, Some(item.hir_id()), item.span, None);\n@@ -808,10 +807,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n                 let ty = self.tcx.type_of(item.def_id);\n-                let (adt_def, substs) = match ty.kind() {\n-                    ty::Adt(adt_def, substs) => (adt_def, substs),\n-                    _ => bug!(),\n-                };\n+                let ty::Adt(adt_def, substs) = ty.kind() else { bug!() };\n \n                 // Non-`Copy` fields are unstable, except for `ManuallyDrop`.\n                 let param_env = self.tcx.param_env(item.def_id);"}, {"sha": "5e21161f2e06aaa6457732e33ee2fdc005770058", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -351,13 +351,11 @@ impl<'a> Resolver<'a> {\n             if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n                 continue;\n             }\n-            let module = match single_import.imported_module.get() {\n-                Some(x) => x,\n-                None => return Err((Undetermined, Weak::No)),\n+            let Some(module) = single_import.imported_module.get() else {\n+                return Err((Undetermined, Weak::No));\n             };\n-            let ident = match single_import.kind {\n-                ImportKind::Single { source, .. } => source,\n-                _ => unreachable!(),\n+            let ImportKind::Single { source: ident, .. } = single_import.kind else {\n+                unreachable!();\n             };\n             match self.resolve_ident_in_module(\n                 module,\n@@ -1347,12 +1345,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n \n     fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n-        let module = match import.imported_module.get().unwrap() {\n-            ModuleOrUniformRoot::Module(module) => module,\n-            _ => {\n-                self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n-                return;\n-            }\n+        let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n+            self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n+            return;\n         };\n \n         if module.is_trait() {"}, {"sha": "f20cf29cc89d1f8b530a173ba56339502b36778a", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1582,12 +1582,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         def_id: DefId,\n         span: Span,\n     ) {\n-        let variants = match self.collect_enum_ctors(def_id) {\n-            Some(variants) => variants,\n-            None => {\n-                err.note(\"you might have meant to use one of the enum's variants\");\n-                return;\n-            }\n+        let Some(variants) = self.collect_enum_ctors(def_id) else {\n+            err.note(\"you might have meant to use one of the enum's variants\");\n+            return;\n         };\n \n         let suggest_only_tuple_variants ="}, {"sha": "2f0ad60709dacea2b5151790dd63b516c2b172ca", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1748,10 +1748,7 @@ fn object_lifetime_defaults_for_item<'tcx>(\n             let param_def_id = tcx.hir().local_def_id(param.hir_id);\n             for predicate in generics.where_clause.predicates {\n                 // Look for `type: ...` where clauses.\n-                let data = match *predicate {\n-                    hir::WherePredicate::BoundPredicate(ref data) => data,\n-                    _ => continue,\n-                };\n+                let hir::WherePredicate::BoundPredicate(ref data) = *predicate else { continue };\n \n                 // Ignore `for<'a> type: ...` as they can change what\n                 // lifetimes mean (although we could \"just\" handle it).\n@@ -1976,12 +1973,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn check_uses_for_lifetimes_defined_by_scope(&mut self) {\n-        let defined_by = match self.scope {\n-            Scope::Binder { lifetimes, .. } => lifetimes,\n-            _ => {\n-                debug!(\"check_uses_for_lifetimes_defined_by_scope: not in a binder scope\");\n-                return;\n-            }\n+        let Scope::Binder { lifetimes: defined_by, .. } = self.scope else {\n+            debug!(\"check_uses_for_lifetimes_defined_by_scope: not in a binder scope\");\n+            return;\n         };\n \n         let def_ids: Vec<_> = defined_by\n@@ -2636,9 +2630,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             smallvec![(def_id, smallvec![])];\n         let mut visited: FxHashSet<DefId> = FxHashSet::default();\n         loop {\n-            let (def_id, bound_vars) = match stack.pop() {\n-                Some(next) => next,\n-                None => break None,\n+            let Some((def_id, bound_vars)) = stack.pop() else {\n+                break None;\n             };\n             // See issue #83753. If someone writes an associated type on a non-trait, just treat it as\n             // there being no supertrait HRTBs.\n@@ -2723,10 +2716,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         });\n \n-        let output = match output {\n-            Some(ty) => ty,\n-            None => return,\n-        };\n+        let Some(output) = output else { return };\n \n         debug!(\"determine output\");\n "}, {"sha": "04b0a18b12b62d76c9e850b44fd6efbd3f546b4d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -3479,16 +3479,15 @@ impl<'a> Resolver<'a> {\n         let ident = Ident::with_dummy_span(sym::main);\n         let parent_scope = &ParentScope::module(module, self);\n \n-        let name_binding = match self.resolve_ident_in_module(\n+        let Ok(name_binding) = self.resolve_ident_in_module(\n             ModuleOrUniformRoot::Module(module),\n             ident,\n             ValueNS,\n             parent_scope,\n             false,\n             DUMMY_SP,\n-        ) {\n-            Ok(name_binding) => name_binding,\n-            _ => return,\n+        ) else {\n+            return;\n         };\n \n         let res = name_binding.res();"}, {"sha": "51f73ac2eb199f5d8cc518c28310116f40dd7f98", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -522,9 +522,8 @@ impl<'tcx> DumpVisitor<'tcx> {\n         ty_params: &'tcx hir::Generics<'tcx>,\n     ) {\n         let enum_data = self.save_ctxt.get_item_data(item);\n-        let enum_data = match enum_data {\n-            None => return,\n-            Some(data) => data,\n+        let Some(enum_data) = enum_data else {\n+            return;\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n "}, {"sha": "5d32063d50b2da80f237dc633caecc88746793db", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -115,12 +115,9 @@ impl<'tcx> SaveContext<'tcx> {\n         let mut result = Vec::with_capacity(self.tcx.crates(()).len());\n \n         for &n in self.tcx.crates(()).iter() {\n-            let span = match self.tcx.extern_crate(n.as_def_id()) {\n-                Some(&ExternCrate { span, .. }) => span,\n-                None => {\n-                    debug!(\"skipping crate {}, no data\", n);\n-                    continue;\n-                }\n+            let Some(&ExternCrate { span, .. }) = self.tcx.extern_crate(n.as_def_id()) else {\n+                debug!(\"skipping crate {}, no data\", n);\n+                continue;\n             };\n             let lo_loc = self.span_utils.sess.source_map().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n@@ -566,12 +563,9 @@ impl<'tcx> SaveContext<'tcx> {\n                 }\n             },\n             hir::ExprKind::MethodCall(ref seg, ..) => {\n-                let method_id = match self.typeck_results().type_dependent_def_id(expr.hir_id) {\n-                    Some(id) => id,\n-                    None => {\n-                        debug!(\"could not resolve method id for {:?}\", expr);\n-                        return None;\n-                    }\n+                let Some(method_id) = self.typeck_results().type_dependent_def_id(expr.hir_id) else {\n+                    debug!(\"could not resolve method id for {:?}\", expr);\n+                    return None;\n                 };\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),"}, {"sha": "7e08b18cf486f2ae7a2c9b8cf3f5990901a1a5a8", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -2306,9 +2306,8 @@ impl crate::Decoder for Decoder {\n             }\n             json => bad!(ExpectedError(\"String or Object\".to_owned(), json.to_string())),\n         };\n-        let idx = match names.iter().position(|n| *n == &name[..]) {\n-            Some(idx) => idx,\n-            None => bad!(UnknownVariantError(name)),\n+        let Some(idx) = names.iter().position(|n| *n == &name[..]) else {\n+            bad!(UnknownVariantError(name));\n         };\n         f(self, idx)\n     }"}, {"sha": "bd257dc64646a2744e41fdbdacce2765b42a7b73", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -15,6 +15,7 @@ Core encoding and decoding interfaces.\n #![feature(min_specialization)]\n #![feature(core_intrinsics)]\n #![feature(maybe_uninit_slice)]\n+#![feature(let_else)]\n #![feature(new_uninit)]\n #![cfg_attr(test, feature(test))]\n #![allow(rustc::internal)]"}, {"sha": "82a95faa3470a87bf173f98bbcd34906e7a65532", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1,5 +1,6 @@\n #![feature(crate_visibility_modifier)]\n #![feature(derive_default_enum)]\n+#![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]"}, {"sha": "9a92258f80985068631b38625693172284db8002", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -763,12 +763,9 @@ mod parse {\n             }\n         }\n \n-        let v = match v {\n-            None => {\n-                *slot = Some(MirSpanview::Statement);\n-                return true;\n-            }\n-            Some(v) => v,\n+        let Some(v) = v else {\n+            *slot = Some(MirSpanview::Statement);\n+            return true;\n         };\n \n         *slot = Some(match v.trim_end_matches('s') {\n@@ -792,12 +789,9 @@ mod parse {\n             }\n         }\n \n-        let v = match v {\n-            None => {\n-                *slot = Some(InstrumentCoverage::All);\n-                return true;\n-            }\n-            Some(v) => v,\n+        let Some(v) = v else {\n+            *slot = Some(InstrumentCoverage::All);\n+            return true;\n         };\n \n         *slot = Some(match v {"}, {"sha": "5991b4d217c6ec05eee37a2da453aa0942678158", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -17,6 +17,7 @@\n #![feature(array_windows)]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_else)]\n #![feature(if_let_guard)]\n #![feature(negative_impls)]\n #![feature(nll)]\n@@ -2103,13 +2104,9 @@ where\n         // If this is not an empty or invalid span, we want to hash the last\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n-        let (file, line_lo, col_lo, line_hi, col_hi) = match ctx.span_data_to_lines_and_cols(&span)\n-        {\n-            Some(pos) => pos,\n-            None => {\n-                Hash::hash(&TAG_INVALID_SPAN, hasher);\n-                return;\n-            }\n+        let Some((file, line_lo, col_lo, line_hi, col_hi)) = ctx.span_data_to_lines_and_cols(&span) else {\n+            Hash::hash(&TAG_INVALID_SPAN, hasher);\n+            return;\n         };\n \n         Hash::hash(&TAG_VALID_SPAN, hasher);"}, {"sha": "4ef863712983f802b793c2f87c717e08c5e39cfc", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -121,12 +121,9 @@ impl TargetDataLayout {\n                     dl.pointer_align = align(a, p)?;\n                 }\n                 [s, ref a @ ..] if s.starts_with('i') => {\n-                    let bits = match s[1..].parse::<u64>() {\n-                        Ok(bits) => bits,\n-                        Err(_) => {\n-                            size(&s[1..], \"i\")?; // For the user error.\n-                            continue;\n-                        }\n+                    let Ok(bits) = s[1..].parse::<u64>() else {\n+                        size(&s[1..], \"i\")?; // For the user error.\n+                        continue;\n                     };\n                     let a = align(a, s)?;\n                     match bits {"}, {"sha": "2919743e4996fa12e9d65f7f2df4a5da3b5a7b8c", "filename": "compiler/rustc_target/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_target%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_target%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -9,6 +9,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n+#![feature(let_else)]\n #![feature(nll)]\n #![feature(never_type)]\n #![feature(associated_type_bounds)]"}, {"sha": "fee014ea7ef7d09bd0849f8bd60a1aae2983026c", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -72,9 +72,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n         let def_id = assoc_type_id.0;\n         let assoc_item = self.interner.tcx.associated_item(def_id);\n-        let trait_def_id = match assoc_item.container {\n-            AssocItemContainer::TraitContainer(def_id) => def_id,\n-            _ => unimplemented!(\"Not possible??\"),\n+        let AssocItemContainer::TraitContainer(trait_def_id) = assoc_item.container else {\n+            unimplemented!(\"Not possible??\");\n         };\n         match assoc_item.kind {\n             AssocKind::Type => {}"}, {"sha": "73fd95e98ca54f4ab0372eb63d26950d019244f1", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -2,6 +2,7 @@\n //! the guts are broken up into modules; see the comments in those modules.\n \n #![feature(crate_visibility_modifier)]\n+#![feature(let_else)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "702a9513b44028e1afff2ba5e321a97e3d978f7e", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(control_flow_enum)]\n+#![feature(let_else)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "20ae986ffa4eedad1b8c7fafb0b211e641ef66f9", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -49,10 +49,7 @@ fn sized_constraint_for_ty<'tcx>(\n             // we know that `T` is Sized and do not need to check\n             // it on the impl.\n \n-            let sized_trait = match tcx.lang_items().sized_trait() {\n-                Some(x) => x,\n-                _ => return vec![ty],\n-            };\n+            let Some(sized_trait) = tcx.lang_items().sized_trait() else { return vec![ty] };\n             let sized_predicate = ty::Binder::dummy(ty::TraitRef {\n                 def_id: sized_trait,\n                 substs: tcx.mk_substs_trait(ty, &[]),"}, {"sha": "dbe7ddeb6a82412cdb542ac20f2b814134549b2b", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1808,12 +1808,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             (_, Res::SelfTy { trait_: Some(_), alias_to: Some((impl_def_id, _)) }) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n-                let trait_ref = match tcx.impl_trait_ref(impl_def_id) {\n-                    Some(trait_ref) => trait_ref,\n-                    None => {\n-                        // A cycle error occurred, most likely.\n-                        return Err(ErrorReported);\n-                    }\n+                let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) else {\n+                    // A cycle error occurred, most likely.\n+                    return Err(ErrorReported);\n                 };\n \n                 self.one_bound_for_assoc_type("}, {"sha": "679cac0b82a52536b1a7ced362b632cdf3b7a698", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -219,10 +219,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (self.tcx.lang_items().fn_mut_trait(), Ident::with_dummy_span(sym::call_mut), true),\n             (self.tcx.lang_items().fn_once_trait(), Ident::with_dummy_span(sym::call_once), false),\n         ] {\n-            let trait_def_id = match opt_trait_def_id {\n-                Some(def_id) => def_id,\n-                None => continue,\n-            };\n+            let Some(trait_def_id) = opt_trait_def_id else { continue };\n \n             let opt_input_types = opt_arg_exprs.map(|arg_exprs| {\n                 [self.tcx.mk_tup(arg_exprs.iter().map(|e| {\n@@ -246,11 +243,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     // Check for &self vs &mut self in the method signature. Since this is either\n                     // the Fn or FnMut trait, it should be one of those.\n-                    let (region, mutbl) = if let ty::Ref(r, _, mutbl) =\n-                        method.sig.inputs()[0].kind()\n-                    {\n-                        (r, mutbl)\n-                    } else {\n+                    let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind() else {\n                         // The `fn`/`fn_mut` lang item is ill-formed, which should have\n                         // caused an error elsewhere.\n                         self.tcx"}, {"sha": "a5e1b2579f8c4aeb06b4a052f189c67a3e2a31b2", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -799,21 +799,19 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         let expr_kind = fcx.pointer_kind(m_expr.ty, self.span)?;\n         let cast_kind = fcx.pointer_kind(m_cast.ty, self.span)?;\n \n-        let cast_kind = match cast_kind {\n+        let Some(cast_kind) = cast_kind else {\n             // We can't cast if target pointer kind is unknown\n-            None => return Err(CastError::UnknownCastPtrKind),\n-            Some(cast_kind) => cast_kind,\n+            return Err(CastError::UnknownCastPtrKind);\n         };\n \n         // Cast to thin pointer is OK\n         if cast_kind == PointerKind::Thin {\n             return Ok(CastKind::PtrPtrCast);\n         }\n \n-        let expr_kind = match expr_kind {\n+        let Some(expr_kind) = expr_kind else {\n             // We can't cast to fat pointer if source pointer kind is unknown\n-            None => return Err(CastError::UnknownExprPtrKind),\n-            Some(expr_kind) => expr_kind,\n+            return Err(CastError::UnknownExprPtrKind);\n         };\n \n         // thin -> fat? report invalid cast (don't complain about vtable kinds)"}, {"sha": "30ae382de42782b5e31cd1a0e0b14d7f539f9b1f", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -415,13 +415,10 @@ fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Spa\n     // have UB during initialization if they are uninhabited, but there also seems to be no good\n     // reason to allow any statics to be uninhabited.\n     let ty = tcx.type_of(def_id);\n-    let layout = match tcx.layout_of(ParamEnv::reveal_all().and(ty)) {\n-        Ok(l) => l,\n-        Err(_) => {\n-            // Generic statics are rejected, but we still reach this case.\n-            tcx.sess.delay_span_bug(span, \"generic static must be rejected\");\n-            return;\n-        }\n+    let Ok(layout) = tcx.layout_of(ParamEnv::reveal_all().and(ty)) else {\n+        // Generic statics are rejected, but we still reach this case.\n+        tcx.sess.delay_span_bug(span, \"generic static must be rejected\");\n+        return;\n     };\n     if layout.abi.is_uninhabited() {\n         tcx.struct_span_lint_hir(\n@@ -852,10 +849,7 @@ pub(super) fn check_specialization_validity<'tcx>(\n     impl_id: DefId,\n     impl_item: &hir::ImplItemRef,\n ) {\n-    let ancestors = match trait_def.ancestors(tcx, impl_id) {\n-        Ok(ancestors) => ancestors,\n-        Err(_) => return,\n-    };\n+    let Ok(ancestors) = trait_def.ancestors(tcx, impl_id) else { return };\n     let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n         if parent.is_from_trait() {\n             None"}, {"sha": "966ef8baedd8b9e38e11466cea2500502fd7237e", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -676,12 +676,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We do not expect any bound regions in our predicate, so\n         // skip past the bound vars.\n-        let predicate = match predicate.no_bound_vars() {\n-            Some(p) => p,\n-            None => {\n-                debug!(\"deduce_future_output_from_projection: has late-bound regions\");\n-                return None;\n-            }\n+        let Some(predicate) = predicate.no_bound_vars() else {\n+            debug!(\"deduce_future_output_from_projection: has late-bound regions\");\n+            return None;\n         };\n \n         // Check that this is a projection from the `Future` trait."}, {"sha": "b011fb8804d3ded91d169e5a3dcf37a84450bb33", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -429,13 +429,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let InferOk { value: ty, mut obligations } = match found {\n-            Some(d) => d,\n-            None => {\n-                let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n-                debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n-                return Err(err);\n-            }\n+        let Some(InferOk { value: ty, mut obligations }) = found else {\n+            let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n+            debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n+            return Err(err);\n         };\n \n         if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n@@ -461,9 +458,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n-        let r_borrow = match ty.kind() {\n-            ty::Ref(r_borrow, _, _) => r_borrow,\n-            _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n+        let ty::Ref(r_borrow, _, _) = ty.kind() else {\n+            span_bug!(span, \"expected a ref type, got {:?}\", ty);\n         };\n         let mutbl = match mutbl_b {\n             hir::Mutability::Not => AutoBorrowMutability::Not,\n@@ -944,9 +940,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // We don't ever need two-phase here since we throw out the result of the coercion\n         let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n         self.probe(|_| {\n-            let ok = match coerce.coerce(source, target) {\n-                Ok(ok) => ok,\n-                _ => return false,\n+            let Ok(ok) = coerce.coerce(source, target) else {\n+                return false;\n             };\n             let mut fcx = traits::FulfillmentContext::new_in_snapshot();\n             fcx.register_predicate_obligations(self, ok.obligations);"}, {"sha": "6c45af3e78686be40897b07522b9263a83f19664", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -435,44 +435,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// opt.map(|param| { takes_ref(param) });\n     /// ```\n     fn can_use_as_ref(&self, expr: &hir::Expr<'_>) -> Option<(Span, &'static str, String)> {\n-        let path = match expr.kind {\n-            hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => path,\n-            _ => return None,\n+        let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind else {\n+            return None;\n         };\n \n-        let local_id = match path.res {\n-            hir::def::Res::Local(id) => id,\n-            _ => return None,\n+        let hir::def::Res::Local(local_id) = path.res else {\n+            return None;\n         };\n \n         let local_parent = self.tcx.hir().get_parent_node(local_id);\n-        let param_hir_id = match self.tcx.hir().find(local_parent) {\n-            Some(Node::Param(hir::Param { hir_id, .. })) => hir_id,\n-            _ => return None,\n+        let Some(Node::Param(hir::Param { hir_id: param_hir_id, .. })) = self.tcx.hir().find(local_parent) else {\n+            return None;\n         };\n \n         let param_parent = self.tcx.hir().get_parent_node(*param_hir_id);\n-        let (expr_hir_id, closure_fn_decl) = match self.tcx.hir().find(param_parent) {\n-            Some(Node::Expr(hir::Expr {\n-                hir_id,\n-                kind: hir::ExprKind::Closure(_, decl, ..),\n-                ..\n-            })) => (hir_id, decl),\n-            _ => return None,\n+        let Some(Node::Expr(hir::Expr {\n+            hir_id: expr_hir_id,\n+            kind: hir::ExprKind::Closure(_, closure_fn_decl, ..),\n+            ..\n+        })) = self.tcx.hir().find(param_parent) else {\n+            return None;\n         };\n \n         let expr_parent = self.tcx.hir().get_parent_node(*expr_hir_id);\n         let hir = self.tcx.hir().find(expr_parent);\n         let closure_params_len = closure_fn_decl.inputs.len();\n-        let (method_path, method_expr) = match (hir, closure_params_len) {\n-            (\n-                Some(Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::MethodCall(segment, expr, _),\n-                    ..\n-                })),\n-                1,\n-            ) => (segment, expr),\n-            _ => return None,\n+        let (\n+            Some(Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::MethodCall(method_path, method_expr, _),\n+                ..\n+            })),\n+            1,\n+        ) = (hir, closure_params_len) else {\n+            return None;\n         };\n \n         let self_ty = self.typeck_results.borrow().node_type(method_expr[0].hir_id);"}, {"sha": "be9bf6399d75736ec5a37ed9bbb982d7c3419dd9", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -622,15 +622,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // the `enclosing_loops` field and let's coerce the\n             // type of `expr_opt` into what is expected.\n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = match enclosing_breakables.opt_find_breakable(target_id) {\n-                Some(ctxt) => ctxt,\n-                None => {\n-                    // Avoid ICE when `break` is inside a closure (#65383).\n-                    return tcx.ty_error_with_message(\n-                        expr.span,\n-                        \"break was outside loop, but no error was emitted\",\n-                    );\n-                }\n+            let Some(ctxt) = enclosing_breakables.opt_find_breakable(target_id) else {\n+                // Avoid ICE when `break` is inside a closure (#65383).\n+                return tcx.ty_error_with_message(\n+                    expr.span,\n+                    \"break was outside loop, but no error was emitted\",\n+                );\n             };\n \n             if let Some(ref mut coerce) = ctxt.coerce {"}, {"sha": "f6cd136940333dd1c3213f2d6eb867b3bd42b452", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -745,10 +745,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         formal_args: &[Ty<'tcx>],\n     ) -> Vec<Ty<'tcx>> {\n         let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n-        let ret_ty = match expected_ret.only_has_type(self) {\n-            Some(ret) => ret,\n-            None => return Vec::new(),\n-        };\n+        let Some(ret_ty) = expected_ret.only_has_type(self) else { return Vec::new() };\n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n                 // Attempt to apply a subtyping relationship between the formal\n@@ -1044,9 +1041,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n-        let last_expr = match last_stmt.kind {\n-            hir::StmtKind::Semi(ref e) => e,\n-            _ => return None,\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n         let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n@@ -1061,11 +1057,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     last_def_id, last_bounds, exp_def_id, exp_bounds\n                 );\n \n-                let (last_local_id, exp_local_id) =\n-                    match (last_def_id.as_local(), exp_def_id.as_local()) {\n-                        (Some(last_hir_id), Some(exp_hir_id)) => (last_hir_id, exp_hir_id),\n-                        (_, _) => return None,\n-                    };\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n \n                 match (\n                     &self.tcx.hir().expect_item(last_local_id).kind,"}, {"sha": "f6a2447572ffdb60b4474efd7b700ac945dede0f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -438,9 +438,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n                 // can suggest Box::pin.\n                 let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n-                let fn_name = match self.tcx.hir().find(parent) {\n-                    Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) => fn_name,\n-                    _ => return false,\n+                let Some(Node::Expr(Expr { kind: ExprKind::Call(fn_name, _), .. })) = self.tcx.hir().find(parent) else {\n+                    return false;\n                 };\n                 match fn_name.kind {\n                     ExprKind::Path(QPath::TypeRelative("}, {"sha": "3fa873e46abbb72f6bc7e42337da8527852e80fb", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -149,14 +149,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // time writing the results into the various typeck results.\n         let mut autoderef =\n             self.autoderef_overloaded_span(self.span, unadjusted_self_ty, self.call_expr.span);\n-        let (ty, n) = match autoderef.nth(pick.autoderefs) {\n-            Some(n) => n,\n-            None => {\n-                return self.tcx.ty_error_with_message(\n-                    rustc_span::DUMMY_SP,\n-                    &format!(\"failed autoderef {}\", pick.autoderefs),\n-                );\n-            }\n+        let Some((ty, n)) = autoderef.nth(pick.autoderefs) else {\n+            return self.tcx.ty_error_with_message(\n+                rustc_span::DUMMY_SP,\n+                &format!(\"failed autoderef {}\", pick.autoderefs),\n+            );\n         };\n         assert_eq!(n, pick.autoderefs);\n \n@@ -520,10 +517,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         &self,\n         predicates: &ty::InstantiatedPredicates<'tcx>,\n     ) -> Option<Span> {\n-        let sized_def_id = match self.tcx.lang_items().sized_trait() {\n-            Some(def_id) => def_id,\n-            None => return None,\n-        };\n+        let sized_def_id = self.tcx.lang_items().sized_trait()?;\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here."}, {"sha": "780a57278c5b0db227c12137c4eed3df74763e16", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -371,15 +371,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = match self.associated_value(trait_def_id, m_name) {\n-            Some(method_item) => method_item,\n-            None => {\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    \"operator trait does not have corresponding operator method\",\n-                );\n-                return None;\n-            }\n+        let Some(method_item) = self.associated_value(trait_def_id, m_name) else {\n+            tcx.sess.delay_span_bug(\n+                span,\n+                \"operator trait does not have corresponding operator method\",\n+            );\n+            return None;\n         };\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);"}, {"sha": "876c575781cf6580c116b06475806d8d598dd9c4", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1246,9 +1246,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             return None;\n         }\n \n-        let ty = match self_ty.kind() {\n-            &ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n-            _ => return None,\n+        let &ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) = self_ty.kind() else {\n+            return None;\n         };\n \n         let const_self_ty = ty::TypeAndMut { ty, mutbl: hir::Mutability::Not };"}, {"sha": "475070b6b835bf888621469879296a56bfc5dd9b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -37,9 +37,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Closure(..) | ty::FnDef(..) | ty::FnPtr(_) => true,\n             // If it's not a simple function, look for things which implement `FnOnce`.\n             _ => {\n-                let fn_once = match tcx.lang_items().require(LangItem::FnOnce) {\n-                    Ok(fn_once) => fn_once,\n-                    Err(..) => return false,\n+                let Some(fn_once) = tcx.lang_items().fn_once_trait() else {\n+                    return false;\n                 };\n \n                 // This conditional prevents us from asking to call errors and unresolved types.\n@@ -112,12 +111,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     CandidateSource::ImplSource(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n-                        let item = match self.associated_value(impl_did, item_name).or_else(|| {\n+                        let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n                             let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n                             self.associated_value(impl_trait_ref.def_id, item_name)\n-                        }) {\n-                            Some(item) => item,\n-                            None => continue,\n+                        }) else {\n+                            continue;\n                         };\n                         let note_span = self\n                             .tcx\n@@ -194,10 +192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n-                        let item = match self.associated_value(trait_did, item_name) {\n-                            Some(item) => item,\n-                            None => continue,\n-                        };\n+                        let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n                         let item_span = self\n                             .tcx\n                             .sess\n@@ -1202,10 +1197,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut derives = Vec::<(String, Span, String)>::new();\n         let mut traits = Vec::<Span>::new();\n         for (pred, _, _) in unsatisfied_predicates {\n-            let trait_pred = match pred.kind().skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred) => trait_pred,\n-                _ => continue,\n-            };\n+            let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() else { continue };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n                 Some(adt) if adt.did.is_local() => adt,\n                 _ => continue,"}, {"sha": "767979c39127e9799a4580a252136d68a1de903d", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -981,9 +981,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if subpats.len() == variant.fields.len()\n             || subpats.len() < variant.fields.len() && ddpos.is_some()\n         {\n-            let substs = match pat_ty.kind() {\n-                ty::Adt(_, substs) => substs,\n-                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n+            let ty::Adt(_, substs) = pat_ty.kind() else {\n+                bug!(\"unexpected pattern type {:?}\", pat_ty);\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n@@ -1221,9 +1220,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         let tcx = self.tcx;\n \n-        let (substs, adt) = match adt_ty.kind() {\n-            ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(pat.span, \"struct pattern is not an ADT\"),\n+        let ty::Adt(adt, substs) = adt_ty.kind() else {\n+            span_bug!(pat.span, \"struct pattern is not an ADT\");\n         };\n \n         // Index the struct fields' types."}, {"sha": "73f7cafa1628cc3270966fb459424ef3b1ca2737", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -533,19 +533,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n-                None => {\n-                    let mutability = self.determine_capture_mutability(&typeck_results, &place);\n-                    let min_cap_list = vec![ty::CapturedPlace {\n-                        place,\n-                        info: capture_info,\n-                        mutability,\n-                        region: None,\n-                    }];\n-                    root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n-                    continue;\n-                }\n-                Some(min_cap_list) => min_cap_list,\n+            let Some(min_cap_list) = root_var_min_capture_list.get_mut(&var_hir_id) else {\n+                let mutability = self.determine_capture_mutability(&typeck_results, &place);\n+                let min_cap_list = vec![ty::CapturedPlace {\n+                    place,\n+                    info: capture_info,\n+                    mutability,\n+                    region: None,\n+                }];\n+                root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n+                continue;\n             };\n \n             // Go through each entry in the current list of min_captures"}, {"sha": "78e549974030192e6bd1c4fa0af6b94f05933943", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -40,11 +40,8 @@ struct InherentCollect<'tcx> {\n \n impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let (ty, assoc_items) = match item.kind {\n-            hir::ItemKind::Impl(hir::Impl { of_trait: None, ref self_ty, items, .. }) => {\n-                (self_ty, items)\n-            }\n-            _ => return,\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items: assoc_items, .. }) = item.kind else {\n+            return;\n         };\n \n         let self_ty = self.tcx.type_of(item.def_id);"}, {"sha": "54fffeb3cdaa6c5e0d4b10d4bd1fc45efb57241f", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -38,9 +38,8 @@ fn orphan_check_impl(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorRep\n     let trait_def_id = trait_ref.def_id;\n \n     let item = tcx.hir().item(hir::ItemId { def_id });\n-    let impl_ = match item.kind {\n-        hir::ItemKind::Impl(ref impl_) => impl_,\n-        _ => bug!(\"{:?} is not an impl: {:?}\", def_id, item),\n+    let hir::ItemKind::Impl(ref impl_) = item.kind else {\n+        bug!(\"{:?} is not an impl: {:?}\", def_id, item);\n     };\n     let sp = tcx.sess.source_map().guess_head_span(item.span);\n     let tr = impl_.of_trait.as_ref().unwrap();"}, {"sha": "19b3d35566b2484af21fd40bbeb8d81dc9860945", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -1018,9 +1017,8 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n \n     let def_id = def_id.expect_local();\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let item = match tcx.hir().get(hir_id) {\n-        Node::Item(item) => item,\n-        _ => bug!(),\n+    let Node::Item(item) = tcx.hir().get(hir_id) else {\n+        bug!();\n     };\n \n     let repr = ReprOptions::new(tcx, def_id.to_def_id());\n@@ -1122,9 +1120,8 @@ fn super_predicates_that_define_assoc_type(\n         debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n         let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n-        let item = match tcx.hir().get(trait_hir_id) {\n-            Node::Item(item) => item,\n-            _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n+        let Node::Item(item) = tcx.hir().get(trait_hir_id) else {\n+            bug!(\"trait_node_id {} is not an item\", trait_hir_id);\n         };\n \n         let (generics, bounds) = match item.kind {\n@@ -2637,10 +2634,7 @@ fn from_target_feature(\n     supported_target_features: &FxHashMap<String, Option<Symbol>>,\n     target_features: &mut Vec<Symbol>,\n ) {\n-    let list = match attr.meta_item_list() {\n-        Some(list) => list,\n-        None => return,\n-    };\n+    let Some(list) = attr.meta_item_list() else { return };\n     let bad_item = |span| {\n         let msg = \"malformed `target_feature` attribute input\";\n         let code = \"enable = \\\"..\\\"\".to_owned();\n@@ -2658,35 +2652,29 @@ fn from_target_feature(\n         }\n \n         // Must be of the form `enable = \"...\"` (a string).\n-        let value = match item.value_str() {\n-            Some(value) => value,\n-            None => {\n-                bad_item(item.span());\n-                continue;\n-            }\n+        let Some(value) = item.value_str() else {\n+            bad_item(item.span());\n+            continue;\n         };\n \n         // We allow comma separation to enable multiple features.\n         target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            let feature_gate = match supported_target_features.get(feature) {\n-                Some(g) => g,\n-                None => {\n-                    let msg =\n-                        format!(\"the feature named `{}` is not valid for this target\", feature);\n-                    let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n-                    err.span_label(\n-                        item.span(),\n-                        format!(\"`{}` is not valid for this target\", feature),\n-                    );\n-                    if let Some(stripped) = feature.strip_prefix('+') {\n-                        let valid = supported_target_features.contains_key(stripped);\n-                        if valid {\n-                            err.help(\"consider removing the leading `+` in the feature name\");\n-                        }\n+            let Some(feature_gate) = supported_target_features.get(feature) else {\n+                let msg =\n+                    format!(\"the feature named `{}` is not valid for this target\", feature);\n+                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n+                err.span_label(\n+                    item.span(),\n+                    format!(\"`{}` is not valid for this target\", feature),\n+                );\n+                if let Some(stripped) = feature.strip_prefix('+') {\n+                    let valid = supported_target_features.contains_key(stripped);\n+                    if valid {\n+                        err.help(\"consider removing the leading `+` in the feature name\");\n                     }\n-                    err.emit();\n-                    return None;\n                 }\n+                err.emit();\n+                return None;\n             };\n \n             // Only allow features whose feature gates have been enabled."}, {"sha": "78097e3697fb968b46f92b6d50aed3fa8b71e431", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -164,12 +164,9 @@ fn get_impl_substs<'tcx>(\n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n     infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n-    let impl2_substs = match infcx.fully_resolve(impl2_substs) {\n-        Ok(s) => s,\n-        Err(_) => {\n-            tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();\n-            return None;\n-        }\n+    let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n+        tcx.sess.struct_span_err(span, \"could not resolve substs on overridden impl\").emit();\n+        return None;\n     };\n     Some((impl1_substs, impl2_substs))\n }"}, {"sha": "876b1ae72ad9644a194791a5942d54fa2104d95d", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -484,9 +484,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let place_ty = self.expr_ty(expr)?;\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n-        let (region, mutbl) = match *base_ty.kind() {\n-            ty::Ref(region, _, mutbl) => (region, mutbl),\n-            _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\"),\n+        let ty::Ref(region, _, mutbl) = *base_ty.kind() else {\n+            span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\");\n         };\n         let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut { ty: place_ty, mutbl });\n \n@@ -544,14 +543,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> McResult<VariantIdx> {\n         let res = self.typeck_results.qpath_res(qpath, pat_hir_id);\n         let ty = self.typeck_results.node_type(pat_hir_id);\n-        let adt_def = match ty.kind() {\n-            ty::Adt(adt_def, _) => adt_def,\n-            _ => {\n-                self.tcx()\n-                    .sess\n-                    .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n-                return Err(());\n-            }\n+        let ty::Adt(adt_def, _) = ty.kind() else {\n+            self.tcx()\n+                .sess\n+                .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n+            return Err(());\n         };\n \n         match res {\n@@ -744,12 +740,9 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             PatKind::Slice(before, ref slice, after) => {\n-                let element_ty = match place_with_id.place.ty().builtin_index() {\n-                    Some(ty) => ty,\n-                    None => {\n-                        debug!(\"explicit index of non-indexable type {:?}\", place_with_id);\n-                        return Err(());\n-                    }\n+                let Some(element_ty) = place_with_id.place.ty().builtin_index() else {\n+                    debug!(\"explicit index of non-indexable type {:?}\", place_with_id);\n+                    return Err(());\n                 };\n                 let elt_place = self.cat_projection(\n                     pat,"}, {"sha": "435df9c00f466aa5e8d45d1e2ed00aa72d320888", "filename": "compiler/rustc_typeck/src/outlives/outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Foutlives_bounds.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -71,12 +71,9 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n             result,\n         );\n         debug!(\"implied_outlives_bounds for {:?}: {:#?}\", ty, result);\n-        let result = match result {\n-            Ok(v) => v,\n-            Err(_) => {\n-                self.tcx.sess.delay_span_bug(span, \"implied_outlives_bounds failed to instantiate\");\n-                return vec![];\n-            }\n+        let Ok(result) = result else {\n+            self.tcx.sess.delay_span_bug(span, \"implied_outlives_bounds failed to instantiate\");\n+            return vec![];\n         };\n \n         // Instantiation may have produced new inference variables and constraints on those"}, {"sha": "139841368d6a1c4096f329ee062e9041e194f64a", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -6,8 +6,6 @@ use crate::fmt;\n use crate::mem::transmute;\n use crate::str::FromStr;\n \n-use super::MAX;\n-\n /// Converts a `u32` to a `char`.\n ///\n /// Note that all [`char`]s are valid [`u32`]s, and can be cast to one with\n@@ -271,7 +269,20 @@ impl FromStr for char {\n \n #[inline]\n const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n-    if (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF) {\n+    // This is an optimized version of the check\n+    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n+    // which can also be written as\n+    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n+    //\n+    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n+    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n+    // In particular, numbers >= 0x110000 stay in this range.\n+    //\n+    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n+    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n+    // surrogate range as well as the numbers originally larger than 0x110000.\n+    //\n+    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n         Err(CharTryFromError(()))\n     } else {\n         // SAFETY: checked that it's a legal unicode value"}, {"sha": "ebfd12d15337cd9d4701dae97bbddae947d5e323", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -805,7 +805,7 @@ impl<T: ?Sized> Pin<&'static T> {\n     ///\n     /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n     /// never ends.\n-    #[unstable(feature = \"pin_static_ref\", issue = \"78186\")]\n+    #[stable(feature = \"pin_static_ref\", since = \"1.60.0\")]\n     #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n     pub const fn static_ref(r: &'static T) -> Pin<&'static T> {\n         // SAFETY: The 'static borrow guarantees the data will not be\n@@ -858,7 +858,7 @@ impl<T: ?Sized> Pin<&'static mut T> {\n     ///\n     /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n     /// never ends.\n-    #[unstable(feature = \"pin_static_ref\", issue = \"78186\")]\n+    #[stable(feature = \"pin_static_ref\", since = \"1.60.0\")]\n     #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n     pub const fn static_mut(r: &'static mut T) -> Pin<&'static mut T> {\n         // SAFETY: The 'static borrow guarantees the data will not be"}, {"sha": "1dba24dd149073b39093b3afa79f170a519d23e7", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -79,6 +79,84 @@ impl [u8] {\n     pub fn escape_ascii(&self) -> EscapeAscii<'_> {\n         EscapeAscii { inner: self.iter().flat_map(EscapeByte) }\n     }\n+\n+    /// Returns a byte slice with leading ASCII whitespace bytes removed.\n+    ///\n+    /// 'Whitespace' refers to the definition used by\n+    /// `u8::is_ascii_whitespace`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(byte_slice_trim_ascii)]\n+    ///\n+    /// assert_eq!(b\" \\t hello world\\n\".trim_ascii_start(), b\"hello world\\n\");\n+    /// assert_eq!(b\"  \".trim_ascii_start(), b\"\");\n+    /// assert_eq!(b\"\".trim_ascii_start(), b\"\");\n+    /// ```\n+    #[unstable(feature = \"byte_slice_trim_ascii\", issue = \"94035\")]\n+    pub const fn trim_ascii_start(&self) -> &[u8] {\n+        let mut bytes = self;\n+        // Note: A pattern matching based approach (instead of indexing) allows\n+        // making the function const.\n+        while let [first, rest @ ..] = bytes {\n+            if first.is_ascii_whitespace() {\n+                bytes = rest;\n+            } else {\n+                break;\n+            }\n+        }\n+        bytes\n+    }\n+\n+    /// Returns a byte slice with trailing ASCII whitespace bytes removed.\n+    ///\n+    /// 'Whitespace' refers to the definition used by\n+    /// `u8::is_ascii_whitespace`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(byte_slice_trim_ascii)]\n+    ///\n+    /// assert_eq!(b\"\\r hello world\\n \".trim_ascii_end(), b\"\\r hello world\");\n+    /// assert_eq!(b\"  \".trim_ascii_end(), b\"\");\n+    /// assert_eq!(b\"\".trim_ascii_end(), b\"\");\n+    /// ```\n+    #[unstable(feature = \"byte_slice_trim_ascii\", issue = \"94035\")]\n+    pub const fn trim_ascii_end(&self) -> &[u8] {\n+        let mut bytes = self;\n+        // Note: A pattern matching based approach (instead of indexing) allows\n+        // making the function const.\n+        while let [rest @ .., last] = bytes {\n+            if last.is_ascii_whitespace() {\n+                bytes = rest;\n+            } else {\n+                break;\n+            }\n+        }\n+        bytes\n+    }\n+\n+    /// Returns a byte slice with leading and trailing ASCII whitespace bytes\n+    /// removed.\n+    ///\n+    /// 'Whitespace' refers to the definition used by\n+    /// `u8::is_ascii_whitespace`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(byte_slice_trim_ascii)]\n+    ///\n+    /// assert_eq!(b\"\\r hello world\\n \".trim_ascii(), b\"hello world\");\n+    /// assert_eq!(b\"  \".trim_ascii(), b\"\");\n+    /// assert_eq!(b\"\".trim_ascii(), b\"\");\n+    /// ```\n+    #[unstable(feature = \"byte_slice_trim_ascii\", issue = \"94035\")]\n+    pub const fn trim_ascii(&self) -> &[u8] {\n+        self.trim_ascii_start().trim_ascii_end()\n+    }\n }\n \n impl_fn_for_zst! {"}, {"sha": "dd9b035e86df14b5d6108a661cb7b4774683f7b4", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -41,8 +41,8 @@ dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }\n [target.x86_64-fortanix-unknown-sgx.dependencies]\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n-[target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.19\", features = ['rustc-dep-of-std'] }\n+[target.'cfg(target_os = \"hermit\")'.dependencies]\n+hermit-abi = { version = \"0.2.0\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.11.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "2628afd42379e0bd1a08538e3540801c0868460c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -311,7 +311,6 @@\n #![feature(panic_internals)]\n #![feature(panic_can_unwind)]\n #![feature(panic_unwind)]\n-#![feature(pin_static_ref)]\n #![feature(platform_intrinsics)]\n #![feature(portable_simd)]\n #![feature(prelude_import)]\n@@ -365,6 +364,10 @@ extern crate libc;\n #[allow(unused_extern_crates)]\n extern crate unwind;\n \n+#[doc(masked)]\n+#[allow(unused_extern_crates)]\n+extern crate miniz_oxide;\n+\n // During testing, this crate is not actually the \"real\" std library, but rather\n // it links to the real std library, which was compiled from this same source\n // code. So any lang items std defines are conditionally excluded (or else they"}, {"sha": "c400f5f2c2e8444edd72f816d764b7d343720426", "filename": "library/std/src/sys/hermit/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1,6 +1,6 @@\n #![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n \n-use crate::io::{self, Read, ReadBuf};\n+use crate::io::{self, Read};\n use crate::mem;\n use crate::sys::cvt;\n use crate::sys::hermit::abi;"}, {"sha": "8693e85e4742f5e41ba3e50244a9475c84f3b46d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -2056,6 +2056,7 @@ impl Step for RustDev {\n             \"llvm-bcanalyzer\",\n             \"llvm-cov\",\n             \"llvm-dwp\",\n+            \"llvm-nm\",\n         ] {\n             tarball.add_file(src_bindir.join(exe(bin, target)), \"bin\", 0o755);\n         }"}, {"sha": "fe1992a5d7e31ed5c47d4d9aa61fa99705b287e1", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -302,7 +302,11 @@ fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> S\n     // For all other types, fallback to the original `pretty_print_const`.\n     match (ct.val(), ct.ty().kind()) {\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n-            format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n+            format!(\n+                \"{}{}\",\n+                format_integer_with_underscore_sep(&int.rustdoc_display()),\n+                ui.name_str()\n+            )\n         }\n         (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n             let ty = tcx.lift(ct.ty()).unwrap();"}, {"sha": "a7f852a432c82c8db4a65a8bd64c3c0efd19a780", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -250,6 +250,8 @@ impl<'tcx> Context<'tcx> {\n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n+        let mut inserted: FxHashMap<ItemType, FxHashSet<Symbol>> = FxHashMap::default();\n+\n         for item in &m.items {\n             if item.is_stripped() {\n                 continue;\n@@ -258,13 +260,16 @@ impl<'tcx> Context<'tcx> {\n             let short = item.type_();\n             let myname = match item.name {\n                 None => continue,\n-                Some(ref s) => s.to_string(),\n+                Some(s) => s,\n             };\n-            let short = short.to_string();\n-            map.entry(short).or_default().push((\n-                myname,\n-                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n-            ));\n+            if inserted.entry(short).or_default().insert(myname) {\n+                let short = short.to_string();\n+                let myname = myname.to_string();\n+                map.entry(short).or_default().push((\n+                    myname,\n+                    Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n+                ));\n+            }\n         }\n \n         if self.shared.sort_modules_alphabetically {"}, {"sha": "03f827f63f37fe43be26ff06ffea1a069d249d7d", "filename": "src/test/mir-opt/const_prop/invalid_constant.main.ConstProp.diff", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -2,68 +2,63 @@\n + // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/invalid_constant.rs:15:11: 15:11\n-      let _1: std::option::Option<()>;     // in scope 0 at $DIR/invalid_constant.rs:16:5: 16:12\n-      let mut _2: std::option::Option<std::option::Option<()>>; // in scope 0 at $DIR/invalid_constant.rs:16:7: 16:11\n-      let _3: main::Union;                 // in scope 0 at $DIR/invalid_constant.rs:22:9: 22:22\n+      let mut _0: ();                      // return place in scope 0 at $DIR/invalid_constant.rs:13:11: 13:11\n+      let _1: main::InvalidChar;           // in scope 0 at $DIR/invalid_constant.rs:19:9: 19:22\n+      let mut _3: main::InvalidTag;        // in scope 0 at $DIR/invalid_constant.rs:26:25: 26:46\n+      let mut _5: main::NoVariants;        // in scope 0 at $DIR/invalid_constant.rs:33:35: 33:56\n       scope 1 {\n-          debug _invalid_char => _3;       // in scope 1 at $DIR/invalid_constant.rs:22:9: 22:22\n-      }\n-      scope 2 (inlined f) {                // at $DIR/invalid_constant.rs:16:5: 16:12\n-          debug x => _2;                   // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-          let mut _4: isize;               // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-          let _5: std::option::Option<()>; // in scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-          scope 3 {\n-              debug y => _5;               // in scope 3 at $DIR/invalid_constant.rs:16:5: 16:12\n+          debug _invalid_char => _1;       // in scope 1 at $DIR/invalid_constant.rs:19:9: 19:22\n+          let _2: [main::InvalidTag; 1];   // in scope 1 at $DIR/invalid_constant.rs:26:9: 26:21\n+          scope 2 {\n+              debug _invalid_tag => _2;    // in scope 2 at $DIR/invalid_constant.rs:26:9: 26:21\n+              let _4: [main::NoVariants; 1]; // in scope 2 at $DIR/invalid_constant.rs:33:9: 33:31\n+              scope 3 {\n+                  debug _enum_without_variants => _4; // in scope 3 at $DIR/invalid_constant.rs:33:9: 33:31\n+              }\n           }\n       }\n   \n       bb0: {\n-          discriminant(_2) = 0;            // scope 0 at $DIR/invalid_constant.rs:16:7: 16:11\n--         _4 = discriminant(_2);           // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n--         switchInt(move _4) -> [0_isize: bb3, otherwise: bb2]; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-+         _4 = const 0_isize;              // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-+         switchInt(const 0_isize) -> [0_isize: bb3, otherwise: bb2]; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-      }\n-  \n-      bb1: {\n--         _3 = const { Union { int: 0x110001 } }; // scope 0 at $DIR/invalid_constant.rs:22:25: 22:58\n-+         _3 = const main::Union { int: 1114113_u32, chr: {transmute(0x00110001): char} }; // scope 0 at $DIR/invalid_constant.rs:22:25: 22:58\n+          StorageLive(_1);                 // scope 0 at $DIR/invalid_constant.rs:19:9: 19:22\n+-         _1 = const { InvalidChar { int: 0x110001 } }; // scope 0 at $DIR/invalid_constant.rs:19:25: 19:64\n++         _1 = const InvalidChar { int: 1114113_u32, chr: {transmute(0x00110001): char} }; // scope 0 at $DIR/invalid_constant.rs:19:25: 19:64\n                                            // ty::Const\n-                                           // + ty: main::Union\n--                                          // + val: Unevaluated(main::{constant#0}, [main::Union], None)\n+                                           // + ty: main::InvalidChar\n+-                                          // + val: Unevaluated(main::{constant#0}, [main::InvalidChar], None)\n +                                          // + val: Value(Scalar(0x00110001))\n                                            // mir::Constant\n-                                           // + span: $DIR/invalid_constant.rs:22:25: 22:58\n--                                          // + literal: Const { ty: main::Union, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:8 ~ invalid_constant[726d]::main::{constant#0}), const_param_did: None }, substs: [main::Union], promoted: None }) }\n-+                                          // + literal: Const { ty: main::Union, val: Value(Scalar(0x00110001)) }\n-          nop;                             // scope 0 at $DIR/invalid_constant.rs:15:11: 23:2\n-          return;                          // scope 0 at $DIR/invalid_constant.rs:23:2: 23:2\n-      }\n-  \n-      bb2: {\n--         _5 = ((_2 as Some).0: std::option::Option<()>); // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n--         _1 = _5;                         // scope 3 at $DIR/invalid_constant.rs:16:5: 16:12\n-+         _5 = const Scalar(0x02): Option::<()>; // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n+                                           // + span: $DIR/invalid_constant.rs:19:25: 19:64\n+-                                          // + literal: Const { ty: main::InvalidChar, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:7 ~ invalid_constant[726d]::main::{constant#0}), const_param_did: None }, substs: [main::InvalidChar], promoted: None }) }\n++                                          // + literal: Const { ty: main::InvalidChar, val: Value(Scalar(0x00110001)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/invalid_constant.rs:26:9: 26:21\n+          StorageLive(_3);                 // scope 1 at $DIR/invalid_constant.rs:26:25: 26:46\n+          (_3.0: u32) = const 4_u32;       // scope 1 at $DIR/invalid_constant.rs:26:25: 26:46\n+-         _2 = [move _3];                  // scope 1 at $DIR/invalid_constant.rs:26:24: 26:47\n++         _2 = [const InvalidTag { int: 4_u32, e: Scalar(0x00000004): E }]; // scope 1 at $DIR/invalid_constant.rs:26:24: 26:47\n +                                          // ty::Const\n-+                                          // + ty: std::option::Option<()>\n-+                                          // + val: Value(Scalar(0x02))\n++                                          // + ty: main::InvalidTag\n++                                          // + val: Value(Scalar(0x00000004))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/invalid_constant.rs:16:5: 16:12\n-+                                          // + literal: Const { ty: std::option::Option<()>, val: Value(Scalar(0x02)) }\n-+         _1 = const Scalar(0x02): Option::<()>; // scope 3 at $DIR/invalid_constant.rs:16:5: 16:12\n++                                          // + span: $DIR/invalid_constant.rs:26:24: 26:47\n++                                          // + literal: Const { ty: main::InvalidTag, val: Value(Scalar(0x00000004)) }\n+          StorageDead(_3);                 // scope 1 at $DIR/invalid_constant.rs:26:46: 26:47\n+          StorageLive(_4);                 // scope 2 at $DIR/invalid_constant.rs:33:9: 33:31\n+          StorageLive(_5);                 // scope 2 at $DIR/invalid_constant.rs:33:35: 33:56\n+          (_5.0: u32) = const 0_u32;       // scope 2 at $DIR/invalid_constant.rs:33:35: 33:56\n+-         _4 = [move _5];                  // scope 2 at $DIR/invalid_constant.rs:33:34: 33:57\n++         _4 = [const NoVariants { int: 0_u32, empty: Scalar(<ZST>): Empty }]; // scope 2 at $DIR/invalid_constant.rs:33:34: 33:57\n +                                          // ty::Const\n-+                                          // + ty: std::option::Option<()>\n-+                                          // + val: Value(Scalar(0x02))\n++                                          // + ty: main::NoVariants\n++                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/invalid_constant.rs:16:5: 16:12\n-+                                          // + literal: Const { ty: std::option::Option<()>, val: Value(Scalar(0x02)) }\n-          goto -> bb1;                     // scope 0 at $DIR/invalid_constant.rs:10:20: 10:21\n-      }\n-  \n-      bb3: {\n-          discriminant(_1) = 0;            // scope 2 at $DIR/invalid_constant.rs:16:5: 16:12\n-          goto -> bb1;                     // scope 0 at $DIR/invalid_constant.rs:9:17: 9:21\n++                                          // + span: $DIR/invalid_constant.rs:33:34: 33:57\n++                                          // + literal: Const { ty: main::NoVariants, val: Value(Scalar(0x00000000)) }\n+          StorageDead(_5);                 // scope 2 at $DIR/invalid_constant.rs:33:56: 33:57\n+          nop;                             // scope 0 at $DIR/invalid_constant.rs:13:11: 34:2\n+          StorageDead(_4);                 // scope 2 at $DIR/invalid_constant.rs:34:1: 34:2\n+          StorageDead(_2);                 // scope 1 at $DIR/invalid_constant.rs:34:1: 34:2\n+          StorageDead(_1);                 // scope 0 at $DIR/invalid_constant.rs:34:1: 34:2\n+          return;                          // scope 0 at $DIR/invalid_constant.rs:34:2: 34:2\n       }\n   }\n   "}, {"sha": "e0879cf4800caa4219243a89c5f997fd73a26745", "filename": "src/test/mir-opt/const_prop/invalid_constant.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Finvalid_constant.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -1,23 +1,34 @@\n-// Verify that we can pretty print invalid constant introduced\n-// by constant propagation. Regression test for issue #93688.\n-//\n-// compile-flags: -Copt-level=0 -Zinline-mir\n+// Verify that we can pretty print invalid constants.\n+\n #![feature(inline_const)]\n-#[inline(always)]\n-pub fn f(x: Option<Option<()>>) -> Option<()> {\n-    match x {\n-        None => None,\n-        Some(y) => y,\n-    }\n-}\n+\n+#[derive(Copy, Clone)]\n+#[repr(u32)]\n+enum E { A, B, C }\n+\n+#[derive(Copy, Clone)]\n+enum Empty {}\n \n // EMIT_MIR invalid_constant.main.ConstProp.diff\n fn main() {\n-    f(None);\n-\n-    union Union {\n+    // An invalid char.\n+    union InvalidChar {\n         int: u32,\n         chr: char,\n     }\n-    let _invalid_char = const { Union { int: 0x110001 } };\n+    let _invalid_char = const { InvalidChar { int: 0x110001 } };\n+\n+    // An enum with an invalid tag. Regression test for #93688.\n+    union InvalidTag {\n+        int: u32,\n+        e: E,\n+    }\n+    let _invalid_tag = [InvalidTag { int: 4 }];\n+\n+    // An enum without variants. Regression test for #94073.\n+    union NoVariants {\n+        int: u32,\n+        empty: Empty,\n+    }\n+    let _enum_without_variants = [NoVariants { int: 0 }];\n }"}, {"sha": "001081798a6e439b85d31989fec216819ed24cf0", "filename": "src/test/run-make-fulldeps/static-nobundle/Makefile", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frun-make-fulldeps%2Fstatic-nobundle%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frun-make-fulldeps%2Fstatic-nobundle%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstatic-nobundle%2FMakefile?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -9,8 +9,10 @@ all: $(call NATIVE_STATICLIB,aaa)\n \t$(RUSTC) bbb.rs --crate-type=rlib\n \n \t# Check that bbb does NOT contain the definition of `native_func`\n-\tnm $(TMPDIR)/libbbb.rlib | $(CGREP) -ve \"T _*native_func\"\n-\tnm $(TMPDIR)/libbbb.rlib | $(CGREP) -e \"U _*native_func\"\n+\t# We're using the llvm-nm instead of the system nm to ensure it\n+\t# is compatible with the LLVM bitcode generated by rustc.\n+\t\"$(LLVM_BIN_DIR)/llvm-nm\" $(TMPDIR)/libbbb.rlib | $(CGREP) -ve \"T _*native_func\"\n+\t\"$(LLVM_BIN_DIR)/llvm-nm\" $(TMPDIR)/libbbb.rlib | $(CGREP) -e \"U _*native_func\"\n \n \t# Check that aaa gets linked (either as `-l aaa` or `aaa.lib`) when building ccc.\n \t$(RUSTC) ccc.rs -C prefer-dynamic --crate-type=dylib --print link-args | $(CGREP) -e '-l[\" ]*aaa|aaa\\.lib'"}, {"sha": "c79b3a220c42c85b26e53d49e87a7d2bf457c4ab", "filename": "src/test/rustdoc-gui/duplicate-macro-reexport.goml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc-gui%2Fduplicate-macro-reexport.goml", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc-gui%2Fduplicate-macro-reexport.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fduplicate-macro-reexport.goml?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -0,0 +1,14 @@\n+// This test ensures that there is no macro duplicates in the sidebar.\n+goto: file://|DOC_PATH|/test_docs/macro.a.html\n+// Waiting for the elements in the sidebar to be rendered.\n+wait-for: \".sidebar-elems .others .macro\"\n+// Check there is only one macro named \"a\" listed in the sidebar.\n+assert-count: (\n+    \"//*[@class='sidebar-elems']//*[@class='others']/*[@class='block macro']//li/a[text()='a']\",\n+    1,\n+)\n+// Check there is only one macro named \"b\" listed in the sidebar.\n+assert-count: (\n+    \"//*[@class='sidebar-elems']//*[@class='others']/*[@class='block macro']//li/a[text()='b']\",\n+    1,\n+)"}, {"sha": "348b1a65c786c8459a5e217708ee437872be0292", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -271,3 +271,6 @@ impl EmptyTrait1 for HasEmptyTraits {}\n impl EmptyTrait2 for HasEmptyTraits {}\n #[doc(cfg(feature = \"some-feature\"))]\n impl EmptyTrait3 for HasEmptyTraits {}\n+\n+mod macros;\n+pub use macros::*;"}, {"sha": "07b2b97926d43ffadc0b55ecdca2ae4a6582cb7f", "filename": "src/test/rustdoc-gui/src/test_docs/macros.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Fmacros.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -0,0 +1,4 @@\n+#[macro_export]\n+macro_rules! a{ () => {}}\n+#[macro_export]\n+macro_rules! b{ () => {}}"}, {"sha": "0ae52592b64ba1dbb30a20bca9578ffe969a8474", "filename": "src/test/rustdoc/const-value-display.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25ad89e47b5a04bdcdd36069ae12f02cc848e553/src%2Ftest%2Frustdoc%2Fconst-value-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-value-display.rs?ref=25ad89e47b5a04bdcdd36069ae12f02cc848e553", "patch": "@@ -0,0 +1,9 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/constant.HOUR_IN_SECONDS.html'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const HOUR_IN_SECONDS: u64 = 60 * 60; // 3_600u64'\n+pub const HOUR_IN_SECONDS: u64 = 60 * 60;\n+\n+// @has 'foo/constant.NEGATIVE.html'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub const NEGATIVE: i64 = -60 * 60; // -3_600i64'\n+pub const NEGATIVE: i64 = -60 * 60;"}]}