{"sha": "4f03f94863dda70ea42ce772b790a520f1490647", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMDNmOTQ4NjNkZGE3MGVhNDJjZTc3MmI3OTBhNTIwZjE0OTA2NDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-03-27T18:31:43Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-03-27T18:31:43Z"}, "message": "clarify 'remains attached', and remove recommendation to use integer arithmetic", "tree": {"sha": "2f5ecfa7bbdd41fa285e84b4f2e1e9da743a96f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f5ecfa7bbdd41fa285e84b4f2e1e9da743a96f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f03f94863dda70ea42ce772b790a520f1490647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f94863dda70ea42ce772b790a520f1490647", "html_url": "https://github.com/rust-lang/rust/commit/4f03f94863dda70ea42ce772b790a520f1490647", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f03f94863dda70ea42ce772b790a520f1490647/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5d71bfb0f229472c48554c9df4bbfedd0633430", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d71bfb0f229472c48554c9df4bbfedd0633430", "html_url": "https://github.com/rust-lang/rust/commit/b5d71bfb0f229472c48554c9df4bbfedd0633430"}], "stats": {"total": 42, "additions": 12, "deletions": 30}, "files": [{"sha": "25b8f435accf24aace4e214dcc65a2370def3cda", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f94863dda70ea42ce772b790a520f1490647/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f94863dda70ea42ce772b790a520f1490647/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=4f03f94863dda70ea42ce772b790a520f1490647", "patch": "@@ -245,8 +245,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n-    /// It may *not* be used to access a different allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -264,9 +264,6 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n     /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`offset`]: #method.offset\n     /// [allocated object]: crate::ptr#allocated-object\n     ///\n@@ -594,8 +591,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n-    /// It may *not* be used to access a different allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -613,9 +610,6 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`add`]: #method.add\n     /// [allocated object]: crate::ptr#allocated-object\n     ///\n@@ -659,8 +653,8 @@ impl<T: ?Sized> *const T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n-    /// It may *not* be used to access a different allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -678,9 +672,6 @@ impl<T: ?Sized> *const T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`sub`]: #method.sub\n     /// [allocated object]: crate::ptr#allocated-object\n     ///"}, {"sha": "732e1273b4be8ab9b402fdc4e729d8927924ccd8", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f03f94863dda70ea42ce772b790a520f1490647/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f03f94863dda70ea42ce772b790a520f1490647/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=4f03f94863dda70ea42ce772b790a520f1490647", "patch": "@@ -251,8 +251,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n-    /// It may *not* be used to access a different allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -270,9 +270,6 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n     /// words, leaving the allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`offset`]: #method.offset\n     /// [allocated object]: crate::ptr#allocated-object\n     ///\n@@ -700,8 +697,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n-    /// It may *not* be used to access a different allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -719,9 +716,6 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`add`]: #method.add\n     /// [allocated object]: crate::ptr#allocated-object\n     ///\n@@ -765,8 +759,8 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This operation itself is always safe, but using the resulting pointer is not.\n     ///\n-    /// The resulting pointer remains attached to the same [allocated object] that `self` points to.\n-    /// It may *not* be used to access a different allocated object.\n+    /// The resulting pointer \"remembers\" the [allocated object] that `self` points to; it may not\n+    /// be used to read or write other allocated objects.\n     ///\n     /// In other words, `let z = x.wrapping_sub((x as usize) - (y as usize))` does *not* make `z`\n     /// the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n@@ -784,9 +778,6 @@ impl<T: ?Sized> *mut T {\n     /// `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n     /// allocated object and then re-entering it later is permitted.\n     ///\n-    /// If you need to cross object boundaries, cast the pointer to an integer and\n-    /// do the arithmetic there.\n-    ///\n     /// [`sub`]: #method.sub\n     /// [allocated object]: crate::ptr#allocated-object\n     ///"}]}