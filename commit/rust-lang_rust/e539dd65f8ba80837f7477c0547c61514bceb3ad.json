{"sha": "e539dd65f8ba80837f7477c0547c61514bceb3ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MzlkZDY1ZjhiYTgwODM3Zjc0NzdjMDU0N2M2MTUxNGJjZWIzYWQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-07-30T01:27:50Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-08-08T02:03:42Z"}, "message": "Eliminate the `SessionGlobals` from `librustc_ast`.\n\nBy moving `{known,used}_attrs` from `SessionGlobals` to `Session`. This\nmeans they are accessed via the `Session`, rather than via TLS. A few\n`Attr` methods and `librustc_ast` functions are now methods of\n`Session`.\n\nAll of this required passing a `Session` to lots of functions that didn't\nalready have one. Some of these functions also had arguments removed, because\nthose arguments could be accessed directly via the `Session` argument.\n\n`contains_feature_attr()` was dead, and is removed.\n\nSome functions were moved from `librustc_ast` elsewhere because they now need\nto access `Session`, which isn't available in that crate.\n- `entry_point_type()` --> `librustc_builtin_macros`\n- `global_allocator_spans()` --> `librustc_metadata`\n- `is_proc_macro_attr()` --> `Session`", "tree": {"sha": "4d52e0a8cb566c47f9f189b7d11af5095d65eb2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d52e0a8cb566c47f9f189b7d11af5095d65eb2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e539dd65f8ba80837f7477c0547c61514bceb3ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e539dd65f8ba80837f7477c0547c61514bceb3ad", "html_url": "https://github.com/rust-lang/rust/commit/e539dd65f8ba80837f7477c0547c61514bceb3ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e539dd65f8ba80837f7477c0547c61514bceb3ad/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6fa011f62ee0c3b256d0be9a69369cbceb3c45b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fa011f62ee0c3b256d0be9a69369cbceb3c45b", "html_url": "https://github.com/rust-lang/rust/commit/d6fa011f62ee0c3b256d0be9a69369cbceb3c45b"}], "stats": {"total": 1621, "additions": 816, "deletions": 805}, "files": [{"sha": "de297f5153660af0288f56f5a64c58f66eb6a8f5", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -3195,7 +3195,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n- \"scoped-tls\",\n  \"smallvec 1.4.0\",\n  \"tracing\",\n ]\n@@ -3467,6 +3466,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\","}, {"sha": "ab0ab7244dbe4818adda88a98852d4105f88ab17", "filename": "src/librustc_ast/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FCargo.toml?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -12,7 +12,6 @@ doctest = false\n [dependencies]\n rustc_serialize = { path = \"../librustc_serialize\" }\n log = { package = \"tracing\", version = \"0.1\" }\n-scoped-tls = \"1.0\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }"}, {"sha": "edcbce3e2cfd34cc2bd77563427b97bbab27db50", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 12, "deletions": 85, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -10,72 +10,30 @@ use crate::ptr::P;\n use crate::token::{self, CommentKind, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n-use rustc_data_structures::sync::Lock;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::source_map::{BytePos, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n use std::iter;\n use std::ops::DerefMut;\n \n-// Per-session global variables: this struct is stored in thread-local storage\n-// in such a way that it is accessible without any kind of handle to all\n-// threads within the compilation session, but is not accessible outside the\n-// session.\n-pub struct SessionGlobals {\n-    used_attrs: Lock<GrowableBitSet<AttrId>>,\n-    known_attrs: Lock<GrowableBitSet<AttrId>>,\n-    span_session_globals: rustc_span::SessionGlobals,\n-}\n+pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n-impl SessionGlobals {\n-    fn new(edition: Edition) -> SessionGlobals {\n-        SessionGlobals {\n-            // We have no idea how many attributes there will be, so just\n-            // initiate the vectors with 0 bits. We'll grow them as necessary.\n-            used_attrs: Lock::new(GrowableBitSet::new_empty()),\n-            known_attrs: Lock::new(GrowableBitSet::new_empty()),\n-            span_session_globals: rustc_span::SessionGlobals::new(edition),\n-        }\n+impl MarkedAttrs {\n+    // We have no idea how many attributes there will be, so just\n+    // initiate the vectors with 0 bits. We'll grow them as necessary.\n+    pub fn new() -> Self {\n+        MarkedAttrs(GrowableBitSet::new_empty())\n     }\n-}\n-\n-pub fn with_session_globals<R>(edition: Edition, f: impl FnOnce() -> R) -> R {\n-    let ast_session_globals = SessionGlobals::new(edition);\n-    SESSION_GLOBALS.set(&ast_session_globals, || {\n-        rustc_span::SESSION_GLOBALS.set(&ast_session_globals.span_session_globals, f)\n-    })\n-}\n-\n-pub fn with_default_session_globals<R>(f: impl FnOnce() -> R) -> R {\n-    with_session_globals(DEFAULT_EDITION, f)\n-}\n \n-scoped_tls::scoped_thread_local!(pub static SESSION_GLOBALS: SessionGlobals);\n-\n-pub fn mark_used(attr: &Attribute) {\n-    debug!(\"marking {:?} as used\", attr);\n-    SESSION_GLOBALS.with(|session_globals| {\n-        session_globals.used_attrs.lock().insert(attr.id);\n-    });\n-}\n-\n-pub fn is_used(attr: &Attribute) -> bool {\n-    SESSION_GLOBALS.with(|session_globals| session_globals.used_attrs.lock().contains(attr.id))\n-}\n-\n-pub fn mark_known(attr: &Attribute) {\n-    debug!(\"marking {:?} as known\", attr);\n-    SESSION_GLOBALS.with(|session_globals| {\n-        session_globals.known_attrs.lock().insert(attr.id);\n-    });\n-}\n+    pub fn mark(&mut self, attr: &Attribute) {\n+        self.0.insert(attr.id);\n+    }\n \n-pub fn is_known(attr: &Attribute) -> bool {\n-    SESSION_GLOBALS.with(|session_globals| session_globals.known_attrs.lock().contains(attr.id))\n+    pub fn is_marked(&self, attr: &Attribute) -> bool {\n+        self.0.contains(attr.id)\n+    }\n }\n \n pub fn is_known_lint_tool(m_item: Ident) -> bool {\n@@ -173,21 +131,6 @@ impl Attribute {\n         }\n     }\n \n-    /// Returns `true` if the attribute's path matches the argument.\n-    /// If it matches, then the attribute is marked as used.\n-    /// Should only be used by rustc, other tools can use `has_name` instead,\n-    /// because only rustc is supposed to report the `unused_attributes` lint.\n-    /// `MetaItem` and `NestedMetaItem` are produced by \"lowering\" an `Attribute`\n-    /// and don't have identity, so they only has the `has_name` method,\n-    /// and you need to mark the original `Attribute` as used when necessary.\n-    pub fn check_name(&self, name: Symbol) -> bool {\n-        let matches = self.has_name(name);\n-        if matches {\n-            mark_used(self);\n-        }\n-        matches\n-    }\n-\n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n     pub fn ident(&self) -> Option<Ident> {\n         match self.kind {\n@@ -418,22 +361,6 @@ pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| item.has_name(name))\n }\n \n-pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n-    attrs.iter().any(|item| item.check_name(name))\n-}\n-\n-pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n-    attrs.iter().find(|attr| attr.check_name(name))\n-}\n-\n-pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n-    attrs.iter().filter(move |attr| attr.check_name(name))\n-}\n-\n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n-    attrs.iter().find(|at| at.check_name(name)).and_then(|at| at.value_str())\n-}\n-\n impl MetaItem {\n     fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n         let mut idents = vec![];"}, {"sha": "290f6006de0790f25cac9f7618e061f54a92e1a7", "filename": "src/librustc_ast/entry.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fentry.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,35 +1,7 @@\n-use crate::ast::{Item, ItemKind};\n-use crate::attr;\n-use rustc_span::symbol::sym;\n-\n pub enum EntryPointType {\n     None,\n     MainNamed,\n     MainAttr,\n     Start,\n     OtherMain, // Not an entry point, but some other function named main\n }\n-\n-// Beware, this is duplicated in librustc_middle/middle/entry.rs, make sure to keep\n-// them in sync.\n-pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n-    match item.kind {\n-        ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, sym::start) {\n-                EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, sym::main) {\n-                EntryPointType::MainAttr\n-            } else if item.ident.name == sym::main {\n-                if depth == 1 {\n-                    // This is a top-level function so can be 'main'\n-                    EntryPointType::MainNamed\n-                } else {\n-                    EntryPointType::OtherMain\n-                }\n-            } else {\n-                EntryPointType::None\n-            }\n-        }\n-        _ => EntryPointType::None,\n-    }\n-}"}, {"sha": "cd27f958e4641868450fbd841313b0b006bc3176", "filename": "src/librustc_ast/expand/allocator.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,6 +1,4 @@\n-use crate::{ast, attr, visit};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n \n #[derive(Clone, Copy)]\n pub enum AllocatorKind {\n@@ -53,25 +51,3 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         output: AllocatorTy::ResultPtr,\n     },\n ];\n-\n-pub fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder {\n-        name: Symbol,\n-        spans: Vec<Span>,\n-    }\n-    impl<'ast> visit::Visitor<'ast> for Finder {\n-        fn visit_item(&mut self, item: &'ast ast::Item) {\n-            if item.ident.name == self.name\n-                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n-            {\n-                self.spans.push(item.span);\n-            }\n-            visit::walk_item(self, item)\n-        }\n-    }\n-\n-    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n-    let mut f = Finder { name, spans: Vec::new() };\n-    visit::walk_crate(&mut f, krate);\n-    f.spans\n-}"}, {"sha": "eebfc38bdf4ec56b510cd71f35c1e33a99cfabd2", "filename": "src/librustc_ast/expand/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fexpand%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,12 +1,3 @@\n //! Definitions shared by macros / syntax extensions and e.g. librustc_middle.\n \n-use crate::ast::Attribute;\n-use rustc_span::symbol::sym;\n-\n pub mod allocator;\n-\n-pub fn is_proc_macro_attr(attr: &Attribute) -> bool {\n-    [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-        .iter()\n-        .any(|kind| attr.check_name(*kind))\n-}"}, {"sha": "3f876169d2236e4baddf2c305cf16a7bbaef517d", "filename": "src/librustc_ast/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -42,7 +42,6 @@ pub mod util {\n \n pub mod ast;\n pub mod attr;\n-pub use attr::{with_default_session_globals, with_session_globals, SESSION_GLOBALS};\n pub mod crate_disambiguator;\n pub mod entry;\n pub mod expand;"}, {"sha": "1919b9341aa341bf198f1331be42582dc8ade75b", "filename": "src/librustc_ast/util/comments/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,5 +1,5 @@\n use super::*;\n-use crate::with_default_session_globals;\n+use rustc_span::with_default_session_globals;\n \n #[test]\n fn line_doc_comments() {"}, {"sha": "7ebedbcb76a3695d519018e313bd7d1f254d7f16", "filename": "src/librustc_ast/util/lev_distance/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Futil%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast%2Futil%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Flev_distance%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -21,7 +21,7 @@ fn test_lev_distance() {\n \n #[test]\n fn test_find_best_match_for_name() {\n-    use crate::with_default_session_globals;\n+    use rustc_span::with_default_session_globals;\n     with_default_session_globals(|| {\n         let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n         assert_eq!("}, {"sha": "5186e62fbf9bc34d866b0225f96122a7c5ed8199", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -3,7 +3,6 @@ use super::{ImplTraitContext, ImplTraitPosition};\n use crate::Arena;\n \n use rustc_ast::ast::*;\n-use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n@@ -205,7 +204,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n-            if !macro_rules || attr::contains_name(&i.attrs, sym::macro_export) {\n+            if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n                 let hir_id = self.lower_node_id(i.id);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {"}, {"sha": "49bbd50db574ecff3cf5fed940eb35063baefb7c", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -37,7 +37,6 @@\n \n use rustc_ast::ast;\n use rustc_ast::ast::*;\n-use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n@@ -2215,7 +2214,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     synthetic: param\n                         .attrs\n                         .iter()\n-                        .filter(|attr| attr.check_name(sym::rustc_synthetic))\n+                        .filter(|attr| self.sess.check_name(attr, sym::rustc_synthetic))\n                         .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n                         .next(),\n                 };\n@@ -2236,7 +2235,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id: self.lower_node_id(param.id),\n             name,\n             span: param.ident.span,\n-            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n             attrs: self.lower_attrs(&param.attrs),\n             bounds: self.arena.alloc_from_iter(bounds),\n             kind,"}, {"sha": "55bcc57290d01d60ef1335fdd7f3843c179779fb", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -8,8 +8,6 @@\n \n use itertools::{Either, Itertools};\n use rustc_ast::ast::*;\n-use rustc_ast::attr;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::walk_list;\n@@ -891,11 +889,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, sym::no_mangle) {\n+        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -1027,7 +1025,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(Mod { inline, .. }) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !attr::contains_name(&item.attrs, sym::path) {\n+                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }"}, {"sha": "8f7923cf12470f44abba0acaf2297755c6f54a63", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,40 +1,44 @@\n use rustc_ast::ast::{self, AssocTyConstraint, AssocTyConstraintKind, NodeId};\n use rustc_ast::ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n-use rustc_ast::attr;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_errors::{struct_span_err, Handler};\n+use rustc_errors::struct_span_err;\n use rustc_feature::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_feature::{Features, GateIssue, UnstableFeatures};\n-use rustc_session::parse::{feature_err, feature_err_issue, ParseSess};\n+use rustc_feature::{Features, GateIssue};\n+use rustc_session::parse::{feature_err, feature_err_issue};\n+use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n use tracing::debug;\n \n macro_rules! gate_feature_fn {\n-    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n-        let (cx, has_feature, span, name, explain) = (&*$cx, $has_feature, $span, $name, $explain);\n-        let has_feature: bool = has_feature(&$cx.features);\n+    ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (visitor, has_feature, span, name, explain) =\n+            (&*$visitor, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(cx.parse_sess, name, span, GateIssue::Language, explain).emit();\n+            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n+                .emit();\n         }\n     }};\n }\n \n macro_rules! gate_feature_post {\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n-        gate_feature_fn!($cx, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n+    ($visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n     };\n }\n \n-pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    PostExpansionVisitor { parse_sess, features }.visit_attribute(attr)\n+pub fn check_attribute(attr: &ast::Attribute, sess: &Session, features: &Features) {\n+    PostExpansionVisitor { sess, features }.visit_attribute(attr)\n }\n \n struct PostExpansionVisitor<'a> {\n-    parse_sess: &'a ParseSess,\n+    sess: &'a Session,\n+\n+    // `sess` contains a `Features`, but this might not be that one.\n     features: &'a Features,\n }\n \n@@ -138,6 +142,7 @@ impl<'a> PostExpansionVisitor<'a> {\n                 );\n             }\n             abi => self\n+                .sess\n                 .parse_sess\n                 .span_diagnostic\n                 .delay_span_bug(span, &format!(\"unrecognized ABI not caught in lowering: {}\", abi)),\n@@ -167,7 +172,7 @@ impl<'a> PostExpansionVisitor<'a> {\n \n         if !discriminant_spans.is_empty() && has_fields {\n             let mut err = feature_err(\n-                self.parse_sess,\n+                &self.sess.parse_sess,\n                 sym::arbitrary_enum_discriminant,\n                 discriminant_spans.clone(),\n                 \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n@@ -240,7 +245,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_fn!(self, has_feature, attr.span, name, descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n-        if attr.check_name(sym::doc) {\n+        if self.sess.check_name(attr, sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n                     $(if nested_meta.has_name(sym::$name) {\n@@ -266,7 +271,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(\n                 &self,\n                 non_ascii_idents,\n-                self.parse_sess.source_map().guess_head_span(sp),\n+                self.sess.parse_sess.source_map().guess_head_span(sp),\n                 \"non-ascii idents are not fully supported\"\n             );\n         }\n@@ -281,15 +286,15 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n+                if self.sess.contains_name(&i.attrs[..], sym::plugin_registrar) {\n                     gate_feature_post!(\n                         &self,\n                         plugin_registrar,\n                         i.span,\n                         \"compiler plugins are experimental and possibly buggy\"\n                     );\n                 }\n-                if attr::contains_name(&i.attrs[..], sym::start) {\n+                if self.sess.contains_name(&i.attrs[..], sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -299,7 +304,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                          over time\"\n                     );\n                 }\n-                if attr::contains_name(&i.attrs[..], sym::main) {\n+                if self.sess.contains_name(&i.attrs[..], sym::main) {\n                     gate_feature_post!(\n                         &self,\n                         main,\n@@ -312,7 +317,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n+                for attr in self.sess.filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n@@ -391,7 +396,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm = match link_name {\n                     Some(val) => val.as_str().starts_with(\"llvm.\"),\n                     _ => false,\n@@ -450,7 +455,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Type(..) => {\n                 // To avoid noise about type ascription in common syntax errors, only emit if it\n                 // is the *only* error.\n-                if self.parse_sess.span_diagnostic.err_count() == 0 {\n+                if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n                     gate_feature_post!(\n                         &self,\n                         type_ascription,\n@@ -599,16 +604,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n }\n \n-pub fn check_crate(\n-    krate: &ast::Crate,\n-    parse_sess: &ParseSess,\n-    features: &Features,\n-    unstable: UnstableFeatures,\n-) {\n-    maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n-    let mut visitor = PostExpansionVisitor { parse_sess, features };\n+pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n+    maybe_stage_features(sess, krate);\n+    let mut visitor = PostExpansionVisitor { sess, features: &sess.features_untracked() };\n \n-    let spans = parse_sess.gated_spans.spans.borrow();\n+    let spans = sess.parse_sess.gated_spans.spans.borrow();\n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => {\n             for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n@@ -651,18 +651,18 @@ pub fn check_crate(\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n     // To avoid noise about type ascription in common syntax errors,\n     // only emit if it is the *only* error. (Also check it last.)\n-    if parse_sess.span_diagnostic.err_count() == 0 {\n+    if sess.parse_sess.span_diagnostic.err_count() == 0 {\n         gate_all!(type_ascription, \"type ascription is experimental\");\n     }\n \n     visit::walk_crate(&mut visitor, krate);\n }\n \n-fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n-    if !unstable.is_nightly_build() {\n-        for attr in krate.attrs.iter().filter(|attr| attr.check_name(sym::feature)) {\n+fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n+    if !sess.opts.unstable_features.is_nightly_build() {\n+        for attr in krate.attrs.iter().filter(|attr| sess.check_name(attr, sym::feature)) {\n             struct_span_err!(\n-                span_handler,\n+                sess.parse_sess.span_diagnostic,\n                 attr.span,\n                 E0554,\n                 \"`#![feature]` may not be used on the {} release channel\","}, {"sha": "fdbd073255e83cf2aaedd300be7e9496677e411b", "filename": "src/librustc_ast_pretty/pprust/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,9 +1,9 @@\n use super::*;\n \n use rustc_ast::ast;\n-use rustc_ast::with_default_session_globals;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::Ident;\n+use rustc_span::with_default_session_globals;\n \n fn fun_to_string(\n     decl: &ast::FnDecl,"}, {"sha": "552584bb4d0b9dd17920203ade73dbf12776a764", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 70, "deletions": 67, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,13 +1,12 @@\n //! Parsing and validation of builtin attributes\n \n-use super::{find_by_name, mark_used};\n-\n use rustc_ast::ast::{self, Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, Handler};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::Session;\n use rustc_span::hygiene::Transparency;\n use rustc_span::{symbol::sym, symbol::Symbol, Span};\n use std::num::NonZeroU32;\n@@ -86,9 +85,9 @@ pub enum UnwindAttr {\n }\n \n /// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n-pub fn find_unwind_attr(diagnostic: &Handler, attrs: &[Attribute]) -> Option<UnwindAttr> {\n+pub fn find_unwind_attr(sess: &Session, attrs: &[Attribute]) -> Option<UnwindAttr> {\n     attrs.iter().fold(None, |ia, attr| {\n-        if attr.check_name(sym::unwind) {\n+        if sess.check_name(attr, sym::unwind) {\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.kind {\n                     if items.len() == 1 {\n@@ -100,7 +99,7 @@ pub fn find_unwind_attr(diagnostic: &Handler, attrs: &[Attribute]) -> Option<Unw\n                     }\n \n                     struct_span_err!(\n-                        diagnostic,\n+                        sess.diagnostic(),\n                         attr.span,\n                         E0633,\n                         \"malformed `unwind` attribute input\"\n@@ -164,30 +163,18 @@ impl StabilityLevel {\n     }\n }\n \n-/// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n-/// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n-    attrs.iter().any(|item| {\n-        item.check_name(sym::feature)\n-            && item\n-                .meta_item_list()\n-                .map(|list| list.iter().any(|mi| mi.is_word() && mi.has_name(feature_name)))\n-                .unwrap_or(false)\n-    })\n-}\n-\n /// Collects stability info from all stability attributes in `attrs`.\n /// Returns `None` if no stability attributes are found.\n pub fn find_stability(\n-    sess: &ParseSess,\n+    sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n ) -> (Option<Stability>, Option<ConstStability>) {\n     find_stability_generic(sess, attrs.iter(), item_sp)\n }\n \n fn find_stability_generic<'a, I>(\n-    sess: &ParseSess,\n+    sess: &Session,\n     attrs_iter: I,\n     item_sp: Span,\n ) -> (Option<Stability>, Option<ConstStability>)\n@@ -200,7 +187,7 @@ where\n     let mut const_stab: Option<ConstStability> = None;\n     let mut promotable = false;\n     let mut allow_const_fn_ptr = false;\n-    let diagnostic = &sess.span_diagnostic;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n         if ![\n@@ -217,7 +204,7 @@ where\n             continue; // not a stability level\n         }\n \n-        mark_used(attr);\n+        sess.mark_attr_used(attr);\n \n         let meta = attr.meta();\n \n@@ -233,7 +220,7 @@ where\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(\n-                        sess,\n+                        &sess.parse_sess,\n                         meta.span,\n                         AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n                     );\n@@ -252,10 +239,18 @@ where\n             match meta_name {\n                 sym::rustc_const_unstable | sym::unstable => {\n                     if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     }\n \n@@ -321,13 +316,13 @@ where\n                                 sym::soft => {\n                                     if !mi.is_word() {\n                                         let msg = \"`soft` should not have any arguments\";\n-                                        sess.span_diagnostic.span_err(mi.span, msg);\n+                                        sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n                                     }\n                                     is_soft = true;\n                                 }\n                                 _ => {\n                                     handle_errors(\n-                                        sess,\n+                                        &sess.parse_sess,\n                                         meta.span(),\n                                         AttrError::UnknownMetaItem(\n                                             pprust::path_to_string(&mi.path),\n@@ -339,7 +334,7 @@ where\n                             }\n                         } else {\n                             handle_errors(\n-                                sess,\n+                                &sess.parse_sess,\n                                 meta.span(),\n                                 AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n                             );\n@@ -362,7 +357,7 @@ where\n                             }\n                         }\n                         (None, _, _) => {\n-                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n                             continue;\n                         }\n                         _ => {\n@@ -374,10 +369,18 @@ where\n                 }\n                 sym::rustc_const_stable | sym::stable => {\n                     if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     }\n \n@@ -398,7 +401,7 @@ where\n                                 }\n                                 _ => {\n                                     handle_errors(\n-                                        sess,\n+                                        &sess.parse_sess,\n                                         meta.span(),\n                                         AttrError::UnknownMetaItem(\n                                             pprust::path_to_string(&mi.path),\n@@ -410,7 +413,7 @@ where\n                             },\n                             NestedMetaItem::Literal(lit) => {\n                                 handle_errors(\n-                                    sess,\n+                                    &sess.parse_sess,\n                                     lit.span,\n                                     AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n                                 );\n@@ -434,11 +437,11 @@ where\n                             }\n                         }\n                         (None, _) => {\n-                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n                             continue;\n                         }\n                         _ => {\n-                            handle_errors(sess, attr.span, AttrError::MissingSince);\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n                             continue;\n                         }\n                     }\n@@ -469,8 +472,8 @@ where\n     (stab, const_stab)\n }\n \n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    super::first_attr_value_str_by_name(attrs, sym::crate_name)\n+pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n+    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n@@ -633,27 +636,24 @@ pub struct Deprecation {\n }\n \n /// Finds the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(\n-    sess: &ParseSess,\n-    attrs: &[Attribute],\n-    item_sp: Span,\n-) -> Option<Deprecation> {\n+pub fn find_deprecation(sess: &Session, attrs: &[Attribute], item_sp: Span) -> Option<Deprecation> {\n     find_deprecation_generic(sess, attrs.iter(), item_sp)\n }\n \n fn find_deprecation_generic<'a, I>(\n-    sess: &ParseSess,\n+    sess: &Session,\n     attrs_iter: I,\n     item_sp: Span,\n ) -> Option<Deprecation>\n where\n     I: Iterator<Item = &'a Attribute>,\n {\n     let mut depr: Option<Deprecation> = None;\n-    let diagnostic = &sess.span_diagnostic;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !(attr.check_name(sym::deprecated) || attr.check_name(sym::rustc_deprecated)) {\n+        if !(sess.check_name(attr, sym::deprecated) || sess.check_name(attr, sym::rustc_deprecated))\n+        {\n             continue;\n         }\n \n@@ -676,7 +676,7 @@ where\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n                         handle_errors(\n-                            sess,\n+                            &sess.parse_sess,\n                             meta.span,\n                             AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n                         );\n@@ -688,7 +688,7 @@ where\n                     } else {\n                         if let Some(lit) = meta.name_value_literal() {\n                             handle_errors(\n-                                sess,\n+                                &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n                                     \"literal in `deprecated` \\\n@@ -713,28 +713,28 @@ where\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::note if attr.check_name(sym::deprecated) => {\n+                            sym::note if sess.check_name(attr, sym::deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::reason if attr.check_name(sym::rustc_deprecated) => {\n+                            sym::reason if sess.check_name(attr, sym::rustc_deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::suggestion if attr.check_name(sym::rustc_deprecated) => {\n+                            sym::suggestion if sess.check_name(attr, sym::rustc_deprecated) => {\n                                 if !get(mi, &mut suggestion) {\n                                     continue 'outer;\n                                 }\n                             }\n                             _ => {\n                                 handle_errors(\n-                                    sess,\n+                                    &sess.parse_sess,\n                                     meta.span(),\n                                     AttrError::UnknownMetaItem(\n                                         pprust::path_to_string(&mi.path),\n-                                        if attr.check_name(sym::deprecated) {\n+                                        if sess.check_name(attr, sym::deprecated) {\n                                             &[\"since\", \"note\"]\n                                         } else {\n                                             &[\"since\", \"reason\", \"suggestion\"]\n@@ -746,7 +746,7 @@ where\n                         },\n                         NestedMetaItem::Literal(lit) => {\n                             handle_errors(\n-                                sess,\n+                                &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n                                     \"item in `deprecated` must be a key/value pair\",\n@@ -760,13 +760,13 @@ where\n             }\n         }\n \n-        if suggestion.is_some() && attr.check_name(sym::deprecated) {\n+        if suggestion.is_some() && sess.check_name(attr, sym::deprecated) {\n             unreachable!(\"only allowed on rustc_deprecated\")\n         }\n \n-        if attr.check_name(sym::rustc_deprecated) {\n+        if sess.check_name(attr, sym::rustc_deprecated) {\n             if since.is_none() {\n-                handle_errors(sess, attr.span, AttrError::MissingSince);\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n                 continue;\n             }\n \n@@ -776,9 +776,9 @@ where\n             }\n         }\n \n-        mark_used(&attr);\n+        sess.mark_attr_used(&attr);\n \n-        let is_since_rustc_version = attr.check_name(sym::rustc_deprecated);\n+        let is_since_rustc_version = sess.check_name(attr, sym::rustc_deprecated);\n         depr = Some(Deprecation { since, note, suggestion, is_since_rustc_version });\n     }\n \n@@ -821,18 +821,18 @@ impl IntType {\n /// the same discriminant size that the corresponding C enum would or C\n /// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n /// concerns to the only non-ZST field.\n-pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n+pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n     use ReprAttr::*;\n \n     let mut acc = Vec::new();\n-    let diagnostic = &sess.span_diagnostic;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n     if attr.has_name(sym::repr) {\n         if let Some(items) = attr.meta_item_list() {\n-            mark_used(attr);\n+            sess.mark_attr_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n                     handle_errors(\n-                        sess,\n+                        &sess.parse_sess,\n                         item.span(),\n                         AttrError::UnsupportedLiteral(\n                             \"meta item in `repr` must be an identifier\",\n@@ -976,13 +976,14 @@ pub enum TransparencyError {\n }\n \n pub fn find_transparency(\n+    sess: &Session,\n     attrs: &[Attribute],\n     macro_rules: bool,\n ) -> (Transparency, Option<TransparencyError>) {\n     let mut transparency = None;\n     let mut error = None;\n     for attr in attrs {\n-        if attr.check_name(sym::rustc_macro_transparency) {\n+        if sess.check_name(attr, sym::rustc_macro_transparency) {\n             if let Some((_, old_span)) = transparency {\n                 error = Some(TransparencyError::MultipleTransparencyAttrs(old_span, attr.span));\n                 break;\n@@ -1007,18 +1008,20 @@ pub fn find_transparency(\n }\n \n pub fn allow_internal_unstable<'a>(\n+    sess: &'a Session,\n     attrs: &[Attribute],\n-    diag: &'a rustc_errors::Handler,\n ) -> Option<impl Iterator<Item = Symbol> + 'a> {\n-    let attr = find_by_name(attrs, sym::allow_internal_unstable)?;\n+    let attr = sess.find_by_name(attrs, sym::allow_internal_unstable)?;\n     let list = attr.meta_item_list().or_else(|| {\n-        diag.span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n+        sess.diagnostic()\n+            .span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n         None\n     })?;\n     Some(list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n-            diag.span_err(it.span(), \"`allow_internal_unstable` expects feature names\");\n+            sess.diagnostic()\n+                .span_err(it.span(), \"`allow_internal_unstable` expects feature names\");\n         }\n         name\n     }))"}, {"sha": "0247ca329915899d82a87ca65d4c72878961194b", "filename": "src/librustc_builtin_macros/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcfg.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -19,7 +19,7 @@ pub fn expand_cfg(\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {\n-            let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n+            let matches_cfg = attr::cfg_matches(&cfg, &cx.sess.parse_sess, cx.ecfg.features);\n             MacEager::expr(cx.expr_bool(sp, matches_cfg))\n         }\n         Err(mut err) => {"}, {"sha": "7a91dde5a9d8aaacd71233e1293be6bce6006af8", "filename": "src/librustc_builtin_macros/cfg_accessible.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -37,7 +37,12 @@ impl MultiItemModifier for Expander {\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n         let attr = &ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(ecx.parse_sess, attr, sym::cfg_accessible, template);\n+        validate_attr::check_builtin_attribute(\n+            &ecx.sess.parse_sess,\n+            attr,\n+            sym::cfg_accessible,\n+            template,\n+        );\n \n         let path = match validate_input(ecx, meta_item) {\n             Some(path) => path,"}, {"sha": "2611855a3a1b5a6709de8b446a64d7c385f41c9c", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -72,7 +72,7 @@ fn default_substructure(\n         },\n         StaticEnum(..) => {\n             struct_span_err!(\n-                cx.parse_sess.span_diagnostic,\n+                &cx.sess.parse_sess.span_diagnostic,\n                 trait_span,\n                 E0665,\n                 \"`Default` cannot be derived for enums, only structs\""}, {"sha": "908aabe902434dd402d2c9fcdadd9d127d6b2f1c", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -392,7 +392,7 @@ impl<'a> TraitDef<'a> {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n-                    for r in attr::find_repr_attrs(&cx.parse_sess, attr) {\n+                    for r in attr::find_repr_attrs(&cx.sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n                             return true;\n                         }\n@@ -677,7 +677,7 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         // Just mark it now since we know that it'll end up used downstream\n-        attr::mark_used(&attr);\n+        cx.sess.mark_attr_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n             let word = rustc_ast::attr::mk_nested_word_item(Ident::new("}, {"sha": "b6f733ee93db08666d1e18b08ecb7711f24a4b59", "filename": "src/librustc_builtin_macros/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fenv.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -23,7 +23,7 @@ pub fn expand_option_env<'cx>(\n \n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(&var.as_str()).ok().as_deref().map(Symbol::intern);\n-    cx.parse_sess.env_depinfo.borrow_mut().insert((Symbol::intern(&var), value));\n+    cx.sess.parse_sess.env_depinfo.borrow_mut().insert((Symbol::intern(&var), value));\n     let e = match value {\n         None => {\n             let lt = cx.lifetime(sp, Ident::new(kw::StaticLifetime, sp));\n@@ -81,7 +81,7 @@ pub fn expand_env<'cx>(\n \n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(&*var.as_str()).ok().as_deref().map(Symbol::intern);\n-    cx.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n+    cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n             cx.span_err(sp, &msg.as_str());"}, {"sha": "ccff8aa90a8ad1a47f1b46590bda60559257c606", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -19,7 +19,7 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let not_static = |item: Annotatable| {\n-        ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n         vec![item]\n     };\n     let item = match item {"}, {"sha": "77fd71d58ef6b3227ca547d1bd9f39805ad0d826", "filename": "src/librustc_builtin_macros/llvm_asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -110,7 +110,7 @@ fn parse_inline_asm<'a>(\n                     // If we already have a string with instructions,\n                     // ending up in Asm state again is an error.\n                     return Err(struct_span_err!(\n-                        cx.parse_sess.span_diagnostic,\n+                        cx.sess.parse_sess.span_diagnostic,\n                         sp,\n                         E0660,\n                         \"malformed inline assembly\"\n@@ -171,7 +171,7 @@ fn parse_inline_asm<'a>(\n                         Some('+') => Some(Symbol::intern(&format!(\"={}\", ch.as_str()))),\n                         _ => {\n                             struct_span_err!(\n-                                cx.parse_sess.span_diagnostic,\n+                                cx.sess.parse_sess.span_diagnostic,\n                                 span,\n                                 E0661,\n                                 \"output operand constraint lacks '=' or '+'\"\n@@ -201,15 +201,15 @@ fn parse_inline_asm<'a>(\n \n                     if constraint.as_str().starts_with('=') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0662,\n                             \"input operand constraint contains '='\"\n                         )\n                         .emit();\n                     } else if constraint.as_str().starts_with('+') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0663,\n                             \"input operand constraint contains '+'\"\n@@ -236,7 +236,7 @@ fn parse_inline_asm<'a>(\n                         cx.span_warn(p.prev_token.span, \"expected a clobber, found an option\");\n                     } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0664,\n                             \"clobber should not be surrounded by braces\""}, {"sha": "4f2f066e652f1533b5e1fc4782f4802d19206fac", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2,13 +2,12 @@ use std::mem;\n \n use rustc_ast::ast::{self, NodeId};\n use rustc_ast::attr;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::hygiene::AstPass;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -42,6 +41,7 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n+    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -51,7 +51,7 @@ struct CollectProcMacros<'a> {\n }\n \n pub fn inject(\n-    sess: &ParseSess,\n+    sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n     mut krate: ast::Crate,\n     is_proc_macro_crate: bool,\n@@ -64,6 +64,7 @@ pub fn inject(\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n+        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -244,7 +245,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -263,7 +264,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if is_proc_macro_attr(&attr) {\n+            if self.sess.is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();\n@@ -331,11 +332,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             return;\n         }\n \n-        if attr.check_name(sym::proc_macro_derive) {\n+        if self.sess.check_name(attr, sym::proc_macro_derive) {\n             self.collect_custom_derive(item, attr);\n-        } else if attr.check_name(sym::proc_macro_attribute) {\n+        } else if self.sess.check_name(attr, sym::proc_macro_attribute) {\n             self.collect_attr_proc_macro(item);\n-        } else if attr.check_name(sym::proc_macro) {\n+        } else if self.sess.check_name(attr, sym::proc_macro) {\n             self.collect_bang_proc_macro(item);\n         };\n "}, {"sha": "52759fede75cefbe33b7617b99ef61333a75e023", "filename": "src/librustc_builtin_macros/standard_library_imports.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,8 +1,8 @@\n+use rustc_ast::ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::{ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::AstPass;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -11,16 +11,16 @@ use rustc_span::DUMMY_SP;\n pub fn inject(\n     mut krate: ast::Crate,\n     resolver: &mut dyn ResolverExpand,\n-    sess: &ParseSess,\n+    sess: &Session,\n     alt_std_name: Option<Symbol>,\n ) -> (ast::Crate, Option<Symbol>) {\n-    let rust_2018 = sess.edition >= Edition::Edition2018;\n+    let rust_2018 = sess.parse_sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n         return (krate, None);\n-    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n-        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n+    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n+        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]"}, {"sha": "16a95288ee83656cca01fcd75cc2adc0830d217b", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::*;\n+use rustc_session::Session;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -87,7 +88,7 @@ pub fn expand_test_or_bench(\n     };\n \n     if let ast::ItemKind::MacCall(_) = item.kind {\n-        cx.parse_sess.span_diagnostic.span_warn(\n+        cx.sess.parse_sess.span_diagnostic.span_warn(\n             item.span,\n             \"`#[test]` attribute should not be used on macros. Use `#[cfg(test)]` instead.\",\n         );\n@@ -232,9 +233,15 @@ pub fn expand_test_or_bench(\n                                         ),\n                                     ),\n                                     // ignore: true | false\n-                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n+                                    field(\n+                                        \"ignore\",\n+                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n+                                    ),\n                                     // allow_fail: true | false\n-                                    field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n+                                    field(\n+                                        \"allow_fail\",\n+                                        cx.expr_bool(sp, should_fail(&cx.sess, &item)),\n+                                    ),\n                                     // should_panic: ...\n                                     field(\n                                         \"should_panic\",\n@@ -318,18 +325,18 @@ enum ShouldPanic {\n     Yes(Option<Symbol>),\n }\n \n-fn should_ignore(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::ignore)\n+fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::ignore)\n }\n \n-fn should_fail(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::allow_fail)\n+fn should_fail(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::allow_fail)\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match attr::find_by_name(&i.attrs, sym::should_panic) {\n+    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n-            let sd = &cx.parse_sess.span_diagnostic;\n+            let sd = &cx.sess.parse_sess.span_diagnostic;\n \n             match attr.meta_item_list() {\n                 // Handle #[should_panic(expected = \"foo\")]\n@@ -393,8 +400,8 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n-    let sd = &cx.parse_sess.span_diagnostic;\n+    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let sd = &cx.sess.parse_sess.span_diagnostic;\n     if let ast::ItemKind::Fn(_, ref sig, ref generics, _) = i.kind {\n         if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n             sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n@@ -453,7 +460,7 @@ fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     };\n \n     if !has_sig {\n-        cx.parse_sess.span_diagnostic.span_err(\n+        cx.sess.parse_sess.span_diagnostic.span_err(\n             i.span,\n             \"functions used as benches must have \\\n             signature `fn(&mut Bencher) -> impl Termination`\","}, {"sha": "b21a7c1e4d572f3314035cc0c029a688e410d2a1", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -3,13 +3,13 @@\n use log::debug;\n use rustc_ast::ast;\n use rustc_ast::attr;\n-use rustc_ast::entry::{self, EntryPointType};\n+use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::hygiene::{AstPass, SyntaxContext, Transparency};\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -35,41 +35,35 @@ struct TestCtxt<'a> {\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn inject(\n-    sess: &ParseSess,\n-    resolver: &mut dyn ResolverExpand,\n-    should_test: bool,\n-    krate: &mut ast::Crate,\n-    span_diagnostic: &rustc_errors::Handler,\n-    features: &Features,\n-    panic_strategy: PanicStrategy,\n-    platform_panic_strategy: PanicStrategy,\n-    enable_panic_abort_tests: bool,\n-) {\n+pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n+    let span_diagnostic = sess.diagnostic();\n+    let panic_strategy = sess.panic_strategy();\n+    let platform_panic_strategy = sess.target.target.options.panic_strategy;\n+\n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(span_diagnostic, &krate);\n+    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n \n-    if should_test {\n-        let panic_strategy = match (panic_strategy, enable_panic_abort_tests) {\n+    if sess.opts.test {\n+        let panic_strategy = match (panic_strategy, sess.opts.debugging_opts.panic_abort_tests) {\n             (PanicStrategy::Abort, true) => PanicStrategy::Abort,\n-            (PanicStrategy::Abort, false) if panic_strategy == platform_panic_strategy => {\n-                // Silently allow compiling with panic=abort on these platforms,\n-                // but with old behavior (abort if a test fails).\n-                PanicStrategy::Unwind\n-            }\n             (PanicStrategy::Abort, false) => {\n-                span_diagnostic.err(\n-                    \"building tests with panic=abort is not supported \\\n-                                     without `-Zpanic_abort_tests`\",\n-                );\n+                if panic_strategy == platform_panic_strategy {\n+                    // Silently allow compiling with panic=abort on these platforms,\n+                    // but with old behavior (abort if a test fails).\n+                } else {\n+                    span_diagnostic.err(\n+                        \"building tests with panic=abort is not supported \\\n+                                         without `-Zpanic_abort_tests`\",\n+                    );\n+                }\n                 PanicStrategy::Unwind\n             }\n             (PanicStrategy::Unwind, _) => PanicStrategy::Unwind,\n@@ -79,7 +73,7 @@ pub fn inject(\n             resolver,\n             reexport_test_harness_main,\n             krate,\n-            features,\n+            &sess.features_untracked(),\n             panic_strategy,\n             test_runner,\n         )\n@@ -101,7 +95,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if is_test_case(&item) {\n+        if is_test_case(&self.cx.ext_cx.sess, &item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident };\n@@ -143,15 +137,39 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     }\n }\n \n+// Beware, this is duplicated in librustc_passes/entry.rs (with\n+// `rustc_hir::Item`), so make sure to keep them in sync.\n+fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+    match item.kind {\n+        ast::ItemKind::Fn(..) => {\n+            if sess.contains_name(&item.attrs, sym::start) {\n+                EntryPointType::Start\n+            } else if sess.contains_name(&item.attrs, sym::main) {\n+                EntryPointType::MainAttr\n+            } else if item.ident.name == sym::main {\n+                if depth == 1 {\n+                    // This is a top-level function so can be 'main'\n+                    EntryPointType::MainNamed\n+                } else {\n+                    EntryPointType::OtherMain\n+                }\n+            } else {\n+                EntryPointType::None\n+            }\n+        }\n+        _ => EntryPointType::None,\n+    }\n+}\n /// A folder used to remove any entry points (like fn main) because the harness\n /// generator will provide its own\n-struct EntryPointCleaner {\n+struct EntryPointCleaner<'a> {\n     // Current depth in the ast\n+    sess: &'a Session,\n     depth: usize,\n     def_site: Span,\n }\n \n-impl MutVisitor for EntryPointCleaner {\n+impl<'a> MutVisitor for EntryPointCleaner<'a> {\n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         self.depth += 1;\n         let item = noop_flat_map_item(i, self).expect_one(\"noop did something\");\n@@ -160,7 +178,7 @@ impl MutVisitor for EntryPointCleaner {\n         // Remove any #[main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry::entry_point_type(&item, self.depth) {\n+        let item = match entry_point_type(self.sess, &item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::MainAttr | EntryPointType::Start => item\n                 .map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n@@ -170,7 +188,10 @@ impl MutVisitor for EntryPointCleaner {\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n                     let attrs = attrs\n                         .into_iter()\n-                        .filter(|attr| !attr.check_name(sym::main) && !attr.check_name(sym::start))\n+                        .filter(|attr| {\n+                            !self.sess.check_name(attr, sym::main)\n+                                && !self.sess.check_name(attr, sym::start)\n+                        })\n                         .chain(iter::once(allow_dead_code))\n                         .collect();\n \n@@ -189,7 +210,7 @@ impl MutVisitor for EntryPointCleaner {\n \n /// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(\n-    sess: &ParseSess,\n+    sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n     reexport_test_harness_main: Option<Symbol>,\n     krate: &mut ast::Crate,\n@@ -211,7 +232,7 @@ fn generate_test_harness(\n     let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n \n     // Remove the entry points\n-    let mut cleaner = EntryPointCleaner { depth: 0, def_site };\n+    let mut cleaner = EntryPointCleaner { sess, depth: 0, def_site };\n     cleaner.visit_crate(krate);\n \n     let cx = TestCtxt {\n@@ -339,12 +360,16 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn is_test_case(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::rustc_test_marker)\n+fn is_test_case(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n-    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(\n+    sess: &Session,\n+    sd: &rustc_errors::Handler,\n+    krate: &ast::Crate,\n+) -> Option<ast::Path> {\n+    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {"}, {"sha": "3ee6cd739644061fa9517f5f191611f20aa4c59a", "filename": "src/librustc_builtin_macros/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_builtin_macros%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Futil.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -8,5 +8,5 @@ pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, na\n     // All the built-in macro attributes are \"words\" at the moment.\n     let template = AttributeTemplate { word: true, ..Default::default() };\n     let attr = ecx.attribute(meta_item.clone());\n-    validate_attr::check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n+    validate_attr::check_builtin_attribute(&ecx.sess.parse_sess, &attr, name, template);\n }"}, {"sha": "acfb294f7c12b220a5f4c2e316d6dc13f5839bd0", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -253,7 +253,7 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n \n             for attr in attrs {\n-                if attr.check_name(sym::thread_local) {\n+                if self.tcx.sess.check_name(attr, sym::thread_local) {\n                     llvm::set_thread_local_mode(g, self.tls_model);\n                 }\n             }"}, {"sha": "29edd66049cdcf1acebfa5fa50da949dabdab749", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -9,7 +9,6 @@ use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n use rustc_session::config::DebugInfo;\n \n-use rustc_ast::attr;\n use rustc_span::symbol::sym;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n@@ -61,8 +60,10 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>) -\n }\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n-    let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+    let omit_gdb_pretty_printer_section = cx\n+        .tcx\n+        .sess\n+        .contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     !omit_gdb_pretty_printer_section\n         && cx.sess().opts.debuginfo != DebugInfo::None"}, {"sha": "d13c2d29d1708f8547f03091127ce27c9e531724", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -9,7 +9,6 @@ use crate::{\n \n use crate::traits::*;\n use jobserver::{Acquired, Client};\n-use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n@@ -416,11 +415,12 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n+    let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n     let is_compiler_builtins =\n-        attr::contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n-    let subsystem =\n-        attr::first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n+        tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n+    let subsystem = tcx\n+        .sess\n+        .first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!("}, {"sha": "5a36df8299c0b5795d5433f4c44e2886a8ad03d8", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n-use rustc_session::{parse::ParseSess, Limit};\n+use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n@@ -790,35 +790,37 @@ impl SyntaxExtension {\n     /// Constructs a syntax extension with the given properties\n     /// and other properties converted from attributes.\n     pub fn new(\n-        sess: &ParseSess,\n+        sess: &Session,\n         kind: SyntaxExtensionKind,\n         span: Span,\n         helper_attrs: Vec<Symbol>,\n         edition: Edition,\n         name: Symbol,\n         attrs: &[ast::Attribute],\n     ) -> SyntaxExtension {\n-        let allow_internal_unstable = attr::allow_internal_unstable(&attrs, &sess.span_diagnostic)\n+        let allow_internal_unstable = attr::allow_internal_unstable(sess, &attrs)\n             .map(|features| features.collect::<Vec<Symbol>>().into());\n \n         let mut local_inner_macros = false;\n-        if let Some(macro_export) = attr::find_by_name(attrs, sym::macro_export) {\n+        if let Some(macro_export) = sess.find_by_name(attrs, sym::macro_export) {\n             if let Some(l) = macro_export.meta_item_list() {\n                 local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n             }\n         }\n \n-        let is_builtin = attr::contains_name(attrs, sym::rustc_builtin_macro);\n+        let is_builtin = sess.contains_name(attrs, sym::rustc_builtin_macro);\n         let (stability, const_stability) = attr::find_stability(&sess, attrs, span);\n         if const_stability.is_some() {\n-            sess.span_diagnostic.span_err(span, \"macros cannot have const stability attributes\");\n+            sess.parse_sess\n+                .span_diagnostic\n+                .span_err(span, \"macros cannot have const stability attributes\");\n         }\n \n         SyntaxExtension {\n             kind,\n             span,\n             allow_internal_unstable,\n-            allow_internal_unsafe: attr::contains_name(attrs, sym::allow_internal_unsafe),\n+            allow_internal_unsafe: sess.contains_name(attrs, sym::allow_internal_unsafe),\n             local_inner_macros,\n             stability,\n             deprecation: attr::find_deprecation(&sess, attrs, span),\n@@ -941,7 +943,7 @@ pub struct ExpansionData {\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n-    pub parse_sess: &'a ParseSess,\n+    pub sess: &'a Session,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub reduced_recursion_limit: Option<Limit>,\n     pub root_path: PathBuf,\n@@ -954,13 +956,13 @@ pub struct ExtCtxt<'a> {\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n-        parse_sess: &'a ParseSess,\n+        sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n         extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n-            parse_sess,\n+            sess,\n             ecfg,\n             reduced_recursion_limit: None,\n             resolver,\n@@ -988,13 +990,13 @@ impl<'a> ExtCtxt<'a> {\n         expand::MacroExpander::new(self, true)\n     }\n     pub fn new_parser_from_tts(&self, stream: TokenStream) -> parser::Parser<'a> {\n-        rustc_parse::stream_to_parser(self.parse_sess, stream, MACRO_ARGUMENTS)\n+        rustc_parse::stream_to_parser(&self.sess.parse_sess, stream, MACRO_ARGUMENTS)\n     }\n     pub fn source_map(&self) -> &'a SourceMap {\n-        self.parse_sess.source_map()\n+        self.sess.parse_sess.source_map()\n     }\n     pub fn parse_sess(&self) -> &'a ParseSess {\n-        self.parse_sess\n+        &self.sess.parse_sess\n     }\n     pub fn call_site(&self) -> Span {\n         self.current_expansion.id.expn_data().call_site\n@@ -1026,7 +1028,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n+        self.sess.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n     }\n \n     /// Emit `msg` attached to `sp`, without immediately stopping\n@@ -1035,17 +1037,17 @@ impl<'a> ExtCtxt<'a> {\n     /// Compilation will be stopped in the near future (at the end of\n     /// the macro expansion phase).\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.parse_sess.span_diagnostic.span_err(sp, msg);\n+        self.sess.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.parse_sess.span_diagnostic.span_warn(sp, msg);\n+        self.sess.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.span_bug(sp, msg);\n+        self.sess.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n     pub fn trace_macros_diag(&mut self) {\n         for (sp, notes) in self.expansions.iter() {\n-            let mut db = self.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n+            let mut db = self.sess.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n             for note in notes {\n                 db.note(note);\n             }\n@@ -1055,7 +1057,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expansions.clear();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.bug(msg);\n+        self.sess.parse_sess.span_diagnostic.bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n         self.ecfg.trace_mac"}, {"sha": "f6ddcd35068c86a5e35a95778bb3654728ca3e75", "filename": "src/librustc_expand/config.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fconfig.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -13,7 +13,8 @@ use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n };\n use rustc_parse::{parse_in, validate_attr};\n-use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::parse::feature_err;\n+use rustc_session::Session;\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -22,15 +23,14 @@ use smallvec::SmallVec;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n-    pub sess: &'a ParseSess,\n+    pub sess: &'a Session,\n     pub features: Option<&'a Features>,\n }\n \n fn get_features(\n+    sess: &Session,\n     span_handler: &Handler,\n     krate_attrs: &[ast::Attribute],\n-    crate_edition: Edition,\n-    allow_features: &Option<Vec<String>>,\n ) -> Features {\n     fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n         let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n@@ -53,6 +53,7 @@ fn get_features(\n \n     let mut features = Features::default();\n     let mut edition_enabled_features = FxHashMap::default();\n+    let crate_edition = sess.edition();\n \n     for &edition in ALL_EDITIONS {\n         if edition <= crate_edition {\n@@ -70,7 +71,7 @@ fn get_features(\n     // Process the edition umbrella feature-gates first, to ensure\n     // `edition_enabled_features` is completed before it's queried.\n     for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n+        if !sess.check_name(attr, sym::feature) {\n             continue;\n         }\n \n@@ -103,7 +104,7 @@ fn get_features(\n     }\n \n     for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n+        if !sess.check_name(attr, sym::feature) {\n             continue;\n         }\n \n@@ -165,7 +166,7 @@ fn get_features(\n                 continue;\n             }\n \n-            if let Some(allowed) = allow_features.as_ref() {\n+            if let Some(allowed) = sess.opts.debugging_opts.allow_features.as_ref() {\n                 if allowed.iter().find(|&f| name.as_str() == *f).is_none() {\n                     struct_span_err!(\n                         span_handler,\n@@ -193,16 +194,11 @@ fn get_features(\n }\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(\n-    mut krate: ast::Crate,\n-    sess: &ParseSess,\n-    edition: Edition,\n-    allow_features: &Option<Vec<String>>,\n-) -> (ast::Crate, Features) {\n+pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features) {\n     let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n \n     let unconfigured_attrs = krate.attrs.clone();\n-    let diag = &sess.span_diagnostic;\n+    let diag = &sess.parse_sess.span_diagnostic;\n     let err_count = diag.err_count();\n     let features = match strip_unconfigured.configure(krate.attrs) {\n         None => {\n@@ -213,7 +209,7 @@ pub fn features(\n         }\n         Some(attrs) => {\n             krate.attrs = attrs;\n-            let features = get_features(diag, &krate.attrs, edition, allow_features);\n+            let features = get_features(sess, diag, &krate.attrs);\n             if err_count == diag.err_count() {\n                 // Avoid reconfiguring malformed `cfg_attr`s.\n                 strip_unconfigured.features = Some(&features);\n@@ -281,9 +277,9 @@ impl<'a> StripUnconfigured<'a> {\n         }\n \n         // At this point we know the attribute is considered used.\n-        attr::mark_used(&attr);\n+        self.sess.mark_attr_used(&attr);\n \n-        if !attr::cfg_matches(&cfg_predicate, self.sess, self.features) {\n+        if !attr::cfg_matches(&cfg_predicate, &self.sess.parse_sess, self.features) {\n             return vec![];\n         }\n \n@@ -303,8 +299,10 @@ impl<'a> StripUnconfigured<'a> {\n         match attr.get_normal_item().args {\n             ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n                 let msg = \"wrong `cfg_attr` delimiters\";\n-                validate_attr::check_meta_bad_delim(self.sess, dspan, delim, msg);\n-                match parse_in(self.sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+                validate_attr::check_meta_bad_delim(&self.sess.parse_sess, dspan, delim, msg);\n+                match parse_in(&self.sess.parse_sess, tts.clone(), \"`cfg_attr` input\", |p| {\n+                    p.parse_cfg_attr()\n+                }) {\n                     Ok(r) => return Some(r),\n                     Err(mut e) => {\n                         e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n@@ -320,6 +318,7 @@ impl<'a> StripUnconfigured<'a> {\n \n     fn error_malformed_cfg_attr_missing(&self, span: Span) {\n         self.sess\n+            .parse_sess\n             .span_diagnostic\n             .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n             .span_suggestion(\n@@ -335,18 +334,18 @@ impl<'a> StripUnconfigured<'a> {\n     /// Determines if a node with the given attributes should be included in this configuration.\n     pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n-            if !is_cfg(attr) {\n+            if !is_cfg(self.sess, attr) {\n                 return true;\n             }\n-            let meta_item = match validate_attr::parse_meta(self.sess, attr) {\n+            let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n                 Ok(meta_item) => meta_item,\n                 Err(mut err) => {\n                     err.emit();\n                     return true;\n                 }\n             };\n             let error = |span, msg, suggestion: &str| {\n-                let mut err = self.sess.span_diagnostic.struct_span_err(span, msg);\n+                let mut err = self.sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n                 if !suggestion.is_empty() {\n                     err.span_suggestion(\n                         span,\n@@ -364,7 +363,9 @@ impl<'a> StripUnconfigured<'a> {\n                 Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n                 Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n                 Some([single]) => match single.meta_item() {\n-                    Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n+                    Some(meta_item) => {\n+                        attr::cfg_matches(meta_item, &self.sess.parse_sess, self.features)\n+                    }\n                     None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n                 },\n             }\n@@ -383,7 +384,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(\n-                self.sess,\n+                &self.sess.parse_sess,\n                 sym::stmt_expr_attributes,\n                 attr.span,\n                 \"attributes on expressions are experimental\",\n@@ -452,9 +453,9 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(self.sess, a)) {\n             let msg = \"removing an expression is not supported in this position\";\n-            self.sess.span_diagnostic.span_err(attr.span, msg);\n+            self.sess.parse_sess.span_diagnostic.span_err(attr.span, msg);\n         }\n \n         self.process_cfg_attrs(expr)\n@@ -527,6 +528,6 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n     }\n }\n \n-fn is_cfg(attr: &Attribute) -> bool {\n-    attr.check_name(sym::cfg)\n+fn is_cfg(sess: &Session, attr: &Attribute) -> bool {\n+    sess.check_name(attr, sym::cfg)\n }"}, {"sha": "8da56dc67e59c3b14bdb397beb53ca4751ff64a9", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n-        let attr = attr::find_by_name(item.attrs(), sym::derive);\n+        let attr = self.cx.sess.find_by_name(item.attrs(), sym::derive);\n         let span = attr.map_or(item.span(), |attr| attr.span);\n         let mut err = self\n             .cx\n@@ -566,10 +566,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let invocations = {\n             let mut collector = InvocationCollector {\n-                cfg: StripUnconfigured {\n-                    sess: self.cx.parse_sess,\n-                    features: self.cx.ecfg.features,\n-                },\n+                cfg: StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n@@ -589,8 +586,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        let mut cfg =\n-            StripUnconfigured { sess: self.cx.parse_sess, features: self.cx.ecfg.features };\n+        let mut cfg = StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features };\n         // Since the item itself has already been configured by the InvocationCollector,\n         // we know that fold result vector will contain exactly one element\n         match item {\n@@ -706,7 +702,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let tokens = item.into_tokens(self.cx.parse_sess);\n+                    let tokens = item.into_tokens(&self.cx.sess.parse_sess);\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n@@ -719,7 +715,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.parse_ast_fragment(tok_result, fragment_kind, &attr_item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n-                    match validate_attr::parse_meta(self.cx.parse_sess, &attr) {\n+                    match validate_attr::parse_meta(&self.cx.sess.parse_sess, &attr) {\n                         Ok(meta) => {\n                             let items = match expander.expand(self.cx, span, &meta, item) {\n                                 ExpandResult::Ready(items) => items,\n@@ -748,9 +744,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n                 }\n                 SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n-                    attr::mark_known(&attr);\n+                    self.cx.sess.mark_attr_known(&attr);\n                     if *mark_used {\n-                        attr::mark_used(&attr);\n+                        self.cx.sess.mark_attr_used(&attr);\n                     }\n                     item.visit_attrs(|attrs| attrs.push(attr));\n                     fragment_kind.expect_from_annotatables(iter::once(item))\n@@ -808,7 +804,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return;\n         }\n         feature_err(\n-            self.cx.parse_sess,\n+            &self.cx.sess.parse_sess,\n             sym::proc_macro_hygiene,\n             span,\n             &format!(\"custom attributes cannot be applied to {}\", kind),\n@@ -843,7 +839,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if !self.cx.ecfg.proc_macro_hygiene() {\n-            annotatable.visit_with(&mut GateProcMacroInput { parse_sess: self.cx.parse_sess });\n+            annotatable\n+                .visit_with(&mut GateProcMacroInput { parse_sess: &self.cx.sess.parse_sess });\n         }\n     }\n \n@@ -989,7 +986,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 ..ExpnData::default(\n                     ExpnKind::Macro(MacroKind::Attr, sym::derive),\n                     item.span(),\n-                    self.cx.parse_sess.edition,\n+                    self.cx.sess.parse_sess.edition,\n                     None,\n                 )\n             }),\n@@ -1049,7 +1046,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 if a.has_name(sym::derive) {\n                     *after_derive = true;\n                 }\n-                !attr::is_known(a) && !is_builtin_attr(a)\n+                !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a)\n             })\n             .map(|i| attrs.remove(i));\n         if let Some(attr) = &attr {\n@@ -1058,7 +1055,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 && !attr.has_name(sym::test)\n             {\n                 feature_err(\n-                    &self.cx.parse_sess,\n+                    &self.cx.sess.parse_sess,\n                     sym::custom_inner_attributes,\n                     attr.span,\n                     \"non-builtin inner attributes are unstable\",\n@@ -1109,8 +1106,8 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n-            validate_attr::check_meta(self.cx.parse_sess, attr);\n+            rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.sess, features);\n+            validate_attr::check_meta(&self.cx.sess.parse_sess, attr);\n \n             // macros are expanded before any lint passes so this warning has to be hardcoded\n             if attr.has_name(sym::derive) {\n@@ -1123,7 +1120,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             }\n \n             if attr.doc_str().is_some() {\n-                self.cx.parse_sess.buffer_lint_with_diagnostic(\n+                self.cx.sess.parse_sess.buffer_lint_with_diagnostic(\n                     &UNUSED_DOC_COMMENTS,\n                     attr.span,\n                     ast::CRATE_NODE_ID,\n@@ -1429,7 +1426,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n-                let sess = self.cx.parse_sess;\n+                let sess = &self.cx.sess.parse_sess;\n                 let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n \n@@ -1438,11 +1435,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let Directory { ownership, path } = if old_mod.inline {\n                     // Inline `mod foo { ... }`, but we still need to push directories.\n                     item.attrs = attrs;\n-                    push_directory(ident, &item.attrs, dir)\n+                    push_directory(&self.cx.sess, ident, &item.attrs, dir)\n                 } else {\n                     // We have an outline `mod foo;` so we need to parse the file.\n                     let (new_mod, dir) =\n-                        parse_external_mod(sess, ident, span, dir, &mut attrs, pushed);\n+                        parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n \n                     let krate = ast::Crate {\n                         span: new_mod.inner,\n@@ -1639,7 +1636,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n         // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n         // contents=\"file contents\")]` attributes\n-        if !at.check_name(sym::doc) {\n+        if !self.cx.sess.check_name(at, sym::doc) {\n             return noop_visit_attribute(at, self);\n         }\n \n@@ -1660,9 +1657,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 }\n \n                 if let Some(file) = it.value_str() {\n-                    let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+                    let err_count = self.cx.sess.parse_sess.span_diagnostic.err_count();\n                     self.check_attributes(slice::from_ref(at));\n-                    if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+                    if self.cx.sess.parse_sess.span_diagnostic.err_count() > err_count {\n                         // avoid loading the file if they haven't enabled the feature\n                         return noop_visit_attribute(at, self);\n                     }"}, {"sha": "15b2c14a2576c44ccd76af165dae3d34d3cada6f", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -19,6 +19,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n@@ -217,7 +218,7 @@ fn generic_extension<'cx>(\n     lhses: &[mbe::TokenTree],\n     rhses: &[mbe::TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n-    let sess = cx.parse_sess;\n+    let sess = &cx.sess.parse_sess;\n \n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(&arg));\n@@ -378,7 +379,7 @@ fn generic_extension<'cx>(\n \n /// Converts a macro item into a syntax extension.\n pub fn compile_declarative_macro(\n-    sess: &ParseSess,\n+    sess: &Session,\n     features: &Features,\n     def: &ast::Item,\n     edition: Edition,\n@@ -396,7 +397,7 @@ pub fn compile_declarative_macro(\n         )\n     };\n \n-    let diag = &sess.span_diagnostic;\n+    let diag = &sess.parse_sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n     let tt_spec = Some(NonterminalKind::TT);\n@@ -444,17 +445,20 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let parser = Parser::new(sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n+    let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n             let sp = token.span.substitute_dummy(def.span);\n-            sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n+            sess.parse_sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n             return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n         Error(sp, msg) => {\n-            sess.span_diagnostic.struct_span_err(sp.substitute_dummy(def.span), &msg).emit();\n+            sess.parse_sess\n+                .span_diagnostic\n+                .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                .emit();\n             return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n         ErrorReported => {\n@@ -471,17 +475,18 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess, def.id)\n-                            .pop()\n-                            .unwrap();\n-                        valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n+                        let tt =\n+                            mbe::quoted::parse(tt.clone().into(), true, &sess.parse_sess, def.id)\n+                                .pop()\n+                                .unwrap();\n+                        valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n                 }\n-                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n+                sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n             .collect::<Vec<mbe::TokenTree>>(),\n-        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n+        _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n     let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n@@ -490,29 +495,34 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(tt.clone().into(), false, sess, def.id)\n-                            .pop()\n-                            .unwrap();\n+                        return mbe::quoted::parse(\n+                            tt.clone().into(),\n+                            false,\n+                            &sess.parse_sess,\n+                            def.id,\n+                        )\n+                        .pop()\n+                        .unwrap();\n                     }\n                 }\n-                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n+                sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n             .collect::<Vec<mbe::TokenTree>>(),\n-        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\"),\n+        _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\"),\n     };\n \n     for rhs in &rhses {\n-        valid &= check_rhs(sess, rhs);\n+        valid &= check_rhs(&sess.parse_sess, rhs);\n     }\n \n     // don't abort iteration early, so that errors for multiple lhses can be reported\n     for lhs in &lhses {\n-        valid &= check_lhs_no_empty_seq(sess, slice::from_ref(lhs));\n+        valid &= check_lhs_no_empty_seq(&sess.parse_sess, slice::from_ref(lhs));\n     }\n \n-    valid &= macro_check::check_meta_variables(sess, def.id, def.span, &lhses, &rhses);\n+    valid &= macro_check::check_meta_variables(&sess.parse_sess, def.id, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n+    let (transparency, transparency_error) = attr::find_transparency(sess, &def.attrs, macro_rules);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) => {\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value))"}, {"sha": "12fe49ed585f06fb01b04d158a0366ec9265e43d", "filename": "src/librustc_expand/module.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmodule.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,8 +1,9 @@\n use rustc_ast::ast::{Attribute, Mod};\n-use rustc_ast::{attr, token};\n+use rustc_ast::token;\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::source_map::{FileName, Span};\n use rustc_span::symbol::{sym, Ident};\n \n@@ -39,7 +40,7 @@ pub struct ModulePathSuccess {\n }\n \n crate fn parse_external_mod(\n-    sess: &ParseSess,\n+    sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n     Directory { mut ownership, path }: Directory,\n@@ -53,14 +54,15 @@ crate fn parse_external_mod(\n         ownership = mp.ownership;\n \n         // Ensure file paths are acyclic.\n-        let mut included_mod_stack = sess.included_mod_stack.borrow_mut();\n-        error_on_circular_module(sess, span, &mp.path, &included_mod_stack)?;\n+        let mut included_mod_stack = sess.parse_sess.included_mod_stack.borrow_mut();\n+        error_on_circular_module(&sess.parse_sess, span, &mp.path, &included_mod_stack)?;\n         included_mod_stack.push(mp.path.clone());\n         *pop_mod_stack = true; // We have pushed, so notify caller.\n         drop(included_mod_stack);\n \n         // Actually parse the external file as a module.\n-        let mut module = new_parser_from_file(sess, &mp.path, Some(span)).parse_mod(&token::Eof)?;\n+        let mut module =\n+            new_parser_from_file(&sess.parse_sess, &mp.path, Some(span)).parse_mod(&token::Eof)?;\n         module.0.inline = false;\n         module\n     };\n@@ -98,11 +100,12 @@ fn error_on_circular_module<'a>(\n }\n \n crate fn push_directory(\n+    sess: &Session,\n     id: Ident,\n     attrs: &[Attribute],\n     Directory { mut ownership, mut path }: Directory,\n ) -> Directory {\n-    if let Some(filename) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+    if let Some(filename) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n         path.push(&*filename.as_str());\n         ownership = DirectoryOwnership::Owned { relative: None };\n     } else {\n@@ -124,14 +127,14 @@ crate fn push_directory(\n }\n \n fn submod_path<'a>(\n-    sess: &'a ParseSess,\n+    sess: &'a Session,\n     id: Ident,\n     span: Span,\n     attrs: &[Attribute],\n     ownership: DirectoryOwnership,\n     dir_path: &Path,\n ) -> PResult<'a, ModulePathSuccess> {\n-    if let Some(path) = submod_path_from_attr(attrs, dir_path) {\n+    if let Some(path) = submod_path_from_attr(sess, attrs, dir_path) {\n         let ownership = match path.file_name().and_then(|s| s.to_str()) {\n             // All `#[path]` files are treated as though they are a `mod.rs` file.\n             // This means that `mod foo;` declarations inside `#[path]`-included\n@@ -151,16 +154,16 @@ fn submod_path<'a>(\n         DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n     };\n     let ModulePath { path_exists, name, result } =\n-        default_submod_path(sess, id, span, relative, dir_path);\n+        default_submod_path(&sess.parse_sess, id, span, relative, dir_path);\n     match ownership {\n         DirectoryOwnership::Owned { .. } => Ok(result?),\n         DirectoryOwnership::UnownedViaBlock => {\n             let _ = result.map_err(|mut err| err.cancel());\n-            error_decl_mod_in_block(sess, span, path_exists, &name)\n+            error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n         }\n         DirectoryOwnership::UnownedViaMod => {\n             let _ = result.map_err(|mut err| err.cancel());\n-            error_cannot_declare_mod_here(sess, span, path_exists, &name)\n+            error_cannot_declare_mod_here(&sess.parse_sess, span, path_exists, &name)\n         }\n     }\n }\n@@ -218,9 +221,13 @@ fn error_cannot_declare_mod_here<'a, T>(\n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n // Public for rustfmt usage.\n-pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+pub fn submod_path_from_attr(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    dir_path: &Path,\n+) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n-    let path_string = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n+    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?;\n     let path_string = path_string.as_str();\n \n     // On windows, the base path might have the form"}, {"sha": "0608ccfffb858b5e6601efaf421cea30c0ed2dad", "filename": "src/librustc_expand/mut_visit/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2,9 +2,9 @@ use crate::tests::{matches_codepattern, string_to_crate};\n \n use rustc_ast::ast;\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::with_default_session_globals;\n use rustc_ast_pretty::pprust;\n use rustc_span::symbol::Ident;\n+use rustc_span::with_default_session_globals;\n \n // This version doesn't care about getting comments or doc-strings in.\n fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {"}, {"sha": "871844442839cf7fd27f1a735de3cb7be9dbc7b8", "filename": "src/librustc_expand/parse/lexer/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,12 +1,12 @@\n use rustc_ast::ast::AttrStyle;\n use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n-use rustc_ast::with_default_session_globals;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{emitter::EmitterWriter, Handler};\n use rustc_parse::lexer::StringReader;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::symbol::Symbol;\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span};\n \n use std::io;"}, {"sha": "5c9116b2f139de8a850c33b9067a6aefbcd8451d", "filename": "src/librustc_expand/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -5,13 +5,13 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::visit;\n-use rustc_ast::with_default_session_globals;\n use rustc_ast_pretty::pprust::item_to_string;\n use rustc_errors::PResult;\n use rustc_parse::new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::FilePathMapping;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, FileName, Pos, Span};\n \n use std::path::PathBuf;"}, {"sha": "85fbf3bc0d0b0d5a9813241275aaee512f94c541", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -107,7 +107,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let input = if item.pretty_printing_compatibility_hack() {\n             TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {\n-            nt_to_tokenstream(&item, ecx.parse_sess, DUMMY_SP)\n+            nt_to_tokenstream(&item, &ecx.sess.parse_sess, DUMMY_SP)\n         };\n \n         let server = proc_macro_server::Rustc::new(ecx);\n@@ -123,9 +123,9 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         };\n \n-        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n+        let error_count_before = ecx.sess.parse_sess.span_diagnostic.err_count();\n         let mut parser =\n-            rustc_parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n+            rustc_parse::stream_to_parser(&ecx.sess.parse_sess, stream, Some(\"proc-macro derive\"));\n         let mut items = vec![];\n \n         loop {\n@@ -140,7 +140,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         }\n \n         // fail if there have been errors emitted\n-        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n+        if ecx.sess.parse_sess.span_diagnostic.err_count() > error_count_before {\n             ecx.struct_span_err(span, \"proc-macro derive produced unparseable tokens\").emit();\n         }\n "}, {"sha": "dc7ba2d0424fc437ac25c4d5078329bbc9ff3d7d", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -364,7 +364,7 @@ impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         let expn_data = cx.current_expansion.id.expn_data();\n         Rustc {\n-            sess: cx.parse_sess,\n+            sess: &cx.sess.parse_sess,\n             def_site: cx.with_def_site_ctxt(expn_data.def_site),\n             call_site: cx.with_call_site_ctxt(expn_data.call_site),\n             mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),"}, {"sha": "b562a690f83612bcd96bd805ed8ba922df977b51", "filename": "src/librustc_expand/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,9 +1,9 @@\n use rustc_ast::ast;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::with_default_session_globals;\n use rustc_parse::{new_parser_from_source_str, parser::Parser, source_file_to_stream};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, MultiSpan, Span};\n \n use rustc_data_structures::sync::Lrc;"}, {"sha": "4e818e9feb08b151b435bd8130749fc354cd9a34", "filename": "src/librustc_expand/tokenstream/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2,7 +2,7 @@ use crate::tests::string_to_stream;\n \n use rustc_ast::token;\n use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree};\n-use rustc_ast::with_default_session_globals;\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span, Symbol};\n use smallvec::smallvec;\n "}, {"sha": "7acaa01764d6031dae319b3b066d521bd602b9f7", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -16,6 +16,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n+rustc_session = { path = \"../librustc_session\" }\n rustc_ast = { path = \"../librustc_ast\" }\n lazy_static = \"1\"\n log = { package = \"tracing\", version = \"0.1\" }"}, {"sha": "bf088473e1547fb562f5f3f5f34e45648ba19e6c", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -16,6 +16,7 @@ use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable_Generic;\n+use rustc_session::Session;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n@@ -141,12 +142,12 @@ impl<CTX> HashStable<CTX> for LangItem {\n /// Extracts the first `lang = \"$name\"` out of a list of attributes.\n /// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n /// are also extracted out when found.\n-pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n+pub fn extract(sess: &Session, attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| {\n         Some(match attr {\n-            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n+            _ if sess.check_name(attr, sym::lang) => (attr.value_str()?, attr.span),\n+            _ if sess.check_name(attr, sym::panic_handler) => (sym::panic_impl, attr.span),\n+            _ if sess.check_name(attr, sym::alloc_error_handler) => (sym::oom, attr.span),\n             _ => return None,\n         })\n     })"}, {"sha": "ddec2e5bc49c8b559a05d95628545a1430e7c1e7", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -5,6 +5,7 @@ use crate::{lang_items, LangItem, LanguageItems};\n \n use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n use lazy_static::lazy_static;\n@@ -20,8 +21,8 @@ lazy_static! {\n     };\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n+pub fn link_name(sess: &Session, attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    lang_items::extract(sess, attrs).and_then(|(name, _)| {\n         $(if name == sym::$name {\n             Some(sym::$sym)\n         } else)* {"}, {"sha": "df602d8bd1bea3762bb654a8bb3f865211bc0e37", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -117,7 +117,7 @@ impl IfThisChanged<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n         for attr in attrs {\n-            if attr.check_name(sym::rustc_if_this_changed) {\n+            if self.tcx.sess.check_name(attr, sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::from_def_path_hash(def_path_hash, DepKind::hir_owner),\n@@ -132,7 +132,7 @@ impl IfThisChanged<'tcx> {\n                     },\n                 };\n                 self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n-            } else if attr.check_name(sym::rustc_then_this_would_need) {\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {"}, {"sha": "ed04a947485c7d234d888276535ef3dcb4446ee8", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -57,26 +57,27 @@ struct AssertModuleSource<'tcx> {\n \n impl AssertModuleSource<'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let (expected_reuse, comp_kind) = if attr.check_name(sym::rustc_partition_reused) {\n-            (CguReuse::PreLto, ComparisonKind::AtLeast)\n-        } else if attr.check_name(sym::rustc_partition_codegened) {\n-            (CguReuse::No, ComparisonKind::Exact)\n-        } else if attr.check_name(sym::rustc_expected_cgu_reuse) {\n-            match self.field(attr, sym::kind) {\n-                sym::no => (CguReuse::No, ComparisonKind::Exact),\n-                sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n-                sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n-                sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n-                other => {\n-                    self.tcx.sess.span_fatal(\n-                        attr.span,\n-                        &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n-                    );\n+        let (expected_reuse, comp_kind) =\n+            if self.tcx.sess.check_name(attr, sym::rustc_partition_reused) {\n+                (CguReuse::PreLto, ComparisonKind::AtLeast)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_partition_codegened) {\n+                (CguReuse::No, ComparisonKind::Exact)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_expected_cgu_reuse) {\n+                match self.field(attr, sym::kind) {\n+                    sym::no => (CguReuse::No, ComparisonKind::Exact),\n+                    sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n+                    sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n+                    sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n+                    other => {\n+                        self.tcx.sess.span_fatal(\n+                            attr.span,\n+                            &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n+                        );\n+                    }\n                 }\n-            }\n-        } else {\n-            return;\n-        };\n+            } else {\n+                return;\n+            };\n \n         if !self.tcx.sess.opts.debugging_opts.query_dep_graph {\n             self.tcx.sess.span_fatal("}, {"sha": "0f254aee8e314d557002426cdbbb9d3fa0615c64", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -180,9 +180,9 @@ pub struct DirtyCleanVisitor<'tcx> {\n impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute) -> Option<Assertion> {\n-        let is_clean = if attr.check_name(sym::rustc_dirty) {\n+        let is_clean = if self.tcx.sess.check_name(attr, sym::rustc_dirty) {\n             false\n-        } else if attr.check_name(sym::rustc_clean) {\n+        } else if self.tcx.sess.check_name(attr, sym::rustc_clean) {\n             true\n         } else {\n             // skip: not rustc_clean/dirty\n@@ -523,7 +523,7 @@ pub struct FindAllAttrs<'tcx> {\n impl FindAllAttrs<'tcx> {\n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n         for attr_name in &self.attr_names {\n-            if attr.check_name(*attr_name) && check_config(self.tcx, attr) {\n+            if self.tcx.sess.check_name(attr, *attr_name) && check_config(self.tcx, attr) {\n                 return true;\n             }\n         }"}, {"sha": "4dccf273dd90fc69f6b17a343222a7aa13323da9", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -73,7 +73,7 @@ impl Compiler {\n \n /// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n-    rustc_ast::with_default_session_globals(move || {\n+    rustc_span::with_default_session_globals(move || {\n         let cfg = cfgspecs\n             .into_iter()\n             .map(|s| {"}, {"sha": "6c0343330c8c9a3a99b43e36168eca00b1c171c6", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -162,12 +162,7 @@ pub fn register_plugins<'a>(\n         )\n     });\n \n-    let (krate, features) = rustc_expand::config::features(\n-        krate,\n-        &sess.parse_sess,\n-        sess.edition(),\n-        &sess.opts.debugging_opts.allow_features,\n-    );\n+    let (krate, features) = rustc_expand::config::features(sess, krate);\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n \n@@ -244,7 +239,7 @@ fn configure_and_expand_inner<'a>(\n         let (krate, name) = rustc_builtin_macros::standard_library_imports::inject(\n             krate,\n             &mut resolver,\n-            &sess.parse_sess,\n+            &sess,\n             alt_std_name,\n         );\n         if let Some(name) = name {\n@@ -253,7 +248,7 @@ fn configure_and_expand_inner<'a>(\n         krate\n     });\n \n-    util::check_attr_crate_type(&krate.attrs, &mut resolver.lint_buffer());\n+    util::check_attr_crate_type(&sess, &krate.attrs, &mut resolver.lint_buffer());\n \n     // Expand all macros\n     krate = sess.time(\"macro_expand_crate\", || {\n@@ -300,7 +295,7 @@ fn configure_and_expand_inner<'a>(\n         };\n \n         let extern_mod_loaded = |k: &ast::Crate| pre_expansion_lint(sess, lint_store, k);\n-        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n+        let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n@@ -312,6 +307,7 @@ fn configure_and_expand_inner<'a>(\n         });\n \n         let mut missing_fragment_specifiers: Vec<_> = ecx\n+            .sess\n             .parse_sess\n             .missing_fragment_specifiers\n             .borrow()\n@@ -341,17 +337,7 @@ fn configure_and_expand_inner<'a>(\n     })?;\n \n     sess.time(\"maybe_building_test_harness\", || {\n-        rustc_builtin_macros::test_harness::inject(\n-            &sess.parse_sess,\n-            &mut resolver,\n-            sess.opts.test,\n-            &mut krate,\n-            sess.diagnostic(),\n-            &sess.features_untracked(),\n-            sess.panic_strategy(),\n-            sess.target.target.options.panic_strategy,\n-            sess.opts.debugging_opts.panic_abort_tests,\n-        )\n+        rustc_builtin_macros::test_harness::inject(&sess, &mut resolver, &mut krate)\n     });\n \n     if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n@@ -385,7 +371,7 @@ fn configure_and_expand_inner<'a>(\n             let num_crate_types = crate_types.len();\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n-                &sess.parse_sess,\n+                &sess,\n                 &mut resolver,\n                 krate,\n                 is_proc_macro_crate,\n@@ -415,12 +401,7 @@ fn configure_and_expand_inner<'a>(\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     sess.time(\"complete_gated_feature_checking\", || {\n-        rustc_ast_passes::feature_gate::check_crate(\n-            &krate,\n-            &sess.parse_sess,\n-            &sess.features_untracked(),\n-            sess.opts.unstable_features,\n-        );\n+        rustc_ast_passes::feature_gate::check_crate(&krate, sess);\n     });\n \n     // Add all buffered lints from the `ParseSess` to the `Session`."}, {"sha": "d56115fd6ac56b0c7681bcbab825cd696833c8ee", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -13,19 +12,20 @@ pub fn find(tcx: TyCtxt<'_>) -> Option<DefId> {\n fn proc_macro_decls_static(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let mut finder = Finder { decls: None };\n+    let mut finder = Finder { tcx, decls: None };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n     finder.decls.map(|id| tcx.hir().local_def_id(id).to_def_id())\n }\n \n-struct Finder {\n+struct Finder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     decls: Option<hir::HirId>,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for Finder {\n+impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if attr::contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n+        if self.tcx.sess.contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id);\n         }\n     }"}, {"sha": "d1a22c69ee0419656360495aef20f7114917765a", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -294,7 +294,7 @@ impl<'tcx> Queries<'tcx> {\n         };\n \n         let attrs = &*tcx.get_attrs(def_id.to_def_id());\n-        let attrs = attrs.iter().filter(|attr| attr.check_name(sym::rustc_error));\n+        let attrs = attrs.iter().filter(|attr| tcx.sess.check_name(attr, sym::rustc_error));\n         for attr in attrs {\n             match attr.meta_item_list() {\n                 // Check if there is a `#[rustc_error(delay_span_bug_from_inside_query)]`."}, {"sha": "e94745519a496608e1c85e21c31ed0a7eb440ed6", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -73,7 +73,7 @@ fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n // When the user supplies --test we should implicitly supply --cfg test\n #[test]\n fn test_switch_implies_cfg_test() {\n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"--test\".to_string()]).unwrap();\n         let (sess, cfg) = mk_session(matches);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n@@ -84,7 +84,7 @@ fn test_switch_implies_cfg_test() {\n // When the user supplies --test and --cfg test, don't implicitly add another --cfg test\n #[test]\n fn test_switch_implies_cfg_test_unless_cfg_test() {\n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"--test\".to_string(), \"--cfg=test\".to_string()]).unwrap();\n         let (sess, cfg) = mk_session(matches);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n@@ -96,20 +96,20 @@ fn test_switch_implies_cfg_test_unless_cfg_test() {\n \n #[test]\n fn test_can_print_warnings() {\n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n         let (sess, _) = mk_session(matches);\n         assert!(!sess.diagnostic().can_emit_warnings());\n     });\n \n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches =\n             optgroups().parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()]).unwrap();\n         let (sess, _) = mk_session(matches);\n         assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n         let (sess, _) = mk_session(matches);\n         assert!(sess.diagnostic().can_emit_warnings());"}, {"sha": "e403a60ff323b3b38e3b793bb3740a810e392d2e", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -142,7 +142,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n     crate::callbacks::setup_callbacks();\n \n     let main_handler = move || {\n-        rustc_ast::with_session_globals(edition, || {\n+        rustc_span::with_session_globals(edition, || {\n             if let Some(stderr) = stderr {\n                 io::set_panic(Some(box Sink(stderr.clone())));\n             }\n@@ -176,27 +176,21 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n \n     let with_pool = move |pool: &rayon::ThreadPool| pool.install(move || f());\n \n-    rustc_ast::with_session_globals(edition, || {\n-        rustc_ast::SESSION_GLOBALS.with(|ast_session_globals| {\n-            rustc_span::SESSION_GLOBALS.with(|span_session_globals| {\n-                // The main handler runs for each Rayon worker thread and sets\n-                // up the thread local rustc uses. ast_session_globals and\n-                // span_session_globals are captured and set on the new\n-                // threads. ty::tls::with_thread_locals sets up thread local\n-                // callbacks from librustc_ast.\n-                let main_handler = move |thread: rayon::ThreadBuilder| {\n-                    rustc_ast::SESSION_GLOBALS.set(ast_session_globals, || {\n-                        rustc_span::SESSION_GLOBALS.set(span_session_globals, || {\n-                            if let Some(stderr) = stderr {\n-                                io::set_panic(Some(box Sink(stderr.clone())));\n-                            }\n-                            thread.run()\n-                        })\n-                    })\n-                };\n+    rustc_span::with_session_globals(edition, || {\n+        rustc_span::SESSION_GLOBALS.with(|session_globals| {\n+            // The main handler runs for each Rayon worker thread and sets up\n+            // the thread local rustc uses. `session_globals` is captured and set\n+            // on the new threads.\n+            let main_handler = move |thread: rayon::ThreadBuilder| {\n+                rustc_span::SESSION_GLOBALS.set(session_globals, || {\n+                    if let Some(stderr) = stderr {\n+                        io::set_panic(Some(box Sink(stderr.clone())));\n+                    }\n+                    thread.run()\n+                })\n+            };\n \n-                config.build_scoped(main_handler, with_pool).unwrap()\n-            })\n+            config.build_scoped(main_handler, with_pool).unwrap()\n         })\n     })\n }\n@@ -407,10 +401,14 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n }\n \n-pub(crate) fn check_attr_crate_type(attrs: &[ast::Attribute], lint_buffer: &mut LintBuffer) {\n+pub(crate) fn check_attr_crate_type(\n+    sess: &Session,\n+    attrs: &[ast::Attribute],\n+    lint_buffer: &mut LintBuffer,\n+) {\n     // Unconditionally collect crate types from attributes to make them used\n     for a in attrs.iter() {\n-        if a.check_name(sym::crate_type) {\n+        if sess.check_name(a, sym::crate_type) {\n             if let Some(n) = a.value_str() {\n                 if categorize_crate_type(n).is_some() {\n                     return;\n@@ -465,7 +463,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     let attr_types: Vec<CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n-            if a.check_name(sym::crate_type) {\n+            if session.check_name(a, sym::crate_type) {\n                 match a.value_str() {\n                     Some(s) => categorize_crate_type(s),\n                     _ => None,\n@@ -531,7 +529,7 @@ pub fn build_output_filenames(\n                 .opts\n                 .crate_name\n                 .clone()\n-                .or_else(|| rustc_attr::find_crate_name(attrs).map(|n| n.to_string()))\n+                .or_else(|| rustc_attr::find_crate_name(&sess, attrs).map(|n| n.to_string()))\n                 .unwrap_or_else(|| input.filestem().to_owned());\n \n             OutputFilenames::new("}, {"sha": "c42794e00b41e0c3426169af4d7c6d1ef346b243", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -41,6 +41,7 @@ use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -237,7 +238,7 @@ impl UnsafeCode {\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(sym::allow_internal_unsafe) {\n+        if cx.sess().check_name(attr, sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, |lint| {\n                 lint.build(\n                     \"`allow_internal_unsafe` allows defining \\\n@@ -315,12 +316,12 @@ pub struct MissingDoc {\n \n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n \n-fn has_doc(attr: &ast::Attribute) -> bool {\n+fn has_doc(sess: &Session, attr: &ast::Attribute) -> bool {\n     if attr.is_doc_comment() {\n         return true;\n     }\n \n-    if !attr.check_name(sym::doc) {\n+    if !sess.check_name(attr, sym::doc) {\n         return false;\n     }\n \n@@ -377,7 +378,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| has_doc(a));\n+        let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n         if !has_doc {\n             cx.struct_span_lint(\n                 MISSING_DOCS,\n@@ -391,10 +392,10 @@ impl MissingDoc {\n }\n \n impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext<'_>, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, cx: &LateContext<'_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                attr.check_name(sym::doc)\n+                cx.sess().check_name(attr, sym::doc)\n                     && match attr.meta_item_list() {\n                         None => false,\n                         Some(l) => attr::list_contains_name(&l, sym::hidden),\n@@ -411,7 +412,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n-            let has_doc = macro_def.attrs.iter().any(|a| has_doc(a));\n+            let has_doc = macro_def.attrs.iter().any(|a| has_doc(cx.sess(), a));\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n@@ -737,7 +738,7 @@ impl EarlyLintPass for DeprecatedAttr {\n                 return;\n             }\n         }\n-        if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n+        if cx.sess().check_name(attr, sym::no_start) || cx.sess().check_name(attr, sym::crate_id) {\n             let path_str = pprust::path_to_string(&attr.get_normal_item().path);\n             let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n@@ -763,7 +764,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n \n         let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n-        if attr.is_doc_comment() || attr.check_name(sym::doc) {\n+        if attr.is_doc_comment() || cx.sess().check_name(attr, sym::doc) {\n             cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n                 let mut err = lint.build(\"unused doc comment\");\n                 err.span_label(\n@@ -819,7 +820,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -845,7 +846,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if attr::contains_name(&it.attrs, sym::no_mangle) {\n+                if cx.sess().contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n@@ -938,11 +939,11 @@ declare_lint_pass!(\n );\n \n impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n-    fn check_attribute(&mut self, ctx: &LateContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(sym::feature) {\n+    fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n+        if cx.sess().check_name(attr, sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    ctx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n+                    cx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n                         lint.build(\"unstable feature\").emit()\n                     });\n                 }\n@@ -1381,7 +1382,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             return;\n         }\n \n-        if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n+        if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n                 lint.build(\"cannot test inner items\").emit()\n             });\n@@ -2131,7 +2132,7 @@ impl ClashingExternDeclarations {\n                     overridden_link_name,\n                     tcx.get_attrs(did.to_def_id())\n                         .iter()\n-                        .find(|at| at.check_name(sym::link_name))\n+                        .find(|at| tcx.sess.check_name(at, sym::link_name))\n                         .unwrap()\n                         .span,\n                 )"}, {"sha": "145a07d8dc852d27f8a1bdbd1969983c0232564a", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -125,7 +125,7 @@ impl<'s> LintLevelsBuilder<'s> {\n             };\n \n             let meta = unwrap_or!(attr.meta(), continue);\n-            attr::mark_used(attr);\n+            self.sess.mark_attr_used(attr);\n \n             let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n "}, {"sha": "5ca6f461048c3fc2b7f70f4e7ffd974d688d74fc", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -127,7 +127,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         let has_repr_c = it\n             .attrs\n             .iter()\n-            .any(|attr| attr::find_repr_attrs(&cx.sess.parse_sess, attr).contains(&attr::ReprC));\n+            .any(|attr| attr::find_repr_attrs(&cx.sess, attr).contains(&attr::ReprC));\n \n         if has_repr_c {\n             return;\n@@ -263,7 +263,8 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n+            cx.sess()\n+                .find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -327,7 +328,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n             },\n             FnKind::ItemFn(ident, _, header, _, attrs) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && attr::contains_name(attrs, sym::no_mangle) {\n+                if header.abi != Abi::Rust && cx.sess().contains_name(attrs, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);\n@@ -407,7 +408,7 @@ impl NonUpperCaseGlobals {\n impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n-            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n+            hir::ItemKind::Static(..) if !cx.sess().contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "b4f8273d9ab680de460e163f1a8cf98ff41f70be", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -538,7 +538,7 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n             let guaranteed_nonnull_optimization = tcx\n                 .get_attrs(def.did)\n                 .iter()\n-                .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n+                .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed));\n \n             if guaranteed_nonnull_optimization {\n                 return true;\n@@ -556,6 +556,7 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n         _ => false,\n     }\n }\n+\n /// Given a non-null scalar (or transparent) type `ty`, return the nullable version of that type.\n /// If the type passed in was not scalar, returns None.\n fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {"}, {"sha": "5de9a16e098819e5161ec22488f6a6cf118d2e40", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2,7 +2,6 @@ use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast::ast;\n use rustc_ast::ast::{ExprKind, StmtKind};\n-use rustc_ast::attr;\n use rustc_ast::util::parser;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n@@ -242,7 +241,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.check_name(sym::must_use) {\n+                if cx.sess().check_name(attr, sym::must_use) {\n                     cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n                         let msg = format!(\n                             \"unused {}`{}`{} that must be used\",\n@@ -331,7 +330,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAttributes {\n             }\n         }\n \n-        if !attr::is_used(attr) {\n+        if !cx.sess().is_attr_used(attr) {\n             debug!(\"emitting warning for: {:?}\", attr);\n             cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n                 lint.build(\"unused attribute\").emit()"}, {"sha": "e15655e3794f53d71c5d6faca100935c0b830ea8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -4,8 +4,8 @@ use crate::dynamic_lib::DynamicLibrary;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n-use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n-use rustc_ast::{ast, attr};\n+use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_ast::{ast, visit};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -636,7 +636,8 @@ impl<'a> CrateLoader<'a> {\n         // compilation mode also comes into play.\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n-        let mut needs_panic_runtime = attr::contains_name(&krate.attrs, sym::needs_panic_runtime);\n+        let mut needs_panic_runtime =\n+            self.sess.contains_name(&krate.attrs, sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n@@ -716,7 +717,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {\n+        self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n                 self.sess\n                     .struct_span_err(*span2, \"cannot define multiple global allocators\")\n@@ -731,7 +732,7 @@ impl<'a> CrateLoader<'a> {\n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n-        let mut needs_allocator = attr::contains_name(&krate.attrs, sym::needs_allocator);\n+        let mut needs_allocator = self.sess.contains_name(&krate.attrs, sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             needs_allocator = needs_allocator || data.needs_allocator();\n         });\n@@ -785,7 +786,7 @@ impl<'a> CrateLoader<'a> {\n         // allocator. At this point our allocator request is typically fulfilled\n         // by the standard library, denoted by the `#![default_lib_allocator]`\n         // attribute.\n-        let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n+        let mut has_default = self.sess.contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             if data.has_default_lib_allocator() {\n                 has_default = true;\n@@ -900,7 +901,7 @@ impl<'a> CrateLoader<'a> {\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n+                let dep_kind = if self.sess.contains_name(&item.attrs, sym::no_link) {\n                     CrateDepKind::MacrosOnly\n                 } else {\n                     CrateDepKind::Explicit\n@@ -945,3 +946,26 @@ impl<'a> CrateLoader<'a> {\n         self.maybe_resolve_crate(name, CrateDepKind::Explicit, None).ok()\n     }\n }\n+\n+fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder<'a> {\n+        sess: &'a Session,\n+        name: Symbol,\n+        spans: Vec<Span>,\n+    }\n+    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name\n+                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+            {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n+    let mut f = Finder { sess, name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "d8f16796083f221112fefa187a5bb8f1e36ede33", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -5,7 +5,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n-    let mut collector = Collector { args: Vec::new() };\n+    let mut collector = Collector { tcx, args: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().item.attrs.iter() {\n@@ -19,11 +19,12 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     collector.args\n }\n \n-struct Collector {\n+struct Collector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     args: Vec<String>,\n }\n \n-impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n@@ -34,7 +35,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n         }\n \n         // First, add all of the custom #[link_args] attributes\n-        for m in it.attrs.iter().filter(|a| a.check_name(sym::link_args)) {\n+        let sess = &self.tcx.sess;\n+        for m in it.attrs.iter().filter(|a| sess.check_name(a, sym::link_args)) {\n             if let Some(linkarg) = m.value_str() {\n                 self.add_link_args(linkarg);\n             }\n@@ -45,7 +47,7 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n-impl Collector {\n+impl<'tcx> Collector<'tcx> {\n     fn add_link_args(&mut self, args: Symbol) {\n         self.args.extend(args.as_str().split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()))\n     }"}, {"sha": "3976475cb063e4b02713d983f32a90ceb9dd1e91", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -43,7 +43,8 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        for m in it.attrs.iter().filter(|a| a.check_name(sym::link)) {\n+        let sess = &self.tcx.sess;\n+        for m in it.attrs.iter().filter(|a| sess.check_name(a, sym::link)) {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,\n@@ -71,16 +72,10 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         \"framework\" => NativeLibKind::Framework,\n                         \"raw-dylib\" => NativeLibKind::RawDylib,\n                         k => {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                item.span(),\n-                                E0458,\n-                                \"unknown kind: `{}`\",\n-                                k\n-                            )\n-                            .span_label(item.span(), \"unknown kind\")\n-                            .span_label(m.span, \"\")\n-                            .emit();\n+                            struct_span_err!(sess, item.span(), E0458, \"unknown kind: `{}`\", k)\n+                                .span_label(item.span(), \"unknown kind\")\n+                                .span_label(m.span, \"\")\n+                                .emit();\n                             NativeLibKind::Unspecified\n                         }\n                     };\n@@ -92,18 +87,18 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         None => continue, // skip like historical compilers\n                     };\n                     if cfg.is_empty() {\n-                        self.tcx.sess.span_err(item.span(), \"`cfg()` must have an argument\");\n+                        sess.span_err(item.span(), \"`cfg()` must have an argument\");\n                     } else if let cfg @ Some(..) = cfg[0].meta_item() {\n                         lib.cfg = cfg.cloned();\n                     } else {\n-                        self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n+                        sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n                 } else if item.has_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {\n                             let msg = \"must be of the form `#[link(wasm_import_module = \\\"...\\\")]`\";\n-                            self.tcx.sess.span_err(item.span(), msg);\n+                            sess.span_err(item.span(), msg);\n                         }\n                     }\n                 } else {\n@@ -117,7 +112,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n             let requires_name = kind_specified || lib.wasm_import_module.is_none();\n             if lib.name.is_none() && requires_name {\n                 struct_span_err!(\n-                    self.tcx.sess,\n+                    sess,\n                     m.span,\n                     E0459,\n                     \"`#[link(...)]` specified without \\"}, {"sha": "8aea9a9f5885061312aa0c18e9710bf22bf57cb9", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -742,7 +742,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         SyntaxExtension::new(\n-            &sess.parse_sess,\n+            sess,\n             kind,\n             self.get_span(id, sess),\n             helper_attrs,\n@@ -1102,7 +1102,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                 // for other constructors correct visibilities\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n-                                if attr::contains_name(&attrs, sym::non_exhaustive) {\n+                                if sess.contains_name(&attrs, sym::non_exhaustive) {\n                                     let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }"}, {"sha": "10b89cdd15a527baf88b75007bbcbadfe30adff8", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -5,7 +5,6 @@ use crate::native_libs;\n use crate::rmeta::{self, encoder};\n \n use rustc_ast::ast;\n-use rustc_ast::attr;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n@@ -415,7 +414,7 @@ impl CStore {\n         // Mark the attrs as used\n         let attrs = data.get_item_attrs(id.index, sess);\n         for attr in attrs.iter() {\n-            attr::mark_used(attr);\n+            sess.mark_attr_used(attr);\n         }\n \n         let ident = data.item_ident(id.index, sess);"}, {"sha": "20dde10a2c19bd35d4645321212cabe14dd95622", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -3,7 +3,6 @@ use crate::rmeta::*;\n \n use log::{debug, trace};\n use rustc_ast::ast;\n-use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -633,7 +632,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let source_map_bytes = self.position() - i;\n \n         let attrs = tcx.hir().krate_attrs();\n-        let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n+        let has_default_lib_allocator = tcx.sess.contains_name(&attrs, sym::default_lib_allocator);\n \n         let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n@@ -659,12 +658,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n-            needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n-            needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n-            no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n-            panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n-            profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n+            compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n+            needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n+            needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n+            no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n+            panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n+            profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n             symbol_mangling_version: tcx.sess.opts.debugging_opts.symbol_mangling_version,\n \n             crate_deps,"}, {"sha": "e982053948479c59c8b75130b5dbeaf0021441b6", "filename": "src/librustc_middle/middle/limits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -27,7 +27,7 @@ fn update_limit(\n     default: usize,\n ) {\n     for attr in &krate.attrs {\n-        if !attr.check_name(name) {\n+        if !sess.check_name(attr, name) {\n             continue;\n         }\n "}, {"sha": "c271d4f25edb0761e4cce2f13ff8ebe3655a21c8", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1040,7 +1040,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n         let attrs = self.get_attrs(def_id);\n         let get = |name| {\n-            let attr = match attrs.iter().find(|a| a.check_name(name)) {\n+            let attr = match attrs.iter().find(|a| self.sess.check_name(a, name)) {\n                 Some(attr) => attr,\n                 None => return Bound::Unbounded,\n             };\n@@ -2736,11 +2736,11 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n+        tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n+        tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n     };\n     providers.has_panic_handler = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "0102225b9b56773e790a396afb30be831cb8f17f", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2265,7 +2265,7 @@ impl ReprOptions {\n         let mut max_align: Option<Align> = None;\n         let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n+            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n@@ -2382,7 +2382,7 @@ impl<'tcx> AdtDef {\n         }\n \n         let attrs = tcx.get_attrs(did);\n-        if attr::contains_name(&attrs, sym::fundamental) {\n+        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n@@ -3021,7 +3021,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Determines whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n-        attr::contains_name(&self.get_attrs(did), attr)\n+        self.sess.contains_name(&self.get_attrs(did), attr)\n     }\n \n     /// Returns `true` if this is an `auto trait`."}, {"sha": "bd2e7747b7db8abb8e46db49284c550fb294fe97", "filename": "src/librustc_middle/ty/query/job.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -15,16 +15,12 @@ pub unsafe fn handle_deadlock() {\n     rustc_data_structures::sync::assert_sync::<tls::ImplicitCtxt<'_, '_>>();\n     let icx: &tls::ImplicitCtxt<'_, '_> = &*(context as *const tls::ImplicitCtxt<'_, '_>);\n \n-    let span_session_globals = rustc_span::SESSION_GLOBALS.with(|ssg| ssg as *const _);\n-    let span_session_globals = &*span_session_globals;\n-    let ast_session_globals = rustc_ast::attr::SESSION_GLOBALS.with(|asg| asg as *const _);\n-    let ast_session_globals = &*ast_session_globals;\n+    let session_globals = rustc_span::SESSION_GLOBALS.with(|sg| sg as *const _);\n+    let session_globals = &*session_globals;\n     thread::spawn(move || {\n         tls::enter_context(icx, |_| {\n-            rustc_ast::attr::SESSION_GLOBALS.set(ast_session_globals, || {\n-                rustc_span::SESSION_GLOBALS\n-                    .set(span_session_globals, || tls::with(|tcx| deadlock(tcx, &registry)))\n-            });\n+            rustc_span::SESSION_GLOBALS\n+                .set(session_globals, || tls::with(|tcx| deadlock(tcx, &registry)))\n         })\n     });\n }"}, {"sha": "89e2d7088f7b6b75c29aad6438711857cead658b", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -335,7 +335,7 @@ impl RustcMirAttrs {\n \n         let rustc_mir_attrs = attrs\n             .iter()\n-            .filter(|attr| attr.check_name(sym::rustc_mir))\n+            .filter(|attr| tcx.sess.check_name(attr, sym::rustc_mir))\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {"}, {"sha": "fdec5729a542591688ea7e93ecee91d67f56fd50", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,5 +1,6 @@\n use rustc_ast::ast::{self, MetaItem};\n use rustc_middle::ty;\n+use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n@@ -28,9 +29,13 @@ pub struct MoveDataParamEnv<'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n+pub(crate) fn has_rustc_mir_with(\n+    sess: &Session,\n+    attrs: &[ast::Attribute],\n+    name: Symbol,\n+) -> Option<MetaItem> {\n     for attr in attrs {\n-        if attr.check_name(sym::rustc_mir) {\n+        if sess.check_name(attr, sym::rustc_mir) {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {"}, {"sha": "592c809c1dec68cbd974171879e7e79644fc017d", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -170,7 +170,11 @@ fn emit_unused_generic_params_error<'tcx>(\n ) {\n     debug!(\"emit_unused_generic_params_error: def_id={:?}\", def_id);\n     let base_def_id = tcx.closure_base_def_id(def_id);\n-    if !tcx.get_attrs(base_def_id).iter().any(|a| a.check_name(sym::rustc_polymorphize_error)) {\n+    if !tcx\n+        .get_attrs(base_def_id)\n+        .iter()\n+        .any(|a| tcx.sess.check_name(a, sym::rustc_polymorphize_error))\n+    {\n         return;\n     }\n "}, {"sha": "c0564105701575f20c9c00150f3be4d61ce602f9", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -130,7 +130,7 @@ impl Candidate {\n \n fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n+    let attr = attrs.iter().find(|a| tcx.sess.check_name(a, sym::rustc_args_required_const))?;\n     let mut ret = vec![];\n     for meta in attr.meta_item_list()? {\n         match meta.literal()?.kind {"}, {"sha": "dfd01e27d57c99bfbed9259f31104ae9ef2aa704", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -342,7 +342,7 @@ fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n \n@@ -362,7 +362,7 @@ pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n "}, {"sha": "729e22a94dcbb9a003dc72e40607b71a5a2fd92d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -35,47 +35,48 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data, param_env };\n+        let sess = &tcx.sess;\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_init).is_some() {\n             let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_uninit).is_some() {\n             let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_definite_init).is_some() {\n             let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n             let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_mut_borrowed);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_liveness).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n             let flow_liveness =\n                 MaybeLiveLocals.into_engine(tcx, body, def_id).iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_liveness);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }"}, {"sha": "f3f3c3e33a46d1f64d7191a8419bb2fb5eedfe91", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -537,7 +537,7 @@ macro_rules! unpack {\n fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, _abi: Abi) -> bool {\n     // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n     let attrs = &tcx.get_attrs(fn_def_id.to_def_id());\n-    let unwind_attr = attr::find_unwind_attr(tcx.sess.diagnostic(), attrs);\n+    let unwind_attr = attr::find_unwind_attr(&tcx.sess, attrs);\n \n     // We never unwind, so it's not relevant to stop an unwind.\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind {"}, {"sha": "bb814ab8248836370c5ffd0ac4ad4c7a0cdaa294", "filename": "src/librustc_mir_build/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -6,7 +6,6 @@ use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n \n use rustc_ast::ast;\n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n@@ -69,7 +68,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n \n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();"}, {"sha": "d438fe35ff488481daa12be6d01e69b5640ef545", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -9,7 +9,6 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n \n use rustc_ast::ast::{Attribute, NestedMetaItem};\n-use rustc_ast::attr;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -60,17 +59,17 @@ impl CheckAttrVisitor<'tcx> {\n     ) {\n         let mut is_valid = true;\n         for attr in attrs {\n-            is_valid &= if attr.check_name(sym::inline) {\n+            is_valid &= if self.tcx.sess.check_name(attr, sym::inline) {\n                 self.check_inline(hir_id, attr, span, target)\n-            } else if attr.check_name(sym::non_exhaustive) {\n+            } else if self.tcx.sess.check_name(attr, sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, span, target)\n-            } else if attr.check_name(sym::marker) {\n+            } else if self.tcx.sess.check_name(attr, sym::marker) {\n                 self.check_marker(attr, span, target)\n-            } else if attr.check_name(sym::target_feature) {\n+            } else if self.tcx.sess.check_name(attr, sym::target_feature) {\n                 self.check_target_feature(attr, span, target)\n-            } else if attr.check_name(sym::track_caller) {\n+            } else if self.tcx.sess.check_name(attr, sym::track_caller) {\n                 self.check_track_caller(&attr.span, attrs, span, target)\n-            } else if attr.check_name(sym::doc) {\n+            } else if self.tcx.sess.check_name(attr, sym::doc) {\n                 self.check_doc_alias(attr)\n             } else {\n                 true\n@@ -144,7 +143,7 @@ impl CheckAttrVisitor<'tcx> {\n         target: Target,\n     ) -> bool {\n         match target {\n-            _ if attr::contains_name(attrs, sym::naked) => {\n+            _ if self.tcx.sess.contains_name(attrs, sym::naked) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n                     *attr_span,\n@@ -262,7 +261,7 @@ impl CheckAttrVisitor<'tcx> {\n         // ```\n         let hints: Vec<_> = attrs\n             .iter()\n-            .filter(|attr| attr.check_name(sym::repr))\n+            .filter(|attr| self.tcx.sess.check_name(attr, sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -391,10 +390,10 @@ impl CheckAttrVisitor<'tcx> {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n-                if attr.check_name(sym::inline) {\n+                if self.tcx.sess.check_name(attr, sym::inline) {\n                     self.check_inline(l.hir_id, attr, &stmt.span, Target::Statement);\n                 }\n-                if attr.check_name(sym::repr) {\n+                if self.tcx.sess.check_name(attr, sym::repr) {\n                     self.emit_repr_error(\n                         attr.span,\n                         stmt.span,\n@@ -412,10 +411,10 @@ impl CheckAttrVisitor<'tcx> {\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {\n-            if attr.check_name(sym::inline) {\n+            if self.tcx.sess.check_name(attr, sym::inline) {\n                 self.check_inline(expr.hir_id, attr, &expr.span, target);\n             }\n-            if attr.check_name(sym::repr) {\n+            if self.tcx.sess.check_name(attr, sym::repr) {\n                 self.emit_repr_error(\n                     attr.span,\n                     expr.span,\n@@ -431,7 +430,7 @@ impl CheckAttrVisitor<'tcx> {\n \n     fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n         for attr in attrs {\n-            if attr.check_name(sym::used) && target != Target::Static {\n+            if self.tcx.sess.check_name(attr, sym::used) && target != Target::Static {\n                 self.tcx\n                     .sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");"}, {"sha": "dd0bcbf208d7c1d355a4d3469f2ec9007b9b62dc", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n             // opt-in via `allow_internal_unstable`.\n-            attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+            attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n                 .map_or(false, |mut features| features.any(|name| name == feature_gate))\n         };\n "}, {"sha": "0e5298acc2cafbcd333218205c00a40ac56d5116", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::middle::privacy;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n \n-use rustc_ast::{ast, attr};\n+use rustc_ast::ast;\n use rustc_span::symbol::{sym, Symbol};\n \n // Any local node that may call something in its body block should be\n@@ -331,17 +331,17 @@ fn has_allow_dead_code_or_lang_attr(\n     id: hir::HirId,\n     attrs: &[ast::Attribute],\n ) -> bool {\n-    if attr::contains_name(attrs, sym::lang) {\n+    if tcx.sess.contains_name(attrs, sym::lang) {\n         return true;\n     }\n \n     // Stable attribute for #[lang = \"panic_impl\"]\n-    if attr::contains_name(attrs, sym::panic_handler) {\n+    if tcx.sess.contains_name(attrs, sym::panic_handler) {\n         return true;\n     }\n \n     // (To be) stable attribute for #[lang = \"oom\"]\n-    if attr::contains_name(attrs, sym::alloc_error_handler) {\n+    if tcx.sess.contains_name(attrs, sym::alloc_error_handler) {\n         return true;\n     }\n "}, {"sha": "fa59337b0f66b69bcdf88a16cb237f2a1692de5b", "filename": "src/librustc_passes/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostic_items.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n struct DiagnosticItemCollector<'tcx> {\n@@ -44,7 +45,7 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n     }\n \n     fn observe_item(&mut self, attrs: &[ast::Attribute], hir_id: hir::HirId) {\n-        if let Some(name) = extract(attrs) {\n+        if let Some(name) = extract(&self.tcx.sess, attrs) {\n             let def_id = self.tcx.hir().local_def_id(hir_id);\n             // insert into our table\n             collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n@@ -86,9 +87,9 @@ fn collect_item(\n }\n \n /// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n-fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+fn extract(sess: &Session, attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().find_map(|attr| {\n-        if attr.check_name(sym::rustc_diagnostic_item) { attr.value_str() } else { None }\n+        if sess.check_name(attr, sym::rustc_diagnostic_item) { attr.value_str() } else { None }\n     })\n }\n "}, {"sha": "8aa6e7936bef61b391c65891539799dc6a00b320", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{CrateNum, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -58,7 +57,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(&tcx.hir().krate().item.attrs, sym::no_main) {\n+    if tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_main) {\n         return None;\n     }\n \n@@ -76,14 +75,14 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)\n     configure_main(tcx, &ctxt)\n }\n \n-// Beware, this is duplicated in `librustc_ast/entry.rs`, so make sure to keep\n-// them in sync.\n-fn entry_point_type(item: &Item<'_>, at_root: bool) -> EntryPointType {\n+// Beware, this is duplicated in `librustc_builtin_macros/test_harness.rs`\n+// (with `ast::Item`), so make sure to keep them in sync.\n+fn entry_point_type(sess: &Session, item: &Item<'_>, at_root: bool) -> EntryPointType {\n     match item.kind {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, sym::start) {\n+            if sess.contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, sym::main) {\n+            } else if sess.contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n                 if at_root {\n@@ -101,7 +100,7 @@ fn entry_point_type(item: &Item<'_>, at_root: bool) -> EntryPointType {\n }\n \n fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n-    match entry_point_type(item, at_root) {\n+    match entry_point_type(&ctxt.session, item, at_root) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n                 ctxt.main_fn = Some((item.hir_id, item.span));"}, {"sha": "f97ac26f4b7ce1b21a25de0154be98dc31a55c46", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -56,7 +56,7 @@ impl LanguageItemCollector<'tcx> {\n     }\n \n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId, attrs: &[Attribute]) {\n-        if let Some((value, span)) = extract(&attrs) {\n+        if let Some((value, span)) = extract(&self.tcx.sess, &attrs) {\n             match ITEM_REFS.get(&value).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {"}, {"sha": "9450d75620a8bc52143575848fafac9874cff598", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -29,7 +29,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n                 for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n-                    if attr.check_name(sym::rustc_layout) {\n+                    if self.tcx.sess.check_name(attr, sym::rustc_layout) {\n                         self.dump_layout_of(item_def_id, item, attr);\n                     }\n                 }"}, {"sha": "9a4aa6a68a6c6a5bf597ecbfe2c8256ff4f0bf5f", "filename": "src/librustc_passes/lib_features.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib_features.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -34,7 +34,9 @@ impl LibFeatureCollector<'tcx> {\n \n         // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n-        if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.check_name(**stab_attr)) {\n+        if let Some(stab_attr) =\n+            stab_attrs.iter().find(|stab_attr| self.tcx.sess.check_name(attr, **stab_attr))\n+        {\n             let meta_item = attr.meta();\n             if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta_item {\n                 let mut feature = None;"}, {"sha": "6477f8da008adcf053c8a117fd3b0a5b6653384a", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -355,7 +355,7 @@ fn visit_fn<'tcx>(\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir().get_parent_item(id);\n         if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n-            if i.attrs.iter().any(|a| a.check_name(sym::automatically_derived)) {\n+            if i.attrs.iter().any(|a| ir.tcx.sess.check_name(a, sym::automatically_derived)) {\n                 return;\n             }\n         }"}, {"sha": "1af77ae61c7f4c594111f0bd48631914523048d3", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -65,11 +65,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             did_error = self.forbid_staged_api_attrs(hir_id, attrs);\n         }\n \n-        let depr = if did_error {\n-            None\n-        } else {\n-            attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp)\n-        };\n+        let depr =\n+            if did_error { None } else { attr::find_deprecation(&self.tcx.sess, attrs, item_sp) };\n         let mut is_deprecated = false;\n         if let Some(depr) = &depr {\n             is_deprecated = true;\n@@ -88,7 +85,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n \n         if self.tcx.features().staged_api {\n-            if let Some(..) = attrs.iter().find(|a| a.check_name(sym::deprecated)) {\n+            if let Some(..) = attrs.iter().find(|a| self.tcx.sess.check_name(a, sym::deprecated)) {\n                 self.tcx.sess.span_err(\n                     item_sp,\n                     \"`#[deprecated]` cannot be used in staged API; \\\n@@ -105,7 +102,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab) = attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n+        let (stab, const_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n \n         let const_stab = const_stab.map(|const_stab| {\n             let const_stab = self.tcx.intern_const_stability(const_stab);\n@@ -252,7 +249,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         for attr in attrs {\n             let name = attr.name_or_empty();\n             if unstable_attrs.contains(&name) {\n-                attr::mark_used(attr);\n+                self.tcx.sess.mark_attr_used(attr);\n                 struct_span_err!(\n                     self.tcx.sess,\n                     attr.span,"}, {"sha": "0a7b195a823190db292ed763b819747130623524", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n+        if let Some((lang_item, _)) = hir::lang_items::extract(&self.tcx.sess, &i.attrs) {\n             self.register(lang_item, i.span, i.hir_id);\n         }\n         intravisit::walk_foreign_item(self, i)"}, {"sha": "d16dd701a120bfa36a01133bdb112ecb99cdf4c7", "filename": "src/librustc_plugin_impl/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_plugin_impl%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_plugin_impl%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fbuild.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,6 +1,5 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -9,14 +8,15 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-struct RegistrarFinder {\n+struct RegistrarFinder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     registrars: Vec<(hir::HirId, Span)>,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n+impl<'v, 'tcx> ItemLikeVisitor<'v> for RegistrarFinder<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Fn(..) = item.kind {\n-            if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n+            if self.tcx.sess.contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }\n         }\n@@ -35,7 +35,7 @@ pub fn find_plugin_registrar(tcx: TyCtxt<'_>) -> Option<DefId> {\n fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let mut finder = RegistrarFinder { registrars: Vec::new() };\n+    let mut finder = RegistrarFinder { tcx, registrars: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n     match finder.registrars.len() {"}, {"sha": "2f307302db03ed677114f15f422f52e7a831b1d7", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -32,7 +32,7 @@ pub fn load_plugins(\n     let mut plugins = Vec::new();\n \n     for attr in &krate.attrs {\n-        if !attr.check_name(sym::plugin) {\n+        if !sess.check_name(attr, sym::plugin) {\n             continue;\n         }\n "}, {"sha": "2aa7780aaaf8370d84f4270714505c693b00ae23", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -232,7 +232,7 @@ fn def_id_visibility<'tcx>(\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                 Node::MacroDef(macro_def) => {\n-                    if attr::contains_name(&macro_def.attrs, sym::macro_export) {\n+                    if tcx.sess.contains_name(&macro_def.attrs, sym::macro_export) {\n                         return (ty::Visibility::Public, macro_def.span, \"public\");\n                     } else {\n                         &macro_def.vis\n@@ -271,8 +271,11 @@ fn def_id_visibility<'tcx>(\n                                 ctor_vis =\n                                     ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n                                 let attrs = tcx.get_attrs(variant.def_id);\n-                                span =\n-                                    attr::find_by_name(&attrs, sym::non_exhaustive).unwrap().span;\n+                                span = tcx\n+                                    .sess\n+                                    .find_by_name(&attrs, sym::non_exhaustive)\n+                                    .unwrap()\n+                                    .span;\n                                 descr = \"crate-visible\";\n                             }\n \n@@ -305,7 +308,9 @@ fn def_id_visibility<'tcx>(\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = attr::find_by_name(&item.attrs, sym::non_exhaustive)\n+                                    span = tcx\n+                                        .sess\n+                                        .find_by_name(&item.attrs, sym::non_exhaustive)\n                                         .unwrap()\n                                         .span;\n                                     descr = \"crate-visible\";\n@@ -914,7 +919,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        if attr::find_transparency(&md.attrs, md.ast.macro_rules).0 != Transparency::Opaque {\n+        if attr::find_transparency(&self.tcx.sess, &md.attrs, md.ast.macro_rules).0\n+            != Transparency::Opaque\n+        {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return;\n         }"}, {"sha": "11c7793b3ad9a3903471f69ee7595883e70a4e5a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n@@ -712,7 +712,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id.to_def_id(), ident.name);\n                 let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n-                        attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n+                        self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(\n                         Some(parent),\n@@ -789,7 +789,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis == ty::Visibility::Public\n-                        && attr::contains_name(&item.attrs, sym::non_exhaustive)\n+                        && self.r.session.contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n                     } else {\n@@ -991,7 +991,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n-            if attr.check_name(sym::macro_use) {\n+            if self.r.session.check_name(attr, sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n                     struct_span_err!(\n                         self.r.session,\n@@ -1097,15 +1097,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     /// Returns `true` if this attribute list contains `macro_use`.\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n-            if attr.check_name(sym::macro_escape) {\n+            if self.r.session.check_name(attr, sym::macro_escape) {\n                 let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n                 let mut err = self.r.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n                     err.emit();\n                 }\n-            } else if !attr.check_name(sym::macro_use) {\n+            } else if !self.r.session.check_name(attr, sym::macro_use) {\n                 continue;\n             }\n \n@@ -1129,12 +1129,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         MacroRulesScope::Invocation(invoc_id)\n     }\n \n-    fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if attr::contains_name(&item.attrs, sym::proc_macro) {\n+    fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n+        if self.r.session.contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if self.r.session.contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n+        } else if let Some(attr) = self.r.session.find_by_name(&item.attrs, sym::proc_macro_derive)\n+        {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n                     return Some((MacroKind::Derive, ident, ident.span));\n@@ -1168,7 +1169,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.macro_rules)\n             }\n-            ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n+            ItemKind::Fn(..) => match self.proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n                     self.r.proc_macro_stubs.insert(def_id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n@@ -1185,7 +1186,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1416,7 +1417,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.attrs, sym::non_exhaustive);\n+        let has_non_exhaustive = self.r.session.contains_name(&variant.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }"}, {"sha": "0b881b089deaa830e12826c21f743a1f7b1a8f52", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -6,7 +6,6 @@\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n-use rustc_ast::attr;\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -1179,7 +1178,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n-                if attr::contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n+                if tcx.sess.contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {\n@@ -1540,13 +1539,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             if let Some(def_id) = parent_def_id.as_local() {\n                                 let parent_hir_id = self.tcx.hir().as_local_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n-                                if self\n-                                    .tcx\n-                                    .hir()\n-                                    .attrs(parent_hir_id)\n-                                    .iter()\n-                                    .any(|attr| attr.check_name(sym::automatically_derived))\n-                                {\n+                                if self.tcx.hir().attrs(parent_hir_id).iter().any(|attr| {\n+                                    self.tcx.sess.check_name(attr, sym::automatically_derived)\n+                                }) {\n                                     continue;\n                                 }\n                             }"}, {"sha": "b6a5cf0069c16753dbbd1bee5b4bbf74347f9ea3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -23,7 +23,6 @@ use rustc_arena::TypedArena;\n use rustc_ast::ast::{self, FloatTy, IntTy, NodeId, UintTy};\n use rustc_ast::ast::{Crate, CRATE_NODE_ID};\n use rustc_ast::ast::{ItemKind, Path};\n-use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n@@ -1194,7 +1193,7 @@ impl<'a> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n         let graph_root = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n         let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n@@ -1232,9 +1231,9 @@ impl<'a> Resolver<'a> {\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !attr::contains_name(&krate.attrs, sym::no_core) {\n+        if !session.contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !attr::contains_name(&krate.attrs, sym::no_std) {\n+            if !session.contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n                 if session.rust_2018() {\n                     extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());"}, {"sha": "542025ac1f4990ad8e7db150d00aa25b7f4d2998", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -9,7 +9,7 @@ use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, T\n use rustc_ast::ast::{self, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n-use rustc_attr::{self as attr, StabilityLevel};\n+use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Indeterminate, InvocationRes, ResolverExpand, SyntaxExtension};\n use rustc_expand::compile_declarative_macro;\n@@ -105,7 +105,7 @@ fn registered_idents(\n     descr: &str,\n ) -> FxHashSet<Ident> {\n     let mut registered = FxHashSet::default();\n-    for attr in attr::filter_by_name(attrs, attr_name) {\n+    for attr in sess.filter_by_name(attrs, attr_name) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {\n@@ -1068,7 +1068,7 @@ impl<'a> Resolver<'a> {\n     /// its expander to a pre-defined one for built-in macros.\n     crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n         let mut result = compile_declarative_macro(\n-            &self.session.parse_sess,\n+            &self.session,\n             self.session.features_untracked(),\n             item,\n             edition,"}, {"sha": "7c6d657eb24383d0f63c6c2308688dbcb945b1be", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -825,7 +825,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n                 result.push_str(&beautify_doc_string(val));\n                 result.push('\\n');\n-            } else if attr.check_name(sym::doc) {\n+            } else if self.tcx.sess.check_name(attr, sym::doc) {\n                 if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list\n                         .into_iter()"}, {"sha": "e4bce435c4b6d91e99922774f0288f35598cea02", "filename": "src/librustc_session/output.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_session%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_session%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foutput.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,7 +1,7 @@\n //! Related to out filenames of compilation (e.g. save analysis, binaries).\n use crate::config::{CrateType, Input, OutputFilenames, OutputType};\n use crate::Session;\n-use rustc_ast::{ast, attr};\n+use rustc_ast::ast;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use std::path::{Path, PathBuf};\n@@ -56,7 +56,7 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input)\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n     let attr_crate_name =\n-        attr::find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n+        sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n \n     if let Some(ref s) = sess.opts.crate_name {\n         if let Some((attr, name)) = attr_crate_name {\n@@ -75,7 +75,6 @@ pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input)\n     if let Some((attr, s)) = attr_crate_name {\n         return validate(s.to_string(), Some(attr.span));\n     }\n-\n     if let Input::File(ref path) = *input {\n         if let Some(s) = path.file_stem().and_then(|s| s.to_str()) {\n             if s.starts_with('-') {"}, {"sha": "9191f7e8d76be85458c205e8c585432af937322b", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -7,6 +7,8 @@ use crate::lint;\n use crate::parse::ParseSess;\n use crate::search_paths::{PathKind, SearchPath};\n \n+pub use rustc_ast::ast::Attribute;\n+pub use rustc_ast::attr::MarkedAttrs;\n pub use rustc_ast::crate_disambiguator::CrateDisambiguator;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -22,7 +24,7 @@ use rustc_errors::registry::Registry;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n-use rustc_span::{SourceFileHashAlgorithm, Symbol};\n+use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple, TlsModel};\n@@ -208,6 +210,9 @@ pub struct Session {\n \n     /// Set of enabled features for the current target.\n     pub target_features: FxHashSet<Symbol>,\n+\n+    known_attrs: Lock<MarkedAttrs>,\n+    used_attrs: Lock<MarkedAttrs>,\n }\n \n pub struct PerfStats {\n@@ -1020,6 +1025,76 @@ impl Session {\n         // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n         || self.opts.debugging_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY)\n     }\n+\n+    pub fn mark_attr_known(&self, attr: &Attribute) {\n+        self.known_attrs.lock().mark(attr)\n+    }\n+\n+    pub fn is_attr_known(&self, attr: &Attribute) -> bool {\n+        self.known_attrs.lock().is_marked(attr)\n+    }\n+\n+    pub fn mark_attr_used(&self, attr: &Attribute) {\n+        self.used_attrs.lock().mark(attr)\n+    }\n+\n+    pub fn is_attr_used(&self, attr: &Attribute) -> bool {\n+        self.used_attrs.lock().is_marked(attr)\n+    }\n+\n+    /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n+    /// attribute is marked as used.\n+\n+    /// Returns `true` if the attribute's path matches the argument. If it\n+    /// matches, then the attribute is marked as used.\n+    ///\n+    /// This method should only be used by rustc, other tools can use\n+    /// `Attribute::has_name` instead, because only rustc is supposed to report\n+    /// the `unused_attributes` lint. (`MetaItem` and `NestedMetaItem` are\n+    /// produced by lowering an `Attribute` and don't have identity, so they\n+    /// only have the `has_name` method, and you need to mark the original\n+    /// `Attribute` as used when necessary.)\n+    pub fn check_name(&self, attr: &Attribute, name: Symbol) -> bool {\n+        let matches = attr.has_name(name);\n+        if matches {\n+            self.mark_attr_used(attr);\n+        }\n+        matches\n+    }\n+\n+    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.check_name(attr, *kind))\n+    }\n+\n+    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n+        attrs.iter().any(|item| self.check_name(item, name))\n+    }\n+\n+    pub fn find_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> Option<&'a Attribute> {\n+        attrs.iter().find(|attr| self.check_name(attr, name))\n+    }\n+\n+    pub fn filter_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> impl Iterator<Item = &'a Attribute> {\n+        attrs.iter().filter(move |attr| self.check_name(attr, name))\n+    }\n+\n+    pub fn first_attr_value_str_by_name(\n+        &self,\n+        attrs: &[Attribute],\n+        name: Symbol,\n+    ) -> Option<Symbol> {\n+        attrs.iter().find(|at| self.check_name(at, name)).and_then(|at| at.value_str())\n+    }\n }\n \n fn default_emitter(\n@@ -1283,6 +1358,8 @@ pub fn build_session(\n         real_rust_source_base_dir,\n         asm_arch,\n         target_features: FxHashSet::default(),\n+        known_attrs: Lock::new(MarkedAttrs::new()),\n+        used_attrs: Lock::new(MarkedAttrs::new()),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "4c441e1cc71f584a898052eda578e55432aa91ae", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -87,6 +87,15 @@ impl SessionGlobals {\n     }\n }\n \n+pub fn with_session_globals<R>(edition: Edition, f: impl FnOnce() -> R) -> R {\n+    let session_globals = SessionGlobals::new(edition);\n+    SESSION_GLOBALS.set(&session_globals, f)\n+}\n+\n+pub fn with_default_session_globals<R>(f: impl FnOnce() -> R) -> R {\n+    with_session_globals(edition::DEFAULT_EDITION, f)\n+}\n+\n // If this ever becomes non thread-local, `decode_syntax_context`\n // and `decode_expn_id` will need to be updated to handle concurrent\n // deserialization."}, {"sha": "24850a8a0d2533a17ad06914272d9e6657f8c89d", "filename": "src/librustc_symbol_mangling/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_symbol_mangling%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_symbol_mangling%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Ftest.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -34,16 +34,16 @@ impl SymbolNamesTest<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(hir_id);\n         for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n-            if attr.check_name(SYMBOL_NAME) {\n+            if tcx.sess.check_name(attr, SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id.to_def_id());\n-                let mangled = self.tcx.symbol_name(instance);\n+                let mangled = tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n                 if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n                     tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n                     tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n                 }\n-            } else if attr.check_name(DEF_PATH) {\n+            } else if tcx.sess.check_name(attr, DEF_PATH) {\n                 let path = tcx.def_path_str(def_id.to_def_id());\n                 tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }"}, {"sha": "7a9ed4b72dd03820a56388560c648c87532ee07f", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> OnUnimplementedDirective {\n     ) -> Result<Option<Self>, ErrorReported> {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n-        let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n+        let attr = if let Some(item) = tcx.sess.find_by_name(&attrs, sym::rustc_on_unimplemented) {\n             item\n         } else {\n             return Ok(None);"}, {"sha": "4c575f1c6ac4eab4a088a6da3e55bed75a8d7eec", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -24,7 +24,6 @@ use super::{Overflow, SelectionError, Unimplemented};\n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectionCacheKeyExt;\n-use rustc_ast::attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n@@ -980,7 +979,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         &mut self.intercrate_ambiguity_causes\n                     {\n                         let attrs = tcx.get_attrs(def_id);\n-                        let attr = attr::find_by_name(&attrs, sym::rustc_reservation_impl);\n+                        let attr = tcx.sess.find_by_name(&attrs, sym::rustc_reservation_impl);\n                         let value = attr.and_then(|a| a.value_str());\n                         if let Some(value) = value {\n                             debug!("}, {"sha": "258c5b77df25bc21c938fdee530147ba7f4b4a3c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     //\n                     // FIXME? Other potential candidate methods: `as_ref` and\n                     // `as_mut`?\n-                    .any(|a| a.check_name(sym::rustc_conversion_suggestion))\n+                    .any(|a| self.sess().check_name(a, sym::rustc_conversion_suggestion))\n         });\n \n         methods"}, {"sha": "3d58fb30d91e409b75a30562712e54fad71ec512", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2603,7 +2603,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n     let repr = def.repr;\n     if repr.packed() {\n         for attr in tcx.get_attrs(def.did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n+            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n                     if let Some(repr_pack) = repr.pack {\n                         if pack as u64 != repr_pack.bytes() {\n@@ -2814,7 +2814,7 @@ pub fn check_enum<'tcx>(\n \n     if vs.is_empty() {\n         let attributes = tcx.get_attrs(def_id.to_def_id());\n-        if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n+        if let Some(attr) = tcx.sess.find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "d293c9671a2023f1061abce01216b11771665a1b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -20,7 +20,7 @@ use crate::constrained_generic_params as cgp;\n use crate::middle::resolve_lifetime as rl;\n use rustc_ast::ast;\n use rustc_ast::ast::MetaItemKind;\n-use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n+use rustc_attr::{list_contains_name, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability};\n@@ -2351,13 +2351,13 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n     for attr in attrs.iter() {\n-        if attr.check_name(sym::cold) {\n+        if tcx.sess.check_name(attr, sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.check_name(sym::rustc_allocator) {\n+        } else if tcx.sess.check_name(attr, sym::rustc_allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.check_name(sym::unwind) {\n+        } else if tcx.sess.check_name(attr, sym::unwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n-        } else if attr.check_name(sym::ffi_returns_twice) {\n+        } else if tcx.sess.check_name(attr, sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n@@ -2370,9 +2370,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if attr.check_name(sym::ffi_pure) {\n+        } else if tcx.sess.check_name(attr, sym::ffi_pure) {\n             if tcx.is_foreign_item(id) {\n-                if attrs.iter().any(|a| a.check_name(sym::ffi_const)) {\n+                if attrs.iter().any(|a| tcx.sess.check_name(a, sym::ffi_const)) {\n                     // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n                     struct_span_err!(\n                         tcx.sess,\n@@ -2394,7 +2394,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if attr.check_name(sym::ffi_const) {\n+        } else if tcx.sess.check_name(attr, sym::ffi_const) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n             } else {\n@@ -2407,25 +2407,25 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if attr.check_name(sym::rustc_allocator_nounwind) {\n+        } else if tcx.sess.check_name(attr, sym::rustc_allocator_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n-        } else if attr.check_name(sym::naked) {\n+        } else if tcx.sess.check_name(attr, sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.check_name(sym::no_mangle) {\n+        } else if tcx.sess.check_name(attr, sym::no_mangle) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.check_name(sym::rustc_std_internal_symbol) {\n+        } else if tcx.sess.check_name(attr, sym::rustc_std_internal_symbol) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.check_name(sym::used) {\n+        } else if tcx.sess.check_name(attr, sym::used) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-        } else if attr.check_name(sym::thread_local) {\n+        } else if tcx.sess.check_name(attr, sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.check_name(sym::track_caller) {\n+        } else if tcx.sess.check_name(attr, sym::track_caller) {\n             if tcx.is_closure(id) || tcx.fn_sig(id).abi() != abi::Abi::Rust {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n             }\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.check_name(sym::export_name) {\n+        } else if tcx.sess.check_name(attr, sym::export_name) {\n             if let Some(s) = attr.value_str() {\n                 if s.as_str().contains('\\0') {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n@@ -2440,7 +2440,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n-        } else if attr.check_name(sym::target_feature) {\n+        } else if tcx.sess.check_name(attr, sym::target_feature) {\n             if !tcx.features().target_feature_11 {\n                 check_target_feature_safe_fn(tcx, id, attr.span);\n             } else if let Some(local_id) = id.as_local() {\n@@ -2455,11 +2455,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 &supported_target_features,\n                 &mut codegen_fn_attrs.target_features,\n             );\n-        } else if attr.check_name(sym::linkage) {\n+        } else if tcx.sess.check_name(attr, sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n-        } else if attr.check_name(sym::link_section) {\n+        } else if tcx.sess.check_name(attr, sym::link_section) {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n                     let msg = format!(\n@@ -2472,14 +2472,14 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     codegen_fn_attrs.link_section = Some(val);\n                 }\n             }\n-        } else if attr.check_name(sym::link_name) {\n+        } else if tcx.sess.check_name(attr, sym::link_name) {\n             codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.check_name(sym::link_ordinal) {\n+        } else if tcx.sess.check_name(attr, sym::link_ordinal) {\n             link_ordinal_span = Some(attr.span);\n             if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n                 codegen_fn_attrs.link_ordinal = ordinal;\n             }\n-        } else if attr.check_name(sym::no_sanitize) {\n+        } else if tcx.sess.check_name(attr, sym::no_sanitize) {\n             no_sanitize_span = Some(attr.span);\n             if let Some(list) = attr.meta_item_list() {\n                 for item in list.iter() {\n@@ -2506,11 +2506,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         }\n         match attr.meta().map(|i| i.kind) {\n             Some(MetaItemKind::Word) => {\n-                mark_used(attr);\n+                tcx.sess.mark_attr_used(attr);\n                 InlineAttr::Hint\n             }\n             Some(MetaItemKind::List(ref items)) => {\n-                mark_used(attr);\n+                tcx.sess.mark_attr_used(attr);\n                 inline_span = Some(attr.span);\n                 if items.len() != 1 {\n                     struct_span_err!(\n@@ -2553,7 +2553,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 ia\n             }\n             Some(MetaItemKind::List(ref items)) => {\n-                mark_used(attr);\n+                tcx.sess.mark_attr_used(attr);\n                 inline_span = Some(attr.span);\n                 if items.len() != 1 {\n                     err(attr.span, \"expected one argument\");\n@@ -2614,7 +2614,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if tcx.is_weak_lang_item(id) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    if let Some(name) = weak_lang_items::link_name(&attrs) {\n+    if let Some(name) = weak_lang_items::link_name(&tcx.sess, &attrs) {\n         codegen_fn_attrs.export_name = Some(name);\n         codegen_fn_attrs.link_name = Some(name);\n     }"}, {"sha": "a8247e2f494ccf1a3fd6b2a2bc1c09c8e86dc7f9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -196,7 +196,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n                     }\n \n                     for attr in it.attrs {\n-                        if attr.check_name(sym::track_caller) {\n+                        if tcx.sess.check_name(attr, sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err(\n                                     attr.span,\n@@ -293,7 +293,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                     }\n \n                     for attr in it.attrs {\n-                        if attr.check_name(sym::track_caller) {\n+                        if tcx.sess.check_name(attr, sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err(\n                                     attr.span,"}, {"sha": "b4ced412e5e5565dbb01e51ca0fc28f7dd975603", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2,8 +2,8 @@ use super::*;\n \n use rustc_ast::ast::*;\n use rustc_ast::attr;\n-use rustc_ast::with_default_session_globals;\n use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::with_default_session_globals;\n use rustc_span::DUMMY_SP;\n \n fn word_cfg(s: &str) -> Cfg {"}, {"sha": "21e476cbe06883bf43b8b5511d47db3177bf6879", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,6 +1,6 @@\n-use rustc_ast::attr::with_session_globals;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n+use rustc_span::with_session_globals;\n use rustc_span::FileName;\n \n use super::Classifier;"}, {"sha": "b722cfc8f7521f9bb3d46912cba0b8f145a40e15", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -4,7 +4,6 @@ use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n \n-use rustc_ast::attr;\n use rustc_span::symbol::sym;\n use rustc_span::FileName;\n use serde::Serialize;\n@@ -155,7 +154,10 @@ impl fold::DocFolder for CoverageCalculator {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_)\n-                if attr::contains_name(&i.attrs.other_attrs, sym::automatically_derived)\n+                if i.attrs\n+                    .other_attrs\n+                    .iter()\n+                    .any(|item| item.has_name(sym::automatically_derived))\n                     || impl_.synthetic\n                     || impl_.blanket_impl.is_some() =>\n             {"}, {"sha": "62f52ea5213f357d445f04ada98ba219dc2c77e2", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -398,7 +398,7 @@ pub fn make_test(\n     // Uses librustc_ast to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n     let result = rustc_driver::catch_fatal_errors(|| {\n-        rustc_ast::with_session_globals(edition, || {\n+        rustc_span::with_session_globals(edition, || {\n             use rustc_errors::emitter::EmitterWriter;\n             use rustc_errors::Handler;\n             use rustc_parse::maybe_new_parser_from_source_str;"}, {"sha": "736a8633dac53c24d7ee909637340847fdabcb30", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -29,7 +29,7 @@ macro_rules! fake_lint_pass {\n         impl LateLintPass<'_> for $struct {\n             fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n                 $(\n-                    if !attr::contains_name(&krate.item.attrs, $attr) {\n+                    if !cx.sess().contains_name(&krate.item.attrs, $attr) {\n                         cx.lint(CRATE_NOT_OKAY, |lint| {\n                              let msg = format!(\"crate is not marked with #![{}]\", $attr);\n                              lint.build(&msg).set_span(krate.item.span).emit()"}, {"sha": "bd477b793fc709a9a986e7617b20db24f92dd60a", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -27,7 +27,7 @@ declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n \n impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n-        if !attr::contains_name(&krate.item.attrs, Symbol::intern(\"crate_okay\")) {\n+        if !cx.sess().contains_name(&krate.item.attrs, Symbol::intern(\"crate_okay\")) {\n             cx.lint(CRATE_NOT_OKAY, |lint| {\n                 lint.build(\"crate is not marked with #![crate_okay]\")\n                     .set_span(krate.item.span)"}, {"sha": "448c57da754a0c31d374ec146834913acae39f02", "filename": "src/test/ui-fulldeps/mod_dir_path_canonicalized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -19,7 +19,7 @@ use std::path::Path;\n mod gravy;\n \n pub fn main() {\n-    rustc_ast::with_default_session_globals(|| parse());\n+    rustc_span::with_default_session_globals(|| parse());\n \n     assert_eq!(gravy::foo(), 10);\n }"}, {"sha": "f0e3ab308e9177eff2fff072982ff329ad978dea", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -208,7 +208,7 @@ impl MutVisitor for AddParens {\n }\n \n fn main() {\n-    rustc_ast::with_default_session_globals(|| run());\n+    rustc_span::with_default_session_globals(|| run());\n }\n \n fn run() {"}, {"sha": "6a141f1fc786d2548f11241faa5793d7111ff7e9", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -239,7 +239,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                 return;\n             }\n             if cx.access_levels.is_exported(item.hir_id)\n-                && !is_proc_macro(&item.attrs)\n+                && !is_proc_macro(cx.sess(), &item.attrs)\n                 && attr_by_name(&item.attrs, \"no_mangle\").is_none()\n             {\n                 check_must_use_candidate(\n@@ -262,7 +262,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                 let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n                 check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n             } else if cx.access_levels.is_exported(item.hir_id)\n-                && !is_proc_macro(&item.attrs)\n+                && !is_proc_macro(cx.sess(), &item.attrs)\n                 && trait_ref_of_method(cx, item.hir_id).is_none()\n             {\n                 check_must_use_candidate(\n@@ -294,7 +294,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                 let body = cx.tcx.hir().body(eid);\n                 Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n \n-                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) && !is_proc_macro(&item.attrs) {\n+                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) && !is_proc_macro(cx.sess(), &item.attrs) {\n                     check_must_use_candidate(\n                         cx,\n                         &sig.decl,"}, {"sha": "4e49bdbdd21bd02a8b04c50f3bfd1ed991eced46", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -102,7 +102,7 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n                     if_chain! {\n-                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym!(non_exhaustive)));\n                         let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {\n@@ -154,7 +154,7 @@ fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data:\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n                     if_chain! {\n-                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym!(non_exhaustive)));\n                         let header_span = find_header_span(cx, item, data);\n                         if let Some(snippet) = snippet_opt(cx, header_span);\n                         then {"}, {"sha": "603440c0f83763963e1bde30b9245b7a669c70f0", "filename": "src/tools/clippy/clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -2,7 +2,6 @@ use crate::utils::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n     Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, Item, ItemKind, Local, MacCall, Pat, PatKind,\n };\n-use rustc_ast::attr;\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_middle::lint::in_external_macro;\n@@ -385,7 +384,7 @@ impl EarlyLintPass for NonExpressiveNames {\n }\n \n fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n-    if !attr::contains_name(attrs, sym!(test)) {\n+    if !attrs.iter().any(|attr| attr.has_name(sym!(test))) {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),\n             cx,"}, {"sha": "407527251da225d4d2b454c8f5eb77f5a84b7812", "filename": "src/tools/clippy/clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,5 +1,4 @@\n use rustc_ast::ast;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_errors::Applicability;\n use rustc_session::Session;\n use std::str::FromStr;\n@@ -126,6 +125,6 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n \n /// Return true if the attributes contain any of `proc_macro`,\n /// `proc_macro_derive` or `proc_macro_attribute`, false otherwise\n-pub fn is_proc_macro(attrs: &[ast::Attribute]) -> bool {\n-    attrs.iter().any(is_proc_macro_attr)\n+pub fn is_proc_macro(sess: &Session, attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| sess.is_proc_macro_attr(attr))\n }"}, {"sha": "95a12fe193547d863783a5e6a2fbd4af9e8fed91", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -932,7 +932,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n /// Checks for the `#[automatically_derived]` attribute all `#[derive]`d\n /// implementations have.\n pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n-    attr::contains_name(attrs, sym!(automatically_derived))\n+    attrs.iter().any(|attr| attr.has_name(sym!(automatically_derived)))\n }\n \n /// Remove blocks around an expression."}, {"sha": "ff6923b3797ebf052ad5d3614441504fcd3dcdf3", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e539dd65f8ba80837f7477c0547c61514bceb3ad/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=e539dd65f8ba80837f7477c0547c61514bceb3ad", "patch": "@@ -1,6 +1,5 @@\n #![feature(rustc_private)]\n \n-extern crate rustc_ast;\n extern crate rustc_driver;\n extern crate rustc_span;\n \n@@ -284,7 +283,7 @@ fn parse_args() -> (OutputFormat, PathBuf) {\n fn main() {\n     rustc_driver::init_env_logger(\"RUST_LOG\");\n     let (format, dst) = parse_args();\n-    let result = rustc_ast::with_default_session_globals(move || main_with_result(format, &dst));\n+    let result = rustc_span::with_default_session_globals(move || main_with_result(format, &dst));\n     if let Err(e) = result {\n         panic!(\"{}\", e.to_string());\n     }"}]}