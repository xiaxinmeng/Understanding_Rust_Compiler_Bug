{"sha": "9df1663c12f48df7f4921e68c928016877390565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkZjE2NjNjMTJmNDhkZjdmNDkyMWU2OGM5MjgwMTY4NzczOTA1NjU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-07T14:37:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-07T14:37:27Z"}, "message": "Merge #2755\n\n2755: Cleanup r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4b03a633fcb27c7fdeb5322b1bb3ca3889778b7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b03a633fcb27c7fdeb5322b1bb3ca3889778b7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9df1663c12f48df7f4921e68c928016877390565", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeFJenCRBK7hj4Ov3rIwAAdHIIALDtsc+gci0hOhlTYjAGpeQj\nWjxudzmgGzqqBpGFjYge2I8TkQzAZXa0XVrxOiwFGSC0Y3TI+klSgGaT3pAt2vm4\n0YnCbJglYVx8nqQtiIybV+H7XZF6APm1pbOZrnTZtuJxXR+Wh1kg69EKQrJS5mwo\nsHQTEzPc2z8vx5UW9Majbk/aDOhPlPMC/LO58SJpjstOYa7ix0p+YIMqDZEFjOad\nDDlCBtiGTIRsp3UIWydlZAMwdYpMS2VamrIbszx9H4HH5lyAK5gzlsfb4G8QdFEN\ntWAEbf8nTHcNU8AJPIxLbwwtrIfO4ExO2bj/XI3rL65XgMHvqHqHk2A5cZvhit8=\n=jN12\n-----END PGP SIGNATURE-----\n", "payload": "tree 4b03a633fcb27c7fdeb5322b1bb3ca3889778b7f\nparent 6c1401404baca846103c85e048b5d0a959ddc81b\nparent 5e7995eeb7b7ab4cf0d80ddfa2d20e506216f895\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1578407847 +0000\ncommitter GitHub <noreply@github.com> 1578407847 +0000\n\nMerge #2755\n\n2755: Cleanup r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9df1663c12f48df7f4921e68c928016877390565", "html_url": "https://github.com/rust-lang/rust/commit/9df1663c12f48df7f4921e68c928016877390565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9df1663c12f48df7f4921e68c928016877390565/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c1401404baca846103c85e048b5d0a959ddc81b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1401404baca846103c85e048b5d0a959ddc81b", "html_url": "https://github.com/rust-lang/rust/commit/6c1401404baca846103c85e048b5d0a959ddc81b"}, {"sha": "5e7995eeb7b7ab4cf0d80ddfa2d20e506216f895", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7995eeb7b7ab4cf0d80ddfa2d20e506216f895", "html_url": "https://github.com/rust-lang/rust/commit/5e7995eeb7b7ab4cf0d80ddfa2d20e506216f895"}], "stats": {"total": 715, "additions": 344, "deletions": 371}, "files": [{"sha": "2027f489379e7f6b709e1675cdbb08c11444374e", "filename": "xtask/src/cmd.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Fcmd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Fcmd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcmd.rs?ref=9df1663c12f48df7f4921e68c928016877390565", "patch": "@@ -0,0 +1,53 @@\n+use std::process::{Command, Output, Stdio};\n+\n+use anyhow::{Context, Result};\n+\n+use crate::project_root;\n+\n+pub struct Cmd<'a> {\n+    pub unix: &'a str,\n+    pub windows: &'a str,\n+    pub work_dir: &'a str,\n+}\n+\n+impl Cmd<'_> {\n+    pub fn run(self) -> Result<()> {\n+        if cfg!(windows) {\n+            run(self.windows, self.work_dir)\n+        } else {\n+            run(self.unix, self.work_dir)\n+        }\n+    }\n+    pub fn run_with_output(self) -> Result<Output> {\n+        if cfg!(windows) {\n+            run_with_output(self.windows, self.work_dir)\n+        } else {\n+            run_with_output(self.unix, self.work_dir)\n+        }\n+    }\n+}\n+\n+pub fn run(cmdline: &str, dir: &str) -> Result<()> {\n+    do_run(cmdline, dir, &mut |c| {\n+        c.stdout(Stdio::inherit());\n+    })\n+    .map(|_| ())\n+}\n+\n+pub fn run_with_output(cmdline: &str, dir: &str) -> Result<Output> {\n+    do_run(cmdline, dir, &mut |_| {})\n+}\n+\n+fn do_run(cmdline: &str, dir: &str, f: &mut dyn FnMut(&mut Command)) -> Result<Output> {\n+    eprintln!(\"\\nwill run: {}\", cmdline);\n+    let proj_dir = project_root().join(dir);\n+    let mut args = cmdline.split_whitespace();\n+    let exec = args.next().unwrap();\n+    let mut cmd = Command::new(exec);\n+    f(cmd.args(args).current_dir(proj_dir).stderr(Stdio::inherit()));\n+    let output = cmd.output().with_context(|| format!(\"running `{}`\", cmdline))?;\n+    if !output.status.success() {\n+        anyhow::bail!(\"`{}` exited with {}\", cmdline, output.status);\n+    }\n+    Ok(output)\n+}"}, {"sha": "f4e25dcde9d28f4723ceb4dbabd9741f168aa08c", "filename": "xtask/src/help.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6c1401404baca846103c85e048b5d0a959ddc81b/xtask%2Fsrc%2Fhelp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1401404baca846103c85e048b5d0a959ddc81b/xtask%2Fsrc%2Fhelp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fhelp.rs?ref=6c1401404baca846103c85e048b5d0a959ddc81b", "patch": "@@ -1,46 +0,0 @@\n-//! FIXME: write short doc here\n-\n-pub const GLOBAL_HELP: &str = \"tasks\n-\n-USAGE:\n-    ra_tools <SUBCOMMAND>\n-\n-FLAGS:\n-    -h, --help       Prints help information\n-\n-SUBCOMMANDS:\n-    format\n-    install-pre-commit-hook\n-    fuzz-tests\n-    codegen\n-    install\n-    lint\";\n-\n-pub const INSTALL_HELP: &str = \"ra_tools-install\n-\n-USAGE:\n-    ra_tools.exe install [FLAGS]\n-\n-FLAGS:\n-        --client-code\n-    -h, --help           Prints help information\n-        --jemalloc\n-        --server\";\n-\n-pub fn print_no_param_subcommand_help(subcommand: &str) {\n-    eprintln!(\n-        \"ra_tools-{}\n-\n-USAGE:\n-    ra_tools {}\n-\n-FLAGS:\n-    -h, --help       Prints help information\",\n-        subcommand, subcommand\n-    );\n-}\n-\n-pub const INSTALL_RA_CONFLICT: &str =\n-    \"error: The argument `--server` cannot be used with `--client-code`\n-\n-For more information try --help\";"}, {"sha": "c5bb7351a4b6167ddb8e5a8a987d23b98b758bd0", "filename": "xtask/src/install.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Finstall.rs?ref=9df1663c12f48df7f4921e68c928016877390565", "patch": "@@ -0,0 +1,178 @@\n+//! Installs rust-analyzer language server and/or editor plugin.\n+\n+use std::{env, path::PathBuf, str};\n+\n+use anyhow::{Context, Result};\n+\n+use crate::cmd::{run, run_with_output, Cmd};\n+\n+// Latest stable, feel free to send a PR if this lags behind.\n+const REQUIRED_RUST_VERSION: u32 = 40;\n+\n+pub struct InstallCmd {\n+    pub client: Option<ClientOpt>,\n+    pub server: Option<ServerOpt>,\n+}\n+\n+pub enum ClientOpt {\n+    VsCode,\n+}\n+\n+pub struct ServerOpt {\n+    pub jemalloc: bool,\n+}\n+\n+impl InstallCmd {\n+    pub fn run(self) -> Result<()> {\n+        if cfg!(target_os = \"macos\") {\n+            fix_path_for_mac().context(\"Fix path for mac\")?\n+        }\n+        if let Some(server) = self.server {\n+            install_server(server).context(\"install server\")?;\n+        }\n+        if let Some(client) = self.client {\n+            install_client(client).context(\"install client\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn fix_path_for_mac() -> Result<()> {\n+    let mut vscode_path: Vec<PathBuf> = {\n+        const COMMON_APP_PATH: &str =\n+            r\"/Applications/Visual Studio Code.app/Contents/Resources/app/bin\";\n+        const ROOT_DIR: &str = \"\";\n+        let home_dir = match env::var(\"HOME\") {\n+            Ok(home) => home,\n+            Err(e) => anyhow::bail!(\"Failed getting HOME from environment with error: {}.\", e),\n+        };\n+\n+        [ROOT_DIR, &home_dir]\n+            .iter()\n+            .map(|dir| String::from(*dir) + COMMON_APP_PATH)\n+            .map(PathBuf::from)\n+            .filter(|path| path.exists())\n+            .collect()\n+    };\n+\n+    if !vscode_path.is_empty() {\n+        let vars = match env::var_os(\"PATH\") {\n+            Some(path) => path,\n+            None => anyhow::bail!(\"Could not get PATH variable from env.\"),\n+        };\n+\n+        let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n+        paths.append(&mut vscode_path);\n+        let new_paths = env::join_paths(paths).context(\"build env PATH\")?;\n+        env::set_var(\"PATH\", &new_paths);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n+    let npm_version = Cmd {\n+        unix: r\"npm --version\",\n+        windows: r\"cmd.exe /c npm --version\",\n+        work_dir: \"./editors/code\",\n+    }\n+    .run();\n+\n+    if npm_version.is_err() {\n+        eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n+    }\n+\n+    Cmd { unix: r\"npm install\", windows: r\"cmd.exe /c npm install\", work_dir: \"./editors/code\" }\n+        .run()?;\n+    Cmd {\n+        unix: r\"npm run package --scripts-prepend-node-path\",\n+        windows: r\"cmd.exe /c npm run package\",\n+        work_dir: \"./editors/code\",\n+    }\n+    .run()?;\n+\n+    let code_binary = [\"code\", \"code-insiders\", \"codium\"].iter().find(|bin| {\n+        Cmd {\n+            unix: &format!(\"{} --version\", bin),\n+            windows: &format!(\"cmd.exe /c {}.cmd --version\", bin),\n+            work_dir: \"./editors/code\",\n+        }\n+        .run()\n+        .is_ok()\n+    });\n+\n+    let code_binary = match code_binary {\n+        Some(it) => it,\n+        None => anyhow::bail!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\"),\n+    };\n+\n+    Cmd {\n+        unix: &format!(r\"{} --install-extension ./ra-lsp-0.0.1.vsix --force\", code_binary),\n+        windows: &format!(\n+            r\"cmd.exe /c {}.cmd --install-extension ./ra-lsp-0.0.1.vsix --force\",\n+            code_binary\n+        ),\n+        work_dir: \"./editors/code\",\n+    }\n+    .run()?;\n+\n+    let output = Cmd {\n+        unix: &format!(r\"{} --list-extensions\", code_binary),\n+        windows: &format!(r\"cmd.exe /c {}.cmd --list-extensions\", code_binary),\n+        work_dir: \".\",\n+    }\n+    .run_with_output()?;\n+\n+    if !str::from_utf8(&output.stdout)?.contains(\"ra-lsp\") {\n+        anyhow::bail!(\n+            \"Could not install the Visual Studio Code extension. \\\n+             Please make sure you have at least NodeJS 10.x together with the latest version of VS Code installed and try again.\"\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+fn install_server(opts: ServerOpt) -> Result<()> {\n+    let mut old_rust = false;\n+    if let Ok(output) = run_with_output(\"cargo --version\", \".\") {\n+        if let Ok(stdout) = String::from_utf8(output.stdout) {\n+            println!(\"{}\", stdout);\n+            if !check_version(&stdout, REQUIRED_RUST_VERSION) {\n+                old_rust = true;\n+            }\n+        }\n+    }\n+\n+    if old_rust {\n+        eprintln!(\n+            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n+            REQUIRED_RUST_VERSION,\n+        )\n+    }\n+\n+    let res = if opts.jemalloc {\n+        run(\"cargo install --path crates/ra_lsp_server --locked --force --features jemalloc\", \".\")\n+    } else {\n+        run(\"cargo install --path crates/ra_lsp_server --locked --force\", \".\")\n+    };\n+\n+    if res.is_err() && old_rust {\n+        eprintln!(\n+            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n+            REQUIRED_RUST_VERSION,\n+        )\n+    }\n+\n+    res\n+}\n+\n+fn check_version(version_output: &str, min_minor_version: u32) -> bool {\n+    // Parse second the number out of\n+    //      cargo 1.39.0-beta (1c6ec66d5 2019-09-30)\n+    let minor: Option<u32> = version_output.split('.').nth(1).and_then(|it| it.parse().ok());\n+    match minor {\n+        None => true,\n+        Some(minor) => minor >= min_minor_version,\n+    }\n+}"}, {"sha": "b7627863553b653c264026664dda6b1628bc2ebf", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 11, "deletions": 92, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=9df1663c12f48df7f4921e68c928016877390565", "patch": "@@ -1,18 +1,22 @@\n //! FIXME: write short doc here\n \n+mod cmd;\n+pub mod install;\n+pub mod pre_commit;\n+\n pub mod codegen;\n mod ast_src;\n \n use anyhow::Context;\n-pub use anyhow::Result;\n use std::{\n-    env, fs,\n-    io::{Error as IoError, ErrorKind},\n+    env,\n     path::{Path, PathBuf},\n-    process::{Command, Output, Stdio},\n+    process::{Command, Stdio},\n };\n \n-use crate::codegen::Mode;\n+use crate::{cmd::run, codegen::Mode};\n+\n+pub use anyhow::Result;\n \n const TOOLCHAIN: &str = \"stable\";\n \n@@ -26,40 +30,6 @@ pub fn project_root() -> PathBuf {\n     .to_path_buf()\n }\n \n-pub struct Cmd<'a> {\n-    pub unix: &'a str,\n-    pub windows: &'a str,\n-    pub work_dir: &'a str,\n-}\n-\n-impl Cmd<'_> {\n-    pub fn run(self) -> Result<()> {\n-        if cfg!(windows) {\n-            run(self.windows, self.work_dir)\n-        } else {\n-            run(self.unix, self.work_dir)\n-        }\n-    }\n-    pub fn run_with_output(self) -> Result<Output> {\n-        if cfg!(windows) {\n-            run_with_output(self.windows, self.work_dir)\n-        } else {\n-            run_with_output(self.unix, self.work_dir)\n-        }\n-    }\n-}\n-\n-pub fn run(cmdline: &str, dir: &str) -> Result<()> {\n-    do_run(cmdline, dir, |c| {\n-        c.stdout(Stdio::inherit());\n-    })\n-    .map(|_| ())\n-}\n-\n-pub fn run_with_output(cmdline: &str, dir: &str) -> Result<Output> {\n-    do_run(cmdline, dir, |_| {})\n-}\n-\n pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     match Command::new(\"rustup\")\n         .args(&[\"run\", TOOLCHAIN, \"--\", \"cargo\", \"fmt\", \"--version\"])\n@@ -79,23 +49,11 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     Ok(())\n }\n \n-pub fn install_rustfmt() -> Result<()> {\n+fn install_rustfmt() -> Result<()> {\n     run(&format!(\"rustup toolchain install {}\", TOOLCHAIN), \".\")?;\n     run(&format!(\"rustup component add rustfmt --toolchain {}\", TOOLCHAIN), \".\")\n }\n \n-pub fn install_pre_commit_hook() -> Result<()> {\n-    let result_path =\n-        PathBuf::from(format!(\"./.git/hooks/pre-commit{}\", std::env::consts::EXE_SUFFIX));\n-    if !result_path.exists() {\n-        let me = std::env::current_exe()?;\n-        fs::copy(me, result_path)?;\n-    } else {\n-        Err(IoError::new(ErrorKind::AlreadyExists, \"Git hook already created\"))?;\n-    }\n-    Ok(())\n-}\n-\n pub fn run_clippy() -> Result<()> {\n     match Command::new(\"rustup\")\n         .args(&[\"run\", TOOLCHAIN, \"--\", \"cargo\", \"clippy\", \"--version\"])\n@@ -125,7 +83,7 @@ pub fn run_clippy() -> Result<()> {\n     Ok(())\n }\n \n-pub fn install_clippy() -> Result<()> {\n+fn install_clippy() -> Result<()> {\n     run(&format!(\"rustup toolchain install {}\", TOOLCHAIN), \".\")?;\n     run(&format!(\"rustup component add clippy --toolchain {}\", TOOLCHAIN), \".\")\n }\n@@ -143,42 +101,3 @@ pub fn run_fuzzer() -> Result<()> {\n \n     run(\"rustup run nightly -- cargo fuzz run parser\", \"./crates/ra_syntax\")\n }\n-\n-pub fn reformat_staged_files() -> Result<()> {\n-    run_rustfmt(Mode::Overwrite)?;\n-    let root = project_root();\n-    let output = Command::new(\"git\")\n-        .arg(\"diff\")\n-        .arg(\"--diff-filter=MAR\")\n-        .arg(\"--name-only\")\n-        .arg(\"--cached\")\n-        .current_dir(&root)\n-        .output()?;\n-    if !output.status.success() {\n-        anyhow::bail!(\n-            \"`git diff --diff-filter=MAR --name-only --cached` exited with {}\",\n-            output.status\n-        );\n-    }\n-    for line in String::from_utf8(output.stdout)?.lines() {\n-        run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;\n-    }\n-    Ok(())\n-}\n-\n-fn do_run<F>(cmdline: &str, dir: &str, mut f: F) -> Result<Output>\n-where\n-    F: FnMut(&mut Command),\n-{\n-    eprintln!(\"\\nwill run: {}\", cmdline);\n-    let proj_dir = project_root().join(dir);\n-    let mut args = cmdline.split_whitespace();\n-    let exec = args.next().unwrap();\n-    let mut cmd = Command::new(exec);\n-    f(cmd.args(args).current_dir(proj_dir).stderr(Stdio::inherit()));\n-    let output = cmd.output().with_context(|| format!(\"running `{}`\", cmdline))?;\n-    if !output.status.success() {\n-        anyhow::bail!(\"`{}` exited with {}\", cmdline, output.status);\n-    }\n-    Ok(output)\n-}"}, {"sha": "9309b2fbd57fbd247af17cbfc4fa1cf9e537ca03", "filename": "xtask/src/main.rs", "status": "modified", "additions": 66, "deletions": 233, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=9df1663c12f48df7f4921e68c928016877390565", "patch": "@@ -7,272 +7,105 @@\n //!\n //! This binary is integrated into the `cargo` command line by using an alias in\n //! `.cargo/config`.\n-mod help;\n \n-use std::{env, fmt::Write, path::PathBuf, str};\n+use std::env;\n \n-use anyhow::Context;\n use pico_args::Arguments;\n use xtask::{\n     codegen::{self, Mode},\n-    install_pre_commit_hook, reformat_staged_files, run, run_clippy, run_fuzzer, run_rustfmt,\n-    run_with_output, Cmd, Result,\n+    install::{ClientOpt, InstallCmd, ServerOpt},\n+    pre_commit, run_clippy, run_fuzzer, run_rustfmt, Result,\n };\n \n-// Latest stable, feel free to send a PR if this lags behind.\n-const REQUIRED_RUST_VERSION: u32 = 40;\n-\n-struct InstallOpt {\n-    client: Option<ClientOpt>,\n-    server: Option<ServerOpt>,\n-}\n-\n-enum ClientOpt {\n-    VsCode,\n-}\n-\n-struct ServerOpt {\n-    jemalloc: bool,\n-}\n-\n fn main() -> Result<()> {\n     if env::args().next().map(|it| it.contains(\"pre-commit\")) == Some(true) {\n-        return reformat_staged_files();\n+        return pre_commit::run_hook();\n     }\n \n-    let subcommand = match std::env::args_os().nth(1) {\n-        None => {\n-            eprintln!(\"{}\", help::GLOBAL_HELP);\n-            return Ok(());\n-        }\n-        Some(s) => s,\n-    };\n-    let mut matches = Arguments::from_vec(std::env::args_os().skip(2).collect());\n-    let subcommand = &*subcommand.to_string_lossy();\n-    match subcommand {\n+    let subcommand = std::env::args().nth(1).unwrap_or_default();\n+    let mut args = Arguments::from_vec(std::env::args_os().skip(2).collect());\n+\n+    match subcommand.as_str() {\n         \"install\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                eprintln!(\"{}\", help::INSTALL_HELP);\n+            if args.contains([\"-h\", \"--help\"]) {\n+                eprintln!(\n+                    \"\\\n+cargo xtask install\n+Install rust-analyzer server or editor plugin.\n+\n+USAGE:\n+    cargo xtask install [FLAGS]\n+\n+FLAGS:\n+        --client-code    Install only VS Code plugin\n+        --server         Install only the language server\n+        --jemalloc       Use jemalloc for server\n+    -h, --help           Prints help information\n+        \"\n+                );\n                 return Ok(());\n             }\n-            let server = matches.contains(\"--server\");\n-            let client_code = matches.contains(\"--client-code\");\n+            let server = args.contains(\"--server\");\n+            let client_code = args.contains(\"--client-code\");\n             if server && client_code {\n-                eprintln!(\"{}\", help::INSTALL_RA_CONFLICT);\n+                eprintln!(\n+                    \"error: The argument `--server` cannot be used with `--client-code`\\n\\n\\\n+                     For more information try --help\"\n+                );\n                 return Ok(());\n             }\n-            let jemalloc = matches.contains(\"--jemalloc\");\n-            matches.finish().or_else(handle_extra_flags)?;\n-            let opts = InstallOpt {\n+\n+            let jemalloc = args.contains(\"--jemalloc\");\n+\n+            args.finish()?;\n+\n+            InstallCmd {\n                 client: if server { None } else { Some(ClientOpt::VsCode) },\n                 server: if client_code { None } else { Some(ServerOpt { jemalloc }) },\n-            };\n-            install(opts)?\n+            }\n+            .run()\n         }\n         \"codegen\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                help::print_no_param_subcommand_help(&subcommand);\n-                return Ok(());\n-            }\n+            args.finish()?;\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n+            Ok(())\n         }\n         \"format\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                help::print_no_param_subcommand_help(&subcommand);\n-                return Ok(());\n-            }\n-            run_rustfmt(Mode::Overwrite)?\n+            args.finish()?;\n+            run_rustfmt(Mode::Overwrite)\n         }\n         \"install-pre-commit-hook\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                help::print_no_param_subcommand_help(&subcommand);\n-                return Ok(());\n-            }\n-            install_pre_commit_hook()?\n+            args.finish()?;\n+            pre_commit::install_hook()\n         }\n         \"lint\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                help::print_no_param_subcommand_help(&subcommand);\n-                return Ok(());\n-            }\n-            run_clippy()?\n+            args.finish()?;\n+            run_clippy()\n         }\n         \"fuzz-tests\" => {\n-            if matches.contains([\"-h\", \"--help\"]) {\n-                help::print_no_param_subcommand_help(&subcommand);\n-                return Ok(());\n-            }\n-            run_fuzzer()?\n+            args.finish()?;\n+            run_fuzzer()\n         }\n-        _ => eprintln!(\"{}\", help::GLOBAL_HELP),\n-    }\n-    Ok(())\n-}\n-\n-fn handle_extra_flags(e: pico_args::Error) -> Result<()> {\n-    if let pico_args::Error::UnusedArgsLeft(flags) = e {\n-        let mut invalid_flags = String::new();\n-        for flag in flags {\n-            write!(&mut invalid_flags, \"{}, \", flag)?;\n+        _ => {\n+            eprintln!(\n+                \"\\\n+cargo xtask\n+Run custom build command.\n+\n+USAGE:\n+    cargo xtask <SUBCOMMAND>\n+\n+SUBCOMMANDS:\n+    format\n+    install-pre-commit-hook\n+    fuzz-tests\n+    codegen\n+    install\n+    lint\"\n+            );\n+            Ok(())\n         }\n-        let (invalid_flags, _) = invalid_flags.split_at(invalid_flags.len() - 2);\n-        anyhow::bail!(\"Invalid flags: {}\", invalid_flags)\n-    } else {\n-        anyhow::bail!(e.to_string())\n-    }\n-}\n-\n-fn install(opts: InstallOpt) -> Result<()> {\n-    if cfg!(target_os = \"macos\") {\n-        fix_path_for_mac().context(\"Fix path for mac\")?\n-    }\n-    if let Some(server) = opts.server {\n-        install_server(server).context(\"install server\")?;\n-    }\n-    if let Some(client) = opts.client {\n-        install_client(client).context(\"install client\")?;\n-    }\n-    Ok(())\n-}\n-\n-fn fix_path_for_mac() -> Result<()> {\n-    let mut vscode_path: Vec<PathBuf> = {\n-        const COMMON_APP_PATH: &str =\n-            r\"/Applications/Visual Studio Code.app/Contents/Resources/app/bin\";\n-        const ROOT_DIR: &str = \"\";\n-        let home_dir = match env::var(\"HOME\") {\n-            Ok(home) => home,\n-            Err(e) => anyhow::bail!(\"Failed getting HOME from environment with error: {}.\", e),\n-        };\n-\n-        [ROOT_DIR, &home_dir]\n-            .iter()\n-            .map(|dir| String::from(*dir) + COMMON_APP_PATH)\n-            .map(PathBuf::from)\n-            .filter(|path| path.exists())\n-            .collect()\n-    };\n-\n-    if !vscode_path.is_empty() {\n-        let vars = match env::var_os(\"PATH\") {\n-            Some(path) => path,\n-            None => anyhow::bail!(\"Could not get PATH variable from env.\"),\n-        };\n-\n-        let mut paths = env::split_paths(&vars).collect::<Vec<_>>();\n-        paths.append(&mut vscode_path);\n-        let new_paths = env::join_paths(paths).context(\"build env PATH\")?;\n-        env::set_var(\"PATH\", &new_paths);\n-    }\n-\n-    Ok(())\n-}\n-\n-fn install_client(ClientOpt::VsCode: ClientOpt) -> Result<()> {\n-    let npm_version = Cmd {\n-        unix: r\"npm --version\",\n-        windows: r\"cmd.exe /c npm --version\",\n-        work_dir: \"./editors/code\",\n-    }\n-    .run();\n-\n-    if npm_version.is_err() {\n-        eprintln!(\"\\nERROR: `npm --version` failed, `npm` is required to build the VS Code plugin\")\n-    }\n-\n-    Cmd { unix: r\"npm install\", windows: r\"cmd.exe /c npm install\", work_dir: \"./editors/code\" }\n-        .run()?;\n-    Cmd {\n-        unix: r\"npm run package --scripts-prepend-node-path\",\n-        windows: r\"cmd.exe /c npm run package\",\n-        work_dir: \"./editors/code\",\n-    }\n-    .run()?;\n-\n-    let code_binary = [\"code\", \"code-insiders\", \"codium\"].iter().find(|bin| {\n-        Cmd {\n-            unix: &format!(\"{} --version\", bin),\n-            windows: &format!(\"cmd.exe /c {}.cmd --version\", bin),\n-            work_dir: \"./editors/code\",\n-        }\n-        .run()\n-        .is_ok()\n-    });\n-\n-    let code_binary = match code_binary {\n-        Some(it) => it,\n-        None => anyhow::bail!(\"Can't execute `code --version`. Perhaps it is not in $PATH?\"),\n-    };\n-\n-    Cmd {\n-        unix: &format!(r\"{} --install-extension ./ra-lsp-0.0.1.vsix --force\", code_binary),\n-        windows: &format!(\n-            r\"cmd.exe /c {}.cmd --install-extension ./ra-lsp-0.0.1.vsix --force\",\n-            code_binary\n-        ),\n-        work_dir: \"./editors/code\",\n-    }\n-    .run()?;\n-\n-    let output = Cmd {\n-        unix: &format!(r\"{} --list-extensions\", code_binary),\n-        windows: &format!(r\"cmd.exe /c {}.cmd --list-extensions\", code_binary),\n-        work_dir: \".\",\n-    }\n-    .run_with_output()?;\n-\n-    if !str::from_utf8(&output.stdout)?.contains(\"ra-lsp\") {\n-        anyhow::bail!(\n-            \"Could not install the Visual Studio Code extension. \\\n-             Please make sure you have at least NodeJS 10.x together with the latest version of VS Code installed and try again.\"\n-        );\n-    }\n-\n-    Ok(())\n-}\n-\n-fn install_server(opts: ServerOpt) -> Result<()> {\n-    let mut old_rust = false;\n-    if let Ok(output) = run_with_output(\"cargo --version\", \".\") {\n-        if let Ok(stdout) = String::from_utf8(output.stdout) {\n-            println!(\"{}\", stdout);\n-            if !check_version(&stdout, REQUIRED_RUST_VERSION) {\n-                old_rust = true;\n-            }\n-        }\n-    }\n-\n-    if old_rust {\n-        eprintln!(\n-            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n-            REQUIRED_RUST_VERSION,\n-        )\n-    }\n-\n-    let res = if opts.jemalloc {\n-        run(\"cargo install --path crates/ra_lsp_server --locked --force --features jemalloc\", \".\")\n-    } else {\n-        run(\"cargo install --path crates/ra_lsp_server --locked --force\", \".\")\n-    };\n-\n-    if res.is_err() && old_rust {\n-        eprintln!(\n-            \"\\nWARNING: at least rust 1.{}.0 is required to compile rust-analyzer\\n\",\n-            REQUIRED_RUST_VERSION,\n-        )\n-    }\n-\n-    res\n-}\n-\n-fn check_version(version_output: &str, min_minor_version: u32) -> bool {\n-    // Parse second the number out of\n-    //      cargo 1.39.0-beta (1c6ec66d5 2019-09-30)\n-    let minor: Option<u32> = version_output.split('.').nth(1).and_then(|it| it.parse().ok());\n-    match minor {\n-        None => true,\n-        Some(minor) => minor >= min_minor_version,\n     }\n }"}, {"sha": "88e868ca685ac359e00e3cfe7a67f3812096233e", "filename": "xtask/src/pre_commit.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Fpre_commit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9df1663c12f48df7f4921e68c928016877390565/xtask%2Fsrc%2Fpre_commit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpre_commit.rs?ref=9df1663c12f48df7f4921e68c928016877390565", "patch": "@@ -0,0 +1,36 @@\n+//! pre-commit hook for code formatting.\n+\n+use std::{fs, path::PathBuf};\n+\n+use anyhow::{bail, Result};\n+\n+use crate::{cmd::run_with_output, project_root, run, run_rustfmt, Mode};\n+\n+// FIXME: if there are changed `.ts` files, also reformat TypeScript (by\n+// shelling out to `npm fmt`).\n+pub fn run_hook() -> Result<()> {\n+    run_rustfmt(Mode::Overwrite)?;\n+\n+    let diff = run_with_output(\"git diff --diff-filter=MAR --name-only --cached\", \".\")?;\n+\n+    let root = project_root();\n+    for line in String::from_utf8(diff.stdout)?.lines() {\n+        run(&format!(\"git update-index --add {}\", root.join(line).to_string_lossy()), \".\")?;\n+    }\n+\n+    Ok(())\n+}\n+\n+pub fn install_hook() -> Result<()> {\n+    let hook_path: PathBuf =\n+        format!(\"./.git/hooks/pre-commit{}\", std::env::consts::EXE_SUFFIX).into();\n+\n+    if hook_path.exists() {\n+        bail!(\"Git hook already created\");\n+    }\n+\n+    let me = std::env::current_exe()?;\n+    fs::copy(me, hook_path)?;\n+\n+    Ok(())\n+}"}]}