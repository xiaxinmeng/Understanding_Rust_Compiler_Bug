{"sha": "05c9c73756dc1409918a7bde8b006aec69195070", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YzljNzM3NTZkYzE0MDk5MThhN2JkZThiMDA2YWVjNjkxOTUwNzA=", "commit": {"author": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-11-06T16:33:39Z"}, "committer": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-11-06T17:10:23Z"}, "message": "[Stdlib] rope.rs: improved doc, code readability", "tree": {"sha": "e299c0f53754f6ff9a1e006efd52db498fb5f31e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e299c0f53754f6ff9a1e006efd52db498fb5f31e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05c9c73756dc1409918a7bde8b006aec69195070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05c9c73756dc1409918a7bde8b006aec69195070", "html_url": "https://github.com/rust-lang/rust/commit/05c9c73756dc1409918a7bde8b006aec69195070", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05c9c73756dc1409918a7bde8b006aec69195070/comments", "author": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bfe4dba807ae908a247a34a4f72d0b610e6376f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bfe4dba807ae908a247a34a4f72d0b610e6376f", "html_url": "https://github.com/rust-lang/rust/commit/7bfe4dba807ae908a247a34a4f72d0b610e6376f"}], "stats": {"total": 239, "additions": 157, "deletions": 82}, "files": [{"sha": "45df908a52d2e70bd3adb9715641551eb5deed5b", "filename": "src/lib/rope.rs", "status": "modified", "additions": 157, "deletions": 82, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/05c9c73756dc1409918a7bde8b006aec69195070/src%2Flib%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c9c73756dc1409918a7bde8b006aec69195070/src%2Flib%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frope.rs?ref=05c9c73756dc1409918a7bde8b006aec69195070", "patch": "@@ -711,6 +711,8 @@ mod node {\n     const hint_max_node_height:   uint = 16u;\n \n     /*\n+    Function: of_str\n+\n     Adopt a string as a node.\n \n     If the string is longer than `max_leaf_char_len`, it is\n@@ -918,7 +920,11 @@ mod node {\n     }\n \n     /*\n+    Function: flatten\n+\n     Replace a subtree by a single leaf with the same contents.\n+\n+    Performance note: This function executes in linear time.\n      */\n     fn flatten(node: @node) -> @node unsafe {\n         alt(*node) {\n@@ -934,49 +940,77 @@ mod node {\n         }\n     }\n \n+    /*\n+    Function: bal\n+\n+    Balance a node.\n+\n+    Algorithm:\n+    - if the node height is smaller than `hint_max_node_height`, do nothing\n+    - otherwise, gather all leaves as a forest, rebuild a balanced node,\n+         concatenating small leaves along the way\n+\n+    Returns:\n+    - `option::none` if no transformation happened\n+    - `option::some(x)` otherwise, in which case `x` has the same contents\n+       as `node` bot lower height and/or fragmentation.\n+    */\n     fn bal(node: @node) -> option::t<@node> {\n-        if height(node) < hint_max_node_height { ret option::none }\n-        else {\n-            //1. Gather all leaves as a forest\n-            let forest = [mutable];\n-            let it = leaf_iterator::start(node);\n-            while true {\n-                alt (leaf_iterator::next(it)) {\n-                  option::none.   { break; }\n-                  option::some(x) { forest += [mutable @leaf(x)]; }\n-                }\n+        if height(node) < hint_max_node_height { ret option::none; }\n+        //1. Gather all leaves as a forest\n+        let forest = [mutable];\n+        let it = leaf_iterator::start(node);\n+        while true {\n+            alt (leaf_iterator::next(it)) {\n+              option::none.   { break; }\n+              option::some(x) { forest += [mutable @leaf(x)]; }\n             }\n-            //2. Rebuild tree from forest\n-            let root = @*tree_from_forest_destructive(forest);\n-            ret option::some(root);\n         }\n+        //2. Rebuild tree from forest\n+        let root = @*tree_from_forest_destructive(forest);\n+        ret option::some(root);\n+\n     }\n \n+    /*\n+    Function: sub_bytes\n+\n+    Compute the subnode of a node.\n+\n+    Parameters:\n+    node        - A node\n+    byte_offset - A byte offset in `node`\n+    byte_len    - The number of bytes to return\n+\n+    Performance notes:\n+    - this function performs no copying;\n+    - this function executes in a time proportional to the height of `node`.\n+\n+    Safety notes:\n+    - this function fails if `byte_offset` or `byte_len` do not represent\n+    valid positions in `node`.\n+    */\n     fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n         let node        = node;\n-        let result      = node;//Arbitrary value\n         let byte_offset = byte_offset;\n-        let byte_len    = byte_len;\n         while true {\n             if byte_offset == 0u && byte_len == node::byte_len(node) {\n-                result = node;\n-                break;\n+                ret node;\n             }\n             alt(*node) {\n               node::leaf(x) {\n                 let char_len =\n                     str::char_len_range(*x.content, byte_offset, byte_len);\n-                result = @leaf({byte_offset: byte_offset,\n+                ret @leaf({byte_offset: byte_offset,\n                                 byte_len:    byte_len,\n                                 char_len:    char_len,\n                                 content:     x.content});\n-                break;\n               }\n               node::concat(x) {\n                 let left_len: uint = node::byte_len(x.left);\n                 if byte_offset <= left_len {\n                     if byte_offset + byte_len <= left_len {\n-                   //Case 1: Everything fits in x.left, tail-call\n+                        //Case 1: Everything fits in x.left, tail-call\n                         node = x.left;\n                     } else {\n                         //Case 2: A (non-empty, possibly full) suffix\n@@ -986,8 +1020,7 @@ mod node {\n                             sub_bytes(x.left, byte_offset, left_len);\n                         let right_result =\n                             sub_bytes(x.right, 0u, left_len - byte_offset);\n-                        result = concat2(left_result, right_result);\n-                        break;\n+                        ret concat2(left_result, right_result);\n                     }\n                 } else {\n                     //Case 3: Everything fits in x.right\n@@ -997,49 +1030,71 @@ mod node {\n               }\n             }\n         }\n-        ret result;\n+        fail;//Note: unreachable\n     }\n \n+    /*\n+    Function: sub_chars\n+\n+    Compute the subnode of a node.\n+\n+    Parameters:\n+    node        - A node\n+    char_offset - A char offset in `node`\n+    char_len    - The number of chars to return\n+\n+    Performance notes:\n+    - this function performs no copying;\n+    - this function executes in a time proportional to the height of `node`.\n+\n+    Safety notes:\n+    - this function fails if `char_offset` or `char_len` do not represent\n+    valid positions in `node`.\n+    */\n     fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n-        alt(*node) {\n-          node::leaf(x) {\n-            if char_offset == 0u && char_len == x.char_len {\n-                ret node;\n-            }\n-            let byte_offset =\n-                str::byte_len_range(*x.content, 0u, char_offset);\n-            let byte_len    =\n-                str::byte_len_range(*x.content, byte_offset, char_len);\n-            ret @leaf({byte_offset: byte_offset,\n-                 byte_len:    byte_len,\n-                 char_len:    char_len,\n-                 content:     x.content});\n-          }\n-          node::concat(x) {\n-            if char_offset == 0u && char_len == x.char_len {ret node;}\n-            let left_len : uint = node::char_len(x.left);\n-            if char_offset <= left_len {\n-                if char_offset + char_len <= left_len {\n-                    //Case 1: Everything fits in x.left\n-                    ret sub_chars(x.left, char_offset, char_len);\n-                    //TODO: Optimize manually this tail call?\n+        let node        = node;\n+        let char_offset = char_offset;\n+        while true {\n+            alt(*node) {\n+              node::leaf(x) {\n+                if char_offset == 0u && char_len == x.char_len {\n+                    ret node;\n+                }\n+                let byte_offset =\n+                    str::byte_len_range(*x.content, 0u, char_offset);\n+                let byte_len    =\n+                    str::byte_len_range(*x.content, byte_offset, char_len);\n+                ret @leaf({byte_offset: byte_offset,\n+                           byte_len:    byte_len,\n+                           char_len:    char_len,\n+                           content:     x.content});\n+              }\n+              node::concat(x) {\n+                if char_offset == 0u && char_len == x.char_len {ret node;}\n+                let left_len : uint = node::char_len(x.left);\n+                if char_offset <= left_len {\n+                    if char_offset + char_len <= left_len {\n+                        //Case 1: Everything fits in x.left, tail call\n+                        node        = x.left;\n+                    } else {\n+                        //Case 2: A (non-empty, possibly full) suffix\n+                        //of x.left and a (non-empty, possibly full) prefix\n+                        //of x.right\n+                        let left_result  =\n+                            sub_chars(x.left, char_offset, left_len);\n+                        let right_result =\n+                            sub_chars(x.right, 0u, left_len - char_offset);\n+                        ret concat2(left_result, right_result);\n+                    }\n                 } else {\n-                    //Case 2: A (non-empty, possibly full) suffix\n-                    //of x.left and a (non-empty, possibly full) prefix\n-                    //of x.right\n-                    let left_result  =\n-                        sub_chars(x.left, char_offset, left_len);\n-                    let right_result =\n-                        sub_chars(x.right, 0u, left_len - char_offset);\n-                    ret concat2(left_result, right_result)\n+                    //Case 3: Everything fits in x.right, tail call\n+                    node = x.right;\n+                    char_offset -= left_len;\n                 }\n-            } else {\n-                //Case 3: Everything fits in x.right\n-                ret sub_chars(x.right, char_offset - left_len, char_len);\n-                //TODO: Optimize manually this tail call?\n+              }\n             }\n-          }\n         }\n+        fail;\n     }\n \n     fn concat2(left: @node, right: @node) -> @node {\n@@ -1091,54 +1146,80 @@ mod node {\n         })\n     }\n \n+    /*\n+    Function: loop_leaves\n+\n+    Loop through a node, leaf by leaf\n+\n+    Parameters:\n+\n+    rope - A node to traverse.\n+    it - A block to execute with each consecutive leaf of the node.\n+    Return `true` to continue, `false` to stop.\n+\n+    Returns:\n+\n+    `true` If execution proceeded correctly, `false` if it was interrupted,\n+    that is if `it` returned `false` at any point.\n+    */\n     fn loop_leaves(node: @node, it: block(leaf) -> bool) -> bool{\n-        let result  = true;\n         let current = node;\n         while true {\n             alt(*current) {\n               leaf(x) {\n-                result = it(x);\n-                break;\n+                ret it(x);\n               }\n               concat(x) {\n                 if loop_leaves(x.left, it) { //non tail call\n                     current = x.right;       //tail call\n                 } else {\n-                    result = false;\n-                    break;\n+                    ret false;\n                 }\n               }\n             }\n         }\n-        ret result;\n+        fail;//unreachable\n     }\n \n+    /*\n+    Function: char_at\n+\n+    Parameters:\n+    pos - A position in the rope\n+\n+    Returns: The character at position `pos`\n+\n+    Safety notes: The function will fail if `pos`\n+    is not a valid position in the rope.\n+\n+    Performance note: This function executes in a time\n+    proportional to the height of the rope + the (bounded)\n+    length of the largest leaf.\n+    */\n    fn char_at(node: @node, pos: uint) -> char {\n        let node    = node;\n        let pos     = pos;\n-       let result  = '0';\n        while true {\n            alt(*node) {\n              leaf(x) {\n-               result = str::char_at(*x.content, pos);\n-               break;\n+               ret str::char_at(*x.content, pos);\n              }\n              concat({left: left,\n                      right: right,\n                      char_len: _,\n                      byte_len: _,\n                      height: _}) {\n                let left_len = char_len(left);\n-           if left_len > pos {\n+               if left_len > pos {\n                    node = left;\n-           } else {\n+               } else {\n                    node = right;\n                    pos  = pos - left_len;\n-           }\n+               }\n              }\n            }\n        };\n-       ret result;\n+       fail;//unreachable\n    }\n \n     mod leaf_iterator {\n@@ -1162,7 +1243,6 @@ mod node {\n \n         fn next(it: t) -> option::t<leaf> {\n             if it.stackpos < 0 { ret option::none; }\n-            let result  = option::none;\n             while true {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n@@ -1174,12 +1254,11 @@ mod node {\n                     it.stack[it.stackpos] = x.left;\n                   }\n                   leaf(x) {\n-                    result    = option::some(x);\n-                    break;\n+                    ret option::some(x);\n                   }\n                 }\n             }\n-            ret result;\n+            fail;//unreachable\n         }\n     }\n \n@@ -1207,27 +1286,23 @@ mod node {\n         }\n \n         fn next(it: t) -> option::t<char> {\n-            let result = option::none;\n             while true {\n                 alt(get_current_or_next_leaf(it)) {\n-                  option::none. {\n-                    break;\n-                  }\n+                  option::none. { ret option::none; }\n                   option::some(leaf) {\n                     let next_char = get_next_char_in_leaf(it);\n                     alt(next_char) {\n                       option::none. {\n                         cont;\n                       }\n                       option::some(_) {\n-                        result = next_char;\n-                        break;\n+                        ret next_char;\n                       }\n                     }\n                   }\n                 }\n             }\n-            ret result;\n+            fail;//unreachable\n         }\n \n         fn get_current_or_next_leaf(it: t) -> option::t<leaf> {"}]}