{"sha": "88beb351940e888932b30c555c273f18a0254aff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YmViMzUxOTQwZTg4ODkzMmIzMGM1NTVjMjczZjE4YTAyNTRhZmY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-09T14:18:27Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-12T13:30:26Z"}, "message": "Implement Expr spanless-hashing", "tree": {"sha": "bd57ac5b9b41ba2a2fcaed9c2b96eb48f7adc306", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd57ac5b9b41ba2a2fcaed9c2b96eb48f7adc306"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88beb351940e888932b30c555c273f18a0254aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88beb351940e888932b30c555c273f18a0254aff", "html_url": "https://github.com/rust-lang/rust/commit/88beb351940e888932b30c555c273f18a0254aff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88beb351940e888932b30c555c273f18a0254aff/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afee209d5a85c41f02145869ca360f23a69344d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/afee209d5a85c41f02145869ca360f23a69344d1", "html_url": "https://github.com/rust-lang/rust/commit/afee209d5a85c41f02145869ca360f23a69344d1"}], "stats": {"total": 392, "additions": 364, "deletions": 28}, "files": [{"sha": "4469853ddf953add1876d189cda1892e6af8366a", "filename": "src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88beb351940e888932b30c555c273f18a0254aff/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88beb351940e888932b30c555c273f18a0254aff/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=88beb351940e888932b30c555c273f18a0254aff", "patch": "@@ -17,7 +17,7 @@ use syntax::ast::{UintTy, FloatTy, StrStyle};\n use syntax::ast::Sign::{self, Plus, Minus};\n \n \n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n+#[derive(PartialEq, Eq, Debug, Copy, Clone, Hash)]\n pub enum FloatWidth {\n     Fw32,\n     Fw64,\n@@ -34,7 +34,7 @@ impl From<FloatTy> for FloatWidth {\n }\n \n /// a Lit_-like enum to fold constant `Expr`s into\n-#[derive(Eq, Debug, Clone)]\n+#[derive(Eq, Debug, Clone, Hash)]\n pub enum Constant {\n     /// a String \"abc\"\n     Str(String, StrStyle),"}, {"sha": "1899b47accd5dffc39e0b32c160ca48f32f74b7a", "filename": "src/copies.rs", "status": "modified", "additions": 68, "deletions": 25, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/88beb351940e888932b30c555c273f18a0254aff/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88beb351940e888932b30c555c273f18a0254aff/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=88beb351940e888932b30c555c273f18a0254aff", "patch": "@@ -1,6 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use utils::SpanlessEq;\n+use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n+use utils::{SpanlessEq, SpanlessHash};\n use utils::{get_parent_expr, in_macro, span_lint, span_note_and_lint};\n \n /// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n@@ -46,8 +48,16 @@ impl LintPass for CopyAndPaste {\n impl LateLintPass for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if !in_macro(cx, expr.span) {\n+            // skip ifs directly in else, it will be checked in the parent if\n+            if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n+                if else_expr.id == expr.id {\n+                    return;\n+                }\n+            }\n+\n+            let (conds, blocks) = if_sequence(expr);\n             lint_same_then_else(cx, expr);\n-            lint_same_cond(cx, expr);\n+            lint_same_cond(cx, &conds);\n         }\n     }\n }\n@@ -64,32 +74,22 @@ fn lint_same_then_else(cx: &LateContext, expr: &Expr) {\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext, expr: &Expr) {\n-    // skip ifs directly in else, it will be checked in the parent if\n-    if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n-        if else_expr.id == expr.id {\n-            return;\n-        }\n-    }\n-\n-    let conds = condition_sequence(expr);\n-\n-    for (n, i) in conds.iter().enumerate() {\n-        for j in conds.iter().skip(n+1) {\n-            if SpanlessEq::new(cx).ignore_fn().eq_expr(i, j) {\n-                span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n-            }\n-        }\n+fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n+    if let Some((i, j)) = search_same(cx, conds) {\n+        span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n     }\n }\n \n-/// Return the list of condition expressions in a sequence of `if/else`.\n-/// Eg. would return `[a, b]` for the expression `if a {..} else if b {..}`.\n-fn condition_sequence(mut expr: &Expr) -> Vec<&Expr> {\n-    let mut result = vec![];\n+/// Return the list of condition expressions and the list of blocks in a sequence of `if/else`.\n+/// Eg. would return `([a, b], [c, d, e])` for the expression\n+/// `if a { c } else if b { d } else { e }`.\n+fn if_sequence(mut expr: &Expr) -> (Vec<&Expr>, Vec<&Block>) {\n+    let mut conds = vec![];\n+    let mut blocks = vec![];\n \n-    while let ExprIf(ref cond, _, ref else_expr) = expr.node {\n-        result.push(&**cond);\n+    while let ExprIf(ref cond, ref then_block, ref else_expr) = expr.node {\n+        conds.push(&**cond);\n+        blocks.push(&**then_block);\n \n         if let Some(ref else_expr) = *else_expr {\n             expr = else_expr;\n@@ -99,5 +99,48 @@ fn condition_sequence(mut expr: &Expr) -> Vec<&Expr> {\n         }\n     }\n \n-    result\n+    // final `else {..}`\n+    if !blocks.is_empty() {\n+        if let ExprBlock(ref block) = expr.node {\n+            blocks.push(&**block);\n+        }\n+    }\n+\n+    (conds, blocks)\n+}\n+\n+fn search_same<'a>(cx: &LateContext, exprs: &[&'a Expr]) -> Option<(&'a Expr, &'a Expr)> {\n+    // common cases\n+    if exprs.len() < 2 {\n+        return None;\n+    }\n+    else if exprs.len() == 2 {\n+        return if SpanlessEq::new(cx).ignore_fn().eq_expr(&exprs[0], &exprs[1]) {\n+            Some((&exprs[0], &exprs[1]))\n+        }\n+        else {\n+            None\n+        }\n+    }\n+\n+    let mut map : HashMap<_, Vec<&'a _>> = HashMap::with_capacity(exprs.len());\n+\n+    for &expr in exprs {\n+        let mut h = SpanlessHash::new(cx);\n+        h.hash_expr(expr);\n+        let h = h.finish();\n+\n+        match map.entry(h) {\n+            Entry::Occupied(o) => {\n+                for o in o.get() {\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(o, expr) {\n+                        return Some((o, expr))\n+                    }\n+                }\n+            }\n+            Entry::Vacant(v) => { v.insert(vec![expr]); }\n+        }\n+    }\n+\n+    None\n }"}, {"sha": "bd2aebfd01347b82da0d0e52a24135dc296f6e56", "filename": "src/utils/hir.rs", "status": "modified", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/88beb351940e888932b30c555c273f18a0254aff/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88beb351940e888932b30c555c273f18a0254aff/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=88beb351940e888932b30c555c273f18a0254aff", "patch": "@@ -1,6 +1,8 @@\n use consts::constant;\n use rustc::lint::*;\n use rustc_front::hir::*;\n+use std::hash::{Hash, Hasher, SipHasher};\n+use syntax::ast::Name;\n use syntax::ptr::P;\n \n /// Type used to check whether two ast are the same. This is different from the operator\n@@ -242,3 +244,288 @@ fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n+\n+\n+pub struct SpanlessHash<'a, 'tcx: 'a> {\n+    /// Context used to evaluate constant expressions.\n+    cx: &'a LateContext<'a, 'tcx>,\n+    s: SipHasher,\n+}\n+\n+impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+        SpanlessHash { cx: cx, s: SipHasher::new() }\n+    }\n+\n+    pub fn finish(&self) -> u64 {\n+        self.s.finish()\n+    }\n+\n+    pub fn hash_block(&mut self, b: &Block) {\n+        for s in &b.stmts {\n+            self.hash_stmt(s);\n+        }\n+\n+        if let Some(ref e) = b.expr {\n+            self.hash_expr(e);\n+        }\n+\n+        b.rules.hash(&mut self.s);\n+    }\n+\n+    pub fn hash_expr(&mut self, e: &Expr) {\n+        if let Some(e) = constant(self.cx, e) {\n+            return e.hash(&mut self.s);\n+        }\n+\n+        match e.node {\n+            ExprAddrOf(m, ref e) => {\n+                let c: fn(_, _) -> _ = ExprAddrOf;\n+                c.hash(&mut self.s);\n+                m.hash(&mut self.s);\n+                self.hash_expr(e);\n+            }\n+            ExprAgain(i) => {\n+                let c: fn(_) -> _ = ExprAgain;\n+                c.hash(&mut self.s);\n+                if let Some(i) = i {\n+                    self.hash_name(&i.node.name);\n+                }\n+            }\n+            ExprAssign(ref l, ref r) => {\n+                let c: fn(_, _) -> _ = ExprAssign;\n+                c.hash(&mut self.s);\n+                self.hash_expr(l);\n+                self.hash_expr(r);\n+            }\n+            ExprAssignOp(ref o, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprAssignOp;\n+                c.hash(&mut self.s);\n+                o.hash(&mut self.s);\n+                self.hash_expr(l);\n+                self.hash_expr(r);\n+            }\n+            ExprBlock(ref b) => {\n+                let c: fn(_) -> _ = ExprBlock;\n+                c.hash(&mut self.s);\n+                self.hash_block(b);\n+            }\n+            ExprBinary(op, ref l, ref r) => {\n+                let c: fn(_, _, _) -> _ = ExprBinary;\n+                c.hash(&mut self.s);\n+                op.node.hash(&mut self.s);\n+                self.hash_expr(l);\n+                self.hash_expr(r);\n+            }\n+            ExprBreak(i) => {\n+                let c: fn(_) -> _ = ExprBreak;\n+                c.hash(&mut self.s);\n+                if let Some(i) = i {\n+                    self.hash_name(&i.node.name);\n+                }\n+            }\n+            ExprBox(ref e) => {\n+                let c: fn(_) -> _ = ExprBox;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+            }\n+            ExprCall(ref fun, ref args) => {\n+                let c: fn(_, _) -> _ = ExprCall;\n+                c.hash(&mut self.s);\n+                self.hash_expr(fun);\n+                self.hash_exprs(args);\n+            }\n+            ExprCast(ref e, ref _ty) => {\n+                let c: fn(_, _) -> _ = ExprCast;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+                // TODO: _ty\n+            }\n+            ExprClosure(cap, _, ref b) => {\n+                let c: fn(_, _, _) -> _ = ExprClosure;\n+                c.hash(&mut self.s);\n+                cap.hash(&mut self.s);\n+                self.hash_block(b);\n+            }\n+            ExprField(ref e, ref f) => {\n+                let c: fn(_, _) -> _ = ExprField;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+                self.hash_name(&f.node);\n+            }\n+            ExprIndex(ref a, ref i) => {\n+                let c: fn(_, _) -> _ = ExprIndex;\n+                c.hash(&mut self.s);\n+                self.hash_expr(a);\n+                self.hash_expr(i);\n+            }\n+            ExprInlineAsm(_) => {\n+                let c: fn(_) -> _ = ExprInlineAsm;\n+                c.hash(&mut self.s);\n+            }\n+            ExprIf(ref cond, ref t, ref e) => {\n+                let c: fn(_, _, _) -> _ = ExprIf;\n+                c.hash(&mut self.s);\n+                self.hash_expr(cond);\n+                self.hash_block(t);\n+                if let Some(ref e) = *e {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprLit(ref l) => {\n+                let c: fn(_) -> _ = ExprLit;\n+                c.hash(&mut self.s);\n+                l.hash(&mut self.s);\n+            },\n+            ExprLoop(ref b, ref i) => {\n+                let c: fn(_, _) -> _ = ExprLoop;\n+                c.hash(&mut self.s);\n+                self.hash_block(b);\n+                if let Some(i) = *i {\n+                    self.hash_name(&i.name);\n+                }\n+            }\n+            ExprMatch(ref e, ref arms, ref s) => {\n+                let c: fn(_, _, _) -> _ = ExprMatch;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+\n+                for arm in arms {\n+                    // TODO: arm.pat?\n+                    if let Some(ref e) = arm.guard {\n+                        self.hash_expr(e);\n+                    }\n+                    self.hash_expr(&arm.body);\n+                }\n+\n+                s.hash(&mut self.s);\n+            }\n+            ExprMethodCall(ref name, ref _tys, ref args) => {\n+                let c: fn(_, _, _) -> _ = ExprMethodCall;\n+                c.hash(&mut self.s);\n+                self.hash_name(&name.node);\n+                self.hash_exprs(args);\n+            }\n+            ExprRange(ref b, ref e) => {\n+                let c: fn(_, _) -> _ = ExprRange;\n+                c.hash(&mut self.s);\n+                if let Some(ref b) = *b {\n+                    self.hash_expr(b);\n+                }\n+                if let Some(ref e) = *e {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprRepeat(ref e, ref l) => {\n+                let c: fn(_, _) -> _ = ExprRepeat;\n+                c.hash(&mut self.s);\n+                self.hash_expr(e);\n+                self.hash_expr(l);\n+            }\n+            ExprRet(ref e) => {\n+                let c: fn(_) -> _ = ExprRet;\n+                c.hash(&mut self.s);\n+                if let Some(ref e) = *e {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprPath(ref _qself, ref subpath) => {\n+                let c: fn(_, _) -> _ = ExprPath;\n+                c.hash(&mut self.s);\n+                self.hash_path(subpath);\n+            }\n+            ExprStruct(ref path, ref fields, ref expr) => {\n+                let c: fn(_, _, _) -> _ = ExprStruct;\n+                c.hash(&mut self.s);\n+\n+                self.hash_path(path);\n+\n+                for f in fields {\n+                    self.hash_name(&f.name.node);\n+                    self.hash_expr(&f.expr);\n+                }\n+\n+                if let Some(ref e) = *expr {\n+                    self.hash_expr(e);\n+                }\n+            }\n+            ExprTup(ref tup) => {\n+                let c: fn(_) -> _ = ExprTup;\n+                c.hash(&mut self.s);\n+                self.hash_exprs(tup);\n+            },\n+            ExprTupField(ref le, li) => {\n+                let c: fn(_, _) -> _ = ExprTupField;\n+                c.hash(&mut self.s);\n+\n+                self.hash_expr(le);\n+                li.node.hash(&mut self.s);\n+            }\n+            ExprType(_, _) => {\n+                let c: fn(_, _) -> _ = ExprType;\n+                c.hash(&mut self.s);\n+                // what\u2019s an ExprType anyway?\n+            }\n+            ExprUnary(lop, ref le) => {\n+                let c: fn(_, _) -> _ = ExprUnary;\n+                c.hash(&mut self.s);\n+\n+                lop.hash(&mut self.s);\n+                self.hash_expr(le);\n+            }\n+            ExprVec(ref v) => {\n+                let c: fn(_) -> _ = ExprVec;\n+                c.hash(&mut self.s);\n+\n+                self.hash_exprs(v);\n+            },\n+            ExprWhile(ref cond, ref b, l) => {\n+                let c: fn(_, _, _) -> _ = ExprWhile;\n+                c.hash(&mut self.s);\n+\n+                self.hash_expr(cond);\n+                self.hash_block(b);\n+                if let Some(l) = l {\n+                    self.hash_name(&l.name);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn hash_exprs(&mut self, e: &[P<Expr>]) {\n+        for e in e {\n+            self.hash_expr(e);\n+        }\n+    }\n+\n+    pub fn hash_name(&mut self, n: &Name) {\n+        n.as_str().hash(&mut self.s);\n+    }\n+\n+    pub fn hash_path(&mut self, p: &Path) {\n+        p.global.hash(&mut self.s);\n+        for p in &p.segments {\n+            self.hash_name(&p.identifier.name);\n+        }\n+    }\n+\n+    pub fn hash_stmt(&mut self, b: &Stmt) {\n+        match b.node {\n+            StmtDecl(ref _decl, _) => {\n+                let c: fn(_, _) -> _ = StmtDecl;\n+                c.hash(&mut self.s);\n+                // TODO: decl\n+            }\n+            StmtExpr(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtExpr;\n+                c.hash(&mut self.s);\n+                self.hash_expr(expr);\n+            }\n+            StmtSemi(ref expr, _) => {\n+                let c: fn(_, _) -> _ = StmtSemi;\n+                c.hash(&mut self.s);\n+                self.hash_expr(expr);\n+            }\n+        }\n+    }\n+}"}, {"sha": "f5a028219ed7cc2c24429156aa5d6b54e0de2f7f", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88beb351940e888932b30c555c273f18a0254aff/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88beb351940e888932b30c555c273f18a0254aff/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=88beb351940e888932b30c555c273f18a0254aff", "patch": "@@ -16,7 +16,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n mod hir;\n-pub use self::hir::SpanlessEq;\n+pub use self::hir::{SpanlessEq, SpanlessHash};\n pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for"}, {"sha": "9ae9004394830874e7601b33d1250fffebc282f1", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88beb351940e888932b30c555c273f18a0254aff/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88beb351940e888932b30c555c273f18a0254aff/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=88beb351940e888932b30c555c273f18a0254aff", "patch": "@@ -105,6 +105,12 @@ fn if_same_then_else() -> &'static str {\n \n fn ifs_same_cond() {\n     let a = 0;\n+    let b = false;\n+\n+    if b {\n+    }\n+    else if b { //~ERROR this if has the same condition as a previous if\n+    }\n \n     if a == 1 {\n     }"}]}