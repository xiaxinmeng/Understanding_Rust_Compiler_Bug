{"sha": "bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOWVkZTBlYzlmYjc2YzhjYzBiNTcyZWYwNDA1ODExZTFjYjY2NmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T19:04:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-25T19:22:40Z"}, "message": "Extract messy tree handling out of profiling code", "tree": {"sha": "723ee0cd16b656a8db5c65ac65b16cc841608126", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/723ee0cd16b656a8db5c65ac65b16cc841608126"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "html_url": "https://github.com/rust-lang/rust/commit/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f099ead8893fa9551e385b030a4239ea1338451", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f099ead8893fa9551e385b030a4239ea1338451", "html_url": "https://github.com/rust-lang/rust/commit/0f099ead8893fa9551e385b030a4239ea1338451"}], "stats": {"total": 269, "additions": 119, "deletions": 150}, "files": [{"sha": "367ff3f82812ec0449a44c2dea7d7e683a515c82", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "patch": "@@ -1139,6 +1139,7 @@ dependencies = [\n  \"jemalloc-ctl\",\n  \"jemallocator\",\n  \"once_cell\",\n+ \"ra_arena\",\n ]\n \n [[package]]"}, {"sha": "441fbb3cbeffb8c83e6a075cf79a88fc07957280", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "patch": "@@ -96,6 +96,9 @@ impl<T> Arena<T> {\n     pub const fn new() -> Arena<T> {\n         Arena { data: Vec::new() }\n     }\n+    pub fn clear(&mut self) {\n+        self.data.clear();\n+    }\n \n     pub fn len(&self) -> usize {\n         self.data.len()"}, {"sha": "c33b5121ae267f619c2026adfa76b64463158707", "filename": "crates/ra_prof/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2FCargo.toml?ref=bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "patch": "@@ -9,6 +9,7 @@ publish = false\n doctest = false\n \n [dependencies]\n+ra_arena = { path = \"../ra_arena\" }\n once_cell = \"1.3.1\"\n backtrace = { version = \"0.3.44\", optional = true }\n "}, {"sha": "2b8a903636ca645c512940deb3ad77628862e7f8", "filename": "crates/ra_prof/src/hprof.rs", "status": "modified", "additions": 29, "deletions": 150, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fhprof.rs?ref=bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "patch": "@@ -1,4 +1,5 @@\n //! Simple hierarchical profiler\n+use once_cell::sync::Lazy;\n use std::{\n     cell::RefCell,\n     collections::{BTreeMap, HashSet},\n@@ -10,7 +11,7 @@ use std::{\n     time::{Duration, Instant},\n };\n \n-use once_cell::sync::Lazy;\n+use crate::tree::{Idx, Tree};\n \n /// Filtering syntax\n /// env RA_PROFILE=*             // dump everything\n@@ -138,20 +139,20 @@ impl Filter {\n \n struct ProfileStack {\n     starts: Vec<Instant>,\n-    messages: Vec<Message>,\n     filter: Filter,\n+    messages: Tree<Message>,\n }\n \n+#[derive(Default)]\n struct Message {\n-    level: usize,\n     duration: Duration,\n     label: Label,\n     detail: Option<String>,\n }\n \n impl ProfileStack {\n     fn new() -> ProfileStack {\n-        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter: Default::default() }\n+        ProfileStack { starts: Vec::new(), messages: Tree::default(), filter: Default::default() }\n     }\n \n     fn push(&mut self, label: Label) -> bool {\n@@ -171,73 +172,64 @@ impl ProfileStack {\n         }\n \n         self.starts.push(Instant::now());\n+        self.messages.start();\n         true\n     }\n \n     pub fn pop(&mut self, label: Label, detail: Option<String>) {\n         let start = self.starts.pop().unwrap();\n         let duration = start.elapsed();\n         let level = self.starts.len();\n-        self.messages.push(Message { level, duration, label, detail });\n+        self.messages.finish(Message { duration, label, detail });\n         if level == 0 {\n             let longer_than = self.filter.longer_than;\n             // Convert to millis for comparison to avoid problems with rounding\n             // (otherwise we could print `0ms` despite user's `>0` filter when\n             // `duration` is just a few nanos).\n             if duration.as_millis() > longer_than.as_millis() {\n                 let stderr = stderr();\n-                print(&self.messages, longer_than, &mut stderr.lock());\n+                if let Some(root) = self.messages.root() {\n+                    print(&self.messages, root, 0, longer_than, &mut stderr.lock());\n+                }\n             }\n             self.messages.clear();\n             assert!(self.starts.is_empty())\n         }\n     }\n }\n \n-fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n-    if msgs.is_empty() {\n-        return;\n-    }\n-    let children_map = idx_to_children(msgs);\n-    let root_idx = msgs.len() - 1;\n-    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n-}\n-\n-fn print_for_idx(\n-    current_idx: usize,\n-    children_map: &[Vec<usize>],\n-    msgs: &[Message],\n+fn print(\n+    tree: &Tree<Message>,\n+    curr: Idx<Message>,\n+    level: u32,\n     longer_than: Duration,\n     out: &mut impl Write,\n ) {\n-    let current = &msgs[current_idx];\n-    let current_indent = \"    \".repeat(current.level);\n-    let detail = current.detail.as_ref().map(|it| format!(\" @ {}\", it)).unwrap_or_default();\n+    let current_indent = \"    \".repeat(level as usize);\n+    let detail = tree[curr].detail.as_ref().map(|it| format!(\" @ {}\", it)).unwrap_or_default();\n     writeln!(\n         out,\n         \"{}{:5}ms - {}{}\",\n         current_indent,\n-        current.duration.as_millis(),\n-        current.label,\n+        tree[curr].duration.as_millis(),\n+        tree[curr].label,\n         detail,\n     )\n     .expect(\"printing profiling info\");\n \n-    let longer_than_millis = longer_than.as_millis();\n-    let children_indices = &children_map[current_idx];\n     let mut accounted_for = Duration::default();\n     let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n+    for child in tree.children(curr) {\n+        accounted_for += tree[child].duration;\n \n-    for child_idx in children_indices.iter() {\n-        let child = &msgs[*child_idx];\n-        if child.duration.as_millis() > longer_than_millis {\n-            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n+        if tree[child].duration.as_millis() > longer_than.as_millis() {\n+            print(tree, child, level + 1, longer_than, out)\n         } else {\n-            let pair = short_children.entry(child.label).or_insert((Duration::default(), 0));\n-            pair.0 += child.duration;\n-            pair.1 += 1;\n+            let (total_duration, cnt) =\n+                short_children.entry(tree[child].label).or_insert((Duration::default(), 0));\n+            *total_duration += tree[child].duration;\n+            *cnt += 1;\n         }\n-        accounted_for += child.duration;\n     }\n \n     for (child_msg, (duration, count)) in short_children.iter() {\n@@ -246,122 +238,9 @@ fn print_for_idx(\n             .expect(\"printing profiling info\");\n     }\n \n-    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n-    if !children_indices.is_empty()\n-        && unaccounted_millis > 0\n-        && unaccounted_millis > longer_than_millis\n-    {\n-        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n+    let unaccounted = tree[curr].duration - accounted_for;\n+    if tree.children(curr).next().is_some() && unaccounted > longer_than {\n+        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted.as_millis())\n             .expect(\"printing profiling info\");\n     }\n }\n-\n-/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n-///\n-/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n-/// In other words, a postorder of the call graph. In particular, the root is the last element of\n-/// `msgs`.\n-fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n-    // Initialize with the index of the root; `msgs` and `ancestors` should be never empty.\n-    assert!(!msgs.is_empty());\n-    let mut ancestors = vec![msgs.len() - 1];\n-    let mut result: Vec<Vec<usize>> = vec![vec![]; msgs.len()];\n-    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n-        // We need to find the parent of the current message, i.e., the last ancestor that has a\n-        // level lower than the current message.\n-        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n-            ancestors.pop();\n-        }\n-        result[*ancestors.last().unwrap()].push(idx);\n-        ancestors.push(idx);\n-    }\n-    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n-    // to get the more natural order where the first element is the first child.\n-    for vec in result.iter_mut() {\n-        vec.reverse();\n-    }\n-    result\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_basic_profile() {\n-        let s = vec![\"profile1\".to_string(), \"profile2\".to_string()];\n-        let f = Filter::new(2, s, Duration::new(0, 0));\n-        set_filter(f);\n-        profiling_function1();\n-    }\n-\n-    fn profiling_function1() {\n-        let _p = profile(\"profile1\");\n-        profiling_function2();\n-    }\n-\n-    fn profiling_function2() {\n-        let _p = profile(\"profile2\");\n-    }\n-\n-    #[test]\n-    fn test_longer_than() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 1, duration: Duration::from_nanos(3), label: \"bar\", detail: None },\n-            Message { level: 1, duration: Duration::from_nanos(2), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(1), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n-        // when printing.\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap(),\n-            \"    1ms - foo\\n        0ms - bar (2 calls)\\n\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unaccounted_for_topmost() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 1, duration: Duration::from_millis(2), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(5), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n-            vec![\n-                \"    5ms - foo\",\n-                \"        2ms - bar\",\n-                \"        3ms - ???\",\n-                // Dummy comment to improve formatting\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unaccounted_for_multiple_levels() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 2, duration: Duration::from_millis(3), label: \"baz\", detail: None },\n-            Message { level: 1, duration: Duration::from_millis(5), label: \"bar\", detail: None },\n-            Message { level: 2, duration: Duration::from_millis(2), label: \"baz\", detail: None },\n-            Message { level: 1, duration: Duration::from_millis(4), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(9), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n-            vec![\n-                \"    9ms - foo\",\n-                \"        5ms - bar\",\n-                \"            3ms - baz\",\n-                \"            2ms - ???\",\n-                \"        4ms - bar\",\n-                \"            2ms - baz\",\n-                \"            2ms - ???\",\n-            ]\n-        );\n-    }\n-}"}, {"sha": "89df7f04b7f90dbbbf62064ca710e636ffa7ce84", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "patch": "@@ -4,6 +4,7 @@ mod memory_usage;\n #[cfg(feature = \"cpu_profiler\")]\n mod google_cpu_profiler;\n mod hprof;\n+mod tree;\n \n use std::cell::RefCell;\n "}, {"sha": "9ea5b5db8e1f3fdd42c128815e461705a14b0942", "filename": "crates/ra_prof/src/tree.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2Fsrc%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e/crates%2Fra_prof%2Fsrc%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Ftree.rs?ref=bd9ede0ec9fb76c8cc0b572ef0405811e1cb666e", "patch": "@@ -0,0 +1,84 @@\n+//! A simple tree implementation which tries to not allocate all over the place.\n+use std::ops;\n+\n+use ra_arena::Arena;\n+\n+#[derive(Default)]\n+pub struct Tree<T> {\n+    nodes: Arena<Node<T>>,\n+    current_path: Vec<(Idx<T>, Option<Idx<T>>)>,\n+}\n+\n+pub type Idx<T> = ra_arena::Idx<Node<T>>;\n+\n+impl<T> Tree<T> {\n+    pub fn start(&mut self)\n+    where\n+        T: Default,\n+    {\n+        let me = self.nodes.alloc(Node::new(T::default()));\n+        if let Some((parent, last_child)) = self.current_path.last_mut() {\n+            let slot = match *last_child {\n+                Some(last_child) => &mut self.nodes[last_child].next_sibling,\n+                None => &mut self.nodes[*parent].first_child,\n+            };\n+            let prev = slot.replace(me);\n+            assert!(prev.is_none());\n+            *last_child = Some(me);\n+        }\n+\n+        self.current_path.push((me, None));\n+    }\n+\n+    pub fn finish(&mut self, data: T) {\n+        let (me, _last_child) = self.current_path.pop().unwrap();\n+        self.nodes[me].data = data;\n+    }\n+\n+    pub fn root(&self) -> Option<Idx<T>> {\n+        self.nodes.iter().next().map(|(idx, _)| idx)\n+    }\n+\n+    pub fn children(&self, idx: Idx<T>) -> impl Iterator<Item = Idx<T>> + '_ {\n+        NodeIter { nodes: &self.nodes, next: self.nodes[idx].first_child }\n+    }\n+    pub fn clear(&mut self) {\n+        self.nodes.clear();\n+        self.current_path.clear();\n+    }\n+}\n+\n+impl<T> ops::Index<Idx<T>> for Tree<T> {\n+    type Output = T;\n+    fn index(&self, index: Idx<T>) -> &T {\n+        &self.nodes[index].data\n+    }\n+}\n+\n+pub struct Node<T> {\n+    data: T,\n+    first_child: Option<Idx<T>>,\n+    next_sibling: Option<Idx<T>>,\n+}\n+\n+impl<T> Node<T> {\n+    fn new(data: T) -> Node<T> {\n+        Node { data, first_child: None, next_sibling: None }\n+    }\n+}\n+\n+struct NodeIter<'a, T> {\n+    nodes: &'a Arena<Node<T>>,\n+    next: Option<Idx<T>>,\n+}\n+\n+impl<'a, T> Iterator for NodeIter<'a, T> {\n+    type Item = Idx<T>;\n+\n+    fn next(&mut self) -> Option<Idx<T>> {\n+        self.next.map(|next| {\n+            self.next = self.nodes[next].next_sibling;\n+            next\n+        })\n+    }\n+}"}]}