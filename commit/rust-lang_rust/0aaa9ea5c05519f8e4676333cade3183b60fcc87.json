{"sha": "0aaa9ea5c05519f8e4676333cade3183b60fcc87", "node_id": "C_kwDOAAsO6NoAKDBhYWE5ZWE1YzA1NTE5ZjhlNDY3NjMzM2NhZGUzMTgzYjYwZmNjODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T11:33:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T11:33:43Z"}, "message": "Auto merge of #2772 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "34763881e535998c36985e301865ef1aeb9dbf23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34763881e535998c36985e301865ef1aeb9dbf23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aaa9ea5c05519f8e4676333cade3183b60fcc87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aaa9ea5c05519f8e4676333cade3183b60fcc87", "html_url": "https://github.com/rust-lang/rust/commit/0aaa9ea5c05519f8e4676333cade3183b60fcc87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aaa9ea5c05519f8e4676333cade3183b60fcc87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22", "html_url": "https://github.com/rust-lang/rust/commit/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22"}, {"sha": "a78e178b659dc1cf29b0482c97006f2e84af8419", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78e178b659dc1cf29b0482c97006f2e84af8419", "html_url": "https://github.com/rust-lang/rust/commit/a78e178b659dc1cf29b0482c97006f2e84af8419"}], "stats": {"total": 39751, "additions": 29960, "deletions": 9791}, "files": [{"sha": "552680f06f66dd58390c69f5b1c09f3c4205acc8", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -418,36 +418,36 @@ jobs:\n             os: windows-latest-xl\n           - name: i686-mingw-1\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --set llvm.allow-old-toolchain\"\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-1\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: i686-mingw-2\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --set llvm.allow-old-toolchain\"\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-2\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: x86_64-mingw-1\n             env:\n               SCRIPT: make ci-mingw-subset-1\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler --set llvm.allow-old-toolchain\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: x86_64-mingw-2\n             env:\n               SCRIPT: make ci-mingw-subset-2\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler --set llvm.allow-old-toolchain\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n             os: windows-latest-xl\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler --set rust.lto=thin\"\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc\n@@ -465,7 +465,7 @@ jobs:\n             os: windows-latest-xl\n           - name: dist-i686-mingw\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               CUSTOM_MINGW: 1\n@@ -474,7 +474,7 @@ jobs:\n           - name: dist-x86_64-mingw\n             env:\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1"}, {"sha": "b35892ccd523e9cba17f412e8b7817e58f24deb5", "filename": "Cargo.lock", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -351,7 +351,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 4.1.1\",\n+ \"clap 4.1.4\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -655,9 +655,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"4.1.1\"\n+version = \"4.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ec7a4128863c188deefe750ac1d1dfe66c236909f845af04beed823638dc1b2\"\n+checksum = \"f13b9c79b5d1dd500d20ef541215a6423c75829ef43117e1b4d17fd8af0b5d76\"\n dependencies = [\n  \"bitflags\",\n  \"clap_derive 4.1.0\",\n@@ -675,7 +675,7 @@ version = \"4.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10861370d2ba66b0f5989f83ebf35db6421713fd92351790e7fdd6c36774c56b\"\n dependencies = [\n- \"clap 4.1.1\",\n+ \"clap 4.1.4\",\n ]\n \n [[package]]\n@@ -724,7 +724,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.68\"\n+version = \"0.1.69\"\n dependencies = [\n  \"clippy_lints\",\n  \"clippy_utils\",\n@@ -766,7 +766,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.68\"\n+version = \"0.1.69\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_utils\",\n@@ -789,7 +789,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.68\"\n+version = \"0.1.69\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n@@ -1168,7 +1168,7 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"declare_clippy_lint\"\n-version = \"0.1.68\"\n+version = \"0.1.69\"\n dependencies = [\n  \"itertools\",\n  \"quote\",\n@@ -1799,9 +1799,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.16.1\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ccf7f68c2995f392c49fffb4f95ae2c873297830eb25c6bc4c114ce8f4562acc\"\n+checksum = \"be36bc9e0546df253c0cc41fd0af34f5e92845ad8509462ec76672fac6997f5b\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -2294,7 +2294,7 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap 4.1.1\",\n+ \"clap 4.1.4\",\n  \"fs-err\",\n  \"rustdoc-json-types\",\n  \"serde\",\n@@ -2365,9 +2365,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.14.2+1.5.1\"\n+version = \"0.14.1+1.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7f3d95f6b51075fe9810a7ae22c7095f12b98005ab364d8544797a825ce946a4\"\n+checksum = \"4a07fb2692bc3593bda59de45a502bb3071659f2c515e28c71e728306b038e17\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -2557,7 +2557,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 4.1.1\",\n+ \"clap 4.1.4\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.10.0\",\n@@ -3528,7 +3528,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 4.1.1\",\n+ \"clap 4.1.4\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -3672,6 +3672,7 @@ name = \"rustc_ast\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n+ \"memchr\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n@@ -3729,6 +3730,7 @@ name = \"rustc_ast_pretty\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n+ \"rustc_parse_format\",\n  \"rustc_span\",\n ]\n \n@@ -4926,7 +4928,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.2.0\"\n+version = \"0.3.0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4936,7 +4938,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.5.1\"\n+version = \"1.5.2\"\n dependencies = [\n  \"annotate-snippets\",\n  \"anyhow\",\n@@ -5214,9 +5216,9 @@ checksum = \"cc88c725d61fc6c3132893370cac4a0200e3fedf5da8331c570664b1987f5ca2\"\n \n [[package]]\n name = \"snap\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n+checksum = \"5e9f0ab6ef7eb7353d9119c170a436d1bf248eea575ac42d19d12f4e34130831\"\n \n [[package]]\n name = \"snapbox\""}, {"sha": "a63d4e8a043c606e4384eb5b7f6d6bc581802de9", "filename": "RELEASES.md", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,3 +1,106 @@\n+Version 1.67.0 (2023-01-26)\n+==========================\n+\n+<a id=\"1.67.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Make `Sized` predicates coinductive, allowing cycles.](https://github.com/rust-lang/rust/pull/100386/)\n+- [`#[must_use]` annotations on `async fn` also affect the `Future::Output`.](https://github.com/rust-lang/rust/pull/100633/)\n+- [Elaborate supertrait obligations when deducing closure signatures.](https://github.com/rust-lang/rust/pull/101834/)\n+- [Invalid literals are no longer an error under `cfg(FALSE)`.](https://github.com/rust-lang/rust/pull/102944/)\n+- [Unreserve braced enum variants in value namespace.](https://github.com/rust-lang/rust/pull/103578/)\n+\n+<a id=\"1.67.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Enable varargs support for calling conventions other than `C` or `cdecl`.](https://github.com/rust-lang/rust/pull/97971/)\n+- [Add new MIR constant propagation based on dataflow analysis.](https://github.com/rust-lang/rust/pull/101168/)\n+- [Optimize field ordering by grouping m\\*2^n-sized fields with equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n+- [Stabilize native library modifier `verbatim`.](https://github.com/rust-lang/rust/pull/104360/)\n+\n+Added and removed targets:\n+\n+- [Add a tier 3 target for PowerPC on AIX](https://github.com/rust-lang/rust/pull/102293/), `powerpc64-ibm-aix`.\n+- [Add a tier 3 target for the Sony PlayStation 1](https://github.com/rust-lang/rust/pull/102689/), `mipsel-sony-psx`.\n+- [Add tier 3 `no_std` targets for the QNX Neutrino RTOS](https://github.com/rust-lang/rust/pull/102701/),\n+  `aarch64-unknown-nto-qnx710` and `x86_64-pc-nto-qnx710`.\n+- [Remove tier 3 `linuxkernel` targets](https://github.com/rust-lang/rust/pull/104015/) (not used by the actual kernel).\n+\n+Refer to Rust's [platform support page][platform-support-doc]\n+for more information on Rust's tiered platform support.\n+\n+<a id=\"1.67.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Merge `crossbeam-channel` into `std::sync::mpsc`.](https://github.com/rust-lang/rust/pull/93563/)\n+- [Fix inconsistent rounding of 0.5 when formatted to 0 decimal places.](https://github.com/rust-lang/rust/pull/102935/)\n+- [Derive `Eq` and `Hash` for `ControlFlow`.](https://github.com/rust-lang/rust/pull/103084/)\n+- [Don't build `compiler_builtins` with `-C panic=abort`.](https://github.com/rust-lang/rust/pull/103786/)\n+\n+<a id=\"1.67.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`{integer}::checked_ilog`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.checked_ilog)\n+- [`{integer}::checked_ilog2`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.checked_ilog2)\n+- [`{integer}::checked_ilog10`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.checked_ilog10)\n+- [`{integer}::ilog`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.ilog)\n+- [`{integer}::ilog2`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.ilog2)\n+- [`{integer}::ilog10`](https://doc.rust-lang.org/stable/std/primitive.i32.html#method.ilog10)\n+- [`NonZeroU*::ilog2`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#method.ilog2)\n+- [`NonZeroU*::ilog10`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#method.ilog10)\n+- [`NonZero*::BITS`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#associatedconstant.BITS)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`char::from_u32`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.from_u32)\n+- [`char::from_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.from_digit)\n+- [`char::to_digit`](https://doc.rust-lang.org/stable/std/primitive.char.html#method.to_digit)\n+- [`core::char::from_u32`](https://doc.rust-lang.org/stable/core/char/fn.from_u32.html)\n+- [`core::char::from_digit`](https://doc.rust-lang.org/stable/core/char/fn.from_digit.html)\n+\n+<a id=\"1.67.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [The layout of `repr(Rust)` types now groups m\\*2^n-sized fields with\n+  equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n+  This is intended to be an optimization, but it is also known to increase type\n+  sizes in a few cases for the placement of enum tags. As a reminder, the layout\n+  of `repr(Rust)` types is an implementation detail, subject to change.\n+- [0.5 now rounds to 0 when formatted to 0 decimal places.](https://github.com/rust-lang/rust/pull/102935/)\n+  This makes it consistent with the rest of floating point formatting that\n+  rounds ties toward even digits.\n+- [Chains of `&&` and `||` will now drop temporaries from their sub-expressions in\n+  evaluation order, left-to-right.](https://github.com/rust-lang/rust/pull/103293/)\n+  Previously, it was \"twisted\" such that the _first_ expression dropped its\n+  temporaries _last_, after all of the other expressions dropped in order.\n+- [Underscore suffixes on string literals are now a hard error.](https://github.com/rust-lang/rust/pull/103914/)\n+  This has been a future-compatibility warning since 1.20.0.\n+- [Stop passing `-export-dynamic` to `wasm-ld`.](https://github.com/rust-lang/rust/pull/105405/)\n+- [`main` is now mangled as `__main_void` on `wasm32-wasi`.](https://github.com/rust-lang/rust/pull/105468/)\n+- [Cargo now emits an error if there are multiple registries in the configuration\n+  with the same index URL.](https://github.com/rust-lang/cargo/pull/10592)\n+\n+<a id=\"1.67.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Rewrite LLVM's archive writer in Rust.](https://github.com/rust-lang/rust/pull/97485/)\n+\n Version 1.66.1 (2023-01-10)\n ===========================\n "}, {"sha": "fe65ad9c6cb0e9bde1aaff6e4801ef2f2b8c964a", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -267,6 +267,9 @@ impl TargetDataLayout {\n                 [\"a\", ref a @ ..] => dl.aggregate_align = align(a, \"a\")?,\n                 [\"f32\", ref a @ ..] => dl.f32_align = align(a, \"f32\")?,\n                 [\"f64\", ref a @ ..] => dl.f64_align = align(a, \"f64\")?,\n+                // FIXME(erikdesjardins): we should be parsing nonzero address spaces\n+                // this will require replacing TargetDataLayout::{pointer_size,pointer_align}\n+                // with e.g. `fn pointer_size_in(AddressSpace)`\n                 [p @ \"p\", s, ref a @ ..] | [p @ \"p0\", s, ref a @ ..] => {\n                     dl.pointer_size = size(s, p)?;\n                     dl.pointer_align = align(a, p)?;\n@@ -861,7 +864,7 @@ pub enum Primitive {\n     Int(Integer, bool),\n     F32,\n     F64,\n-    Pointer,\n+    Pointer(AddressSpace),\n }\n \n impl Primitive {\n@@ -872,7 +875,10 @@ impl Primitive {\n             Int(i, _) => i.size(),\n             F32 => Size::from_bits(32),\n             F64 => Size::from_bits(64),\n-            Pointer => dl.pointer_size,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different sizes\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_size,\n         }\n     }\n \n@@ -883,26 +889,12 @@ impl Primitive {\n             Int(i, _) => i.align(dl),\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n-            Pointer => dl.pointer_align,\n+            // FIXME(erikdesjardins): ignoring address space is technically wrong, pointers in\n+            // different address spaces can have different alignments\n+            // (but TargetDataLayout doesn't currently parse that part of the DL string)\n+            Pointer(_) => dl.pointer_align,\n         }\n     }\n-\n-    // FIXME(eddyb) remove, it's trivial thanks to `matches!`.\n-    #[inline]\n-    pub fn is_float(self) -> bool {\n-        matches!(self, F32 | F64)\n-    }\n-\n-    // FIXME(eddyb) remove, it's completely unused.\n-    #[inline]\n-    pub fn is_int(self) -> bool {\n-        matches!(self, Int(..))\n-    }\n-\n-    #[inline]\n-    pub fn is_ptr(self) -> bool {\n-        matches!(self, Pointer)\n-    }\n }\n \n /// Inclusive wrap-around range of valid values, that is, if\n@@ -1188,7 +1180,8 @@ impl FieldsShape {\n /// An identifier that specifies the address space that some operation\n /// should operate on. Special address spaces have an effect on code generation,\n /// depending on the target and the address spaces it implements.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n pub struct AddressSpace(pub u32);\n \n impl AddressSpace {\n@@ -1468,7 +1461,6 @@ pub struct PointeeInfo {\n     pub size: Size,\n     pub align: Align,\n     pub safe: Option<PointerKind>,\n-    pub address_space: AddressSpace,\n }\n \n /// Used in `might_permit_raw_init` to indicate the kind of initialisation"}, {"sha": "10d7fa1db605a7dc7c5e70b53fe175c1f60ff185", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n+memchr = \"2.5.0\"\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_lexer = { path = \"../rustc_lexer\" }"}, {"sha": "8ad3270c5103ec24cbd11429b4f7cd7984fba6fd", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -18,6 +18,7 @@\n //! - [`Attribute`]: Metadata associated with item.\n //! - [`UnOp`], [`BinOp`], and [`BinOpKind`]: Unary and binary operators.\n \n+pub use crate::format::*;\n pub use crate::util::parser::ExprPrecedence;\n pub use GenericArgs::*;\n pub use UnsafeSource::*;\n@@ -1269,6 +1270,7 @@ impl Expr {\n             ExprKind::Try(..) => ExprPrecedence::Try,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n             ExprKind::Yeet(..) => ExprPrecedence::Yeet,\n+            ExprKind::FormatArgs(..) => ExprPrecedence::FormatArgs,\n             ExprKind::Err => ExprPrecedence::Err,\n         }\n     }\n@@ -1499,6 +1501,9 @@ pub enum ExprKind {\n     /// with a `ByteStr` literal.\n     IncludedBytes(Lrc<[u8]>),\n \n+    /// A `format_args!()` expression.\n+    FormatArgs(P<FormatArgs>),\n+\n     /// Placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }"}, {"sha": "d021bea5ecacb94c7b616a8ffeca10a0c1369c87", "filename": "compiler/rustc_ast/src/format.rs", "status": "renamed", "additions": 50, "deletions": 18, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,5 +1,5 @@\n-use rustc_ast::ptr::P;\n-use rustc_ast::Expr;\n+use crate::ptr::P;\n+use crate::Expr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n@@ -39,7 +39,7 @@ use rustc_span::Span;\n /// Basically the \"AST\" for a complete `format_args!()`.\n ///\n /// E.g., `format_args!(\"hello {name}\");`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArgs {\n     pub span: Span,\n     pub template: Vec<FormatArgsPiece>,\n@@ -49,7 +49,7 @@ pub struct FormatArgs {\n /// A piece of a format template string.\n ///\n /// E.g. \"hello\" or \"{name}\".\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FormatArgsPiece {\n     Literal(Symbol),\n     Placeholder(FormatPlaceholder),\n@@ -59,14 +59,20 @@ pub enum FormatArgsPiece {\n ///\n /// E.g. `1, 2, name=\"ferris\", n=3`,\n /// but also implicit captured arguments like `x` in `format_args!(\"{x}\")`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArguments {\n     arguments: Vec<FormatArgument>,\n     num_unnamed_args: usize,\n     num_explicit_args: usize,\n     names: FxHashMap<Symbol, usize>,\n }\n \n+// FIXME: Rustdoc has trouble proving Send/Sync for this. See #106930.\n+#[cfg(parallel_compiler)]\n+unsafe impl Sync for FormatArguments {}\n+#[cfg(parallel_compiler)]\n+unsafe impl Send for FormatArguments {}\n+\n impl FormatArguments {\n     pub fn new() -> Self {\n         Self {\n@@ -121,18 +127,22 @@ impl FormatArguments {\n         &self.arguments[..self.num_explicit_args]\n     }\n \n-    pub fn into_vec(self) -> Vec<FormatArgument> {\n-        self.arguments\n+    pub fn all_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..]\n+    }\n+\n+    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n+        &mut self.arguments[..]\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FormatArgument {\n     pub kind: FormatArgumentKind,\n     pub expr: P<Expr>,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FormatArgumentKind {\n     /// `format_args(\u2026, arg)`\n     Normal,\n@@ -152,7 +162,7 @@ impl FormatArgumentKind {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub struct FormatPlaceholder {\n     /// Index into [`FormatArgs::arguments`].\n     pub argument: FormatArgPosition,\n@@ -164,7 +174,7 @@ pub struct FormatPlaceholder {\n     pub format_options: FormatOptions,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub struct FormatArgPosition {\n     /// Which argument this position refers to (Ok),\n     /// or would've referred to if it existed (Err).\n@@ -175,7 +185,7 @@ pub struct FormatArgPosition {\n     pub span: Option<Span>,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatArgPositionKind {\n     /// `{}` or `{:.*}`\n     Implicit,\n@@ -185,7 +195,7 @@ pub enum FormatArgPositionKind {\n     Named,\n }\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq, Hash)]\n pub enum FormatTrait {\n     /// `{}`\n     Display,\n@@ -207,7 +217,7 @@ pub enum FormatTrait {\n     UpperHex,\n }\n \n-#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Default, Debug, PartialEq, Eq)]\n pub struct FormatOptions {\n     /// The width. E.g. `{:5}` or `{:width$}`.\n     pub width: Option<FormatCount>,\n@@ -217,11 +227,33 @@ pub struct FormatOptions {\n     pub alignment: Option<FormatAlignment>,\n     /// The fill character. E.g. the `.` in `{:.>10}`.\n     pub fill: Option<char>,\n-    /// The `+`, `-`, `0`, `#`, `x?` and `X?` flags.\n-    pub flags: u32,\n+    /// The `+` or `-` flag.\n+    pub sign: Option<FormatSign>,\n+    /// The `#` flag.\n+    pub alternate: bool,\n+    /// The `0` flag. E.g. the `0` in `{:02x}`.\n+    pub zero_pad: bool,\n+    /// The `x` or `X` flag (for `Debug` only). E.g. the `x` in `{:x?}`.\n+    pub debug_hex: Option<FormatDebugHex>,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatSign {\n+    /// The `+` flag.\n+    Plus,\n+    /// The `-` flag.\n+    Minus,\n+}\n+\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n+pub enum FormatDebugHex {\n+    /// The `x` flag in `{:x?}`.\n+    Lower,\n+    /// The `X` flag in `{:X?}`.\n+    Upper,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatAlignment {\n     /// `{:<}`\n     Left,\n@@ -231,7 +263,7 @@ pub enum FormatAlignment {\n     Center,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum FormatCount {\n     /// `{:5}` or `{:.5}`\n     Literal(usize),", "previous_filename": "compiler/rustc_builtin_macros/src/format/ast.rs"}, {"sha": "23c32fa96ca449e40f705596d897a9a6c0d14f87", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -16,7 +16,6 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n-#![feature(slice_internals)]\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -42,6 +41,7 @@ pub mod ast_traits;\n pub mod attr;\n pub mod entry;\n pub mod expand;\n+pub mod format;\n pub mod mut_visit;\n pub mod node_id;\n pub mod ptr;\n@@ -51,6 +51,7 @@ pub mod visit;\n \n pub use self::ast::*;\n pub use self::ast_traits::{AstDeref, AstNodeWrapper, HasAttrs, HasNodeId, HasSpan, HasTokens};\n+pub use self::format::*;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "1dd62626b8f5e33607a4e87a362b4875997128ef", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -297,6 +297,10 @@ pub trait MutVisitor: Sized {\n     fn visit_inline_asm_sym(&mut self, sym: &mut InlineAsmSym) {\n         noop_visit_inline_asm_sym(sym, self)\n     }\n+\n+    fn visit_format_args(&mut self, fmt: &mut FormatArgs) {\n+        noop_visit_format_args(fmt, self)\n+    }\n }\n \n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n@@ -1284,6 +1288,15 @@ pub fn noop_visit_inline_asm_sym<T: MutVisitor>(\n     vis.visit_path(path);\n }\n \n+pub fn noop_visit_format_args<T: MutVisitor>(fmt: &mut FormatArgs, vis: &mut T) {\n+    for arg in fmt.arguments.all_args_mut() {\n+        if let FormatArgumentKind::Named(name) = &mut arg.kind {\n+            vis.visit_ident(name);\n+        }\n+        vis.visit_expr(&mut arg.expr);\n+    }\n+}\n+\n pub fn noop_visit_expr<T: MutVisitor>(\n     Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n@@ -1425,6 +1438,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             visit_opt(expr, |expr| vis.visit_expr(expr));\n         }\n         ExprKind::InlineAsm(asm) => vis.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(fmt) => vis.visit_format_args(fmt),\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();"}, {"sha": "81efdaa44b365a3979187d37a540640636784a4f", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -271,6 +271,7 @@ pub enum ExprPrecedence {\n     Try,\n     InlineAsm,\n     Mac,\n+    FormatArgs,\n \n     Array,\n     Repeat,\n@@ -335,7 +336,8 @@ impl ExprPrecedence {\n             | ExprPrecedence::Index\n             | ExprPrecedence::Try\n             | ExprPrecedence::InlineAsm\n-            | ExprPrecedence::Mac => PREC_POSTFIX,\n+            | ExprPrecedence::Mac\n+            | ExprPrecedence::FormatArgs => PREC_POSTFIX,\n \n             // Never need parens\n             ExprPrecedence::Array"}, {"sha": "6f57d66b2273a2cf4421d42f8057c4290dfc653e", "filename": "compiler/rustc_ast/src/util/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Funicode.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -17,7 +17,7 @@ pub fn contains_text_flow_control_chars(s: &str) -> bool {\n     // U+2069 - E2 81 A9\n     let mut bytes = s.as_bytes();\n     loop {\n-        match core::slice::memchr::memchr(0xE2, bytes) {\n+        match memchr::memchr(0xE2, bytes) {\n             Some(idx) => {\n                 // bytes are valid UTF-8 -> E2 must be followed by two bytes\n                 let ch = &bytes[idx..idx + 3];"}, {"sha": "e7b2e4b1cb4b072a4d300e0e20b978fa16fb2ee4", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -242,6 +242,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_inline_asm(&mut self, asm: &'ast InlineAsm) {\n         walk_inline_asm(self, asm)\n     }\n+    fn visit_format_args(&mut self, fmt: &'ast FormatArgs) {\n+        walk_format_args(self, fmt)\n+    }\n     fn visit_inline_asm_sym(&mut self, sym: &'ast InlineAsmSym) {\n         walk_inline_asm_sym(self, sym)\n     }\n@@ -400,8 +403,8 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n+        TyKind::Tup(tys) => {\n+            walk_list!(visitor, visit_ty, tys);\n         }\n         TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n@@ -756,6 +759,15 @@ pub fn walk_inline_asm_sym<'a, V: Visitor<'a>>(visitor: &mut V, sym: &'a InlineA\n     visitor.visit_path(&sym.path, sym.id);\n }\n \n+pub fn walk_format_args<'a, V: Visitor<'a>>(visitor: &mut V, fmt: &'a FormatArgs) {\n+    for arg in fmt.arguments.all_args() {\n+        if let FormatArgumentKind::Named(name) = arg.kind {\n+            visitor.visit_ident(name);\n+        }\n+        visitor.visit_expr(&arg.expr);\n+    }\n+}\n+\n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n@@ -896,6 +908,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::MacCall(mac) => visitor.visit_mac_call(mac),\n         ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n+        ExprKind::FormatArgs(f) => visitor.visit_format_args(f),\n         ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }"}, {"sha": "cc523fe7d08f501b44b9c81e35d307ed179b0423", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::def::Res;\n use rustc_hir::definitions::DefPathData;\n use rustc_session::errors::report_lit_error;\n use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n@@ -294,6 +294,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n+                ExprKind::FormatArgs(fmt) => self.lower_format_args(e.span, fmt),\n                 ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n@@ -1735,7 +1736,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::DropTemps(expr))\n     }\n \n-    fn expr_match(\n+    pub(super) fn expr_match(\n         &mut self,\n         span: Span,\n         arg: &'hir hir::Expr<'hir>,\n@@ -1763,7 +1764,44 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[])))\n     }\n \n-    fn expr_call_mut(\n+    pub(super) fn expr_usize(&mut self, sp: Span, value: usize) -> hir::Expr<'hir> {\n+        self.expr(\n+            sp,\n+            hir::ExprKind::Lit(hir::Lit {\n+                span: sp,\n+                node: ast::LitKind::Int(\n+                    value as u128,\n+                    ast::LitIntType::Unsigned(ast::UintTy::Usize),\n+                ),\n+            }),\n+        )\n+    }\n+\n+    pub(super) fn expr_u32(&mut self, sp: Span, value: u32) -> hir::Expr<'hir> {\n+        self.expr(\n+            sp,\n+            hir::ExprKind::Lit(hir::Lit {\n+                span: sp,\n+                node: ast::LitKind::Int(value.into(), ast::LitIntType::Unsigned(ast::UintTy::U32)),\n+            }),\n+        )\n+    }\n+\n+    pub(super) fn expr_char(&mut self, sp: Span, value: char) -> hir::Expr<'hir> {\n+        self.expr(sp, hir::ExprKind::Lit(hir::Lit { span: sp, node: ast::LitKind::Char(value) }))\n+    }\n+\n+    pub(super) fn expr_str(&mut self, sp: Span, value: Symbol) -> hir::Expr<'hir> {\n+        self.expr(\n+            sp,\n+            hir::ExprKind::Lit(hir::Lit {\n+                span: sp,\n+                node: ast::LitKind::Str(value, ast::StrStyle::Cooked),\n+            }),\n+        )\n+    }\n+\n+    pub(super) fn expr_call_mut(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n@@ -1772,7 +1810,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, hir::ExprKind::Call(e, args))\n     }\n \n-    fn expr_call(\n+    pub(super) fn expr_call(\n         &mut self,\n         span: Span,\n         e: &'hir hir::Expr<'hir>,\n@@ -1814,6 +1852,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         )\n     }\n \n+    /// `<LangItem>::name`\n+    pub(super) fn expr_lang_item_type_relative(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        name: Symbol,\n+    ) -> hir::Expr<'hir> {\n+        let path = hir::ExprKind::Path(hir::QPath::TypeRelative(\n+            self.arena.alloc(self.ty(\n+                span,\n+                hir::TyKind::Path(hir::QPath::LangItem(lang_item, self.lower_span(span), None)),\n+            )),\n+            self.arena.alloc(hir::PathSegment::new(\n+                Ident::new(name, span),\n+                self.next_id(),\n+                Res::Err,\n+            )),\n+        ));\n+        self.expr(span, path)\n+    }\n+\n     pub(super) fn expr_ident(\n         &mut self,\n         sp: Span,\n@@ -1872,12 +1931,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(b.span, hir::ExprKind::Block(b, None))\n     }\n \n+    pub(super) fn expr_array_ref(\n+        &mut self,\n+        span: Span,\n+        elements: &'hir [hir::Expr<'hir>],\n+    ) -> hir::Expr<'hir> {\n+        let addrof = hir::ExprKind::AddrOf(\n+            hir::BorrowKind::Ref,\n+            hir::Mutability::Not,\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Array(elements))),\n+        );\n+        self.expr(span, addrof)\n+    }\n+\n     pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         hir::Expr { hir_id, kind, span: self.lower_span(span) }\n     }\n \n-    fn expr_field(\n+    pub(super) fn expr_field(\n         &mut self,\n         ident: Ident,\n         expr: &'hir hir::Expr<'hir>,\n@@ -1892,7 +1964,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n+    pub(super) fn arm(\n+        &mut self,\n+        pat: &'hir hir::Pat<'hir>,\n+        expr: &'hir hir::Expr<'hir>,\n+    ) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             pat,"}, {"sha": "e7dd0b18a03b9adc0743c423611b2f758414e3e9", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,398 @@\n+use super::LoweringContext;\n+use rustc_ast as ast;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_hir as hir;\n+use rustc_span::{\n+    sym,\n+    symbol::{kw, Ident},\n+    Span,\n+};\n+\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n+        expand_format_args(self, sp, fmt)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum ArgumentType {\n+    Format(FormatTrait),\n+    Usize,\n+}\n+\n+/// Generate a hir expression representing an argument to a format_args invocation.\n+///\n+/// Generates:\n+///\n+/// ```text\n+///     <core::fmt::ArgumentV1>::new_\u2026(arg)\n+/// ```\n+fn make_argument<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    arg: &'hir hir::Expr<'hir>,\n+    ty: ArgumentType,\n+) -> hir::Expr<'hir> {\n+    use ArgumentType::*;\n+    use FormatTrait::*;\n+    let new_fn = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatArgument,\n+        match ty {\n+            Format(Display) => sym::new_display,\n+            Format(Debug) => sym::new_debug,\n+            Format(LowerExp) => sym::new_lower_exp,\n+            Format(UpperExp) => sym::new_upper_exp,\n+            Format(Octal) => sym::new_octal,\n+            Format(Pointer) => sym::new_pointer,\n+            Format(Binary) => sym::new_binary,\n+            Format(LowerHex) => sym::new_lower_hex,\n+            Format(UpperHex) => sym::new_upper_hex,\n+            Usize => sym::from_usize,\n+        },\n+    ));\n+    ctx.expr_call_mut(sp, new_fn, std::slice::from_ref(arg))\n+}\n+\n+/// Generate a hir expression for a format_args Count.\n+///\n+/// Generates:\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Count>::Is(\u2026)\n+/// ```\n+///\n+/// or\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Count>::Param(\u2026)\n+/// ```\n+///\n+/// or\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Count>::Implied\n+/// ```\n+fn make_count<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    count: &Option<FormatCount>,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> hir::Expr<'hir> {\n+    match count {\n+        Some(FormatCount::Literal(n)) => {\n+            let count_is = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                sp,\n+                hir::LangItem::FormatCount,\n+                sym::Is,\n+            ));\n+            let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, *n)]);\n+            ctx.expr_call_mut(sp, count_is, value)\n+        }\n+        Some(FormatCount::Argument(arg)) => {\n+            if let Ok(arg_index) = arg.index {\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+                    sp,\n+                    hir::LangItem::FormatCount,\n+                    sym::Param,\n+                ));\n+                let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n+                ctx.expr_call_mut(sp, count_param, value)\n+            } else {\n+                ctx.expr(sp, hir::ExprKind::Err)\n+            }\n+        }\n+        None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n+    }\n+}\n+\n+/// Generate a hir expression for a format_args placeholder specification.\n+///\n+/// Generates\n+///\n+/// ```text\n+///     <core::fmt::rt::v1::Argument::new(\n+///         \u2026usize, // position\n+///         '\u2026', // fill\n+///         <core::fmt::rt::v1::Alignment>::\u2026, // alignment\n+///         \u2026u32, // flags\n+///         <core::fmt::rt::v1::Count::\u2026>, // width\n+///         <core::fmt::rt::v1::Count::\u2026>, // precision\n+///     )\n+/// ```\n+fn make_format_spec<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    sp: Span,\n+    placeholder: &FormatPlaceholder,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> hir::Expr<'hir> {\n+    let position = match placeholder.argument.index {\n+        Ok(arg_index) => {\n+            let (i, _) =\n+                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            ctx.expr_usize(sp, i)\n+        }\n+        Err(_) => ctx.expr(sp, hir::ExprKind::Err),\n+    };\n+    let &FormatOptions {\n+        ref width,\n+        ref precision,\n+        alignment,\n+        fill,\n+        sign,\n+        alternate,\n+        zero_pad,\n+        debug_hex,\n+    } = &placeholder.format_options;\n+    let fill = ctx.expr_char(sp, fill.unwrap_or(' '));\n+    let align = ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatAlignment,\n+        match alignment {\n+            Some(FormatAlignment::Left) => sym::Left,\n+            Some(FormatAlignment::Right) => sym::Right,\n+            Some(FormatAlignment::Center) => sym::Center,\n+            None => sym::Unknown,\n+        },\n+    );\n+    // This needs to match `FlagV1` in library/core/src/fmt/mod.rs.\n+    let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)\n+        | ((sign == Some(FormatSign::Minus)) as u32) << 1\n+        | (alternate as u32) << 2\n+        | (zero_pad as u32) << 3\n+        | ((debug_hex == Some(FormatDebugHex::Lower)) as u32) << 4\n+        | ((debug_hex == Some(FormatDebugHex::Upper)) as u32) << 5;\n+    let flags = ctx.expr_u32(sp, flags);\n+    let precision = make_count(ctx, sp, &precision, argmap);\n+    let width = make_count(ctx, sp, &width, argmap);\n+    let format_placeholder_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+        sp,\n+        hir::LangItem::FormatPlaceholder,\n+        sym::new,\n+    ));\n+    let args = ctx.arena.alloc_from_iter([position, fill, align, flags, precision, width]);\n+    ctx.expr_call_mut(sp, format_placeholder_new, args)\n+}\n+\n+fn expand_format_args<'hir>(\n+    ctx: &mut LoweringContext<'_, 'hir>,\n+    macsp: Span,\n+    fmt: &FormatArgs,\n+) -> hir::ExprKind<'hir> {\n+    let lit_pieces =\n+        ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n+            match piece {\n+                &FormatArgsPiece::Literal(s) => Some(ctx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Placeholder(_) => {\n+                    // Inject empty string before placeholders when not already preceded by a literal piece.\n+                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n+                        Some(ctx.expr_str(fmt.span, kw::Empty))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        }));\n+    let lit_pieces = ctx.expr_array_ref(fmt.span, lit_pieces);\n+\n+    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n+    // or the `Arguments::new_v1` form (false).\n+    let mut use_format_options = false;\n+\n+    // Create a list of all _unique_ (argument, format trait) combinations.\n+    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+    let mut argmap = FxIndexSet::default();\n+    for piece in &fmt.template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if placeholder.format_options != Default::default() {\n+            // Can't use basic form if there's any formatting options.\n+            use_format_options = true;\n+        }\n+        if let Ok(index) = placeholder.argument.index {\n+            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+                // Duplicate (argument, format trait) combination,\n+                // which we'll only put once in the args array.\n+                use_format_options = true;\n+            }\n+        }\n+    }\n+\n+    let format_options = use_format_options.then(|| {\n+        // Generate:\n+        //     &[format_spec_0, format_spec_1, format_spec_2]\n+        let elements: Vec<_> = fmt\n+            .template\n+            .iter()\n+            .filter_map(|piece| {\n+                let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                Some(make_format_spec(ctx, macsp, placeholder, &mut argmap))\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    });\n+\n+    let arguments = fmt.arguments.all_args();\n+\n+    // If the args array contains exactly all the original arguments once,\n+    // in order, we can use a simple array instead of a `match` construction.\n+    // However, if there's a yield point in any argument except the first one,\n+    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    //\n+    // This is an optimization, speeding up compilation about 1-2% in some cases.\n+    // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n+    let use_simple_array = argmap.len() == arguments.len()\n+        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n+\n+    let args = if use_simple_array {\n+        // Generate:\n+        //     &[\n+        //         <core::fmt::ArgumentV1>::new_display(&arg0),\n+        //         <core::fmt::ArgumentV1>::new_lower_hex(&arg1),\n+        //         <core::fmt::ArgumentV1>::new_debug(&arg2),\n+        //         \u2026\n+        //     ]\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .zip(argmap)\n+            .map(|(arg, (_, ty))| {\n+                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                let arg = ctx.lower_expr(&arg.expr);\n+                let ref_arg = ctx.arena.alloc(ctx.expr(\n+                    sp,\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n+                ));\n+                make_argument(ctx, sp, ref_arg, ty)\n+            })\n+            .collect();\n+        ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n+    } else {\n+        // Generate:\n+        //     &match (&arg0, &arg1, &\u2026) {\n+        //         args => [\n+        //             <core::fmt::ArgumentV1>::new_display(args.0),\n+        //             <core::fmt::ArgumentV1>::new_lower_hex(args.1),\n+        //             <core::fmt::ArgumentV1>::new_debug(args.0),\n+        //             \u2026\n+        //         ]\n+        //     }\n+        let args_ident = Ident::new(sym::args, macsp);\n+        let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n+            if let Some(arg) = arguments.get(arg_index) {\n+                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, sp, arg, ty)\n+            } else {\n+                ctx.expr(macsp, hir::ExprKind::Err)\n+            }\n+        }));\n+        let elements: Vec<_> = arguments\n+            .iter()\n+            .map(|arg| {\n+                let arg_expr = ctx.lower_expr(&arg.expr);\n+                ctx.expr(\n+                    arg.expr.span.with_ctxt(macsp.ctxt()),\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg_expr),\n+                )\n+            })\n+            .collect();\n+        let args_tuple = ctx\n+            .arena\n+            .alloc(ctx.expr(macsp, hir::ExprKind::Tup(ctx.arena.alloc_from_iter(elements))));\n+        let array = ctx.arena.alloc(ctx.expr(macsp, hir::ExprKind::Array(args)));\n+        let match_arms = ctx.arena.alloc_from_iter([ctx.arm(args_pat, array)]);\n+        let match_expr = ctx.arena.alloc(ctx.expr_match(\n+            macsp,\n+            args_tuple,\n+            match_arms,\n+            hir::MatchSource::FormatArgs,\n+        ));\n+        ctx.expr(\n+            macsp,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, match_expr),\n+        )\n+    };\n+\n+    if let Some(format_options) = format_options {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_v1_formatted(\n+        //         lit_pieces,\n+        //         args,\n+        //         format_options,\n+        //         unsafe { ::core::fmt::UnsafeArg::new() }\n+        //     )\n+        let new_v1_formatted = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1_formatted,\n+        ));\n+        let unsafe_arg_new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatUnsafeArg,\n+            sym::new,\n+        ));\n+        let unsafe_arg_new_call = ctx.expr_call(macsp, unsafe_arg_new, &[]);\n+        let hir_id = ctx.next_id();\n+        let unsafe_arg = ctx.expr_block(ctx.arena.alloc(hir::Block {\n+            stmts: &[],\n+            expr: Some(unsafe_arg_new_call),\n+            hir_id,\n+            rules: hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::CompilerGenerated),\n+            span: macsp,\n+            targeted_by_break: false,\n+        }));\n+        let args = ctx.arena.alloc_from_iter([lit_pieces, args, format_options, unsafe_arg]);\n+        hir::ExprKind::Call(new_v1_formatted, args)\n+    } else {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_v1(\n+        //         lit_pieces,\n+        //         args,\n+        //     )\n+        let new_v1 = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_v1,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces, args]);\n+        hir::ExprKind::Call(new_v1, new_args)\n+    }\n+}\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            // Macros should be expanded at this point.\n+            unreachable!(\"unexpanded macro in ast lowering\");\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}, {"sha": "f7fe0d771a13c495cf7f14e77ee9363beba686df", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -275,19 +275,6 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_fn(\n-        &mut self,\n-        fk: intravisit::FnKind<'hir>,\n-        fd: &'hir FnDecl<'hir>,\n-        b: BodyId,\n-        _: Span,\n-        id: HirId,\n-    ) {\n-        assert_eq!(self.owner, id.owner);\n-        assert_eq!(self.parent_node, id.local_id);\n-        intravisit::walk_fn(self, fk, fd, b, id);\n-    }\n-\n     fn visit_block(&mut self, block: &'hir Block<'hir>) {\n         self.insert(block.span, block.hir_id, Node::Block(block));\n         self.with_parent(block.hir_id, |this| {"}, {"sha": "2865082bd7a47c5322019389fa660118b1a99cc9", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -67,7 +67,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             current_hir_id_owner: hir::CRATE_OWNER_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n-            local_id_to_def_id: SortedMap::new(),\n             trait_map: Default::default(),\n \n             // Lowering state."}, {"sha": "a04a259529310959009d81dec2ca644f71548d31", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -80,6 +80,7 @@ mod asm;\n mod block;\n mod errors;\n mod expr;\n+mod format;\n mod index;\n mod item;\n mod lifetime_collector;\n@@ -118,7 +119,6 @@ struct LoweringContext<'a, 'hir> {\n \n     current_hir_id_owner: hir::OwnerId,\n     item_local_id_counter: hir::ItemLocalId,\n-    local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n     trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n \n     impl_trait_defs: Vec<hir::GenericParam<'hir>>,\n@@ -416,6 +416,7 @@ fn compute_hir_hash(\n \n pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n+    tcx.ensure().output_filenames(());\n     let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);\n@@ -565,7 +566,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let current_attrs = std::mem::take(&mut self.attrs);\n         let current_bodies = std::mem::take(&mut self.bodies);\n         let current_node_ids = std::mem::take(&mut self.node_id_to_local_id);\n-        let current_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let current_trait_map = std::mem::take(&mut self.trait_map);\n         let current_owner =\n             std::mem::replace(&mut self.current_hir_id_owner, hir::OwnerId { def_id });\n@@ -592,7 +592,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.attrs = current_attrs;\n         self.bodies = current_bodies;\n         self.node_id_to_local_id = current_node_ids;\n-        self.local_id_to_def_id = current_id_to_def_id;\n         self.trait_map = current_trait_map;\n         self.current_hir_id_owner = current_owner;\n         self.item_local_id_counter = current_local_counter;\n@@ -627,7 +626,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn make_owner_info(&mut self, node: hir::OwnerNode<'hir>) -> &'hir hir::OwnerInfo<'hir> {\n         let attrs = std::mem::take(&mut self.attrs);\n         let mut bodies = std::mem::take(&mut self.bodies);\n-        let local_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let trait_map = std::mem::take(&mut self.trait_map);\n \n         #[cfg(debug_assertions)]\n@@ -643,13 +641,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n         let (nodes, parenting) =\n             index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n-        let nodes = hir::OwnerNodes {\n-            hash_including_bodies,\n-            hash_without_bodies,\n-            nodes,\n-            bodies,\n-            local_id_to_def_id,\n-        };\n+        let nodes = hir::OwnerNodes { hash_including_bodies, hash_without_bodies, nodes, bodies };\n         let attrs = {\n             let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n                 let mut stable_hasher = StableHasher::new();\n@@ -708,7 +700,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 assert_ne!(local_id, hir::ItemLocalId::new(0));\n                 if let Some(def_id) = self.opt_local_def_id(ast_node_id) {\n                     self.children.push((def_id, hir::MaybeOwner::NonOwner(hir_id)));\n-                    self.local_id_to_def_id.insert(local_id, def_id);\n                 }\n \n                 if let Some(traits) = self.resolver.trait_map.remove(&ast_node_id) {"}, {"sha": "b4900dc39a8af4d98913c75f26146923df617714", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -6,5 +6,6 @@ edition = \"2021\"\n [lib]\n \n [dependencies]\n-rustc_span = { path = \"../rustc_span\" }\n rustc_ast = { path = \"../rustc_ast\" }\n+rustc_parse_format = { path = \"../rustc_parse_format\" }\n+rustc_span = { path = \"../rustc_span\" }"}, {"sha": "cacfe9eb2f10745f8add02cecd528b90ab3a5b0c", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -6,6 +6,11 @@ use rustc_ast::token;\n use rustc_ast::util::literal::escape_byte_str_symbol;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode};\n+use rustc_ast::{\n+    FormatAlignment, FormatArgPosition, FormatArgsPiece, FormatCount, FormatDebugHex, FormatSign,\n+    FormatTrait,\n+};\n+use std::fmt::Write;\n \n impl<'a> State<'a> {\n     fn print_else(&mut self, els: Option<&ast::Expr>) {\n@@ -527,9 +532,23 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::InlineAsm(a) => {\n+                // FIXME: This should have its own syntax, distinct from a macro invocation.\n                 self.word(\"asm!\");\n                 self.print_inline_asm(a);\n             }\n+            ast::ExprKind::FormatArgs(fmt) => {\n+                // FIXME: This should have its own syntax, distinct from a macro invocation.\n+                self.word(\"format_args!\");\n+                self.popen();\n+                self.rbox(0, Inconsistent);\n+                self.word(reconstruct_format_args_template_string(&fmt.template));\n+                for arg in fmt.arguments.all_args() {\n+                    self.word_space(\",\");\n+                    self.print_expr(&arg.expr);\n+                }\n+                self.end();\n+                self.pclose();\n+            }\n             ast::ExprKind::MacCall(m) => self.print_mac(m),\n             ast::ExprKind::Paren(e) => {\n                 self.popen();\n@@ -629,3 +648,88 @@ impl<'a> State<'a> {\n         }\n     }\n }\n+\n+pub fn reconstruct_format_args_template_string(pieces: &[FormatArgsPiece]) -> String {\n+    let mut template = \"\\\"\".to_string();\n+    for piece in pieces {\n+        match piece {\n+            FormatArgsPiece::Literal(s) => {\n+                for c in s.as_str().escape_debug() {\n+                    template.push(c);\n+                    if let '{' | '}' = c {\n+                        template.push(c);\n+                    }\n+                }\n+            }\n+            FormatArgsPiece::Placeholder(p) => {\n+                template.push('{');\n+                let (Ok(n) | Err(n)) = p.argument.index;\n+                write!(template, \"{n}\").unwrap();\n+                if p.format_options != Default::default() || p.format_trait != FormatTrait::Display\n+                {\n+                    template.push_str(\":\");\n+                }\n+                if let Some(fill) = p.format_options.fill {\n+                    template.push(fill);\n+                }\n+                match p.format_options.alignment {\n+                    Some(FormatAlignment::Left) => template.push_str(\"<\"),\n+                    Some(FormatAlignment::Right) => template.push_str(\">\"),\n+                    Some(FormatAlignment::Center) => template.push_str(\"^\"),\n+                    None => {}\n+                }\n+                match p.format_options.sign {\n+                    Some(FormatSign::Plus) => template.push('+'),\n+                    Some(FormatSign::Minus) => template.push('-'),\n+                    None => {}\n+                }\n+                if p.format_options.alternate {\n+                    template.push('#');\n+                }\n+                if p.format_options.zero_pad {\n+                    template.push('0');\n+                }\n+                if let Some(width) = &p.format_options.width {\n+                    match width {\n+                        FormatCount::Literal(n) => write!(template, \"{n}\").unwrap(),\n+                        FormatCount::Argument(FormatArgPosition {\n+                            index: Ok(n) | Err(n), ..\n+                        }) => {\n+                            write!(template, \"{n}$\").unwrap();\n+                        }\n+                    }\n+                }\n+                if let Some(precision) = &p.format_options.precision {\n+                    template.push('.');\n+                    match precision {\n+                        FormatCount::Literal(n) => write!(template, \"{n}\").unwrap(),\n+                        FormatCount::Argument(FormatArgPosition {\n+                            index: Ok(n) | Err(n), ..\n+                        }) => {\n+                            write!(template, \"{n}$\").unwrap();\n+                        }\n+                    }\n+                }\n+                match p.format_options.debug_hex {\n+                    Some(FormatDebugHex::Lower) => template.push('x'),\n+                    Some(FormatDebugHex::Upper) => template.push('X'),\n+                    None => {}\n+                }\n+                template.push_str(match p.format_trait {\n+                    FormatTrait::Display => \"\",\n+                    FormatTrait::Debug => \"?\",\n+                    FormatTrait::LowerExp => \"e\",\n+                    FormatTrait::UpperExp => \"E\",\n+                    FormatTrait::Octal => \"o\",\n+                    FormatTrait::Pointer => \"p\",\n+                    FormatTrait::Binary => \"b\",\n+                    FormatTrait::LowerHex => \"x\",\n+                    FormatTrait::UpperHex => \"X\",\n+                });\n+                template.push('}');\n+            }\n+        }\n+    }\n+    template.push('\"');\n+    template\n+}"}, {"sha": "2bbb9618dbf09f27f74a09662e66c6fffd6dd031", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -37,7 +37,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n             desc,\n         );\n \n-        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_desc));\n+        err.span_label(borrow_span, format!(\"{} is borrowed here\", borrow_desc));\n         err.span_label(span, format!(\"use of borrowed {}\", borrow_desc));\n         err\n     }\n@@ -250,8 +250,8 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n             desc,\n         );\n \n-        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", desc));\n-        err.span_label(span, format!(\"assignment to borrowed {} occurs here\", desc));\n+        err.span_label(borrow_span, format!(\"{} is borrowed here\", desc));\n+        err.span_label(span, format!(\"{} is assigned to here but it was already borrowed\", desc));\n         err\n     }\n "}, {"sha": "2821677c5371f7857044cd535e24bd14bfd7ca59", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -393,6 +393,7 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             | mir::StatementKind::AscribeUserType(..)\n             | mir::StatementKind::Coverage(..)\n             | mir::StatementKind::Intrinsic(..)\n+            | mir::StatementKind::ConstEvalCounter\n             | mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "50c0faf4597f1a2cdb36f0a085b0e09e2533cc8a", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -766,7 +766,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let copy_did = infcx.tcx.require_lang_item(LangItem::Copy, Some(span));\n         let cause = ObligationCause::new(\n             span,\n-            self.mir_hir_id(),\n+            self.mir_def_id(),\n             rustc_infer::traits::ObligationCauseCode::MiscObligation,\n         );\n         let errors = rustc_trait_selection::traits::fully_solve_bound(\n@@ -1736,7 +1736,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n-                None,\n+                Some(borrow_span),\n                 None,\n             );\n         }\n@@ -2599,7 +2599,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 match ty.kind() {\n                     ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n                         self.mir_def_id(),\n-                        self.infcx.tcx.fn_sig(self.mir_def_id()),\n+                        self.infcx.tcx.fn_sig(self.mir_def_id()).subst_identity(),\n                     ),\n                     _ => None,\n                 }"}, {"sha": "19855075ced80d7383d01be49f5d4e5dc946aedd", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,6 +1,8 @@\n //! Print diagnostics to explain why values are borrowed.\n \n use rustc_errors::{Applicability, Diagnostic};\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::Visitor;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n@@ -11,6 +13,7 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n+use rustc_trait_selection::traits::error_reporting::FindExprBySpan;\n \n use crate::region_infer::{BlameConstraint, ExtraConstraintInfo};\n use crate::{\n@@ -63,6 +66,36 @@ impl<'tcx> BorrowExplanation<'tcx> {\n         borrow_span: Option<Span>,\n         multiple_borrow_span: Option<(Span, Span)>,\n     ) {\n+        if let Some(span) = borrow_span {\n+            let def_id = body.source.def_id();\n+            if let Some(node) = tcx.hir().get_if_local(def_id)\n+                && let Some(body_id) = node.body_id()\n+            {\n+                let body = tcx.hir().body(body_id);\n+                let mut expr_finder = FindExprBySpan::new(span);\n+                expr_finder.visit_expr(body.value);\n+                if let Some(mut expr) = expr_finder.result {\n+                    while let hir::ExprKind::AddrOf(_, _, inner)\n+                        | hir::ExprKind::Unary(hir::UnOp::Deref, inner)\n+                        | hir::ExprKind::Field(inner, _)\n+                        | hir::ExprKind::MethodCall(_, inner, _, _)\n+                        | hir::ExprKind::Index(inner, _) = &expr.kind\n+                    {\n+                        expr = inner;\n+                    }\n+                    if let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind\n+                        && let [hir::PathSegment { ident, args: None, .. }] = p.segments\n+                        && let hir::def::Res::Local(hir_id) = p.res\n+                        && let Some(hir::Node::Pat(pat)) = tcx.hir().find(hir_id)\n+                    {\n+                        err.span_label(\n+                            pat.span,\n+                            &format!(\"binding `{ident}` declared here\"),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n         match *self {\n             BorrowExplanation::UsedLater(later_use_kind, var_or_use_span, path_span) => {\n                 let message = match later_use_kind {"}, {"sha": "8c579bac7e8eb471c8dc8690eb7f7c3a7c62c5d1", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1064,7 +1064,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                 }\n-                CallKind::Normal { self_arg, desugaring, method_did } => {\n+                CallKind::Normal { self_arg, desugaring, method_did, method_substs } => {\n                     let self_arg = self_arg.unwrap();\n                     let tcx = self.infcx.tcx;\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n@@ -1128,15 +1128,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n                             ),\n                         );\n+\n                         let infcx = tcx.infer_ctxt().build();\n+                        // Erase and shadow everything that could be passed to the new infcx.\n                         let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n+                        let method_substs = tcx.erase_regions(method_substs);\n+\n                         if let ty::Adt(def, substs) = ty.kind()\n                             && Some(def.did()) == tcx.lang_items().pin_type()\n                             && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()\n                             && let self_ty = infcx.replace_bound_vars_with_fresh_vars(\n                                 fn_call_span,\n                                 LateBoundRegionConversionTime::FnCall,\n-                                tcx.fn_sig(method_did).input(0),\n+                                tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),\n                             )\n                             && infcx.can_eq(self.param_env, ty, self_ty).is_ok()\n                         {"}, {"sha": "ea58ad5ae3e34539a7ee5bf53f2ec95ffa7a8a3e", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n                 self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n \n-                use_spans.args_span_label(err, format!(\"move out of {place_desc} occurs here\"));\n+                use_spans.args_span_label(err, format!(\"{place_desc} is moved here\"));\n             }\n         }\n     }"}, {"sha": "87db08ef5b5108e3b6439883ce5d8bb869f90967", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -813,17 +813,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             if *outlived_f != ty::ReStatic {\n                 return;\n             }\n+            let suitable_region = self.infcx.tcx.is_suitable_region(f);\n+            let Some(suitable_region) = suitable_region else { return; };\n \n-            let fn_returns = self\n-                .infcx\n-                .tcx\n-                .is_suitable_region(f)\n-                .map(|r| self.infcx.tcx.return_type_impl_or_dyn_traits(r.def_id))\n-                .unwrap_or_default();\n-\n-            if fn_returns.is_empty() {\n-                return;\n-            }\n+            let fn_returns = self.infcx.tcx.return_type_impl_or_dyn_traits(suitable_region.def_id);\n \n             let param = if let Some(param) = find_param_with_region(self.infcx.tcx, f, outlived_f) {\n                 param\n@@ -839,15 +832,43 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             };\n             let captures = format!(\"captures data from {arg}\");\n \n-            return nice_region_error::suggest_new_region_bound(\n-                self.infcx.tcx,\n-                diag,\n-                fn_returns,\n-                lifetime.to_string(),\n-                Some(arg),\n-                captures,\n-                Some((param.param_ty_span, param.param_ty.to_string())),\n-                self.infcx.tcx.is_suitable_region(f).map(|r| r.def_id),\n+            if !fn_returns.is_empty() {\n+                nice_region_error::suggest_new_region_bound(\n+                    self.infcx.tcx,\n+                    diag,\n+                    fn_returns,\n+                    lifetime.to_string(),\n+                    Some(arg),\n+                    captures,\n+                    Some((param.param_ty_span, param.param_ty.to_string())),\n+                    Some(suitable_region.def_id),\n+                );\n+                return;\n+            }\n+\n+            let Some((alias_tys, alias_span)) = self\n+                .infcx\n+                .tcx\n+                .return_type_impl_or_dyn_traits_with_type_alias(suitable_region.def_id) else { return; };\n+\n+            // in case the return type of the method is a type alias\n+            let mut spans_suggs: Vec<_> = Vec::new();\n+            for alias_ty in alias_tys {\n+                if alias_ty.span.desugaring_kind().is_some() {\n+                    // Skip `async` desugaring `impl Future`.\n+                    ()\n+                }\n+                if let TyKind::TraitObject(_, lt, _) = alias_ty.kind {\n+                    spans_suggs.push((lt.ident.span.shrink_to_hi(), \" + 'a\".to_string()));\n+                }\n+            }\n+            spans_suggs.push((alias_span.shrink_to_hi(), \"<'a>\".to_string()));\n+            diag.multipart_suggestion_verbose(\n+                &format!(\n+                    \"to declare that the trait object {captures}, you can add a lifetime parameter `'a` in the type alias\"\n+                ),\n+                spans_suggs,\n+                Applicability::MaybeIncorrect,\n             );\n         }\n     }"}, {"sha": "6217676d5c150f5f977ff22735f65ca1d817a86f", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -91,7 +91,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n-            StatementKind::Nop\n+            StatementKind::ConstEvalCounter\n+            | StatementKind::Nop\n             | StatementKind::Retag { .. }\n             | StatementKind::Deinit(..)\n             | StatementKind::SetDiscriminant { .. } => {"}, {"sha": "bc81abe4005c919467114d502173cf017e0ab308", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -609,7 +609,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             StatementKind::AscribeUserType(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n-            // Does not actually affect borrowck\n+            // These do not actually affect borrowck\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::StorageLive(..) => {}\n             StatementKind::StorageDead(local) => {\n                 self.access_place("}, {"sha": "2ae13990a4589834128aea43c4b98bbe0f5d0ef3", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n@@ -2022,7 +2021,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|constraint| BlameConstraint {\n                 category: constraint.category,\n                 from_closure: constraint.from_closure,\n-                cause: ObligationCause::new(constraint.span, CRATE_HIR_ID, cause_code.clone()),\n+                cause: ObligationCause::new(constraint.span, CRATE_DEF_ID, cause_code.clone()),\n                 variance_info: constraint.variance_info,\n                 outlives_constraint: *constraint,\n             })"}, {"sha": "e0e814cfc0ac812e94655a920a909da4809555bb", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -273,7 +273,6 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // This logic duplicates most of `check_opaque_meets_bounds`.\n         // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n         let param_env = self.tcx.param_env(def_id);\n-        let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n         // HACK This bubble is required for this tests to pass:\n         // type-alias-impl-trait/issue-67844-nested-opaque.rs\n         let infcx =\n@@ -290,15 +289,15 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // the bounds that the function supplies.\n         let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n         if let Err(err) = ocx.eq(\n-            &ObligationCause::misc(instantiated_ty.span, body_id),\n+            &ObligationCause::misc(instantiated_ty.span, def_id),\n             param_env,\n             opaque_ty,\n             definition_ty,\n         ) {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types(\n-                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                    &ObligationCause::misc(instantiated_ty.span, def_id),\n                     opaque_ty,\n                     definition_ty,\n                     err,\n@@ -309,7 +308,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         ocx.register_obligation(Obligation::misc(\n             infcx.tcx,\n             instantiated_ty.span,\n-            body_id,\n+            def_id,\n             param_env,\n             predicate,\n         ));\n@@ -368,18 +367,6 @@ fn check_opaque_type_parameter_valid(\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n         let arg_is_param = match arg.unpack() {\n             GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-            GenericArgKind::Lifetime(lt) if lt.is_static() => {\n-                tcx.sess\n-                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n-                        \"cannot use static lifetime; use a bound lifetime \\\n-                                    instead or remove the lifetime parameter from the \\\n-                                    opaque type\",\n-                    )\n-                    .emit();\n-                return false;\n-            }\n             GenericArgKind::Lifetime(lt) => {\n                 matches!(*lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n             }"}, {"sha": "06087b0c579d8c293349d82e0e847fb5a2b50da5", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1258,6 +1258,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | StatementKind::StorageDead(..)\n             | StatementKind::Retag { .. }\n             | StatementKind::Coverage(..)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {}\n             StatementKind::Deinit(..) | StatementKind::SetDiscriminant { .. } => {\n                 bug!(\"Statement not allowed in this MIR phase\")"}, {"sha": "5380913f5c86ae5a4ab4fc06ee422b6ea553cbee", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -472,7 +472,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         // C-variadic fns also have a `VaList` input that's not listed in the signature\n         // (as it's created inside the body itself, not passed in from outside).\n         if let DefiningTy::FnDef(def_id, _) = defining_ty {\n-            if self.infcx.tcx.fn_sig(def_id).c_variadic() {\n+            if self.infcx.tcx.fn_sig(def_id).skip_binder().c_variadic() {\n                 let va_list_did = self.infcx.tcx.require_lang_item(\n                     LangItem::VaList,\n                     Some(self.infcx.tcx.def_span(self.mir_def.did)),\n@@ -665,7 +665,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::FnDef(def_id, _) => {\n-                let sig = tcx.fn_sig(def_id);\n+                let sig = tcx.fn_sig(def_id).subst_identity();\n                 let sig = indices.fold_to_region_vids(tcx, sig);\n                 sig.inputs_and_output()\n             }"}, {"sha": "342b1735661df9acd779fdf54fc6f7fc6154174c", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -297,6 +297,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Continue(_)\n             | ExprKind::Err\n             | ExprKind::Field(_, _)\n+            | ExprKind::FormatArgs(_)\n             | ExprKind::ForLoop(_, _, _, _)\n             | ExprKind::If(_, _, _)\n             | ExprKind::IncludedBytes(..)"}, {"sha": "0481a118906902697eb25900fda82ca07c5c5d6d", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -17,6 +17,7 @@ pub fn expand_deriving_copy(\n         span,\n         path: path_std!(marker::Copy),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: false,\n         additional_bounds: Vec::new(),\n         supports_unions: true,\n         methods: Vec::new(),"}, {"sha": "42f50d8ade2785c2535374a6bb2ccc69bfef2a41", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -73,6 +73,7 @@ pub fn expand_deriving_clone(\n         span,\n         path: path_std!(clone::Clone),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: bounds,\n         supports_unions: true,\n         methods: vec![MethodDef {"}, {"sha": "424719f97954f743b2115600469d96ee80ef7fa5", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -27,6 +27,7 @@ pub fn expand_deriving_eq(\n         span,\n         path: path_std!(cmp::Eq),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: true,\n         methods: vec![MethodDef {"}, {"sha": "671f32550d2bbee957dd2775fa0976c1a8cefee7", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -20,6 +20,7 @@ pub fn expand_deriving_ord(\n         span,\n         path: path_std!(cmp::Ord),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "88d454fbc11230f5ad04f55269112bd8789dc1d9", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -84,6 +84,7 @@ pub fn expand_deriving_partial_eq(\n         span,\n         path: path_std!(cmp::PartialEq),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods,"}, {"sha": "bcc90442eb72bb91aef8f06a7cd2830155d881ff", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-use rustc_ast::MetaItem;\n+use rustc_ast::{ExprKind, ItemKind, MetaItem, PatKind};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -21,6 +21,27 @@ pub fn expand_deriving_partial_ord(\n \n     let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n \n+    // Order in which to perform matching\n+    let tag_then_data = if let Annotatable::Item(item) = item\n+        && let ItemKind::Enum(def, _) = &item.kind {\n+            let dataful: Vec<bool> = def.variants.iter().map(|v| !v.data.fields().is_empty()).collect();\n+            match dataful.iter().filter(|&&b| b).count() {\n+                // No data, placing the tag check first makes codegen simpler\n+                0 => true,\n+                1..=2 => false,\n+                _ => {\n+                    (0..dataful.len()-1).any(|i| {\n+                        if dataful[i] && let Some(idx) = dataful[i+1..].iter().position(|v| *v) {\n+                            idx >= 2\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                }\n+            }\n+        } else {\n+            true\n+        };\n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n@@ -30,14 +51,15 @@ pub fn expand_deriving_partial_ord(\n         attributes: attrs,\n         fieldless_variants_strategy: FieldlessVariantsStrategy::Unify,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-            cs_partial_cmp(cx, span, substr)\n+            cs_partial_cmp(cx, span, substr, tag_then_data)\n         })),\n     };\n \n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::PartialOrd),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: vec![],\n         supports_unions: false,\n         methods: vec![partial_cmp_def],\n@@ -47,7 +69,12 @@ pub fn expand_deriving_partial_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+fn cs_partial_cmp(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    substr: &Substructure<'_>,\n+    tag_then_data: bool,\n+) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n@@ -74,12 +101,50 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 let args = vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n-            CsFold::Combine(span, expr1, expr2) => {\n-                let eq_arm =\n-                    cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n-                let neq_arm =\n-                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            CsFold::Combine(span, mut expr1, expr2) => {\n+                // When the item is an enum, this expands to\n+                // ```\n+                // match (expr2) {\n+                //     Some(Ordering::Equal) => expr1,\n+                //     cmp => cmp\n+                // }\n+                // ```\n+                // where `expr2` is `partial_cmp(self_tag, other_tag)`, and `expr1` is a `match`\n+                //  against the enum variants. This means that we begin by comparing the enum tags,\n+                // before either inspecting their contents (if they match), or returning\n+                // the `cmp::Ordering` of comparing the enum tags.\n+                // ```\n+                // match partial_cmp(self_tag, other_tag) {\n+                //     Some(Ordering::Equal) => match (self, other)  {\n+                //         (Self::A(self_0), Self::A(other_0)) => partial_cmp(self_0, other_0),\n+                //         (Self::B(self_0), Self::B(other_0)) => partial_cmp(self_0, other_0),\n+                //         _ => Some(Ordering::Equal)\n+                //     }\n+                //     cmp => cmp\n+                // }\n+                // ```\n+                // If we have any certain enum layouts, flipping this results in better codegen\n+                // ```\n+                // match (self, other) {\n+                //     (Self::A(self_0), Self::A(other_0)) => partial_cmp(self_0, other_0),\n+                //     _ => partial_cmp(self_tag, other_tag)\n+                // }\n+                // ```\n+                // Reference: https://github.com/rust-lang/rust/pull/103659#issuecomment-1328126354\n+\n+                if !tag_then_data\n+                    && let ExprKind::Match(_, arms) = &mut expr1.kind\n+                    && let Some(last) = arms.last_mut()\n+                    && let PatKind::Wild = last.pat.kind {\n+                        last.body = expr2;\n+                        expr1\n+                } else {\n+                    let eq_arm =\n+                        cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n+                    let neq_arm =\n+                        cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                    cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                }\n             }\n             CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n         },"}, {"sha": "897048f64211e37d509d31457f1d71cf4d7edf3f", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -23,6 +23,7 @@ pub fn expand_deriving_debug(\n         span,\n         path: path_std!(fmt::Debug),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "c783e46eda9416ba23bb00a77d536e61d97891af", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -25,6 +25,7 @@ pub fn expand_deriving_rustc_decodable(\n         span,\n         path: Path::new_(vec![krate, sym::Decodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "a6c8b111527a3e241f26e55dfef9fa92ddf533e3", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -25,6 +25,7 @@ pub fn expand_deriving_default(\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),\n         skip_path_as_bound: has_a_default_variant(item),\n+        needs_copy_as_bound_if_packed: false,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "a5e2b599df4e8f0fae48ee2848f6c4bb2a772407", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -109,6 +109,7 @@ pub fn expand_deriving_rustc_encodable(\n         span,\n         path: Path::new_(vec![krate, sym::Encodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "97de40bac34661f12d86e27e12a139ae76ebdd36", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 87, "deletions": 48, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -165,11 +165,12 @@ pub use SubstructureFields::*;\n use crate::deriving;\n use rustc_ast::ptr::P;\n use rustc_ast::{\n-    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, Generics, Mutability, PatKind,\n+    self as ast, BindingAnnotation, ByRef, EnumDef, Expr, GenericArg, GenericParamKind, Generics,\n+    Mutability, PatKind, TyKind, VariantData,\n };\n-use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_session::lint::builtin::BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::RefCell;\n@@ -191,6 +192,9 @@ pub struct TraitDef<'a> {\n     /// Whether to skip adding the current trait as a bound to the type parameters of the type.\n     pub skip_path_as_bound: bool,\n \n+    /// Whether `Copy` is needed as an additional bound on type parameters in a packed struct.\n+    pub needs_copy_as_bound_if_packed: bool,\n+\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n     pub additional_bounds: Vec<Ty>,\n@@ -455,18 +459,6 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match &item.kind {\n-                    ast::ItemKind::Struct(_, generics)\n-                    | ast::ItemKind::Enum(_, generics)\n-                    | ast::ItemKind::Union(_, generics) => !generics\n-                        .params\n-                        .iter()\n-                        .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n-                    _ => unreachable!(),\n-                };\n-                let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n-                let copy_fields =\n-                    is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n                 let newitem = match &item.kind {\n                     ast::ItemKind::Struct(struct_def, generics) => self.expand_struct_def(\n@@ -475,7 +467,7 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        copy_fields,\n+                        is_packed,\n                     ),\n                     ast::ItemKind::Enum(enum_def, generics) => {\n                         // We ignore `is_packed` here, because `repr(packed)`\n@@ -493,7 +485,7 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                copy_fields,\n+                                is_packed,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -565,6 +557,7 @@ impl<'a> TraitDef<'a> {\n         generics: &Generics,\n         field_tys: Vec<P<ast::Ty>>,\n         methods: Vec<P<ast::AssocItem>>,\n+        is_packed: bool,\n     ) -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n@@ -607,20 +600,32 @@ impl<'a> TraitDef<'a> {\n             .map(|param| match &param.kind {\n                 GenericParamKind::Lifetime { .. } => param.clone(),\n                 GenericParamKind::Type { .. } => {\n-                    // I don't think this can be moved out of the loop, since\n-                    // a GenericBound requires an ast id\n-                    let bounds: Vec<_> =\n-                    // extra restrictions on the generics parameters to the\n-                    // type being derived upon\n-                    self.additional_bounds.iter().map(|p| {\n-                        cx.trait_bound(p.to_path(cx, self.span, type_ident, generics))\n-                    }).chain(\n-                        // require the current trait\n-                        self.skip_path_as_bound.not().then(|| cx.trait_bound(trait_path.clone()))\n-                    ).chain(\n-                        // also add in any bounds from the declaration\n-                        param.bounds.iter().cloned()\n-                    ).collect();\n+                    // Extra restrictions on the generics parameters to the\n+                    // type being derived upon.\n+                    let bounds: Vec<_> = self\n+                        .additional_bounds\n+                        .iter()\n+                        .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                        .chain(\n+                            // Add a bound for the current trait.\n+                            self.skip_path_as_bound\n+                                .not()\n+                                .then(|| cx.trait_bound(trait_path.clone())),\n+                        )\n+                        .chain({\n+                            // Add a `Copy` bound if required.\n+                            if is_packed && self.needs_copy_as_bound_if_packed {\n+                                let p = deriving::path_std!(marker::Copy);\n+                                Some(cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                        .chain(\n+                            // Also add in any bounds from the declaration.\n+                            param.bounds.iter().cloned(),\n+                        )\n+                        .collect();\n \n                     cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, bounds, None)\n                 }\n@@ -692,9 +697,17 @@ impl<'a> TraitDef<'a> {\n                             .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n                             .collect();\n \n-                        // require the current trait\n+                        // Require the current trait.\n                         bounds.push(cx.trait_bound(trait_path.clone()));\n \n+                        // Add a `Copy` bound if required.\n+                        if is_packed && self.needs_copy_as_bound_if_packed {\n+                            let p = deriving::path_std!(marker::Copy);\n+                            bounds.push(\n+                                cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)),\n+                            );\n+                        }\n+\n                         let predicate = ast::WhereBoundPredicate {\n                             span: self.span,\n                             bound_generic_params: field_ty_param.bound_generic_params,\n@@ -762,7 +775,7 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        copy_fields: bool,\n+        is_packed: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -790,7 +803,7 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        copy_fields,\n+                        is_packed,\n                     )\n                 };\n \n@@ -806,7 +819,7 @@ impl<'a> TraitDef<'a> {\n             })\n             .collect();\n \n-        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods, is_packed)\n     }\n \n     fn expand_enum_def(\n@@ -861,7 +874,8 @@ impl<'a> TraitDef<'a> {\n             })\n             .collect();\n \n-        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n+        let is_packed = false; // enums are never packed\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods, is_packed)\n     }\n }\n \n@@ -1011,8 +1025,8 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// But if the struct is `repr(packed)`, we can't use something like\n     /// `&self.x` because that might cause an unaligned ref. So for any trait\n-    /// method that takes a reference, if the struct impls `Copy` then we use a\n-    /// local block to force a copy:\n+    /// method that takes a reference, we use a local block to force a copy.\n+    /// This requires that the field impl `Copy`.\n     /// ```\n     /// # struct A { x: u8, y: u8 }\n     /// impl PartialEq for A {\n@@ -1027,10 +1041,6 @@ impl<'a> MethodDef<'a> {\n     ///         ::core::hash::Hash::hash(&{ self.y }, state)\n     ///     }\n     /// }\n-    /// ```\n-    /// If the struct doesn't impl `Copy`, we use the normal `&self.x`. This\n-    /// only works if the fields match the alignment required by the\n-    /// `packed(N)` attribute. (We'll get errors later on if not.)\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,\n@@ -1039,12 +1049,12 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        copy_fields: bool,\n+        is_packed: bool,\n     ) -> BlockOrExpr {\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n \n         let selflike_fields =\n-            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, copy_fields);\n+            trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, is_packed);\n         self.call_substructure_method(\n             cx,\n             trait_,\n@@ -1514,7 +1524,7 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         selflike_args: &[P<Expr>],\n         struct_def: &'a VariantData,\n-        copy_fields: bool,\n+        is_packed: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n@@ -1533,10 +1543,39 @@ impl<'a> TraitDef<'a> {\n                             }),\n                         ),\n                     );\n-                    if copy_fields {\n-                        field_expr = cx.expr_block(\n-                            cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n-                        );\n+                    // In general, fields in packed structs are copied via a\n+                    // block, e.g. `&{self.0}`. The one exception is `[u8]`\n+                    // fields, which cannot be copied and also never cause\n+                    // unaligned references. This exception is allowed to\n+                    // handle the `FlexZeroSlice` type in the `zerovec` crate\n+                    // within `icu4x-0.9.0`.\n+                    //\n+                    // Once use of `icu4x-0.9.0` has dropped sufficiently, this\n+                    // exception should be removed.\n+                    let is_u8_slice = if let TyKind::Slice(ty) = &struct_field.ty.kind &&\n+                        let TyKind::Path(None, rustc_ast::Path { segments, .. }) = &ty.kind &&\n+                        let [seg] = segments.as_slice() &&\n+                        seg.ident.name == sym::u8 && seg.args.is_none()\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    };\n+                    if is_packed {\n+                        if is_u8_slice {\n+                            cx.sess.parse_sess.buffer_lint_with_diagnostic(\n+                                BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n+                                sp,\n+                                ast::CRATE_NODE_ID,\n+                                \"byte slice in a packed struct that derives a built-in trait\",\n+                                rustc_lint_defs::BuiltinLintDiagnostics::ByteSliceInPackedStructWithDerive\n+                            );\n+                        } else {\n+                            // Wrap the expression in `{...}`, causing a copy.\n+                            field_expr = cx.expr_block(\n+                                cx.block(struct_field.span, vec![cx.stmt_expr(field_expr)]),\n+                            );\n+                        }\n                     }\n                     cx.expr_addr_of(sp, field_expr)\n                 })"}, {"sha": "5c2e89c5697b2776478d0dd5c707d15d957bfa0c", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -24,6 +24,7 @@ pub fn expand_deriving_hash(\n         span,\n         path,\n         skip_path_as_bound: false,\n+        needs_copy_as_bound_if_packed: true,\n         additional_bounds: Vec::new(),\n         supports_unions: false,\n         methods: vec![MethodDef {"}, {"sha": "e93a23394c03ff9b9f74ea87e72c6d1ef27ee539", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,7 +1,11 @@\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::Expr;\n+use rustc_ast::{\n+    Expr, ExprKind, FormatAlignment, FormatArgPosition, FormatArgPositionKind, FormatArgs,\n+    FormatArgsPiece, FormatArgument, FormatArgumentKind, FormatArguments, FormatCount,\n+    FormatDebugHex, FormatOptions, FormatPlaceholder, FormatSign, FormatTrait,\n+};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n@@ -12,21 +16,15 @@ use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n \n-mod ast;\n-use ast::*;\n-\n-mod expand;\n-use expand::expand_parsed_format_args;\n-\n // The format_args!() macro is expanded in three steps:\n //  1. First, `parse_args` will parse the `(literal, arg, arg, name=arg, name=arg)` syntax,\n //     but doesn't parse the template (the literal) itself.\n //  2. Second, `make_format_args` will parse the template, the format options, resolve argument references,\n-//     produce diagnostics, and turn the whole thing into a `FormatArgs` structure.\n-//  3. Finally, `expand_parsed_format_args` will turn that `FormatArgs` structure\n-//     into the expression that the macro expands to.\n+//     produce diagnostics, and turn the whole thing into a `FormatArgs` AST node.\n+//  3. Much later, in AST lowering (rustc_ast_lowering), that `FormatArgs` structure will be turned\n+//     into the expression of type `core::fmt::Arguments`.\n \n-// See format/ast.rs for the FormatArgs structure and glossary.\n+// See rustc_ast/src/format.rs for the FormatArgs structure and glossary.\n \n // Only used in parse_args and report_invalid_references,\n // to indicate how a referred argument was used.\n@@ -437,7 +435,16 @@ pub fn make_format_args(\n                     format_options: FormatOptions {\n                         fill: format.fill,\n                         alignment,\n-                        flags: format.flags,\n+                        sign: format.sign.map(|s| match s {\n+                            parse::Sign::Plus => FormatSign::Plus,\n+                            parse::Sign::Minus => FormatSign::Minus,\n+                        }),\n+                        alternate: format.alternate,\n+                        zero_pad: format.zero_pad,\n+                        debug_hex: format.debug_hex.map(|s| match s {\n+                            parse::DebugHex::Lower => FormatDebugHex::Lower,\n+                            parse::DebugHex::Upper => FormatDebugHex::Upper,\n+                        }),\n                         precision,\n                         width,\n                     },\n@@ -850,7 +857,7 @@ fn expand_format_args_impl<'cx>(\n     match parse_args(ecx, sp, tts) {\n         Ok((efmt, args)) => {\n             if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n-                MacEager::expr(expand_parsed_format_args(ecx, format_args))\n+                MacEager::expr(ecx.expr(sp, ExprKind::FormatArgs(P(format_args))))\n             } else {\n                 MacEager::expr(DummyResult::raw_expr(sp, true))\n             }"}, {"sha": "9dde5efcb28b7611c514e8517fc0d769fcb4d126", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "removed", "additions": 0, "deletions": 353, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22", "patch": "@@ -1,353 +0,0 @@\n-use super::*;\n-use rustc_ast as ast;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{BlockCheckMode, UnsafeSource};\n-use rustc_data_structures::fx::FxIndexSet;\n-use rustc_span::{sym, symbol::kw};\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-enum ArgumentType {\n-    Format(FormatTrait),\n-    Usize,\n-}\n-\n-fn make_argument(ecx: &ExtCtxt<'_>, sp: Span, arg: P<ast::Expr>, ty: ArgumentType) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::ArgumentV1::new_\u2026(arg)\n-    use ArgumentType::*;\n-    use FormatTrait::*;\n-    ecx.expr_call_global(\n-        sp,\n-        ecx.std_path(&[\n-            sym::fmt,\n-            sym::ArgumentV1,\n-            match ty {\n-                Format(Display) => sym::new_display,\n-                Format(Debug) => sym::new_debug,\n-                Format(LowerExp) => sym::new_lower_exp,\n-                Format(UpperExp) => sym::new_upper_exp,\n-                Format(Octal) => sym::new_octal,\n-                Format(Pointer) => sym::new_pointer,\n-                Format(Binary) => sym::new_binary,\n-                Format(LowerHex) => sym::new_lower_hex,\n-                Format(UpperHex) => sym::new_upper_hex,\n-                Usize => sym::from_usize,\n-            },\n-        ]),\n-        vec![arg],\n-    )\n-}\n-\n-fn make_count(\n-    ecx: &ExtCtxt<'_>,\n-    sp: Span,\n-    count: &Option<FormatCount>,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n-) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::rt::v1::Count::\u2026(\u2026)\n-    match count {\n-        Some(FormatCount::Literal(n)) => ecx.expr_call_global(\n-            sp,\n-            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Is]),\n-            vec![ecx.expr_usize(sp, *n)],\n-        ),\n-        Some(FormatCount::Argument(arg)) => {\n-            if let Ok(arg_index) = arg.index {\n-                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n-                ecx.expr_call_global(\n-                    sp,\n-                    ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Param]),\n-                    vec![ecx.expr_usize(sp, i)],\n-                )\n-            } else {\n-                DummyResult::raw_expr(sp, true)\n-            }\n-        }\n-        None => ecx.expr_path(ecx.path_global(\n-            sp,\n-            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Implied]),\n-        )),\n-    }\n-}\n-\n-fn make_format_spec(\n-    ecx: &ExtCtxt<'_>,\n-    sp: Span,\n-    placeholder: &FormatPlaceholder,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n-) -> P<ast::Expr> {\n-    // Generate:\n-    //     ::core::fmt::rt::v1::Argument {\n-    //         position: 0usize,\n-    //         format: ::core::fmt::rt::v1::FormatSpec {\n-    //             fill: ' ',\n-    //             align: ::core::fmt::rt::v1::Alignment::Unknown,\n-    //             flags: 0u32,\n-    //             precision: ::core::fmt::rt::v1::Count::Implied,\n-    //             width: ::core::fmt::rt::v1::Count::Implied,\n-    //         },\n-    //     }\n-    let position = match placeholder.argument.index {\n-        Ok(arg_index) => {\n-            let (i, _) =\n-                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n-            ecx.expr_usize(sp, i)\n-        }\n-        Err(_) => DummyResult::raw_expr(sp, true),\n-    };\n-    let fill = ecx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n-    let align = ecx.expr_path(ecx.path_global(\n-        sp,\n-        ecx.std_path(&[\n-            sym::fmt,\n-            sym::rt,\n-            sym::v1,\n-            sym::Alignment,\n-            match placeholder.format_options.alignment {\n-                Some(FormatAlignment::Left) => sym::Left,\n-                Some(FormatAlignment::Right) => sym::Right,\n-                Some(FormatAlignment::Center) => sym::Center,\n-                None => sym::Unknown,\n-            },\n-        ]),\n-    ));\n-    let flags = ecx.expr_u32(sp, placeholder.format_options.flags);\n-    let prec = make_count(ecx, sp, &placeholder.format_options.precision, argmap);\n-    let width = make_count(ecx, sp, &placeholder.format_options.width, argmap);\n-    ecx.expr_struct(\n-        sp,\n-        ecx.path_global(sp, ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Argument])),\n-        vec![\n-            ecx.field_imm(sp, Ident::new(sym::position, sp), position),\n-            ecx.field_imm(\n-                sp,\n-                Ident::new(sym::format, sp),\n-                ecx.expr_struct(\n-                    sp,\n-                    ecx.path_global(\n-                        sp,\n-                        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::FormatSpec]),\n-                    ),\n-                    vec![\n-                        ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n-                        ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n-                        ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n-                        ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n-                        ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n-                    ],\n-                ),\n-            ),\n-        ],\n-    )\n-}\n-\n-pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<ast::Expr> {\n-    let macsp = ecx.with_def_site_ctxt(ecx.call_site());\n-\n-    let lit_pieces = ecx.expr_array_ref(\n-        fmt.span,\n-        fmt.template\n-            .iter()\n-            .enumerate()\n-            .filter_map(|(i, piece)| match piece {\n-                &FormatArgsPiece::Literal(s) => Some(ecx.expr_str(fmt.span, s)),\n-                &FormatArgsPiece::Placeholder(_) => {\n-                    // Inject empty string before placeholders when not already preceded by a literal piece.\n-                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n-                        Some(ecx.expr_str(fmt.span, kw::Empty))\n-                    } else {\n-                        None\n-                    }\n-                }\n-            })\n-            .collect(),\n-    );\n-\n-    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n-    // or the `Arguments::new_v1` form (false).\n-    let mut use_format_options = false;\n-\n-    // Create a list of all _unique_ (argument, format trait) combinations.\n-    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-    let mut argmap = FxIndexSet::default();\n-    for piece in &fmt.template {\n-        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n-        if placeholder.format_options != Default::default() {\n-            // Can't use basic form if there's any formatting options.\n-            use_format_options = true;\n-        }\n-        if let Ok(index) = placeholder.argument.index {\n-            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n-                // Duplicate (argument, format trait) combination,\n-                // which we'll only put once in the args array.\n-                use_format_options = true;\n-            }\n-        }\n-    }\n-\n-    let format_options = use_format_options.then(|| {\n-        // Generate:\n-        //     &[format_spec_0, format_spec_1, format_spec_2]\n-        ecx.expr_array_ref(\n-            macsp,\n-            fmt.template\n-                .iter()\n-                .filter_map(|piece| {\n-                    let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n-                    Some(make_format_spec(ecx, macsp, placeholder, &mut argmap))\n-                })\n-                .collect(),\n-        )\n-    });\n-\n-    let arguments = fmt.arguments.into_vec();\n-\n-    // If the args array contains exactly all the original arguments once,\n-    // in order, we can use a simple array instead of a `match` construction.\n-    // However, if there's a yield point in any argument except the first one,\n-    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n-    let use_simple_array = argmap.len() == arguments.len()\n-        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n-        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n-\n-    let args = if use_simple_array {\n-        // Generate:\n-        //     &[\n-        //         ::core::fmt::ArgumentV1::new_display(&arg0),\n-        //         ::core::fmt::ArgumentV1::new_lower_hex(&arg1),\n-        //         ::core::fmt::ArgumentV1::new_debug(&arg2),\n-        //     ]\n-        ecx.expr_array_ref(\n-            macsp,\n-            arguments\n-                .into_iter()\n-                .zip(argmap)\n-                .map(|(arg, (_, ty))| {\n-                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg.expr), ty)\n-                })\n-                .collect(),\n-        )\n-    } else {\n-        // Generate:\n-        //     match (&arg0, &arg1, &arg2) {\n-        //         args => &[\n-        //             ::core::fmt::ArgumentV1::new_display(args.0),\n-        //             ::core::fmt::ArgumentV1::new_lower_hex(args.1),\n-        //             ::core::fmt::ArgumentV1::new_debug(args.0),\n-        //         ]\n-        //     }\n-        let args_ident = Ident::new(sym::args, macsp);\n-        let args = argmap\n-            .iter()\n-            .map(|&(arg_index, ty)| {\n-                if let Some(arg) = arguments.get(arg_index) {\n-                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                    make_argument(\n-                        ecx,\n-                        sp,\n-                        ecx.expr_field(\n-                            sp,\n-                            ecx.expr_ident(macsp, args_ident),\n-                            Ident::new(sym::integer(arg_index), macsp),\n-                        ),\n-                        ty,\n-                    )\n-                } else {\n-                    DummyResult::raw_expr(macsp, true)\n-                }\n-            })\n-            .collect();\n-        ecx.expr_addr_of(\n-            macsp,\n-            ecx.expr_match(\n-                macsp,\n-                ecx.expr_tuple(\n-                    macsp,\n-                    arguments\n-                        .into_iter()\n-                        .map(|arg| {\n-                            ecx.expr_addr_of(arg.expr.span.with_ctxt(macsp.ctxt()), arg.expr)\n-                        })\n-                        .collect(),\n-                ),\n-                vec![ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))],\n-            ),\n-        )\n-    };\n-\n-    if let Some(format_options) = format_options {\n-        // Generate:\n-        //     ::core::fmt::Arguments::new_v1_formatted(\n-        //         lit_pieces,\n-        //         args,\n-        //         format_options,\n-        //         unsafe { ::core::fmt::UnsafeArg::new() }\n-        //     )\n-        ecx.expr_call_global(\n-            macsp,\n-            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1_formatted]),\n-            vec![\n-                lit_pieces,\n-                args,\n-                format_options,\n-                ecx.expr_block(P(ast::Block {\n-                    stmts: vec![ecx.stmt_expr(ecx.expr_call_global(\n-                        macsp,\n-                        ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]),\n-                        Vec::new(),\n-                    ))],\n-                    id: ast::DUMMY_NODE_ID,\n-                    rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n-                    span: macsp,\n-                    tokens: None,\n-                    could_be_bare_literal: false,\n-                })),\n-            ],\n-        )\n-    } else {\n-        // Generate:\n-        //     ::core::fmt::Arguments::new_v1(\n-        //         lit_pieces,\n-        //         args,\n-        //     )\n-        ecx.expr_call_global(\n-            macsp,\n-            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1]),\n-            vec![lit_pieces, args],\n-        )\n-    }\n-}\n-\n-fn may_contain_yield_point(e: &ast::Expr) -> bool {\n-    struct MayContainYieldPoint(bool);\n-\n-    impl Visitor<'_> for MayContainYieldPoint {\n-        fn visit_expr(&mut self, e: &ast::Expr) {\n-            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n-                self.0 = true;\n-            } else {\n-                visit::walk_expr(self, e);\n-            }\n-        }\n-\n-        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n-            self.0 = true;\n-        }\n-\n-        fn visit_attribute(&mut self, _: &ast::Attribute) {\n-            // Conservatively assume this may be a proc macro attribute in\n-            // expression position.\n-            self.0 = true;\n-        }\n-\n-        fn visit_item(&mut self, _: &ast::Item) {\n-            // Do not recurse into nested items.\n-        }\n-    }\n-\n-    let mut visitor = MayContainYieldPoint(false);\n-    visitor.visit_expr(e);\n-    visitor.0\n-}"}, {"sha": "7886cae42a15ab1902d7d79ce677e8c4dd0be075", "filename": "compiler/rustc_codegen_cranelift/.cirrus.yml", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.cirrus.yml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,23 +1,16 @@\n task:\n   name: freebsd\n   freebsd_instance:\n-    image: freebsd-12-1-release-amd64\n+    image: freebsd-13-1-release-amd64\n   setup_rust_script:\n     - pkg install -y curl git bash\n     - curl https://sh.rustup.rs -sSf --output rustup.sh\n     - sh rustup.sh --default-toolchain none -y --profile=minimal\n-  cargo_bin_cache:\n-    folder: ~/.cargo/bin\n   target_cache:\n     folder: target\n   prepare_script:\n     - . $HOME/.cargo/env\n     - ./y.rs prepare\n   test_script:\n     - . $HOME/.cargo/env\n-    - # Enable backtraces for easier debugging\n-    - export RUST_BACKTRACE=1\n-    - # Reduce amount of benchmark runs as they are slow\n-    - export COMPILE_RUNS=2\n-    - export RUN_RUNS=2\n     - ./y.rs test"}, {"sha": "c0daf69e98e912560c68b378f5c36bac6cf3004d", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 50, "deletions": 90, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -25,6 +25,10 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n+    defaults:\n+      run:\n+        shell: bash\n+\n     strategy:\n       fail-fast: false\n       matrix:\n@@ -46,36 +50,31 @@ jobs:\n           - os: ubuntu-latest\n             env:\n               TARGET_TRIPLE: s390x-unknown-linux-gnu\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n         path: build/cg_clif\n-        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.os == 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n \n     - name: Install MinGW toolchain and wine\n       if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       run: |\n         sudo apt-get update\n         sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n-        rustup target add x86_64-pc-windows-gnu\n \n     - name: Install AArch64 toolchain and qemu\n       if: matrix.os == 'ubuntu-latest' && matrix.env.TARGET_TRIPLE == 'aarch64-unknown-linux-gnu'\n@@ -89,6 +88,13 @@ jobs:\n         sudo apt-get update\n         sudo apt-get install -y gcc-s390x-linux-gnu qemu-user\n \n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n \n@@ -104,70 +110,54 @@ jobs:\n     - name: Test\n       env:\n         TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n-\n-        # Enable extra checks\n-        export CG_CLIF_ENABLE_VERIFIER=1\n-\n-        ./y.rs test\n+      run: ./y.rs test\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz dist\n \n     - name: Upload prebuilt cg_clif\n-      if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n-      uses: actions/upload-artifact@v2\n+      if: matrix.os == 'windows-latest' || matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n+      uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar.xz\n \n     - name: Upload prebuilt cg_clif (cross compile)\n-      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      if: matrix.os != 'windows-latest' && matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n \n-  windows:\n+\n+  abi_cafe:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n+    defaults:\n+      run:\n+        shell: bash\n+\n     strategy:\n-      fail-fast: false\n+      fail-fast: true\n       matrix:\n         include:\n-          # Native Windows build with MSVC\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n+          - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n           - os: windows-latest\n             env:\n               TARGET_TRIPLE: x86_64-pc-windows-msvc\n-          # cross-compile from Windows to Windows MinGW\n           - os: windows-latest\n             env:\n               TARGET_TRIPLE: x86_64-pc-windows-gnu\n \n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n@@ -178,50 +168,20 @@ jobs:\n       if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       run: rustup set default-host x86_64-pc-windows-gnu\n \n-    - name: Prepare dependencies\n+    - name: Use sparse cargo registry\n       run: |\n-        git config --global core.autocrlf false\n-        rustc y.rs -o y.exe -g\n-        ./y.exe prepare\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n \n-    - name: Build without unstable features\n-      env:\n-        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      # This is the config rust-lang/rust uses for builds\n-      run: ./y.rs build --no-unstable-features\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n     - name: Build\n       run: ./y.rs build --sysroot none\n \n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        $Env:RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        $Env:COMPILE_RUNS=2\n-        $Env:RUN_RUNS=2\n-\n-        # Enable extra checks\n-        $Env:CG_CLIF_ENABLE_VERIFIER=1\n-\n-        # WIP Disable some tests\n-\n-        # This fails due to some weird argument handling by hyperfine, not an actual regression\n-        # more of a build system issue\n-        (Get-Content config.txt) -replace '(bench.simple-raytracer)', '# $1' |  Out-File config.txt\n-\n-        # This fails with a different output than expected\n-        (Get-Content config.txt) -replace '(test.regex-shootout-regex-dna)', '# $1' |  Out-File config.txt\n-\n-        ./y.exe test\n-\n-    - name: Package prebuilt cg_clif\n-      # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n-      run: tar cvf cg_clif.tar dist\n-\n-    - name: Upload prebuilt cg_clif\n-      uses: actions/upload-artifact@v3\n-      with:\n-        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n-        path: cg_clif.tar\n+    - name: Test abi-cafe\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      run: ./y.rs abi-cafe"}, {"sha": "d0d58d2a7eacbd19a07442af167bdb0e2926274a", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/nightly-cranelift.yml", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fnightly-cranelift.yml?ref=e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22", "patch": "@@ -1,59 +0,0 @@\n-name: Test nightly Cranelift\n-\n-on:\n-  push:\n-  schedule:\n-    - cron: '17 1 * * *' # At 01:17 UTC every day.\n-\n-jobs:\n-  build:\n-    runs-on: ubuntu-latest\n-    timeout-minutes: 60\n-\n-    steps:\n-    - uses: actions/checkout@v3\n-\n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ubuntu-latest-cargo-installed-crates\n-\n-    - name: Prepare dependencies\n-      run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n-\n-    - name: Patch Cranelift\n-      run: |\n-        sed -i 's/cranelift-codegen = { version = \"\\w*.\\w*.\\w*\", features = \\[\"unwind\", \"all-arch\"\\] }/cranelift-codegen = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\", features = [\"unwind\", \"all-arch\"] }/' Cargo.toml\n-        sed -i 's/cranelift-frontend = \"\\w*.\\w*.\\w*\"/cranelift-frontend = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-        sed -i 's/cranelift-module = \"\\w*.\\w*.\\w*\"/cranelift-module = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-        sed -i 's/cranelift-native = \"\\w*.\\w*.\\w*\"/cranelift-native = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-        sed -i 's/cranelift-jit = { version = \"\\w*.\\w*.\\w*\", optional = true }/cranelift-jit = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\", optional = true }/' Cargo.toml\n-        sed -i 's/cranelift-object = \"\\w*.\\w*.\\w*\"/cranelift-object = { git = \"https:\\/\\/github.com\\/bytecodealliance\\/wasmtime.git\" }/' Cargo.toml\n-\n-        sed -i 's/object = { version = \"0.27.0\"/object = { version = \"0.28.0\"/' Cargo.toml\n-\n-        cat Cargo.toml\n-\n-    - name: Build without unstable features\n-      # This is the config rust-lang/rust uses for builds\n-      run: ./y.rs build --no-unstable-features\n-\n-    - name: Build\n-      run: ./y.rs build --sysroot none\n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n-\n-        # Enable extra checks\n-        export CG_CLIF_ENABLE_VERIFIER=1\n-\n-        ./test.sh"}, {"sha": "5faa8f0540451b848506fadd139fc6333429b230", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "modified", "additions": 18, "deletions": 46, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -10,73 +10,45 @@ jobs:\n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n         path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Prepare dependencies\n+    - name: Use sparse cargo registry\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n \n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n-        ./scripts/test_bootstrap.sh\n+    - name: Test\n+      run: ./scripts/test_bootstrap.sh\n   rustc_test_suite:\n     runs-on: ubuntu-latest\n \n     steps:\n     - uses: actions/checkout@v3\n \n-    - name: Cache cargo installed crates\n-      uses: actions/cache@v3\n-      with:\n-        path: ~/.cargo/bin\n-        key: ${{ runner.os }}-cargo-installed-crates\n-\n-    - name: Cache cargo registry and index\n-      uses: actions/cache@v3\n-      with:\n-        path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-        key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n     - name: Cache cargo target dir\n       uses: actions/cache@v3\n       with:\n         path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Prepare dependencies\n+    - name: Use sparse cargo registry\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n \n-    - name: Test\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n-        ./scripts/test_rustc_tests.sh\n+    - name: Test\n+      run: ./scripts/test_rustc_tests.sh"}, {"sha": "8012e93f6a90ebdee2747548145a52b8f2e3f45c", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,4 +1,4 @@\n-target\n+/target\n **/*.rs.bk\n *.rlib\n *.o\n@@ -11,9 +11,6 @@ perf.data.old\n /y.exe\n /y.pdb\n /build\n-/build_sysroot/sysroot_src\n-/build_sysroot/compiler-builtins\n-/build_sysroot/rustc_version\n /dist\n /rust\n /download"}, {"sha": "7c8703cba505c6e221910aabcef2a5ea4f712a41", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,4 +1,6 @@\n {\n+    \"editor.formatOnSave\": true,\n+\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n     \"rust-analyzer.imports.granularity.enforce\": true,\n@@ -30,7 +32,7 @@\n             ]\n         },\n         {\n-            \"sysroot_src\": \"./build_sysroot/sysroot_src/library\",\n+            \"sysroot_src\": \"./download/sysroot/sysroot_src/library\",\n             \"crates\": [\n                 {\n                     \"root_module\": \"./example/std_example.rs\","}, {"sha": "50249ea1bdb493e08815b1f81c373c4a1d4937db", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 53, "deletions": 54, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -57,28 +57,28 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b62c772976416112fa4484cbd688cb6fb35fd430005c1c586224fc014018abad\"\n+checksum = \"2f3d54eab028f5805ae3b26fd60eca3f3a9cfb76b989d9bab173be3f61356cc3\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9b40ed2dd13c2ac7e24f88a3090c68ad3414eb1d066a95f8f1f7b3b819cb4e46\"\n+checksum = \"2be1d5f2c3cca1efb691844bc1988b89c77291f13f778499a3f3c0cf49c0ed61\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n- \"cranelift-egraph\",\n  \"cranelift-entity\",\n  \"cranelift-isle\",\n  \"gimli\",\n+ \"hashbrown\",\n  \"log\",\n  \"regalloc2\",\n  \"smallvec\",\n@@ -87,44 +87,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb927a8f1c27c34ee3759b6b0ffa528d2330405d5cc4511f0cab33fe2279f4b5\"\n+checksum = \"3f9b1b1089750ce4005893af7ee00bb08a2cf1c9779999c0f7164cbc8ad2e0d2\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"43dfa417b884a9ab488d95fd6b93b25e959321fe7bfd7a0a960ba5d7fb7ab927\"\n-\n-[[package]]\n-name = \"cranelift-egraph\"\n-version = \"0.90.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e0a66b39785efd8513d2cca967ede56d6cc57c8d7986a595c7c47d0c78de8dce\"\n-dependencies = [\n- \"cranelift-entity\",\n- \"fxhash\",\n- \"hashbrown\",\n- \"indexmap\",\n- \"log\",\n- \"smallvec\",\n-]\n+checksum = \"cc5fbaec51de47297fd7304986fd53c8c0030abbe69728a60d72e1c63559318d\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0637ffde963cb5d759bc4d454cfa364b6509e6c74cdaa21298add0ed9276f346\"\n+checksum = \"dab984c94593f876090fae92e984bdcc74d9b1acf740ab5f79036001c65cba13\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fb72b8342685e850cb037350418f62cc4fc55d6c2eb9c7ca01b82f9f1a6f3d56\"\n+checksum = \"6e0cb3102d21a2fe5f3210af608748ddd0cd09825ac12d42dc56ed5ed8725fe0\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -134,15 +120,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"850579cb9e4b448f7c301f1e6e6cbad99abe3f1f1d878a4994cb66e33c6db8cd\"\n+checksum = \"72101dd1f441d629735143c41e00b3428f9267738176983ef588ff43382af0a0\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9add822ad66dcbe152b5ab57de10240a2df4505099f2f6c27159acb711890bd4\"\n+checksum = \"6557f8ce44d498777f2495aa58d9692a4a37d6f84aa445750d666cef770b6a5c\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -159,19 +145,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"406b772626fc2664864cf947f3895a23b619895c7fff635f3622e2d857f4492f\"\n+checksum = \"88807e1c0c47ec02fe433333ccbe56b480425418b1470e333205e11650697d72\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d0a279e5bcba3e0466c734d8d8eb6bfc1ad29e95c37f3e4955b492b5616335e\"\n+checksum = \"c22b0d9fcbe3fc5a1af9e7021b44ce42b930bcefac446ce22e02e8f9a0d67120\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -180,9 +166,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.90.1\"\n+version = \"0.92.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39793c550f0c1d7db96c2fc1324583670c8143befe6edbfbaf1c68aba53be983\"\n+checksum = \"341375758d7c3fedc0b5315f552e6f0feac46baf87c450a15e9455ef47c2b261\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -317,9 +303,9 @@ checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.4.2\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"91b2eab54204ea0117fe9a060537e0b07a4e72f7c7d182361ecc346cab2240e5\"\n+checksum = \"300d4fbfb40c1c66a78ba3ddd41c1110247cf52f97b87d0f2fc9209bd49b030c\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -347,7 +333,6 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n- \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -396,9 +381,9 @@ checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"wasmtime-jit-icache-coherence\"\n-version = \"2.0.1\"\n+version = \"5.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6bbabb309c06cc238ee91b1455b748c45f0bdcab0dda2c2db85b0a1e69fcb66\"\n+checksum = \"08fcba5ebd96da2a9f0747ab6337fe9788adfb3f63fa2c180520d665562d257e\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -429,43 +414,57 @@ checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n+ \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n  \"windows_i686_gnu\",\n  \"windows_i686_msvc\",\n  \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\""}, {"sha": "34117c2886febae43ecebb4f93cc498b2555ed58", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -15,12 +15,14 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.90.1\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.90.1\"\n-cranelift-module = \"0.90.1\"\n-cranelift-native = \"0.90.1\"\n-cranelift-jit = { version = \"0.90.1\", optional = true }\n-cranelift-object = \"0.90.1\"\n+cranelift-codegen = { version = \"0.92\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { version = \"0.92\" }\n+cranelift-module = { version = \"0.92\" }\n+# NOTE vendored as src/cranelift_native.rs\n+# FIXME revert back to the external crate with Cranelift 0.93\n+#cranelift-native = { version = \"0.92\" }\n+cranelift-jit = { version = \"0.92\", optional = true }\n+cranelift-object = { version = \"0.92\" }\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }"}, {"sha": "b87a9dc51e8d0f3f956e5fc69acb701a2c8e1ad3", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -8,9 +8,9 @@ If not please open an issue.\n ## Building and testing\n \n ```bash\n-$ git clone https://github.com/bjorn3/rustc_codegen_cranelift.git\n+$ git clone https://github.com/bjorn3/rustc_codegen_cranelift\n $ cd rustc_codegen_cranelift\n-$ ./y.rs prepare # download and patch sysroot src and install hyperfine for benchmarking\n+$ ./y.rs prepare\n $ ./y.rs build\n ```\n \n@@ -20,13 +20,12 @@ To run the test suite replace the last command with:\n $ ./test.sh\n ```\n \n-This will implicitly build cg_clif too. Both `y.rs build` and `test.sh` accept a `--debug` argument to\n-build in debug mode.\n+For more docs on how to build and test see [build_system/usage.txt](build_system/usage.txt) or the help message of `./y.rs`.\n \n-Alternatively you can download a pre built version from [GHA]. It is listed in the artifacts section\n+Alternatively you can download a pre built version from [Github Actions]. It is listed in the artifacts section\n of workflow runs. Unfortunately due to GHA restrictions you need to be logged in to access it.\n \n-[GHA]: https://github.com/bjorn3/rustc_codegen_cranelift/actions?query=branch%3Amaster+event%3Apush+is%3Asuccess\n+[Github Actions]: https://github.com/bjorn3/rustc_codegen_cranelift/actions?query=branch%3Amaster+event%3Apush+is%3Asuccess\n \n ## Usage\n \n@@ -53,7 +52,8 @@ configuration options.\n \n * Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n     * On UNIX there is support for invoking an external assembler for `global_asm!` and `asm!`.\n-* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n+* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), `std::simd` fully works, `std::arch` is partially supported)\n+* Unwinding on panics ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1677), `-Cpanic=abort` is enabled by default)\n \n ## License\n "}, {"sha": "24f15fc8521fee0dba322e556e6cbe49d3782238", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -34,9 +34,9 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.77\"\n+version = \"1.0.78\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n+checksum = \"a20104e2335ce8a659d6dd92a51a767a0c062599c73b343fd152cb401e828c3d\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.85\"\n+version = \"0.1.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"13e81c6cd7ab79f51a0c927d22858d61ad12bd0b3865f0b13ece02a4486aeabb\"\n+checksum = \"5dae98c88e576098d7ab13ebcb40cc43e5114b2beafe61a87cda9200649ff205\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -129,9 +129,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.138\"\n+version = \"0.2.139\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n+checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "dbee9be04eea6356920bbcde1c97583abb0c9cb7", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,7 +1,6 @@\n use std::path::Path;\n \n use super::build_sysroot;\n-use super::config;\n use super::path::Dirs;\n use super::prepare::GitRepo;\n use super::utils::{spawn_and_wait, CargoProject, Compiler};\n@@ -10,41 +9,31 @@ use super::SysrootKind;\n pub(crate) static ABI_CAFE_REPO: GitRepo =\n     GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n \n-static ABI_CAFE: CargoProject = CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n+pub(crate) static ABI_CAFE: CargoProject =\n+    CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n \n pub(crate) fn run(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     dirs: &Dirs,\n     cg_clif_dylib: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n+    bootstrap_host_compiler: &Compiler,\n ) {\n-    if !config::get_bool(\"testsuite.abi-cafe\") {\n-        eprintln!(\"[SKIP] abi-cafe\");\n-        return;\n-    }\n-\n-    if host_triple != target_triple {\n-        eprintln!(\"[SKIP] abi-cafe (cross-compilation not supported)\");\n-        return;\n-    }\n-\n     eprintln!(\"Building sysroot for abi-cafe\");\n     build_sysroot::build_sysroot(\n         dirs,\n         channel,\n         sysroot_kind,\n         cg_clif_dylib,\n-        host_triple,\n-        target_triple,\n+        bootstrap_host_compiler,\n+        bootstrap_host_compiler.triple.clone(),\n     );\n \n     eprintln!(\"Running abi-cafe\");\n \n     let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n \n-    let mut cmd = ABI_CAFE.run(&Compiler::host(), dirs);\n+    let mut cmd = ABI_CAFE.run(bootstrap_host_compiler, dirs);\n     cmd.arg(\"--\");\n     cmd.arg(\"--pairs\");\n     cmd.args(pairs);"}, {"sha": "01d44dafbdd17ac4e2c8b4412ecc695e318c1277", "filename": "compiler/rustc_codegen_cranelift/build_system/bench.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbench.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,97 @@\n+use std::env;\n+use std::fs;\n+use std::path::Path;\n+\n+use super::path::{Dirs, RelPath};\n+use super::prepare::GitRepo;\n+use super::rustc_info::get_file_name;\n+use super::utils::{hyperfine_command, is_ci, spawn_and_wait, CargoProject, Compiler};\n+\n+pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n+\n+// Use a separate target dir for the initial LLVM build to reduce unnecessary recompiles\n+pub(crate) static SIMPLE_RAYTRACER_LLVM: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer_llvm\");\n+\n+pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n+\n+pub(crate) fn benchmark(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n+    benchmark_simple_raytracer(dirs, bootstrap_host_compiler);\n+}\n+\n+fn benchmark_simple_raytracer(dirs: &Dirs, bootstrap_host_compiler: &Compiler) {\n+    if std::process::Command::new(\"hyperfine\").output().is_err() {\n+        eprintln!(\"Hyperfine not installed\");\n+        eprintln!(\"Hint: Try `cargo install hyperfine` to install hyperfine\");\n+        std::process::exit(1);\n+    }\n+\n+    eprintln!(\"[LLVM BUILD] simple-raytracer\");\n+    let build_cmd = SIMPLE_RAYTRACER_LLVM.build(bootstrap_host_compiler, dirs);\n+    spawn_and_wait(build_cmd);\n+    fs::copy(\n+        SIMPLE_RAYTRACER_LLVM\n+            .target_dir(dirs)\n+            .join(&bootstrap_host_compiler.triple)\n+            .join(\"debug\")\n+            .join(get_file_name(\"main\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+    )\n+    .unwrap();\n+\n+    let run_runs = env::var(\"RUN_RUNS\")\n+        .unwrap_or(if is_ci() { \"2\" } else { \"10\" }.to_string())\n+        .parse()\n+        .unwrap();\n+\n+    eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+    let cargo_clif =\n+        RelPath::DIST.to_path(dirs).join(get_file_name(\"cargo_clif\", \"bin\").replace('_', \"-\"));\n+    let manifest_path = SIMPLE_RAYTRACER.manifest_path(dirs);\n+    let target_dir = SIMPLE_RAYTRACER.target_dir(dirs);\n+\n+    let clean_cmd = format!(\n+        \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        manifest_path = manifest_path.display(),\n+        target_dir = target_dir.display(),\n+    );\n+    let llvm_build_cmd = format!(\n+        \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        manifest_path = manifest_path.display(),\n+        target_dir = target_dir.display(),\n+    );\n+    let clif_build_cmd = format!(\n+        \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+        cargo_clif = cargo_clif.display(),\n+        manifest_path = manifest_path.display(),\n+        target_dir = target_dir.display(),\n+    );\n+\n+    let bench_compile =\n+        hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n+\n+    spawn_and_wait(bench_compile);\n+\n+    eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+    fs::copy(\n+        target_dir.join(\"debug\").join(get_file_name(\"main\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_clif\", \"bin\")),\n+    )\n+    .unwrap();\n+\n+    let mut bench_run = hyperfine_command(\n+        0,\n+        run_runs,\n+        None,\n+        Path::new(\".\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")).to_str().unwrap(),\n+        Path::new(\".\").join(get_file_name(\"raytracer_cg_clif\", \"bin\")).to_str().unwrap(),\n+    );\n+    bench_run.current_dir(RelPath::BUILD.to_path(dirs));\n+    spawn_and_wait(bench_run);\n+}"}, {"sha": "514404305a3fa0416635e45dc7ad0b9a6a34357a", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -5,15 +5,15 @@ use super::path::{Dirs, RelPath};\n use super::rustc_info::get_file_name;\n use super::utils::{is_ci, CargoProject, Compiler};\n \n-static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n+pub(crate) static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n \n pub(crate) fn build_backend(\n     dirs: &Dirs,\n     channel: &str,\n-    host_triple: &str,\n+    bootstrap_host_compiler: &Compiler,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let mut cmd = CG_CLIF.build(&Compiler::host(), dirs);\n+    let mut cmd = CG_CLIF.build(&bootstrap_host_compiler, dirs);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -25,6 +25,8 @@ pub(crate) fn build_backend(\n \n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n         cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+\n+        cmd.env(\"CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS\", \"true\");\n     }\n \n     if use_unstable_features {\n@@ -46,7 +48,7 @@ pub(crate) fn build_backend(\n \n     CG_CLIF\n         .target_dir(dirs)\n-        .join(host_triple)\n+        .join(&bootstrap_host_compiler.triple)\n         .join(channel)\n         .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))\n }"}, {"sha": "bd04fdbe304a3031cf7995133a306a04744ff118", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 187, "deletions": 118, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,31 +1,32 @@\n use std::fs;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n use super::path::{Dirs, RelPath};\n-use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{spawn_and_wait, try_hard_link, CargoProject, Compiler};\n+use super::rustc_info::{get_file_name, get_rustc_version, get_toolchain_name};\n+use super::utils::{remove_dir_if_exists, spawn_and_wait, try_hard_link, CargoProject, Compiler};\n use super::SysrootKind;\n \n static DIST_DIR: RelPath = RelPath::DIST;\n static BIN_DIR: RelPath = RelPath::DIST.join(\"bin\");\n static LIB_DIR: RelPath = RelPath::DIST.join(\"lib\");\n-static RUSTLIB_DIR: RelPath = LIB_DIR.join(\"rustlib\");\n \n pub(crate) fn build_sysroot(\n     dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     cg_clif_dylib_src: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n-) {\n+    bootstrap_host_compiler: &Compiler,\n+    target_triple: String,\n+) -> Compiler {\n     eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n \n     DIST_DIR.ensure_fresh(dirs);\n     BIN_DIR.ensure_exists(dirs);\n     LIB_DIR.ensure_exists(dirs);\n \n+    let is_native = bootstrap_host_compiler.triple == target_triple;\n+\n     // Copy the backend\n     let cg_clif_dylib_path = if cfg!(windows) {\n         // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n@@ -35,137 +36,177 @@ pub(crate) fn build_sysroot(\n         LIB_DIR\n     }\n     .to_path(dirs)\n-    .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    .join(cg_clif_dylib_src.file_name().unwrap());\n     try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n+    let wrapper_base_name = get_file_name(\"____\", \"bin\");\n+    let toolchain_name = get_toolchain_name();\n     for wrapper in [\"rustc-clif\", \"rustdoc-clif\", \"cargo-clif\"] {\n-        let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n+        let wrapper_name = wrapper_base_name.replace(\"____\", wrapper);\n \n-        let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n+        let mut build_cargo_wrapper_cmd = Command::new(&bootstrap_host_compiler.rustc);\n         build_cargo_wrapper_cmd\n+            .env(\"TOOLCHAIN_NAME\", toolchain_name.clone())\n             .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n             .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n-            .arg(\"-g\");\n+            .arg(\"-Cstrip=debuginfo\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }\n \n-    let default_sysroot = super::rustc_info::get_default_sysroot();\n+    let host = build_sysroot_for_triple(\n+        dirs,\n+        channel,\n+        bootstrap_host_compiler.clone(),\n+        &cg_clif_dylib_path,\n+        sysroot_kind,\n+    );\n+    host.install_into_sysroot(&DIST_DIR.to_path(dirs));\n \n-    let host_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(host_triple).join(\"lib\");\n-    let target_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(target_triple).join(\"lib\");\n-    fs::create_dir_all(&host_rustlib_lib).unwrap();\n-    fs::create_dir_all(&target_rustlib_lib).unwrap();\n+    if !is_native {\n+        build_sysroot_for_triple(\n+            dirs,\n+            channel,\n+            {\n+                let mut bootstrap_target_compiler = bootstrap_host_compiler.clone();\n+                bootstrap_target_compiler.triple = target_triple.clone();\n+                bootstrap_target_compiler.set_cross_linker_and_runner();\n+                bootstrap_target_compiler\n+            },\n+            &cg_clif_dylib_path,\n+            sysroot_kind,\n+        )\n+        .install_into_sysroot(&DIST_DIR.to_path(dirs));\n+    }\n \n-    if target_triple == \"x86_64-pc-windows-gnu\" {\n-        if !default_sysroot.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\").exists() {\n-            eprintln!(\n-                \"The x86_64-pc-windows-gnu target needs to be installed first before it is possible \\\n-                to compile a sysroot for it.\",\n-            );\n-            process::exit(1);\n+    // Copy std for the host to the lib dir. This is necessary for the jit mode to find\n+    // libstd.\n+    for lib in host.libs {\n+        let filename = lib.file_name().unwrap().to_str().unwrap();\n+        if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n+            try_hard_link(&lib, LIB_DIR.to_path(dirs).join(lib.file_name().unwrap()));\n         }\n-        for file in fs::read_dir(\n-            default_sysroot.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\"),\n-        )\n-        .unwrap()\n-        {\n-            let file = file.unwrap().path();\n-            if file.extension().map_or(true, |ext| ext.to_str().unwrap() != \"o\") {\n-                continue; // only copy object files\n-            }\n-            try_hard_link(&file, target_rustlib_lib.join(file.file_name().unwrap()));\n+    }\n+\n+    let mut target_compiler = {\n+        let dirs: &Dirs = &dirs;\n+        let rustc_clif =\n+            RelPath::DIST.to_path(&dirs).join(wrapper_base_name.replace(\"____\", \"rustc-clif\"));\n+        let rustdoc_clif =\n+            RelPath::DIST.to_path(&dirs).join(wrapper_base_name.replace(\"____\", \"rustdoc-clif\"));\n+\n+        Compiler {\n+            cargo: bootstrap_host_compiler.cargo.clone(),\n+            rustc: rustc_clif.clone(),\n+            rustdoc: rustdoc_clif.clone(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: target_triple,\n+            runner: vec![],\n         }\n+    };\n+    if !is_native {\n+        target_compiler.set_cross_linker_and_runner();\n     }\n+    target_compiler\n+}\n \n-    match sysroot_kind {\n-        SysrootKind::None => {} // Nothing to do\n-        SysrootKind::Llvm => {\n-            for file in fs::read_dir(\n-                default_sysroot.join(\"lib\").join(\"rustlib\").join(host_triple).join(\"lib\"),\n-            )\n-            .unwrap()\n-            {\n-                let file = file.unwrap().path();\n-                let file_name_str = file.file_name().unwrap().to_str().unwrap();\n-                if (file_name_str.contains(\"rustc_\")\n-                    && !file_name_str.contains(\"rustc_std_workspace_\")\n-                    && !file_name_str.contains(\"rustc_demangle\"))\n-                    || file_name_str.contains(\"chalk\")\n-                    || file_name_str.contains(\"tracing\")\n-                    || file_name_str.contains(\"regex\")\n-                {\n-                    // These are large crates that are part of the rustc-dev component and are not\n-                    // necessary to run regular programs.\n-                    continue;\n-                }\n-                try_hard_link(&file, host_rustlib_lib.join(file.file_name().unwrap()));\n-            }\n+struct SysrootTarget {\n+    triple: String,\n+    libs: Vec<PathBuf>,\n+}\n \n-            if target_triple != host_triple {\n-                for file in fs::read_dir(\n-                    default_sysroot.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\"),\n-                )\n-                .unwrap()\n-                {\n-                    let file = file.unwrap().path();\n-                    try_hard_link(&file, target_rustlib_lib.join(file.file_name().unwrap()));\n-                }\n-            }\n+impl SysrootTarget {\n+    fn install_into_sysroot(&self, sysroot: &Path) {\n+        if self.libs.is_empty() {\n+            return;\n         }\n-        SysrootKind::Clif => {\n-            build_clif_sysroot_for_triple(dirs, channel, host_triple, &cg_clif_dylib_path, None);\n-\n-            if host_triple != target_triple {\n-                // When cross-compiling it is often necessary to manually pick the right linker\n-                let linker = match target_triple {\n-                    \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu-gcc\"),\n-                    \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu-gcc\"),\n-                    _ => None,\n-                };\n-                build_clif_sysroot_for_triple(\n-                    dirs,\n-                    channel,\n-                    target_triple,\n-                    &cg_clif_dylib_path,\n-                    linker,\n-                );\n-            }\n \n-            // Copy std for the host to the lib dir. This is necessary for the jit mode to find\n-            // libstd.\n-            for file in fs::read_dir(host_rustlib_lib).unwrap() {\n-                let file = file.unwrap().path();\n-                let filename = file.file_name().unwrap().to_str().unwrap();\n-                if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n-                    try_hard_link(&file, LIB_DIR.to_path(dirs).join(file.file_name().unwrap()));\n-                }\n-            }\n+        let target_rustlib_lib = sysroot.join(\"lib\").join(\"rustlib\").join(&self.triple).join(\"lib\");\n+        fs::create_dir_all(&target_rustlib_lib).unwrap();\n+\n+        for lib in &self.libs {\n+            try_hard_link(lib, target_rustlib_lib.join(lib.file_name().unwrap()));\n         }\n     }\n }\n \n-// FIXME move to download/ or dist/\n-pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = RelPath::BUILD_SYSROOT.join(\"rustc_version\");\n-pub(crate) static SYSROOT_SRC: RelPath = RelPath::BUILD_SYSROOT.join(\"sysroot_src\");\n-static STANDARD_LIBRARY: CargoProject = CargoProject::new(&RelPath::BUILD_SYSROOT, \"build_sysroot\");\n+pub(crate) static ORIG_BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n+pub(crate) static BUILD_SYSROOT: RelPath = RelPath::DOWNLOAD.join(\"sysroot\");\n+pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = BUILD_SYSROOT.join(\"rustc_version\");\n+pub(crate) static SYSROOT_SRC: RelPath = BUILD_SYSROOT.join(\"sysroot_src\");\n+pub(crate) static STANDARD_LIBRARY: CargoProject =\n+    CargoProject::new(&BUILD_SYSROOT, \"build_sysroot\");\n+pub(crate) static RTSTARTUP_SYSROOT: RelPath = RelPath::BUILD.join(\"rtstartup\");\n \n+#[must_use]\n+fn build_sysroot_for_triple(\n+    dirs: &Dirs,\n+    channel: &str,\n+    compiler: Compiler,\n+    cg_clif_dylib_path: &Path,\n+    sysroot_kind: SysrootKind,\n+) -> SysrootTarget {\n+    match sysroot_kind {\n+        SysrootKind::None => build_rtstartup(dirs, &compiler)\n+            .unwrap_or(SysrootTarget { triple: compiler.triple, libs: vec![] }),\n+        SysrootKind::Llvm => build_llvm_sysroot_for_triple(compiler),\n+        SysrootKind::Clif => {\n+            build_clif_sysroot_for_triple(dirs, channel, compiler, &cg_clif_dylib_path)\n+        }\n+    }\n+}\n+\n+#[must_use]\n+fn build_llvm_sysroot_for_triple(compiler: Compiler) -> SysrootTarget {\n+    let default_sysroot = super::rustc_info::get_default_sysroot(&compiler.rustc);\n+\n+    let mut target_libs = SysrootTarget { triple: compiler.triple, libs: vec![] };\n+\n+    for entry in fs::read_dir(\n+        default_sysroot.join(\"lib\").join(\"rustlib\").join(&target_libs.triple).join(\"lib\"),\n+    )\n+    .unwrap()\n+    {\n+        let entry = entry.unwrap();\n+        if entry.file_type().unwrap().is_dir() {\n+            continue;\n+        }\n+        let file = entry.path();\n+        let file_name_str = file.file_name().unwrap().to_str().unwrap();\n+        if (file_name_str.contains(\"rustc_\")\n+            && !file_name_str.contains(\"rustc_std_workspace_\")\n+            && !file_name_str.contains(\"rustc_demangle\"))\n+            || file_name_str.contains(\"chalk\")\n+            || file_name_str.contains(\"tracing\")\n+            || file_name_str.contains(\"regex\")\n+        {\n+            // These are large crates that are part of the rustc-dev component and are not\n+            // necessary to run regular programs.\n+            continue;\n+        }\n+        target_libs.libs.push(file);\n+    }\n+\n+    target_libs\n+}\n+\n+#[must_use]\n fn build_clif_sysroot_for_triple(\n     dirs: &Dirs,\n     channel: &str,\n-    triple: &str,\n+    mut compiler: Compiler,\n     cg_clif_dylib_path: &Path,\n-    linker: Option<&str>,\n-) {\n+) -> SysrootTarget {\n     match fs::read_to_string(SYSROOT_RUSTC_VERSION.to_path(dirs)) {\n         Err(e) => {\n             eprintln!(\"Failed to get rustc version for patched sysroot source: {}\", e);\n             eprintln!(\"Hint: Try `./y.rs prepare` to patch the sysroot source\");\n             process::exit(1);\n         }\n         Ok(source_version) => {\n-            let rustc_version = get_rustc_version();\n+            let rustc_version = get_rustc_version(&compiler.rustc);\n             if source_version != rustc_version {\n                 eprintln!(\"The patched sysroot source is outdated\");\n                 eprintln!(\"Source version: {}\", source_version.trim());\n@@ -176,37 +217,39 @@ fn build_clif_sysroot_for_triple(\n         }\n     }\n \n-    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(triple).join(channel);\n+    let mut target_libs = SysrootTarget { triple: compiler.triple.clone(), libs: vec![] };\n+\n+    if let Some(rtstartup_target_libs) = build_rtstartup(dirs, &compiler) {\n+        rtstartup_target_libs.install_into_sysroot(&RTSTARTUP_SYSROOT.to_path(dirs));\n+\n+        target_libs.libs.extend(rtstartup_target_libs.libs);\n+    }\n+\n+    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(&compiler.triple).join(channel);\n \n     if !super::config::get_bool(\"keep_sysroot\") {\n         // Cleanup the deps dir, but keep build scripts and the incremental cache for faster\n         // recompilation as they are not affected by changes in cg_clif.\n-        if build_dir.join(\"deps\").exists() {\n-            fs::remove_dir_all(build_dir.join(\"deps\")).unwrap();\n-        }\n+        remove_dir_if_exists(&build_dir.join(\"deps\"));\n     }\n \n     // Build sysroot\n-    let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n+    let mut rustflags = \" -Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n-    rustflags.push_str(&format!(\" --sysroot={}\", DIST_DIR.to_path(dirs).to_str().unwrap()));\n+    // Necessary for MinGW to find rsbegin.o and rsend.o\n+    rustflags\n+        .push_str(&format!(\" --sysroot={}\", RTSTARTUP_SYSROOT.to_path(dirs).to_str().unwrap()));\n     if channel == \"release\" {\n         rustflags.push_str(\" -Zmir-opt-level=3\");\n     }\n-    if let Some(linker) = linker {\n-        use std::fmt::Write;\n-        write!(rustflags, \" -Clinker={}\", linker).unwrap();\n-    }\n-    let mut compiler = Compiler::with_triple(triple.to_owned());\n-    compiler.rustflags = rustflags;\n+    compiler.rustflags += &rustflags;\n     let mut build_cmd = STANDARD_LIBRARY.build(&compiler, dirs);\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n     }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n \n-    // Copy all relevant files to the sysroot\n     for entry in fs::read_dir(build_dir.join(\"deps\")).unwrap() {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n@@ -216,9 +259,35 @@ fn build_clif_sysroot_for_triple(\n         } else {\n             continue;\n         };\n-        try_hard_link(\n-            entry.path(),\n-            RUSTLIB_DIR.to_path(dirs).join(triple).join(\"lib\").join(entry.file_name()),\n-        );\n+        target_libs.libs.push(entry.path());\n+    }\n+\n+    target_libs\n+}\n+\n+fn build_rtstartup(dirs: &Dirs, compiler: &Compiler) -> Option<SysrootTarget> {\n+    if !compiler.triple.ends_with(\"windows-gnu\") {\n+        return None;\n     }\n+\n+    RTSTARTUP_SYSROOT.ensure_fresh(dirs);\n+\n+    let rtstartup_src = SYSROOT_SRC.to_path(dirs).join(\"library\").join(\"rtstartup\");\n+    let mut target_libs = SysrootTarget { triple: compiler.triple.clone(), libs: vec![] };\n+\n+    for file in [\"rsbegin\", \"rsend\"] {\n+        let obj = RTSTARTUP_SYSROOT.to_path(dirs).join(format!(\"{file}.o\"));\n+        let mut build_rtstartup_cmd = Command::new(&compiler.rustc);\n+        build_rtstartup_cmd\n+            .arg(\"--target\")\n+            .arg(&compiler.triple)\n+            .arg(\"--emit=obj\")\n+            .arg(\"-o\")\n+            .arg(&obj)\n+            .arg(rtstartup_src.join(format!(\"{file}.rs\")));\n+        spawn_and_wait(build_rtstartup_cmd);\n+        target_libs.libs.push(obj.clone());\n+    }\n+\n+    Some(target_libs)\n }"}, {"sha": "8dcbe8de189b25a0c31edb7a8fe5525a5826a359", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -2,9 +2,10 @@ use std::env;\n use std::path::PathBuf;\n use std::process;\n \n-use self::utils::is_ci;\n+use self::utils::{is_ci, Compiler};\n \n mod abi_cafe;\n+mod bench;\n mod build_backend;\n mod build_sysroot;\n mod config;\n@@ -14,31 +15,8 @@ mod rustc_info;\n mod tests;\n mod utils;\n \n-const USAGE: &str = r#\"The build system of cg_clif.\n-\n-USAGE:\n-    ./y.rs prepare [--out-dir DIR]\n-    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n-    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n-\n-OPTIONS:\n-    --sysroot none|clif|llvm\n-            Which sysroot libraries to use:\n-            `none` will not include any standard library in the sysroot.\n-            `clif` will build the standard library using Cranelift.\n-            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n-\n-    --out-dir DIR\n-            Specify the directory in which the download, build and dist directories are stored.\n-            By default this is the working directory.\n-\n-    --no-unstable-features\n-            fSome features are not yet ready for production usage. This option will disable these\n-            features. This includes the JIT mode and inline assembly support.\n-\"#;\n-\n fn usage() {\n-    eprintln!(\"{USAGE}\");\n+    eprintln!(\"{}\", include_str!(\"usage.txt\"));\n }\n \n macro_rules! arg_error {\n@@ -54,6 +32,8 @@ enum Command {\n     Prepare,\n     Build,\n     Test,\n+    AbiCafe,\n+    Bench,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -64,19 +44,26 @@ pub(crate) enum SysrootKind {\n }\n \n pub fn main() {\n-    env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n+    if env::var(\"RUST_BACKTRACE\").is_err() {\n+        env::set_var(\"RUST_BACKTRACE\", \"1\");\n+    }\n     env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n \n     if is_ci() {\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n         env::set_var(\"CARGO_BUILD_INCREMENTAL\", \"false\");\n+\n+        // Enable the Cranelift verifier\n+        env::set_var(\"CG_CLIF_ENABLE_VERIFIER\", \"1\");\n     }\n \n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n         Some(\"prepare\") => Command::Prepare,\n         Some(\"build\") => Command::Build,\n         Some(\"test\") => Command::Test,\n+        Some(\"abi-cafe\") => Command::AbiCafe,\n+        Some(\"bench\") => Command::Bench,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n         Some(command) => arg_error!(\"Unknown command {}\", command),\n         None => {\n@@ -112,24 +99,16 @@ pub fn main() {\n         }\n     }\n \n-    let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n-        host_triple\n-    } else if let Some(host_triple) = config::get_value(\"host\") {\n-        host_triple\n-    } else {\n-        rustc_info::get_host_triple()\n-    };\n-    let target_triple = if let Ok(target_triple) = std::env::var(\"TARGET_TRIPLE\") {\n-        if target_triple != \"\" {\n-            target_triple\n-        } else {\n-            host_triple.clone() // Empty target triple can happen on GHA\n-        }\n-    } else if let Some(target_triple) = config::get_value(\"target\") {\n-        target_triple\n-    } else {\n-        host_triple.clone()\n-    };\n+    let bootstrap_host_compiler = Compiler::bootstrap_with_triple(\n+        std::env::var(\"HOST_TRIPLE\")\n+            .ok()\n+            .or_else(|| config::get_value(\"host\"))\n+            .unwrap_or_else(|| rustc_info::get_host_triple()),\n+    );\n+    let target_triple = std::env::var(\"TARGET_TRIPLE\")\n+        .ok()\n+        .or_else(|| config::get_value(\"target\"))\n+        .unwrap_or_else(|| bootstrap_host_compiler.triple.clone());\n \n     // FIXME allow changing the location of these dirs using cli arguments\n     let current_dir = std::env::current_dir().unwrap();\n@@ -157,8 +136,15 @@ pub fn main() {\n         process::exit(0);\n     }\n \n-    let cg_clif_dylib =\n-        build_backend::build_backend(&dirs, channel, &host_triple, use_unstable_features);\n+    env::set_var(\"RUSTC\", \"rustc_should_be_set_explicitly\");\n+    env::set_var(\"RUSTDOC\", \"rustdoc_should_be_set_explicitly\");\n+\n+    let cg_clif_dylib = build_backend::build_backend(\n+        &dirs,\n+        channel,\n+        &bootstrap_host_compiler,\n+        use_unstable_features,\n+    );\n     match command {\n         Command::Prepare => {\n             // Handled above\n@@ -169,28 +155,37 @@ pub fn main() {\n                 channel,\n                 sysroot_kind,\n                 &cg_clif_dylib,\n-                &host_triple,\n-                &target_triple,\n+                &bootstrap_host_compiler,\n+                target_triple.clone(),\n             );\n-\n-            abi_cafe::run(\n+        }\n+        Command::AbiCafe => {\n+            if bootstrap_host_compiler.triple != target_triple {\n+                eprintln!(\"Abi-cafe doesn't support cross-compilation\");\n+                process::exit(1);\n+            }\n+            abi_cafe::run(channel, sysroot_kind, &dirs, &cg_clif_dylib, &bootstrap_host_compiler);\n+        }\n+        Command::Build => {\n+            build_sysroot::build_sysroot(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &dirs,\n                 &cg_clif_dylib,\n-                &host_triple,\n-                &target_triple,\n+                &bootstrap_host_compiler,\n+                target_triple,\n             );\n         }\n-        Command::Build => {\n+        Command::Bench => {\n             build_sysroot::build_sysroot(\n                 &dirs,\n                 channel,\n                 sysroot_kind,\n                 &cg_clif_dylib,\n-                &host_triple,\n-                &target_triple,\n+                &bootstrap_host_compiler,\n+                target_triple,\n             );\n+            bench::benchmark(&dirs, &bootstrap_host_compiler);\n         }\n     }\n }"}, {"sha": "3290723005dd92b939486489e4acda090b0a8ac0", "filename": "compiler/rustc_codegen_cranelift/build_system/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fpath.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,6 +1,8 @@\n use std::fs;\n use std::path::PathBuf;\n \n+use super::utils::remove_dir_if_exists;\n+\n #[derive(Debug, Clone)]\n pub(crate) struct Dirs {\n     pub(crate) source_dir: PathBuf,\n@@ -42,7 +44,6 @@ impl RelPath {\n     pub(crate) const DIST: RelPath = RelPath::Base(PathBase::Dist);\n \n     pub(crate) const SCRIPTS: RelPath = RelPath::SOURCE.join(\"scripts\");\n-    pub(crate) const BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n     pub(crate) const PATCHES: RelPath = RelPath::SOURCE.join(\"patches\");\n \n     pub(crate) const fn join(&'static self, suffix: &'static str) -> RelPath {\n@@ -62,9 +63,7 @@ impl RelPath {\n \n     pub(crate) fn ensure_fresh(&self, dirs: &Dirs) {\n         let path = self.to_path(dirs);\n-        if path.exists() {\n-            fs::remove_dir_all(&path).unwrap();\n-        }\n+        remove_dir_if_exists(&path);\n         fs::create_dir_all(path).unwrap();\n     }\n }"}, {"sha": "f25a81dc23459f8e93e4204eb32efb2c80df12e8", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 54, "deletions": 75, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,73 +3,55 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use super::build_sysroot::{SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n+use super::build_sysroot::{BUILD_SYSROOT, ORIG_BUILD_SYSROOT, SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n use super::path::{Dirs, RelPath};\n-use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{copy_dir_recursively, spawn_and_wait, Compiler};\n+use super::rustc_info::{get_default_sysroot, get_rustc_version};\n+use super::utils::{copy_dir_recursively, git_command, retry_spawn_and_wait, spawn_and_wait};\n \n pub(crate) fn prepare(dirs: &Dirs) {\n-    if RelPath::DOWNLOAD.to_path(dirs).exists() {\n-        std::fs::remove_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n-    }\n-    std::fs::create_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n+    RelPath::DOWNLOAD.ensure_fresh(dirs);\n \n-    prepare_sysroot(dirs);\n+    spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", dirs));\n \n-    // FIXME maybe install this only locally?\n-    eprintln!(\"[INSTALL] hyperfine\");\n-    Command::new(\"cargo\")\n-        .arg(\"install\")\n-        .arg(\"hyperfine\")\n-        .env_remove(\"CARGO_TARGET_DIR\")\n-        .spawn()\n-        .unwrap()\n-        .wait()\n-        .unwrap();\n+    prepare_sysroot(dirs);\n+    spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", dirs));\n+    spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", dirs));\n \n     super::abi_cafe::ABI_CAFE_REPO.fetch(dirs);\n+    spawn_and_wait(super::abi_cafe::ABI_CAFE.fetch(\"cargo\", dirs));\n     super::tests::RAND_REPO.fetch(dirs);\n+    spawn_and_wait(super::tests::RAND.fetch(\"cargo\", dirs));\n     super::tests::REGEX_REPO.fetch(dirs);\n+    spawn_and_wait(super::tests::REGEX.fetch(\"cargo\", dirs));\n     super::tests::PORTABLE_SIMD_REPO.fetch(dirs);\n-    super::tests::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n-\n-    eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let host_compiler = Compiler::host();\n-    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler, dirs);\n-    spawn_and_wait(build_cmd);\n-    fs::copy(\n-        super::tests::SIMPLE_RAYTRACER\n-            .target_dir(dirs)\n-            .join(&host_compiler.triple)\n-            .join(\"debug\")\n-            .join(get_file_name(\"main\", \"bin\")),\n-        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n-    )\n-    .unwrap();\n+    spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", dirs));\n+    super::bench::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n+    spawn_and_wait(super::bench::SIMPLE_RAYTRACER.fetch(\"cargo\", dirs));\n }\n \n fn prepare_sysroot(dirs: &Dirs) {\n-    let rustc_path = get_rustc_path();\n-    let sysroot_src_orig = rustc_path.parent().unwrap().join(\"../lib/rustlib/src/rust\");\n-    let sysroot_src = SYSROOT_SRC;\n-\n+    let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n     assert!(sysroot_src_orig.exists());\n \n-    sysroot_src.ensure_fresh(dirs);\n-    fs::create_dir_all(sysroot_src.to_path(dirs).join(\"library\")).unwrap();\n     eprintln!(\"[COPY] sysroot src\");\n+\n+    // FIXME ensure builds error out or update the copy if any of the files copied here change\n+    BUILD_SYSROOT.ensure_fresh(dirs);\n+    copy_dir_recursively(&ORIG_BUILD_SYSROOT.to_path(dirs), &BUILD_SYSROOT.to_path(dirs));\n+\n+    fs::create_dir_all(SYSROOT_SRC.to_path(dirs).join(\"library\")).unwrap();\n     copy_dir_recursively(\n         &sysroot_src_orig.join(\"library\"),\n-        &sysroot_src.to_path(dirs).join(\"library\"),\n+        &SYSROOT_SRC.to_path(dirs).join(\"library\"),\n     );\n \n-    let rustc_version = get_rustc_version();\n+    let rustc_version = get_rustc_version(Path::new(\"rustc\"));\n     fs::write(SYSROOT_RUSTC_VERSION.to_path(dirs), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n-    init_git_repo(&sysroot_src.to_path(dirs));\n+    init_git_repo(&SYSROOT_SRC.to_path(dirs));\n \n-    apply_patches(dirs, \"sysroot\", &sysroot_src.to_path(dirs));\n+    apply_patches(dirs, \"sysroot\", &SYSROOT_SRC.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {\n@@ -118,14 +100,14 @@ impl GitRepo {\n fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     eprintln!(\"[CLONE] {}\", repo);\n     // Ignore exit code as the repo may already have been checked out\n-    Command::new(\"git\").arg(\"clone\").arg(repo).arg(&download_dir).spawn().unwrap().wait().unwrap();\n+    git_command(None, \"clone\").arg(repo).arg(download_dir).spawn().unwrap().wait().unwrap();\n \n-    let mut clean_cmd = Command::new(\"git\");\n-    clean_cmd.arg(\"checkout\").arg(\"--\").arg(\".\").current_dir(&download_dir);\n+    let mut clean_cmd = git_command(download_dir, \"checkout\");\n+    clean_cmd.arg(\"--\").arg(\".\");\n     spawn_and_wait(clean_cmd);\n \n-    let mut checkout_cmd = Command::new(\"git\");\n-    checkout_cmd.arg(\"checkout\").arg(\"-q\").arg(rev).current_dir(download_dir);\n+    let mut checkout_cmd = git_command(download_dir, \"checkout\");\n+    checkout_cmd.arg(\"-q\").arg(rev);\n     spawn_and_wait(checkout_cmd);\n }\n \n@@ -149,8 +131,22 @@ fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo:\n \n     // Download zip archive\n     let mut download_cmd = Command::new(\"curl\");\n-    download_cmd.arg(\"--location\").arg(\"--output\").arg(&archive_file).arg(archive_url);\n-    spawn_and_wait(download_cmd);\n+    download_cmd\n+        .arg(\"--max-time\")\n+        .arg(\"600\")\n+        .arg(\"-y\")\n+        .arg(\"30\")\n+        .arg(\"-Y\")\n+        .arg(\"10\")\n+        .arg(\"--connect-timeout\")\n+        .arg(\"30\")\n+        .arg(\"--continue-at\")\n+        .arg(\"-\")\n+        .arg(\"--location\")\n+        .arg(\"--output\")\n+        .arg(&archive_file)\n+        .arg(archive_url);\n+    retry_spawn_and_wait(5, download_cmd);\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n@@ -167,25 +163,16 @@ fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo:\n }\n \n fn init_git_repo(repo_dir: &Path) {\n-    let mut git_init_cmd = Command::new(\"git\");\n-    git_init_cmd.arg(\"init\").arg(\"-q\").current_dir(repo_dir);\n+    let mut git_init_cmd = git_command(repo_dir, \"init\");\n+    git_init_cmd.arg(\"-q\");\n     spawn_and_wait(git_init_cmd);\n \n-    let mut git_add_cmd = Command::new(\"git\");\n-    git_add_cmd.arg(\"add\").arg(\".\").current_dir(repo_dir);\n+    let mut git_add_cmd = git_command(repo_dir, \"add\");\n+    git_add_cmd.arg(\".\");\n     spawn_and_wait(git_add_cmd);\n \n-    let mut git_commit_cmd = Command::new(\"git\");\n-    git_commit_cmd\n-        .arg(\"-c\")\n-        .arg(\"user.name=Dummy\")\n-        .arg(\"-c\")\n-        .arg(\"user.email=dummy@example.com\")\n-        .arg(\"commit\")\n-        .arg(\"-m\")\n-        .arg(\"Initial commit\")\n-        .arg(\"-q\")\n-        .current_dir(repo_dir);\n+    let mut git_commit_cmd = git_command(repo_dir, \"commit\");\n+    git_commit_cmd.arg(\"-m\").arg(\"Initial commit\").arg(\"-q\");\n     spawn_and_wait(git_commit_cmd);\n }\n \n@@ -220,16 +207,8 @@ fn apply_patches(dirs: &Dirs, crate_name: &str, target_dir: &Path) {\n             target_dir.file_name().unwrap(),\n             patch.file_name().unwrap()\n         );\n-        let mut apply_patch_cmd = Command::new(\"git\");\n-        apply_patch_cmd\n-            .arg(\"-c\")\n-            .arg(\"user.name=Dummy\")\n-            .arg(\"-c\")\n-            .arg(\"user.email=dummy@example.com\")\n-            .arg(\"am\")\n-            .arg(patch)\n-            .arg(\"-q\")\n-            .current_dir(target_dir);\n+        let mut apply_patch_cmd = git_command(target_dir, \"am\");\n+        apply_patch_cmd.arg(patch).arg(\"-q\");\n         spawn_and_wait(apply_patch_cmd);\n     }\n }"}, {"sha": "a70453b4422898e31f0030f1613cf7877260e481", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,9 +1,9 @@\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n \n-pub(crate) fn get_rustc_version() -> String {\n+pub(crate) fn get_rustc_version(rustc: &Path) -> String {\n     let version_info =\n-        Command::new(\"rustc\").stderr(Stdio::inherit()).args(&[\"-V\"]).output().unwrap().stdout;\n+        Command::new(rustc).stderr(Stdio::inherit()).args(&[\"-V\"]).output().unwrap().stdout;\n     String::from_utf8(version_info).unwrap()\n }\n \n@@ -23,6 +23,16 @@ pub(crate) fn get_host_triple() -> String {\n         .to_owned()\n }\n \n+pub(crate) fn get_toolchain_name() -> String {\n+    let active_toolchain = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"show\", \"active-toolchain\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    String::from_utf8(active_toolchain).unwrap().trim().split_once(' ').unwrap().0.to_owned()\n+}\n+\n pub(crate) fn get_cargo_path() -> PathBuf {\n     let cargo_path = Command::new(\"rustup\")\n         .stderr(Stdio::inherit())\n@@ -53,8 +63,8 @@ pub(crate) fn get_rustdoc_path() -> PathBuf {\n     Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n }\n \n-pub(crate) fn get_default_sysroot() -> PathBuf {\n-    let default_sysroot = Command::new(\"rustc\")\n+pub(crate) fn get_default_sysroot(rustc: &Path) -> PathBuf {\n+    let default_sysroot = Command::new(rustc)\n         .stderr(Stdio::inherit())\n         .args(&[\"--print\", \"sysroot\"])\n         .output()\n@@ -83,12 +93,3 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n     assert!(file_name.contains(crate_name));\n     file_name\n }\n-\n-/// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n-/// underscores (`_`). This is specially made for the rustc and cargo wrappers\n-/// which have a dash in the name, and that is not allowed in a crate name.\n-pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n-    let crate_name = crate_name.replace('-', \"_\");\n-    let wrapper_name = get_file_name(&crate_name, crate_type);\n-    wrapper_name.replace('_', \"-\")\n-}"}, {"sha": "dcfadd737566e20d8a76f0fb8bf393e9b27eb654", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 183, "deletions": 393, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,11 +1,10 @@\n-use super::build_sysroot;\n+use super::bench::SIMPLE_RAYTRACER;\n+use super::build_sysroot::{self, SYSROOT_SRC};\n use super::config;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n-use super::rustc_info::{get_cargo_path, get_wrapper_file_name};\n-use super::utils::{\n-    hyperfine_command, spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler,\n-};\n+use super::rustc_info::get_host_triple;\n+use super::utils::{spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler};\n use super::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n@@ -17,256 +16,111 @@ static BUILD_EXAMPLE_OUT_DIR: RelPath = RelPath::BUILD.join(\"example\");\n \n struct TestCase {\n     config: &'static str,\n-    func: &'static dyn Fn(&TestRunner),\n+    cmd: TestCaseCmd,\n+}\n+\n+enum TestCaseCmd {\n+    Custom { func: &'static dyn Fn(&TestRunner) },\n+    BuildLib { source: &'static str, crate_types: &'static str },\n+    BuildBinAndRun { source: &'static str, args: &'static [&'static str] },\n+    JitBin { source: &'static str, args: &'static str },\n }\n \n impl TestCase {\n-    const fn new(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n-        Self { config, func }\n+    // FIXME reduce usage of custom test case commands\n+    const fn custom(config: &'static str, func: &'static dyn Fn(&TestRunner)) -> Self {\n+        Self { config, cmd: TestCaseCmd::Custom { func } }\n+    }\n+\n+    const fn build_lib(\n+        config: &'static str,\n+        source: &'static str,\n+        crate_types: &'static str,\n+    ) -> Self {\n+        Self { config, cmd: TestCaseCmd::BuildLib { source, crate_types } }\n+    }\n+\n+    const fn build_bin_and_run(\n+        config: &'static str,\n+        source: &'static str,\n+        args: &'static [&'static str],\n+    ) -> Self {\n+        Self { config, cmd: TestCaseCmd::BuildBinAndRun { source, args } }\n+    }\n+\n+    const fn jit_bin(config: &'static str, source: &'static str, args: &'static str) -> Self {\n+        Self { config, cmd: TestCaseCmd::JitBin { source, args } }\n     }\n }\n \n const NO_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"build.mini_core\", &|runner| {\n-        runner.run_rustc([\n-            \"example/mini_core.rs\",\n-            \"--crate-name\",\n-            \"mini_core\",\n-            \"--crate-type\",\n-            \"lib,dylib\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"build.example\", &|runner| {\n-        runner.run_rustc([\n-            \"example/example.rs\",\n-            \"--crate-type\",\n-            \"lib\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n-        let mut jit_cmd = runner.rustc_command([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit\",\n-            \"-Cprefer-dynamic\",\n-            \"example/mini_core_hello_world.rs\",\n-            \"--cfg\",\n-            \"jit\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n-        spawn_and_wait(jit_cmd);\n-\n-        eprintln!(\"[JIT-lazy] mini_core_hello_world\");\n-        let mut jit_cmd = runner.rustc_command([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit-lazy\",\n-            \"-Cprefer-dynamic\",\n-            \"example/mini_core_hello_world.rs\",\n-            \"--cfg\",\n-            \"jit\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n-        spawn_and_wait(jit_cmd);\n-    }),\n-    TestCase::new(\"aot.mini_core_hello_world\", &|runner| {\n-        runner.run_rustc([\n-            \"example/mini_core_hello_world.rs\",\n-            \"--crate-name\",\n-            \"mini_core_hello_world\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-g\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n-    }),\n+    TestCase::build_lib(\"build.mini_core\", \"example/mini_core.rs\", \"lib,dylib\"),\n+    TestCase::build_lib(\"build.example\", \"example/example.rs\", \"lib\"),\n+    TestCase::jit_bin(\"jit.mini_core_hello_world\", \"example/mini_core_hello_world.rs\", \"abc bcd\"),\n+    TestCase::build_bin_and_run(\n+        \"aot.mini_core_hello_world\",\n+        \"example/mini_core_hello_world.rs\",\n+        &[\"abc\", \"bcd\"],\n+    ),\n ];\n \n const BASE_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"aot.arbitrary_self_types_pointers_and_wrappers\", &|runner| {\n-        runner.run_rustc([\n-            \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n-            \"--crate-name\",\n-            \"arbitrary_self_types_pointers_and_wrappers\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n-    }),\n-    TestCase::new(\"aot.issue_91827_extern_types\", &|runner| {\n-        runner.run_rustc([\n-            \"example/issue-91827-extern-types.rs\",\n-            \"--crate-name\",\n-            \"issue_91827_extern_types\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"issue_91827_extern_types\", []);\n-    }),\n-    TestCase::new(\"build.alloc_system\", &|runner| {\n-        runner.run_rustc([\n-            \"example/alloc_system.rs\",\n-            \"--crate-type\",\n-            \"lib\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"aot.alloc_example\", &|runner| {\n-        runner.run_rustc([\n-            \"example/alloc_example.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"alloc_example\", []);\n-    }),\n-    TestCase::new(\"jit.std_example\", &|runner| {\n-        runner.run_rustc([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit\",\n-            \"-Cprefer-dynamic\",\n-            \"example/std_example.rs\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-\n-        eprintln!(\"[JIT-lazy] std_example\");\n-        runner.run_rustc([\n-            \"-Zunstable-options\",\n-            \"-Cllvm-args=mode=jit-lazy\",\n-            \"-Cprefer-dynamic\",\n-            \"example/std_example.rs\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-    }),\n-    TestCase::new(\"aot.std_example\", &|runner| {\n-        runner.run_rustc([\n-            \"example/std_example.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"std_example\", [\"arg\"]);\n-    }),\n-    TestCase::new(\"aot.dst_field_align\", &|runner| {\n-        runner.run_rustc([\n-            \"example/dst-field-align.rs\",\n-            \"--crate-name\",\n-            \"dst_field_align\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"dst_field_align\", []);\n-    }),\n-    TestCase::new(\"aot.subslice-patterns-const-eval\", &|runner| {\n-        runner.run_rustc([\n-            \"example/subslice-patterns-const-eval.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-Cpanic=abort\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"subslice-patterns-const-eval\", []);\n-    }),\n-    TestCase::new(\"aot.track-caller-attribute\", &|runner| {\n-        runner.run_rustc([\n-            \"example/track-caller-attribute.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-Cpanic=abort\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"track-caller-attribute\", []);\n-    }),\n-    TestCase::new(\"aot.float-minmax-pass\", &|runner| {\n-        runner.run_rustc([\n-            \"example/float-minmax-pass.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"-Cpanic=abort\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"float-minmax-pass\", []);\n-    }),\n-    TestCase::new(\"aot.mod_bench\", &|runner| {\n-        runner.run_rustc([\n-            \"example/mod_bench.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"mod_bench\", []);\n-    }),\n-    TestCase::new(\"aot.issue-72793\", &|runner| {\n-        runner.run_rustc([\n-            \"example/issue-72793.rs\",\n-            \"--crate-type\",\n-            \"bin\",\n-            \"--target\",\n-            &runner.target_compiler.triple,\n-        ]);\n-        runner.run_out_command(\"issue-72793\", []);\n-    }),\n+    TestCase::build_bin_and_run(\n+        \"aot.arbitrary_self_types_pointers_and_wrappers\",\n+        \"example/arbitrary_self_types_pointers_and_wrappers.rs\",\n+        &[],\n+    ),\n+    TestCase::build_bin_and_run(\n+        \"aot.issue_91827_extern_types\",\n+        \"example/issue-91827-extern-types.rs\",\n+        &[],\n+    ),\n+    TestCase::build_lib(\"build.alloc_system\", \"example/alloc_system.rs\", \"lib\"),\n+    TestCase::build_bin_and_run(\"aot.alloc_example\", \"example/alloc_example.rs\", &[]),\n+    TestCase::jit_bin(\"jit.std_example\", \"example/std_example.rs\", \"\"),\n+    TestCase::build_bin_and_run(\"aot.std_example\", \"example/std_example.rs\", &[\"arg\"]),\n+    TestCase::build_bin_and_run(\"aot.dst_field_align\", \"example/dst-field-align.rs\", &[]),\n+    TestCase::build_bin_and_run(\n+        \"aot.subslice-patterns-const-eval\",\n+        \"example/subslice-patterns-const-eval.rs\",\n+        &[],\n+    ),\n+    TestCase::build_bin_and_run(\n+        \"aot.track-caller-attribute\",\n+        \"example/track-caller-attribute.rs\",\n+        &[],\n+    ),\n+    TestCase::build_bin_and_run(\"aot.float-minmax-pass\", \"example/float-minmax-pass.rs\", &[]),\n+    TestCase::build_bin_and_run(\"aot.mod_bench\", \"example/mod_bench.rs\", &[]),\n+    TestCase::build_bin_and_run(\"aot.issue-72793\", \"example/issue-72793.rs\", &[]),\n ];\n \n pub(crate) static RAND_REPO: GitRepo =\n     GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n \n-static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n+pub(crate) static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n     GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n \n-static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n+pub(crate) static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n     \"portable-simd\",\n-    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"582239ac3b32007613df04d7ffa78dc30f4c5645\",\n     \"portable-simd\",\n );\n \n-static PORTABLE_SIMD: CargoProject =\n+pub(crate) static PORTABLE_SIMD: CargoProject =\n     CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n \n-pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n-    \"ebobby\",\n-    \"simple-raytracer\",\n-    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    \"<none>\",\n-);\n-\n-pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n-    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n-\n-static LIBCORE_TESTS: CargoProject =\n-    CargoProject::new(&RelPath::BUILD_SYSROOT.join(\"sysroot_src/library/core/tests\"), \"core_tests\");\n+pub(crate) static LIBCORE_TESTS: CargoProject =\n+    CargoProject::new(&SYSROOT_SRC.join(\"library/core/tests\"), \"core_tests\");\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.rust-random/rand\", &|runner| {\n+        RAND.clean(&runner.dirs);\n \n         if runner.is_native {\n             eprintln!(\"[TEST] rust-random/rand\");\n@@ -280,60 +134,12 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n-\n-        if runner.is_native {\n-            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-            let cargo_clif = RelPath::DIST\n-                .to_path(&runner.dirs)\n-                .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-            let manifest_path = SIMPLE_RAYTRACER.manifest_path(&runner.dirs);\n-            let target_dir = SIMPLE_RAYTRACER.target_dir(&runner.dirs);\n-\n-            let clean_cmd = format!(\n-                \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n-                manifest_path = manifest_path.display(),\n-                target_dir = target_dir.display(),\n-            );\n-            let llvm_build_cmd = format!(\n-                \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n-                manifest_path = manifest_path.display(),\n-                target_dir = target_dir.display(),\n-            );\n-            let clif_build_cmd = format!(\n-                \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n-                cargo_clif = cargo_clif.display(),\n-                manifest_path = manifest_path.display(),\n-                target_dir = target_dir.display(),\n-            );\n-\n-            let bench_compile =\n-                hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n-\n-            spawn_and_wait(bench_compile);\n-\n-            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n-            fs::copy(\n-                target_dir.join(\"debug\").join(\"main\"),\n-                RelPath::BUILD.to_path(&runner.dirs).join(\"raytracer_cg_clif\"),\n-            )\n-            .unwrap();\n-\n-            let mut bench_run =\n-                hyperfine_command(0, run_runs, None, \"./raytracer_cg_llvm\", \"./raytracer_cg_clif\");\n-            bench_run.current_dir(RelPath::BUILD.to_path(&runner.dirs));\n-            spawn_and_wait(bench_run);\n-        } else {\n-            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo, &runner.dirs));\n-            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n-            eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n-            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n-        }\n+    TestCase::custom(\"test.simple-raytracer\", &|runner| {\n+        SIMPLE_RAYTRACER.clean(&runner.dirs);\n+        spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n     }),\n-    TestCase::new(\"test.libcore\", &|runner| {\n-        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.libcore\", &|runner| {\n+        LIBCORE_TESTS.clean(&runner.dirs);\n \n         if runner.is_native {\n             spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n@@ -344,8 +150,8 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.regex-shootout-regex-dna\", &|runner| {\n+        REGEX.clean(&runner.dirs);\n \n         // newer aho_corasick versions throw a deprecation warning\n         let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n@@ -364,9 +170,10 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n                 REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n             )\n             .unwrap();\n-            let expected_path =\n-                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\");\n-            let expected = fs::read_to_string(&expected_path).unwrap();\n+            let expected = fs::read_to_string(\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\"),\n+            )\n+            .unwrap();\n \n             let output = spawn_and_wait_with_input(run_cmd, input);\n             // Make sure `[codegen mono items] start` doesn't poison the diff\n@@ -379,27 +186,16 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n \n             let output_matches = expected.lines().eq(output.lines());\n             if !output_matches {\n-                let res_path = REGEX.source_dir(&runner.dirs).join(\"res.txt\");\n-                fs::write(&res_path, &output).unwrap();\n-\n-                if cfg!(windows) {\n-                    println!(\"Output files don't match!\");\n-                    println!(\"Expected Output:\\n{}\", expected);\n-                    println!(\"Actual Output:\\n{}\", output);\n-                } else {\n-                    let mut diff = Command::new(\"diff\");\n-                    diff.arg(\"-u\");\n-                    diff.arg(res_path);\n-                    diff.arg(expected_path);\n-                    spawn_and_wait(diff);\n-                }\n+                println!(\"Output files don't match!\");\n+                println!(\"Expected Output:\\n{}\", expected);\n+                println!(\"Actual Output:\\n{}\", output);\n \n                 std::process::exit(1);\n             }\n         }\n     }),\n-    TestCase::new(\"test.regex\", &|runner| {\n-        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.regex\", &|runner| {\n+        REGEX.clean(&runner.dirs);\n \n         // newer aho_corasick versions throw a deprecation warning\n         let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n@@ -425,8 +221,8 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             spawn_and_wait(build_cmd);\n         }\n     }),\n-    TestCase::new(\"test.portable-simd\", &|runner| {\n-        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo, &runner.dirs));\n+    TestCase::custom(\"test.portable-simd\", &|runner| {\n+        PORTABLE_SIMD.clean(&runner.dirs);\n \n         let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--all-targets\");\n@@ -445,21 +241,22 @@ pub(crate) fn run_tests(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     cg_clif_dylib: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n+    bootstrap_host_compiler: &Compiler,\n+    target_triple: String,\n ) {\n-    let runner = TestRunner::new(dirs.clone(), host_triple.to_string(), target_triple.to_string());\n-\n     if config::get_bool(\"testsuite.no_sysroot\") {\n-        build_sysroot::build_sysroot(\n+        let target_compiler = build_sysroot::build_sysroot(\n             dirs,\n             channel,\n             SysrootKind::None,\n             cg_clif_dylib,\n-            &host_triple,\n-            &target_triple,\n+            bootstrap_host_compiler,\n+            target_triple.clone(),\n         );\n \n+        let runner =\n+            TestRunner::new(dirs.clone(), target_compiler, get_host_triple() == target_triple);\n+\n         BUILD_EXAMPLE_OUT_DIR.ensure_fresh(dirs);\n         runner.run_testsuite(NO_SYSROOT_SUITE);\n     } else {\n@@ -470,111 +267,64 @@ pub(crate) fn run_tests(\n     let run_extended_sysroot = config::get_bool(\"testsuite.extended_sysroot\");\n \n     if run_base_sysroot || run_extended_sysroot {\n-        build_sysroot::build_sysroot(\n+        let target_compiler = build_sysroot::build_sysroot(\n             dirs,\n             channel,\n             sysroot_kind,\n             cg_clif_dylib,\n-            &host_triple,\n-            &target_triple,\n+            bootstrap_host_compiler,\n+            target_triple.clone(),\n         );\n-    }\n \n-    if run_base_sysroot {\n-        runner.run_testsuite(BASE_SYSROOT_SUITE);\n-    } else {\n-        eprintln!(\"[SKIP] base_sysroot tests\");\n-    }\n+        let runner =\n+            TestRunner::new(dirs.clone(), target_compiler, get_host_triple() == target_triple);\n \n-    if run_extended_sysroot {\n-        runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n-    } else {\n-        eprintln!(\"[SKIP] extended_sysroot tests\");\n+        if run_base_sysroot {\n+            runner.run_testsuite(BASE_SYSROOT_SUITE);\n+        } else {\n+            eprintln!(\"[SKIP] base_sysroot tests\");\n+        }\n+\n+        if run_extended_sysroot {\n+            runner.run_testsuite(EXTENDED_SYSROOT_SUITE);\n+        } else {\n+            eprintln!(\"[SKIP] extended_sysroot tests\");\n+        }\n     }\n }\n \n struct TestRunner {\n     is_native: bool,\n     jit_supported: bool,\n     dirs: Dirs,\n-    host_compiler: Compiler,\n     target_compiler: Compiler,\n }\n \n impl TestRunner {\n-    pub fn new(dirs: Dirs, host_triple: String, target_triple: String) -> Self {\n-        let is_native = host_triple == target_triple;\n-        let jit_supported =\n-            target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n-\n-        let rustc_clif =\n-            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n-        let rustdoc_clif =\n-            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n-\n-        let mut rustflags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n-        let mut runner = vec![];\n-\n-        if !is_native {\n-            match target_triple.as_str() {\n-                \"aarch64-unknown-linux-gnu\" => {\n-                    // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-                    rustflags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rustflags);\n-                    runner = vec![\n-                        \"qemu-aarch64\".to_owned(),\n-                        \"-L\".to_owned(),\n-                        \"/usr/aarch64-linux-gnu\".to_owned(),\n-                    ];\n-                }\n-                \"s390x-unknown-linux-gnu\" => {\n-                    // We are cross-compiling for s390x. Use the correct linker and run tests in qemu.\n-                    rustflags = format!(\"-Clinker=s390x-linux-gnu-gcc{}\", rustflags);\n-                    runner = vec![\n-                        \"qemu-s390x\".to_owned(),\n-                        \"-L\".to_owned(),\n-                        \"/usr/s390x-linux-gnu\".to_owned(),\n-                    ];\n-                }\n-                \"x86_64-pc-windows-gnu\" => {\n-                    // We are cross-compiling for Windows. Run tests in wine.\n-                    runner = vec![\"wine\".to_owned()];\n-                }\n-                _ => {\n-                    println!(\"Unknown non-native platform\");\n-                }\n-            }\n+    pub fn new(dirs: Dirs, mut target_compiler: Compiler, is_native: bool) -> Self {\n+        if let Ok(rustflags) = env::var(\"RUSTFLAGS\") {\n+            target_compiler.rustflags.push(' ');\n+            target_compiler.rustflags.push_str(&rustflags);\n+        }\n+        if let Ok(rustdocflags) = env::var(\"RUSTDOCFLAGS\") {\n+            target_compiler.rustdocflags.push(' ');\n+            target_compiler.rustdocflags.push_str(&rustdocflags);\n         }\n \n         // FIXME fix `#[linkage = \"extern_weak\"]` without this\n-        if target_triple.contains(\"darwin\") {\n-            rustflags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rustflags);\n+        if target_compiler.triple.contains(\"darwin\") {\n+            target_compiler.rustflags.push_str(\" -Clink-arg=-undefined -Clink-arg=dynamic_lookup\");\n         }\n \n-        let host_compiler = Compiler {\n-            cargo: get_cargo_path(),\n-            rustc: rustc_clif.clone(),\n-            rustdoc: rustdoc_clif.clone(),\n-            rustflags: String::new(),\n-            rustdocflags: String::new(),\n-            triple: host_triple,\n-            runner: vec![],\n-        };\n-\n-        let target_compiler = Compiler {\n-            cargo: get_cargo_path(),\n-            rustc: rustc_clif,\n-            rustdoc: rustdoc_clif,\n-            rustflags: rustflags.clone(),\n-            rustdocflags: rustflags,\n-            triple: target_triple,\n-            runner,\n-        };\n-\n-        Self { is_native, jit_supported, dirs, host_compiler, target_compiler }\n+        let jit_supported = is_native\n+            && target_compiler.triple.contains(\"x86_64\")\n+            && !target_compiler.triple.contains(\"windows\");\n+\n+        Self { is_native, jit_supported, dirs, target_compiler }\n     }\n \n     pub fn run_testsuite(&self, tests: &[TestCase]) {\n-        for &TestCase { config, func } in tests {\n+        for TestCase { config, cmd } in tests {\n             let (tag, testname) = config.split_once('.').unwrap();\n             let tag = tag.to_uppercase();\n             let is_jit_test = tag == \"JIT\";\n@@ -586,7 +336,47 @@ impl TestRunner {\n                 eprintln!(\"[{tag}] {testname}\");\n             }\n \n-            func(self);\n+            match *cmd {\n+                TestCaseCmd::Custom { func } => func(self),\n+                TestCaseCmd::BuildLib { source, crate_types } => {\n+                    self.run_rustc([source, \"--crate-type\", crate_types]);\n+                }\n+                TestCaseCmd::BuildBinAndRun { source, args } => {\n+                    self.run_rustc([source]);\n+                    self.run_out_command(\n+                        source.split('/').last().unwrap().split('.').next().unwrap(),\n+                        args,\n+                    );\n+                }\n+                TestCaseCmd::JitBin { source, args } => {\n+                    let mut jit_cmd = self.rustc_command([\n+                        \"-Zunstable-options\",\n+                        \"-Cllvm-args=mode=jit\",\n+                        \"-Cprefer-dynamic\",\n+                        source,\n+                        \"--cfg\",\n+                        \"jit\",\n+                    ]);\n+                    if !args.is_empty() {\n+                        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", args);\n+                    }\n+                    spawn_and_wait(jit_cmd);\n+\n+                    eprintln!(\"[JIT-lazy] {testname}\");\n+                    let mut jit_cmd = self.rustc_command([\n+                        \"-Zunstable-options\",\n+                        \"-Cllvm-args=mode=jit-lazy\",\n+                        \"-Cprefer-dynamic\",\n+                        source,\n+                        \"--cfg\",\n+                        \"jit\",\n+                    ]);\n+                    if !args.is_empty() {\n+                        jit_cmd.env(\"CG_CLIF_JIT_ARGS\", args);\n+                    }\n+                    spawn_and_wait(jit_cmd);\n+                }\n+            }\n         }\n     }\n \n@@ -603,6 +393,9 @@ impl TestRunner {\n         cmd.arg(\"--out-dir\");\n         cmd.arg(format!(\"{}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"-Cdebuginfo=2\");\n+        cmd.arg(\"--target\");\n+        cmd.arg(&self.target_compiler.triple);\n+        cmd.arg(\"-Cpanic=abort\");\n         cmd.args(args);\n         cmd\n     }\n@@ -615,10 +408,7 @@ impl TestRunner {\n         spawn_and_wait(self.rustc_command(args));\n     }\n \n-    fn run_out_command<'a, I>(&self, name: &str, args: I)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n+    fn run_out_command<'a>(&self, name: &str, args: &[&str]) {\n         let mut full_cmd = vec![];\n \n         // Prepend the RUN_WRAPPER's\n@@ -630,7 +420,7 @@ impl TestRunner {\n             BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).join(name).to_str().unwrap().to_string(),\n         );\n \n-        for arg in args.into_iter() {\n+        for arg in args {\n             full_cmd.push(arg.to_string());\n         }\n "}, {"sha": "ab98ccc35a58a595e0e0bc3ffc7621194ae7e27d", "filename": "compiler/rustc_codegen_cranelift/build_system/usage.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fusage.txt?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,35 @@\n+The build system of cg_clif.\n+\n+USAGE:\n+    ./y.rs prepare [--out-dir DIR]\n+    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs abi-cafe [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs bench [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+\n+OPTIONS:\n+    --debug\n+            Build cg_clif and the standard library in debug mode rather than release mode.\n+            Warning: An unoptimized cg_clif is very slow.\n+\n+    --sysroot none|clif|llvm\n+            Which sysroot libraries to use:\n+            `none` will not include any standard library in the sysroot.\n+            `clif` will build the standard library using Cranelift.\n+            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n+\n+    --out-dir DIR\n+            Specify the directory in which the download, build and dist directories are stored.\n+            By default this is the working directory.\n+\n+    --no-unstable-features\n+            Some features are not yet ready for production usage. This option will disable these\n+            features. This includes the JIT mode and inline assembly support.\n+\n+REQUIREMENTS:\n+    * Rustup: The build system has a hard coded dependency on rustup to install the right nightly\n+      version and make sure it is used where necessary.\n+    * Git: `./y.rs prepare` uses git for applying patches and on Windows for downloading test repos.\n+    * Curl and tar (non-Windows only): Used by `./y.rs prepare` to download a single commit for\n+      repos. Git will be used to clone the whole repo when using Windows.\n+    * [Hyperfine](https://github.com/sharkdp/hyperfine/): Used for benchmarking with `./y.rs bench`."}, {"sha": "da2a94a0a4ff84a3b307c22213e1813fd03ca55f", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,12 +1,13 @@\n use std::env;\n use std::fs;\n-use std::io::Write;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::{self, Command, Stdio};\n \n use super::path::{Dirs, RelPath};\n-use super::rustc_info::{get_cargo_path, get_host_triple, get_rustc_path, get_rustdoc_path};\n+use super::rustc_info::{get_cargo_path, get_rustc_path, get_rustdoc_path};\n \n+#[derive(Clone, Debug)]\n pub(crate) struct Compiler {\n     pub(crate) cargo: PathBuf,\n     pub(crate) rustc: PathBuf,\n@@ -18,27 +19,47 @@ pub(crate) struct Compiler {\n }\n \n impl Compiler {\n-    pub(crate) fn host() -> Compiler {\n+    pub(crate) fn bootstrap_with_triple(triple: String) -> Compiler {\n         Compiler {\n             cargo: get_cargo_path(),\n             rustc: get_rustc_path(),\n             rustdoc: get_rustdoc_path(),\n             rustflags: String::new(),\n             rustdocflags: String::new(),\n-            triple: get_host_triple(),\n+            triple,\n             runner: vec![],\n         }\n     }\n \n-    pub(crate) fn with_triple(triple: String) -> Compiler {\n-        Compiler {\n-            cargo: get_cargo_path(),\n-            rustc: get_rustc_path(),\n-            rustdoc: get_rustdoc_path(),\n-            rustflags: String::new(),\n-            rustdocflags: String::new(),\n-            triple,\n-            runner: vec![],\n+    pub(crate) fn set_cross_linker_and_runner(&mut self) {\n+        match self.triple.as_str() {\n+            \"aarch64-unknown-linux-gnu\" => {\n+                // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+                self.rustflags += \" -Clinker=aarch64-linux-gnu-gcc\";\n+                self.rustdocflags += \" -Clinker=aarch64-linux-gnu-gcc\";\n+                self.runner = vec![\n+                    \"qemu-aarch64\".to_owned(),\n+                    \"-L\".to_owned(),\n+                    \"/usr/aarch64-linux-gnu\".to_owned(),\n+                ];\n+            }\n+            \"s390x-unknown-linux-gnu\" => {\n+                // We are cross-compiling for s390x. Use the correct linker and run tests in qemu.\n+                self.rustflags += \" -Clinker=s390x-linux-gnu-gcc\";\n+                self.rustdocflags += \" -Clinker=s390x-linux-gnu-gcc\";\n+                self.runner = vec![\n+                    \"qemu-s390x\".to_owned(),\n+                    \"-L\".to_owned(),\n+                    \"/usr/s390x-linux-gnu\".to_owned(),\n+                ];\n+            }\n+            \"x86_64-pc-windows-gnu\" => {\n+                // We are cross-compiling for Windows. Run tests in wine.\n+                self.runner = vec![\"wine\".to_owned()];\n+            }\n+            _ => {\n+                println!(\"Unknown non-native platform\");\n+            }\n         }\n     }\n }\n@@ -65,18 +86,21 @@ impl CargoProject {\n         RelPath::BUILD.join(self.target).to_path(dirs)\n     }\n \n+    #[must_use]\n     fn base_cmd(&self, command: &str, cargo: &Path, dirs: &Dirs) -> Command {\n         let mut cmd = Command::new(cargo);\n \n         cmd.arg(command)\n             .arg(\"--manifest-path\")\n             .arg(self.manifest_path(dirs))\n             .arg(\"--target-dir\")\n-            .arg(self.target_dir(dirs));\n+            .arg(self.target_dir(dirs))\n+            .arg(\"--frozen\");\n \n         cmd\n     }\n \n+    #[must_use]\n     fn build_cmd(&self, command: &str, compiler: &Compiler, dirs: &Dirs) -> Command {\n         let mut cmd = self.base_cmd(command, &compiler.cargo, dirs);\n \n@@ -105,9 +129,8 @@ impl CargoProject {\n         cmd\n     }\n \n-    #[must_use]\n-    pub(crate) fn clean(&self, cargo: &Path, dirs: &Dirs) -> Command {\n-        self.base_cmd(\"clean\", cargo, dirs)\n+    pub(crate) fn clean(&self, dirs: &Dirs) {\n+        let _ = fs::remove_dir_all(self.target_dir(dirs));\n     }\n \n     #[must_use]\n@@ -153,6 +176,23 @@ pub(crate) fn hyperfine_command(\n     bench\n }\n \n+#[must_use]\n+pub(crate) fn git_command<'a>(repo_dir: impl Into<Option<&'a Path>>, cmd: &str) -> Command {\n+    let mut git_cmd = Command::new(\"git\");\n+    git_cmd\n+        .arg(\"-c\")\n+        .arg(\"user.name=Dummy\")\n+        .arg(\"-c\")\n+        .arg(\"user.email=dummy@example.com\")\n+        .arg(\"-c\")\n+        .arg(\"core.autocrlf=false\")\n+        .arg(cmd);\n+    if let Some(repo_dir) = repo_dir.into() {\n+        git_cmd.current_dir(repo_dir);\n+    }\n+    git_cmd\n+}\n+\n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n     let src = src.as_ref();\n@@ -169,6 +209,22 @@ pub(crate) fn spawn_and_wait(mut cmd: Command) {\n     }\n }\n \n+// Based on the retry function in rust's src/ci/shared.sh\n+#[track_caller]\n+pub(crate) fn retry_spawn_and_wait(tries: u64, mut cmd: Command) {\n+    for i in 1..tries + 1 {\n+        if i != 1 {\n+            println!(\"Command failed. Attempt {i}/{tries}:\");\n+        }\n+        if cmd.spawn().unwrap().wait().unwrap().success() {\n+            return;\n+        }\n+        std::thread::sleep(std::time::Duration::from_secs(i * 5));\n+    }\n+    println!(\"The command has failed after {tries} attempts.\");\n+    process::exit(1);\n+}\n+\n #[track_caller]\n pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> String {\n     let mut child = cmd\n@@ -190,6 +246,14 @@ pub(crate) fn spawn_and_wait_with_input(mut cmd: Command, input: String) -> Stri\n     String::from_utf8(output.stdout).unwrap()\n }\n \n+pub(crate) fn remove_dir_if_exists(path: &Path) {\n+    match fs::remove_dir_all(&path) {\n+        Ok(()) => {}\n+        Err(err) if err.kind() == io::ErrorKind::NotFound => {}\n+        Err(err) => panic!(\"Failed to remove {path}: {err}\", path = path.display()),\n+    }\n+}\n+\n pub(crate) fn copy_dir_recursively(from: &Path, to: &Path) {\n     for entry in fs::read_dir(from).unwrap() {\n         let entry = entry.unwrap();"}, {"sha": "cdfc2e143e6748247d056e11488b5adae5ea21f7", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,10 +1,9 @@\n #!/usr/bin/env bash\n set -e\n \n-rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n-rm -rf target/ build/ dist/ perf.data{,.old} y.bin\n-rm -rf download/\n+rm -rf target/ download/ build/ dist/ y.bin y.bin.dSYM y.exe y.pdb\n \n # Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh\n # FIXME remove at some point in the future\n rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/ abi-cafe/\n+rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}"}, {"sha": "d49cc90791a5d5fb01a81bbf7aeb905405681d55", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -44,10 +44,8 @@ aot.issue-72793\n \n testsuite.extended_sysroot\n test.rust-random/rand\n-bench.simple-raytracer\n+test.simple-raytracer\n test.libcore\n test.regex-shootout-regex-dna\n test.regex\n test.portable-simd\n-\n-testsuite.abi-cafe"}, {"sha": "89e2b61c1fc8553be9c7668525c66e97d5fdcd52", "filename": "compiler/rustc_codegen_cranelift/patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=e57962f4f1a5424ca8dc5eaebc4d0d93b7194c22", "patch": "@@ -1,35 +0,0 @@\n-From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 18 Nov 2021 19:28:40 +0100\n-Subject: [PATCH] Disable unsupported tests\n-\n----\n- crates/core_simd/src/elements/int.rs     | 8 ++++++++\n- crates/core_simd/src/elements/uint.rs    | 4 ++++\n- crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n- crates/core_simd/src/vector.rs           | 2 ++\n- crates/core_simd/tests/masks.rs          | 3 ---\n- 5 files changed, 20 insertions(+), 3 deletions(-)\n-\n-diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n-index e8e8f68..7173c24 100644\n---- a/crates/core_simd/src/vector.rs\n-+++ b/crates/core_simd/src/vector.rs\n-@@ -250,6 +250,7 @@ where\n-         unsafe { intrinsics::simd_cast(self) }\n-     }\n- \n-+    /*\n-     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-     /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n-     ///\n-@@ -473,6 +474,7 @@ where\n-             // Cleared \u2622\ufe0f *mut T Zone\n-         }\n-     }\n-+    */\n- }\n- \n- impl<T, const LANES: usize> Copy for Simd<T, LANES>\n--- \n-2.25.1"}, {"sha": "865aa833a5eef4c01754916a1534d54c84ec175f", "filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-sysroot-Disable-not-compiling-tests.patch?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -18,7 +18,7 @@ new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n +++ b/library/core/tests/Cargo.toml\n-@@ -0,0 +1,11 @@\n+@@ -0,0 +1,12 @@\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n@@ -29,6 +29,7 @@ index 0000000..46fd999\n +path = \"lib.rs\"\n +\n +[dependencies]\n-+rand = \"0.7\"\n++rand = { version = \"0.8.5\", default-features = false }\n++rand_xorshift = { version = \"0.3.0\", default-features = false }\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "77345b9a17c6edca7102326001fcef783e74a1c9", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-12-13\"\n+channel = \"nightly-2023-01-20\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "c993430b830b6ebe3d4c1fc919f50fd043f57311", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     env::set_var(\"RUSTDOCFLAGS\", env::var(\"RUSTDOCFLAGS\").unwrap_or(String::new()) + &rustflags);\n \n     // Ensure that the right toolchain is used\n-    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     let args: Vec<_> = match env::args().nth(1).as_deref() {\n         Some(\"jit\") => {"}, {"sha": "c187f54a60e775a0b2a5bca42406390035f6310d", "filename": "compiler/rustc_codegen_cranelift/scripts/rustc-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     }\n \n     // Ensure that the right toolchain is used\n-    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     #[cfg(unix)]\n     Command::new(\"rustc\").args(args).exec();"}, {"sha": "a6528ac41aee08f9f57ae4e396af40c99b239728", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     }\n \n     // Ensure that the right toolchain is used\n-    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     #[cfg(unix)]\n     Command::new(\"rustdoc\").args(args).exec();"}, {"sha": "34e3981b5381f5ceeb7e5df8d6a4f6d94ee87b06", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -17,10 +17,10 @@ case $1 in\n         done\n \n         ./clean_all.sh\n-        ./y.rs prepare\n \n-        (cd build_sysroot && cargo update)\n+        ./y.rs prepare\n \n+        (cd download/sysroot && cargo update && cargo fetch && cp Cargo.lock ../../build_sysroot/)\n         ;;\n     \"commit\")\n         git add rust-toolchain build_sysroot/Cargo.lock"}, {"sha": "a08e80dd19abc74bf93036d1707059325464b86e", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -10,7 +10,7 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n-git am ../patches/*-sysroot-*.patch\n+git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-sysroot-*.patch\n \n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n@@ -25,8 +25,8 @@ index d95b5b7f17f..00b6f0e3635 100644\n +compiler_builtins = { version = \"0.1.66\", features = ['rustc-dep-of-std', 'no-asm'] }\n \n  [dev-dependencies]\n- rand = \"0.7\"\n- rand_xorshift = \"0.2\"\n+ rand = { version = \"0.8.5\", default-features = false, features = [\"alloc\"] }\n+ rand_xorshift = \"0.3.0\"\n EOF\n \n cat > config.toml <<EOF\n@@ -51,7 +51,7 @@ popd\n # FIXME remove once inline asm is fully supported\n export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\"\n \n-export CFG_VIRTUAL_RUST_SOURCE_BASE_DIR=\"$(cd build_sysroot/sysroot_src; pwd)\"\n+export CFG_VIRTUAL_RUST_SOURCE_BASE_DIR=\"$(cd download/sysroot/sysroot_src; pwd)\"\n \n # Allow the testsuite to use llvm tools\n host_triple=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")"}, {"sha": "07c9ae6ee9ff2c1f4340ac0ead9c68879f82ba4e", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -11,7 +11,7 @@ pushd rust\n command -v rg >/dev/null 2>&1 || cargo install ripgrep\n \n rm -r tests/ui/{extern/,unsized-locals/,lto/,linkage*} || true\n-for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" tests/{ui,incremental}); do\n+for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" tests/{codegen-units,ui,incremental}); do\n   rm $test\n done\n \n@@ -32,20 +32,13 @@ rm tests/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort\n # requires compiling with -Cpanic=unwind\n rm -r tests/ui/macros/rfc-2011-nicer-assert-messages/\n rm -r tests/run-make/test-benches\n+rm tests/ui/test-attrs/test-type.rs\n \n # vendor intrinsics\n rm tests/ui/sse2.rs # cpuid not supported, so sse2 not detected\n rm tests/ui/intrinsics/const-eval-select-x86_64.rs # requires x86_64 vendor intrinsics\n rm tests/ui/simd/array-type.rs # \"Index argument for `simd_insert` is not a constant\"\n-rm tests/ui/simd/intrinsic/generic-bitmask-pass.rs # simd_bitmask unimplemented\n-rm tests/ui/simd/intrinsic/generic-as.rs # simd_as unimplemented\n-rm tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs # simd_saturating_add unimplemented\n rm tests/ui/simd/intrinsic/float-math-pass.rs # simd_fcos unimplemented\n-rm tests/ui/simd/intrinsic/generic-gather-pass.rs # simd_gather unimplemented\n-rm tests/ui/simd/intrinsic/generic-select-pass.rs # simd_select_bitmask unimplemented\n-rm tests/ui/simd/issue-85915-simd-ptrs.rs # simd_gather unimplemented\n-rm tests/ui/simd/issue-89193.rs # simd_gather unimplemented\n-rm tests/ui/simd/simd-bitmask.rs # simd_bitmask unimplemented\n \n # exotic linkages\n rm tests/ui/issues/issue-33992.rs # unsupported linkages\n@@ -64,10 +57,7 @@ rm tests/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and near\n rm tests/ui/target-feature/missing-plusminus.rs # error not implemented\n rm tests/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r tests/run-make/emit-named-files # requires full --emit support\n-rm tests/ui/abi/stack-probes.rs # stack probes not yet implemented\n-rm tests/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n rm -r tests/run-make/repr128-dwarf # debuginfo test\n-rm tests/codegen-units/item-collection/asm-sym.rs # requires support for sym in asm!()\n \n # optimization tests\n # ==================\n@@ -88,6 +78,20 @@ rm tests/ui/mir/mir_raw_fat_ptr.rs # same\n rm tests/ui/consts/issue-33537.rs # same\n rm tests/ui/layout/valid_range_oob.rs # different ICE message\n \n+rm tests/ui/consts/issue-miri-1910.rs # different error message\n+rm tests/ui/consts/offset_ub.rs # same\n+rm tests/ui/intrinsics/panic-uninitialized-zeroed.rs # same\n+rm tests/ui/lint/lint-const-item-mutation.rs # same\n+rm tests/ui/pattern/usefulness/doc-hidden-non-exhaustive.rs # same\n+rm tests/ui/suggestions/derive-trait-for-method-call.rs # same\n+rm tests/ui/typeck/issue-46112.rs # same\n+\n+rm tests/ui/proc-macro/crt-static.rs # extra warning about -Cpanic=abort for proc macros\n+rm tests/ui/proc-macro/proc-macro-deprecated-attr.rs # same\n+rm tests/ui/proc-macro/quote-debug.rs # same\n+rm tests/ui/proc-macro/no-missing-docs.rs # same\n+rm tests/ui/rust-2018/proc-macro-crate-in-paths.rs # same\n+\n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended\n # ============================================================\n@@ -102,23 +106,20 @@ rm -r tests/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to b\n # ============\n rm tests/incremental/spike-neg1.rs # errors out for some reason\n rm tests/incremental/spike-neg2.rs # same\n-rm tests/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n-rm tests/ui/mir/ssa-analysis-regression-50041.rs # produces ICE\n-rm tests/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/runtime/out-of-stack.rs # SIGSEGV instead of SIGABRT for some reason (#1301)\n+rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type filed (#1318)\n+rm tests/ui/simd/simd-bitmask.rs # crash\n+\n+rm tests/ui/dyn-star/dyn-star-to-dyn.rs\n+rm tests/ui/dyn-star/dispatch-on-pin-mut.rs\n \n # bugs in the test suite\n # ======================\n rm tests/ui/backtrace.rs # TODO warning\n rm tests/ui/simple_global_asm.rs # TODO add needs-asm-support\n-rm tests/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n-# not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n-rm -r tests/run-make/native-link-modifier-bundle\n rm tests/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n-rm tests/ui/dyn-star/dispatch-on-pin-mut.rs # TODO failed assertion in vtable::get_ptr_and_method_ref\n \n rm tests/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n "}, {"sha": "3c34585d4191e6ef1eaa80b82dd06dc578972e9a", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -7,6 +7,7 @@ mod returning;\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n+use rustc_session::Session;\n use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n@@ -22,7 +23,7 @@ fn clif_sig_from_fn_abi<'tcx>(\n     default_call_conv: CallConv,\n     fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let call_conv = conv_to_call_conv(fn_abi.conv, default_call_conv);\n+    let call_conv = conv_to_call_conv(tcx.sess, fn_abi.conv, default_call_conv);\n \n     let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n \n@@ -33,24 +34,32 @@ fn clif_sig_from_fn_abi<'tcx>(\n     Signature { params, returns, call_conv }\n }\n \n-pub(crate) fn conv_to_call_conv(c: Conv, default_call_conv: CallConv) -> CallConv {\n+pub(crate) fn conv_to_call_conv(sess: &Session, c: Conv, default_call_conv: CallConv) -> CallConv {\n     match c {\n         Conv::Rust | Conv::C => default_call_conv,\n         Conv::RustCold => CallConv::Cold,\n         Conv::X86_64SysV => CallConv::SystemV,\n         Conv::X86_64Win64 => CallConv::WindowsFastcall,\n-        Conv::ArmAapcs\n-        | Conv::CCmseNonSecureCall\n-        | Conv::Msp430Intr\n+\n+        // Should already get a back compat warning\n+        Conv::X86Fastcall | Conv::X86Stdcall | Conv::X86ThisCall | Conv::X86VectorCall => {\n+            default_call_conv\n+        }\n+\n+        Conv::X86Intr => sess.fatal(\"x86-interrupt call conv not yet implemented\"),\n+\n+        Conv::ArmAapcs => sess.fatal(\"aapcs call conv not yet implemented\"),\n+        Conv::CCmseNonSecureCall => {\n+            sess.fatal(\"C-cmse-nonsecure-call call conv is not yet implemented\");\n+        }\n+\n+        Conv::Msp430Intr\n         | Conv::PtxKernel\n-        | Conv::X86Fastcall\n-        | Conv::X86Intr\n-        | Conv::X86Stdcall\n-        | Conv::X86ThisCall\n-        | Conv::X86VectorCall\n         | Conv::AmdGpuKernel\n         | Conv::AvrInterrupt\n-        | Conv::AvrNonBlockingInterrupt => todo!(\"{:?}\", c),\n+        | Conv::AvrNonBlockingInterrupt => {\n+            unreachable!(\"tried to use {c:?} call conv which only exists on an unsupported target\");\n+        }\n     }\n }\n \n@@ -161,6 +170,12 @@ fn make_local_place<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     is_ssa: bool,\n ) -> CPlace<'tcx> {\n+    if layout.is_unsized() {\n+        fx.tcx.sess.span_fatal(\n+            fx.mir.local_decls[local].source_info.span,\n+            \"unsized locals are not yet supported\",\n+        );\n+    }\n     let place = if is_ssa {\n         if let rustc_target::abi::Abi::ScalarPair(_, _) = layout.abi {\n             CPlace::new_var_pair(fx, local, layout)"}, {"sha": "dffb2ed8f4f392544f5d551d1ea7105c853e55db", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -113,6 +113,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     };\n \n     tcx.sess.time(\"codegen clif ir\", || codegen_fn_body(&mut fx, start_block));\n+    fx.bcx.seal_all_blocks();\n+    fx.bcx.finalize();\n \n     // Recover all necessary data from fx, before accessing func will prevent future access to it.\n     let symbol_name = fx.symbol_name;\n@@ -303,6 +305,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n         let source_info = bb_data.terminator().source_info;\n         fx.set_debug_loc(source_info);\n \n+        let _print_guard =\n+            crate::PrintOnPanic(|| format!(\"terminator {:?}\", bb_data.terminator().kind));\n+\n         match &bb_data.terminator().kind {\n             TerminatorKind::Goto { target } => {\n                 if let TerminatorKind::Return = fx.mir[*target].terminator().kind {\n@@ -464,7 +469,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                     *destination,\n                 );\n             }\n-            TerminatorKind::Resume | TerminatorKind::Abort => {\n+            TerminatorKind::Abort => {\n+                codegen_panic_cannot_unwind(fx, source_info);\n+            }\n+            TerminatorKind::Resume => {\n                 // FIXME implement unwinding\n                 fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n             }\n@@ -487,9 +495,6 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             }\n         };\n     }\n-\n-    fx.bcx.seal_all_blocks();\n-    fx.bcx.finalize();\n }\n \n fn codegen_stmt<'tcx>(\n@@ -789,6 +794,7 @@ fn codegen_stmt<'tcx>(\n         StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)\n         | StatementKind::Deinit(_)\n+        | StatementKind::ConstEvalCounter\n         | StatementKind::Nop\n         | StatementKind::FakeRead(..)\n         | StatementKind::Retag { .. }\n@@ -932,7 +938,28 @@ pub(crate) fn codegen_panic<'tcx>(\n     codegen_panic_inner(fx, rustc_hir::LangItem::Panic, &args, source_info.span);\n }\n \n-pub(crate) fn codegen_panic_inner<'tcx>(\n+pub(crate) fn codegen_panic_nounwind<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    msg_str: &str,\n+    source_info: mir::SourceInfo,\n+) {\n+    let msg_ptr = fx.anonymous_str(msg_str);\n+    let msg_len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(msg_str.len()).unwrap());\n+    let args = [msg_ptr, msg_len];\n+\n+    codegen_panic_inner(fx, rustc_hir::LangItem::PanicNounwind, &args, source_info.span);\n+}\n+\n+pub(crate) fn codegen_panic_cannot_unwind<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    source_info: mir::SourceInfo,\n+) {\n+    let args = [];\n+\n+    codegen_panic_inner(fx, rustc_hir::LangItem::PanicCannotUnwind, &args, source_info.span);\n+}\n+\n+fn codegen_panic_inner<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     lang_item: rustc_hir::LangItem,\n     args: &[Value],\n@@ -949,11 +976,7 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n \n     fx.lib_call(\n         &*symbol_name,\n-        vec![\n-            AbiParam::new(fx.pointer_type),\n-            AbiParam::new(fx.pointer_type),\n-            AbiParam::new(fx.pointer_type),\n-        ],\n+        args.iter().map(|&arg| AbiParam::new(fx.bcx.func.dfg.value_type(arg))).collect(),\n         vec![],\n         args,\n     );"}, {"sha": "f41af3a9e636631949be8a616b799a3dfc6644c8", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -35,7 +35,8 @@ pub(crate) fn scalar_to_clif_type(tcx: TyCtxt<'_>, scalar: Scalar) -> Type {\n         },\n         Primitive::F32 => types::F32,\n         Primitive::F64 => types::F64,\n-        Primitive::Pointer => pointer_ty(tcx),\n+        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+        Primitive::Pointer(_) => pointer_ty(tcx),\n     }\n }\n \n@@ -167,6 +168,15 @@ pub(crate) fn codegen_icmp_imm(\n     }\n }\n \n+pub(crate) fn codegen_bitcast(fx: &mut FunctionCx<'_, '_, '_>, dst_ty: Type, val: Value) -> Value {\n+    let mut flags = MemFlags::new();\n+    flags.set_endianness(match fx.tcx.data_layout.endian {\n+        rustc_target::abi::Endian::Big => cranelift_codegen::ir::Endianness::Big,\n+        rustc_target::abi::Endian::Little => cranelift_codegen::ir::Endianness::Little,\n+    });\n+    fx.bcx.ins().bitcast(dst_ty, flags, val)\n+}\n+\n pub(crate) fn type_zero_value(bcx: &mut FunctionBuilder<'_>, ty: Type) -> Value {\n     if ty == types::I128 {\n         let zero = bcx.ins().iconst(types::I64, 0);"}, {"sha": "49c4f1aaaefc69a9e52a68792f55f76b68471281", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -530,6 +530,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                         | StatementKind::Retag(_, _)\n                         | StatementKind::AscribeUserType(_, _)\n                         | StatementKind::Coverage(_)\n+                        | StatementKind::ConstEvalCounter\n                         | StatementKind::Nop => {}\n                     }\n                 }"}, {"sha": "6c4efca442448a700d77e946edb926ab02e8ced9", "filename": "compiler/rustc_codegen_cranelift/src/cranelift_native.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,248 @@\n+// Vendored from https://github.com/bytecodealliance/wasmtime/blob/b58a197d33f044193c3d608010f5e6ec394ac07e/cranelift/native/src/lib.rs\n+// which is licensed as\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+// unlike rustc_codegen_cranelift itself. Also applies a small change to remove #![cfg_attr] that\n+// rust's CI complains about and to fix formatting to match rustc.\n+// FIXME revert back to the external crate with Cranelift 0.93\n+#![allow(warnings)]\n+\n+//! Performs autodetection of the host for the purposes of running\n+//! Cranelift to generate code to run on the same machine.\n+\n+#![deny(missing_docs, trivial_numeric_casts, unused_extern_crates, unstable_features)]\n+#![warn(unused_import_braces)]\n+\n+use cranelift_codegen::isa;\n+use target_lexicon::Triple;\n+\n+/// Return an `isa` builder configured for the current host\n+/// machine, or `Err(())` if the host machine is not supported\n+/// in the current configuration.\n+pub fn builder() -> Result<isa::Builder, &'static str> {\n+    builder_with_options(true)\n+}\n+\n+/// Return an `isa` builder configured for the current host\n+/// machine, or `Err(())` if the host machine is not supported\n+/// in the current configuration.\n+///\n+/// Selects the given backend variant specifically; this is\n+/// useful when more than oen backend exists for a given target\n+/// (e.g., on x86-64).\n+pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {\n+    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {\n+        isa::LookupError::SupportDisabled => \"support for architecture disabled at compile time\",\n+        isa::LookupError::Unsupported => \"unsupported architecture\",\n+    })?;\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !std::is_x86_feature_detected!(\"sse2\") {\n+            return Err(\"x86 support requires SSE2\");\n+        }\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        // These are temporarily enabled by default (see #3810 for\n+        // more) so that a default-constructed `Flags` can work with\n+        // default Wasmtime features. Otherwise, the user must\n+        // explicitly use native flags or turn these on when on x86-64\n+        // platforms to avoid a configuration panic. In order for the\n+        // \"enable if detected\" logic below to work, we must turn them\n+        // *off* (differing from the default) and then re-enable below\n+        // if present.\n+        isa_builder.set(\"has_sse3\", \"false\").unwrap();\n+        isa_builder.set(\"has_ssse3\", \"false\").unwrap();\n+        isa_builder.set(\"has_sse41\", \"false\").unwrap();\n+        isa_builder.set(\"has_sse42\", \"false\").unwrap();\n+\n+        if std::is_x86_feature_detected!(\"sse3\") {\n+            isa_builder.enable(\"has_sse3\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"ssse3\") {\n+            isa_builder.enable(\"has_ssse3\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"sse4.1\") {\n+            isa_builder.enable(\"has_sse41\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"sse4.2\") {\n+            isa_builder.enable(\"has_sse42\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"popcnt\") {\n+            isa_builder.enable(\"has_popcnt\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx\") {\n+            isa_builder.enable(\"has_avx\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx2\") {\n+            isa_builder.enable(\"has_avx2\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"fma\") {\n+            isa_builder.enable(\"has_fma\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"bmi1\") {\n+            isa_builder.enable(\"has_bmi1\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"bmi2\") {\n+            isa_builder.enable(\"has_bmi2\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512bitalg\") {\n+            isa_builder.enable(\"has_avx512bitalg\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512dq\") {\n+            isa_builder.enable(\"has_avx512dq\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512f\") {\n+            isa_builder.enable(\"has_avx512f\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512vl\") {\n+            isa_builder.enable(\"has_avx512vl\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"avx512vbmi\") {\n+            isa_builder.enable(\"has_avx512vbmi\").unwrap();\n+        }\n+        if std::is_x86_feature_detected!(\"lzcnt\") {\n+            isa_builder.enable(\"has_lzcnt\").unwrap();\n+        }\n+    }\n+\n+    #[cfg(target_arch = \"aarch64\")]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        if std::arch::is_aarch64_feature_detected!(\"lse\") {\n+            isa_builder.enable(\"has_lse\").unwrap();\n+        }\n+\n+        if std::arch::is_aarch64_feature_detected!(\"paca\") {\n+            isa_builder.enable(\"has_pauth\").unwrap();\n+        }\n+\n+        if cfg!(target_os = \"macos\") {\n+            // Pointer authentication is always available on Apple Silicon.\n+            isa_builder.enable(\"sign_return_address\").unwrap();\n+            // macOS enforces the use of the B key for return addresses.\n+            isa_builder.enable(\"sign_return_address_with_bkey\").unwrap();\n+        }\n+    }\n+\n+    // There is no is_s390x_feature_detected macro yet, so for now\n+    // we use getauxval from the libc crate directly.\n+    #[cfg(all(target_arch = \"s390x\", target_os = \"linux\"))]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n+        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;\n+        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {\n+            isa_builder.enable(\"has_vxrs_ext2\").unwrap();\n+            // There is no separate HWCAP bit for mie2, so assume\n+            // that any machine with vxrs_ext2 also has mie2.\n+            isa_builder.enable(\"has_mie2\").unwrap();\n+        }\n+    }\n+\n+    // `is_riscv_feature_detected` is nightly only for now, use\n+    // getauxval from the libc crate directly as a temporary measure.\n+    #[cfg(all(target_arch = \"riscv64\", target_os = \"linux\"))]\n+    {\n+        use cranelift_codegen::settings::Configurable;\n+\n+        if !infer_native_flags {\n+            return Ok(isa_builder);\n+        }\n+\n+        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n+\n+        const HWCAP_RISCV_EXT_A: libc::c_ulong = 1 << (b'a' - b'a');\n+        const HWCAP_RISCV_EXT_C: libc::c_ulong = 1 << (b'c' - b'a');\n+        const HWCAP_RISCV_EXT_D: libc::c_ulong = 1 << (b'd' - b'a');\n+        const HWCAP_RISCV_EXT_F: libc::c_ulong = 1 << (b'f' - b'a');\n+        const HWCAP_RISCV_EXT_M: libc::c_ulong = 1 << (b'm' - b'a');\n+        const HWCAP_RISCV_EXT_V: libc::c_ulong = 1 << (b'v' - b'a');\n+\n+        if (v & HWCAP_RISCV_EXT_A) != 0 {\n+            isa_builder.enable(\"has_a\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_C) != 0 {\n+            isa_builder.enable(\"has_c\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_D) != 0 {\n+            isa_builder.enable(\"has_d\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_F) != 0 {\n+            isa_builder.enable(\"has_f\").unwrap();\n+\n+            // TODO: There doesn't seem to be a bit associated with this extension\n+            // rust enables it with the `f` extension:\n+            // https://github.com/rust-lang/stdarch/blob/790411f93c4b5eada3c23abb4c9a063fb0b24d99/crates/std_detect/src/detect/os/linux/riscv.rs#L43\n+            isa_builder.enable(\"has_zicsr\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_M) != 0 {\n+            isa_builder.enable(\"has_m\").unwrap();\n+        }\n+\n+        if (v & HWCAP_RISCV_EXT_V) != 0 {\n+            isa_builder.enable(\"has_v\").unwrap();\n+        }\n+\n+        // TODO: ZiFencei does not have a bit associated with it\n+        // TODO: Zbkb does not have a bit associated with it\n+    }\n+\n+    // squelch warnings about unused mut/variables on some platforms.\n+    drop(&mut isa_builder);\n+    drop(infer_native_flags);\n+\n+    Ok(isa_builder)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::builder;\n+    use cranelift_codegen::isa::CallConv;\n+    use cranelift_codegen::settings;\n+\n+    #[test]\n+    fn test() {\n+        if let Ok(isa_builder) = builder() {\n+            let flag_builder = settings::builder();\n+            let isa = isa_builder.finish(settings::Flags::new(flag_builder)).unwrap();\n+\n+            if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n+                assert_eq!(isa.default_call_conv(), CallConv::AppleAarch64);\n+            } else if cfg!(any(unix, target_os = \"nebulet\")) {\n+                assert_eq!(isa.default_call_conv(), CallConv::SystemV);\n+            } else if cfg!(windows) {\n+                assert_eq!(isa.default_call_conv(), CallConv::WindowsFastcall);\n+            }\n+\n+            if cfg!(target_pointer_width = \"64\") {\n+                assert_eq!(isa.pointer_bits(), 64);\n+            } else if cfg!(target_pointer_width = \"32\") {\n+                assert_eq!(isa.pointer_bits(), 32);\n+            } else if cfg!(target_pointer_width = \"16\") {\n+                assert_eq!(isa.pointer_bits(), 16);\n+            }\n+        }\n+    }\n+}\n+\n+/// Version number of this crate.\n+pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");"}, {"sha": "3a7421d8b30d843354e3462d1fec296a7f957035", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -20,6 +20,14 @@ use indexmap::IndexSet;\n pub(crate) use emit::{DebugReloc, DebugRelocName};\n pub(crate) use unwind::UnwindContext;\n \n+pub(crate) fn producer() -> String {\n+    format!(\n+        \"cg_clif (rustc {}, cranelift {})\",\n+        rustc_interface::util::rustc_version_str().unwrap_or(\"unknown version\"),\n+        cranelift_codegen::VERSION,\n+    )\n+}\n+\n pub(crate) struct DebugContext {\n     endian: RunTimeEndian,\n \n@@ -57,11 +65,7 @@ impl DebugContext {\n \n         let mut dwarf = DwarfUnit::new(encoding);\n \n-        let producer = format!(\n-            \"cg_clif (rustc {}, cranelift {})\",\n-            rustc_interface::util::rustc_version_str().unwrap_or(\"unknown version\"),\n-            cranelift_codegen::VERSION,\n-        );\n+        let producer = producer();\n         let comp_dir = tcx\n             .sess\n             .opts"}, {"sha": "d4494a9e45de49981df3dcf679809e225132d054", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -108,6 +108,8 @@ impl OngoingCodegen {\n \n         self.concurrency_limiter.finished();\n \n+        sess.abort_if_errors();\n+\n         (\n             CodegenResults {\n                 modules,\n@@ -169,10 +171,22 @@ fn emit_cgu(\n fn emit_module(\n     output_filenames: &OutputFilenames,\n     prof: &SelfProfilerRef,\n-    object: cranelift_object::object::write::Object<'_>,\n+    mut object: cranelift_object::object::write::Object<'_>,\n     kind: ModuleKind,\n     name: String,\n ) -> Result<CompiledModule, String> {\n+    if object.format() == cranelift_object::object::BinaryFormat::Elf {\n+        let comment_section = object.add_section(\n+            Vec::new(),\n+            b\".comment\".to_vec(),\n+            cranelift_object::object::SectionKind::OtherString,\n+        );\n+        let mut producer = vec![0];\n+        producer.extend(crate::debuginfo::producer().as_bytes());\n+        producer.push(0);\n+        object.set_section_data(comment_section, producer, 1);\n+    }\n+\n     let tmp_file = output_filenames.temp_path(OutputType::Object, Some(&name));\n     let mut file = match File::create(&tmp_file) {\n         Ok(file) => file,\n@@ -399,8 +413,6 @@ pub(crate) fn run_aot(\n             .collect::<Vec<_>>()\n     });\n \n-    tcx.sess.abort_if_errors();\n-\n     let mut allocator_module = make_module(tcx.sess, &backend_config, \"allocator_shim\".to_string());\n     let mut allocator_unwind_context = UnwindContext::new(allocator_module.isa(), true);\n     let created_alloc_shim ="}, {"sha": "d2ae6978ca2a8ee84e63410dd0d6d6aa1985461b", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -33,8 +33,8 @@ pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n \n                 // cast float to int\n                 let a_lane = match lane_ty {\n-                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n-                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    types::F32 => codegen_bitcast(fx, types::I32, a_lane),\n+                    types::F64 => codegen_bitcast(fx, types::I64, a_lane),\n                     _ => a_lane,\n                 };\n "}, {"sha": "d561cf139b6c9bca3ac97f0d985f006383916322", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -21,6 +21,7 @@ mod simd;\n pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n+use rustc_middle::ty::layout::HasParamEnv;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -200,7 +201,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n     let mut res = fx.bcx.ins().bmask(int_ty, val);\n \n     if ty.is_float() {\n-        res = fx.bcx.ins().bitcast(ty, res);\n+        res = codegen_bitcast(fx, ty, res);\n     }\n \n     res\n@@ -240,10 +241,9 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             substs,\n             args,\n             destination,\n+            target,\n             source_info.span,\n         );\n-        let ret_block = fx.get_block(target);\n-        fx.bcx.ins().jump(ret_block, &[]);\n     } else if codegen_float_intrinsic_call(fx, intrinsic, args, destination) {\n         let ret_block = fx.get_block(target);\n         fx.bcx.ins().jump(ret_block, &[]);\n@@ -650,7 +650,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let layout = fx.layout_of(substs.type_at(0));\n             if layout.abi.is_uninhabited() {\n                 with_no_trimmed_paths!({\n-                    crate::base::codegen_panic(\n+                    crate::base::codegen_panic_nounwind(\n                         fx,\n                         &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n                         source_info,\n@@ -659,9 +659,11 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == sym::assert_zero_valid && !fx.tcx.permits_zero_init(layout) {\n+            if intrinsic == sym::assert_zero_valid\n+                && !fx.tcx.permits_zero_init(fx.param_env().and(layout))\n+            {\n                 with_no_trimmed_paths!({\n-                    crate::base::codegen_panic(\n+                    crate::base::codegen_panic_nounwind(\n                         fx,\n                         &format!(\n                             \"attempted to zero-initialize type `{}`, which is invalid\",\n@@ -674,10 +676,10 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             }\n \n             if intrinsic == sym::assert_mem_uninitialized_valid\n-                && !fx.tcx.permits_uninit_init(layout)\n+                && !fx.tcx.permits_uninit_init(fx.param_env().and(layout))\n             {\n                 with_no_trimmed_paths!({\n-                    crate::base::codegen_panic(\n+                    crate::base::codegen_panic_nounwind(\n                         fx,\n                         &format!(\n                             \"attempted to leave type `{}` uninitialized, which is invalid\","}, {"sha": "b33eb29754ab70e3fab43eeef4109e6962f99683", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 115, "deletions": 7, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -24,6 +24,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     _substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n+    target: BasicBlock,\n     span: Span,\n ) {\n     match intrinsic {\n@@ -277,16 +278,15 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             } else {\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n                 let trap_block = fx.bcx.create_block();\n-                let dummy_block = fx.bcx.create_block();\n                 let true_ = fx.bcx.ins().iconst(types::I8, 1);\n                 fx.bcx.ins().brnz(true_, trap_block, &[]);\n-                fx.bcx.ins().jump(dummy_block, &[]);\n+                let ret_block = fx.get_block(target);\n+                fx.bcx.ins().jump(ret_block, &[]);\n                 fx.bcx.switch_to_block(trap_block);\n                 crate::trap::trap_unimplemented(\n                     fx,\n                     \"Index argument for `simd_extract` is not a constant\",\n                 );\n-                fx.bcx.switch_to_block(dummy_block);\n                 return;\n             };\n \n@@ -770,11 +770,119 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             });\n         }\n \n-        // simd_arith_offset\n-        // simd_scatter\n-        // simd_gather\n+        sym::simd_expose_addr | sym::simd_from_exposed_addr | sym::simd_cast_ptr => {\n+            intrinsic_args!(fx, args => (arg); intrinsic);\n+            ret.write_cvalue_transmute(fx, arg);\n+        }\n+\n+        sym::simd_arith_offset => {\n+            intrinsic_args!(fx, args => (ptr, offset); intrinsic);\n+\n+            let (lane_count, ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let pointee_ty = ptr_lane_ty.builtin_deref(true).unwrap().ty;\n+            let pointee_size = fx.layout_of(pointee_ty).size.bytes();\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n+            assert_eq!(lane_count, ret_lane_count);\n+\n+            for lane_idx in 0..lane_count {\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let offset_lane = offset.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let ptr_diff = if pointee_size != 1 {\n+                    fx.bcx.ins().imul_imm(offset_lane, pointee_size as i64)\n+                } else {\n+                    offset_lane\n+                };\n+                let res_lane = fx.bcx.ins().iadd(ptr_lane, ptr_diff);\n+                let res_lane = CValue::by_val(res_lane, ret_lane_layout);\n+\n+                ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n+            }\n+        }\n+\n+        sym::simd_gather => {\n+            intrinsic_args!(fx, args => (val, ptr, mask); intrinsic);\n+\n+            let (val_lane_count, val_lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ptr_lane_count, _ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let (mask_lane_count, _mask_lane_ty) = mask.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ret_lane_count, ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+            assert_eq!(val_lane_count, ptr_lane_count);\n+            assert_eq!(val_lane_count, mask_lane_count);\n+            assert_eq!(val_lane_count, ret_lane_count);\n+\n+            let lane_clif_ty = fx.clif_type(val_lane_ty).unwrap();\n+            let ret_lane_layout = fx.layout_of(ret_lane_ty);\n+\n+            for lane_idx in 0..ptr_lane_count {\n+                let val_lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let mask_lane = mask.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let if_enabled = fx.bcx.create_block();\n+                let if_disabled = fx.bcx.create_block();\n+                let next = fx.bcx.create_block();\n+                let res_lane = fx.bcx.append_block_param(next, lane_clif_ty);\n+\n+                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n+                fx.bcx.ins().jump(if_disabled, &[]);\n+                fx.bcx.seal_block(if_enabled);\n+                fx.bcx.seal_block(if_disabled);\n+\n+                fx.bcx.switch_to_block(if_enabled);\n+                let res = fx.bcx.ins().load(lane_clif_ty, MemFlags::trusted(), ptr_lane, 0);\n+                fx.bcx.ins().jump(next, &[res]);\n+\n+                fx.bcx.switch_to_block(if_disabled);\n+                fx.bcx.ins().jump(next, &[val_lane]);\n+\n+                fx.bcx.seal_block(next);\n+                fx.bcx.switch_to_block(next);\n+\n+                fx.bcx.ins().nop();\n+\n+                ret.place_lane(fx, lane_idx)\n+                    .write_cvalue(fx, CValue::by_val(res_lane, ret_lane_layout));\n+            }\n+        }\n+\n+        sym::simd_scatter => {\n+            intrinsic_args!(fx, args => (val, ptr, mask); intrinsic);\n+\n+            let (val_lane_count, _val_lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n+            let (ptr_lane_count, _ptr_lane_ty) = ptr.layout().ty.simd_size_and_type(fx.tcx);\n+            let (mask_lane_count, _mask_lane_ty) = mask.layout().ty.simd_size_and_type(fx.tcx);\n+            assert_eq!(val_lane_count, ptr_lane_count);\n+            assert_eq!(val_lane_count, mask_lane_count);\n+\n+            for lane_idx in 0..ptr_lane_count {\n+                let val_lane = val.value_lane(fx, lane_idx).load_scalar(fx);\n+                let ptr_lane = ptr.value_lane(fx, lane_idx).load_scalar(fx);\n+                let mask_lane = mask.value_lane(fx, lane_idx).load_scalar(fx);\n+\n+                let if_enabled = fx.bcx.create_block();\n+                let next = fx.bcx.create_block();\n+\n+                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n+                fx.bcx.ins().jump(next, &[]);\n+                fx.bcx.seal_block(if_enabled);\n+\n+                fx.bcx.switch_to_block(if_enabled);\n+                fx.bcx.ins().store(MemFlags::trusted(), val_lane, ptr_lane, 0);\n+                fx.bcx.ins().jump(next, &[]);\n+\n+                fx.bcx.seal_block(next);\n+                fx.bcx.switch_to_block(next);\n+            }\n+        }\n+\n         _ => {\n-            fx.tcx.sess.span_fatal(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+            fx.tcx.sess.span_err(span, &format!(\"Unknown SIMD intrinsic {}\", intrinsic));\n+            // Prevent verifier error\n+            fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n         }\n     }\n+    let ret_block = fx.get_block(target);\n+    fx.bcx.ins().jump(ret_block, &[]);\n }"}, {"sha": "d3868730557b7e1e4da40a9f684e78be375dcd49", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -57,6 +57,8 @@ mod compiler_builtins;\n mod concurrency_limiter;\n mod config;\n mod constant;\n+// FIXME revert back to the external crate with Cranelift 0.93\n+mod cranelift_native;\n mod debuginfo;\n mod discriminant;\n mod driver;\n@@ -278,12 +280,14 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n-    if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n+    if let target_lexicon::Architecture::Aarch64(_) | target_lexicon::Architecture::X86_64 =\n+        target_triple.architecture\n+    {\n         // Windows depends on stack probes to grow the committed part of the stack\n         flags_builder.enable(\"enable_probestack\").unwrap();\n         flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n     } else {\n-        // __cranelift_probestack is not provided and inline stack probes are only supported on x86_64\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on AArch64 and x86_64\n         flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n     }\n "}, {"sha": "3e3b685713427ce13bb571354b00316c4d02943c", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         is_main_fn: bool,\n         sigpipe: u8,\n     ) {\n-        let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n+        let main_ret_ty = tcx.fn_sig(rust_main_def_id).no_bound_vars().unwrap().output();\n         // Given that `main()` has no arguments,\n         // then its return type cannot have\n         // late-bound regions, since late-bound\n@@ -64,13 +64,20 @@ pub(crate) fn maybe_create_entry_wrapper(\n             ],\n             returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: crate::conv_to_call_conv(\n+                tcx.sess,\n                 tcx.sess.target.options.entry_abi,\n                 m.target_config().default_call_conv,\n             ),\n         };\n \n         let entry_name = tcx.sess.target.options.entry_name.as_ref();\n-        let cmain_func_id = m.declare_function(entry_name, Linkage::Export, &cmain_sig).unwrap();\n+        let cmain_func_id = match m.declare_function(entry_name, Linkage::Export, &cmain_sig) {\n+            Ok(func_id) => func_id,\n+            Err(err) => {\n+                tcx.sess\n+                    .fatal(&format!(\"entry symbol `{entry_name}` declared multiple times: {err}\"));\n+            }\n+        };\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n@@ -162,7 +169,11 @@ pub(crate) fn maybe_create_entry_wrapper(\n             bcx.seal_all_blocks();\n             bcx.finalize();\n         }\n-        m.define_function(cmain_func_id, &mut ctx).unwrap();\n+\n+        if let Err(err) = m.define_function(cmain_func_id, &mut ctx) {\n+            tcx.sess.fatal(&format!(\"entry symbol `{entry_name}` defined multiple times: {err}\"));\n+        }\n+\n         unwind_context.add_function(cmain_func_id, &ctx, m.isa());\n     }\n }"}, {"sha": "26327dca299b930da6a973b0683915c4634c78ae", "filename": "compiler/rustc_codegen_cranelift/src/optimize/peephole.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fpeephole.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -7,7 +7,7 @@ use cranelift_frontend::FunctionBuilder;\n /// otherwise return the given value and false.\n pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n     if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-        match bcx.func.dfg[arg_inst] {\n+        match bcx.func.dfg.insts[arg_inst] {\n             // This is the lowering of `Rvalue::Not`\n             InstructionData::IntCompareImm {\n                 opcode: Opcode::IcmpImm,\n@@ -34,7 +34,7 @@ pub(crate) fn maybe_known_branch_taken(\n         return None;\n     };\n \n-    match bcx.func.dfg[arg_inst] {\n+    match bcx.func.dfg.insts[arg_inst] {\n         InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)"}, {"sha": "fa06d6c3ba7f3a2a27b9f14b73d8862cfac75d87", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -514,8 +514,8 @@ impl<'tcx> CPlace<'tcx> {\n                 (types::I32, types::F32)\n                 | (types::F32, types::I32)\n                 | (types::I64, types::F64)\n-                | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n-                _ if src_ty.is_vector() && dst_ty.is_vector() => fx.bcx.ins().bitcast(dst_ty, data),\n+                | (types::F64, types::I64) => codegen_bitcast(fx, dst_ty, data),\n+                _ if src_ty.is_vector() && dst_ty.is_vector() => codegen_bitcast(fx, dst_ty, data),\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {"}, {"sha": "fd825d02e355c0bfd3f58a6a8e99a33806ab33be", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,7 +3,7 @@\n # This block is ignored by rustc\n set -e\n echo \"[BUILD] y.rs\" 1>&2\n-rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021\n+rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021 -Cpanic=abort\n exec ${0/.rs/.bin} $@\n */\n "}, {"sha": "e88c12716ecd3d240da161bd05e7c7900067a39b", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         bx.range_metadata(load, vr);\n                     }\n                 }\n-                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n+                abi::Pointer(_) if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}"}, {"sha": "c939da9cec3c21346be0ed6b5db214830bb858b1", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -211,7 +211,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {"}, {"sha": "dc41cb761b59c44b9e60d2567d3b5b5b276a315f", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -322,13 +322,16 @@ pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: ConstAl\n             )\n             .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n+\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n+\n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            abi::Scalar::Initialized { value: Primitive::Pointer, valid_range: WrappingRange::full(dl.pointer_size) },\n-            cx.type_i8p(),\n+            abi::Scalar::Initialized { value: Primitive::Pointer(address_space), valid_range: WrappingRange::full(dl.pointer_size) },\n+            cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "1326af670cde4e4cc78f3eb1e48eabb79eaf39bb", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -253,7 +253,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, false) => cx.type_from_unsigned_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee =\n                     if let Some(pointee) = self.pointee_info_at(cx, offset) {\n@@ -262,7 +262,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                     else {\n                         cx.type_i8()\n                     };\n-                cx.type_ptr_to(pointee)\n+                cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }\n     }"}, {"sha": "d9f8170a3cffa0617172e93f5d0d5d4a0038efdd", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -849,14 +849,16 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n /// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n /// the equivalent integer type.\n fn llvm_asm_scalar_type<'ll>(cx: &CodegenCx<'ll, '_>, scalar: Scalar) -> &'ll Type {\n+    let dl = &cx.tcx.data_layout;\n     match scalar.primitive() {\n         Primitive::Int(Integer::I8, _) => cx.type_i8(),\n         Primitive::Int(Integer::I16, _) => cx.type_i16(),\n         Primitive::Int(Integer::I32, _) => cx.type_i32(),\n         Primitive::Int(Integer::I64, _) => cx.type_i64(),\n         Primitive::F32 => cx.type_f32(),\n         Primitive::F64 => cx.type_f64(),\n-        Primitive::Pointer => cx.type_isize(),\n+        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+        Primitive::Pointer(_) => cx.type_from_integer(dl.ptr_sized_integer()),\n         _ => unreachable!(),\n     }\n }\n@@ -868,6 +870,7 @@ fn llvm_fixup_input<'ll, 'tcx>(\n     reg: InlineAsmRegClass,\n     layout: &TyAndLayout<'tcx>,\n ) -> &'ll Value {\n+    let dl = &bx.tcx.data_layout;\n     match (reg, layout.abi) {\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n             if let Primitive::Int(Integer::I8, _) = s.primitive() {\n@@ -881,8 +884,10 @@ fn llvm_fixup_input<'ll, 'tcx>(\n             let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n             let count = 16 / layout.size.bytes();\n             let vec_ty = bx.cx.type_vector(elem_ty, count);\n-            if let Primitive::Pointer = s.primitive() {\n-                value = bx.ptrtoint(value, bx.cx.type_isize());\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            if let Primitive::Pointer(_) = s.primitive() {\n+                let t = bx.type_from_integer(dl.ptr_sized_integer());\n+                value = bx.ptrtoint(value, t);\n             }\n             bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n         }\n@@ -958,7 +963,7 @@ fn llvm_fixup_output<'ll, 'tcx>(\n         }\n         (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n             value = bx.extract_element(value, bx.const_i32(0));\n-            if let Primitive::Pointer = s.primitive() {\n+            if let Primitive::Pointer(_) = s.primitive() {\n                 value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n             }\n             value"}, {"sha": "54ac7a46cf2f331681ffb9f2e9b0e90034b94dcd", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -441,7 +441,7 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         // the WebAssembly specification, which has this feature. This won't be\n         // needed when LLVM enables this `multivalue` feature by default.\n         if !cx.tcx.is_closure(instance.def_id()) {\n-            let abi = cx.tcx.fn_sig(instance.def_id()).abi();\n+            let abi = cx.tcx.fn_sig(instance.def_id()).skip_binder().abi();\n             if abi == Abi::Wasm {\n                 function_features.push(\"+multivalue\".to_string());\n             }"}, {"sha": "58ca87524deb69d891cc1dbfe8c953de5cdc4b95", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -15,8 +15,8 @@ use crate::errors::{\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{\n-    get_native_object_symbols, ArArchiveBuilder, ArchiveBuildFailure, ArchiveBuilder,\n-    ArchiveBuilderBuilder, UnknownArchiveKind,\n+    get_native_object_symbols, try_extract_macho_fat_archive, ArArchiveBuilder,\n+    ArchiveBuildFailure, ArchiveBuilder, ArchiveBuilderBuilder, UnknownArchiveKind,\n };\n \n use rustc_session::cstore::DllImport;\n@@ -66,15 +66,21 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n         archive: &Path,\n         skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let archive_ro = match ArchiveRO::open(archive) {\n+        let mut archive = archive.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive) = try_extract_macho_fat_archive(&self.sess, &archive)? {\n+                archive = new_archive\n+            }\n+        }\n+        let archive_ro = match ArchiveRO::open(&archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n         };\n         if self.additions.iter().any(|ar| ar.path() == archive) {\n             return Ok(());\n         }\n         self.additions.push(Addition::Archive {\n-            path: archive.to_path_buf(),\n+            path: archive,\n             archive: archive_ro,\n             skip: Box::new(skip),\n         });\n@@ -102,7 +108,9 @@ pub struct LlvmArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        if sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n+        // FIXME use ArArchiveBuilder on most targets again once reading thin archives is\n+        // implemented\n+        if true || sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n             Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n         } else {\n             Box::new(ArArchiveBuilder::new(sess, get_llvm_object_symbols))"}, {"sha": "0f33b98548984877a230edeb0004e8ba403e7132", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         bx.range_metadata(load, scalar.valid_range(bx));\n                     }\n                 }\n-                abi::Pointer => {\n+                abi::Pointer(_) => {\n                     if !scalar.valid_range(bx).contains(0) {\n                         bx.nonnull_metadata(load);\n                     }"}, {"sha": "edb1c160626ea7cf3a24b89e9d61541bbd887b17", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -236,7 +236,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             Scalar::Int(int) => {\n                 let data = int.assert_bits(layout.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n-                if layout.primitive() == Pointer {\n+                if matches!(layout.primitive(), Pointer(_)) {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)\n@@ -284,7 +284,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         1,\n                     )\n                 };\n-                if layout.primitive() != Pointer {\n+                if !matches!(layout.primitive(), Pointer(_)) {\n                     unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n                 } else {\n                     self.const_bitcast(llval, llty)"}, {"sha": "cad3c5d87b73c6bf445a15a08bf8f99702f40e2f", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -13,17 +13,15 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ConstAllocation, ErrorHandled, GlobalAlloc, InitChunk, Pointer,\n+    read_target_uint, Allocation, ConstAllocation, ErrorHandled, InitChunk, Pointer,\n     Scalar as InterpScalar,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::Lto;\n-use rustc_target::abi::{\n-    AddressSpace, Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n-};\n+use rustc_target::abi::{Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange};\n use std::ops::Range;\n \n pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<'_>) -> &'ll Value {\n@@ -98,20 +96,15 @@ pub fn const_alloc_to_llvm<'ll>(cx: &CodegenCx<'ll, '_>, alloc: ConstAllocation<\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n \n-        let address_space = match cx.tcx.global_alloc(alloc_id) {\n-            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n-            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n-                AddressSpace::DATA\n-            }\n-        };\n+        let address_space = cx.tcx.global_alloc(alloc_id).address_space(cx);\n \n         llvals.push(cx.scalar_to_backend(\n             InterpScalar::from_pointer(\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n             Scalar::Initialized {\n-                value: Primitive::Pointer,\n+                value: Primitive::Pointer(address_space),\n                 valid_range: WrappingRange::full(dl.pointer_size),\n             },\n             cx.type_i8p_ext(address_space),"}, {"sha": "32cd3a4efa227e0b0a5a77a1e0b18a25ef417474", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -191,7 +191,7 @@ pub unsafe fn create_module<'ll>(\n         //\n         // FIXME(#34960)\n         let cfg_llvm_root = option_env!(\"CFG_LLVM_ROOT\").unwrap_or(\"\");\n-        let custom_llvm_used = cfg_llvm_root.trim() != \"\";\n+        let custom_llvm_used = !cfg_llvm_root.trim().is_empty();\n \n         if !custom_llvm_used && target_data_layout != llvm_data_layout {\n             bug!("}, {"sha": "240a9d2f37184aa8adecf82a837e5d78693e14c5", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,6 +1,5 @@\n use crate::common::CodegenCx;\n use crate::coverageinfo;\n-use crate::errors::InstrumentCoverageRequiresLLVM12;\n use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n@@ -19,8 +18,8 @@ use std::ffi::CString;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// Rust Coverage Map generation supports LLVM Coverage Mapping Format versions\n-/// 5 (LLVM 12, only) and 6 (zero-based encoded as 4 and 5, respectively), as defined at\n+/// Rust Coverage Map generation supports LLVM Coverage Mapping Format version\n+/// 6 (zero-based encoded as 5), as defined at\n /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n /// These versions are supported by the LLVM coverage tools (`llvm-profdata` and `llvm-cov`)\n /// bundled with Rust's fork of LLVM.\n@@ -33,13 +32,10 @@ use std::ffi::CString;\n pub fn finalize(cx: &CodegenCx<'_, '_>) {\n     let tcx = cx.tcx;\n \n-    // Ensure the installed version of LLVM supports at least Coverage Map\n-    // Version 5 (encoded as a zero-based value: 4), which was introduced with\n-    // LLVM 12.\n+    // Ensure the installed version of LLVM supports Coverage Map Version 6\n+    // (encoded as a zero-based value: 5), which was introduced with LLVM 13.\n     let version = coverageinfo::mapping_version();\n-    if version < 4 {\n-        tcx.sess.emit_fatal(InstrumentCoverageRequiresLLVM12);\n-    }\n+    assert_eq!(version, 5, \"The `CoverageMappingVersion` exposed by `llvm-wrapper` is out of sync\");\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());\n \n@@ -61,7 +57,7 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n         return;\n     }\n \n-    let mut mapgen = CoverageMapGenerator::new(tcx, version);\n+    let mut mapgen = CoverageMapGenerator::new(tcx);\n \n     // Encode coverage mappings and generate function records\n     let mut function_data = Vec::new();\n@@ -124,25 +120,18 @@ struct CoverageMapGenerator {\n }\n \n impl CoverageMapGenerator {\n-    fn new(tcx: TyCtxt<'_>, version: u32) -> Self {\n+    fn new(tcx: TyCtxt<'_>) -> Self {\n         let mut filenames = FxIndexSet::default();\n-        if version >= 5 {\n-            // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n-            // requires setting the first filename to the compilation directory.\n-            // Since rustc generates coverage maps with relative paths, the\n-            // compilation directory can be combined with the relative paths\n-            // to get absolute paths, if needed.\n-            let working_dir = tcx\n-                .sess\n-                .opts\n-                .working_dir\n-                .remapped_path_if_available()\n-                .to_string_lossy()\n-                .to_string();\n-            let c_filename =\n-                CString::new(working_dir).expect(\"null error converting filename to C string\");\n-            filenames.insert(c_filename);\n-        }\n+        // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n+        // requires setting the first filename to the compilation directory.\n+        // Since rustc generates coverage maps with relative paths, the\n+        // compilation directory can be combined with the relative paths\n+        // to get absolute paths, if needed.\n+        let working_dir =\n+            tcx.sess.opts.working_dir.remapped_path_if_available().to_string_lossy().to_string();\n+        let c_filename =\n+            CString::new(working_dir).expect(\"null error converting filename to C string\");\n+        filenames.insert(c_filename);\n         Self { filenames }\n     }\n \n@@ -306,9 +295,8 @@ fn add_unused_functions(cx: &CodegenCx<'_, '_>) {\n                 DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator\n             ) {\n                 return None;\n-            } else if ignore_unused_generics\n-                && tcx.generics_of(def_id).requires_monomorphization(tcx)\n-            {\n+            }\n+            if ignore_unused_generics && tcx.generics_of(def_id).requires_monomorphization(tcx) {\n                 return None;\n             }\n             Some(local_def_id.to_def_id())"}, {"sha": "f73bbf3d22bd789f17306cfefaff39a7b7885cba", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1499,6 +1499,11 @@ pub fn create_vtable_di_node<'ll, 'tcx>(\n         return;\n     }\n \n+    // When full debuginfo is enabled, we want to try and prevent vtables from being\n+    // merged. Otherwise debuggers will have a hard time mapping from dyn pointer\n+    // to concrete type.\n+    llvm::SetUnnamedAddress(vtable, llvm::UnnamedAddr::No);\n+\n     let vtable_name =\n         compute_debuginfo_vtable_name(cx.tcx, ty, poly_trait_ref, VTableNameKind::GlobalVariable);\n     let vtable_type_di_node = build_vtable_type_di_node(cx, ty, poly_trait_ref);"}, {"sha": "54e850f25996b0d1894b038e197480f581ab630e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -122,7 +122,8 @@ fn tag_base_type<'ll, 'tcx>(\n                 Primitive::Int(t, _) => t,\n                 Primitive::F32 => Integer::I32,\n                 Primitive::F64 => Integer::I64,\n-                Primitive::Pointer => {\n+                // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                Primitive::Pointer(_) => {\n                     // If the niche is the NULL value of a reference, then `discr_enum_ty` will be\n                     // a RawPtr. CodeView doesn't know what to do with enums whose base type is a\n                     // pointer so we fix this up to just be `usize`."}, {"sha": "001d1ce93d8b479ee6184658373b78504813dab9", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -39,10 +39,6 @@ pub(crate) struct ErrorCreatingImportLibrary<'a> {\n     pub error: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(codegen_llvm_instrument_coverage_requires_llvm_12)]\n-pub(crate) struct InstrumentCoverageRequiresLLVM12;\n-\n #[derive(Diagnostic)]\n #[diag(codegen_llvm_symbol_already_defined)]\n pub(crate) struct SymbolAlreadyDefined<'a> {"}, {"sha": "dd89c4c59c14d83e0ac639f5557e628b26ac17ff", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -149,7 +149,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                                     emit_va_arg(self, args[0], ret_ty)\n                                 }\n                             }\n-                            Primitive::F64 | Primitive::Pointer => {\n+                            Primitive::F64 | Primitive::Pointer(_) => {\n                                 emit_va_arg(self, args[0], ret_ty)\n                             }\n                             // `va_arg` should never be used with the return type f32."}, {"sha": "c73d233b767a41cb20720ebd1696a7a9ec0f04b0", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n-use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n+use rustc_target::abi::{Abi, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{PointeeInfo, Scalar, Size, TyAbiInterface, Variants};\n use smallvec::{smallvec, SmallVec};\n@@ -312,14 +312,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             Int(i, _) => cx.type_from_integer(i),\n             F32 => cx.type_f32(),\n             F64 => cx.type_f64(),\n-            Pointer => {\n+            Pointer(address_space) => {\n                 // If we know the alignment, pick something better than i8.\n-                let (pointee, address_space) =\n-                    if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                        (cx.type_pointee_for_align(pointee.align), pointee.address_space)\n-                    } else {\n-                        (cx.type_i8(), AddressSpace::DATA)\n-                    };\n+                let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                    cx.type_pointee_for_align(pointee.align)\n+                } else {\n+                    cx.type_i8()\n+                };\n                 cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }"}, {"sha": "d3cd085cfb66854f374041ab5d5a2aeba32925bc", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -14,7 +14,7 @@ use tempfile::Builder as TempFileBuilder;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n // Re-exporting for rustc_codegen_llvm::back::archive\n@@ -116,42 +116,51 @@ impl<'a> ArArchiveBuilder<'a> {\n     }\n }\n \n-fn try_filter_fat_archs<'a>(\n+fn try_filter_fat_archs(\n     archs: object::read::Result<&[impl FatArch]>,\n     target_arch: object::Architecture,\n-    archive_map_data: &'a [u8],\n-) -> io::Result<Option<(&'a [u8], u64)>> {\n+    archive_path: &Path,\n+    archive_map_data: &[u8],\n+) -> io::Result<Option<PathBuf>> {\n     let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n \n     let desired = match archs.iter().find(|a| a.architecture() == target_arch) {\n         Some(a) => a,\n         None => return Ok(None),\n     };\n \n-    Ok(Some((\n+    let (mut new_f, extracted_path) = tempfile::Builder::new()\n+        .suffix(archive_path.file_name().unwrap())\n+        .tempfile()?\n+        .keep()\n+        .unwrap();\n+\n+    new_f.write_all(\n         desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-        desired.offset().into(),\n-    )))\n+    )?;\n+\n+    Ok(Some(extracted_path))\n }\n \n-pub fn try_extract_macho_fat_archive<'a>(\n+pub fn try_extract_macho_fat_archive(\n     sess: &Session,\n-    archive_bytes: &'a [u8],\n-) -> io::Result<Option<(&'a [u8], u64)>> {\n+    archive_path: &Path,\n+) -> io::Result<Option<PathBuf>> {\n+    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n     let target_arch = match sess.target.arch.as_ref() {\n         \"aarch64\" => object::Architecture::Aarch64,\n         \"x86_64\" => object::Architecture::X86_64,\n         _ => return Ok(None),\n     };\n \n-    match object::macho::FatHeader::parse(archive_bytes) {\n+    match object::macho::FatHeader::parse(&*archive_map) {\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(archive_bytes);\n-            try_filter_fat_archs(archs, target_arch, archive_bytes)\n+            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n         }\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(archive_bytes);\n-            try_filter_fat_archs(archs, target_arch, archive_bytes)\n+            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n         }\n         // Not a FatHeader at all, just return None.\n         _ => Ok(None),\n@@ -164,24 +173,21 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         archive_path: &Path,\n         mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let mut archive_path = archive_path.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive_path) =\n+                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n+            {\n+                archive_path = new_archive_path\n+            }\n+        }\n+\n         if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n             return Ok(());\n         }\n \n-        let (archive_bytes, offset) = if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n-            if let Some((sub_archive, archive_offset)) =\n-                try_extract_macho_fat_archive(&self.sess, &*archive_map)?\n-            {\n-                (sub_archive, Some(archive_offset))\n-            } else {\n-                (&*archive_map, None)\n-            }\n-        } else {\n-            (&*archive_map, None)\n-        };\n-\n-        let archive = ArchiveFile::parse(&*archive_bytes)\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let archive = ArchiveFile::parse(&*archive_map)\n             .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n         let archive_index = self.src_archives.len();\n \n@@ -190,13 +196,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.name().to_vec())\n                 .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                let mut range = entry.file_range();\n-                if let Some(offset) = offset {\n-                    range.0 += offset;\n-                }\n                 self.entries.push((\n                     file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: range },\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n                 ));\n             }\n         }"}, {"sha": "4ac7bea03ebc01e7a77abcfb8597673e3bf0d3ca", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -599,7 +599,8 @@ fn link_dwarf_object<'a>(\n     cg_results: &CodegenResults,\n     executable_out_filename: &Path,\n ) {\n-    let dwp_out_filename = executable_out_filename.with_extension(\"dwp\");\n+    let mut dwp_out_filename = executable_out_filename.to_path_buf().into_os_string();\n+    dwp_out_filename.push(\".dwp\");\n     debug!(?dwp_out_filename, ?executable_out_filename);\n \n     #[derive(Default)]\n@@ -1300,12 +1301,6 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> (bool, bool) {\n         return (false, false);\n     }\n \n-    // If we're only producing artifacts that are archives, no need to preserve\n-    // the objects as they're losslessly contained inside the archives.\n-    if sess.crate_types().iter().all(|&x| x.is_archive()) {\n-        return (false, false);\n-    }\n-\n     match (sess.split_debuginfo(), sess.opts.unstable_opts.split_dwarf_kind) {\n         // If there is no split debuginfo then do not preserve objects.\n         (SplitDebuginfo::Off, _) => (false, false),"}, {"sha": "02b502d948c2c890b83430bb45ee9a5791646a49", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -436,7 +436,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             cx.type_func(&[], cx.type_int())\n         };\n \n-        let main_ret_ty = cx.tcx().fn_sig(rust_main_def_id).output();\n+        let main_ret_ty = cx.tcx().fn_sig(rust_main_def_id).no_bound_vars().unwrap().output();\n         // Given that `main()` has no arguments,\n         // then its return type cannot have\n         // late-bound regions, since late-bound"}, {"sha": "87b819ebc9849504a6be8219bcfa67bda680c416", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -214,7 +214,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             }\n         } else if attr.has_name(sym::cmse_nonsecure_entry) {\n             if validate_fn_only_attr(attr.span)\n-                && !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. })\n+                && !matches!(tcx.fn_sig(did).skip_binder().abi(), abi::Abi::C { .. })\n             {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -234,7 +234,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         } else if attr.has_name(sym::track_caller) {\n             if !tcx.is_closure(did.to_def_id())\n                 && validate_fn_only_attr(attr.span)\n-                && tcx.fn_sig(did).abi() != abi::Abi::Rust\n+                && tcx.fn_sig(did).skip_binder().abi() != abi::Abi::Rust\n             {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n@@ -266,7 +266,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             }\n         } else if attr.has_name(sym::target_feature) {\n             if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n+                && tcx.fn_sig(did).skip_binder().unsafety() == hir::Unsafety::Normal\n             {\n                 if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n                     // The `#[target_feature]` attribute is allowed on"}, {"sha": "b0e007ce0097bd4c966edc23d1ce16017a0885c6", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -414,6 +414,7 @@ fn push_debuginfo_type_name<'tcx>(\n         | ty::Placeholder(..)\n         | ty::Alias(..)\n         | ty::Bound(..)\n+        | ty::GeneratorWitnessMIR(..)\n         | ty::GeneratorWitness(..) => {\n             bug!(\n                 \"debuginfo: Trying to create type name for \\"}, {"sha": "95aad10fdb0f9852505cd08ebffa88f6f62ac7c2", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -36,7 +36,7 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Arguments get assigned to by means of the function being called\n     for arg in mir.args_iter() {\n-        analyzer.assign(arg, mir::START_BLOCK.start_location());\n+        analyzer.assign(arg, DefLocation::Argument);\n     }\n \n     // If there exists a local definition that dominates all uses of that local,\n@@ -64,7 +64,22 @@ enum LocalKind {\n     /// A scalar or a scalar pair local that is neither defined nor used.\n     Unused,\n     /// A scalar or a scalar pair local with a single definition that dominates all uses.\n-    SSA(mir::Location),\n+    SSA(DefLocation),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum DefLocation {\n+    Argument,\n+    Body(Location),\n+}\n+\n+impl DefLocation {\n+    fn dominates(self, location: Location, dominators: &Dominators<mir::BasicBlock>) -> bool {\n+        match self {\n+            DefLocation::Argument => true,\n+            DefLocation::Body(def) => def.successor_within_block().dominates(location, dominators),\n+        }\n+    }\n }\n \n struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n@@ -74,17 +89,13 @@ struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n }\n \n impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n-    fn assign(&mut self, local: mir::Local, location: Location) {\n+    fn assign(&mut self, local: mir::Local, location: DefLocation) {\n         let kind = &mut self.locals[local];\n         match *kind {\n             LocalKind::ZST => {}\n             LocalKind::Memory => {}\n-            LocalKind::Unused => {\n-                *kind = LocalKind::SSA(location);\n-            }\n-            LocalKind::SSA(_) => {\n-                *kind = LocalKind::Memory;\n-            }\n+            LocalKind::Unused => *kind = LocalKind::SSA(location),\n+            LocalKind::SSA(_) => *kind = LocalKind::Memory,\n         }\n     }\n \n@@ -166,7 +177,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n         if let Some(local) = place.as_local() {\n-            self.assign(local, location);\n+            self.assign(local, DefLocation::Body(location));\n             if self.locals[local] != LocalKind::Memory {\n                 let decl_span = self.fx.mir.local_decls[local].source_info.span;\n                 if !self.fx.rvalue_creates_operand(rvalue, decl_span) {\n@@ -189,7 +200,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n         match context {\n             PlaceContext::MutatingUse(MutatingUseContext::Call)\n             | PlaceContext::MutatingUse(MutatingUseContext::Yield) => {\n-                self.assign(local, location);\n+                self.assign(local, DefLocation::Body(location));\n             }\n \n             PlaceContext::NonUse(_) | PlaceContext::MutatingUse(MutatingUseContext::Retag) => {}"}, {"sha": "2623a650e07b28f4c86e30263a192c90a7ec0814", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -39,7 +39,6 @@ enum MergingSucc {\n struct TerminatorCodegenHelper<'tcx> {\n     bb: mir::BasicBlock,\n     terminator: &'tcx mir::Terminator<'tcx>,\n-    funclet_bb: Option<mir::BasicBlock>,\n }\n \n impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n@@ -49,28 +48,24 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         &self,\n         fx: &'b mut FunctionCx<'a, 'tcx, Bx>,\n     ) -> Option<&'b Bx::Funclet> {\n-        let funclet_bb = self.funclet_bb?;\n-        if base::wants_msvc_seh(fx.cx.tcx().sess) {\n-            // If `landing_pad_for` hasn't been called yet to create the `Funclet`,\n-            // it has to be now. This may not seem necessary, as RPO should lead\n-            // to all the unwind edges being visited (and so to `landing_pad_for`\n-            // getting called for them), before building any of the blocks inside\n-            // the funclet itself - however, if MIR contains edges that end up not\n-            // being needed in the LLVM IR after monomorphization, the funclet may\n-            // be unreachable, and we don't have yet a way to skip building it in\n-            // such an eventuality (which may be a better solution than this).\n-            if fx.funclets[funclet_bb].is_none() {\n-                fx.landing_pad_for(funclet_bb);\n-            }\n-\n-            Some(\n-                fx.funclets[funclet_bb]\n-                    .as_ref()\n-                    .expect(\"landing_pad_for didn't also create funclets entry\"),\n-            )\n-        } else {\n-            None\n+        let cleanup_kinds = (&fx.cleanup_kinds).as_ref()?;\n+        let funclet_bb = cleanup_kinds[self.bb].funclet_bb(self.bb)?;\n+        // If `landing_pad_for` hasn't been called yet to create the `Funclet`,\n+        // it has to be now. This may not seem necessary, as RPO should lead\n+        // to all the unwind edges being visited (and so to `landing_pad_for`\n+        // getting called for them), before building any of the blocks inside\n+        // the funclet itself - however, if MIR contains edges that end up not\n+        // being needed in the LLVM IR after monomorphization, the funclet may\n+        // be unreachable, and we don't have yet a way to skip building it in\n+        // such an eventuality (which may be a better solution than this).\n+        if fx.funclets[funclet_bb].is_none() {\n+            fx.landing_pad_for(funclet_bb);\n         }\n+        Some(\n+            fx.funclets[funclet_bb]\n+                .as_ref()\n+                .expect(\"landing_pad_for didn't also create funclets entry\"),\n+        )\n     }\n \n     /// Get a basic block (creating it if necessary), possibly with cleanup\n@@ -104,23 +99,24 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> (bool, bool) {\n-        let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n-        let (needs_landing_pad, is_cleanupret) = match (self.funclet_bb, target_funclet) {\n-            (None, None) => (false, false),\n-            (None, Some(_)) => (true, false),\n-            (Some(_), None) => {\n-                let span = self.terminator.source_info.span;\n-                span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator);\n-            }\n-            (Some(f), Some(t_f)) => {\n-                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n-                    (false, false)\n-                } else {\n-                    (true, true)\n+        if let Some(ref cleanup_kinds) = fx.cleanup_kinds {\n+            let funclet_bb = cleanup_kinds[self.bb].funclet_bb(self.bb);\n+            let target_funclet = cleanup_kinds[target].funclet_bb(target);\n+            let (needs_landing_pad, is_cleanupret) = match (funclet_bb, target_funclet) {\n+                (None, None) => (false, false),\n+                (None, Some(_)) => (true, false),\n+                (Some(f), Some(t_f)) => (f != t_f, f != t_f),\n+                (Some(_), None) => {\n+                    let span = self.terminator.source_info.span;\n+                    span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator);\n                 }\n-            }\n-        };\n-        (needs_landing_pad, is_cleanupret)\n+            };\n+            (needs_landing_pad, is_cleanupret)\n+        } else {\n+            let needs_landing_pad = !fx.mir[self.bb].is_cleanup && fx.mir[target].is_cleanup;\n+            let is_cleanupret = false;\n+            (needs_landing_pad, is_cleanupret)\n+        }\n     }\n \n     fn funclet_br<Bx: BuilderMethods<'a, 'tcx>>(\n@@ -678,8 +674,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 Inhabited => layout.abi.is_uninhabited(),\n-                ZeroValid => !bx.tcx().permits_zero_init(layout),\n-                MemUninitializedValid => !bx.tcx().permits_uninit_init(layout),\n+                ZeroValid => !bx.tcx().permits_zero_init(bx.param_env().and(layout)),\n+                MemUninitializedValid => !bx.tcx().permits_uninit_init(bx.param_env().and(layout)),\n             };\n             Some(if do_panic {\n                 let msg_str = with_no_visible_paths!({\n@@ -1253,9 +1249,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> MergingSucc {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n-        // Create the cleanup bundle, if needed.\n-        let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n-        let helper = TerminatorCodegenHelper { bb, terminator, funclet_bb };\n+        let helper = TerminatorCodegenHelper { bb, terminator };\n \n         let mergeable_succ = || {\n             // Note: any call to `switch_to_block` will invalidate a `true` value\n@@ -1801,8 +1795,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         match (src.layout.abi, dst.layout.abi) {\n             (abi::Abi::Scalar(src_scalar), abi::Abi::Scalar(dst_scalar)) => {\n                 // HACK(eddyb) LLVM doesn't like `bitcast`s between pointers and non-pointers.\n-                let src_is_ptr = src_scalar.primitive() == abi::Pointer;\n-                let dst_is_ptr = dst_scalar.primitive() == abi::Pointer;\n+                let src_is_ptr = matches!(src_scalar.primitive(), abi::Pointer(_));\n+                let dst_is_ptr = matches!(dst_scalar.primitive(), abi::Pointer(_));\n                 if src_is_ptr == dst_is_ptr {\n                     assert_eq!(src.layout.size, dst.layout.size);\n "}, {"sha": "bb265b8289ed977364b8126ffbba2459eec18f2d", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,3 +1,4 @@\n+use crate::base;\n use crate::traits::*;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n@@ -58,7 +59,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>>,\n \n     /// The funclet status of each basic block\n-    cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n+    cleanup_kinds: Option<IndexVec<mir::BasicBlock, analyze::CleanupKind>>,\n \n     /// When targeting MSVC, this stores the cleanup info for each funclet BB.\n     /// This is initialized at the same time as the `landing_pads` entry for the\n@@ -166,7 +167,9 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n-    let cleanup_kinds = analyze::cleanup_kinds(&mir);\n+    let cleanup_kinds =\n+        if base::wants_msvc_seh(cx.tcx().sess) { Some(analyze::cleanup_kinds(&mir)) } else { None };\n+\n     let cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>> =\n         mir.basic_blocks\n             .indices()"}, {"sha": "cf02f59f67b97c3470c281d511ed4ade1390ec84", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, FieldsShape, Int, TagEncoding};\n+use rustc_target::abi::{Abi, Align, FieldsShape, Int, Pointer, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n@@ -209,6 +209,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         cast_to: Ty<'tcx>,\n     ) -> V {\n+        let dl = &bx.tcx().data_layout;\n         let cast_to_layout = bx.cx().layout_of(cast_to);\n         let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n@@ -250,12 +251,14 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n                 // Cast to an integer so we don't have to treat a pointer as a\n                 // special case.\n-                let (tag, tag_llty) = if tag_scalar.primitive().is_ptr() {\n-                    let t = bx.type_isize();\n-                    let tag = bx.ptrtoint(tag_imm, t);\n-                    (tag, t)\n-                } else {\n-                    (tag_imm, bx.cx().immediate_backend_type(tag_op.layout))\n+                let (tag, tag_llty) = match tag_scalar.primitive() {\n+                    // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                    Pointer(_) => {\n+                        let t = bx.type_from_integer(dl.ptr_sized_integer());\n+                        let tag = bx.ptrtoint(tag_imm, t);\n+                        (tag, t)\n+                    }\n+                    _ => (tag_imm, bx.cx().immediate_backend_type(tag_op.layout)),\n                 };\n \n                 let tag_size = tag_scalar.size(bx.cx());"}, {"sha": "60fbceb344d88dd360120d8d2594375b74793c60", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -91,6 +91,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::StatementKind::FakeRead(..)\n             | mir::StatementKind::Retag { .. }\n             | mir::StatementKind::AscribeUserType(..)\n+            | mir::StatementKind::ConstEvalCounter\n             | mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "f92277b111374ea268d5492dc76fd4d44b91872e", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -66,7 +66,7 @@ fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n                 if cfg!(debug_assertions) && stab.promotable {\n                     let sig = tcx.fn_sig(def_id);\n                     assert_eq!(\n-                        sig.unsafety(),\n+                        sig.skip_binder().unsafety(),\n                         hir::Unsafety::Normal,\n                         \"don't mark const unsafe fns as promotable\",\n                         // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682"}, {"sha": "a5bc121485d8cde6a3beb7dd0b1a601b32e1c445", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -561,8 +561,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         throw_unsup_format!(\"pointer arithmetic or comparison is not supported at compile-time\");\n     }\n \n-    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        // The step limit has already been hit in a previous call to `before_terminator`.\n+    fn increment_const_eval_counter(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        // The step limit has already been hit in a previous call to `increment_const_eval_counter`.\n         if ecx.machine.steps_remaining == 0 {\n             return Ok(());\n         }"}, {"sha": "c52886b77e64bc77388757aa9c520a6b96ea43e4", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -151,7 +151,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         // FIXME(oli-obk): we can probably encode closures just like structs\n         | ty::Closure(..)\n         | ty::Generator(..)\n-        | ty::GeneratorWitness(..) => Err(ValTreeCreationError::NonSupportedType),\n+        | ty::GeneratorWitness(..) |ty::GeneratorWitnessMIR(..)=> Err(ValTreeCreationError::NonSupportedType),\n     }\n }\n \n@@ -314,6 +314,7 @@ pub fn valtree_to_const_value<'tcx>(\n         | ty::Closure(..)\n         | ty::Generator(..)\n         | ty::GeneratorWitness(..)\n+        | ty::GeneratorWitnessMIR(..)\n         | ty::FnPtr(_)\n         | ty::RawPtr(_)\n         | ty::Str"}, {"sha": "907f014dfb5180f90b48e2a2403c9d6b38dd699e", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -101,6 +101,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n             | ty::Closure(_, _)\n             | ty::Generator(_, _, _)\n             | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(_, _)\n             | ty::Never\n             | ty::Tuple(_)\n             | ty::Error(_) => ConstValue::from_machine_usize(0u64, &tcx),\n@@ -447,7 +448,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n \n                 if intrinsic_name == sym::assert_zero_valid {\n-                    let should_panic = !self.tcx.permits_zero_init(layout);\n+                    let should_panic = !self.tcx.permits_zero_init(self.param_env.and(layout));\n \n                     if should_panic {\n                         M::abort(\n@@ -461,7 +462,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n \n                 if intrinsic_name == sym::assert_mem_uninitialized_valid {\n-                    let should_panic = !self.tcx.permits_uninit_init(layout);\n+                    let should_panic = !self.tcx.permits_uninit_init(self.param_env.and(layout));\n \n                     if should_panic {\n                         M::abort("}, {"sha": "76ed7b80f8d81b7a69c553a2597450cd5710572a", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -244,12 +244,18 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Called before a basic block terminator is executed.\n-    /// You can use this to detect endlessly running programs.\n     #[inline]\n     fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n+    /// Called when the interpreter encounters a `StatementKind::ConstEvalCounter` instruction.\n+    /// You can use this to detect long or endlessly running programs.\n+    #[inline]\n+    fn increment_const_eval_counter(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Called before a global allocation is accessed.\n     /// `def_id` is `Some` if this is the \"lazy\" allocation of a static.\n     #[inline]"}, {"sha": "a1b3985dce4e6ecfa27ff80b225e28e28f1d9d91", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -319,7 +319,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n                 let scalar = alloc.read_scalar(\n                     alloc_range(Size::ZERO, size),\n-                    /*read_provenance*/ s.is_ptr(),\n+                    /*read_provenance*/ matches!(s, abi::Pointer(_)),\n                 )?;\n                 Some(ImmTy { imm: scalar.into(), layout: mplace.layout })\n             }\n@@ -335,11 +335,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n                 let a_val = alloc.read_scalar(\n                     alloc_range(Size::ZERO, a_size),\n-                    /*read_provenance*/ a.is_ptr(),\n+                    /*read_provenance*/ matches!(a, abi::Pointer(_)),\n                 )?;\n                 let b_val = alloc.read_scalar(\n                     alloc_range(b_offset, b_size),\n-                    /*read_provenance*/ b.is_ptr(),\n+                    /*read_provenance*/ matches!(b, abi::Pointer(_)),\n                 )?;\n                 Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout })\n             }"}, {"sha": "d101937fd7406cc64f214f60b0c1073024b87bc3", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -129,6 +129,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // FIXME(#73156): Handle source code coverage in const eval\n             Coverage(..) => {}\n \n+            ConstEvalCounter => {\n+                M::increment_const_eval_counter(self)?;\n+            }\n+\n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly.\n             Nop => {}"}, {"sha": "aa539516d5e503ee328cb9734b7b55ff034c4d74", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -602,6 +602,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             | ty::Bound(..)\n             | ty::Param(..)\n             | ty::Alias(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::GeneratorWitness(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n     }"}, {"sha": "51624a0c6c817bb4a5327cd3cf1e744a75329772", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -58,7 +58,12 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n-    providers.permits_uninit_init =\n-        |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::UninitMitigated0x01Fill);\n-    providers.permits_zero_init = |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::Zero);\n+    providers.permits_uninit_init = |tcx, param_env_and_ty| {\n+        let (param_env, ty) = param_env_and_ty.into_parts();\n+        util::might_permit_raw_init(tcx, param_env, ty, InitKind::UninitMitigated0x01Fill)\n+    };\n+    providers.permits_zero_init = |tcx, param_env_and_ty| {\n+        let (param_env, ty) = param_env_and_ty.into_parts();\n+        util::might_permit_raw_init(tcx, param_env, ty, InitKind::Zero)\n+    };\n }"}, {"sha": "f47e3e86ebe2e0a0eedf3b14903e62d986c2c341", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -693,6 +693,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {}\n         }\n     }\n@@ -754,12 +755,9 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         let ocx = ObligationCtxt::new(&infcx);\n \n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n-                        let hir_id = tcx\n-                            .hir()\n-                            .local_def_id_to_hir_id(self.body.source.def_id().expect_local());\n                         let cause = ObligationCause::new(\n                             terminator.source_info.span,\n-                            hir_id,\n+                            self.body.source.def_id().expect_local(),\n                             ObligationCauseCode::ItemObligation(callee),\n                         );\n                         let normalized_predicates = ocx.normalize(&cause, param_env, predicates);"}, {"sha": "e841500bf3e0569bc2ab9202eebe6bf8b6fffd9b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -72,7 +72,7 @@ impl<'mir, 'tcx> ConstCx<'mir, 'tcx> {\n             let ty::Closure(_, substs) = ty.kind() else { bug!(\"type_of closure not ty::Closure\") };\n             substs.as_closure().sig()\n         } else {\n-            self.tcx.fn_sig(did)\n+            self.tcx.fn_sig(did).subst_identity()\n         }\n     }\n }"}, {"sha": "a2f2457487a4fc35974cb12a8f9e9e8af998320e", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n     ProjectionElem, RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind,\n     Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -230,11 +230,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // Equal types, all is good.\n             return true;\n         }\n-        // Normalization reveals opaque types, but we may be validating MIR while computing\n-        // said opaque types, causing cycles.\n-        if (src, dest).has_opaque_types() {\n-            return true;\n-        }\n \n         crate::util::is_subtype(self.tcx, self.param_env, src, dest)\n     }\n@@ -377,12 +372,12 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                                 return;\n                             };\n \n-                            let Some(&f_ty) = layout.field_tys.get(local) else {\n+                            let Some(f_ty) = layout.field_tys.get(local) else {\n                                 self.fail(location, format!(\"Out of bounds local {:?} for {:?}\", local, parent_ty));\n                                 return;\n                             };\n \n-                            f_ty\n+                            f_ty.ty\n                         } else {\n                             let Some(f_ty) = substs.as_generator().prefix_tys().nth(f.index()) else {\n                                 fail_out_of_bounds(self, location);\n@@ -766,6 +761,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             StatementKind::StorageLive(..)\n             | StatementKind::StorageDead(..)\n             | StatementKind::Coverage(_)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {}\n         }\n "}, {"sha": "995363c0edd92e3e4849b045328b1650ec1225d1", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -40,6 +40,7 @@ pub enum CallKind<'tcx> {\n         self_arg: Option<Ident>,\n         desugaring: Option<(CallDesugaringKind, Ty<'tcx>)>,\n         method_did: DefId,\n+        method_substs: SubstsRef<'tcx>,\n     },\n     /// A call to `Fn(..)::call(..)`, desugared from `my_closure(a, b, c)`\n     FnCall { fn_trait_id: DefId, self_ty: Ty<'tcx> },\n@@ -131,6 +132,6 @@ pub fn call_kind<'tcx>(\n         } else {\n             None\n         };\n-        CallKind::Normal { self_arg, desugaring, method_did }\n+        CallKind::Normal { self_arg, desugaring, method_did, method_substs }\n     })\n }"}, {"sha": "48961b7aac64588486695ddc2ba4b61d4a036117", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -20,13 +20,14 @@ use crate::interpret::{InterpCx, MemoryKind, OpTy};\n /// to the full uninit check).\n pub fn might_permit_raw_init<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     ty: TyAndLayout<'tcx>,\n     kind: InitKind,\n ) -> bool {\n     if tcx.sess.opts.unstable_opts.strict_init_checks {\n         might_permit_raw_init_strict(ty, tcx, kind)\n     } else {\n-        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n+        let layout_cx = LayoutCx { tcx, param_env };\n         might_permit_raw_init_lax(ty, &layout_cx, kind)\n     }\n }"}, {"sha": "4e80a28518668ef10f9f77971f281fb069abd557", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -64,6 +64,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),\n \n             ty::GeneratorWitness(_) => bug!(\"type_name: unexpected `GeneratorWitness`\"),\n+            ty::GeneratorWitnessMIR(..) => bug!(\"type_name: unexpected `GeneratorWitnessMIR`\"),\n         }\n     }\n "}, {"sha": "0a21a4249c8295b94ab4b2f7db068a58e8da9ba7", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -135,7 +135,47 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // This loop computes the semi[w] for w.\n         semi[w] = w;\n         for v in graph.predecessors(pre_order_to_real[w]) {\n-            // Reachable vertices may have unreachable predecessors, so ignore any of them\n+            // TL;DR: Reachable vertices may have unreachable predecessors, so ignore any of them.\n+            //\n+            // Ignore blocks which are not connected to the entry block.\n+            //\n+            // The algorithm that was used to traverse the graph and build the\n+            // `pre_order_to_real` and `real_to_pre_order` vectors does so by\n+            // starting from the entry block and following the successors.\n+            // Therefore, any blocks not reachable from the entry block will be\n+            // set to `None` in the `pre_order_to_real` vector.\n+            //\n+            // For example, in this graph, A and B should be skipped:\n+            //\n+            //           \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n+            //           \u2502     \u2502\n+            //           \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n+            //              \u2502\n+            //           \u250c\u2500\u2500\u25bc\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2510\n+            //           \u2502     \u2502              \u2502  A  \u2502\n+            //           \u2514\u2500\u2500\u252c\u2500\u2500\u2518              \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n+            //              \u2502                    \u2502\n+            //      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u2502\n+            //      \u2502               \u2502            \u2502\n+            //   \u250c\u2500\u2500\u25bc\u2500\u2500\u2510         \u250c\u2500\u2500\u25bc\u2500\u2500\u2510      \u250c\u2500\u2500\u25bc\u2500\u2500\u2510\n+            //   \u2502     \u2502         \u2502     \u2502      \u2502  B  \u2502\n+            //   \u2514\u2500\u2500\u252c\u2500\u2500\u2518         \u2514\u2500\u2500\u252c\u2500\u2500\u2518      \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n+            //      \u2502               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n+            //   \u250c\u2500\u2500\u25bc\u2500\u2500\u2510                   \u2502\n+            //   \u2502     \u2502                   \u2502\n+            //   \u2514\u2500\u2500\u252c\u2500\u2500\u2518                \u250c\u2500\u2500\u25bc\u2500\u2500\u2510\n+            //      \u2502                   \u2502     \u2502\n+            //      \u2502                   \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n+            //   \u250c\u2500\u2500\u25bc\u2500\u2500\u2510\n+            //   \u2502     \u2502\n+            //   \u2514\u2500\u2500\u252c\u2500\u2500\u2518\n+            //      \u2502\n+            //   \u250c\u2500\u2500\u25bc\u2500\u2500\u2510\n+            //   \u2502     \u2502\n+            //   \u2514\u2500\u2500\u2500\u2500\u2500\u2518\n+            //\n+            // ...this may be the case if a MirPass modifies the CFG to remove\n+            // or rearrange certain blocks/edges.\n             let Some(v) = real_to_pre_order[v] else {\n                 continue\n             };\n@@ -264,13 +304,18 @@ fn compress(\n     }\n }\n \n+/// Tracks the list of dominators for each node.\n #[derive(Clone, Debug)]\n pub struct Dominators<N: Idx> {\n     post_order_rank: IndexVec<N, usize>,\n+    // Even though we track only the immediate dominator of each node, it's\n+    // possible to get its full list of dominators by looking up the dominator\n+    // of each dominator. (See the `impl Iterator for Iter` definition).\n     immediate_dominators: IndexVec<N, Option<N>>,\n }\n \n impl<Node: Idx> Dominators<Node> {\n+    /// Whether the given Node has an immediate dominator.\n     pub fn is_reachable(&self, node: Node) -> bool {\n         self.immediate_dominators[node].is_some()\n     }\n@@ -280,12 +325,14 @@ impl<Node: Idx> Dominators<Node> {\n         self.immediate_dominators[node].unwrap()\n     }\n \n+    /// Provides an iterator over each dominator up the CFG, for the given Node.\n+    /// See the `impl Iterator for Iter` definition to understand how this works.\n     pub fn dominators(&self, node: Node) -> Iter<'_, Node> {\n         assert!(self.is_reachable(node), \"node {node:?} is not reachable\");\n         Iter { dominators: self, node: Some(node) }\n     }\n \n-    pub fn is_dominated_by(&self, node: Node, dom: Node) -> bool {\n+    pub fn dominates(&self, dom: Node, node: Node) -> bool {\n         // FIXME -- could be optimized by using post-order-rank\n         self.dominators(node).any(|n| n == dom)\n     }"}, {"sha": "dda422c6dd07ee60cb67674282b657d053976890", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -139,8 +139,7 @@ pub enum ProcessResult<O, E> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n struct ObligationTreeId(usize);\n \n-type ObligationTreeIdGenerator =\n-    std::iter::Map<std::ops::RangeFrom<usize>, fn(usize) -> ObligationTreeId>;\n+type ObligationTreeIdGenerator = impl Iterator<Item = ObligationTreeId>;\n \n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to [Self::process_obligations],"}, {"sha": "ccefd6adaf14b6012a614e96368d46b83919a3ad", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -296,9 +296,8 @@ fn run_compiler(\n \n             if let Some(ppm) = &sess.opts.pretty {\n                 if ppm.needs_ast_map() {\n-                    let expanded_crate = queries.expansion()?.borrow().0.clone();\n                     queries.global_ctxt()?.enter(|tcx| {\n-                        pretty::print_after_hir_lowering(tcx, &*expanded_crate, *ppm);\n+                        pretty::print_after_hir_lowering(tcx, *ppm);\n                         Ok(())\n                     })?;\n                 } else {\n@@ -328,11 +327,15 @@ fn run_compiler(\n                 }\n             }\n \n-            queries.global_ctxt()?;\n+            let mut gctxt = queries.global_ctxt()?;\n             if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n \n+            // Make sure the `output_filenames` query is run for its side\n+            // effects of writing the dep-info and reporting errors.\n+            gctxt.enter(|tcx| tcx.output_filenames(()));\n+\n             if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n                 && sess.opts.output_types.len() == 1\n             {\n@@ -343,7 +346,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            queries.global_ctxt()?.enter(|tcx| {\n+            gctxt.enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n                     let crate_name = tcx.crate_name(LOCAL_CRATE);\n@@ -360,6 +363,8 @@ fn run_compiler(\n                 result\n             })?;\n \n+            drop(gctxt);\n+\n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }"}, {"sha": "446c6832cb7b607657a23a63e4c628d0123867cc", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -403,7 +403,7 @@ pub fn print_after_parsing(sess: &Session, krate: &ast::Crate, ppm: PpMode) {\n     write_or_print(&out, sess);\n }\n \n-pub fn print_after_hir_lowering<'tcx>(tcx: TyCtxt<'tcx>, krate: &ast::Crate, ppm: PpMode) {\n+pub fn print_after_hir_lowering<'tcx>(tcx: TyCtxt<'tcx>, ppm: PpMode) {\n     if ppm.needs_analysis() {\n         abort_on_err(print_with_analysis(tcx, ppm), tcx.sess);\n         return;\n@@ -420,7 +420,7 @@ pub fn print_after_hir_lowering<'tcx>(tcx: TyCtxt<'tcx>, krate: &ast::Crate, ppm\n                 let parse = &sess.parse_sess;\n                 pprust::print_crate(\n                     sess.source_map(),\n-                    krate,\n+                    &tcx.resolver_for_lowering(()).borrow().1,\n                     src_name,\n                     src,\n                     annotation.pp_ann(),\n@@ -433,7 +433,7 @@ pub fn print_after_hir_lowering<'tcx>(tcx: TyCtxt<'tcx>, krate: &ast::Crate, ppm\n \n         AstTree(PpAstTreeMode::Expanded) => {\n             debug!(\"pretty-printing expanded AST\");\n-            format!(\"{krate:#?}\")\n+            format!(\"{:#?}\", tcx.resolver_for_lowering(()).borrow().1)\n         }\n \n         Hir(s) => call_with_pp_support_hir(&s, tcx, move |annotation, hir_map| {\n@@ -498,6 +498,21 @@ fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuarante\n             out\n         }\n \n+        ThirFlat => {\n+            let mut out = String::new();\n+            abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n+            debug!(\"pretty printing THIR flat\");\n+            for did in tcx.hir().body_owners() {\n+                let _ = writeln!(\n+                    out,\n+                    \"{:?}:\\n{}\\n\",\n+                    did,\n+                    tcx.thir_flat(ty::WithOptConstParam::unknown(did))\n+                );\n+            }\n+            out\n+        }\n+\n         _ => unreachable!(),\n     };\n "}, {"sha": "4ae372bb90432cc86908ed3f41dc6d0b64982806", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -506,6 +506,7 @@ E0785: include_str!(\"./error_codes/E0785.md\"),\n E0786: include_str!(\"./error_codes/E0786.md\"),\n E0787: include_str!(\"./error_codes/E0787.md\"),\n E0788: include_str!(\"./error_codes/E0788.md\"),\n+E0789: include_str!(\"./error_codes/E0789.md\"),\n E0790: include_str!(\"./error_codes/E0790.md\"),\n E0791: include_str!(\"./error_codes/E0791.md\"),\n E0792: include_str!(\"./error_codes/E0792.md\"),\n@@ -645,5 +646,4 @@ E0792: include_str!(\"./error_codes/E0792.md\"),\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-    E0789, // rustc_allowed_through_unstable_modules without stability attribute\n }"}, {"sha": "d7998af85b94fc71c9c142abe46b9bbb9c4a06e6", "filename": "compiler/rustc_error_codes/src/error_codes/E0587.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0587.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0587.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0587.md?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -11,6 +11,6 @@ You cannot use `packed` and `align` hints on a same type. If you want to pack a\n type to a given size, you should provide a size to packed:\n \n ```\n-#[repr(packed)] // ok!\n+#[repr(packed(8))] // ok!\n struct Umbrella(i32);\n ```"}, {"sha": "89b7cd422fe966a56e805cfeb21061d06fedd0c6", "filename": "compiler/rustc_error_codes/src/error_codes/E0789.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0789.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0789.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0789.md?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,30 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code.\n+\n+The internal `rustc_allowed_through_unstable_modules` attribute must be used\n+on an item with a `stable` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0789\n+// NOTE: both of these attributes are perma-unstable and should *never* be\n+//       used outside of the compiler and standard library.\n+#![feature(rustc_attrs)]\n+#![feature(staged_api)]\n+\n+#![unstable(feature = \"foo_module\", reason = \"...\", issue = \"123\")]\n+\n+#[rustc_allowed_through_unstable_modules]\n+// #[stable(feature = \"foo\", since = \"1.0\")]\n+struct Foo;\n+// ^^^ error: `rustc_allowed_through_unstable_modules` attribute must be\n+//            paired with a `stable` attribute\n+```\n+\n+Typically when an item is marked with a `stable` attribute, the modules that\n+enclose the item must also be marked with `stable` attributes, otherwise the\n+item becomes *de facto* unstable. `#[rustc_allowed_through_unstable_modules]`\n+is a workaround which allows an item to \"escape\" its unstable parent modules.\n+This error occurs when an item is marked with\n+`#[rustc_allowed_through_unstable_modules]` but no supplementary `stable`\n+attribute exists. See [#99288](https://github.com/rust-lang/rust/pull/99288)\n+for an example of `#[rustc_allowed_through_unstable_modules]` in use."}, {"sha": "0021638c10268c9ce5fcf68c7ffac5d0793d570c", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -123,4 +123,7 @@ borrowck_cannot_move_when_borrowed =\n \n borrowck_opaque_type_non_generic_param =\n     expected generic {$kind} parameter, found `{$ty}`\n-    .label = this generic parameter must be used with a generic {$kind} parameter\n+    .label = {STREQ($ty, \"'static\") ->\n+        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+        *[other] this generic parameter must be used with a generic {$kind} parameter\n+    }"}, {"sha": "6101b28ab0cdde9a42b69834de91ea4bff2d6198", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -23,7 +23,7 @@ codegen_gcc_invalid_monomorphization_unsupported_element =\n     invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n \n codegen_gcc_invalid_monomorphization_invalid_bitmask =\n-    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n codegen_gcc_invalid_monomorphization_simd_shuffle =\n     invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`"}, {"sha": "b82c903290b9a2c10c42db4fcfd036335bbdd8d4", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -11,9 +11,6 @@ codegen_llvm_unknown_ctarget_feature_prefix =\n codegen_llvm_error_creating_import_library =\n     Error creating import library for {$lib_name}: {$error}\n \n-codegen_llvm_instrument_coverage_requires_llvm_12 =\n-    rustc option `-C instrument-coverage` requires LLVM 12 or higher.\n-\n codegen_llvm_symbol_already_defined =\n     symbol `{$symbol_name}` is already defined\n "}, {"sha": "4924105128db6eb1d55afa46efdb612999b7fd5b", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -179,9 +179,9 @@ codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$\n \n codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n \n-codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {error}\n+codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {$error}\n \n-codegen_ssa_read_file = failed to read file: {message}\n+codegen_ssa_read_file = failed to read file: {$message}\n \n codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n "}, {"sha": "bcc1d9002dfdebe040e00726a48a8a34dceac576", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -147,8 +147,6 @@ infer_region_explanation = {$pref_kind ->\n }{$desc_kind ->\n     *[should_not_happen] [{$desc_kind}]\n     [restatic] the static lifetime\n-    [reempty] the empty lifetime\n-    [reemptyuni] the empty lifetime in universe {$desc_arg}\n     [revar] lifetime {$desc_arg}\n \n     [as_defined] the lifetime `{$desc_arg}` as defined here"}, {"sha": "dca678dff7a793253524fe055db88b49934f9dc1", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -100,6 +100,8 @@ lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n     .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n     .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n \n+lint_multple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n+\n lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n \n lint_identifier_uncommon_codepoints = identifier contains uncommon Unicode codepoints"}, {"sha": "f9bda721df34dcb30830c092aa5dd918691c8b9b", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -299,10 +299,18 @@ mir_build_borrow_of_moved_value = borrow of moved value\n     .suggestion = borrow this binding in the pattern to avoid moving the value\n \n mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n-    .label = first mutable borrow, by `{$name}`, occurs here\n-    .mutable_borrow = another mutable borrow, by `{$name_mut}`, occurs here\n-    .immutable_borrow = also borrowed as immutable, by `{$name_immut}`, here\n-    .moved = also moved into `{$name_moved}` here\n+\n+mir_build_already_borrowed = cannot borrow value as mutable because it is also borrowed as immutable\n+\n+mir_build_already_mut_borrowed = cannot borrow value as immutable because it is also borrowed as mutable\n+\n+mir_build_moved_while_borrowed = cannot move out of value because it is borrowed\n+\n+mir_build_mutable_borrow = value is mutably borrowed by `{$name}` here\n+\n+mir_build_borrow = value is borrowed by `{$name}` here\n+\n+mir_build_moved = value is moved into `{$name}` here\n \n mir_build_union_pattern = cannot use unions in constant patterns\n "}, {"sha": "1728ef70cba0a7bd817b4db0a917b9060587c9db", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -199,6 +199,17 @@ parse_match_arm_body_without_braces = `match` arm body without braces\n         } with a body\n     .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n \n+parse_inclusive_range_extra_equals = unexpected `=` after inclusive range\n+    .suggestion_remove_eq = use `..=` instead\n+    .note = inclusive ranges end with a single equals sign (`..=`)\n+\n+parse_inclusive_range_match_arrow = unexpected `=>` after open range\n+    .suggestion_add_space = add a space between the pattern and `=>`\n+\n+parse_inclusive_range_no_end = inclusive range with no end\n+    .suggestion_open_range = use `..` instead\n+    .note = inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n parse_struct_literal_not_allowed_here = struct literals are not allowed here\n     .suggestion = surround the struct literal with parentheses\n \n@@ -238,6 +249,7 @@ parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n \n parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+parse_extra_if_in_let_else = remove the `if` if you meant to write a `let...else` statement\n \n parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n     .suggestion = initialize the variable"}, {"sha": "0c2ab3d08f9dea13d6b1da74a346e231f40c9f6f", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -710,3 +710,24 @@ passes_ignored_derived_impls =\n       [one] trait {$trait_list}, but this is\n      *[other] traits {$trait_list}, but these are\n     } intentionally ignored during dead code analysis\n+\n+passes_proc_macro_typeerror = mismatched {$kind} signature\n+    .label = found {$found}, expected type `proc_macro::TokenStream`\n+    .note = {$kind}s must have a signature of `{$expected_signature}`\n+\n+passes_proc_macro_diff_arg_count = mismatched {$kind} signature\n+    .label = found unexpected {$count ->\n+      [one] argument\n+     *[other] arguments\n+    }\n+    .note = {$kind}s must have a signature of `{$expected_signature}`\n+\n+passes_proc_macro_missing_args = mismatched {$kind} signature\n+    .label = {$kind} must have {$expected_input_count ->\n+      [one] one argument\n+     *[other] two arguments\n+    } of type `proc_macro::TokenStream`\n+\n+passes_proc_macro_invalid_abi = proc macro functions may not be `extern \"{$abi}\"`\n+\n+passes_proc_macro_unsafe = proc macro functions may not be `unsafe`"}, {"sha": "f053bdc3809be30d5377cae4abc3960f503644b9", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -182,6 +182,9 @@ pub fn fluent_bundle(\n     trace!(?locale);\n     let mut bundle = new_bundle(vec![locale]);\n \n+    // Add convenience functions available to ftl authors.\n+    register_functions(&mut bundle);\n+\n     // Fluent diagnostics can insert directionality isolation markers around interpolated variables\n     // indicating that there may be a shift from right-to-left to left-to-right text (or\n     // vice-versa). These are disabled because they are sometimes visible in the error output, but\n@@ -244,6 +247,15 @@ pub fn fluent_bundle(\n     Ok(Some(bundle))\n }\n \n+fn register_functions(bundle: &mut FluentBundle) {\n+    bundle\n+        .add_function(\"STREQ\", |positional, _named| match positional {\n+            [FluentValue::String(a), FluentValue::String(b)] => format!(\"{}\", (a == b)).into(),\n+            _ => FluentValue::Error,\n+        })\n+        .expect(\"Failed to add a function to the bundle.\");\n+}\n+\n /// Type alias for the result of `fallback_fluent_bundle` - a reference-counted pointer to a lazily\n /// evaluated fluent bundle.\n pub type LazyFallbackBundle = Lrc<Lazy<FluentBundle, impl FnOnce() -> FluentBundle>>;\n@@ -256,6 +268,9 @@ pub fn fallback_fluent_bundle(\n ) -> LazyFallbackBundle {\n     Lrc::new(Lazy::new(move || {\n         let mut fallback_bundle = new_bundle(vec![langid!(\"en-US\")]);\n+\n+        register_functions(&mut fallback_bundle);\n+\n         // See comment in `fluent_bundle`.\n         fallback_bundle.set_use_isolating(with_directionality_markers);\n "}, {"sha": "4ad24c1400d69d1a5ec36650443b4ab4b00a0e88", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -629,19 +629,27 @@ impl Diagnostic {\n         applicability: Applicability,\n         style: SuggestionStyle,\n     ) -> &mut Self {\n-        assert!(!suggestion.is_empty());\n-        debug_assert!(\n-            !(suggestion.iter().any(|(sp, text)| sp.is_empty() && text.is_empty())),\n-            \"Span must not be empty and have no suggestion\"\n+        let mut parts = suggestion\n+            .into_iter()\n+            .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+            .collect::<Vec<_>>();\n+\n+        parts.sort_unstable_by_key(|part| part.span);\n+\n+        assert!(!parts.is_empty());\n+        debug_assert_eq!(\n+            parts.iter().find(|part| part.span.is_empty() && part.snippet.is_empty()),\n+            None,\n+            \"Span must not be empty and have no suggestion\",\n+        );\n+        debug_assert_eq!(\n+            parts.array_windows().find(|[a, b]| a.span.overlaps(b.span)),\n+            None,\n+            \"suggestion must not have overlapping parts\",\n         );\n \n         self.push_suggestion(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: suggestion\n-                    .into_iter()\n-                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                    .collect(),\n-            }],\n+            substitutions: vec![Substitution { parts }],\n             msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n             style,\n             applicability,\n@@ -802,25 +810,34 @@ impl Diagnostic {\n         suggestions: impl IntoIterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        let suggestions: Vec<_> = suggestions.into_iter().collect();\n-        debug_assert!(\n-            !(suggestions\n-                .iter()\n-                .flatten()\n-                .any(|(sp, suggestion)| sp.is_empty() && suggestion.is_empty())),\n-            \"Span must not be empty and have no suggestion\"\n-        );\n+        let substitutions = suggestions\n+            .into_iter()\n+            .map(|sugg| {\n+                let mut parts = sugg\n+                    .into_iter()\n+                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                    .collect::<Vec<_>>();\n+\n+                parts.sort_unstable_by_key(|part| part.span);\n+\n+                assert!(!parts.is_empty());\n+                debug_assert_eq!(\n+                    parts.iter().find(|part| part.span.is_empty() && part.snippet.is_empty()),\n+                    None,\n+                    \"Span must not be empty and have no suggestion\",\n+                );\n+                debug_assert_eq!(\n+                    parts.array_windows().find(|[a, b]| a.span.overlaps(b.span)),\n+                    None,\n+                    \"suggestion must not have overlapping parts\",\n+                );\n+\n+                Substitution { parts }\n+            })\n+            .collect();\n \n         self.push_suggestion(CodeSuggestion {\n-            substitutions: suggestions\n-                .into_iter()\n-                .map(|sugg| Substitution {\n-                    parts: sugg\n-                        .into_iter()\n-                        .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                        .collect(),\n-                })\n-                .collect(),\n+            substitutions,\n             msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n             style: SuggestionStyle::ShowCode,\n             applicability,"}, {"sha": "d076fc08b0e2f1f023e73a3259d18c6cf9d98795", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,6 +3,7 @@\n //! This module contains the code for creating and emitting diagnostics.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(array_windows)]\n #![feature(drain_filter)]\n #![feature(if_let_guard)]\n #![feature(is_terminal)]"}, {"sha": "cd431f5701958e529531504fc9f9574915b7cf4b", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -10,7 +10,7 @@ use crate::mbe::transcribe::transcribe;\n \n use rustc_ast as ast;\n use rustc_ast::token::{self, Delimiter, NonterminalKind, Token, TokenKind, TokenKind::*};\n-use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n+use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n@@ -212,7 +212,6 @@ fn expand_macro<'cx>(\n             };\n             let arm_span = rhses[i].span();\n \n-            let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n             // rhs has holes ( `$id` and `$(...)` that need filled)\n             let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n                 Ok(tts) => tts,\n@@ -224,12 +223,25 @@ fn expand_macro<'cx>(\n \n             // Replace all the tokens for the corresponding positions in the macro, to maintain\n             // proper positions in error reporting, while maintaining the macro_backtrace.\n-            if rhs_spans.len() == tts.len() {\n+            if tts.len() == rhs.tts.len() {\n                 tts = tts.map_enumerated(|i, tt| {\n                     let mut tt = tt.clone();\n-                    let mut sp = rhs_spans[i];\n-                    sp = sp.with_ctxt(tt.span().ctxt());\n-                    tt.set_span(sp);\n+                    let rhs_tt = &rhs.tts[i];\n+                    let ctxt = tt.span().ctxt();\n+                    match (&mut tt, rhs_tt) {\n+                        // preserve the delim spans if able\n+                        (\n+                            TokenTree::Delimited(target_sp, ..),\n+                            mbe::TokenTree::Delimited(source_sp, ..),\n+                        ) => {\n+                            target_sp.open = source_sp.open.with_ctxt(ctxt);\n+                            target_sp.close = source_sp.close.with_ctxt(ctxt);\n+                        }\n+                        _ => {\n+                            let sp = rhs_tt.span().with_ctxt(ctxt);\n+                            tt.set_span(sp);\n+                        }\n+                    }\n                     tt\n                 });\n             }"}, {"sha": "af9c40a3ba5227b249221b6a1e59a5fdfe1a2c0a", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -160,6 +160,8 @@ declare_features! (\n     (active, intrinsics, \"1.0.0\", None, None),\n     /// Allows using `#[lang = \"..\"]` attribute for linking items to special compiler logic.\n     (active, lang_items, \"1.0.0\", None, None),\n+    /// Allows the `multiple_supertrait_upcastable` lint.\n+    (active, multiple_supertrait_upcastable, \"CURRENT_RUSTC_VERSION\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items."}, {"sha": "93d16716346915119dcf3213c27728293e73e20a", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -83,7 +83,8 @@ impl UnstableFeatures {\n     /// Otherwise, only `RUSTC_BOOTSTRAP=1` will work.\n     pub fn from_environment(krate: Option<&str>) -> Self {\n         // `true` if this is a feature-staged build, i.e., on the beta or stable channel.\n-        let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+        let disable_unstable_features =\n+            option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").map(|s| s != \"0\").unwrap_or(false);\n         // Returns whether `krate` should be counted as unstable\n         let is_unstable_crate = |var: &str| {\n             krate.map_or(false, |name| var.split(',').any(|new_krate| new_krate == name))"}, {"sha": "a063307af0cb4109e7c14dddf7504df9584e9839", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 372, "deletions": 8, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -831,8 +831,6 @@ pub struct OwnerNodes<'tcx> {\n     pub nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n     /// Content of local bodies.\n     pub bodies: SortedMap<ItemLocalId, &'tcx Body<'tcx>>,\n-    /// Non-owning definitions contained in this owner.\n-    pub local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n }\n \n impl<'tcx> OwnerNodes<'tcx> {\n@@ -862,7 +860,6 @@ impl fmt::Debug for OwnerNodes<'_> {\n                     .collect::<Vec<_>>(),\n             )\n             .field(\"bodies\", &self.bodies)\n-            .field(\"local_id_to_def_id\", &self.local_id_to_def_id)\n             .field(\"hash_without_bodies\", &self.hash_without_bodies)\n             .field(\"hash_including_bodies\", &self.hash_including_bodies)\n             .finish()\n@@ -2106,8 +2103,8 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -2117,6 +2114,8 @@ pub enum MatchSource {\n     TryDesugar,\n     /// A desugared `<expr>.await`.\n     AwaitDesugar,\n+    /// A desugared `format_args!()`.\n+    FormatArgs,\n }\n \n impl MatchSource {\n@@ -2128,6 +2127,7 @@ impl MatchSource {\n             ForLoopDesugar => \"for\",\n             TryDesugar => \"?\",\n             AwaitDesugar => \".await\",\n+            FormatArgs => \"format_args!()\",\n         }\n     }\n }\n@@ -2263,7 +2263,7 @@ pub struct TraitItem<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-impl TraitItem<'_> {\n+impl<'hir> TraitItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2273,6 +2273,32 @@ impl TraitItem<'_> {\n     pub fn trait_item_id(&self) -> TraitItemId {\n         TraitItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`TraitItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, Option<BodyId>) {\n+        let TraitItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &TraitFn<'hir>) {\n+        let TraitItemKind::Fn(ty, trfn) = &self.kind else { self.expect_failed(\"a function\") };\n+        (ty, trfn)\n+    }\n+\n+    /// Expect an [`TraitItemKind::Type`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> (GenericBounds<'hir>, Option<&'hir Ty<'hir>>) {\n+        let TraitItemKind::Type(bounds, ty) = self.kind else { self.expect_failed(\"a type\") };\n+        (bounds, ty)\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents a trait method's body (or just argument names).\n@@ -2325,7 +2351,7 @@ pub struct ImplItem<'hir> {\n     pub vis_span: Span,\n }\n \n-impl ImplItem<'_> {\n+impl<'hir> ImplItem<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -2335,6 +2361,32 @@ impl ImplItem<'_> {\n     pub fn impl_item_id(&self) -> ImplItemId {\n         ImplItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ImplItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ImplItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, BodyId) {\n+        let ImplItemKind::Fn(ty, body) = &self.kind else { self.expect_failed(\"a function\") };\n+        (ty, *body)\n+    }\n+\n+    /// Expect an [`ImplItemKind::Type`] or panic.\n+    #[track_caller]\n+    pub fn expect_type(&self) -> &'hir Ty<'hir> {\n+        let ImplItemKind::Type(ty) = self.kind else { self.expect_failed(\"a type\") };\n+        ty\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents various kinds of content within an `impl`.\n@@ -2995,7 +3047,7 @@ pub struct Item<'hir> {\n     pub vis_span: Span,\n }\n \n-impl Item<'_> {\n+impl<'hir> Item<'hir> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n@@ -3005,6 +3057,132 @@ impl Item<'_> {\n     pub fn item_id(&self) -> ItemId {\n         ItemId { owner_id: self.owner_id }\n     }\n+\n+    /// Expect an [`ItemKind::ExternCrate`] or panic.\n+    #[track_caller]\n+    pub fn expect_extern_crate(&self) -> Option<Symbol> {\n+        let ItemKind::ExternCrate(s) = self.kind else { self.expect_failed(\"an extern crate\") };\n+        s\n+    }\n+\n+    /// Expect an [`ItemKind::Use`] or panic.\n+    #[track_caller]\n+    pub fn expect_use(&self) -> (&'hir UsePath<'hir>, UseKind) {\n+        let ItemKind::Use(p, uk) = self.kind else { self.expect_failed(\"a use\") };\n+        (p, uk)\n+    }\n+\n+    /// Expect an [`ItemKind::Static`] or panic.\n+    #[track_caller]\n+    pub fn expect_static(&self) -> (&'hir Ty<'hir>, Mutability, BodyId) {\n+        let ItemKind::Static(ty, mutbl, body) = self.kind else { self.expect_failed(\"a static\") };\n+        (ty, mutbl, body)\n+    }\n+    /// Expect an [`ItemKind::Const`] or panic.\n+    #[track_caller]\n+    pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n+        let ItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n+        (ty, body)\n+    }\n+    /// Expect an [`ItemKind::Fn`] or panic.\n+    #[track_caller]\n+    pub fn expect_fn(&self) -> (&FnSig<'hir>, &'hir Generics<'hir>, BodyId) {\n+        let ItemKind::Fn(sig, gen, body) = &self.kind else { self.expect_failed(\"a function\") };\n+        (sig, gen, *body)\n+    }\n+\n+    /// Expect an [`ItemKind::Macro`] or panic.\n+    #[track_caller]\n+    pub fn expect_macro(&self) -> (&ast::MacroDef, MacroKind) {\n+        let ItemKind::Macro(def, mk) = &self.kind else { self.expect_failed(\"a macro\") };\n+        (def, *mk)\n+    }\n+\n+    /// Expect an [`ItemKind::Mod`] or panic.\n+    #[track_caller]\n+    pub fn expect_mod(&self) -> &'hir Mod<'hir> {\n+        let ItemKind::Mod(m) = self.kind else { self.expect_failed(\"a module\") };\n+        m\n+    }\n+\n+    /// Expect an [`ItemKind::ForeignMod`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_mod(&self) -> (Abi, &'hir [ForeignItemRef]) {\n+        let ItemKind::ForeignMod { abi, items } = self.kind else { self.expect_failed(\"a foreign module\") };\n+        (abi, items)\n+    }\n+\n+    /// Expect an [`ItemKind::GlobalAsm`] or panic.\n+    #[track_caller]\n+    pub fn expect_global_asm(&self) -> &'hir InlineAsm<'hir> {\n+        let ItemKind::GlobalAsm(asm) = self.kind else { self.expect_failed(\"a global asm\") };\n+        asm\n+    }\n+\n+    /// Expect an [`ItemKind::TyAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty_alias(&self) -> (&'hir Ty<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::TyAlias(ty, gen) = self.kind else { self.expect_failed(\"a type alias\") };\n+        (ty, gen)\n+    }\n+\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n+    /// Expect an [`ItemKind::OpaqueTy`] or panic.\n+    #[track_caller]\n+    pub fn expect_opaque_ty(&self) -> &OpaqueTy<'hir> {\n+        let ItemKind::OpaqueTy(ty) = &self.kind else { self.expect_failed(\"an opaque type\") };\n+        ty\n+    }\n+\n+    /// Expect an [`ItemKind::Enum`] or panic.\n+    #[track_caller]\n+    pub fn expect_enum(&self) -> (&EnumDef<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Enum(def, gen) = &self.kind else { self.expect_failed(\"an enum\") };\n+        (def, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Struct`] or panic.\n+    #[track_caller]\n+    pub fn expect_struct(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Struct(data, gen) = &self.kind else { self.expect_failed(\"a struct\") };\n+        (data, gen)\n+    }\n+\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n+    /// Expect an [`ItemKind::Union`] or panic.\n+    #[track_caller]\n+    pub fn expect_union(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n+        let ItemKind::Union(data, gen) = &self.kind else { self.expect_failed(\"a union\") };\n+        (data, gen)\n+    }\n+\n+    /// Expect an [`ItemKind::Trait`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait(\n+        self,\n+    ) -> (IsAuto, Unsafety, &'hir Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]) {\n+        let ItemKind::Trait(is_auto, unsafety, gen, bounds, items) = self.kind else { self.expect_failed(\"a trait\") };\n+        (is_auto, unsafety, gen, bounds, items)\n+    }\n+\n+    /// Expect an [`ItemKind::TraitAlias`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_alias(&self) -> (&'hir Generics<'hir>, GenericBounds<'hir>) {\n+        let ItemKind::TraitAlias(gen, bounds) = self.kind else { self.expect_failed(\"a trait alias\") };\n+        (gen, bounds)\n+    }\n+\n+    /// Expect an [`ItemKind::Impl`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl(&self) -> &'hir Impl<'hir> {\n+        let ItemKind::Impl(imp) = self.kind else { self.expect_failed(\"an impl\") };\n+        imp\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -3524,6 +3702,13 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n+    pub fn alias_ty(self) -> Option<&'hir Ty<'hir>> {\n+        match self {\n+            Node::Item(Item { kind: ItemKind::TyAlias(ty, ..), .. }) => Some(ty),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n             Node::TraitItem(TraitItem {\n@@ -3590,6 +3775,185 @@ impl<'hir> Node<'hir> {\n     pub fn tuple_fields(&self) -> Option<&'hir [FieldDef<'hir>]> {\n         if let Node::Ctor(&VariantData::Tuple(fields, _, _)) = self { Some(fields) } else { None }\n     }\n+\n+    /// Expect a [`Node::Param`] or panic.\n+    #[track_caller]\n+    pub fn expect_param(self) -> &'hir Param<'hir> {\n+        let Node::Param(this) = self else { self.expect_failed(\"a parameter\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Item`] or panic.\n+    #[track_caller]\n+    pub fn expect_item(self) -> &'hir Item<'hir> {\n+        let Node::Item(this) = self else { self.expect_failed(\"a item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ForeignItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_foreign_item(self) -> &'hir ForeignItem<'hir> {\n+        let Node::ForeignItem(this) = self else { self.expect_failed(\"a foreign item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_item(self) -> &'hir TraitItem<'hir> {\n+        let Node::TraitItem(this) = self else { self.expect_failed(\"a trait item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::ImplItem`] or panic.\n+    #[track_caller]\n+    pub fn expect_impl_item(self) -> &'hir ImplItem<'hir> {\n+        let Node::ImplItem(this) = self else { self.expect_failed(\"an implementation item\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Variant`] or panic.\n+    #[track_caller]\n+    pub fn expect_variant(self) -> &'hir Variant<'hir> {\n+        let Node::Variant(this) = self else { self.expect_failed(\"a variant\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Field`] or panic.\n+    #[track_caller]\n+    pub fn expect_field(self) -> &'hir FieldDef<'hir> {\n+        let Node::Field(this) = self else { self.expect_failed(\"a field definition\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::AnonConst`] or panic.\n+    #[track_caller]\n+    pub fn expect_anon_const(self) -> &'hir AnonConst {\n+        let Node::AnonConst(this) = self else { self.expect_failed(\"an anonymous constant\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Expr`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr(self) -> &'hir Expr<'hir> {\n+        let Node::Expr(this) = self else { self.expect_failed(\"an expression\") };\n+        this\n+    }\n+    /// Expect a [`Node::ExprField`] or panic.\n+    #[track_caller]\n+    pub fn expect_expr_field(self) -> &'hir ExprField<'hir> {\n+        let Node::ExprField(this) = self else { self.expect_failed(\"an expression field\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Stmt`] or panic.\n+    #[track_caller]\n+    pub fn expect_stmt(self) -> &'hir Stmt<'hir> {\n+        let Node::Stmt(this) = self else { self.expect_failed(\"a statement\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PathSegment`] or panic.\n+    #[track_caller]\n+    pub fn expect_path_segment(self) -> &'hir PathSegment<'hir> {\n+        let Node::PathSegment(this) = self else { self.expect_failed(\"a path segment\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ty`] or panic.\n+    #[track_caller]\n+    pub fn expect_ty(self) -> &'hir Ty<'hir> {\n+        let Node::Ty(this) = self else { self.expect_failed(\"a type\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TypeBinding`] or panic.\n+    #[track_caller]\n+    pub fn expect_type_binding(self) -> &'hir TypeBinding<'hir> {\n+        let Node::TypeBinding(this) = self else { self.expect_failed(\"a type binding\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::TraitRef`] or panic.\n+    #[track_caller]\n+    pub fn expect_trait_ref(self) -> &'hir TraitRef<'hir> {\n+        let Node::TraitRef(this) = self else { self.expect_failed(\"a trait reference\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Pat`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat(self) -> &'hir Pat<'hir> {\n+        let Node::Pat(this) = self else { self.expect_failed(\"a pattern\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::PatField`] or panic.\n+    #[track_caller]\n+    pub fn expect_pat_field(self) -> &'hir PatField<'hir> {\n+        let Node::PatField(this) = self else { self.expect_failed(\"a pattern field\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Arm`] or panic.\n+    #[track_caller]\n+    pub fn expect_arm(self) -> &'hir Arm<'hir> {\n+        let Node::Arm(this) = self else { self.expect_failed(\"an arm\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Block`] or panic.\n+    #[track_caller]\n+    pub fn expect_block(self) -> &'hir Block<'hir> {\n+        let Node::Block(this) = self else { self.expect_failed(\"a block\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Local`] or panic.\n+    #[track_caller]\n+    pub fn expect_local(self) -> &'hir Local<'hir> {\n+        let Node::Local(this) = self else { self.expect_failed(\"a local\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Ctor`] or panic.\n+    #[track_caller]\n+    pub fn expect_ctor(self) -> &'hir VariantData<'hir> {\n+        let Node::Ctor(this) = self else { self.expect_failed(\"a constructor\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Lifetime`] or panic.\n+    #[track_caller]\n+    pub fn expect_lifetime(self) -> &'hir Lifetime {\n+        let Node::Lifetime(this) = self else { self.expect_failed(\"a lifetime\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::GenericParam`] or panic.\n+    #[track_caller]\n+    pub fn expect_generic_param(self) -> &'hir GenericParam<'hir> {\n+        let Node::GenericParam(this) = self else { self.expect_failed(\"a generic parameter\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Crate`] or panic.\n+    #[track_caller]\n+    pub fn expect_crate(self) -> &'hir Mod<'hir> {\n+        let Node::Crate(this) = self else { self.expect_failed(\"a crate\") };\n+        this\n+    }\n+\n+    /// Expect a [`Node::Infer`] or panic.\n+    #[track_caller]\n+    pub fn expect_infer(self) -> &'hir InferArg {\n+        let Node::Infer(this) = self else { self.expect_failed(\"an infer\") };\n+        this\n+    }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} node, found {self:?}\")\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "f632babab0b24476b299f943d74ef2462d42afa7", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -67,6 +67,7 @@\n use crate::hir::*;\n use rustc_ast::walk_list;\n use rustc_ast::{Attribute, Label};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n@@ -364,7 +365,7 @@ pub trait Visitor<'v>: Sized {\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl<'v>) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, _: Span, id: HirId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, _: Span, id: LocalDefId) {\n         walk_fn(self, fk, fd, b, id)\n     }\n     fn visit_use(&mut self, path: &'v UsePath<'v>, hir_id: HirId) {\n@@ -468,13 +469,16 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n-        ItemKind::Fn(ref sig, ref generics, body_id) => visitor.visit_fn(\n-            FnKind::ItemFn(item.ident, generics, sig.header),\n-            sig.decl,\n-            body_id,\n-            item.span,\n-            item.hir_id(),\n-        ),\n+        ItemKind::Fn(ref sig, ref generics, body_id) => {\n+            visitor.visit_id(item.hir_id());\n+            visitor.visit_fn(\n+                FnKind::ItemFn(item.ident, generics, sig.header),\n+                sig.decl,\n+                body_id,\n+                item.span,\n+                item.owner_id.def_id,\n+            )\n+        }\n         ItemKind::Macro(..) => {\n             visitor.visit_id(item.hir_id());\n         }\n@@ -733,7 +737,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             walk_list!(visitor, visit_arm, arms);\n         }\n         ExprKind::Closure(&Closure {\n-            def_id: _,\n+            def_id,\n             binder: _,\n             bound_generic_params,\n             fn_decl,\n@@ -745,7 +749,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n             constness: _,\n         }) => {\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n-            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n+            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, def_id)\n         }\n         ExprKind::Block(ref block, ref opt_label) => {\n             walk_list!(visitor, visit_label, opt_label);\n@@ -923,9 +927,8 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n     function_kind: FnKind<'v>,\n     function_declaration: &'v FnDecl<'v>,\n     body_id: BodyId,\n-    id: HirId,\n+    _: LocalDefId,\n ) {\n-    visitor.visit_id(id);\n     visitor.visit_fn_decl(function_declaration);\n     walk_fn_kind(visitor, function_kind);\n     visitor.visit_nested_body(body_id)\n@@ -953,26 +956,30 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n     let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n     let hir_id = trait_item.hir_id();\n     visitor.visit_ident(ident);\n-    visitor.visit_generics(generics);\n-    visitor.visit_defaultness(defaultness);\n+    visitor.visit_generics(&generics);\n+    visitor.visit_defaultness(&defaultness);\n+    visitor.visit_id(hir_id);\n     match *kind {\n         TraitItemKind::Const(ref ty, default) => {\n-            visitor.visit_id(hir_id);\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Required(param_names)) => {\n-            visitor.visit_id(hir_id);\n             visitor.visit_fn_decl(sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n             }\n         }\n         TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n-            visitor.visit_fn(FnKind::Method(ident, sig), sig.decl, body_id, span, hir_id);\n+            visitor.visit_fn(\n+                FnKind::Method(ident, sig),\n+                sig.decl,\n+                body_id,\n+                span,\n+                trait_item.owner_id.def_id,\n+            );\n         }\n         TraitItemKind::Type(bounds, ref default) => {\n-            visitor.visit_id(hir_id);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_ty, default);\n         }\n@@ -1002,9 +1009,9 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     visitor.visit_ident(ident);\n     visitor.visit_generics(generics);\n     visitor.visit_defaultness(defaultness);\n+    visitor.visit_id(impl_item.hir_id());\n     match *kind {\n         ImplItemKind::Const(ref ty, body) => {\n-            visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(body);\n         }\n@@ -1014,11 +1021,10 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n                 sig.decl,\n                 body_id,\n                 impl_item.span,\n-                impl_item.hir_id(),\n+                impl_item.owner_id.def_id,\n             );\n         }\n         ImplItemKind::Type(ref ty) => {\n-            visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n         }\n     }"}, {"sha": "9158fc082471f8fbedaf7e915fa998d83243215d", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -244,6 +244,14 @@ language_item_table! {\n     /// libstd panic entry point. Necessary for const eval to be able to catch it\n     BeginPanic,              sym::begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n \n+    // Lang items needed for `format_args!()`.\n+    FormatAlignment,         sym::format_alignment,    format_alignment,           Target::Enum,           GenericRequirement::None;\n+    FormatArgument,          sym::format_argument,     format_argument,            Target::Struct,         GenericRequirement::None;\n+    FormatArguments,         sym::format_arguments,    format_arguments,           Target::Struct,         GenericRequirement::None;\n+    FormatCount,             sym::format_count,        format_count,               Target::Enum,           GenericRequirement::None;\n+    FormatPlaceholder,       sym::format_placeholder,  format_placeholder,         Target::Struct,         GenericRequirement::None;\n+    FormatUnsafeArg,         sym::format_unsafe_arg,   format_unsafe_arg,          Target::Struct,         GenericRequirement::None;\n+\n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n     BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);"}, {"sha": "85d0e02d0b6834004ca51eacdd1bf62093e600e7", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -100,13 +100,8 @@ impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'\n         // `local_id_to_def_id` is also ignored because is dependent on the body, then just hashing\n         // the body satisfies the condition of two nodes being different have different\n         // `hash_stable` results.\n-        let OwnerNodes {\n-            hash_including_bodies,\n-            hash_without_bodies: _,\n-            nodes: _,\n-            bodies: _,\n-            local_id_to_def_id: _,\n-        } = *self;\n+        let OwnerNodes { hash_including_bodies, hash_without_bodies: _, nodes: _, bodies: _ } =\n+            *self;\n         hash_including_bodies.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "bec9f0ff0772cb8a9862d65f761f07282b4be2cf", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 63, "deletions": 48, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -27,7 +27,7 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n@@ -37,7 +37,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -54,7 +54,7 @@ use std::slice;\n pub struct PathSeg(pub DefId, pub usize);\n \n pub trait AstConv<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn item_def_id(&self) -> DefId;\n \n@@ -131,6 +131,8 @@ pub trait AstConv<'tcx> {\n     {\n         self\n     }\n+\n+    fn infcx(&self) -> Option<&InferCtxt<'tcx>>;\n }\n \n #[derive(Debug)]\n@@ -2132,48 +2134,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     )\n                     .emit() // Already reported in an earlier stage.\n                 } else {\n-                    // Find all the `impl`s that `qself_ty` has for any trait that has the\n-                    // associated type, so that we suggest the right one.\n-                    let infcx = tcx.infer_ctxt().build();\n-                    // We create a fresh `ty::ParamEnv` instead of the one for `self.item_def_id()`\n-                    // to avoid a cycle error in `src/test/ui/resolve/issue-102946.rs`.\n-                    let param_env = ty::ParamEnv::empty();\n-                    let traits: Vec<_> = self\n-                        .tcx()\n-                        .all_traits()\n-                        .filter(|trait_def_id| {\n-                            // Consider only traits with the associated type\n-                            tcx.associated_items(*trait_def_id)\n-                                .in_definition_order()\n-                                .any(|i| {\n-                                    i.kind.namespace() == Namespace::TypeNS\n-                                        && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n-                                        && matches!(i.kind, ty::AssocKind::Type)\n-                                })\n-                            // Consider only accessible traits\n-                            && tcx.visibility(*trait_def_id)\n-                                .is_accessible_from(self.item_def_id(), tcx)\n-                            && tcx.all_impls(*trait_def_id)\n-                                .any(|impl_def_id| {\n-                                    let trait_ref = tcx.impl_trait_ref(impl_def_id);\n-                                    trait_ref.map_or(false, |trait_ref| {\n-                                        let impl_ = trait_ref.subst(\n-                                            tcx,\n-                                            infcx.fresh_substs_for_item(span, impl_def_id),\n-                                        );\n-                                        infcx\n-                                            .can_eq(\n-                                                param_env,\n-                                                tcx.erase_regions(impl_.self_ty()),\n-                                                tcx.erase_regions(qself_ty),\n-                                            )\n-                                            .is_ok()\n-                                    })\n-                                    && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n-                                })\n-                        })\n-                        .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n-                        .collect();\n+                    let traits: Vec<_> =\n+                        self.probe_traits_that_match_assoc_ty(qself_ty, assoc_ident);\n \n                     // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(\n@@ -2232,6 +2194,60 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok((ty, DefKind::AssocTy, assoc_ty_did))\n     }\n \n+    fn probe_traits_that_match_assoc_ty(\n+        &self,\n+        qself_ty: Ty<'tcx>,\n+        assoc_ident: Ident,\n+    ) -> Vec<String> {\n+        let tcx = self.tcx();\n+\n+        // In contexts that have no inference context, just make a new one.\n+        // We do need a local variable to store it, though.\n+        let infcx_;\n+        let infcx = if let Some(infcx) = self.infcx() {\n+            infcx\n+        } else {\n+            assert!(!qself_ty.needs_infer());\n+            infcx_ = tcx.infer_ctxt().build();\n+            &infcx_\n+        };\n+\n+        tcx.all_traits()\n+            .filter(|trait_def_id| {\n+                // Consider only traits with the associated type\n+                tcx.associated_items(*trait_def_id)\n+                        .in_definition_order()\n+                        .any(|i| {\n+                            i.kind.namespace() == Namespace::TypeNS\n+                                && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident\n+                                && matches!(i.kind, ty::AssocKind::Type)\n+                        })\n+                    // Consider only accessible traits\n+                    && tcx.visibility(*trait_def_id)\n+                        .is_accessible_from(self.item_def_id(), tcx)\n+                    && tcx.all_impls(*trait_def_id)\n+                        .any(|impl_def_id| {\n+                            let trait_ref = tcx.impl_trait_ref(impl_def_id);\n+                            trait_ref.map_or(false, |trait_ref| {\n+                                let impl_ = trait_ref.subst(\n+                                    tcx,\n+                                    infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n+                                );\n+                                infcx\n+                                    .can_eq(\n+                                        ty::ParamEnv::empty(),\n+                                        tcx.erase_regions(impl_.self_ty()),\n+                                        tcx.erase_regions(qself_ty),\n+                                    )\n+                                    .is_ok()\n+                            })\n+                            && tcx.impl_polarity(impl_def_id) != ty::ImplPolarity::Negative\n+                        })\n+            })\n+            .map(|trait_def_id| tcx.def_path_str(trait_def_id))\n+            .collect()\n+    }\n+\n     fn lookup_assoc_ty(\n         &self,\n         ident: Ident,\n@@ -3124,8 +3140,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), ident, .. }) =\n             hir.get(fn_hir_id) else { return None };\n-        let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n-                hir.get_parent(fn_hir_id) else { bug!(\"ImplItem should have Impl parent\") };\n+        let i = hir.get_parent(fn_hir_id).expect_item().expect_impl();\n \n         let trait_ref = self.instantiate_mono_trait_ref(\n             i.of_trait.as_ref()?,\n@@ -3140,7 +3155,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_ref.def_id,\n         )?;\n \n-        let fn_sig = tcx.bound_fn_sig(assoc.def_id).subst(\n+        let fn_sig = tcx.fn_sig(assoc.def_id).subst(\n             tcx,\n             trait_ref.substs.extend_to(tcx, assoc.def_id, |param, _| tcx.mk_param_from_def(param)),\n         );"}, {"sha": "a5c96a8b01613aa42a51389536b4abfad7b3b0fa", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -2,11 +2,11 @@ use crate::errors::AutoDerefReachedRecursionLimit;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::NormalizeExt;\n use crate::traits::{self, TraitEngine, TraitEngineExt};\n-use rustc_hir as hir;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::Limit;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::Span;\n \n@@ -28,7 +28,7 @@ pub struct Autoderef<'a, 'tcx> {\n     // Meta infos:\n     infcx: &'a InferCtxt<'tcx>,\n     span: Span,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n \n     // Current state:\n@@ -96,14 +96,14 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     pub fn new(\n         infcx: &'a InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_def_id: LocalDefId,\n         span: Span,\n         base_ty: Ty<'tcx>,\n     ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             span,\n-            body_id,\n+            body_id: body_def_id,\n             param_env,\n             state: AutoderefSnapshot {\n                 steps: vec![],"}, {"sha": "6f4ebc987e6a97ee0951550e5c894f76a68f8f41", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n-use rustc_infer::traits::Obligation;\n+use rustc_infer::traits::{Obligation, TraitEngineExt as _};\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::stability::EvalResult;\n@@ -28,7 +28,7 @@ use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCtxt};\n+use rustc_trait_selection::traits::{self, ObligationCtxt, TraitEngine, TraitEngineExt as _};\n \n use std::ops::ControlFlow;\n \n@@ -412,7 +412,6 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n         hir::OpaqueTyOrigin::TyAlias => def_id,\n@@ -438,7 +437,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         _ => re,\n     });\n \n-    let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+    let misc_cause = traits::ObligationCause::misc(span, def_id);\n \n     match ocx.eq(&misc_cause, param_env, opaque_ty, hidden_ty) {\n         Ok(()) => {}\n@@ -666,7 +665,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n         DefKind::GlobalAsm => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::GlobalAsm(asm) = it.kind else { span_bug!(it.span, \"DefKind::GlobalAsm but got {:#?}\", it) };\n-            InlineAsmCtxt::new_global_asm(tcx).check_asm(asm, id.hir_id());\n+            InlineAsmCtxt::new_global_asm(tcx).check_asm(asm, id.owner_id.def_id);\n         }\n         _ => {}\n     }\n@@ -1461,7 +1460,8 @@ fn opaque_type_cycle_error(\n                 for def_id in visitor.opaques {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n-                        err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n+                        let descr = if ty.is_impl_trait() { \"opaque \" } else { \"\" };\n+                        err.span_label(ty_span, &format!(\"returning this {descr}type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n                     err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n@@ -1508,3 +1508,34 @@ fn opaque_type_cycle_error(\n     }\n     err.emit()\n }\n+\n+pub(super) fn check_generator_obligations(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    debug_assert!(tcx.sess.opts.unstable_opts.drop_tracking_mir);\n+    debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Generator));\n+\n+    let typeck = tcx.typeck(def_id);\n+    let param_env = tcx.param_env(def_id);\n+\n+    let generator_interior_predicates = &typeck.generator_interior_predicates[&def_id];\n+    debug!(?generator_interior_predicates);\n+\n+    let infcx = tcx\n+        .infer_ctxt()\n+        // typeck writeback gives us predicates with their regions erased.\n+        // As borrowck already has checked lifetimes, we do not need to do it again.\n+        .ignoring_regions()\n+        // Bind opaque types to `def_id` as they should have been checked by borrowck.\n+        .with_opaque_type_inference(DefiningAnchor::Bind(def_id))\n+        .build();\n+\n+    let mut fulfillment_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+    for (predicate, cause) in generator_interior_predicates {\n+        let obligation = Obligation::new(tcx, cause.clone(), param_env, *predicate);\n+        fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+    }\n+    let errors = fulfillment_cx.select_all_or_error(&infcx);\n+    debug!(?errors);\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+    }\n+}"}, {"sha": "3115f5f464a09c44969f09a03cd1d81db92dd27a", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n-use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc_hir::{GenericParamKind, ImplItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n@@ -147,12 +147,12 @@ fn compare_method_predicate_entailment<'tcx>(\n     //\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n-    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+    let impl_m_def_id = impl_m.def_id.expect_local();\n     let cause = ObligationCause::new(\n         impl_m_span,\n-        impl_m_hir_id,\n+        impl_m_def_id,\n         ObligationCauseCode::CompareImplItemObligation {\n-            impl_item_def_id: impl_m.def_id.expect_local(),\n+            impl_item_def_id: impl_m_def_id,\n             trait_item_def_id: trait_m.def_id,\n             kind: impl_m.kind,\n         },\n@@ -198,7 +198,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n@@ -213,14 +213,14 @@ fn compare_method_predicate_entailment<'tcx>(\n \n     let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_placeholder_substs);\n     for (predicate, span) in impl_m_own_bounds {\n-        let normalize_cause = traits::ObligationCause::misc(span, impl_m_hir_id);\n+        let normalize_cause = traits::ObligationCause::misc(span, impl_m_def_id);\n         let predicate = ocx.normalize(&normalize_cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n-            impl_m_hir_id,\n+            impl_m_def_id,\n             ObligationCauseCode::CompareImplItemObligation {\n-                impl_item_def_id: impl_m.def_id.expect_local(),\n+                impl_item_def_id: impl_m_def_id,\n                 trait_item_def_id: trait_m.def_id,\n                 kind: impl_m.kind,\n             },\n@@ -249,15 +249,15 @@ fn compare_method_predicate_entailment<'tcx>(\n     let unnormalized_impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n         impl_m_span,\n         infer::HigherRankedType,\n-        tcx.fn_sig(impl_m.def_id),\n+        tcx.fn_sig(impl_m.def_id).subst_identity(),\n     );\n     let unnormalized_impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(unnormalized_impl_sig));\n \n-    let norm_cause = ObligationCause::misc(impl_m_span, impl_m_hir_id);\n+    let norm_cause = ObligationCause::misc(impl_m_span, impl_m_def_id);\n     let impl_sig = ocx.normalize(&norm_cause, param_env, unnormalized_impl_sig);\n     debug!(\"compare_impl_method: impl_fty={:?}\", impl_sig);\n \n-    let trait_sig = tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n+    let trait_sig = tcx.fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs);\n     let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, trait_sig);\n \n     // Next, add all inputs and output as well-formed tys. Importantly,\n@@ -311,6 +311,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     if !errors.is_empty() {\n         match check_implied_wf {\n             CheckImpliedWfMode::Check => {\n+                let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n                 return compare_method_predicate_entailment(\n                     tcx,\n                     impl_m,\n@@ -336,7 +337,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys.clone()),\n+        infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n         outlives_env.region_bound_pairs(),\n@@ -346,6 +347,7 @@ fn compare_method_predicate_entailment<'tcx>(\n     if !errors.is_empty() {\n         // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n         // becomes a hard error (i.e. ideally we'd just call `resolve_regions_and_report_errors`\n+        let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n         match check_implied_wf {\n             CheckImpliedWfMode::Check => {\n                 return compare_method_predicate_entailment(\n@@ -371,7 +373,7 @@ fn compare_method_predicate_entailment<'tcx>(\n             }\n             CheckImpliedWfMode::Skip => {\n                 if infcx.tainted_by_errors().is_none() {\n-                    infcx.err_ctxt().report_region_errors(impl_m.def_id.expect_local(), &errors);\n+                    infcx.err_ctxt().report_region_errors(impl_m_def_id, &errors);\n                 }\n                 return Err(tcx\n                     .sess\n@@ -420,8 +422,8 @@ fn extract_bad_args_for_implies_lint<'tcx>(\n \n     // Map late-bound regions from trait to impl, so the names are right.\n     let mapping = std::iter::zip(\n-        tcx.fn_sig(trait_m.def_id).bound_vars(),\n-        tcx.fn_sig(impl_m.def_id).bound_vars(),\n+        tcx.fn_sig(trait_m.def_id).skip_binder().bound_vars(),\n+        tcx.fn_sig(impl_m.def_id).skip_binder().bound_vars(),\n     )\n     .filter_map(|(impl_bv, trait_bv)| {\n         if let ty::BoundVariableKind::Region(impl_bv) = impl_bv\n@@ -538,7 +540,7 @@ fn compare_asyncness<'tcx>(\n     trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n     if tcx.asyncness(trait_m.def_id) == hir::IsAsync::Async {\n-        match tcx.fn_sig(impl_m.def_id).skip_binder().output().kind() {\n+        match tcx.fn_sig(impl_m.def_id).skip_binder().skip_binder().output().kind() {\n             ty::Alias(ty::Opaque, ..) => {\n                 // allow both `async fn foo()` and `fn foo() -> impl Future`\n             }\n@@ -610,13 +612,14 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n \n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n-    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+    let impl_m_def_id = impl_m.def_id.expect_local();\n+    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n     let cause = ObligationCause::new(\n         return_span,\n-        impl_m_hir_id,\n+        impl_m_def_id,\n         ObligationCauseCode::CompareImplItemObligation {\n-            impl_item_def_id: impl_m.def_id.expect_local(),\n+            impl_item_def_id: impl_m_def_id,\n             trait_item_def_id: trait_m.def_id,\n             kind: impl_m.kind,\n         },\n@@ -633,14 +636,14 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let ocx = ObligationCtxt::new(infcx);\n \n     // Normalize the impl signature with fresh variables for lifetime inference.\n-    let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n+    let norm_cause = ObligationCause::misc(return_span, impl_m_def_id);\n     let impl_sig = ocx.normalize(\n         &norm_cause,\n         param_env,\n         infcx.replace_bound_vars_with_fresh_vars(\n             return_span,\n             infer::HigherRankedType,\n-            tcx.fn_sig(impl_m.def_id),\n+            tcx.fn_sig(impl_m.def_id).subst_identity(),\n         ),\n     );\n     impl_sig.error_reported()?;\n@@ -650,11 +653,11 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // the ImplTraitInTraitCollector, which gathers all of the RPITITs and replaces\n     // them with inference variables.\n     // We will use these inference variables to collect the hidden types of RPITITs.\n-    let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n+    let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_def_id);\n     let unnormalized_trait_sig = tcx\n         .liberate_late_bound_regions(\n             impl_m.def_id,\n-            tcx.bound_fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n+            tcx.fn_sig(trait_m.def_id).subst(tcx, trait_to_placeholder_substs),\n         )\n         .fold_with(&mut collector);\n     let trait_sig = ocx.normalize(&norm_cause, param_env, unnormalized_trait_sig);\n@@ -732,12 +735,11 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n         Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys),\n+        infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n-    infcx.err_ctxt().check_region_obligations_and_report_errors(\n-        impl_m.def_id.expect_local(),\n-        &outlives_environment,\n-    )?;\n+    infcx\n+        .err_ctxt()\n+        .check_region_obligations_and_report_errors(impl_m_def_id, &outlives_environment)?;\n \n     let mut collected_tys = FxHashMap::default();\n     for (def_id, (ty, substs)) in collector.types {\n@@ -819,15 +821,15 @@ struct ImplTraitInTraitCollector<'a, 'tcx> {\n     types: FxHashMap<DefId, (Ty<'tcx>, ty::SubstsRef<'tcx>)>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_id: hir::HirId,\n+    body_id: LocalDefId,\n }\n \n impl<'a, 'tcx> ImplTraitInTraitCollector<'a, 'tcx> {\n     fn new(\n         ocx: &'a ObligationCtxt<'a, 'tcx>,\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n     ) -> Self {\n         ImplTraitInTraitCollector { ocx, types: FxHashMap::default(), span, param_env, body_id }\n     }\n@@ -916,7 +918,7 @@ fn report_trait_method_mismatch<'tcx>(\n             // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n             // span points only at the type `Box<Self`>, but we want to cover the whole\n             // argument pattern and type.\n-            let ImplItemKind::Fn(ref sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{impl_m:?} is not a method\") };\n+            let (sig, body) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n             let span = tcx\n                 .hir()\n                 .body_param_names(body)\n@@ -1078,12 +1080,12 @@ fn extract_spans_for_error_reporting<'tcx>(\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let mut impl_args = {\n-        let ImplItemKind::Fn(sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (sig, _) = tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     };\n \n     let trait_args = trait_m.def_id.as_local().map(|def_id| {\n-        let TraitItemKind::Fn(sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m) };\n+        let (sig, _) = tcx.hir().expect_trait_item(def_id).expect_fn();\n         sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n     });\n \n@@ -1115,7 +1117,7 @@ fn compare_self_type<'tcx>(\n             ty::ImplContainer => impl_trait_ref.self_ty(),\n             ty::TraitContainer => tcx.types.self_param,\n         };\n-        let self_arg_ty = tcx.fn_sig(method.def_id).input(0);\n+        let self_arg_ty = tcx.fn_sig(method.def_id).subst_identity().input(0);\n         let param_env = ty::ParamEnv::reveal_all();\n \n         let infcx = tcx.infer_ctxt().build();\n@@ -1348,15 +1350,15 @@ fn compare_number_of_method_arguments<'tcx>(\n ) -> Result<(), ErrorGuaranteed> {\n     let impl_m_fty = tcx.fn_sig(impl_m.def_id);\n     let trait_m_fty = tcx.fn_sig(trait_m.def_id);\n-    let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n-    let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n+    let trait_number_args = trait_m_fty.skip_binder().inputs().skip_binder().len();\n+    let impl_number_args = impl_m_fty.skip_binder().inputs().skip_binder().len();\n \n     if trait_number_args != impl_number_args {\n         let trait_span = trait_m\n             .def_id\n             .as_local()\n             .and_then(|def_id| {\n-                let TraitItemKind::Fn(trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+                let (trait_m_sig, _) = &tcx.hir().expect_trait_item(def_id).expect_fn();\n                 let pos = trait_number_args.saturating_sub(1);\n                 trait_m_sig.decl.inputs.get(pos).map(|arg| {\n                     if pos == 0 {\n@@ -1368,7 +1370,7 @@ fn compare_number_of_method_arguments<'tcx>(\n             })\n             .or(trait_item_span);\n \n-        let ImplItemKind::Fn(impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind else { bug!(\"{:?} is not a method\", impl_m) };\n+        let (impl_m_sig, _) = &tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).expect_fn();\n         let pos = impl_number_args.saturating_sub(1);\n         let impl_span = impl_m_sig\n             .decl\n@@ -1504,7 +1506,7 @@ fn compare_synthetic_generics<'tcx>(\n                     let _: Option<_> = try {\n                         let impl_m = impl_m.def_id.as_local()?;\n                         let impl_m = tcx.hir().expect_impl_item(impl_m);\n-                        let hir::ImplItemKind::Fn(sig, _) = &impl_m.kind else { unreachable!() };\n+                        let (sig, _) = impl_m.expect_fn();\n                         let input_tys = sig.decl.inputs;\n \n                         struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n@@ -1671,14 +1673,12 @@ pub(super) fn compare_impl_const_raw(\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_const_item_def);\n-\n     // Compute placeholder form of impl and trait const tys.\n     let impl_ty = tcx.type_of(impl_const_item_def.to_def_id());\n     let trait_ty = tcx.bound_type_of(trait_const_item_def).subst(tcx, trait_to_impl_substs);\n     let mut cause = ObligationCause::new(\n         impl_c_span,\n-        impl_c_hir_id,\n+        impl_const_item_def,\n         ObligationCauseCode::CompareImplItemObligation {\n             impl_item_def_id: impl_const_item_def,\n             trait_item_def_id: trait_const_item_def,\n@@ -1704,7 +1704,7 @@ pub(super) fn compare_impl_const_raw(\n         );\n \n         // Locate the Span containing just the type of the offending impl\n-        let ImplItemKind::Const(ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).kind else { bug!(\"{impl_const_item:?} is not a impl const\") };\n+        let (ty, _) = tcx.hir().expect_impl_item(impl_const_item_def).expect_const();\n         cause.span = ty.span;\n \n         let mut diag = struct_span_err!(\n@@ -1717,7 +1717,7 @@ pub(super) fn compare_impl_const_raw(\n \n         let trait_c_span = trait_const_item_def.as_local().map(|trait_c_def_id| {\n             // Add a label to the Span containing just the type of the const\n-            let TraitItemKind::Const(ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).kind else { bug!(\"{trait_const_item:?} is not a trait const\") };\n+            let (ty, _) = tcx.hir().expect_trait_item(trait_c_def_id).expect_const();\n             ty.span\n         });\n \n@@ -1799,7 +1799,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // This `HirId` should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n+    let impl_ty_def_id = impl_ty.def_id.expect_local();\n     debug!(\"compare_type_predicate_entailment: trait_to_impl_substs={:?}\", trait_to_impl_substs);\n \n     // The predicates declared by the impl definition, the trait and the\n@@ -1814,7 +1814,7 @@ fn compare_type_predicate_entailment<'tcx>(\n \n     debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n \n-    let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_hir_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_def_id);\n     let param_env = ty::ParamEnv::new(\n         tcx.intern_predicates(&hybrid_preds.predicates),\n         Reveal::UserFacing,\n@@ -1827,12 +1827,12 @@ fn compare_type_predicate_entailment<'tcx>(\n     debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n     for (predicate, span) in impl_ty_own_bounds {\n-        let cause = ObligationCause::misc(span, impl_ty_hir_id);\n+        let cause = ObligationCause::misc(span, impl_ty_def_id);\n         let predicate = ocx.normalize(&cause, param_env, predicate);\n \n         let cause = ObligationCause::new(\n             span,\n-            impl_ty_hir_id,\n+            impl_ty_def_id,\n             ObligationCauseCode::CompareImplItemObligation {\n                 impl_item_def_id: impl_ty.def_id.expect_local(),\n                 trait_item_def_id: trait_ty.def_id,\n@@ -2008,7 +2008,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     };\n     debug!(?normalize_param_env);\n \n-    let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n+    let impl_ty_def_id = impl_ty.def_id.expect_local();\n     let impl_ty_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n     let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n \n@@ -2020,7 +2020,7 @@ pub(super) fn check_type_bounds<'tcx>(\n \n     let normalize_cause = ObligationCause::new(\n         impl_ty_span,\n-        impl_ty_hir_id,\n+        impl_ty_def_id,\n         ObligationCauseCode::CheckAssociatedTypeBounds {\n             impl_item_def_id: impl_ty.def_id.expect_local(),\n             trait_item_def_id: trait_ty.def_id,\n@@ -2032,7 +2032,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         } else {\n             traits::BindingObligation(trait_ty.def_id, span)\n         };\n-        ObligationCause::new(impl_ty_span, impl_ty_hir_id, code)\n+        ObligationCause::new(impl_ty_span, impl_ty_def_id, code)\n     };\n \n     let obligations = tcx\n@@ -2063,7 +2063,7 @@ pub(super) fn check_type_bounds<'tcx>(\n \n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n-    let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_hir_id, assumed_wf_types);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n     let outlives_environment =\n         OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n "}, {"sha": "955cacf03b1c676f5dfa32fca091b84497f4b825", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -56,8 +56,14 @@ fn equate_intrinsic_type<'tcx>(\n         && gen_count_ok(own_counts.consts, 0, \"const\")\n     {\n         let fty = tcx.mk_fn_ptr(sig);\n-        let cause = ObligationCause::new(it.span, it.hir_id(), ObligationCauseCode::IntrinsicType);\n-        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id)), fty);\n+        let it_def_id = it.owner_id.def_id;\n+        let cause = ObligationCause::new(it.span, it_def_id, ObligationCauseCode::IntrinsicType);\n+        require_same_types(\n+            tcx,\n+            &cause,\n+            tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id).subst_identity()),\n+            fty,\n+        );\n     }\n }\n "}, {"sha": "122b6ead8e9d7f8432a6078cf2b58a318b63db93", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,6 +3,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n use rustc_session::lint;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::{Symbol, DUMMY_SP};\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n \n@@ -253,10 +254,8 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n         Some(asm_ty)\n     }\n \n-    pub fn check_asm(&self, asm: &hir::InlineAsm<'tcx>, enclosing_id: hir::HirId) {\n-        let hir = self.tcx.hir();\n-        let enclosing_def_id = hir.local_def_id(enclosing_id).to_def_id();\n-        let target_features = self.tcx.asm_target_features(enclosing_def_id);\n+    pub fn check_asm(&self, asm: &hir::InlineAsm<'tcx>, enclosing_id: LocalDefId) {\n+        let target_features = self.tcx.asm_target_features(enclosing_id.to_def_id());\n         let Some(asm_arch) = self.tcx.sess.asm_arch else {\n             self.tcx.sess.delay_span_bug(DUMMY_SP, \"target architecture does not support asm\");\n             return;"}, {"sha": "bec693439a46c1d26a3ec9ba2753d71d9f75fe64", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -105,6 +105,7 @@ pub fn provide(providers: &mut Providers) {\n         region_scope_tree,\n         collect_return_position_impl_trait_in_trait_tys,\n         compare_impl_const: compare_impl_item::compare_impl_const_raw,\n+        check_generator_obligations: check::check_generator_obligations,\n         ..*providers\n     };\n }\n@@ -445,7 +446,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n             // regions just fine, showing `fn(&MyType)`.\n             fn_sig_suggestion(\n                 tcx,\n-                tcx.fn_sig(assoc.def_id).skip_binder(),\n+                tcx.fn_sig(assoc.def_id).subst_identity().skip_binder(),\n                 assoc.ident(tcx),\n                 tcx.predicates_of(assoc.def_id),\n                 assoc,"}, {"sha": "5b9b57da3820e48e8a2c42a8364db3971384d272", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 64, "deletions": 47, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -37,7 +37,7 @@ use std::ops::{ControlFlow, Deref};\n pub(super) struct WfCheckingCtxt<'a, 'tcx> {\n     pub(super) ocx: ObligationCtxt<'a, 'tcx>,\n     span: Span,\n-    body_id: hir::HirId,\n+    body_def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n impl<'a, 'tcx> Deref for WfCheckingCtxt<'a, 'tcx> {\n@@ -59,7 +59,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         self.ocx.normalize(\n-            &ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc)),\n+            &ObligationCause::new(span, self.body_def_id, ObligationCauseCode::WellFormed(loc)),\n             self.param_env,\n             value,\n         )\n@@ -71,8 +71,11 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         loc: Option<WellFormedLoc>,\n         arg: ty::GenericArg<'tcx>,\n     ) {\n-        let cause =\n-            traits::ObligationCause::new(span, self.body_id, ObligationCauseCode::WellFormed(loc));\n+        let cause = traits::ObligationCause::new(\n+            span,\n+            self.body_def_id,\n+            ObligationCauseCode::WellFormed(loc),\n+        );\n         // for a type to be WF, we do not need to check if const trait predicates satisfy.\n         let param_env = self.param_env.without_const();\n         self.ocx.register_obligation(traits::Obligation::new(\n@@ -93,19 +96,18 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     F: for<'a> FnOnce(&WfCheckingCtxt<'a, 'tcx>),\n {\n     let param_env = tcx.param_env(body_def_id);\n-    let body_id = tcx.hir().local_def_id_to_hir_id(body_def_id);\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n \n-    let mut wfcx = WfCheckingCtxt { ocx, span, body_id, param_env };\n+    let mut wfcx = WfCheckingCtxt { ocx, span, body_def_id, param_env };\n \n     if !tcx.features().trivial_bounds {\n         wfcx.check_false_global_bounds()\n     }\n     f(&mut wfcx);\n \n     let assumed_wf_types = wfcx.ocx.assumed_wf_types(param_env, span, body_def_id);\n-    let implied_bounds = infcx.implied_bounds_tys(param_env, body_id, assumed_wf_types);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, body_def_id, assumed_wf_types);\n \n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n@@ -374,7 +376,6 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                     continue;\n                 }\n \n-                let item_hir_id = item.id.hir_id();\n                 let param_env = tcx.param_env(item_def_id);\n \n                 let item_required_bounds = match item.kind {\n@@ -385,12 +386,12 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                         // `Self::Iter<'a>` is a GAT we want to gather any potential missing bounds from.\n                         let sig: ty::FnSig<'_> = tcx.liberate_late_bound_regions(\n                             item_def_id.to_def_id(),\n-                            tcx.fn_sig(item_def_id),\n+                            tcx.fn_sig(item_def_id).subst_identity(),\n                         );\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n-                            item_hir_id,\n+                            item_def_id,\n                             sig.inputs_and_output,\n                             // We also assume that all of the function signature's parameter types\n                             // are well formed.\n@@ -412,7 +413,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                         gather_gat_bounds(\n                             tcx,\n                             param_env,\n-                            item_hir_id,\n+                            item_def_id,\n                             tcx.explicit_item_bounds(item_def_id).to_vec(),\n                             &FxIndexSet::default(),\n                             gat_def_id.def_id,\n@@ -458,21 +459,32 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n         let gat_item_hir = tcx.hir().expect_trait_item(gat_def_id.def_id);\n         debug!(?required_bounds);\n         let param_env = tcx.param_env(gat_def_id);\n-        let gat_hir = gat_item_hir.hir_id();\n \n         let mut unsatisfied_bounds: Vec<_> = required_bounds\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n                     a,\n                     b,\n-                ))) => {\n-                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n-                }\n+                ))) => !region_known_to_outlive(\n+                    tcx,\n+                    gat_def_id.def_id,\n+                    param_env,\n+                    &FxIndexSet::default(),\n+                    a,\n+                    b,\n+                ),\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n                     a,\n                     b,\n-                ))) => !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b),\n+                ))) => !ty_known_to_outlive(\n+                    tcx,\n+                    gat_def_id.def_id,\n+                    param_env,\n+                    &FxIndexSet::default(),\n+                    a,\n+                    b,\n+                ),\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n             .map(|clause| clause.to_string())\n@@ -551,7 +563,7 @@ fn augment_param_env<'tcx>(\n fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    item_hir: hir::HirId,\n+    item_def_id: hir::OwnerId,\n     to_check: T,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     gat_def_id: LocalDefId,\n@@ -584,7 +596,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n         // reflected in a where clause on the GAT itself.\n         for (ty, ty_idx) in &types {\n             // In our example, requires that `Self: 'a`\n-            if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n+            if ty_known_to_outlive(tcx, item_def_id.def_id, param_env, &wf_tys, *ty, *region_a) {\n                 debug!(?ty_idx, ?region_a_idx);\n                 debug!(\"required clause: {ty} must outlive {region_a}\");\n                 // Translate into the generic parameters of the GAT. In\n@@ -622,7 +634,14 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             if ty::ReStatic == **region_b || region_a == region_b {\n                 continue;\n             }\n-            if region_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *region_a, *region_b) {\n+            if region_known_to_outlive(\n+                tcx,\n+                item_def_id.def_id,\n+                param_env,\n+                &wf_tys,\n+                *region_a,\n+                *region_b,\n+            ) {\n                 debug!(?region_a_idx, ?region_b_idx);\n                 debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT.\n@@ -658,7 +677,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n+    id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     ty: Ty<'tcx>,\n@@ -675,7 +694,7 @@ fn ty_known_to_outlive<'tcx>(\n /// `region_a` outlives `region_b`\n fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n+    id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n@@ -699,7 +718,7 @@ fn region_known_to_outlive<'tcx>(\n /// to be tested), then resolve region and return errors\n fn resolve_regions_with_wf_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    id: hir::HirId,\n+    id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxIndexSet<Ty<'tcx>>,\n     add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'tcx>, &'a RegionBoundPairs<'tcx>),\n@@ -822,7 +841,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n         _ => {}\n     }\n     if !trait_should_be_self.is_empty() {\n-        if tcx.object_safety_violations(trait_def_id).is_empty() {\n+        if tcx.check_is_object_safe(trait_def_id) {\n             return;\n         }\n         let sugg = trait_should_be_self.iter().map(|span| (*span, \"Self\".to_string())).collect();\n@@ -1006,7 +1025,7 @@ fn check_associated_item(\n                 wfcx.register_wf_obligation(span, loc, ty.into());\n             }\n             ty::AssocKind::Fn => {\n-                let sig = tcx.fn_sig(item.def_id);\n+                let sig = tcx.fn_sig(item.def_id).subst_identity();\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n                     wfcx,\n@@ -1053,8 +1072,8 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             // All field types must be well-formed.\n             for field in &variant.fields {\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n                     hir_ty.span,\n@@ -1087,13 +1106,13 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             {\n                 let last = idx == variant.fields.len() - 1;\n                 let field_id = field.did.expect_local();\n-                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n-                else { bug!() };\n+                let hir::FieldDef { ty: hir_ty, .. } =\n+                    tcx.hir().get_by_def_id(field_id).expect_field();\n                 let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n                         hir_ty.span,\n-                        wfcx.body_id,\n+                        wfcx.body_def_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n@@ -1113,7 +1132,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n-                    wfcx.body_id,\n+                    wfcx.body_def_id,\n                     traits::MiscObligation,\n                 );\n                 wfcx.register_obligation(traits::Obligation::new(\n@@ -1174,7 +1193,7 @@ fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: &ty::AssocI\n         traits::wf::predicate_obligations(\n             wfcx.infcx,\n             wfcx.param_env,\n-            wfcx.body_id,\n+            wfcx.body_def_id,\n             normalized_bound,\n             bound_span,\n         )\n@@ -1191,7 +1210,7 @@ fn check_item_fn(\n     decl: &hir::FnDecl<'_>,\n ) {\n     enter_wf_checking_ctxt(tcx, span, def_id, |wfcx| {\n-        let sig = tcx.fn_sig(def_id);\n+        let sig = tcx.fn_sig(def_id).subst_identity();\n         check_fn_or_method(wfcx, ident.span, sig, decl, def_id);\n     })\n }\n@@ -1214,7 +1233,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n         wfcx.register_wf_obligation(ty_span, Some(WellFormedLoc::Ty(item_id)), item_ty.into());\n         if forbid_unsized {\n             wfcx.register_bound(\n-                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::WellFormed(None)),\n+                traits::ObligationCause::new(ty_span, wfcx.body_def_id, traits::WellFormed(None)),\n                 wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sized, None),\n@@ -1229,7 +1248,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: LocalDefId, ty_span: Span, allow_fo\n \n         if should_check_for_sync {\n             wfcx.register_bound(\n-                traits::ObligationCause::new(ty_span, wfcx.body_id, traits::SharedStatic),\n+                traits::ObligationCause::new(ty_span, wfcx.body_def_id, traits::SharedStatic),\n                 wfcx.param_env,\n                 item_ty,\n                 tcx.require_lang_item(LangItem::Sync, Some(ty_span)),\n@@ -1269,7 +1288,7 @@ fn check_impl<'tcx>(\n                 let mut obligations = traits::wf::trait_obligations(\n                     wfcx.infcx,\n                     wfcx.param_env,\n-                    wfcx.body_id,\n+                    wfcx.body_def_id,\n                     &trait_pred,\n                     ast_trait_ref.path.span,\n                     item,\n@@ -1466,7 +1485,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n             let pred = wfcx.normalize(sp, None, pred);\n             let cause = traits::ObligationCause::new(\n                 sp,\n-                wfcx.body_id,\n+                wfcx.body_def_id,\n                 traits::ItemObligation(def_id.to_def_id()),\n             );\n             traits::Obligation::new(tcx, cause, wfcx.param_env, pred)\n@@ -1482,12 +1501,11 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n         traits::wf::predicate_obligations(\n             infcx,\n             wfcx.param_env.without_const(),\n-            wfcx.body_id,\n+            wfcx.body_def_id,\n             p,\n             sp,\n         )\n     });\n-\n     let obligations: Vec<_> = wf_obligations.chain(default_obligations).collect();\n     wfcx.register_obligations(obligations);\n }\n@@ -1549,7 +1567,7 @@ fn check_fn_or_method<'tcx>(\n         // Check that the argument is a tuple\n         if let Some(ty) = inputs.next() {\n             wfcx.register_bound(\n-                ObligationCause::new(span, wfcx.body_id, ObligationCauseCode::RustCall),\n+                ObligationCause::new(span, wfcx.body_def_id, ObligationCauseCode::RustCall),\n                 wfcx.param_env,\n                 *ty,\n                 tcx.require_lang_item(hir::LangItem::Tuple, Some(span)),\n@@ -1597,7 +1615,7 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n                     traits::wf::predicate_obligations(\n                         wfcx.infcx,\n                         wfcx.param_env,\n-                        wfcx.body_id,\n+                        wfcx.body_def_id,\n                         normalized_bound,\n                         bound_span,\n                     )\n@@ -1627,7 +1645,7 @@ fn check_method_receiver<'tcx>(\n \n     let span = fn_sig.decl.inputs[0].span;\n \n-    let sig = tcx.fn_sig(method.def_id);\n+    let sig = tcx.fn_sig(method.def_id).subst_identity();\n     let sig = tcx.liberate_late_bound_regions(method.def_id, sig);\n     let sig = wfcx.normalize(span, None, sig);\n \n@@ -1697,7 +1715,7 @@ fn receiver_is_valid<'tcx>(\n     let infcx = wfcx.infcx;\n     let tcx = wfcx.tcx();\n     let cause =\n-        ObligationCause::new(span, wfcx.body_id, traits::ObligationCauseCode::MethodReceiver);\n+        ObligationCause::new(span, wfcx.body_def_id, traits::ObligationCauseCode::MethodReceiver);\n \n     let can_eq_self = |ty| infcx.can_eq(wfcx.param_env, self_ty, ty).is_ok();\n \n@@ -1709,7 +1727,7 @@ fn receiver_is_valid<'tcx>(\n         return true;\n     }\n \n-    let mut autoderef = Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty);\n+    let mut autoderef = Autoderef::new(infcx, wfcx.param_env, wfcx.body_def_id, span, receiver_ty);\n \n     // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n@@ -1894,8 +1912,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         let mut span = self.span;\n         let empty_env = ty::ParamEnv::empty();\n \n-        let def_id = tcx.hir().local_def_id(self.body_id);\n-        let predicates_with_span = tcx.predicates_of(def_id).predicates.iter().copied();\n+        let predicates_with_span = tcx.predicates_of(self.body_def_id).predicates.iter().copied();\n         // Check elaborated bounds.\n         let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n \n@@ -1910,7 +1927,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n             // Match the existing behavior.\n             if pred.is_global() && !pred.has_late_bound_vars() {\n                 let pred = self.normalize(span, None, pred);\n-                let hir_node = tcx.hir().find(self.body_id);\n+                let hir_node = tcx.hir().find_by_def_id(self.body_def_id);\n \n                 // only use the span of the predicate clause (#90869)\n \n@@ -1929,7 +1946,7 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n                 let obligation = traits::Obligation::new(\n                     tcx,\n-                    traits::ObligationCause::new(span, self.body_id, traits::TrivialBound),\n+                    traits::ObligationCause::new(span, self.body_def_id, traits::TrivialBound),\n                     empty_env,\n                     pred,\n                 );"}, {"sha": "5716be4f1a95445c5f4db941b7c89123f440c13b", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -29,7 +29,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n         if item.span.is_dummy() {\n             continue;\n         }\n-        let hir::ItemKind::Use(path, _) = item.kind else { unreachable!() };\n+        let (path, _) = item.expect_use();\n         let msg = if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(path.span) {\n             format!(\"unused import: `{}`\", snippet)\n         } else {"}, {"sha": "6600e4216bd1f4a54304af6e41bc128ff22d4670", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -56,16 +56,14 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => {}\n     }\n \n-    let ItemKind::Impl(impl_) = tcx.hir().expect_item(impl_did).kind else { bug!(\"expected Drop impl item\") };\n+    let impl_ = tcx.hir().expect_item(impl_did).expect_impl();\n \n     tcx.sess.emit_err(DropImplOnWrongItem { span: impl_.self_ty.span });\n }\n \n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-\n     let self_type = tcx.type_of(impl_did);\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\", self_type);\n \n@@ -80,7 +78,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => bug!(\"expected Copy impl item\"),\n     };\n \n-    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    let cause = traits::ObligationCause::misc(span, impl_did);\n     match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n@@ -224,7 +222,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     let create_err = |msg: &str| struct_span_err!(tcx.sess, span, E0378, \"{}\", msg);\n \n     let infcx = tcx.infer_ctxt().build();\n-    let cause = ObligationCause::misc(span, impl_hir_id);\n+    let cause = ObligationCause::misc(span, impl_did);\n \n     use rustc_type_ir::sty::TyKind::*;\n     match (source.kind(), target.kind()) {\n@@ -386,8 +384,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\", source, target);\n \n     let infcx = tcx.infer_ctxt().build();\n-    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n-    let cause = ObligationCause::misc(span, impl_hir_id);\n+    let cause = ObligationCause::misc(span, impl_did);\n     let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                        mt_b: ty::TypeAndMut<'tcx>,\n                        mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -575,7 +572,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     };\n \n     // Register an obligation for `A: Trait<B>`.\n-    let cause = traits::ObligationCause::misc(span, impl_hir_id);\n+    let cause = traits::ObligationCause::misc(span, impl_did);\n     let predicate =\n         predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, [source, target]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);"}, {"sha": "c1b0237b2d1f13813c9ccd195d60441e532b4ea2", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -240,6 +240,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {"}, {"sha": "bbde59c953a026375ef708e93141d0691d3fd2c5", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -169,7 +169,7 @@ fn check_object_overlap<'tcx>(\n         });\n \n         for component_def_id in component_def_ids {\n-            if !tcx.is_object_safe(component_def_id) {\n+            if !tcx.check_is_object_safe(component_def_id) {\n                 // Without the 'object_safe_for_dispatch' feature this is an error\n                 // which will be reported by wfcheck. Ignore it here.\n                 // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`."}, {"sha": "c6b16171311fb0de221c0bbcb9c2c667a7aba35d", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,15 +3,13 @@\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::Unsafety;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::LocalDefId;\n \n pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    debug_assert!(matches!(tcx.def_kind(def_id), DefKind::Impl));\n     let item = tcx.hir().expect_item(def_id);\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = item.expect_impl();\n \n     if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_ref = trait_ref.subst_identity();"}, {"sha": "cc7235a61c0b822ef6c9ba0cbc71162b2ab949f9", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -25,7 +25,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericParamKind, Node};\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::query::Providers;\n@@ -517,6 +517,10 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n     fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n         // There's no place to record types from signatures?\n     }\n+\n+    fn infcx(&self) -> Option<&InferCtxt<'tcx>> {\n+        None\n+    }\n }\n \n /// Synthesize a new lifetime name that doesn't clash with any of the lifetimes already present.\n@@ -1087,7 +1091,7 @@ pub fn get_infer_ret_ty<'hir>(output: &'hir hir::FnRetTy<'hir>) -> Option<&'hir\n }\n \n #[instrument(level = \"debug\", skip(tcx))]\n-fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n+fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'_>> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n \n@@ -1096,7 +1100,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n \n     let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n-    match tcx.hir().get(hir_id) {\n+    let output = match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Fn(sig, TraitFn::Provided(_)),\n             generics,\n@@ -1169,7 +1173,8 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         x => {\n             bug!(\"unexpected sort of node in fn_sig(): {:?}\", x);\n         }\n-    }\n+    };\n+    ty::EarlyBinder(output)\n }\n \n fn infer_return_ty_for_fn_sig<'tcx>(\n@@ -1248,11 +1253,12 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n     }\n }\n \n+// FIXME(vincenzopalazzo): remove the hir item when the refactoring is stable\n fn suggest_impl_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ret_ty: Ty<'tcx>,\n     span: Span,\n-    hir_id: hir::HirId,\n+    _hir_id: hir::HirId,\n     def_id: LocalDefId,\n ) -> Option<String> {\n     let format_as_assoc: fn(_, _, _, _, _) -> _ =\n@@ -1324,7 +1330,7 @@ fn suggest_impl_trait<'tcx>(\n         }\n         let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n         let item_ty = ocx.normalize(\n-            &ObligationCause::misc(span, hir_id),\n+            &ObligationCause::misc(span, def_id),\n             param_env,\n             tcx.mk_projection(assoc_item_def_id, substs),\n         );\n@@ -1342,8 +1348,7 @@ fn suggest_impl_trait<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    let item = tcx.hir().expect_item(def_id.expect_local());\n-    let hir::ItemKind::Impl(impl_) = item.kind else { bug!() };\n+    let impl_ = tcx.hir().expect_item(def_id.expect_local()).expect_impl();\n     impl_\n         .of_trait\n         .as_ref()"}, {"sha": "3c67722b637bfa93aa9c33d5c0a3ea1955c2dbf5", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -829,7 +829,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         fd: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         _: Span,\n-        _: hir::HirId,\n+        _: LocalDefId,\n     ) {\n         let output = match fd.output {\n             hir::FnRetTy::DefaultReturn(_) => None,\n@@ -1264,14 +1264,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n-                    Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    Node::Item(hir::Item { owner_id, kind: hir::ItemKind::Fn(..), .. })\n                     | Node::TraitItem(hir::TraitItem {\n-                        kind: hir::TraitItemKind::Fn(..), ..\n+                        owner_id,\n+                        kind: hir::TraitItemKind::Fn(..),\n+                        ..\n                     })\n-                    | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. })\n-                    | Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n-                        let scope = self.tcx.hir().local_def_id(fn_id);\n-                        def = Region::Free(scope.to_def_id(), def.id().unwrap());\n+                    | Node::ImplItem(hir::ImplItem {\n+                        owner_id,\n+                        kind: hir::ImplItemKind::Fn(..),\n+                        ..\n+                    }) => {\n+                        def = Region::Free(owner_id.to_def_id(), def.id().unwrap());\n+                    }\n+                    Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(closure), .. }) => {\n+                        def = Region::Free(closure.def_id.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1658,10 +1665,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<LocalDefId>> {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let decl = tcx.hir().fn_decl_by_hir_id(hir_id)?;\n-    let generics = tcx.hir().get_generics(def_id)?;\n+fn is_late_bound_map(\n+    tcx: TyCtxt<'_>,\n+    owner_id: hir::OwnerId,\n+) -> Option<&FxIndexSet<hir::ItemLocalId>> {\n+    let decl = tcx.hir().fn_decl_by_hir_id(owner_id.into())?;\n+    let generics = tcx.hir().get_generics(owner_id.def_id)?;\n \n     let mut late_bound = FxIndexSet::default();\n \n@@ -1695,24 +1704,22 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&param_def_id) {\n+        if appears_in_where_clause.regions.contains(&param.def_id) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&param_def_id)\n-            && appears_in_output.regions.contains(&param_def_id)\n+        if !constrained_by_input.regions.contains(&param.def_id)\n+            && appears_in_output.regions.contains(&param.def_id)\n         {\n             continue;\n         }\n \n-        debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.hir_id);\n+        debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.def_id);\n \n-        let inserted = late_bound.insert(param_def_id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n+        let inserted = late_bound.insert(param.hir_id.local_id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", param.def_id);\n     }\n \n     debug!(?late_bound);"}, {"sha": "d0d67ae9257c5ddcb959b28ee5f0e752c6fccc01", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -280,7 +280,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             }\n \n             let hir::GenericParamKind::Lifetime { .. } = duplicate.kind else { continue };\n-            let dup_def = tcx.hir().local_def_id(duplicate.hir_id).to_def_id();\n+            let dup_def = duplicate.def_id.to_def_id();\n \n             let Some(dup_index) = generics.param_def_id_to_index(tcx, dup_def) else { bug!() };\n "}, {"sha": "e7b0846e10352b1093b1d7efdd2174629513267e", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -54,15 +54,14 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // ty which is a fully resolved projection.\n             // For the code example above, this would mean converting Self::Assoc<3>\n             // into a ty::Alias(ty::Projection, <Self as Foo>::Assoc<3>)\n-            let item_hir_id = tcx\n+            let item_def_id = tcx\n                 .hir()\n-                .parent_iter(hir_id)\n-                .filter(|(_, node)| matches!(node, Node::Item(_)))\n-                .map(|(id, _)| id)\n-                .next()\n-                .unwrap();\n-            let item_did = tcx.hir().local_def_id(item_hir_id).to_def_id();\n-            let item_ctxt = &ItemCtxt::new(tcx, item_did) as &dyn crate::astconv::AstConv<'_>;\n+                .parent_owner_iter(hir_id)\n+                .find(|(_, node)| matches!(node, OwnerNode::Item(_)))\n+                .unwrap()\n+                .0\n+                .to_def_id();\n+            let item_ctxt = &ItemCtxt::new(tcx, item_def_id) as &dyn crate::astconv::AstConv<'_>;\n             let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n \n             // Iterate through the generics of the projection to find the one that corresponds to\n@@ -867,7 +866,9 @@ fn infer_placeholder_type<'a>(\n             }\n \n             match ty.kind() {\n-                ty::FnDef(def_id, _) => self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id)),\n+                ty::FnDef(def_id, substs) => {\n+                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id).subst(self.tcx, substs))\n+                }\n                 // FIXME: non-capturing closures should also suggest a function pointer\n                 ty::Closure(..) | ty::Generator(..) => {\n                     self.success = false;"}, {"sha": "9cf82b39ec947b9e4d5ee29e803dfe2fc5a088b6", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,11 +1,12 @@\n use crate::collect::ItemCtxt;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{ForeignItem, ForeignItemKind, HirId};\n+use rustc_hir::{ForeignItem, ForeignItemKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Region, TyCtxt, TypeFoldable, TypeFolder};\n+use rustc_span::def_id::LocalDefId;\n use rustc_trait_selection::traits;\n \n pub fn provide(providers: &mut Providers) {\n@@ -57,7 +58,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n         cause: Option<ObligationCause<'tcx>>,\n         cause_depth: usize,\n         icx: ItemCtxt<'tcx>,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         depth: usize,\n     }\n@@ -68,7 +69,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n             let tcx_ty = self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n             let cause = traits::ObligationCause::new(\n                 ty.span,\n-                self.hir_id,\n+                self.def_id,\n                 traits::ObligationCauseCode::WellFormed(None),\n             );\n             let errors = traits::fully_solve_obligation(\n@@ -106,7 +107,7 @@ fn diagnostic_hir_wf_check<'tcx>(\n         cause: None,\n         cause_depth: 0,\n         icx,\n-        hir_id,\n+        def_id,\n         param_env: tcx.param_env(def_id.to_def_id()),\n         depth: 0,\n     };"}, {"sha": "a5dcfab9be8e84d102923a58822f232df27731e8", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -164,7 +164,6 @@ fn get_impl_substs(\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n     let param_env = tcx.param_env(impl1_def_id);\n-    let impl1_hir_id = tcx.hir().local_def_id_to_hir_id(impl1_def_id);\n \n     let assumed_wf_types =\n         ocx.assumed_wf_types(param_env, tcx.def_span(impl1_def_id), impl1_def_id);\n@@ -179,7 +178,7 @@ fn get_impl_substs(\n         return None;\n     }\n \n-    let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_hir_id, assumed_wf_types);\n+    let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n     let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n@@ -372,15 +371,9 @@ fn check_predicates<'tcx>(\n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity().substs {\n         let infcx = &tcx.infer_ctxt().build();\n-        let obligations = wf::obligations(\n-            infcx,\n-            tcx.param_env(impl1_def_id),\n-            tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n-            0,\n-            arg,\n-            span,\n-        )\n-        .unwrap();\n+        let obligations =\n+            wf::obligations(infcx, tcx.param_env(impl1_def_id), impl1_def_id, 0, arg, span)\n+                .unwrap();\n \n         assert!(!obligations.needs_infer());\n         impl2_predicates.extend("}, {"sha": "c2fa46e563e60ac60d7149bb4fc8dd45d03c7a72", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -100,14 +100,14 @@ mod variance;\n \n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_hir::Node;\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util;\n use rustc_session::{config::EntryFnType, parse::feature_err};\n+use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -182,19 +182,18 @@ fn require_same_types<'tcx>(\n }\n \n fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n-    let main_fnsig = tcx.fn_sig(main_def_id);\n+    let main_fnsig = tcx.fn_sig(main_def_id).subst_identity();\n     let main_span = tcx.def_span(main_def_id);\n \n-    fn main_fn_diagnostics_hir_id(tcx: TyCtxt<'_>, def_id: DefId, sp: Span) -> hir::HirId {\n+    fn main_fn_diagnostics_def_id(tcx: TyCtxt<'_>, def_id: DefId, sp: Span) -> LocalDefId {\n         if let Some(local_def_id) = def_id.as_local() {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n             let hir_type = tcx.type_of(local_def_id);\n             if !matches!(hir_type.kind(), ty::FnDef(..)) {\n                 span_bug!(sp, \"main has a non-function type: found `{}`\", hir_type);\n             }\n-            hir_id\n+            local_def_id\n         } else {\n-            CRATE_HIR_ID\n+            CRATE_DEF_ID\n         }\n     }\n \n@@ -251,7 +250,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n \n     let mut error = false;\n-    let main_diagnostics_hir_id = main_fn_diagnostics_hir_id(tcx, main_def_id, main_span);\n+    let main_diagnostics_def_id = main_fn_diagnostics_def_id(tcx, main_def_id, main_span);\n     let main_fn_generics = tcx.generics_of(main_def_id);\n     let main_fn_predicates = tcx.predicates_of(main_def_id);\n     if main_fn_generics.count() != 0 || !main_fnsig.bound_vars().is_empty() {\n@@ -326,7 +325,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let param_env = ty::ParamEnv::empty();\n         let cause = traits::ObligationCause::new(\n             return_ty_span,\n-            main_diagnostics_hir_id,\n+            main_diagnostics_def_id,\n             ObligationCauseCode::MainFunctionType,\n         );\n         let ocx = traits::ObligationCtxt::new(&infcx);\n@@ -356,7 +355,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         tcx,\n         &ObligationCause::new(\n             main_span,\n-            main_diagnostics_hir_id,\n+            main_diagnostics_def_id,\n             ObligationCauseCode::MainFunctionType,\n         ),\n         se_ty,\n@@ -444,9 +443,13 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n \n             require_same_types(\n                 tcx,\n-                &ObligationCause::new(start_span, start_id, ObligationCauseCode::StartFunctionType),\n+                &ObligationCause::new(\n+                    start_span,\n+                    start_def_id,\n+                    ObligationCauseCode::StartFunctionType,\n+                ),\n                 se_ty,\n-                tcx.mk_fn_ptr(tcx.fn_sig(start_def_id)),\n+                tcx.mk_fn_ptr(tcx.fn_sig(start_def_id).subst_identity()),\n             );\n         }\n         _ => {"}, {"sha": "165782f209a0ce925418ef909f926d61db62a5b8", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -119,7 +119,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::FnDef(..) => {\n-                self.add_constraints_from_sig(current_item, tcx.fn_sig(def_id), self.covariant);\n+                self.add_constraints_from_sig(\n+                    current_item,\n+                    tcx.fn_sig(def_id).subst_identity(),\n+                    self.covariant,\n+                );\n             }\n \n             ty::Error(_) => {}\n@@ -221,8 +225,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::Ref(region, ty, mutbl) => {\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(current, region, contra);\n+                self.add_constraints_from_region(current, region, variance);\n                 self.add_constraints_from_mt(current, &ty::TypeAndMut { ty, mutbl }, variance);\n             }\n \n@@ -254,9 +257,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::Dynamic(data, r, _) => {\n-                // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n-                let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(current, r, contra);\n+                // The type `dyn Trait<T> +'a` is covariant w/r/t `'a`:\n+                self.add_constraints_from_region(current, r, variance);\n \n                 if let Some(poly_trait_ref) = data.principal() {\n                     self.add_constraints_from_invariant_substs(\n@@ -291,12 +293,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // types, where we use Error as the Self type\n             }\n \n-            ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Bound(..) | ty::Infer(..) => {\n-                bug!(\n-                    \"unexpected type encountered in \\\n-                      variance inference: {}\",\n-                    ty\n-                );\n+            ty::Placeholder(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Bound(..)\n+            | ty::Infer(..) => {\n+                bug!(\"unexpected type encountered in variance inference: {}\", ty);\n             }\n         }\n     }"}, {"sha": "88fb26535868603907dfdd4ec89c8678f301c024", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -188,8 +188,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir = self.tcx.hir();\n \n         // First, check that we're actually in the tail of a function.\n-        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n-            hir.get(self.body_id) else { return; };\n+        let Some(body_id) = hir.maybe_body_owned_by(self.body_id) else { return; };\n+        let body = hir.body(body_id);\n+        let hir::ExprKind::Block(block, _) = body.value.kind else { return; };\n         let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n             = block.innermost_block().stmts.last() else {  return; };\n         if last_expr.hir_id != expr.hir_id {\n@@ -198,7 +199,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Next, make sure that we have no type expectation.\n         let Some(ret) = hir\n-            .find_by_def_id(self.body_id.owner.def_id)\n+            .find_by_def_id(self.body_id)\n             .and_then(|owner| owner.fn_decl())\n             .map(|decl| decl.output.span()) else { return; };\n         let Expectation::IsLast(stmt) = expectation else {"}, {"sha": "c220956a2012e15620f124c86c5942b479587759", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let (fn_sig, def_id) = match *callee_ty.kind() {\n             ty::FnDef(def_id, subst) => {\n-                let fn_sig = self.tcx.bound_fn_sig(def_id).subst(self.tcx, subst);\n+                let fn_sig = self.tcx.fn_sig(def_id).subst(self.tcx, subst);\n \n                 // Unit testing: function items annotated with\n                 // `#[rustc_evaluate_where_clauses]` trigger special output"}, {"sha": "8e21c084841d0d1707edea19be3f534c4fb7fd36", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -130,6 +130,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             | ty::Float(_)\n             | ty::Array(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::RawPtr(_)\n             | ty::Ref(..)\n             | ty::FnDef(..)"}, {"sha": "1c70c1b71e7639315f741329413e96be905b73b3", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -43,7 +43,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     let ret_ty =\n         fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n             declared_ret_ty,\n-            body.value.hir_id,\n+            fn_def_id,\n             decl.output.span(),\n             fcx.param_env,\n         ));\n@@ -130,7 +130,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n     let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n         let interior = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n+        fcx.deferred_generator_interiors.borrow_mut().push((\n+            fn_def_id,\n+            body.id(),\n+            interior,\n+            gen_kind,\n+        ));\n \n         let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n         Some(GeneratorTypes {\n@@ -167,12 +172,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n-        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n+        && panic_impl_did == fn_def_id.to_def_id()\n     {\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n-    if let Some(lang_start_defid) = tcx.lang_items().start_fn() && lang_start_defid == hir.local_def_id(fn_id).to_def_id() {\n+    if let Some(lang_start_defid) = tcx.lang_items().start_fn() && lang_start_defid == fn_def_id.to_def_id() {\n         check_lang_start_fn(tcx, fn_sig, decl, fn_def_id);\n     }\n "}, {"sha": "329b69eff54a396338f6e6f4e58e69f0ffc3c61c", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -4,7 +4,6 @@ use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use hir::def::DefKind;\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -14,6 +13,7 @@ use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TypeSuperVisitable, TypeVisitor};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(?bound_sig, ?liberated_sig);\n \n-        let mut fcx = FnCtxt::new(self, self.param_env.without_const(), body.value.hir_id);\n+        let mut fcx = FnCtxt::new(self, self.param_env.without_const(), closure.def_id);\n         let generator_types = check_fn(\n             &mut fcx,\n             liberated_sig,\n@@ -620,8 +620,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // function.\n                 Some(hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn)) => {\n                     debug!(\"closure is async fn body\");\n-                    self.deduce_future_output_from_obligations(expr_def_id, body.id().hir_id)\n-                        .unwrap_or_else(|| {\n+                    let def_id = self.tcx.hir().body_owner_def_id(body.id());\n+                    self.deduce_future_output_from_obligations(expr_def_id, def_id).unwrap_or_else(\n+                        || {\n                             // AFAIK, deducing the future output\n                             // always succeeds *except* in error cases\n                             // like #65159. I'd like to return Error\n@@ -630,7 +631,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // *have* reported an\n                             // error. --nikomatsakis\n                             astconv.ty_infer(None, decl.output.span())\n-                        })\n+                        },\n+                    )\n                 }\n \n                 _ => astconv.ty_infer(None, decl.output.span()),\n@@ -665,7 +667,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn deduce_future_output_from_obligations(\n         &self,\n         expr_def_id: LocalDefId,\n-        body_id: hir::HirId,\n+        body_def_id: LocalDefId,\n     ) -> Option<Ty<'tcx>> {\n         let ret_coercion = self.ret_coercion.as_ref().unwrap_or_else(|| {\n             span_bug!(self.tcx.def_span(expr_def_id), \"async fn generator outside of a fn\")\n@@ -725,7 +727,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let InferOk { value: output_ty, obligations } = self\n             .replace_opaque_types_with_inference_vars(\n                 output_ty,\n-                body_id,\n+                body_def_id,\n                 self.tcx.def_span(expr_def_id),\n                 self.param_env,\n             );"}, {"sha": "ade9c037c519405d04470edbf8c5741f8e9cba07", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1613,12 +1613,14 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 if visitor.ret_exprs.len() > 0 && let Some(expr) = expression {\n                     self.note_unreachable_loop_return(&mut err, &expr, &visitor.ret_exprs);\n                 }\n+\n                 let reported = err.emit_unless(unsized_return);\n \n                 self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(reported));\n             }\n         }\n     }\n+\n     fn note_unreachable_loop_return(\n         &self,\n         err: &mut Diagnostic,\n@@ -1821,7 +1823,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         .trait_ref()\n                         .and_then(|t| t.trait_def_id())\n                         .map_or(false, |def_id| {\n-                            fcx.tcx.object_safety_violations(def_id).is_empty()\n+                            fcx.tcx.check_is_object_safe(def_id)\n                         })\n                 })\n             }"}, {"sha": "19b8fb96cde37133145ed156b3477c887c8225ee", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 85, "deletions": 26, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -59,9 +59,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_clone_for_ref(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_floating_point_literal(err, expr, expected);\n+            || self.suggest_floating_point_literal(err, expr, expected)\n+            || self.note_result_coercion(err, expr, expected, expr_ty);\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n         }\n     }\n \n@@ -81,7 +82,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n         self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n-        self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n         self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n@@ -222,6 +222,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         found: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        mismatch_span: Span,\n     ) -> bool {\n         let map = self.tcx.hir();\n \n@@ -270,7 +271,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             lt_op: |_| self.tcx.lifetimes.re_erased,\n             ct_op: |c| c,\n             ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(vid)) => self.tcx.mk_ty_infer(ty::TyVar(self.root_var(vid))),\n+                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n                 ty::Infer(ty::IntVar(_)) => {\n                     self.tcx.mk_ty_infer(ty::IntVar(ty::IntVid { index: 0 }))\n                 }\n@@ -281,7 +282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n         let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span = None;\n+        let mut prev_span: Option<Span> = None;\n \n         for binding in expr_finder.uses {\n             // In every expression where the binding is referenced, we will look at that\n@@ -298,7 +299,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 // We special case methods, because they can influence inference through the\n                 // call's arguments and we can provide a more explicit span.\n-                let sig = self.tcx.fn_sig(def_id);\n+                let sig = self.tcx.fn_sig(def_id).subst_identity();\n                 let def_self_ty = sig.input(0).skip_binder();\n                 let rcvr_ty = self.node_ty(rcvr.hir_id);\n                 // Get the evaluated type *after* calling the method call, so that the influence\n@@ -333,13 +334,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // inferred in this method call.\n                             let arg = &args[i];\n                             let arg_ty = self.node_ty(arg.hir_id);\n-                            err.span_label(\n-                                arg.span,\n-                                &format!(\n-                                    \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                     inferred as `{ty}`\",\n-                                ),\n-                            );\n+                            if !arg.span.overlaps(mismatch_span) {\n+                                err.span_label(\n+                                    arg.span,\n+                                    &format!(\n+                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n+                                        inferred as `{ty}`\",\n+                                    ),\n+                                );\n+                            }\n                             param_args.insert(param_ty, (arg, arg_ty));\n                         }\n                     }\n@@ -382,12 +385,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && self.can_eq(self.param_env, ty, found).is_ok()\n                 {\n                     // We only point at the first place where the found type was inferred.\n+                    if !segment.ident.span.overlaps(mismatch_span) {\n                     err.span_label(\n                         segment.ident.span,\n                         with_forced_trimmed_paths!(format!(\n                             \"here the type of `{ident}` is inferred to be `{ty}`\",\n                         )),\n-                    );\n+                    );}\n                     break;\n                 } else if !param_args.is_empty() {\n                     break;\n@@ -406,12 +410,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We use the *previous* span because if the type is known *here* it means\n                     // it was *evaluated earlier*. We don't do this for method calls because we\n                     // evaluate the method's self type eagerly, but not in any other case.\n-                    err.span_label(\n-                        span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );\n+                    if !span.overlaps(mismatch_span) {\n+                        err.span_label(\n+                            span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n+                            )),\n+                        );\n+                    }\n                     break;\n                 }\n                 prev = ty;\n@@ -597,6 +603,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let substs = ty::InternalSubsts::for_item(self.tcx, m.def_id, |param, _| {\n                     self.var_for_def(deref.span, param)\n                 });\n+                let mutability =\n+                    match self.tcx.fn_sig(m.def_id).skip_binder().input(0).skip_binder().kind() {\n+                        ty::Ref(_, _, hir::Mutability::Mut) => \"&mut \",\n+                        ty::Ref(_, _, _) => \"&\",\n+                        _ => \"\",\n+                    };\n                 vec![\n                     (\n                         deref.span.until(base.span),\n@@ -605,11 +617,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             with_no_trimmed_paths!(\n                                 self.tcx.def_path_str_with_substs(m.def_id, substs,)\n                             ),\n-                            match self.tcx.fn_sig(m.def_id).input(0).skip_binder().kind() {\n-                                ty::Ref(_, _, hir::Mutability::Mut) => \"&mut \",\n-                                ty::Ref(_, _, _) => \"&\",\n-                                _ => \"\",\n-                            },\n+                            mutability,\n                         ),\n                     ),\n                     match &args[..] {\n@@ -697,6 +705,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n+    pub(crate) fn note_result_coercion(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let ty::Adt(e, substs_e) = expected.kind() else { return false; };\n+        let ty::Adt(f, substs_f) = found.kind() else { return false; };\n+        if e.did() != f.did() {\n+            return false;\n+        }\n+        if Some(e.did()) != self.tcx.get_diagnostic_item(sym::Result) {\n+            return false;\n+        }\n+        let map = self.tcx.hir();\n+        if let Some(hir::Node::Expr(expr)) = map.find_parent(expr.hir_id)\n+            && let hir::ExprKind::Ret(_) = expr.kind\n+        {\n+            // `return foo;`\n+        } else if map.get_return_block(expr.hir_id).is_some() {\n+            // Function's tail expression.\n+        } else {\n+            return false;\n+        }\n+        let e = substs_e.type_at(1);\n+        let f = substs_f.type_at(1);\n+        if self\n+            .infcx\n+            .type_implements_trait(\n+                self.tcx.get_diagnostic_item(sym::Into).unwrap(),\n+                [f, e],\n+                self.param_env,\n+            )\n+            .must_apply_modulo_regions()\n+        {\n+            err.multipart_suggestion(\n+                \"use `?` to coerce and return an appropriate `Err`, and wrap the resulting value \\\n+                 in `Ok` so the expression remains of type `Result`\",\n+                vec![\n+                    (expr.span.shrink_to_lo(), \"Ok(\".to_string()),\n+                    (expr.span.shrink_to_hi(), \"?)\".to_string()),\n+                ],\n+                Applicability::MaybeIncorrect,\n+            );\n+            return true;\n+        }\n+        false\n+    }\n+\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants(\n@@ -980,7 +1038,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match method.kind {\n             ty::AssocKind::Fn => {\n                 method.fn_has_self_parameter\n-                    && self.tcx.fn_sig(method.def_id).inputs().skip_binder().len() == 1\n+                    && self.tcx.fn_sig(method.def_id).skip_binder().inputs().skip_binder().len()\n+                        == 1\n             }\n             _ => false,\n         }"}, {"sha": "74913bac72411a7b73d771648c088367fc541db5", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -542,7 +542,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let ty::FnDef(did, ..) = *ty.kind() {\n             let fn_sig = ty.fn_sig(tcx);\n-            if tcx.fn_sig(did).abi() == RustIntrinsic && tcx.item_name(did) == sym::transmute {\n+            if tcx.fn_sig(did).skip_binder().abi() == RustIntrinsic\n+                && tcx.item_name(did) == sym::transmute\n+            {\n                 let from = fn_sig.inputs().skip_binder()[0];\n                 let to = fn_sig.output().skip_binder();\n                 // We defer the transmute to the end of typeck, once all inference vars have\n@@ -852,7 +854,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Point any obligations that were registered due to opaque type\n             // inference at the return expression.\n             self.select_obligations_where_possible(|errors| {\n-                self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty);\n+                self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty, return_expr.span);\n             });\n         }\n     }\n@@ -862,9 +864,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n         span: Span,\n         return_expr_ty: Ty<'tcx>,\n+        return_span: Span,\n     ) {\n         // Don't point at the whole block if it's empty\n-        if span == self.tcx.hir().span(self.body_id) {\n+        if span == return_span {\n             return;\n         }\n         for err in errors {\n@@ -1374,7 +1377,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let body = self.tcx.hir().body(anon_const.body);\n \n         // Create a new function context.\n-        let fcx = FnCtxt::new(self, self.param_env.with_const(), body.value.hir_id);\n+        let def_id = anon_const.def_id;\n+        let fcx = FnCtxt::new(self, self.param_env.with_const(), def_id);\n         crate::GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n         let ty = fcx.check_expr_with_expectation(&body.value, expected);\n@@ -2151,13 +2155,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         variant: &'tcx ty::VariantDef,\n         access_span: Span,\n     ) -> Vec<Symbol> {\n+        let body_owner_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n         variant\n             .fields\n             .iter()\n             .filter(|field| {\n                 let def_scope = self\n                     .tcx\n-                    .adjust_ident_and_get_scope(field.ident(self.tcx), variant.def_id, self.body_id)\n+                    .adjust_ident_and_get_scope(\n+                        field.ident(self.tcx),\n+                        variant.def_id,\n+                        body_owner_hir_id,\n+                    )\n                     .1;\n                 field.vis.is_accessible_from(def_scope, self.tcx)\n                     && !matches!(\n@@ -2199,8 +2208,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match deref_base_ty.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\", deref_base_ty);\n+                    let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n                     let (ident, def_scope) =\n-                        self.tcx.adjust_ident_and_get_scope(field, base_def.did(), self.body_id);\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did(), body_hir_id);\n                     let fields = &base_def.non_enum_variant().fields;\n                     if let Some(index) = fields\n                         .iter()\n@@ -2538,7 +2548,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn point_at_param_definition(&self, err: &mut Diagnostic, param: ty::ParamTy) {\n-        let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n+        let generics = self.tcx.generics_of(self.body_id);\n         let generic_param = generics.type_param(&param, self.tcx);\n         if let ty::GenericParamDefKind::Type { synthetic: true, .. } = generic_param.kind {\n             return;"}, {"sha": "a355a54d6959abb5570144e9c40b53f2e973ce3f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -517,16 +517,72 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n+        if self.tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+            self.save_generator_interior_predicates(def_id);\n+            return;\n+        }\n+\n+        self.select_obligations_where_possible(|_| {});\n+\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n-        for (body_id, interior, kind) in generators.drain(..) {\n-            self.select_obligations_where_possible(|_| {});\n+        for (_, body_id, interior, kind) in generators.drain(..) {\n             crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n+            self.select_obligations_where_possible(|_| {});\n+        }\n+    }\n+\n+    /// Unify the inference variables corresponding to generator witnesses, and save all the\n+    /// predicates that were stalled on those inference variables.\n+    ///\n+    /// This process allows to conservatively save all predicates that do depend on the generator\n+    /// interior types, for later processing by `check_generator_obligations`.\n+    ///\n+    /// We must not attempt to select obligations after this method has run, or risk query cycle\n+    /// ICE.\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn save_generator_interior_predicates(&self, def_id: DefId) {\n+        // Try selecting all obligations that are not blocked on inference variables.\n+        // Once we start unifying generator witnesses, trying to select obligations on them will\n+        // trigger query cycle ICEs, as doing so requires MIR.\n+        self.select_obligations_where_possible(|_| {});\n+\n+        let generators = std::mem::take(&mut *self.deferred_generator_interiors.borrow_mut());\n+        debug!(?generators);\n+\n+        for &(expr_def_id, body_id, interior, _) in generators.iter() {\n+            debug!(?expr_def_id);\n+\n+            // Create the `GeneratorWitness` type that we will unify with `interior`.\n+            let substs = ty::InternalSubsts::identity_for_item(\n+                self.tcx,\n+                self.tcx.typeck_root_def_id(expr_def_id.to_def_id()),\n+            );\n+            let witness = self.tcx.mk_generator_witness_mir(expr_def_id.to_def_id(), substs);\n+\n+            // Unify `interior` with `witness` and collect all the resulting obligations.\n+            let span = self.tcx.hir().body(body_id).value.span;\n+            let ok = self\n+                .at(&self.misc(span), self.param_env)\n+                .eq(interior, witness)\n+                .expect(\"Failed to unify generator interior type\");\n+            let mut obligations = ok.obligations;\n+\n+            // Also collect the obligations that were unstalled by this unification.\n+            obligations\n+                .extend(self.fulfillment_cx.borrow_mut().drain_unstalled_obligations(&self.infcx));\n+\n+            let obligations = obligations.into_iter().map(|o| (o.predicate, o.cause)).collect();\n+            debug!(?obligations);\n+            self.typeck_results\n+                .borrow_mut()\n+                .generator_interior_predicates\n+                .insert(expr_def_id, obligations);\n         }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub(in super::super) fn select_all_obligations_or_error(&self) {\n-        let mut errors = self.fulfillment_cx.borrow_mut().select_all_or_error(&self);\n+    pub(in super::super) fn report_ambiguity_errors(&self) {\n+        let mut errors = self.fulfillment_cx.borrow_mut().collect_remaining_errors();\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n@@ -926,43 +982,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(in super::super) fn note_need_for_fn_pointer(\n-        &self,\n-        err: &mut Diagnostic,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        let (sig, did, substs) = match (&expected.kind(), &found.kind()) {\n-            (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n-                let sig1 = self.tcx.bound_fn_sig(*did1).subst(self.tcx, substs1);\n-                let sig2 = self.tcx.bound_fn_sig(*did2).subst(self.tcx, substs2);\n-                if sig1 != sig2 {\n-                    return;\n-                }\n-                err.note(\n-                    \"different `fn` items always have unique types, even if their signatures are \\\n-                     the same\",\n-                );\n-                (sig1, *did1, substs1)\n-            }\n-            (ty::FnDef(did, substs), ty::FnPtr(sig2)) => {\n-                let sig1 = self.tcx.bound_fn_sig(*did).subst(self.tcx, substs);\n-                if sig1 != *sig2 {\n-                    return;\n-                }\n-                (sig1, *did, substs)\n-            }\n-            _ => return,\n-        };\n-        err.help(&format!(\"change the expected type to be function pointer `{}`\", sig));\n-        err.help(&format!(\n-            \"if the expected type is due to type inference, cast the expected `fn` to a function \\\n-             pointer: `{} as {}`\",\n-            self.tcx.def_path_str_with_substs(did, substs),\n-            sig\n-        ));\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     #[instrument(skip(self, span), level = \"debug\")]"}, {"sha": "47ef106e750321470003d3b25103cbcb25b98d9c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n             InlineAsmCtxt::new_in_fn(self.tcx, self.param_env, get_operand_ty)\n-                .check_asm(asm, self.tcx.hir().local_def_id_to_hir_id(enclosing_id));\n+                .check_asm(asm, enclosing_id);\n         }\n     }\n \n@@ -808,7 +808,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: full_call_span,\n                 });\n-                self.point_at_expr_source_of_inferred_type(&mut err, rcvr, expected, callee_ty);\n+                self.point_at_expr_source_of_inferred_type(\n+                    &mut err,\n+                    rcvr,\n+                    expected,\n+                    callee_ty,\n+                    provided_arg_span,\n+                );\n             }\n             // Call out where the function is defined\n             self.label_fn_like(\n@@ -2126,7 +2132,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match *callee_ty.kind() {\n                 ty::Param(param) => {\n                     let param =\n-                        self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx);\n+                        self.tcx.generics_of(self.body_id).type_param(&param, self.tcx);\n                     if param.kind.is_synthetic() {\n                         // if it's `impl Fn() -> ..` then just fall down to the def-id based logic\n                         def_id = param.def_id;\n@@ -2135,7 +2141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // and point at that.\n                         let instantiated = self\n                             .tcx\n-                            .explicit_predicates_of(self.body_id.owner)\n+                            .explicit_predicates_of(self.body_id)\n                             .instantiate_identity(self.tcx);\n                         // FIXME(compiler-errors): This could be problematic if something has two\n                         // fn-like predicates with different args, but callable types really never"}, {"sha": "4940015ddd571811d90137ce5dd33a69cd6ba08f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -10,7 +10,7 @@ pub use suggestions::*;\n use crate::coercion::DynamicCoerceMany;\n use crate::{Diverges, EnclosingBreakables, Inherited};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n@@ -38,7 +38,7 @@ use std::ops::Deref;\n /// [`ItemCtxt`]: rustc_hir_analysis::collect::ItemCtxt\n /// [`InferCtxt`]: infer::InferCtxt\n pub struct FnCtxt<'a, 'tcx> {\n-    pub(super) body_id: hir::HirId,\n+    pub(super) body_id: LocalDefId,\n \n     /// The parameter environment used for proving trait obligations\n     /// in this function. This can change when we descend into\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn new(\n         inh: &'a Inherited<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n     ) -> FnCtxt<'a, 'tcx> {\n         FnCtxt {\n             body_id,\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn item_def_id(&self) -> DefId {\n-        self.body_id.owner.to_def_id()\n+        self.body_id.to_def_id()\n     }\n \n     fn get_type_parameter_bounds(\n@@ -324,6 +324,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         let ty = if !ty.has_escaping_bound_vars() { self.normalize(span, ty) } else { ty };\n         self.write_ty(hir_id, ty)\n     }\n+\n+    fn infcx(&self) -> Option<&infer::InferCtxt<'tcx>> {\n+        Some(&self.infcx)\n+    }\n }\n \n /// Represents a user-provided type in the raw form (never normalized)."}, {"sha": "6046e55c65c18366c2b2cb10fae1cd1a390fe7f1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results\n             .borrow()\n             .liberated_fn_sigs()\n-            .get(self.tcx.hir().parent_id(self.body_id))\n+            .get(self.tcx.hir().local_def_id_to_hir_id(self.body_id))\n             .copied()\n     }\n \n@@ -164,7 +164,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n-        self.err_ctxt().extract_callable_info(self.body_id, self.param_env, ty)\n+        let body_hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n+        self.err_ctxt().extract_callable_info(body_hir_id, self.param_env, ty)\n     }\n \n     pub fn suggest_two_fn_call("}, {"sha": "38445f28440527822932e6424379d6419ddb46e5", "filename": "compiler/rustc_hir_typeck/src/gather_locals.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -5,6 +5,7 @@ use rustc_hir::PatKind;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::UserType;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n@@ -156,7 +157,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         _: &'tcx hir::FnDecl<'tcx>,\n         _: hir::BodyId,\n         _: Span,\n-        _: hir::HirId,\n+        _: LocalDefId,\n     ) {\n     }\n }"}, {"sha": "87e54025330e8a928873fc3295a31dd5e17d1a78", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -56,7 +56,7 @@ pub struct Inherited<'tcx> {\n     pub(super) deferred_asm_checks: RefCell<Vec<(&'tcx hir::InlineAsm<'tcx>, hir::HirId)>>,\n \n     pub(super) deferred_generator_interiors:\n-        RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n+        RefCell<Vec<(LocalDefId, hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n     pub(super) body_id: Option<hir::BodyId>,\n "}, {"sha": "2c76582f2ec8fbd14b9b911b4f922498a747b4d0", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -38,6 +38,7 @@ fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n         let tcx = self.tcx;\n+        let dl = &tcx.data_layout;\n         let span = tcx.hir().span(hir_id);\n         let normalize = |ty| {\n             let ty = self.resolve_vars_if_possible(ty);\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Special-case transmuting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer(dl.instruction_address_space).size(&tcx) {\n                 struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n                     .note(&format!(\"source type: {from}\"))\n                     .note(&format!(\"target type: {to}\"))"}, {"sha": "323bacf70ab9ca911b5f34c5619eb6c41b0828d6", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -201,13 +201,13 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n-        let mut fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+        let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n \n         if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n             } else {\n-                tcx.fn_sig(def_id)\n+                tcx.fn_sig(def_id).subst_identity()\n             };\n \n             check_abi(tcx, id, span, fn_sig.abi());\n@@ -294,14 +294,24 @@ fn typeck_with_fallback<'tcx>(\n         // Before the generator analysis, temporary scopes shall be marked to provide more\n         // precise information on types to be captured.\n         fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n             let ty = fcx.normalize(span, ty);\n             fcx.require_type_is_sized(ty, span, code);\n         }\n \n-        fcx.select_all_obligations_or_error();\n+        fcx.select_obligations_where_possible(|_| {});\n+\n+        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+\n+        // This must be the last thing before `report_ambiguity_errors`.\n+        fcx.resolve_generator_interiors(def_id.to_def_id());\n+\n+        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+\n+        if let None = fcx.infcx.tainted_by_errors() {\n+            fcx.report_ambiguity_errors();\n+        }\n \n         if let None = fcx.infcx.tainted_by_errors() {\n             fcx.check_transmutes();"}, {"sha": "65ca47bfe538bbd5c42cb8854ee9dfa1adcc601b", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -503,9 +503,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         debug!(\"method_predicates after subst = {:?}\", method_predicates);\n \n-        let sig = self.tcx.bound_fn_sig(def_id);\n-\n-        let sig = sig.subst(self.tcx, all_substs);\n+        let sig = self.tcx.fn_sig(def_id).subst(self.tcx, all_substs);\n         debug!(\"type scheme substituted, sig={:?}\", sig);\n \n         let sig = self.replace_bound_vars_with_fresh_vars(sig);"}, {"sha": "60d4dc326eea16f837983767fc138d6ffda50a5d", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             )\n             .map(|pick| {\n                 let sig = self.tcx.fn_sig(pick.item.def_id);\n-                sig.inputs().skip_binder().len().saturating_sub(1)\n+                sig.skip_binder().inputs().skip_binder().len().saturating_sub(1)\n             })\n             .unwrap_or(0);\n \n@@ -399,8 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // N.B., instantiate late-bound regions before normalizing the\n         // function signature so that normalization does not need to deal\n         // with bound regions.\n-        let fn_sig = tcx.bound_fn_sig(def_id);\n-        let fn_sig = fn_sig.subst(self.tcx, substs);\n+        let fn_sig = tcx.fn_sig(def_id).subst(self.tcx, substs);\n         let fn_sig =\n             self.replace_bound_vars_with_fresh_vars(obligation.cause.span, infer::FnCall, fn_sig);\n "}, {"sha": "9fc4c16fb071d2dbac212436a8187cca2d836a2a", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -508,9 +508,10 @@ fn method_autoderef_steps<'tcx>(\n     let (ref infcx, goal, inference_vars) = tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n     let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-    let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n-        .include_raw_pointers()\n-        .silence_errors();\n+    let mut autoderef =\n+        Autoderef::new(infcx, param_env, hir::def_id::CRATE_DEF_ID, DUMMY_SP, self_ty)\n+            .include_raw_pointers()\n+            .silence_errors();\n     let mut reached_raw_pointer = false;\n     let mut steps: Vec<_> = autoderef\n         .by_ref()\n@@ -610,10 +611,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn push_candidate(&mut self, candidate: Candidate<'tcx>, is_inherent: bool) {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope = self\n-                .tcx\n-                .adjust_ident_and_get_scope(name, item.container_id(self.tcx), self.body_id)\n-                .1;\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(name, item.container_id(self.tcx), hir_id).1;\n             item.visibility(self.tcx).is_accessible_from(def_scope, self.tcx)\n         } else {\n             true\n@@ -921,26 +921,22 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         expected: Ty<'tcx>,\n     ) -> bool {\n         match method.kind {\n-            ty::AssocKind::Fn => {\n-                let fty = self.tcx.bound_fn_sig(method.def_id);\n-                self.probe(|_| {\n-                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n-                    let fty = fty.subst(self.tcx, substs);\n-                    let fty =\n-                        self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, fty);\n-\n-                    if let Some(self_ty) = self_ty {\n-                        if self\n-                            .at(&ObligationCause::dummy(), self.param_env)\n-                            .sup(fty.inputs()[0], self_ty)\n-                            .is_err()\n-                        {\n-                            return false;\n-                        }\n+            ty::AssocKind::Fn => self.probe(|_| {\n+                let substs = self.fresh_substs_for_item(self.span, method.def_id);\n+                let fty = self.tcx.fn_sig(method.def_id).subst(self.tcx, substs);\n+                let fty = self.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, fty);\n+\n+                if let Some(self_ty) = self_ty {\n+                    if self\n+                        .at(&ObligationCause::dummy(), self.param_env)\n+                        .sup(fty.inputs()[0], self_ty)\n+                        .is_err()\n+                    {\n+                        return false;\n                     }\n-                    self.can_sub(self.param_env, fty.output(), expected).is_ok()\n-                })\n-            }\n+                }\n+                self.can_sub(self.param_env, fty.output(), expected).is_ok()\n+            }),\n             _ => false,\n         }\n     }\n@@ -1887,7 +1883,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn xform_method_sig(&self, method: DefId, substs: SubstsRef<'tcx>) -> ty::FnSig<'tcx> {\n-        let fn_sig = self.tcx.bound_fn_sig(method);\n+        let fn_sig = self.tcx.fn_sig(method);\n         debug!(?fn_sig);\n \n         assert!(!substs.has_escaping_bound_vars());"}, {"sha": "31d55a41d8a31b6d91b3d533d95a2008ab0b87ad", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty_span = match rcvr_ty.kind() {\n             ty::Param(param_type) => {\n-                Some(param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()))\n+                Some(param_type.span_from_generics(self.tcx, self.body_id.to_def_id()))\n             }\n             ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n             _ => None,\n@@ -403,7 +403,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 args,\n                 sugg_span,\n             );\n-\n             self.note_candidates_on_method_error(\n                 rcvr_ty,\n                 item_name,\n@@ -496,9 +495,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::Param(_) => {\n                                 // Account for `fn` items like in `issue-35677.rs` to\n                                 // suggest restricting its type params.\n-                                let parent_body =\n-                                    hir.body_owner(hir::BodyId { hir_id: self.body_id });\n-                                Some(hir.get(parent_body))\n+                                Some(hir.get_by_def_id(self.body_id))\n                             }\n                             ty::Adt(def, _) => {\n                                 def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n@@ -1131,6 +1128,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ty::AssocKind::Fn => self\n                                 .tcx\n                                 .fn_sig(item.def_id)\n+                                .subst_identity()\n                                 .inputs()\n                                 .skip_binder()\n                                 .get(0)\n@@ -1267,7 +1265,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && let Some(assoc) = self.associated_value(*impl_did, item_name)\n                 && assoc.kind == ty::AssocKind::Fn\n             {\n-                let sig = self.tcx.fn_sig(assoc.def_id);\n+                let sig = self.tcx.fn_sig(assoc.def_id).subst_identity();\n                 sig.inputs().skip_binder().get(0).and_then(|first| if first.peel_refs() == rcvr_ty.peel_refs() {\n                     None\n                 } else {\n@@ -1343,7 +1341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => None,\n         });\n         if let Some((field, field_ty)) = field_receiver {\n-            let scope = tcx.parent_module(self.body_id);\n+            let scope = tcx.parent_module_from_def_id(self.body_id);\n             let is_accessible = field.vis.is_accessible_from(scope, tcx);\n \n             if is_accessible {\n@@ -1593,7 +1591,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 else { return };\n \n         let map = self.infcx.tcx.hir();\n-        let body = map.body(rustc_hir::BodyId { hir_id: self.body_id });\n+        let body_id = self.tcx.hir().body_owned_by(self.body_id);\n+        let body = map.body(body_id);\n         struct LetVisitor<'a> {\n             result: Option<&'a hir::Expr<'a>>,\n             ident_name: Symbol,\n@@ -2100,7 +2099,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // just changing the path.\n                     && pick.item.fn_has_self_parameter\n                     && let Some(self_ty) =\n-                        self.tcx.fn_sig(pick.item.def_id).inputs().skip_binder().get(0)\n+                        self.tcx.fn_sig(pick.item.def_id).subst_identity().inputs().skip_binder().get(0)\n                     && self_ty.is_ref()\n                 {\n                     let suggested_path = match deref_ty.kind() {\n@@ -2195,7 +2194,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             true\n         });\n \n-        let module_did = self.tcx.parent_module(self.body_id);\n+        let module_did = self.tcx.parent_module_from_def_id(self.body_id);\n         let (module, _, _) = self.tcx.hir().get_module(module_did);\n         let span = module.spans.inject_use_span;\n \n@@ -2353,7 +2352,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // implement the `AsRef` trait.\n                         let skip = skippable.contains(&did)\n                             || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name))\n-                            || inputs_len.map_or(false, |inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().inputs().len() != inputs_len);\n+                            || inputs_len.map_or(false, |inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().skip_binder().inputs().len() != inputs_len);\n                         // Make sure the method is defined for the *actual* receiver: we don't\n                         // want to treat `Box<Self>` as a receiver if it only works because of\n                         // an autoderef to `&self`\n@@ -2517,7 +2516,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             // Obtain the span for `param` and use it for a structured suggestion.\n             if let Some(param) = param_type {\n-                let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n+                let generics = self.tcx.generics_of(self.body_id.to_def_id());\n                 let type_param = generics.type_param(param, self.tcx);\n                 let hir = self.tcx.hir();\n                 if let Some(def_id) = type_param.def_id.as_local() {\n@@ -2733,7 +2732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // check the method arguments number\n             if let Ok(pick) = probe &&\n                 let fn_sig = self.tcx.fn_sig(pick.item.def_id) &&\n-                let fn_args = fn_sig.skip_binder().inputs() &&\n+                let fn_args = fn_sig.skip_binder().skip_binder().inputs() &&\n                 fn_args.len() == args.len() + 1 {\n                 err.span_suggestion_verbose(\n                     method_name.span.shrink_to_hi(),"}, {"sha": "0aa34f9dd70724d2b0588fec4de21bbe150d0b57", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -40,8 +40,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         body: &'tcx hir::Body<'tcx>,\n     ) -> &'tcx ty::TypeckResults<'tcx> {\n-        let item_id = self.tcx.hir().body_owner(body.id());\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().body_owner_def_id(body.id());\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is used for unit tests.\n@@ -55,7 +54,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Type only exists for constants and statics, not functions.\n         match self.tcx.hir().body_owner_kind(item_def_id) {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => {\n-                wbcx.visit_node_id(body.value.span, item_id);\n+                let item_hir_id = self.tcx.hir().local_def_id_to_hir_id(item_def_id);\n+                wbcx.visit_node_id(body.value.span, item_hir_id);\n             }\n             hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => (),\n         }\n@@ -545,6 +545,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         self.typeck_results.generator_interior_types =\n             fcx_typeck_results.generator_interior_types.clone();\n+        for (&expr_def_id, predicates) in fcx_typeck_results.generator_interior_predicates.iter() {\n+            let predicates = self.resolve(predicates.clone(), &self.fcx.tcx.def_span(expr_def_id));\n+            self.typeck_results.generator_interior_predicates.insert(expr_def_id, predicates);\n+        }\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}, {"sha": "6703d53f3805cfe2884d2a649d4c033b5149d9e5", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -38,7 +38,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{Direction, NodeIndex, INCOMING, OUTGOING};\n use rustc_graphviz as dot;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::dep_graph::{\n     DepGraphQuery, DepKind, DepNode, DepNodeExt, DepNodeFilter, EdgeFilter,\n@@ -74,7 +74,7 @@ pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n         let (if_this_changed, then_this_would_need) = {\n             let mut visitor =\n                 IfThisChanged { tcx, if_this_changed: vec![], then_this_would_need: vec![] };\n-            visitor.process_attrs(hir::CRATE_HIR_ID);\n+            visitor.process_attrs(CRATE_DEF_ID);\n             tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n             (visitor.if_this_changed, visitor.then_this_would_need)\n         };\n@@ -119,9 +119,9 @@ impl<'tcx> IfThisChanged<'tcx> {\n         value\n     }\n \n-    fn process_attrs(&mut self, hir_id: hir::HirId) {\n-        let def_id = self.tcx.hir().local_def_id(hir_id);\n+    fn process_attrs(&mut self, def_id: LocalDefId) {\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n         for attr in attrs {\n             if attr.has_name(sym::rustc_if_this_changed) {\n@@ -180,22 +180,22 @@ impl<'tcx> Visitor<'tcx> for IfThisChanged<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.process_attrs(item.hir_id());\n+        self.process_attrs(item.owner_id.def_id);\n         intravisit::walk_item(self, item);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.process_attrs(trait_item.hir_id());\n+        self.process_attrs(trait_item.owner_id.def_id);\n         intravisit::walk_trait_item(self, trait_item);\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.process_attrs(impl_item.hir_id());\n+        self.process_attrs(impl_item.owner_id.def_id);\n         intravisit::walk_impl_item(self, impl_item);\n     }\n \n     fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        self.process_attrs(s.hir_id);\n+        self.process_attrs(s.def_id);\n         intravisit::walk_field_def(self, s);\n     }\n }"}, {"sha": "87c6dfad5fa2bd01b79578277f8f8c329af1f567", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -435,6 +435,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Bool\n             | ty::Char\n             | ty::Int(..)"}, {"sha": "f7e3e4a1cc09ee2583ecbce9e4c0c2269e3c8c5a", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -26,7 +26,7 @@ use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVari\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArg;\n-use rustc_middle::ty::{self, BoundVar, List};\n+use rustc_middle::ty::{self, List};\n use rustc_span::source_map::Span;\n \n pub use rustc_middle::infer::canonical::*;\n@@ -87,12 +87,13 @@ impl<'tcx> InferCtxt<'tcx> {\n         variables: &List<CanonicalVarInfo<'tcx>>,\n         universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> CanonicalVarValues<'tcx> {\n-        let var_values: IndexVec<BoundVar, GenericArg<'tcx>> = variables\n-            .iter()\n-            .map(|info| self.instantiate_canonical_var(span, info, &universe_map))\n-            .collect();\n-\n-        CanonicalVarValues { var_values }\n+        CanonicalVarValues {\n+            var_values: self.tcx.mk_substs(\n+                variables\n+                    .iter()\n+                    .map(|info| self.instantiate_canonical_var(span, info, &universe_map)),\n+            ),\n+        }\n     }\n \n     /// Given the \"info\" about a canonical variable, creates a fresh"}, {"sha": "3e8e7734a5a5de61d34fefba70cf674f0be512d7", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -17,7 +17,7 @@ use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n-use crate::traits::{PredicateObligations, TraitEngine};\n+use crate::traits::{PredicateObligations, TraitEngine, TraitEngineExt};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n@@ -482,11 +482,8 @@ impl<'tcx> InferCtxt<'tcx> {\n         // given variable in the loop above, use that. Otherwise, use\n         // a fresh inference variable.\n         let result_subst = CanonicalVarValues {\n-            var_values: query_response\n-                .variables\n-                .iter()\n-                .enumerate()\n-                .map(|(index, info)| {\n+            var_values: self.tcx.mk_substs(query_response.variables.iter().enumerate().map(\n+                |(index, info)| {\n                     if info.is_existential() {\n                         match opt_values[BoundVar::new(index)] {\n                             Some(k) => k,\n@@ -499,8 +496,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                             universe_map[u.as_usize()]\n                         })\n                     }\n-                })\n-                .collect(),\n+                },\n+            )),\n         };\n \n         let mut obligations = vec![];"}, {"sha": "e77f2d37b7dae8d5c6314c8f22092d28d05b95b1", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -72,16 +72,15 @@ where\n         value\n     } else {\n         let delegate = FnMutDelegate {\n-            regions: &mut |br: ty::BoundRegion| match var_values.var_values[br.var].unpack() {\n+            regions: &mut |br: ty::BoundRegion| match var_values[br.var].unpack() {\n                 GenericArgKind::Lifetime(l) => l,\n                 r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n             },\n-            types: &mut |bound_ty: ty::BoundTy| match var_values.var_values[bound_ty.var].unpack() {\n+            types: &mut |bound_ty: ty::BoundTy| match var_values[bound_ty.var].unpack() {\n                 GenericArgKind::Type(ty) => ty,\n                 r => bug!(\"{:?} is a type but value is {:?}\", bound_ty, r),\n             },\n-            consts: &mut |bound_ct: ty::BoundVar, _| match var_values.var_values[bound_ct].unpack()\n-            {\n+            consts: &mut |bound_ct: ty::BoundVar, _| match var_values[bound_ct].unpack() {\n                 GenericArgKind::Const(ct) => ct,\n                 c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n             },"}, {"sha": "a567b6acdbeeb2dc802175bea078a979d6795a7c", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 26, "deletions": 88, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -37,7 +37,10 @@ use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, InferConst, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, FallibleTypeFolder, InferConst, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable,\n+    TypeVisitable,\n+};\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -140,8 +143,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         let a = self.shallow_resolve(a);\n         let b = self.shallow_resolve(b);\n \n-        let a_is_expected = relation.a_is_expected();\n-\n         match (a.kind(), b.kind()) {\n             (\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),\n@@ -158,11 +159,11 @@ impl<'tcx> InferCtxt<'tcx> {\n             }\n \n             (ty::ConstKind::Infer(InferConst::Var(vid)), _) => {\n-                return self.unify_const_variable(relation.param_env(), vid, b, a_is_expected);\n+                return self.unify_const_variable(vid, b);\n             }\n \n             (_, ty::ConstKind::Infer(InferConst::Var(vid))) => {\n-                return self.unify_const_variable(relation.param_env(), vid, a, !a_is_expected);\n+                return self.unify_const_variable(vid, a);\n             }\n             (ty::ConstKind::Unevaluated(..), _) if self.tcx.lazy_normalization() => {\n                 // FIXME(#59490): Need to remove the leak check to accommodate\n@@ -223,10 +224,8 @@ impl<'tcx> InferCtxt<'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn unify_const_variable(\n         &self,\n-        param_env: ty::ParamEnv<'tcx>,\n         target_vid: ty::ConstVid<'tcx>,\n         ct: ty::Const<'tcx>,\n-        vid_is_expected: bool,\n     ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         let (for_universe, span) = {\n             let mut inner = self.inner.borrow_mut();\n@@ -239,8 +238,12 @@ impl<'tcx> InferCtxt<'tcx> {\n                 ConstVariableValue::Unknown { universe } => (universe, var_value.origin.span),\n             }\n         };\n-        let value = ConstInferUnifier { infcx: self, span, param_env, for_universe, target_vid }\n-            .relate(ct, ct)?;\n+        let value = ct.try_fold_with(&mut ConstInferUnifier {\n+            infcx: self,\n+            span,\n+            for_universe,\n+            target_vid,\n+        })?;\n \n         self.inner.borrow_mut().const_unification_table().union_value(\n             target_vid,\n@@ -800,8 +803,6 @@ struct ConstInferUnifier<'cx, 'tcx> {\n \n     span: Span,\n \n-    param_env: ty::ParamEnv<'tcx>,\n-\n     for_universe: ty::UniverseIndex,\n \n     /// The vid of the const variable that is in the process of being\n@@ -810,69 +811,23 @@ struct ConstInferUnifier<'cx, 'tcx> {\n     target_vid: ty::ConstVid<'tcx>,\n }\n \n-// We use `TypeRelation` here to propagate `RelateResult` upwards.\n-//\n-// Both inputs are expected to be the same.\n-impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn intercrate(&self) -> bool {\n-        assert!(!self.infcx.intercrate);\n-        false\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"ConstInferUnifier\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _variance: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        // We don't care about variance here.\n-        self.relate(a, b)\n-    }\n+impl<'tcx> FallibleTypeFolder<'tcx> for ConstInferUnifier<'_, 'tcx> {\n+    type Error = TypeError<'tcx>;\n \n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n     }\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n-    fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug_assert_eq!(t, _t);\n-\n+    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, TypeError<'tcx>> {\n         match t.kind() {\n             &ty::Infer(ty::TyVar(vid)) => {\n                 let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n                 let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n                 match probe {\n                     TypeVariableValue::Known { value: u } => {\n                         debug!(\"ConstOccursChecker: known value {:?}\", u);\n-                        self.tys(u, u)\n+                        u.try_fold_with(self)\n                     }\n                     TypeVariableValue::Unknown { universe } => {\n                         if self.for_universe.can_name(universe) {\n@@ -892,16 +847,15 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                 }\n             }\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => Ok(t),\n-            _ => relate::super_relate_tys(self, t, t),\n+            _ => t.try_super_fold_with(self),\n         }\n     }\n \n-    fn regions(\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn try_fold_region(\n         &mut self,\n         r: ty::Region<'tcx>,\n-        _r: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug_assert_eq!(r, _r);\n+    ) -> Result<ty::Region<'tcx>, TypeError<'tcx>> {\n         debug!(\"ConstInferUnifier: r={:?}\", r);\n \n         match *r {\n@@ -930,14 +884,8 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self))]\n-    fn consts(\n-        &mut self,\n-        c: ty::Const<'tcx>,\n-        _c: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        debug_assert_eq!(c, _c);\n-\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn try_fold_const(&mut self, c: ty::Const<'tcx>) -> Result<ty::Const<'tcx>, TypeError<'tcx>> {\n         match c.kind() {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n                 // Check if the current unification would end up\n@@ -958,7 +906,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                 let var_value =\n                     self.infcx.inner.borrow_mut().const_unification_table().probe_value(vid);\n                 match var_value.val {\n-                    ConstVariableValue::Known { value: u } => self.consts(u, u),\n+                    ConstVariableValue::Known { value: u } => u.try_fold_with(self),\n                     ConstVariableValue::Unknown { universe } => {\n                         if self.for_universe.can_name(universe) {\n                             Ok(c)\n@@ -977,17 +925,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     }\n                 }\n             }\n-            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n-                let substs = self.relate_with_variance(\n-                    ty::Variance::Invariant,\n-                    ty::VarianceDiagInfo::default(),\n-                    substs,\n-                    substs,\n-                )?;\n-\n-                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n-            }\n-            _ => relate::super_relate_consts(self, c, c),\n+            _ => c.try_super_fold_with(self),\n         }\n     }\n }"}, {"sha": "b11db8396c9203e9e840c599590c8da6a2885c6e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -79,6 +79,7 @@ use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n+mod note_and_explain;\n mod suggest;\n \n pub(crate) mod need_type_info;\n@@ -1344,8 +1345,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n \n             (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n-                let sig1 = self.tcx.bound_fn_sig(*did1).subst(self.tcx, substs1);\n-                let sig2 = self.tcx.bound_fn_sig(*did2).subst(self.tcx, substs2);\n+                let sig1 = self.tcx.fn_sig(*did1).subst(self.tcx, substs1);\n+                let sig2 = self.tcx.fn_sig(*did2).subst(self.tcx, substs2);\n                 let mut values = self.cmp_fn_sig(&sig1, &sig2);\n                 let path1 = format!(\" {{{}}}\", self.tcx.def_path_str_with_substs(*did1, substs1));\n                 let path2 = format!(\" {{{}}}\", self.tcx.def_path_str_with_substs(*did2, substs2));\n@@ -1356,7 +1357,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n \n             (ty::FnDef(did1, substs1), ty::FnPtr(sig2)) => {\n-                let sig1 = self.tcx.bound_fn_sig(*did1).subst(self.tcx, substs1);\n+                let sig1 = self.tcx.fn_sig(*did1).subst(self.tcx, substs1);\n                 let mut values = self.cmp_fn_sig(&sig1, sig2);\n                 values.0.push_highlighted(format!(\n                     \" {{{}}}\",\n@@ -1366,7 +1367,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             }\n \n             (ty::FnPtr(sig1), ty::FnDef(did2, substs2)) => {\n-                let sig2 = self.tcx.bound_fn_sig(*did2).subst(self.tcx, substs2);\n+                let sig2 = self.tcx.fn_sig(*did2).subst(self.tcx, substs2);\n                 let mut values = self.cmp_fn_sig(sig1, &sig2);\n                 values.1.push_normal(format!(\n                     \" {{{}}}\",\n@@ -1841,19 +1842,13 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n                 self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n                 self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n+                self.suggest_function_pointers(cause, span, &exp_found, diag);\n             }\n         }\n \n-        // In some (most?) cases cause.body_id points to actual body, but in some cases\n-        // it's an actual definition. According to the comments (e.g. in\n-        // rustc_hir_analysis/check/compare_impl_item.rs:compare_predicate_entailment) the latter\n-        // is relied upon by some other code. This might (or might not) need cleanup.\n-        let body_owner_def_id =\n-            self.tcx.hir().opt_local_def_id(cause.body_id).unwrap_or_else(|| {\n-                self.tcx.hir().body_owner_def_id(hir::BodyId { hir_id: cause.body_id })\n-            });\n         self.check_and_note_conflicting_crates(diag, terr);\n-        self.tcx.note_and_explain_type_err(diag, terr, cause, span, body_owner_def_id.to_def_id());\n+\n+        self.note_and_explain_type_err(diag, terr, cause, span, cause.body_id.to_def_id());\n \n         if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values\n             && let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind()\n@@ -2585,7 +2580,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     /// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n     /// FloatVar inference type are compatible with themselves or their concrete types (Int and\n     /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n-    pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    pub fn same_type_modulo_infer<T: relate::Relate<'tcx>>(&self, a: T, b: T) -> bool {\n         let (a, b) = self.resolve_vars_if_possible((a, b));\n         SameTypeModuloInfer(self).relate(a, b).is_ok()\n     }"}, {"sha": "4c0f457b46a7c76cbee3ebc7e4743e90272b4d08", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -65,7 +65,7 @@ pub fn find_param_with_region<'tcx>(\n \n     let owner_id = hir.body_owner(body_id);\n     let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n-    let poly_fn_sig = tcx.fn_sig(id);\n+    let poly_fn_sig = tcx.fn_sig(id).subst_identity();\n \n     let fn_sig = tcx.liberate_late_bound_regions(id, poly_fn_sig);\n     let body = hir.body(body_id);"}, {"sha": "34e8edd6140b211002eaf1f6de68b5b3a0bc8fcf", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,654 @@\n+use super::TypeErrCtxt;\n+use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n+use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n+use rustc_hir::{self as hir, def::DefKind};\n+use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::print::Printer;\n+use rustc_middle::{\n+    traits::ObligationCause,\n+    ty::{self, error::TypeError, print::FmtPrinter, suggest_constraining_type_param, Ty},\n+};\n+use rustc_span::{def_id::DefId, sym, BytePos, Span, Symbol};\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub fn note_and_explain_type_err(\n+        &self,\n+        diag: &mut Diagnostic,\n+        err: TypeError<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        sp: Span,\n+        body_owner_def_id: DefId,\n+    ) {\n+        use ty::error::TypeError::*;\n+        debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n+\n+        let tcx = self.tcx;\n+\n+        match err {\n+            ArgumentSorts(values, _) | Sorts(values) => {\n+                match (values.expected.kind(), values.found.kind()) {\n+                    (ty::Closure(..), ty::Closure(..)) => {\n+                        diag.note(\"no two closures, even if identical, have the same type\");\n+                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n+                    }\n+                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n+                        // Issue #63167\n+                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    }\n+                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n+                        if let Ok(\n+                            // Issue #53280\n+                            snippet,\n+                        ) = tcx.sess.source_map().span_to_snippet(sp) =>\n+                    {\n+                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n+                            diag.span_suggestion(\n+                                sp,\n+                                \"use a float literal\",\n+                                format!(\"{}.0\", snippet),\n+                                MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                    (ty::Param(expected), ty::Param(found)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let e_span = tcx.def_span(generics.type_param(expected, tcx).def_id);\n+                        if !sp.contains(e_span) {\n+                            diag.span_label(e_span, \"expected type parameter\");\n+                        }\n+                        let f_span = tcx.def_span(generics.type_param(found, tcx).def_id);\n+                        if !sp.contains(f_span) {\n+                            diag.span_label(f_span, \"found type parameter\");\n+                        }\n+                        diag.note(\n+                            \"a type parameter was expected, but a different one was found; \\\n+                             you might be missing a type parameter or trait bound\",\n+                        );\n+                        diag.note(\n+                            \"for more information, visit \\\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n+                        );\n+                    }\n+                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                        diag.note(\"an associated type was expected, but a different one was found\");\n+                    }\n+                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n+                        if tcx.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n+                    {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        let hir = tcx.hir();\n+                        let mut note = true;\n+                        if let Some(generics) = generics\n+                            .type_param(p, tcx)\n+                            .def_id\n+                            .as_local()\n+                            .map(|id| hir.local_def_id_to_hir_id(id))\n+                            .and_then(|id| tcx.hir().find_parent(id))\n+                            .as_ref()\n+                            .and_then(|node| node.generics())\n+                        {\n+                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n+                            // FIXME: extract this logic for use in other diagnostics.\n+                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(tcx);\n+                            let path =\n+                                tcx.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n+                            let item_name = tcx.item_name(proj.def_id);\n+                            let item_args = self.format_generic_args(assoc_substs);\n+\n+                            let path = if path.ends_with('>') {\n+                                format!(\n+                                    \"{}, {}{} = {}>\",\n+                                    &path[..path.len() - 1],\n+                                    item_name,\n+                                    item_args,\n+                                    p\n+                                )\n+                            } else {\n+                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n+                            };\n+                            note = !suggest_constraining_type_param(\n+                                tcx,\n+                                generics,\n+                                diag,\n+                                &format!(\"{}\", proj.self_ty()),\n+                                &path,\n+                                None,\n+                            );\n+                        }\n+                        if note {\n+                            diag.note(\"you might be missing a type parameter or trait bound\");\n+                        }\n+                    }\n+                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n+                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        diag.help(\"type parameters must be constrained to match other types\");\n+                        if tcx.sess.teach(&diag.get_code().unwrap()) {\n+                            diag.help(\n+                                \"given a type parameter `T` and a method `foo`:\n+```\n+trait Trait<T> { fn foo(&tcx) -> T; }\n+```\n+the only ways to implement method `foo` are:\n+- constrain `T` with an explicit type:\n+```\n+impl Trait<String> for X {\n+    fn foo(&tcx) -> String { String::new() }\n+}\n+```\n+- add a trait bound to `T` and call a method on that trait that returns `Self`:\n+```\n+impl<T: std::default::Default> Trait<T> for X {\n+    fn foo(&tcx) -> T { <T as std::default::Default>::default() }\n+}\n+```\n+- change `foo` to return an argument of type `T`:\n+```\n+impl<T> Trait<T> for X {\n+    fn foo(&tcx, x: T) -> T { x }\n+}\n+```\",\n+                            );\n+                        }\n+                        diag.note(\n+                            \"for more information, visit \\\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n+                        );\n+                    }\n+                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        diag.help(&format!(\n+                            \"every closure has a distinct type and so could not always match the \\\n+                             caller-chosen type of parameter `{}`\",\n+                            p\n+                        ));\n+                    }\n+                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                    }\n+                    (ty::Alias(ty::Projection, proj_ty), _) if tcx.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                        self.expected_projection(\n+                            diag,\n+                            proj_ty,\n+                            values,\n+                            body_owner_def_id,\n+                            cause.code(),\n+                        );\n+                    }\n+                    (_, ty::Alias(ty::Projection, proj_ty)) if tcx.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                        let msg = format!(\n+                            \"consider constraining the associated type `{}` to `{}`\",\n+                            values.found, values.expected,\n+                        );\n+                        if !(self.suggest_constraining_opaque_associated_type(\n+                            diag,\n+                            &msg,\n+                            proj_ty,\n+                            values.expected,\n+                        ) || self.suggest_constraint(\n+                            diag,\n+                            &msg,\n+                            body_owner_def_id,\n+                            proj_ty,\n+                            values.expected,\n+                        )) {\n+                            diag.help(&msg);\n+                            diag.note(\n+                                \"for more information, visit \\\n+                                https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n+                            );\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                debug!(\n+                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n+                    values.expected,\n+                    values.expected.kind(),\n+                    values.found,\n+                    values.found.kind(),\n+                );\n+            }\n+            CyclicTy(ty) => {\n+                // Watch out for various cases of cyclic types and try to explain.\n+                if ty.is_closure() || ty.is_generator() {\n+                    diag.note(\n+                        \"closures cannot capture themselves or take themselves as argument;\\n\\\n+                         this error may be the result of a recent compiler bug-fix,\\n\\\n+                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n+                         for more information\",\n+                    );\n+                }\n+            }\n+            TargetFeatureCast(def_id) => {\n+                let target_spans = tcx.get_attrs(def_id, sym::target_feature).map(|attr| attr.span);\n+                diag.note(\n+                    \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n+                );\n+                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn suggest_constraint(\n+        &self,\n+        diag: &mut Diagnostic,\n+        msg: &str,\n+        body_owner_def_id: DefId,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(tcx);\n+        if let Some(item) = tcx.hir().get_if_local(body_owner_def_id) {\n+            if let Some(hir_generics) = item.generics() {\n+                // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n+                // This will also work for `impl Trait`.\n+                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n+                    let generics = tcx.generics_of(body_owner_def_id);\n+                    generics.type_param(param_ty, tcx).def_id\n+                } else {\n+                    return false;\n+                };\n+                let Some(def_id) = def_id.as_local() else {\n+                    return false;\n+                };\n+\n+                // First look in the `where` clause, as this might be\n+                // `fn foo<T>(x: T) where T: Trait`.\n+                for pred in hir_generics.bounds_for_param(def_id) {\n+                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n+                        diag,\n+                        &trait_ref,\n+                        pred.bounds,\n+                        &assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n+                        false,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// An associated type was expected and a different type was found.\n+    ///\n+    /// We perform a few different checks to see what we can suggest:\n+    ///\n+    ///  - In the current item, look for associated functions that return the expected type and\n+    ///    suggest calling them. (Not a structured suggestion.)\n+    ///  - If any of the item's generic bounds can be constrained, we suggest constraining the\n+    ///    associated type to the found type.\n+    ///  - If the associated type has a default type and was expected inside of a `trait`, we\n+    ///    mention that this is disallowed.\n+    ///  - If all other things fail, and the error is not because of a mismatch between the `trait`\n+    ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n+    ///    fn that returns the type.\n+    fn expected_projection(\n+        &self,\n+        diag: &mut Diagnostic,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        values: ExpectedFound<Ty<'tcx>>,\n+        body_owner_def_id: DefId,\n+        cause_code: &ObligationCauseCode<'_>,\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let msg = format!(\n+            \"consider constraining the associated type `{}` to `{}`\",\n+            values.expected, values.found\n+        );\n+        let body_owner = tcx.hir().get_if_local(body_owner_def_id);\n+        let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n+\n+        // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n+        let callable_scope = matches!(\n+            body_owner,\n+            Some(\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+                    | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n+            )\n+        );\n+        let impl_comparison =\n+            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        if !callable_scope || impl_comparison {\n+            // We do not want to suggest calling functions when the reason of the\n+            // type error is a comparison of an `impl` with its `trait` or when the\n+            // scope is outside of a `Body`.\n+        } else {\n+            // If we find a suitable associated function that returns the expected type, we don't\n+            // want the more general suggestion later in this method about \"consider constraining\n+            // the associated type or calling a method that returns the associated type\".\n+            let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n+                diag,\n+                assoc.container_id(tcx),\n+                current_method_ident,\n+                proj_ty.def_id,\n+                values.expected,\n+            );\n+            // Possibly suggest constraining the associated type to conform to the\n+            // found type.\n+            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n+                || point_at_assoc_fn\n+            {\n+                return;\n+            }\n+        }\n+\n+        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n+\n+        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n+            return;\n+        }\n+\n+        if !impl_comparison {\n+            // Generic suggestion when we can't be more specific.\n+            if callable_scope {\n+                diag.help(&format!(\n+                    \"{} or calling a method that returns `{}`\",\n+                    msg, values.expected\n+                ));\n+            } else {\n+                diag.help(&msg);\n+            }\n+            diag.note(\n+                \"for more information, visit \\\n+                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n+            );\n+        }\n+        if tcx.sess.teach(&diag.get_code().unwrap()) {\n+            diag.help(\n+                \"given an associated type `T` and a method `foo`:\n+```\n+trait Trait {\n+type T;\n+fn foo(&tcx) -> Self::T;\n+}\n+```\n+the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n+```\n+impl Trait for X {\n+type T = String;\n+fn foo(&tcx) -> Self::T { String::new() }\n+}\n+```\",\n+            );\n+        }\n+    }\n+\n+    /// When the expected `impl Trait` is not defined in the current item, it will come from\n+    /// a return type. This can occur when dealing with `TryStream` (#71035).\n+    fn suggest_constraining_opaque_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        msg: &str,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n+            let opaque_local_def_id = def_id.as_local();\n+            let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n+                match &tcx.hir().expect_item(opaque_local_def_id).kind {\n+                    hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n+                    _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n+                }\n+            } else {\n+                return false;\n+            };\n+\n+            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(tcx);\n+\n+            self.constrain_generic_bound_associated_type_structured_suggestion(\n+                diag,\n+                &trait_ref,\n+                opaque_hir_ty.bounds,\n+                assoc,\n+                assoc_substs,\n+                ty,\n+                msg,\n+                true,\n+            )\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_methods_that_satisfy_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        assoc_container_id: DefId,\n+        current_method_ident: Option<Symbol>,\n+        proj_ty_item_def_id: DefId,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let items = tcx.associated_items(assoc_container_id);\n+        // Find all the methods in the trait that could be called to construct the\n+        // expected associated type.\n+        // FIXME: consider suggesting the use of associated `const`s.\n+        let methods: Vec<(Span, String)> = items\n+            .in_definition_order()\n+            .filter(|item| {\n+                ty::AssocKind::Fn == item.kind && Some(item.name) != current_method_ident\n+            })\n+            .filter_map(|item| {\n+                let method = tcx.fn_sig(item.def_id).subst_identity();\n+                match *method.output().skip_binder().kind() {\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n+                        if item_def_id == proj_ty_item_def_id =>\n+                    {\n+                        Some((\n+                            tcx.def_span(item.def_id),\n+                            format!(\"consider calling `{}`\", tcx.def_path_str(item.def_id)),\n+                        ))\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect();\n+        if !methods.is_empty() {\n+            // Use a single `help:` to show all the methods in the trait that can\n+            // be used to construct the expected associated type.\n+            let mut span: MultiSpan =\n+                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n+            let msg = format!(\n+                \"{some} method{s} {are} available that return{r} `{ty}`\",\n+                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n+                s = pluralize!(methods.len()),\n+                are = pluralize!(\"is\", methods.len()),\n+                r = if methods.len() == 1 { \"s\" } else { \"\" },\n+                ty = expected\n+            );\n+            for (sp, label) in methods.into_iter() {\n+                span.push_span_label(sp, label);\n+            }\n+            diag.span_help(span, &msg);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn point_at_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        body_owner_def_id: DefId,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let Some(hir_id) = body_owner_def_id.as_local() else {\n+            return false;\n+        };\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(hir_id);\n+        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n+        // `expected` and point at it.\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n+        let item = tcx.hir().find_by_def_id(parent_id.def_id);\n+\n+        debug!(\"expected_projection parent item {:?}\", item);\n+\n+        let param_env = tcx.param_env(body_owner_def_id);\n+\n+        match item {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n+                // FIXME: account for `#![feature(specialization)]`\n+                for item in &items[..] {\n+                    match item.kind {\n+                        hir::AssocItemKind::Type => {\n+                            // FIXME: account for returning some type in a trait fn impl that has\n+                            // an assoc type as a return type (#72076).\n+                            if let hir::Defaultness::Default { has_value: true } =\n+                                tcx.impl_defaultness(item.id.owner_id)\n+                            {\n+                                let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n+                                if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                                    diag.span_label(\n+                                        item.span,\n+                                        \"associated type defaults can't be assumed inside the \\\n+                                            trait defining them\",\n+                                    );\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { items, .. }),\n+                ..\n+            })) => {\n+                for item in &items[..] {\n+                    if let hir::AssocItemKind::Type = item.kind {\n+                        let assoc_ty = tcx.bound_type_of(item.id.owner_id).subst_identity();\n+\n+                        if self.infcx.can_eq(param_env, assoc_ty, found).is_ok() {\n+                            diag.span_label(item.span, \"expected this associated type\");\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+\n+    /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n+    /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n+    ///\n+    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n+    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n+    /// trait bound as the one we're looking for. This can help in cases where the associated\n+    /// type is defined on a supertrait of the one present in the bounds.\n+    fn constrain_generic_bound_associated_type_structured_suggestion(\n+        &self,\n+        diag: &mut Diagnostic,\n+        trait_ref: &ty::TraitRef<'tcx>,\n+        bounds: hir::GenericBounds<'_>,\n+        assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n+        ty: Ty<'tcx>,\n+        msg: &str,\n+        is_bound_surely_present: bool,\n+    ) -> bool {\n+        // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n+\n+        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n+            _ => None,\n+        });\n+\n+        let matching_trait_bounds = trait_bounds\n+            .clone()\n+            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n+            .collect::<Vec<_>>();\n+\n+        let span = match &matching_trait_bounds[..] {\n+            &[ptr] => ptr.span,\n+            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n+                &[ptr] => ptr.span,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        };\n+\n+        self.constrain_associated_type_structured_suggestion(\n+            diag,\n+            span,\n+            assoc,\n+            assoc_substs,\n+            ty,\n+            msg,\n+        )\n+    }\n+\n+    /// Given a span corresponding to a bound, provide a structured suggestion to set an\n+    /// associated type to a given type `ty`.\n+    fn constrain_associated_type_structured_suggestion(\n+        &self,\n+        diag: &mut Diagnostic,\n+        span: Span,\n+        assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n+        ty: Ty<'tcx>,\n+        msg: &str,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        if let Ok(has_params) =\n+            tcx.sess.source_map().span_to_snippet(span).map(|snippet| snippet.ends_with('>'))\n+        {\n+            let (span, sugg) = if has_params {\n+                let pos = span.hi() - BytePos(1);\n+                let span = Span::new(pos, pos, span.ctxt(), span.parent());\n+                (span, format!(\", {} = {}\", assoc.ident(tcx), ty))\n+            } else {\n+                let item_args = self.format_generic_args(assoc_substs);\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(tcx), item_args, ty))\n+            };\n+            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    pub fn format_generic_args(&self, args: &[ty::GenericArg<'tcx>]) -> String {\n+        FmtPrinter::new(self.tcx, hir::def::Namespace::TypeNS)\n+            .path_generic_args(Ok, args)\n+            .expect(\"could not write to `String`.\")\n+            .into_buffer()\n+    }\n+}"}, {"sha": "23063e80b05ff117091c95c35bdfa728f8de1584", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::traits::{\n     StatementAsExpression,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self as ty, Ty, TypeVisitable};\n+use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n use crate::errors::SuggAddLetForLetChains;\n@@ -351,6 +351,118 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n+    pub(super) fn suggest_function_pointers(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\"suggest_function_pointers(cause={:?}, exp_found={:?})\", cause, exp_found);\n+        let ty::error::ExpectedFound { expected, found } = exp_found;\n+        let expected_inner = expected.peel_refs();\n+        let found_inner = found.peel_refs();\n+        if !expected_inner.is_fn() || !found_inner.is_fn() {\n+            return;\n+        }\n+        match (&expected_inner.kind(), &found_inner.kind()) {\n+            (ty::FnPtr(sig), ty::FnDef(did, substs)) => {\n+                let expected_sig = &(self.normalize_fn_sig)(*sig);\n+                let found_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.fn_sig(*did).subst(self.tcx, substs));\n+\n+                let fn_name = self.tcx.def_path_str_with_substs(*did, substs);\n+\n+                if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n+                    || !sig.is_suggestable(self.tcx, true)\n+                    || ty::util::is_intrinsic(self.tcx, *did)\n+                {\n+                    return;\n+                }\n+\n+                let (msg, sug) = match (expected.is_ref(), found.is_ref()) {\n+                    (true, false) => {\n+                        let msg = \"consider using a reference\";\n+                        let sug = format!(\"&{fn_name}\");\n+                        (msg, sug)\n+                    }\n+                    (false, true) => {\n+                        let msg = \"consider removing the reference\";\n+                        let sug = format!(\"{fn_name}\");\n+                        (msg, sug)\n+                    }\n+                    (true, true) => {\n+                        diag.note(\"fn items are distinct from fn pointers\");\n+                        let msg = \"consider casting to a fn pointer\";\n+                        let sug = format!(\"&({fn_name} as {sig})\");\n+                        (msg, sug)\n+                    }\n+                    (false, false) => {\n+                        diag.note(\"fn items are distinct from fn pointers\");\n+                        let msg = \"consider casting to a fn pointer\";\n+                        let sug = format!(\"{fn_name} as {sig}\");\n+                        (msg, sug)\n+                    }\n+                };\n+                diag.span_suggestion(span, msg, sug, Applicability::MaybeIncorrect);\n+            }\n+            (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n+                let expected_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.fn_sig(*did1).subst(self.tcx, substs1));\n+                let found_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.fn_sig(*did2).subst(self.tcx, substs2));\n+\n+                if self.same_type_modulo_infer(*expected_sig, *found_sig) {\n+                    diag.note(\"different fn items have unique types, even if their signatures are the same\");\n+                }\n+\n+                if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n+                    || !found_sig.is_suggestable(self.tcx, true)\n+                    || !expected_sig.is_suggestable(self.tcx, true)\n+                    || ty::util::is_intrinsic(self.tcx, *did1)\n+                    || ty::util::is_intrinsic(self.tcx, *did2)\n+                {\n+                    return;\n+                }\n+\n+                let fn_name = self.tcx.def_path_str_with_substs(*did2, substs2);\n+                let sug = if found.is_ref() {\n+                    format!(\"&({fn_name} as {found_sig})\")\n+                } else {\n+                    format!(\"{fn_name} as {found_sig}\")\n+                };\n+\n+                let msg = format!(\n+                    \"consider casting both fn items to fn pointers using `as {expected_sig}`\"\n+                );\n+\n+                diag.span_suggestion_hidden(span, msg, sug, Applicability::MaybeIncorrect);\n+            }\n+            (ty::FnDef(did, substs), ty::FnPtr(sig)) => {\n+                let expected_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.fn_sig(*did).subst(self.tcx, substs));\n+                let found_sig = &(self.normalize_fn_sig)(*sig);\n+\n+                if !self.same_type_modulo_infer(*found_sig, *expected_sig) {\n+                    return;\n+                }\n+\n+                let fn_name = self.tcx.def_path_str_with_substs(*did, substs);\n+\n+                let casting = if expected.is_ref() {\n+                    format!(\"&({fn_name} as {found_sig})\")\n+                } else {\n+                    format!(\"{fn_name} as {found_sig}\")\n+                };\n+\n+                diag.help(&format!(\"consider casting the fn item to a fn pointer: `{}`\", casting));\n+            }\n+            _ => {\n+                return;\n+            }\n+        };\n+    }\n+\n     pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n             (expected.kind(), found.kind())\n@@ -411,8 +523,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         span: Span,\n     ) {\n         let hir = self.tcx.hir();\n-        let fn_hir_id = hir.parent_id(cause.body_id);\n-        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n+        if let Some(node) = self.tcx.hir().find_by_def_id(cause.body_id) &&\n             let hir::Node::Item(hir::Item {\n                     kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n                 }) = node {"}, {"sha": "83d71edc2abd927a640819ce5a71e28b4b8409a4", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -209,6 +209,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Closure(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::GeneratorWitness(..) => t.super_fold_with(self),\n \n             ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),"}, {"sha": "b92b162a9786a652dd51a0e8085251718e8f5a4f", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -79,7 +79,8 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(Box::new(self.fields.trace.clone()));\n-        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n+        // GLB(&'static u8, &'a u8) == &RegionLUB('static, 'a) u8 == &'static u8\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n             self.tcx(),\n             origin,\n             a,"}, {"sha": "f6e0554fd1f951634bfa9b78a7123b3338b286d9", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -79,7 +79,8 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(Box::new(self.fields.trace.clone()));\n-        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n+        // LUB(&'static u8, &'a u8) == &RegionGLB('static, 'a) u8 == &'a u8\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n             self.tcx(),\n             origin,\n             a,"}, {"sha": "f83219b8ee2a0e0ad1e80f374f6d12dd4574aa5c", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -663,13 +663,13 @@ where\n         debug!(?v_b);\n \n         if self.ambient_covariance() {\n-            // Covariance: a <= b. Hence, `b: a`.\n-            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n+            // Covariant: &'a u8 <: &'b u8. Hence, `'a: 'b`.\n+            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n         }\n \n         if self.ambient_contravariance() {\n-            // Contravariant: b <= a. Hence, `a: b`.\n-            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n+            // Contravariant: &'b u8 <: &'a u8. Hence, `'b: 'a`.\n+            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n         }\n \n         Ok(a)"}, {"sha": "b68b0baaa4062bd7df559e134fbb21b5b5725f49", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,7 +3,7 @@ use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def::DefKind;\n use hir::def_id::{DefId, LocalDefId};\n-use hir::{HirId, OpaqueTyOrigin};\n+use hir::OpaqueTyOrigin;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n@@ -48,7 +48,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     pub fn replace_opaque_types_with_inference_vars<T: TypeFoldable<'tcx>>(\n         &self,\n         value: T,\n-        body_id: HirId,\n+        body_id: LocalDefId,\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {"}, {"sha": "e3d9566917125546c49c5383572fe27625861895", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -112,7 +112,7 @@ fn compute_components<'tcx>(\n             }\n \n             // All regions are bound inside a witness\n-            ty::GeneratorWitness(..) => (),\n+            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) => (),\n \n             // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n             // is implied by the environment is done in regionck."}, {"sha": "51c34f0d55f6ff715336cc2b45d53c3e2df19a16", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -191,12 +191,13 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(Box::new(self.fields.trace.clone()));\n+        // Subtype(&'a u8, &'b u8) => Outlives('a: 'b) => SubRegion('b, 'a)\n         self.fields\n             .infcx\n             .inner\n             .borrow_mut()\n             .unwrap_region_constraints()\n-            .make_subregion(origin, a, b);\n+            .make_subregion(origin, b, a);\n \n         Ok(a)\n     }"}, {"sha": "f75344f20b6d98e842f622dfd3e39d23e8e22385", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -36,11 +36,19 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         obligation: PredicateObligation<'tcx>,\n     );\n \n-    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n-\n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n+    fn collect_remaining_errors(&mut self) -> Vec<FulfillmentError<'tcx>>;\n+\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n+\n+    /// Among all pending obligations, collect those are stalled on a inference variable which has\n+    /// changed since the last call to `select_where_possible`. Those obligations are marked as\n+    /// successful and returned.\n+    fn drain_unstalled_obligations(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+    ) -> Vec<PredicateObligation<'tcx>>;\n }\n \n pub trait TraitEngineExt<'tcx> {\n@@ -49,6 +57,8 @@ pub trait TraitEngineExt<'tcx> {\n         infcx: &InferCtxt<'tcx>,\n         obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n     );\n+\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n }\n \n impl<'tcx, T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n@@ -61,4 +71,13 @@ impl<'tcx, T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n             self.register_predicate_obligation(infcx, obligation);\n         }\n     }\n+\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = self.select_where_possible(infcx);\n+        if !errors.is_empty() {\n+            return errors;\n+        }\n+\n+        self.collect_remaining_errors()\n+    }\n }"}, {"sha": "3a82899660b19df2e1c842cd7bb60a0624522358", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -8,6 +8,7 @@ mod project;\n mod structural_impls;\n pub mod util;\n \n+use hir::def_id::LocalDefId;\n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::{self, Const, ToPredicate, Ty, TyCtxt};\n@@ -146,7 +147,7 @@ impl<'tcx, O> Obligation<'tcx, O> {\n     pub fn misc(\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         trait_ref: impl ToPredicate<'tcx, O>,\n     ) -> Obligation<'tcx, O> {"}, {"sha": "60b60edd2c8119a9a2cfb1d2377356a8e3fa0275", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::parallel;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n-use rustc_hir::def_id::StableCrateId;\n+use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n@@ -30,7 +30,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn, Untracked};\n+use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn, Untracked};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -47,7 +47,7 @@ use std::marker::PhantomPinned;\n use std::path::{Path, PathBuf};\n use std::pin::Pin;\n use std::rc::Rc;\n-use std::sync::LazyLock;\n+use std::sync::{Arc, LazyLock};\n use std::{env, fs, iter};\n \n pub fn parse<'a>(sess: &'a Session) -> PResult<'a, ast::Crate> {\n@@ -548,7 +548,7 @@ fn escape_dep_env(symbol: Symbol) -> String {\n \n fn write_out_deps(\n     sess: &Session,\n-    boxed_resolver: &RefCell<BoxedResolver>,\n+    cstore: &CrateStoreDyn,\n     outputs: &OutputFilenames,\n     out_filenames: &[PathBuf],\n ) {\n@@ -600,20 +600,19 @@ fn write_out_deps(\n                 }\n             }\n \n-            boxed_resolver.borrow_mut().access(|resolver| {\n-                for cnum in resolver.cstore().crates_untracked() {\n-                    let source = resolver.cstore().crate_source_untracked(cnum);\n-                    if let Some((path, _)) = &source.dylib {\n-                        files.push(escape_dep_filename(&path.display().to_string()));\n-                    }\n-                    if let Some((path, _)) = &source.rlib {\n-                        files.push(escape_dep_filename(&path.display().to_string()));\n-                    }\n-                    if let Some((path, _)) = &source.rmeta {\n-                        files.push(escape_dep_filename(&path.display().to_string()));\n-                    }\n+            let cstore = cstore.as_any().downcast_ref::<CStore>().unwrap();\n+            for cnum in cstore.crates_untracked() {\n+                let source = cstore.crate_source_untracked(cnum);\n+                if let Some((path, _)) = &source.dylib {\n+                    files.push(escape_dep_filename(&path.display().to_string()));\n                 }\n-            });\n+                if let Some((path, _)) = &source.rlib {\n+                    files.push(escape_dep_filename(&path.display().to_string()));\n+                }\n+                if let Some((path, _)) = &source.rmeta {\n+                    files.push(escape_dep_filename(&path.display().to_string()));\n+                }\n+            }\n         }\n \n         let mut file = BufWriter::new(fs::File::create(&deps_filename)?);\n@@ -661,13 +660,11 @@ fn write_out_deps(\n     }\n }\n \n-pub fn prepare_outputs(\n-    sess: &Session,\n-    krate: &ast::Crate,\n-    boxed_resolver: &RefCell<BoxedResolver>,\n-    crate_name: Symbol,\n-) -> Result<OutputFilenames> {\n+fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n+    let sess = tcx.sess;\n     let _timer = sess.timer(\"prepare_outputs\");\n+    let (_, krate) = &*tcx.resolver_for_lowering(()).borrow();\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n \n     // FIXME: rustdoc passes &[] instead of &krate.attrs here\n     let outputs = util::build_output_filenames(&krate.attrs, sess);\n@@ -679,45 +676,41 @@ pub fn prepare_outputs(\n     if let Some(ref input_path) = sess.io.input.opt_path() {\n         if sess.opts.will_create_output_file() {\n             if output_contains_path(&output_paths, input_path) {\n-                let reported = sess.emit_err(InputFileWouldBeOverWritten { path: input_path });\n-                return Err(reported);\n+                sess.emit_fatal(InputFileWouldBeOverWritten { path: input_path });\n             }\n             if let Some(ref dir_path) = output_conflicts_with_dir(&output_paths) {\n-                let reported =\n-                    sess.emit_err(GeneratedFileConflictsWithDirectory { input_path, dir_path });\n-                return Err(reported);\n+                sess.emit_fatal(GeneratedFileConflictsWithDirectory { input_path, dir_path });\n             }\n         }\n     }\n \n     if let Some(ref dir) = sess.io.temps_dir {\n         if fs::create_dir_all(dir).is_err() {\n-            let reported = sess.emit_err(TempsDirError);\n-            return Err(reported);\n+            sess.emit_fatal(TempsDirError);\n         }\n     }\n \n-    write_out_deps(sess, boxed_resolver, &outputs, &output_paths);\n+    write_out_deps(sess, tcx.cstore_untracked(), &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n \n     if !only_dep_info {\n         if let Some(ref dir) = sess.io.output_dir {\n             if fs::create_dir_all(dir).is_err() {\n-                let reported = sess.emit_err(OutDirError);\n-                return Err(reported);\n+                sess.emit_fatal(OutDirError);\n             }\n         }\n     }\n \n-    Ok(outputs)\n+    outputs.into()\n }\n \n pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     let providers = &mut Providers::default();\n     providers.analysis = analysis;\n     providers.hir_crate = rustc_ast_lowering::lower_to_hir;\n+    providers.output_filenames = output_filenames;\n     proc_macro_decls::provide(providers);\n     rustc_const_eval::provide(providers);\n     rustc_middle::hir::provide(providers);\n@@ -900,6 +893,15 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n         }\n     });\n \n+    if tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+        tcx.hir().par_body_owners(|def_id| {\n+            if let rustc_hir::def::DefKind::Generator = tcx.def_kind(def_id) {\n+                tcx.ensure().mir_generator_witnesses(def_id);\n+                tcx.ensure().check_generator_obligations(def_id);\n+            }\n+        });\n+    }\n+\n     sess.time(\"layout_testing\", || layout_test::test_layout(tcx));\n \n     // Avoid overwhelming user with errors if borrow checking failed."}, {"sha": "4b0180741c19df0af11d84b6c6d388bc5b1ffc42", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -65,7 +65,7 @@ impl<'a, T> std::ops::DerefMut for QueryResult<'a, T> {\n }\n \n impl<'a, 'tcx> QueryResult<'a, QueryContext<'tcx>> {\n-    pub fn enter<T>(mut self, f: impl FnOnce(TyCtxt<'tcx>) -> T) -> T {\n+    pub fn enter<T>(&mut self, f: impl FnOnce(TyCtxt<'tcx>) -> T) -> T {\n         (*self.0).get_mut().enter(f)\n     }\n }\n@@ -212,8 +212,6 @@ impl<'tcx> Queries<'tcx> {\n             let crate_name = *self.crate_name()?.borrow();\n             let (krate, resolver, lint_store) = self.expansion()?.steal();\n \n-            let outputs = passes::prepare_outputs(self.session(), &krate, &resolver, crate_name)?;\n-\n             let ty::ResolverOutputs {\n                 untracked,\n                 global_ctxt: untracked_resolutions,\n@@ -237,7 +235,6 @@ impl<'tcx> Queries<'tcx> {\n                     tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, krate))),\n                 );\n                 feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n-                feed.output_filenames(tcx.arena.alloc(std::sync::Arc::new(outputs)));\n                 feed.features_query(tcx.sess.features_untracked());\n                 let feed = tcx.feed_local_crate();\n                 feed.crate_name(crate_name);"}, {"sha": "52a4e0e74181f78092fb85230051352b995a23ac", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -802,6 +802,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(teach, true);\n     tracked!(thinlto, Some(true));\n     tracked!(thir_unsafeck, true);\n+    tracked!(tiny_const_eval_limit, true);\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n     tracked!(trait_solver, TraitSolver::Chalk);\n     tracked!(translate_remapped_path_to_local_path, false);"}, {"sha": "8361c81f0efe35f63d22fe9bc08ce52217e0d2b1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 54, "deletions": 32, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -56,9 +56,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::intravisit::FnKind as HirFnKind;\n-use rustc_hir::{\n-    Body, FnDecl, ForeignItemKind, GenericParamKind, HirId, Node, PatKind, PredicateOrigin,\n-};\n+use rustc_hir::{Body, FnDecl, ForeignItemKind, GenericParamKind, Node, PatKind, PredicateOrigin};\n use rustc_index::vec::Idx;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n@@ -583,12 +581,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n-        if method_context(cx, impl_item.hir_id()) == MethodLateContext::TraitImpl {\n+        let context = method_context(cx, impl_item.owner_id.def_id);\n+        if context == MethodLateContext::TraitImpl {\n             return;\n         }\n \n         // If the method is an impl for an item with docs_hidden, don't doc.\n-        if method_context(cx, impl_item.hir_id()) == MethodLateContext::PlainImpl {\n+        if context == MethodLateContext::PlainImpl {\n             let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n             let impl_ty = cx.tcx.type_of(parent);\n             let outerdef = match impl_ty.kind() {\n@@ -732,7 +731,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             cx.tcx,\n             param_env,\n             ty,\n-            traits::ObligationCause::misc(item.span, item.hir_id()),\n+            traits::ObligationCause::misc(item.span, item.owner_id.def_id),\n         )\n         .is_ok()\n         {\n@@ -1296,19 +1295,18 @@ impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n         _: &'tcx FnDecl<'_>,\n         _: &'tcx Body<'_>,\n         span: Span,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n     ) {\n         if fn_kind.asyncness() == IsAsync::Async\n             && !cx.tcx.features().closure_track_caller\n-            && let attrs = cx.tcx.hir().attrs(hir_id)\n             // Now, check if the function has the `#[track_caller]` attribute\n-            && let Some(attr) = attrs.iter().find(|attr| attr.has_name(sym::track_caller))\n-            {\n-                cx.emit_spanned_lint(UNGATED_ASYNC_FN_TRACK_CALLER, attr.span, BuiltinUngatedAsyncFnTrackCaller {\n-                    label: span,\n-                    parse_sess: &cx.tcx.sess.parse_sess,\n-                });\n-            }\n+            && let Some(attr) = cx.tcx.get_attr(def_id.to_def_id(), sym::track_caller)\n+        {\n+            cx.emit_spanned_lint(UNGATED_ASYNC_FN_TRACK_CALLER, attr.span, BuiltinUngatedAsyncFnTrackCaller {\n+                label: span,\n+                parse_sess: &cx.tcx.sess.parse_sess,\n+            });\n+        }\n     }\n }\n \n@@ -2175,13 +2173,31 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     dropped_predicate_count += 1;\n                 }\n \n-                if drop_predicate && !in_where_clause {\n-                    lint_spans.push(predicate_span);\n-                } else if drop_predicate && i + 1 < num_predicates {\n-                    // If all the bounds on a predicate were inferable and there are\n-                    // further predicates, we want to eat the trailing comma.\n-                    let next_predicate_span = hir_generics.predicates[i + 1].span();\n-                    where_lint_spans.push(predicate_span.to(next_predicate_span.shrink_to_lo()));\n+                if drop_predicate {\n+                    if !in_where_clause {\n+                        lint_spans.push(predicate_span);\n+                    } else if predicate_span.from_expansion() {\n+                        // Don't try to extend the span if it comes from a macro expansion.\n+                        where_lint_spans.push(predicate_span);\n+                    } else if i + 1 < num_predicates {\n+                        // If all the bounds on a predicate were inferable and there are\n+                        // further predicates, we want to eat the trailing comma.\n+                        let next_predicate_span = hir_generics.predicates[i + 1].span();\n+                        if next_predicate_span.from_expansion() {\n+                            where_lint_spans.push(predicate_span);\n+                        } else {\n+                            where_lint_spans\n+                                .push(predicate_span.to(next_predicate_span.shrink_to_lo()));\n+                        }\n+                    } else {\n+                        // Eat the optional trailing comma after the last predicate.\n+                        let where_span = hir_generics.where_clause_span;\n+                        if where_span.from_expansion() {\n+                            where_lint_spans.push(predicate_span);\n+                        } else {\n+                            where_lint_spans.push(predicate_span.to(where_span.shrink_to_hi()));\n+                        }\n+                    }\n                 } else {\n                     where_lint_spans.extend(self.consolidate_outlives_bound_spans(\n                         predicate_span.shrink_to_lo(),\n@@ -2225,6 +2241,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     Applicability::MaybeIncorrect\n                 };\n \n+                // Due to macros, there might be several predicates with the same span\n+                // and we only want to suggest removing them once.\n+                lint_spans.sort_unstable();\n+                lint_spans.dedup();\n+\n                 cx.emit_spanned_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n@@ -2661,7 +2682,7 @@ pub struct ClashingExternDeclarations {\n     /// the symbol should be reported as a clashing declaration.\n     // FIXME: Technically, we could just store a &'tcx str here without issue; however, the\n     // `impl_lint_pass` macro doesn't currently support lints parametric over a lifetime.\n-    seen_decls: FxHashMap<Symbol, HirId>,\n+    seen_decls: FxHashMap<Symbol, hir::OwnerId>,\n }\n \n /// Differentiate between whether the name for an extern decl came from the link_name attribute or\n@@ -2687,19 +2708,20 @@ impl ClashingExternDeclarations {\n     pub(crate) fn new() -> Self {\n         ClashingExternDeclarations { seen_decls: FxHashMap::default() }\n     }\n+\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n     /// for the item, return its HirId without updating the set.\n-    fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n+    fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<hir::OwnerId> {\n         let did = fi.owner_id.to_def_id();\n         let instance = Instance::new(did, ty::List::identity_for_item(tcx, did));\n         let name = Symbol::intern(tcx.symbol_name(instance).name);\n-        if let Some(&hir_id) = self.seen_decls.get(&name) {\n+        if let Some(&existing_id) = self.seen_decls.get(&name) {\n             // Avoid updating the map with the new entry when we do find a collision. We want to\n             // make sure we're always pointing to the first definition as the previous declaration.\n             // This lets us avoid emitting \"knock-on\" diagnostics.\n-            Some(hir_id)\n+            Some(existing_id)\n         } else {\n-            self.seen_decls.insert(name, fi.hir_id())\n+            self.seen_decls.insert(name, fi.owner_id)\n         }\n     }\n \n@@ -2926,16 +2948,16 @@ impl ClashingExternDeclarations {\n impl_lint_pass!(ClashingExternDeclarations => [CLASHING_EXTERN_DECLARATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n+    #[instrument(level = \"trace\", skip(self, cx))]\n     fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, this_fi: &hir::ForeignItem<'_>) {\n-        trace!(\"ClashingExternDeclarations: check_foreign_item: {:?}\", this_fi);\n         if let ForeignItemKind::Fn(..) = this_fi.kind {\n             let tcx = cx.tcx;\n-            if let Some(existing_hid) = self.insert(tcx, this_fi) {\n-                let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n+            if let Some(existing_did) = self.insert(tcx, this_fi) {\n+                let existing_decl_ty = tcx.type_of(existing_did);\n                 let this_decl_ty = tcx.type_of(this_fi.owner_id);\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n-                    existing_hid, existing_decl_ty, this_fi.owner_id, this_decl_ty\n+                    existing_did, existing_decl_ty, this_fi.owner_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n                 if !Self::structurally_same_type(\n@@ -2944,7 +2966,7 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     this_decl_ty,\n                     CItemKind::Declaration,\n                 ) {\n-                    let orig_fi = tcx.hir().expect_foreign_item(existing_hid.expect_owner());\n+                    let orig_fi = tcx.hir().expect_foreign_item(existing_did);\n                     let orig = Self::name_of_extern_decl(tcx, orig_fi);\n \n                     // We want to ensure that we use spans for both decls that include where the"}, {"sha": "d1d4bb375282f004673fb63bf2141c002f7b9956", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -882,6 +882,9 @@ pub trait LintContext: Sized {\n                         );\n                     }\n                 }\n+                BuiltinLintDiagnostics::ByteSliceInPackedStructWithDerive => {\n+                    db.help(\"consider implementing the trait by hand, or remove the `packed` attribute\");\n+                }\n             }\n             // Rewrap `db`, and pass control to the user.\n             decorate(db)"}, {"sha": "1add352e0c42d853f719a2db62c234b5497864ef", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -139,9 +139,10 @@ fn suggest_question_mark<'tcx>(\n \n     let ty = substs.type_at(0);\n     let infcx = cx.tcx.infer_ctxt().build();\n+    let body_def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let cause = ObligationCause::new(\n         span,\n-        body_id.hir_id,\n+        body_def_id,\n         rustc_infer::traits::ObligationCauseCode::MiscObligation,\n     );\n     let errors = rustc_trait_selection::traits::fully_solve_bound("}, {"sha": "b42878a02ee02985408d41e21ac7efd4aaf7392a", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -66,13 +66,12 @@ impl<'tcx, T: LateLintPass<'tcx>> LateContextAndPass<'tcx, T> {\n         self.context.last_node_with_lint_attrs = prev;\n     }\n \n-    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n+    fn with_param_env<F>(&mut self, id: hir::OwnerId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n         let old_param_env = self.context.param_env;\n-        self.context.param_env =\n-            self.context.tcx.param_env(self.context.tcx.hir().local_def_id(id));\n+        self.context.param_env = self.context.tcx.param_env(id);\n         f(self);\n         self.context.param_env = old_param_env;\n     }\n@@ -132,7 +131,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         let old_cached_typeck_results = self.context.cached_typeck_results.take();\n         let old_enclosing_body = self.context.enclosing_body.take();\n         self.with_lint_attrs(it.hir_id(), |cx| {\n-            cx.with_param_env(it.hir_id(), |cx| {\n+            cx.with_param_env(it.owner_id, |cx| {\n                 lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n                 lint_callback!(cx, check_item_post, it);\n@@ -145,7 +144,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n         self.with_lint_attrs(it.hir_id(), |cx| {\n-            cx.with_param_env(it.hir_id(), |cx| {\n+            cx.with_param_env(it.owner_id, |cx| {\n                 lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n             });\n@@ -180,7 +179,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         decl: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         span: Span,\n-        id: hir::HirId,\n+        id: LocalDefId,\n     ) {\n         // Wrap in typeck results here, not just in visit_nested_body,\n         // in order for `check_fn` to be able to use them.\n@@ -268,7 +267,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id(), |cx| {\n-            cx.with_param_env(trait_item.hir_id(), |cx| {\n+            cx.with_param_env(trait_item.owner_id, |cx| {\n                 lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n             });\n@@ -280,7 +279,7 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n         let generics = self.context.generics.take();\n         self.context.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id(), |cx| {\n-            cx.with_param_env(impl_item.hir_id(), |cx| {\n+            cx.with_param_env(impl_item.owner_id, |cx| {\n                 lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n                 lint_callback!(cx, check_impl_item_post, impl_item);"}, {"sha": "ba15dbd86cfa4caff089c597a84391a69ff7a400", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -64,6 +64,7 @@ mod let_underscore;\n mod levels;\n mod lints;\n mod methods;\n+mod multiple_supertrait_upcastable;\n mod non_ascii_idents;\n mod non_fmt_panic;\n mod nonstandard_style;\n@@ -98,6 +99,7 @@ use hidden_unicode_codepoints::*;\n use internal::*;\n use let_underscore::*;\n use methods::*;\n+use multiple_supertrait_upcastable::*;\n use non_ascii_idents::*;\n use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n@@ -232,6 +234,7 @@ late_lint_methods!(\n             InvalidAtomicOrdering: InvalidAtomicOrdering,\n             NamedAsmLabels: NamedAsmLabels,\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n+            MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n         ]\n     ]\n );"}, {"sha": "0c1019545f382f8a5ce425a871a5aa1cc225f149", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -917,6 +917,13 @@ pub struct CStringPtr {\n     pub unwrap: Span,\n }\n \n+// multiple_supertrait_upcastable.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_multple_supertrait_upcastable)]\n+pub struct MultipleSupertraitUpcastable {\n+    pub ident: Ident,\n+}\n+\n // non_ascii_idents.rs\n #[derive(LintDiagnostic)]\n #[diag(lint_identifier_non_ascii_char)]"}, {"sha": "c2ed0e19f4011e5aa70221716ac318107c57f237", "filename": "compiler/rustc_lint/src/multiple_supertrait_upcastable.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmultiple_supertrait_upcastable.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,60 @@\n+use crate::{LateContext, LateLintPass, LintContext};\n+\n+use rustc_hir as hir;\n+use rustc_span::sym;\n+\n+declare_lint! {\n+    /// The `multiple_supertrait_upcastable` lint detects when an object-safe trait has multiple\n+    /// supertraits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// trait A {}\n+    /// trait B {}\n+    ///\n+    /// #[warn(multiple_supertrait_upcastable)]\n+    /// trait C: A + B {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// To support upcasting with multiple supertraits, we need to store multiple vtables and this\n+    /// can result in extra space overhead, even if no code actually uses upcasting.\n+    /// This lint allows users to identify when such scenarios occur and to decide whether the\n+    /// additional overhead is justified.\n+    pub MULTIPLE_SUPERTRAIT_UPCASTABLE,\n+    Allow,\n+    \"detect when an object-safe trait has multiple supertraits\",\n+    @feature_gate = sym::multiple_supertrait_upcastable;\n+}\n+\n+declare_lint_pass!(MultipleSupertraitUpcastable => [MULTIPLE_SUPERTRAIT_UPCASTABLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MultipleSupertraitUpcastable {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n+        let def_id = item.owner_id.to_def_id();\n+        // NOTE(nbdd0121): use `object_safety_violations` instead of `check_is_object_safe` because\n+        // the latter will report `where_clause_object_safety` lint.\n+        if let hir::ItemKind::Trait(_, _, _, _, _) = item.kind\n+            && cx.tcx.object_safety_violations(def_id).is_empty()\n+        {\n+            let direct_super_traits_iter = cx.tcx\n+                    .super_predicates_of(def_id)\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(|(pred, _)| pred.to_opt_poly_trait_pred());\n+            if direct_super_traits_iter.count() > 1 {\n+                cx.emit_spanned_lint(\n+                    MULTIPLE_SUPERTRAIT_UPCASTABLE,\n+                    cx.tcx.def_span(def_id),\n+                    crate::lints::MultipleSupertraitUpcastable {\n+                        ident: item.ident\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "71e2e66bdebc2786b0459478b5bfa7b54954a222", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -10,8 +10,9 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{GenericParamKind, PatKind};\n use rustc_middle::ty;\n-use rustc_span::symbol::sym;\n-use rustc_span::{symbol::Ident, BytePos, Span};\n+use rustc_span::def_id::LocalDefId;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{BytePos, Span};\n use rustc_target::spec::abi::Abi;\n \n #[derive(PartialEq)]\n@@ -21,9 +22,8 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext<'_>, id: hir::HirId) -> MethodLateContext {\n-    let def_id = cx.tcx.hir().local_def_id(id);\n-    let item = cx.tcx.associated_item(def_id);\n+pub fn method_context(cx: &LateContext<'_>, id: LocalDefId) -> MethodLateContext {\n+    let item = cx.tcx.associated_item(id);\n     match item.container {\n         ty::TraitContainer => MethodLateContext::TraitAutoImpl,\n         ty::ImplContainer => match cx.tcx.impl_trait_ref(item.container_id(cx.tcx)) {\n@@ -379,13 +379,13 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         _: &hir::FnDecl<'_>,\n         _: &hir::Body<'_>,\n         _: Span,\n-        id: hir::HirId,\n+        id: LocalDefId,\n     ) {\n-        let attrs = cx.tcx.hir().attrs(id);\n         match &fk {\n             FnKind::Method(ident, sig, ..) => match method_context(cx, id) {\n                 MethodLateContext::PlainImpl => {\n-                    if sig.header.abi != Abi::Rust && cx.sess().contains_name(attrs, sym::no_mangle)\n+                    if sig.header.abi != Abi::Rust\n+                        && cx.tcx.has_attr(id.to_def_id(), sym::no_mangle)\n                     {\n                         return;\n                     }\n@@ -398,7 +398,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n             },\n             FnKind::ItemFn(ident, _, header) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && cx.sess().contains_name(attrs, sym::no_mangle) {\n+                if header.abi != Abi::Rust && cx.tcx.has_attr(id.to_def_id(), sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);"}, {"sha": "16964565b010328935a346de5052081512758374", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -4,6 +4,7 @@ use rustc_ast as ast;\n use rustc_hir as hir;\n use rustc_session::lint::builtin::HardwiredLints;\n use rustc_session::lint::LintPass;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -36,7 +37,7 @@ macro_rules! late_lint_methods {\n                 b: &'tcx hir::FnDecl<'tcx>,\n                 c: &'tcx hir::Body<'tcx>,\n                 d: Span,\n-                e: hir::HirId);\n+                e: LocalDefId);\n             fn check_trait_item(a: &'tcx hir::TraitItem<'tcx>);\n             fn check_impl_item(a: &'tcx hir::ImplItem<'tcx>);\n             fn check_impl_item_post(a: &'tcx hir::ImplItem<'tcx>);"}, {"sha": "b0a5d3674ad2795d75fdcefe041c68c2db19f7de", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -14,6 +14,7 @@ use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n@@ -1107,6 +1108,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Placeholder(..)\n             | ty::FnDef(..) => bug!(\"unexpected type in foreign function: {:?}\", ty),\n         }\n@@ -1223,9 +1225,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_fn(&mut self, id: hir::HirId, decl: &hir::FnDecl<'_>) {\n-        let def_id = self.cx.tcx.hir().local_def_id(id);\n-        let sig = self.cx.tcx.fn_sig(def_id);\n+    fn check_foreign_fn(&mut self, def_id: LocalDefId, decl: &hir::FnDecl<'_>) {\n+        let sig = self.cx.tcx.fn_sig(def_id).subst_identity();\n         let sig = self.cx.tcx.erase_late_bound_regions(sig);\n \n         for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {\n@@ -1238,9 +1239,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_foreign_static(&mut self, id: hir::HirId, span: Span) {\n-        let def_id = self.cx.tcx.hir().local_def_id(id);\n-        let ty = self.cx.tcx.type_of(def_id);\n+    fn check_foreign_static(&mut self, id: hir::OwnerId, span: Span) {\n+        let ty = self.cx.tcx.type_of(id);\n         self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n \n@@ -1260,10 +1260,10 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n         if !vis.is_internal_abi(abi) {\n             match it.kind {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {\n-                    vis.check_foreign_fn(it.hir_id(), decl);\n+                    vis.check_foreign_fn(it.owner_id.def_id, decl);\n                 }\n                 hir::ForeignItemKind::Static(ref ty, _) => {\n-                    vis.check_foreign_static(it.hir_id(), ty.span);\n+                    vis.check_foreign_static(it.owner_id, ty.span);\n                 }\n                 hir::ForeignItemKind::Type => (),\n             }\n@@ -1279,7 +1279,7 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {\n         decl: &'tcx hir::FnDecl<'_>,\n         _: &'tcx hir::Body<'_>,\n         _: Span,\n-        hir_id: hir::HirId,\n+        id: LocalDefId,\n     ) {\n         use hir::intravisit::FnKind;\n \n@@ -1291,7 +1291,7 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {\n \n         let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Definition };\n         if !vis.is_internal_abi(abi) {\n-            vis.check_foreign_fn(hir_id, decl);\n+            vis.check_foreign_fn(id, decl);\n         }\n     }\n }"}, {"sha": "d731c10f46e28efec1f5659cfecfc75b43b339a5", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3381,6 +3381,7 @@ declare_lint_pass! {\n         REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n         NAMED_ARGUMENTS_USED_POSITIONALLY,\n         IMPLIED_BOUNDS_ENTAILMENT,\n+        BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n     ]\n }\n \n@@ -3531,9 +3532,15 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// Previously, there were very like checks being performed on `#[doc(..)]`\n-    /// unlike the other attributes. It'll now catch all the issues that it\n-    /// silently ignored previously.\n+    /// Previously, incorrect usage of the `#[doc(..)]` attribute was not\n+    /// being validated. Usually these should be rejected as a hard error,\n+    /// but this lint was introduced to avoid breaking any existing\n+    /// crates which included them.\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard\n+    /// error in the future. See [issue #82730] for more details.\n+    ///\n+    /// [issue #82730]: https://github.com/rust-lang/rust/issues/82730\n     pub INVALID_DOC_ATTRIBUTES,\n     Warn,\n     \"detects invalid `#[doc(...)]` attributes\",\n@@ -4109,3 +4116,35 @@ declare_lint! {\n         reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n+\n+declare_lint! {\n+    /// The `byte_slice_in_packed_struct_with_derive` lint detects cases where a byte slice field\n+    /// (`[u8]`) is used in a `packed` struct that derives one or more built-in traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[repr(packed)]\n+    /// #[derive(Hash)]\n+    /// struct FlexZeroSlice {\n+    ///     width: u8,\n+    ///     data: [u8],\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This was previously accepted but is being phased out, because fields in packed structs are\n+    /// now required to implement `Copy` for `derive` to work. Byte slices are a temporary\n+    /// exception because certain crates depended on them.\n+    pub BYTE_SLICE_IN_PACKED_STRUCT_WITH_DERIVE,\n+    Warn,\n+    \"`[u8]` slice used in a packed struct with `derive`\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #107457 <https://github.com/rust-lang/rust/issues/107457>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n+    };\n+    report_in_external_macro\n+}"}, {"sha": "6efbf5ce9eef308fa1100512b6f76ea6fc583bdf", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -521,6 +521,7 @@ pub enum BuiltinLintDiagnostics {\n         /// Indicates if the named argument is used as a width/precision for formatting\n         is_formatting_arg: bool,\n     },\n+    ByteSliceInPackedStructWithDerive,\n }\n \n /// Lints that are buffered up early on in the `Session` before the"}, {"sha": "08098c9bb2a85c5a2c37b7a557e7b91fc5f4a2bc", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -4,7 +4,10 @@ use annotate_snippets::{\n };\n use fluent_bundle::{FluentBundle, FluentError, FluentResource};\n use fluent_syntax::{\n-    ast::{Attribute, Entry, Identifier, Message},\n+    ast::{\n+        Attribute, Entry, Expression, Identifier, InlineExpression, Message, Pattern,\n+        PatternElement,\n+    },\n     parser::ParserError,\n };\n use proc_macro::{Diagnostic, Level, Span};\n@@ -185,9 +188,12 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n         };\n \n         let mut constants = TokenStream::new();\n+        let mut messagerefs = Vec::new();\n         for entry in resource.entries() {\n             let span = res.krate.span();\n-            if let Entry::Message(Message { id: Identifier { name }, attributes, .. }) = entry {\n+            if let Entry::Message(Message { id: Identifier { name }, attributes, value, .. }) =\n+                entry\n+            {\n                 let _ = previous_defns.entry(name.to_string()).or_insert(path_span);\n \n                 if name.contains('-') {\n@@ -200,6 +206,18 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                     .emit();\n                 }\n \n+                if let Some(Pattern { elements }) = value {\n+                    for elt in elements {\n+                        if let PatternElement::Placeable {\n+                            expression:\n+                                Expression::Inline(InlineExpression::MessageReference { id, .. }),\n+                        } = elt\n+                        {\n+                            messagerefs.push((id.name, *name));\n+                        }\n+                    }\n+                }\n+\n                 // Require that the message name starts with the crate name\n                 // `hir_typeck_foo_bar` (in `hir_typeck.ftl`)\n                 // `const_eval_baz` (in `const_eval.ftl`)\n@@ -258,6 +276,18 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             }\n         }\n \n+        for (mref, name) in messagerefs.into_iter() {\n+            if !previous_defns.contains_key(mref) {\n+                Diagnostic::spanned(\n+                    path_span,\n+                    Level::Error,\n+                    format!(\"referenced message `{mref}` does not exist (in message `{name}`)\"),\n+                )\n+                .help(&format!(\"you may have meant to use a variable reference (`{{${mref}}}`)\"))\n+                .emit();\n+            }\n+        }\n+\n         if let Err(errs) = bundle.add_resource(resource) {\n             for e in errs {\n                 match e {"}, {"sha": "bb2dd290c6d5d1edef0ef7f26ae3f0bbb1793d69", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -985,7 +985,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let vis = self.get_visibility(id);\n         let span = self.get_span(id, sess);\n         let macro_rules = match kind {\n-            DefKind::Macro(..) => self.root.tables.macro_rules.get(self, id).is_some(),\n+            DefKind::Macro(..) => self.root.tables.is_macro_rules.get(self, id),\n             _ => false,\n         };\n \n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {\n         match self.def_kind(id) {\n             DefKind::Macro(_) => {\n-                let macro_rules = self.root.tables.macro_rules.get(self, id).is_some();\n+                let macro_rules = self.root.tables.is_macro_rules.get(self, id);\n                 let body =\n                     self.root.tables.macro_definition.get(self, id).unwrap().decode((self, sess));\n                 ast::MacroDef { macro_rules, body: ast::ptr::P(body) }\n@@ -1595,11 +1595,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_attr_flags(self, index: DefIndex) -> AttrFlags {\n-        self.root.tables.attr_flags.get(self, index).unwrap_or(AttrFlags::empty())\n+        self.root.tables.attr_flags.get(self, index)\n     }\n \n     fn get_is_intrinsic(self, index: DefIndex) -> bool {\n-        self.root.tables.is_intrinsic.get(self, index).is_some()\n+        self.root.tables.is_intrinsic.get(self, index)\n     }\n }\n "}, {"sha": "9b1401f4a44dfdf922120faf9bd9f165c902d3c9", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -202,6 +202,7 @@ provide! { tcx, def_id, other, cdata,\n     thir_abstract_const => { table }\n     optimized_mir => { table }\n     mir_for_ctfe => { table }\n+    mir_generator_witnesses => { table }\n     promoted_mir => { table }\n     def_span => { table }\n     def_ident_span => { table }\n@@ -226,12 +227,7 @@ provide! { tcx, def_id, other, cdata,\n     deduced_param_attrs => { table }\n     is_type_alias_impl_trait => {\n         debug_assert_eq!(tcx.def_kind(def_id), DefKind::OpaqueTy);\n-        cdata\n-            .root\n-            .tables\n-            .is_type_alias_impl_trait\n-            .get(cdata, def_id.index)\n-            .is_some()\n+        cdata.root.tables.is_type_alias_impl_trait.get(cdata, def_id.index)\n     }\n     collect_return_position_impl_trait_in_trait_tys => {\n         Ok(cdata\n@@ -637,6 +633,12 @@ impl CStore {\n             .get_attr_flags(def_id.index)\n             .contains(AttrFlags::MAY_HAVE_DOC_LINKS)\n     }\n+\n+    pub fn is_doc_hidden_untracked(&self, def_id: DefId) -> bool {\n+        self.get_crate_data(def_id.krate)\n+            .get_attr_flags(def_id.index)\n+            .contains(AttrFlags::IS_DOC_HIDDEN)\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "29507ff3a86c1dc2f27e66027f67e46ceea53331", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 108, "deletions": 153, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,6 +3,7 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n+use rustc_ast::util::comments;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n@@ -38,7 +39,6 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n-use rustc_target::abi::VariantIdx;\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -483,7 +483,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n-    fn encode_source_map(&mut self) -> LazyTable<u32, LazyValue<rustc_span::SourceFile>> {\n+    fn encode_source_map(&mut self) -> LazyTable<u32, Option<LazyValue<rustc_span::SourceFile>>> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -760,36 +760,54 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n+struct AnalyzeAttrState {\n+    is_exported: bool,\n+    may_have_doc_links: bool,\n+    is_doc_hidden: bool,\n+}\n+\n /// Returns whether an attribute needs to be recorded in metadata, that is, if it's usable and\n /// useful in downstream crates. Local-only attributes are an obvious example, but some\n /// rustdoc-specific attributes can equally be of use while documenting the current crate only.\n ///\n /// Removing these superfluous attributes speeds up compilation by making the metadata smaller.\n ///\n-/// Note: the `is_def_id_public` parameter is used to cache whether the given `DefId` has a public\n+/// Note: the `is_exported` parameter is used to cache whether the given `DefId` has a public\n /// visibility: this is a piece of data that can be computed once per defid, and not once per\n /// attribute. Some attributes would only be usable downstream if they are public.\n #[inline]\n-fn should_encode_attr(\n-    tcx: TyCtxt<'_>,\n-    attr: &Attribute,\n-    def_id: LocalDefId,\n-    is_def_id_public: &mut Option<bool>,\n-) -> bool {\n+fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n+    let mut should_encode = false;\n     if rustc_feature::is_builtin_only_local(attr.name_or_empty()) {\n         // Attributes marked local-only don't need to be encoded for downstream crates.\n-        false\n-    } else if attr.doc_str().is_some() {\n-        // We keep all public doc comments because they might be \"imported\" into downstream crates\n-        // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public.get_or_insert_with(|| tcx.effective_visibilities(()).is_exported(def_id))\n+    } else if let Some(s) = attr.doc_str() {\n+        // We keep all doc comments reachable to rustdoc because they might be \"imported\" into\n+        // downstream crates if they use `#[doc(inline)]` to copy an item's documentation into\n+        // their own.\n+        if state.is_exported {\n+            should_encode = true;\n+            if comments::may_have_doc_links(s.as_str()) {\n+                state.may_have_doc_links = true;\n+            }\n+        }\n     } else if attr.has_name(sym::doc) {\n-        // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n-        // remove it. It won't be inlinable in downstream crates.\n-        attr.meta_item_list().map(|l| l.iter().any(|l| !l.has_name(sym::inline))).unwrap_or(false)\n+        // If this is a `doc` attribute that doesn't have anything except maybe `inline` (as in\n+        // `#[doc(inline)]`), then we can remove it. It won't be inlinable in downstream crates.\n+        if let Some(item_list) = attr.meta_item_list() {\n+            for item in item_list {\n+                if !item.has_name(sym::inline) {\n+                    should_encode = true;\n+                    if item.has_name(sym::hidden) {\n+                        state.is_doc_hidden = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n     } else {\n-        true\n+        should_encode = true;\n     }\n+    should_encode\n }\n \n fn should_encode_visibility(def_kind: DefKind) -> bool {\n@@ -1094,7 +1112,7 @@ fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // of the trait fn to look for any RPITITs, but that's kinda doing a lot\n     // of work. We can probably remove this when we refactor RPITITs to be\n     // associated types.\n-    tcx.fn_sig(trait_item_def_id).skip_binder().output().walk().any(|arg| {\n+    tcx.fn_sig(trait_item_def_id).subst_identity().skip_binder().output().walk().any(|arg| {\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n             && let ty::Alias(ty::Projection, data) = ty.kind()\n             && tcx.def_kind(data.def_id) == DefKind::ImplTraitPlaceholder\n@@ -1109,28 +1127,28 @@ fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        let mut is_public: Option<bool> = None;\n-\n-        let hir_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n-        let mut attrs = hir_attrs\n+        let mut state = AnalyzeAttrState {\n+            is_exported: tcx.effective_visibilities(()).is_exported(def_id),\n+            may_have_doc_links: false,\n+            is_doc_hidden: false,\n+        };\n+        let attr_iter = tcx\n+            .hir()\n+            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n             .iter()\n-            .filter(move |attr| should_encode_attr(tcx, attr, def_id, &mut is_public));\n+            .filter(|attr| analyze_attr(attr, &mut state));\n+\n+        record_array!(self.tables.attributes[def_id.to_def_id()] <- attr_iter);\n \n-        record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         let mut attr_flags = AttrFlags::empty();\n-        if attrs.any(|attr| attr.may_have_doc_links()) {\n+        if state.may_have_doc_links {\n             attr_flags |= AttrFlags::MAY_HAVE_DOC_LINKS;\n         }\n-        if hir_attrs\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::doc))\n-            .filter_map(|attr| attr.meta_item_list())\n-            .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n-        {\n+        if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n         if !attr_flags.is_empty() {\n-            self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n+            self.tables.attr_flags.set_nullable(def_id.local_def_index, attr_flags);\n         }\n     }\n \n@@ -1189,8 +1207,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n-                let params_in_repr = self.tcx.params_in_repr(def_id);\n-                record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+                self.encode_info_for_adt(def_id);\n             }\n             if should_encode_trait_impl_trait_tys(tcx, def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n@@ -1213,46 +1230,53 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn encode_info_for_adt(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n-        let variant = &def.variant(index);\n-        let def_id = variant.def_id;\n-        debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+        let adt_def = tcx.adt_def(def_id);\n+        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n+\n+        let params_in_repr = self.tcx.params_in_repr(def_id);\n+        record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n-            assert!(f.did.is_local());\n-            f.did.index\n-        }));\n-        if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+        if adt_def.is_enum() {\n+            record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                for variant in tcx.adt_def(def_id).variants() {\n+                    yield variant.def_id.index;\n+                    // Encode constructors which take a separate slot in value namespace.\n+                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n+                        yield ctor_def_id.index;\n+                    }\n+                }\n+            ));\n+        } else {\n+            // For non-enum, there is only one variant, and its def_id is the adt's.\n+            debug_assert_eq!(adt_def.variants().len(), 1);\n+            debug_assert_eq!(adt_def.non_enum_variant().def_id, def_id);\n+            // Therefore, the loop over variants will encode its fields as the adt's children.\n         }\n-    }\n \n-    fn encode_enum_variant_ctor(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n-        let variant = &def.variant(index);\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n+        for variant in adt_def.variants().iter() {\n+            let data = VariantData {\n+                discr: variant.discr,\n+                ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n+                is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+            };\n+            record!(self.tables.variant_data[variant.def_id] <- data);\n \n-        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+            self.tables.constness.set(variant.def_id.index, hir::Constness::Const);\n+            record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n+                assert!(f.did.is_local());\n+                f.did.index\n+            }));\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n+            if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n+                self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n+                let fn_sig = tcx.fn_sig(ctor_def_id);\n+                record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n+                // FIXME only encode signature for ctor_def_id\n+                record!(self.tables.fn_sig[variant.def_id] <- fn_sig);\n+            }\n         }\n     }\n \n@@ -1286,8 +1310,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         hir::ItemKind::Struct(ref vdata, _) => {\n                             yield item_id.owner_id.def_id.local_def_index;\n                             // Encode constructors which take a separate slot in value namespace.\n-                            if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n-                                yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n+                            if let Some(ctor_def_id) = vdata.ctor_def_id() {\n+                                yield ctor_def_id.local_def_index;\n                             }\n                         }\n                         _ if tcx.def_key(item_id.owner_id.to_def_id()).get_opt_name().is_some() => {\n@@ -1305,25 +1329,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>) {\n-        let variant = adt_def.non_enum_variant();\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n-\n-        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n-        }\n-    }\n-\n     fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n@@ -1387,7 +1392,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n     }\n@@ -1409,6 +1414,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n             if encode_opt {\n                 record!(self.tables.optimized_mir[def_id.to_def_id()] <- tcx.optimized_mir(def_id));\n+\n+                if let DefKind::Generator = self.tcx.def_kind(def_id) && tcx.sess.opts.unstable_opts.drop_tracking_mir {\n+                    record!(self.tables.mir_generator_witnesses[def_id.to_def_id()] <- tcx.mir_generator_witnesses(def_id));\n+                }\n             }\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- tcx.mir_for_ctfe(def_id));\n@@ -1519,7 +1528,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 if macro_def.macro_rules {\n-                    self.tables.macro_rules.set(def_id.index, ());\n+                    self.tables.is_macro_rules.set_nullable(def_id.index, true);\n                 }\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n@@ -1529,36 +1538,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n                 if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n-                    self.tables.is_type_alias_impl_trait.set(def_id.index, ());\n+                    self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n                 }\n             }\n-            hir::ItemKind::Enum(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                self.tables.constness.set(def_id.index, hir::Constness::Const);\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n-            hir::ItemKind::Union(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n                 self.tables.constness.set(def_id.index, *constness);\n@@ -1597,31 +1579,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n-                    for variant in tcx.adt_def(def_id).variants() {\n-                        yield variant.def_id.index;\n-                        // Encode constructors which take a separate slot in value namespace.\n-                        if let Some(ctor_def_id) = variant.ctor_def_id() {\n-                            yield ctor_def_id.index;\n-                        }\n-                    }\n-                ))\n-            }\n-            hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record_array!(self.tables.children[def_id] <-\n-                    self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    })\n-                )\n-            }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record_array!(self.tables.children[def_id] <-\n@@ -1636,7 +1602,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n@@ -1649,17 +1615,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // so it's easier to do that here then to wait until we would encounter\n         // normally in the visitor walk.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                for (i, _) in def.variants().iter_enumerated() {\n-                    self.encode_enum_variant_info(def, i);\n-                    self.encode_enum_variant_ctor(def, i);\n-                }\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                self.encode_struct_ctor(def);\n-            }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n                     self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n@@ -1696,7 +1651,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::Closure(_, substs) => {\n                 let constness = self.tcx.constness(def_id.to_def_id());\n                 self.tables.constness.set(def_id.to_def_id().index, constness);\n-                record!(self.tables.fn_sig[def_id.to_def_id()] <- substs.as_closure().sig());\n+                record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder(substs.as_closure().sig()));\n             }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n@@ -2038,7 +1993,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n     }"}, {"sha": "37af9e64e9a3da5002ee527d5b6f655d05366506", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -185,9 +185,9 @@ enum LazyState {\n     Previous(NonZeroUsize),\n }\n \n-type SyntaxContextTable = LazyTable<u32, LazyValue<SyntaxContextData>>;\n-type ExpnDataTable = LazyTable<ExpnIndex, LazyValue<ExpnData>>;\n-type ExpnHashTable = LazyTable<ExpnIndex, LazyValue<ExpnHash>>;\n+type SyntaxContextTable = LazyTable<u32, Option<LazyValue<SyntaxContextData>>>;\n+type ExpnDataTable = LazyTable<ExpnIndex, Option<LazyValue<ExpnData>>>;\n+type ExpnHashTable = LazyTable<ExpnIndex, Option<LazyValue<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n pub(crate) struct ProcMacroData {\n@@ -253,7 +253,7 @@ pub(crate) struct CrateRoot {\n \n     def_path_hash_map: LazyValue<DefPathHashMapRef<'static>>,\n \n-    source_map: LazyTable<u32, LazyValue<rustc_span::SourceFile>>,\n+    source_map: LazyTable<u32, Option<LazyValue<rustc_span::SourceFile>>>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,\n@@ -315,31 +315,43 @@ pub(crate) struct IncoherentImpls {\n \n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n-    ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n+    (\n+        - nullable: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n+        - optional: $($name2:ident: Table<$IDX2:ty, $T2:ty>,)+\n+    ) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n         pub(crate) struct LazyTables {\n-            $($name: LazyTable<$IDX, $T>),+\n+            $($name1: LazyTable<$IDX1, $T1>,)+\n+            $($name2: LazyTable<$IDX2, Option<$T2>>,)+\n         }\n \n         #[derive(Default)]\n         struct TableBuilders {\n-            $($name: TableBuilder<$IDX, $T>),+\n+            $($name1: TableBuilder<$IDX1, $T1>,)+\n+            $($name2: TableBuilder<$IDX2, Option<$T2>>,)+\n         }\n \n         impl TableBuilders {\n             fn encode(&self, buf: &mut FileEncoder) -> LazyTables {\n                 LazyTables {\n-                    $($name: self.$name.encode(buf)),+\n+                    $($name1: self.$name1.encode(buf),)+\n+                    $($name2: self.$name2.encode(buf),)+\n                 }\n             }\n         }\n     }\n }\n \n define_tables! {\n+- nullable:\n+    is_intrinsic: Table<DefIndex, bool>,\n+    is_macro_rules: Table<DefIndex, bool>,\n+    is_type_alias_impl_trait: Table<DefIndex, bool>,\n+    attr_flags: Table<DefIndex, AttrFlags>,\n+\n+- optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n     children: Table<DefIndex, LazyArray<DefIndex>>,\n-\n     opt_def_kind: Table<DefIndex, DefKind>,\n     visibility: Table<DefIndex, LazyValue<ty::Visibility<DefIndex>>>,\n     def_span: Table<DefIndex, LazyValue<Span>>,\n@@ -357,20 +369,20 @@ define_tables! {\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<Ty<'static>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n-    fn_sig: Table<DefIndex, LazyValue<ty::PolyFnSig<'static>>>,\n+    fn_sig: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::PolyFnSig<'static>>>>,\n     codegen_fn_attrs: Table<DefIndex, LazyValue<CodegenFnAttrs>>,\n     impl_trait_ref: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::TraitRef<'static>>>>,\n     const_param_default: Table<DefIndex, LazyValue<ty::EarlyBinder<rustc_middle::ty::Const<'static>>>>,\n     object_lifetime_default: Table<DefIndex, LazyValue<ObjectLifetimeDefault>>,\n     optimized_mir: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n+    mir_generator_witnesses: Table<DefIndex, LazyValue<mir::GeneratorLayout<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n     thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,\n-    is_intrinsic: Table<DefIndex, ()>,\n     impl_defaultness: Table<DefIndex, hir::Defaultness>,\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     coerce_unsized_info: Table<DefIndex, LazyValue<ty::adjustment::CoerceUnsizedInfo>>,\n@@ -380,7 +392,6 @@ define_tables! {\n     fn_arg_names: Table<DefIndex, LazyArray<Ident>>,\n     generator_kind: Table<DefIndex, LazyValue<hir::GeneratorKind>>,\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n-\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n@@ -395,18 +406,12 @@ define_tables! {\n     def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n-    attr_flags: Table<DefIndex, AttrFlags>,\n     variant_data: Table<DefIndex, LazyValue<VariantData>>,\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n-    // Slot is full when macro is macro_rules.\n-    macro_rules: Table<DefIndex, ()>,\n     macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n-    // Slot is full when opaque is TAIT.\n-    is_type_alias_impl_trait: Table<DefIndex, ()>,\n-\n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n }\n \n@@ -419,6 +424,7 @@ struct VariantData {\n }\n \n bitflags::bitflags! {\n+    #[derive(Default)]\n     pub struct AttrFlags: u8 {\n         const MAY_HAVE_DOC_LINKS = 1 << 0;\n         const IS_DOC_HIDDEN      = 1 << 1;"}, {"sha": "70dbf6476e2fab40d8c4a89b575528b3bd3f6f6b", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -16,6 +16,7 @@ use std::num::NonZeroUsize;\n /// but this has no impact on safety.\n pub(super) trait FixedSizeEncoding: Default {\n     /// This should be `[u8; BYTE_LEN]`;\n+    /// Cannot use an associated `const BYTE_LEN: usize` instead due to const eval limitations.\n     type ByteArray;\n \n     fn from_bytes(b: &Self::ByteArray) -> Self;\n@@ -199,31 +200,31 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     }\n }\n \n-impl FixedSizeEncoding for Option<AttrFlags> {\n+impl FixedSizeEncoding for AttrFlags {\n     type ByteArray = [u8; 1];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 1]) -> Self {\n-        (b[0] != 0).then(|| AttrFlags::from_bits_truncate(b[0]))\n+        AttrFlags::from_bits_truncate(b[0])\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n-        b[0] = self.map_or(0, |flags| flags.bits())\n+        b[0] = self.bits();\n     }\n }\n \n-impl FixedSizeEncoding for Option<()> {\n+impl FixedSizeEncoding for bool {\n     type ByteArray = [u8; 1];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 1]) -> Self {\n-        (b[0] != 0).then(|| ())\n+        b[0] != 0\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n-        b[0] = self.is_some() as u8\n+        b[0] = self as u8\n     }\n }\n \n@@ -273,44 +274,38 @@ impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n }\n \n /// Helper for constructing a table's serialization (also see `Table`).\n-pub(super) struct TableBuilder<I: Idx, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    blocks: IndexVec<I, <Option<T> as FixedSizeEncoding>::ByteArray>,\n+pub(super) struct TableBuilder<I: Idx, T: FixedSizeEncoding> {\n+    blocks: IndexVec<I, T::ByteArray>,\n     _marker: PhantomData<T>,\n }\n \n-impl<I: Idx, T> Default for TableBuilder<I, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n+impl<I: Idx, T: FixedSizeEncoding> Default for TableBuilder<I, T> {\n     fn default() -> Self {\n         TableBuilder { blocks: Default::default(), _marker: PhantomData }\n     }\n }\n \n-impl<I: Idx, T> TableBuilder<I, T>\n+impl<I: Idx, const N: usize, T> TableBuilder<I, Option<T>>\n where\n-    Option<T>: FixedSizeEncoding,\n+    Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n-    pub(crate) fn set<const N: usize>(&mut self, i: I, value: T)\n-    where\n-        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(crate) fn set(&mut self, i: I, value: T) {\n+        self.set_nullable(i, Some(value))\n+    }\n+}\n+\n+impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]>> TableBuilder<I, T> {\n+    pub(crate) fn set_nullable(&mut self, i: I, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n         // > trick (i.e. divide things into buckets of 32 or 64 items and then\n         // > store bit-masks of which item in each bucket is actually serialized).\n         self.blocks.ensure_contains_elem(i, || [0; N]);\n-        Some(value).write_to_bytes(&mut self.blocks[i]);\n+        value.write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut FileEncoder) -> LazyTable<I, T>\n-    where\n-        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(crate) fn encode(&self, buf: &mut FileEncoder) -> LazyTable<I, T> {\n         let pos = buf.position();\n         for block in &self.blocks {\n             buf.emit_raw_bytes(block);\n@@ -323,34 +318,27 @@ where\n     }\n }\n \n-impl<I: Idx, T: ParameterizedOverTcx> LazyTable<I, T>\n+impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]> + ParameterizedOverTcx>\n+    LazyTable<I, T>\n where\n-    Option<T>: FixedSizeEncoding,\n+    for<'tcx> T::Value<'tcx>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>, const N: usize>(\n-        &self,\n-        metadata: M,\n-        i: I,\n-    ) -> Option<T::Value<'tcx>>\n-    where\n-        Option<T::Value<'tcx>>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(&self, metadata: M, i: I) -> T::Value<'tcx> {\n         debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n \n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n-        let bytes = bytes.get(i.index())?;\n-        FixedSizeEncoding::from_bytes(bytes)\n+        match bytes.get(i.index()) {\n+            Some(bytes) => FixedSizeEncoding::from_bytes(bytes),\n+            None => FixedSizeEncoding::from_bytes(&[0; N]),\n+        }\n     }\n \n     /// Size of the table in entries, including possible gaps.\n-    pub(super) fn size<const N: usize>(&self) -> usize\n-    where\n-        for<'tcx> Option<T::Value<'tcx>>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(super) fn size(&self) -> usize {\n         self.encoded_size / N\n     }\n }"}, {"sha": "72f4f6e649bcf178e51017fc2fb8a57bb81b52a0", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -105,7 +105,7 @@ macro_rules! arena_types {\n             // (during lowering) and the `librustc_middle` arena (for decoding MIR)\n             [decode] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [decode] used_trait_imports: rustc_data_structures::unord::UnordSet<rustc_hir::def_id::LocalDefId>,\n-            [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] is_late_bound_map: rustc_data_structures::fx::FxIndexSet<rustc_hir::ItemLocalId>,\n             [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n \n             [] dep_kind: rustc_middle::dep_graph::DepKindStruct<'tcx>,"}, {"sha": "5bd6b0704426b667b4e0435cd4ac3bb30f5f66a8", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -18,32 +18,38 @@ use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n #[inline]\n-pub fn associated_body(node: Node<'_>) -> Option<BodyId> {\n+pub fn associated_body(node: Node<'_>) -> Option<(LocalDefId, BodyId)> {\n     match node {\n         Node::Item(Item {\n+            owner_id,\n             kind: ItemKind::Const(_, body) | ItemKind::Static(.., body) | ItemKind::Fn(.., body),\n             ..\n         })\n         | Node::TraitItem(TraitItem {\n+            owner_id,\n             kind:\n                 TraitItemKind::Const(_, Some(body)) | TraitItemKind::Fn(_, TraitFn::Provided(body)),\n             ..\n         })\n         | Node::ImplItem(ImplItem {\n+            owner_id,\n             kind: ImplItemKind::Const(_, body) | ImplItemKind::Fn(_, body),\n             ..\n-        })\n-        | Node::Expr(Expr { kind: ExprKind::Closure(Closure { body, .. }), .. }) => Some(*body),\n+        }) => Some((owner_id.def_id, *body)),\n+\n+        Node::Expr(Expr { kind: ExprKind::Closure(Closure { def_id, body, .. }), .. }) => {\n+            Some((*def_id, *body))\n+        }\n \n-        Node::AnonConst(constant) => Some(constant.body),\n+        Node::AnonConst(constant) => Some((constant.def_id, constant.body)),\n \n         _ => None,\n     }\n }\n \n fn is_body_owner(node: Node<'_>, hir_id: HirId) -> bool {\n     match associated_body(node) {\n-        Some(b) => b.hir_id == hir_id,\n+        Some((_, b)) => b.hir_id == hir_id,\n         None => false,\n     }\n }\n@@ -154,10 +160,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions_untracked().def_key(def_id)\n     }\n \n-    pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n-        self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n-    }\n-\n     pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         self.tcx.definitions_untracked().def_path(def_id)\n@@ -169,32 +171,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions_untracked().def_path_hash(def_id)\n     }\n \n-    #[inline]\n-    #[track_caller]\n-    pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n-        self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n-            bug!(\n-                \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n-                hir_id,\n-                self.find(hir_id)\n-            )\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn opt_local_def_id(self, hir_id: HirId) -> Option<LocalDefId> {\n-        if hir_id.local_id == ItemLocalId::new(0) {\n-            Some(hir_id.owner.def_id)\n-        } else {\n-            self.tcx\n-                .hir_owner_nodes(hir_id.owner)\n-                .as_owner()?\n-                .local_id_to_def_id\n-                .get(&hir_id.local_id)\n-                .copied()\n-        }\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(self, def_id: LocalDefId) -> HirId {\n         self.tcx.local_def_id_to_hir_id(def_id)\n@@ -410,8 +386,8 @@ impl<'hir> Map<'hir> {\n     #[track_caller]\n     pub fn enclosing_body_owner(self, hir_id: HirId) -> LocalDefId {\n         for (_, node) in self.parent_iter(hir_id) {\n-            if let Some(body) = associated_body(node) {\n-                return self.body_owner_def_id(body);\n+            if let Some((def_id, _)) = associated_body(node) {\n+                return def_id;\n             }\n         }\n \n@@ -427,14 +403,17 @@ impl<'hir> Map<'hir> {\n         parent\n     }\n \n-    pub fn body_owner_def_id(self, id: BodyId) -> LocalDefId {\n-        self.local_def_id(self.body_owner(id))\n+    pub fn body_owner_def_id(self, BodyId { hir_id }: BodyId) -> LocalDefId {\n+        let parent = self.parent_id(hir_id);\n+        associated_body(self.get(parent)).unwrap().0\n     }\n \n     /// Given a `LocalDefId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(self, id: LocalDefId) -> Option<BodyId> {\n-        self.find_by_def_id(id).and_then(associated_body)\n+        let node = self.find_by_def_id(id)?;\n+        let (_, body_id) = associated_body(node)?;\n+        Some(body_id)\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it."}, {"sha": "6e130bbf7d8284403fccb3af90c7e1a229a08c86", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -25,10 +25,8 @@ use crate::infer::MemberConstraint;\n use crate::mir::ConstraintCategory;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, Ty, TyCtxt};\n-use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use smallvec::SmallVec;\n-use std::iter;\n use std::ops::Index;\n \n /// A \"canonicalized\" type `V` is one where all free inference\n@@ -62,23 +60,23 @@ impl<'tcx> ty::TypeFoldable<'tcx> for CanonicalVarInfos<'tcx> {\n /// vectors with the original values that were replaced by canonical\n /// variables. You will need to supply it later to instantiate the\n /// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n+    pub var_values: ty::SubstsRef<'tcx>,\n }\n \n impl CanonicalVarValues<'_> {\n     pub fn is_identity(&self) -> bool {\n-        self.var_values.iter_enumerated().all(|(bv, arg)| match arg.unpack() {\n+        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n             ty::GenericArgKind::Lifetime(r) => {\n-                matches!(*r, ty::ReLateBound(ty::INNERMOST, br) if br.var == bv)\n+                matches!(*r, ty::ReLateBound(ty::INNERMOST, br) if br.var.as_usize() == bv)\n             }\n             ty::GenericArgKind::Type(ty) => {\n-                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var == bv)\n+                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n             }\n             ty::GenericArgKind::Const(ct) => {\n-                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc == bv)\n+                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n             }\n         })\n     }\n@@ -339,64 +337,64 @@ TrivialTypeTraversalAndLiftImpls! {\n }\n \n impl<'tcx> CanonicalVarValues<'tcx> {\n+    // Given a list of canonical variables, construct a set of values which are\n+    // the identity response.\n+    pub fn make_identity(\n+        tcx: TyCtxt<'tcx>,\n+        infos: CanonicalVarInfos<'tcx>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        CanonicalVarValues {\n+            var_values: tcx.mk_substs(infos.iter().enumerate().map(\n+                |(i, info)| -> ty::GenericArg<'tcx> {\n+                    match info.kind {\n+                        CanonicalVarKind::Ty(_) | CanonicalVarKind::PlaceholderTy(_) => tcx\n+                            .mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i).into()))\n+                            .into(),\n+                        CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => {\n+                            let br = ty::BoundRegion {\n+                                var: ty::BoundVar::from_usize(i),\n+                                kind: ty::BrAnon(i as u32, None),\n+                            };\n+                            tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n+                        }\n+                        CanonicalVarKind::Const(_, ty)\n+                        | CanonicalVarKind::PlaceholderConst(_, ty) => tcx\n+                            .mk_const(\n+                                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(i)),\n+                                ty,\n+                            )\n+                            .into(),\n+                    }\n+                },\n+            )),\n+        }\n+    }\n+\n     /// Creates dummy var values which should not be used in a\n     /// canonical response.\n     pub fn dummy() -> CanonicalVarValues<'tcx> {\n-        CanonicalVarValues { var_values: Default::default() }\n+        CanonicalVarValues { var_values: ty::List::empty() }\n     }\n \n     #[inline]\n     pub fn len(&self) -> usize {\n         self.var_values.len()\n     }\n-\n-    /// Makes an identity substitution from this one: each bound var\n-    /// is matched to the same bound var, preserving the original kinds.\n-    /// For example, if we have:\n-    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n-    /// we'll return a substitution `subst` with:\n-    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n-        use crate::ty::subst::GenericArgKind;\n-\n-        CanonicalVarValues {\n-            var_values: iter::zip(&self.var_values, 0..)\n-                .map(|(kind, i)| match kind.unpack() {\n-                    GenericArgKind::Type(..) => {\n-                        tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n-                    }\n-                    GenericArgKind::Lifetime(..) => {\n-                        let br = ty::BoundRegion {\n-                            var: ty::BoundVar::from_u32(i),\n-                            kind: ty::BrAnon(i, None),\n-                        };\n-                        tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n-                    }\n-                    GenericArgKind::Const(ct) => tcx\n-                        .mk_const(\n-                            ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n-                            ct.ty(),\n-                        )\n-                        .into(),\n-                })\n-                .collect(),\n-        }\n-    }\n }\n \n impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n     type Item = GenericArg<'tcx>;\n-    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n+    type IntoIter = ::std::iter::Copied<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n \n     fn into_iter(self) -> Self::IntoIter {\n-        self.var_values.iter().cloned()\n+        self.var_values.iter()\n     }\n }\n \n impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n     type Output = GenericArg<'tcx>;\n \n     fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n-        &self.var_values[value]\n+        &self.var_values[value.as_usize()]\n     }\n }"}, {"sha": "95148de251824ad0aceb5dbe48777fcbceaeddbc", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -43,6 +43,7 @@\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(type_alias_impl_trait)]\n+#![feature(strict_provenance)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(control_flow_enum)]"}, {"sha": "b93871769b791c9ab7de6f3c0aa605d3cef4f89b", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -41,7 +41,6 @@ impl<'tcx> BasicBlocks<'tcx> {\n         *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n-    #[inline]\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n         dominators(&self)\n     }"}, {"sha": "b0975616b6151546773253fb88af57da891f678f", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -110,7 +110,7 @@ use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_target::abi::Endian;\n+use rustc_target::abi::{AddressSpace, Endian, HasDataLayout};\n \n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n@@ -438,6 +438,17 @@ impl<'tcx> GlobalAlloc<'tcx> {\n             _ => bug!(\"expected vtable, got {:?}\", self),\n         }\n     }\n+\n+    /// The address space that this `GlobalAlloc` should be placed in.\n+    #[inline]\n+    pub fn address_space(&self, cx: &impl HasDataLayout) -> AddressSpace {\n+        match self {\n+            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) | GlobalAlloc::VTable(..) => {\n+                AddressSpace::DATA\n+            }\n+        }\n+    }\n }\n \n pub(crate) struct AllocMap<'tcx> {"}, {"sha": "552af589bec59b12f3b2f40516f7ef7f6dce5b37", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -902,6 +902,8 @@ pub enum LocalInfo<'tcx> {\n     AggregateTemp,\n     /// A temporary created during the pass `Derefer` to avoid it's retagging\n     DerefTemp,\n+    /// A temporary created for borrow checking.\n+    FakeBorrow,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n@@ -1461,6 +1463,7 @@ impl Debug for Statement<'_> {\n             }\n             Coverage(box ref coverage) => write!(fmt, \"Coverage::{:?}\", coverage.kind),\n             Intrinsic(box ref intrinsic) => write!(fmt, \"{intrinsic}\"),\n+            ConstEvalCounter => write!(fmt, \"ConstEvalCounter\"),\n             Nop => write!(fmt, \"nop\"),\n         }\n     }\n@@ -2504,7 +2507,7 @@ impl<'tcx> ConstantKind<'tcx> {\n \n         let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n         let parent_substs = if let Some(parent_hir_id) = tcx.hir().opt_parent_id(hir_id) {\n-            if let Some(parent_did) = tcx.hir().opt_local_def_id(parent_hir_id) {\n+            if let Some(parent_did) = parent_hir_id.as_owner() {\n                 InternalSubsts::identity_for_item(tcx, parent_did.to_def_id())\n             } else {\n                 tcx.mk_substs(Vec::<GenericArg<'tcx>>::new().into_iter())\n@@ -3046,7 +3049,7 @@ impl Location {\n         if self.block == other.block {\n             self.statement_index <= other.statement_index\n         } else {\n-            dominators.is_dominated_by(other.block, self.block)\n+            dominators.dominates(self.block, other.block)\n         }\n     }\n }"}, {"sha": "7a05ee2ff37fdc3dbc3324603b203fec44e59f60", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -318,16 +318,19 @@ impl<'tcx> CodegenUnit<'tcx> {\n         base_n::encode(hash, base_n::CASE_INSENSITIVE)\n     }\n \n-    pub fn estimate_size(&mut self, tcx: TyCtxt<'tcx>) {\n+    pub fn create_size_estimate(&mut self, tcx: TyCtxt<'tcx>) {\n         // Estimate the size of a codegen unit as (approximately) the number of MIR\n         // statements it corresponds to.\n         self.size_estimate = Some(self.items.keys().map(|mi| mi.size_estimate(tcx)).sum());\n     }\n \n     #[inline]\n+    /// Should only be called if [`create_size_estimate`] has previously been called.\n+    ///\n+    /// [`create_size_estimate`]: Self::create_size_estimate\n     pub fn size_estimate(&self) -> usize {\n-        // Should only be called if `estimate_size` has previously been called.\n-        self.size_estimate.expect(\"estimate_size must be called before getting a size_estimate\")\n+        self.size_estimate\n+            .expect(\"create_size_estimate must be called before getting a size_estimate\")\n     }\n \n     pub fn modify_size_estimate(&mut self, delta: usize) {"}, {"sha": "6155f2bb56ce93bdb0f4c72fa6189e53359254f7", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -135,11 +135,20 @@ rustc_index::newtype_index! {\n     pub struct GeneratorSavedLocal {}\n }\n \n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+pub struct GeneratorSavedTy<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    /// Source info corresponding to the local in the original MIR body.\n+    pub source_info: SourceInfo,\n+    /// Whether the local should be ignored for trait bound computations.\n+    pub ignore_for_traits: bool,\n+}\n+\n /// The layout of generator state.\n #[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n-    pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n+    pub field_tys: IndexVec<GeneratorSavedLocal, GeneratorSavedTy<'tcx>>,\n \n     /// Which of the above fields are in each variant. Note that one field may\n     /// be stored in multiple variants."}, {"sha": "1610ae1ce1480937d3b6fc1e8b155b6f4480f871", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -250,6 +250,7 @@ pub fn statement_kind_name(statement: &Statement<'_>) -> &'static str {\n         AscribeUserType(..) => \"AscribeUserType\",\n         Coverage(..) => \"Coverage\",\n         Intrinsic(..) => \"Intrinsic\",\n+        ConstEvalCounter => \"ConstEvalCounter\",\n         Nop => \"Nop\",\n     }\n }\n@@ -670,7 +671,7 @@ fn fn_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n \n fn hir_body(tcx: TyCtxt<'_>, def_id: DefId) -> Option<&rustc_hir::Body<'_>> {\n     let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n-    hir::map::associated_body(hir_node).map(|fn_body_id| tcx.hir().body(fn_body_id))\n+    hir::map::associated_body(hir_node).map(|(_, fn_body_id)| tcx.hir().body(fn_body_id))\n }\n \n fn escape_html(s: &str) -> String {"}, {"sha": "549bc65d6d79c7858a144fd038c107f1a07d85e5", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -355,6 +355,12 @@ pub enum StatementKind<'tcx> {\n     /// This avoids adding a new block and a terminator for simple intrinsics.\n     Intrinsic(Box<NonDivergingIntrinsic<'tcx>>),\n \n+    /// Instructs the const eval interpreter to increment a counter; this counter is used to track\n+    /// how many steps the interpreter has taken. It is used to prevent the user from writing const\n+    /// code that runs for too long or infinitely. Other than in the const eval interpreter, this\n+    /// is a no-op.\n+    ConstEvalCounter,\n+\n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }"}, {"sha": "3ddac5e11fbc53bea3811686fdee4076d6d7a89e", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -427,6 +427,7 @@ macro_rules! make_mir_visitor {\n                             }\n                         }\n                     }\n+                    StatementKind::ConstEvalCounter => {}\n                     StatementKind::Nop => {}\n                 }\n             }"}, {"sha": "4cebe416354a928fd423f0cd4c56f68af5d3c253", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -183,6 +183,15 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query unsizing_params_for_adt(key: DefId) -> rustc_index::bit_set::BitSet<u32>\n+    {\n+        arena_cache\n+        desc { |tcx|\n+            \"determining what parameters of `{}` can participate in unsizing\",\n+            tcx.def_path_str(key),\n+        }\n+    }\n+\n     query analysis(key: ()) -> Result<(), ErrorGuaranteed> {\n         eval_always\n         desc { \"running analysis passes on this crate\" }\n@@ -361,6 +370,13 @@ rustc_queries! {\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n+    /// Create a list-like THIR representation for debugging.\n+    query thir_flat(key: ty::WithOptConstParam<LocalDefId>) -> String {\n+        no_hash\n+        arena_cache\n+        desc { |tcx| \"constructing flat THIR representation for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+    }\n+\n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n@@ -471,6 +487,17 @@ rustc_queries! {\n         }\n     }\n \n+    query mir_generator_witnesses(key: DefId) -> mir::GeneratorLayout<'tcx> {\n+        arena_cache\n+        desc { |tcx| \"generator witness types for `{}`\", tcx.def_path_str(key) }\n+        cache_on_disk_if { key.is_local() }\n+        separate_provide_extern\n+    }\n+\n+    query check_generator_obligations(key: LocalDefId) {\n+        desc { |tcx| \"verify auto trait bounds for generator interior type `{}`\", tcx.def_path_str(key.to_def_id()) }\n+    }\n+\n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n     query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n@@ -796,15 +823,6 @@ rustc_queries! {\n         }\n     }\n \n-    /// HACK: when evaluated, this reports an \"unsafe derive on repr(packed)\" error.\n-    ///\n-    /// Unsafety checking is executed for each method separately, but we only want\n-    /// to emit this error once per derive. As there are some impls with multiple\n-    /// methods, we use a query for deduplication.\n-    query unsafe_derive_on_repr_packed(key: LocalDefId) -> () {\n-        desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n-    }\n-\n     /// Returns the types assumed to be well formed while \"inside\" of the given item.\n     ///\n     /// Note that we've liberated the late bound regions of function signatures, so\n@@ -814,7 +832,7 @@ rustc_queries! {\n     }\n \n     /// Computes the signature of the function.\n-    query fn_sig(key: DefId) -> ty::PolyFnSig<'tcx> {\n+    query fn_sig(key: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {\n         desc { |tcx| \"computing function signature of `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n@@ -1263,6 +1281,9 @@ rustc_queries! {\n     query object_safety_violations(trait_id: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n         desc { |tcx| \"determining object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n     }\n+    query check_is_object_safe(trait_id: DefId) -> bool {\n+        desc { |tcx| \"checking if trait `{}` is object safe\", tcx.def_path_str(trait_id) }\n+    }\n \n     /// Gets the ParameterEnvironment for a given item; this environment\n     /// will be in \"user-facing\" mode, meaning that it is suitable for\n@@ -1629,7 +1650,7 @@ rustc_queries! {\n         Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n         desc { \"looking up a named region\" }\n     }\n-    query is_late_bound_map(_: LocalDefId) -> Option<&'tcx FxIndexSet<LocalDefId>> {\n+    query is_late_bound_map(_: hir::OwnerId) -> Option<&'tcx FxIndexSet<ItemLocalId>> {\n         desc { \"testing if a region is late bound\" }\n     }\n     /// For a given item's generic parameter, gets the default lifetimes to be used\n@@ -1863,9 +1884,10 @@ rustc_queries! {\n     ///\n     /// This query returns an `&Arc` because codegen backends need the value even after the `TyCtxt`\n     /// has been destroyed.\n-    query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n+    query output_filenames(_: ()) -> Arc<OutputFilenames> {\n         feedable\n         desc { \"getting output filenames\" }\n+        arena_cache\n     }\n \n     /// Do not call this query directly: invoke `normalize` instead.\n@@ -2116,12 +2138,12 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query permits_uninit_init(key: TyAndLayout<'tcx>) -> bool {\n-        desc { \"checking to see if `{}` permits being left uninit\", key.ty }\n+    query permits_uninit_init(key: ty::ParamEnvAnd<'tcx, TyAndLayout<'tcx>>) -> bool {\n+        desc { \"checking to see if `{}` permits being left uninit\", key.value.ty }\n     }\n \n-    query permits_zero_init(key: TyAndLayout<'tcx>) -> bool {\n-        desc { \"checking to see if `{}` permits being left zeroed\", key.ty }\n+    query permits_zero_init(key: ty::ParamEnvAnd<'tcx, TyAndLayout<'tcx>>) -> bool {\n+        desc { \"checking to see if `{}` permits being left zeroed\", key.value.ty }\n     }\n \n     query compare_impl_const("}, {"sha": "6f2dac467532cdfb50e2b54b24276ff7278719ee", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -29,6 +29,7 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n+pub mod print;\n pub mod visit;\n \n macro_rules! thir_with_elements {"}, {"sha": "60b903e99066b6d4ef8b5127f2dec7d768c05583", "filename": "compiler/rustc_middle/src/thir/print.rs", "status": "added", "additions": 881, "deletions": 0, "changes": 881, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fprint.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,881 @@\n+use crate::thir::*;\n+use crate::ty::{self, TyCtxt};\n+\n+use std::fmt::{self, Write};\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub fn thir_tree_representation<'a>(self, thir: &'a Thir<'tcx>) -> String {\n+        let mut printer = ThirPrinter::new(thir);\n+        printer.print();\n+        printer.into_buffer()\n+    }\n+}\n+\n+struct ThirPrinter<'a, 'tcx> {\n+    thir: &'a Thir<'tcx>,\n+    fmt: String,\n+}\n+\n+const INDENT: &str = \"    \";\n+\n+macro_rules! print_indented {\n+    ($writer:ident, $s:expr, $indent_lvl:expr) => {\n+        let indent = (0..$indent_lvl).map(|_| INDENT).collect::<Vec<_>>().concat();\n+        writeln!($writer, \"{}{}\", indent, $s).expect(\"unable to write to ThirPrinter\");\n+    };\n+}\n+\n+impl<'a, 'tcx> Write for ThirPrinter<'a, 'tcx> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        self.fmt.push_str(s);\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> ThirPrinter<'a, 'tcx> {\n+    fn new(thir: &'a Thir<'tcx>) -> Self {\n+        Self { thir, fmt: String::new() }\n+    }\n+\n+    fn print(&mut self) {\n+        print_indented!(self, \"params: [\", 0);\n+        for param in self.thir.params.iter() {\n+            self.print_param(param, 1);\n+        }\n+        print_indented!(self, \"]\", 0);\n+\n+        print_indented!(self, \"body:\", 0);\n+        let expr = ExprId::from_usize(self.thir.exprs.len() - 1);\n+        self.print_expr(expr, 1);\n+    }\n+\n+    fn into_buffer(self) -> String {\n+        self.fmt\n+    }\n+\n+    fn print_param(&mut self, param: &Param<'tcx>, depth_lvl: usize) {\n+        let Param { pat, ty, ty_span, self_kind, hir_id } = param;\n+\n+        print_indented!(self, \"Param {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"ty_span: {:?}\", ty_span), depth_lvl + 1);\n+        print_indented!(self, format!(\"self_kind: {:?}\", self_kind), depth_lvl + 1);\n+        print_indented!(self, format!(\"hir_id: {:?}\", hir_id), depth_lvl + 1);\n+\n+        if let Some(pat) = pat {\n+            print_indented!(self, \"param: Some( \", depth_lvl + 1);\n+            self.print_pat(pat, depth_lvl + 2);\n+            print_indented!(self, \")\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"param: None\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_block(&mut self, block_id: BlockId, depth_lvl: usize) {\n+        let Block {\n+            targeted_by_break,\n+            opt_destruction_scope,\n+            span,\n+            region_scope,\n+            stmts,\n+            expr,\n+            safety_mode,\n+        } = &self.thir.blocks[block_id];\n+\n+        print_indented!(self, \"Block {\", depth_lvl);\n+        print_indented!(self, format!(\"targeted_by_break: {}\", targeted_by_break), depth_lvl + 1);\n+        print_indented!(\n+            self,\n+            format!(\"opt_destruction_scope: {:?}\", opt_destruction_scope),\n+            depth_lvl + 1\n+        );\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, format!(\"region_scope: {:?}\", region_scope), depth_lvl + 1);\n+        print_indented!(self, format!(\"safety_mode: {:?}\", safety_mode), depth_lvl + 1);\n+\n+        if stmts.len() > 0 {\n+            print_indented!(self, \"stmts: [\", depth_lvl + 1);\n+            for stmt in stmts.iter() {\n+                self.print_stmt(*stmt, depth_lvl + 2);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"stmts: []\", depth_lvl + 1);\n+        }\n+\n+        if let Some(expr_id) = expr {\n+            print_indented!(self, \"expr:\", depth_lvl + 1);\n+            self.print_expr(*expr_id, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"expr: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_stmt(&mut self, stmt_id: StmtId, depth_lvl: usize) {\n+        let Stmt { kind, opt_destruction_scope } = &self.thir.stmts[stmt_id];\n+\n+        print_indented!(self, \"Stmt {\", depth_lvl);\n+        print_indented!(\n+            self,\n+            format!(\"opt_destruction_scope: {:?}\", opt_destruction_scope),\n+            depth_lvl + 1\n+        );\n+\n+        match kind {\n+            StmtKind::Expr { scope, expr } => {\n+                print_indented!(self, \"kind: Expr {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"scope: {:?}\", scope), depth_lvl + 2);\n+                print_indented!(self, \"expr:\", depth_lvl + 2);\n+                self.print_expr(*expr, depth_lvl + 3);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            StmtKind::Let {\n+                remainder_scope,\n+                init_scope,\n+                pattern,\n+                initializer,\n+                else_block,\n+                lint_level,\n+            } => {\n+                print_indented!(self, \"kind: Let {\", depth_lvl + 1);\n+                print_indented!(\n+                    self,\n+                    format!(\"remainder_scope: {:?}\", remainder_scope),\n+                    depth_lvl + 2\n+                );\n+                print_indented!(self, format!(\"init_scope: {:?}\", init_scope), depth_lvl + 2);\n+\n+                print_indented!(self, \"pattern: \", depth_lvl + 2);\n+                self.print_pat(pattern, depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+\n+                if let Some(init) = initializer {\n+                    print_indented!(self, \"initializer: Some(\", depth_lvl + 2);\n+                    self.print_expr(*init, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"initializer: None\", depth_lvl + 2);\n+                }\n+\n+                if let Some(else_block) = else_block {\n+                    print_indented!(self, \"else_block: Some(\", depth_lvl + 2);\n+                    self.print_block(*else_block, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"else_block: None\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_expr(&mut self, expr: ExprId, depth_lvl: usize) {\n+        let Expr { ty, temp_lifetime, span, kind } = &self.thir[expr];\n+        print_indented!(self, \"Expr {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"temp_lifetime: {:?}\", temp_lifetime), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, \"kind: \", depth_lvl + 1);\n+        self.print_expr_kind(kind, depth_lvl + 2);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_expr_kind(&mut self, expr_kind: &ExprKind<'tcx>, depth_lvl: usize) {\n+        use rustc_middle::thir::ExprKind::*;\n+\n+        match expr_kind {\n+            Scope { region_scope, value, lint_level } => {\n+                print_indented!(self, \"Scope {\", depth_lvl);\n+                print_indented!(self, format!(\"region_scope: {:?}\", region_scope), depth_lvl + 1);\n+                print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 1);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Box { value } => {\n+                print_indented!(self, \"Box {\", depth_lvl);\n+                self.print_expr(*value, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            If { if_then_scope, cond, then, else_opt } => {\n+                print_indented!(self, \"If {\", depth_lvl);\n+                print_indented!(self, format!(\"if_then_scope: {:?}\", if_then_scope), depth_lvl + 1);\n+                print_indented!(self, \"cond:\", depth_lvl + 1);\n+                self.print_expr(*cond, depth_lvl + 2);\n+                print_indented!(self, \"then:\", depth_lvl + 1);\n+                self.print_expr(*then, depth_lvl + 2);\n+\n+                if let Some(else_expr) = else_opt {\n+                    print_indented!(self, \"else:\", depth_lvl + 1);\n+                    self.print_expr(*else_expr, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Call { fun, args, ty, from_hir_call, fn_span } => {\n+                print_indented!(self, \"Call {\", depth_lvl);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"from_hir_call: {}\", from_hir_call), depth_lvl + 1);\n+                print_indented!(self, format!(\"fn_span: {:?}\", fn_span), depth_lvl + 1);\n+                print_indented!(self, \"fun:\", depth_lvl + 1);\n+                self.print_expr(*fun, depth_lvl + 2);\n+\n+                if args.len() > 0 {\n+                    print_indented!(self, \"args: [\", depth_lvl + 1);\n+                    for arg in args.iter() {\n+                        self.print_expr(*arg, depth_lvl + 2);\n+                    }\n+                    print_indented!(self, \"]\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"args: []\", depth_lvl + 1);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Deref { arg } => {\n+                print_indented!(self, \"Deref {\", depth_lvl);\n+                self.print_expr(*arg, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Binary { op, lhs, rhs } => {\n+                print_indented!(self, \"Binary {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            LogicalOp { op, lhs, rhs } => {\n+                print_indented!(self, \"LogicalOp {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Unary { op, arg } => {\n+                print_indented!(self, \"Unary {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Cast { source } => {\n+                print_indented!(self, \"Cast {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Use { source } => {\n+                print_indented!(self, \"Use {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            NeverToAny { source } => {\n+                print_indented!(self, \"NeverToAny {\", depth_lvl);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Pointer { cast, source } => {\n+                print_indented!(self, \"Pointer {\", depth_lvl);\n+                print_indented!(self, format!(\"cast: {:?}\", cast), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Loop { body } => {\n+                print_indented!(self, \"Loop (\", depth_lvl);\n+                print_indented!(self, \"body:\", depth_lvl + 1);\n+                self.print_expr(*body, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            Let { expr, pat } => {\n+                print_indented!(self, \"Let {\", depth_lvl);\n+                print_indented!(self, \"expr:\", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, format!(\"pat: {:?}\", pat), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Match { scrutinee, arms } => {\n+                print_indented!(self, \"Match {\", depth_lvl);\n+                print_indented!(self, \"scrutinee:\", depth_lvl + 1);\n+                self.print_expr(*scrutinee, depth_lvl + 2);\n+\n+                print_indented!(self, \"arms: [\", depth_lvl + 1);\n+                for arm_id in arms.iter() {\n+                    self.print_arm(*arm_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Block { block } => self.print_block(*block, depth_lvl),\n+            Assign { lhs, rhs } => {\n+                print_indented!(self, \"Assign {\", depth_lvl);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            AssignOp { op, lhs, rhs } => {\n+                print_indented!(self, \"AssignOp {\", depth_lvl);\n+                print_indented!(self, format!(\"op: {:?}\", op), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"rhs:\", depth_lvl + 1);\n+                self.print_expr(*rhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Field { lhs, variant_index, name } => {\n+                print_indented!(self, \"Field {\", depth_lvl);\n+                print_indented!(self, format!(\"variant_index: {:?}\", variant_index), depth_lvl + 1);\n+                print_indented!(self, format!(\"name: {:?}\", name), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Index { lhs, index } => {\n+                print_indented!(self, \"Index {\", depth_lvl);\n+                print_indented!(self, format!(\"index: {:?}\", index), depth_lvl + 1);\n+                print_indented!(self, \"lhs:\", depth_lvl + 1);\n+                self.print_expr(*lhs, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            VarRef { id } => {\n+                print_indented!(self, \"VarRef {\", depth_lvl);\n+                print_indented!(self, format!(\"id: {:?}\", id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            UpvarRef { closure_def_id, var_hir_id } => {\n+                print_indented!(self, \"UpvarRef {\", depth_lvl);\n+                print_indented!(\n+                    self,\n+                    format!(\"closure_def_id: {:?}\", closure_def_id),\n+                    depth_lvl + 1\n+                );\n+                print_indented!(self, format!(\"var_hir_id: {:?}\", var_hir_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Borrow { borrow_kind, arg } => {\n+                print_indented!(self, \"Borrow (\", depth_lvl);\n+                print_indented!(self, format!(\"borrow_kind: {:?}\", borrow_kind), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            AddressOf { mutability, arg } => {\n+                print_indented!(self, \"AddressOf {\", depth_lvl);\n+                print_indented!(self, format!(\"mutability: {:?}\", mutability), depth_lvl + 1);\n+                print_indented!(self, \"arg:\", depth_lvl + 1);\n+                self.print_expr(*arg, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Break { label, value } => {\n+                print_indented!(self, \"Break (\", depth_lvl);\n+                print_indented!(self, format!(\"label: {:?}\", label), depth_lvl + 1);\n+\n+                if let Some(value) = value {\n+                    print_indented!(self, \"value:\", depth_lvl + 1);\n+                    self.print_expr(*value, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \")\", depth_lvl);\n+            }\n+            Continue { label } => {\n+                print_indented!(self, \"Continue {\", depth_lvl);\n+                print_indented!(self, format!(\"label: {:?}\", label), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Return { value } => {\n+                print_indented!(self, \"Return {\", depth_lvl);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+\n+                if let Some(value) = value {\n+                    self.print_expr(*value, depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ConstBlock { did, substs } => {\n+                print_indented!(self, \"ConstBlock {\", depth_lvl);\n+                print_indented!(self, format!(\"did: {:?}\", did), depth_lvl + 1);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Repeat { value, count } => {\n+                print_indented!(self, \"Repeat {\", depth_lvl);\n+                print_indented!(self, format!(\"count: {:?}\", count), depth_lvl + 1);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Array { fields } => {\n+                print_indented!(self, \"Array {\", depth_lvl);\n+                print_indented!(self, \"fields: [\", depth_lvl + 1);\n+                for field_id in fields.iter() {\n+                    self.print_expr(*field_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Tuple { fields } => {\n+                print_indented!(self, \"Tuple {\", depth_lvl);\n+                print_indented!(self, \"fields: [\", depth_lvl + 1);\n+                for field_id in fields.iter() {\n+                    self.print_expr(*field_id, depth_lvl + 2);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Adt(adt_expr) => {\n+                print_indented!(self, \"Adt {\", depth_lvl);\n+                self.print_adt_expr(&**adt_expr, depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            PlaceTypeAscription { source, user_ty } => {\n+                print_indented!(self, \"PlaceTypeAscription {\", depth_lvl);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ValueTypeAscription { source, user_ty } => {\n+                print_indented!(self, \"ValueTypeAscription {\", depth_lvl);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"source:\", depth_lvl + 1);\n+                self.print_expr(*source, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Closure(closure_expr) => {\n+                print_indented!(self, \"Closure {\", depth_lvl);\n+                print_indented!(self, \"closure_expr:\", depth_lvl + 1);\n+                self.print_closure_expr(&**closure_expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Literal { lit, neg } => {\n+                print_indented!(\n+                    self,\n+                    format!(\"Literal( lit: {:?}, neg: {:?})\\n\", lit, neg),\n+                    depth_lvl\n+                );\n+            }\n+            NonHirLiteral { lit, user_ty } => {\n+                print_indented!(self, \"NonHirLiteral {\", depth_lvl);\n+                print_indented!(self, format!(\"lit: {:?}\", lit), depth_lvl + 1);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ZstLiteral { user_ty } => {\n+                print_indented!(self, format!(\"ZstLiteral(user_ty: {:?})\", user_ty), depth_lvl);\n+            }\n+            NamedConst { def_id, substs, user_ty } => {\n+                print_indented!(self, \"NamedConst {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"user_ty: {:?}\", user_ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ConstParam { param, def_id } => {\n+                print_indented!(self, \"ConstParam {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"param: {:?}\", param), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            StaticRef { alloc_id, ty, def_id } => {\n+                print_indented!(self, \"StaticRef {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+                print_indented!(self, format!(\"alloc_id: {:?}\", alloc_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            InlineAsm(expr) => {\n+                print_indented!(self, \"InlineAsm {\", depth_lvl);\n+                print_indented!(self, \"expr:\", depth_lvl + 1);\n+                self.print_inline_asm_expr(&**expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            ThreadLocalRef(def_id) => {\n+                print_indented!(self, \"ThreadLocalRef {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+            Yield { value } => {\n+                print_indented!(self, \"Yield {\", depth_lvl);\n+                print_indented!(self, \"value:\", depth_lvl + 1);\n+                self.print_expr(*value, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl);\n+            }\n+        }\n+    }\n+\n+    fn print_adt_expr(&mut self, adt_expr: &AdtExpr<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"adt_def:\", depth_lvl);\n+        self.print_adt_def(adt_expr.adt_def, depth_lvl + 1);\n+        print_indented!(\n+            self,\n+            format!(\"variant_index: {:?}\", adt_expr.variant_index),\n+            depth_lvl + 1\n+        );\n+        print_indented!(self, format!(\"substs: {:?}\", adt_expr.substs), depth_lvl + 1);\n+        print_indented!(self, format!(\"user_ty: {:?}\", adt_expr.user_ty), depth_lvl + 1);\n+\n+        for (i, field_expr) in adt_expr.fields.iter().enumerate() {\n+            print_indented!(self, format!(\"field {}:\", i), depth_lvl + 1);\n+            self.print_expr(field_expr.expr, depth_lvl + 2);\n+        }\n+\n+        if let Some(ref base) = adt_expr.base {\n+            print_indented!(self, \"base:\", depth_lvl + 1);\n+            self.print_fru_info(base, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"base: None\", depth_lvl + 1);\n+        }\n+    }\n+\n+    fn print_adt_def(&mut self, adt_def: ty::AdtDef<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"AdtDef {\", depth_lvl);\n+        print_indented!(self, format!(\"did: {:?}\", adt_def.did()), depth_lvl + 1);\n+        print_indented!(self, format!(\"variants: {:?}\", adt_def.variants()), depth_lvl + 1);\n+        print_indented!(self, format!(\"flags: {:?}\", adt_def.flags()), depth_lvl + 1);\n+        print_indented!(self, format!(\"repr: {:?}\", adt_def.repr()), depth_lvl + 1);\n+    }\n+\n+    fn print_fru_info(&mut self, fru_info: &FruInfo<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"FruInfo {\", depth_lvl);\n+        print_indented!(self, \"base: \", depth_lvl + 1);\n+        self.print_expr(fru_info.base, depth_lvl + 2);\n+        print_indented!(self, \"field_types: [\", depth_lvl + 1);\n+        for ty in fru_info.field_types.iter() {\n+            print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 2);\n+        }\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_arm(&mut self, arm_id: ArmId, depth_lvl: usize) {\n+        print_indented!(self, \"Arm {\", depth_lvl);\n+\n+        let arm = &self.thir.arms[arm_id];\n+        let Arm { pattern, guard, body, lint_level, scope, span } = arm;\n+\n+        print_indented!(self, \"pattern: \", depth_lvl + 1);\n+        self.print_pat(pattern, depth_lvl + 2);\n+\n+        if let Some(guard) = guard {\n+            print_indented!(self, \"guard: \", depth_lvl + 1);\n+            self.print_guard(guard, depth_lvl + 2);\n+        } else {\n+            print_indented!(self, \"guard: None\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"body: \", depth_lvl + 1);\n+        self.print_expr(*body, depth_lvl + 2);\n+        print_indented!(self, format!(\"lint_level: {:?}\", lint_level), depth_lvl + 1);\n+        print_indented!(self, format!(\"scope: {:?}\", scope), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_pat(&mut self, pat: &Box<Pat<'tcx>>, depth_lvl: usize) {\n+        let Pat { ty, span, kind } = &**pat;\n+\n+        print_indented!(self, \"Pat: {\", depth_lvl);\n+        print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 1);\n+        print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+        self.print_pat_kind(kind, depth_lvl + 1);\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_pat_kind(&mut self, pat_kind: &PatKind<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"kind: PatKind {\", depth_lvl);\n+\n+        match pat_kind {\n+            PatKind::Wild => {\n+                print_indented!(self, \"Wild\", depth_lvl + 1);\n+            }\n+            PatKind::AscribeUserType { ascription, subpattern } => {\n+                print_indented!(self, \"AscribeUserType: {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"ascription: {:?}\", ascription), depth_lvl + 2);\n+                print_indented!(self, \"subpattern: \", depth_lvl + 2);\n+                self.print_pat(subpattern, depth_lvl + 3);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Binding { mutability, name, mode, var, ty, subpattern, is_primary } => {\n+                print_indented!(self, \"Binding {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"mutability: {:?}\", mutability), depth_lvl + 2);\n+                print_indented!(self, format!(\"name: {:?}\", name), depth_lvl + 2);\n+                print_indented!(self, format!(\"mode: {:?}\", mode), depth_lvl + 2);\n+                print_indented!(self, format!(\"var: {:?}\", var), depth_lvl + 2);\n+                print_indented!(self, format!(\"ty: {:?}\", ty), depth_lvl + 2);\n+                print_indented!(self, format!(\"is_primary: {:?}\", is_primary), depth_lvl + 2);\n+\n+                if let Some(subpattern) = subpattern {\n+                    print_indented!(self, \"subpattern: Some( \", depth_lvl + 2);\n+                    self.print_pat(subpattern, depth_lvl + 3);\n+                    print_indented!(self, \")\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"subpattern: None\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Variant { adt_def, substs, variant_index, subpatterns } => {\n+                print_indented!(self, \"Variant {\", depth_lvl + 1);\n+                print_indented!(self, \"adt_def: \", depth_lvl + 2);\n+                self.print_adt_def(*adt_def, depth_lvl + 3);\n+                print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 2);\n+                print_indented!(self, format!(\"variant_index: {:?}\", variant_index), depth_lvl + 2);\n+\n+                if subpatterns.len() > 0 {\n+                    print_indented!(self, \"subpatterns: [\", depth_lvl + 2);\n+                    for field_pat in subpatterns.iter() {\n+                        self.print_pat(&field_pat.pattern, depth_lvl + 3);\n+                    }\n+                    print_indented!(self, \"]\", depth_lvl + 2);\n+                } else {\n+                    print_indented!(self, \"subpatterns: []\", depth_lvl + 2);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Leaf { subpatterns } => {\n+                print_indented!(self, \"Leaf { \", depth_lvl + 1);\n+                print_indented!(self, \"subpatterns: [\", depth_lvl + 2);\n+                for field_pat in subpatterns.iter() {\n+                    self.print_pat(&field_pat.pattern, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Deref { subpattern } => {\n+                print_indented!(self, \"Deref { \", depth_lvl + 1);\n+                print_indented!(self, \"subpattern: \", depth_lvl + 2);\n+                self.print_pat(subpattern, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Constant { value } => {\n+                print_indented!(self, \"Constant {\", depth_lvl + 1);\n+                print_indented!(self, format!(\"value: {:?}\", value), depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Range(pat_range) => {\n+                print_indented!(self, format!(\"Range ( {:?} )\", pat_range), depth_lvl + 1);\n+            }\n+            PatKind::Slice { prefix, slice, suffix } => {\n+                print_indented!(self, \"Slice {\", depth_lvl + 1);\n+\n+                print_indented!(self, \"prefix: [\", depth_lvl + 2);\n+                for prefix_pat in prefix.iter() {\n+                    self.print_pat(prefix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                if let Some(slice) = slice {\n+                    print_indented!(self, \"slice: \", depth_lvl + 2);\n+                    self.print_pat(slice, depth_lvl + 3);\n+                }\n+\n+                print_indented!(self, \"suffix: [\", depth_lvl + 2);\n+                for suffix_pat in suffix.iter() {\n+                    self.print_pat(suffix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Array { prefix, slice, suffix } => {\n+                print_indented!(self, \"Array {\", depth_lvl + 1);\n+\n+                print_indented!(self, \"prefix: [\", depth_lvl + 2);\n+                for prefix_pat in prefix.iter() {\n+                    self.print_pat(prefix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                if let Some(slice) = slice {\n+                    print_indented!(self, \"slice: \", depth_lvl + 2);\n+                    self.print_pat(slice, depth_lvl + 3);\n+                }\n+\n+                print_indented!(self, \"suffix: [\", depth_lvl + 2);\n+                for suffix_pat in suffix.iter() {\n+                    self.print_pat(suffix_pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            PatKind::Or { pats } => {\n+                print_indented!(self, \"Or {\", depth_lvl + 1);\n+                print_indented!(self, \"pats: [\", depth_lvl + 2);\n+                for pat in pats.iter() {\n+                    self.print_pat(pat, depth_lvl + 3);\n+                }\n+                print_indented!(self, \"]\", depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_guard(&mut self, guard: &Guard<'tcx>, depth_lvl: usize) {\n+        print_indented!(self, \"Guard {\", depth_lvl);\n+\n+        match guard {\n+            Guard::If(expr_id) => {\n+                print_indented!(self, \"If (\", depth_lvl + 1);\n+                self.print_expr(*expr_id, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl + 1);\n+            }\n+            Guard::IfLet(pat, expr_id) => {\n+                print_indented!(self, \"IfLet (\", depth_lvl + 1);\n+                self.print_pat(pat, depth_lvl + 2);\n+                print_indented!(self, \",\", depth_lvl + 1);\n+                self.print_expr(*expr_id, depth_lvl + 2);\n+                print_indented!(self, \")\", depth_lvl + 1);\n+            }\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_closure_expr(&mut self, expr: &ClosureExpr<'tcx>, depth_lvl: usize) {\n+        let ClosureExpr { closure_id, substs, upvars, movability, fake_reads } = expr;\n+\n+        print_indented!(self, \"ClosureExpr {\", depth_lvl);\n+        print_indented!(self, format!(\"closure_id: {:?}\", closure_id), depth_lvl + 1);\n+        print_indented!(self, format!(\"substs: {:?}\", substs), depth_lvl + 1);\n+\n+        if upvars.len() > 0 {\n+            print_indented!(self, \"upvars: [\", depth_lvl + 1);\n+            for upvar in upvars.iter() {\n+                self.print_expr(*upvar, depth_lvl + 2);\n+                print_indented!(self, \",\", depth_lvl + 1);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"upvars: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, format!(\"movability: {:?}\", movability), depth_lvl + 1);\n+\n+        if fake_reads.len() > 0 {\n+            print_indented!(self, \"fake_reads: [\", depth_lvl + 1);\n+            for (fake_read_expr, cause, hir_id) in fake_reads.iter() {\n+                print_indented!(self, \"(\", depth_lvl + 2);\n+                self.print_expr(*fake_read_expr, depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+                print_indented!(self, format!(\"cause: {:?}\", cause), depth_lvl + 3);\n+                print_indented!(self, \",\", depth_lvl + 2);\n+                print_indented!(self, format!(\"hir_id: {:?}\", hir_id), depth_lvl + 3);\n+                print_indented!(self, \"),\", depth_lvl + 2);\n+            }\n+            print_indented!(self, \"]\", depth_lvl + 1);\n+        } else {\n+            print_indented!(self, \"fake_reads: []\", depth_lvl + 1);\n+        }\n+\n+        print_indented!(self, \"}\", depth_lvl);\n+    }\n+\n+    fn print_inline_asm_expr(&mut self, expr: &InlineAsmExpr<'tcx>, depth_lvl: usize) {\n+        let InlineAsmExpr { template, operands, options, line_spans } = expr;\n+\n+        print_indented!(self, \"InlineAsmExpr {\", depth_lvl);\n+\n+        print_indented!(self, \"template: [\", depth_lvl + 1);\n+        for template_piece in template.iter() {\n+            print_indented!(self, format!(\"{:?}\", template_piece), depth_lvl + 2);\n+        }\n+        print_indented!(self, \"]\", depth_lvl + 1);\n+\n+        print_indented!(self, \"operands: [\", depth_lvl + 1);\n+        for operand in operands.iter() {\n+            self.print_inline_operand(operand, depth_lvl + 2);\n+        }\n+        print_indented!(self, \"]\", depth_lvl + 1);\n+\n+        print_indented!(self, format!(\"options: {:?}\", options), depth_lvl + 1);\n+        print_indented!(self, format!(\"line_spans: {:?}\", line_spans), depth_lvl + 1);\n+    }\n+\n+    fn print_inline_operand(&mut self, operand: &InlineAsmOperand<'tcx>, depth_lvl: usize) {\n+        match operand {\n+            InlineAsmOperand::In { reg, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::In {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, \"expr: \", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::Out { reg, late, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::Out {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+\n+                if let Some(out) = expr {\n+                    print_indented!(self, \"place: Some( \", depth_lvl + 1);\n+                    self.print_expr(*out, depth_lvl + 2);\n+                    print_indented!(self, \")\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"place: None\", depth_lvl + 1);\n+                }\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::InOut { reg, late, expr } => {\n+                print_indented!(self, \"InlineAsmOperand::InOut {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+                print_indented!(self, \"expr: \", depth_lvl + 1);\n+                self.print_expr(*expr, depth_lvl + 2);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                print_indented!(self, \"InlineAsmOperand::SplitInOut {\", depth_lvl);\n+                print_indented!(self, format!(\"reg: {:?}\", reg), depth_lvl + 1);\n+                print_indented!(self, format!(\"late: {:?}\", late), depth_lvl + 1);\n+                print_indented!(self, \"in_expr: \", depth_lvl + 1);\n+                self.print_expr(*in_expr, depth_lvl + 2);\n+\n+                if let Some(out_expr) = out_expr {\n+                    print_indented!(self, \"out_expr: Some( \", depth_lvl + 1);\n+                    self.print_expr(*out_expr, depth_lvl + 2);\n+                    print_indented!(self, \")\", depth_lvl + 1);\n+                } else {\n+                    print_indented!(self, \"out_expr: None\", depth_lvl + 1);\n+                }\n+\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::Const { value, span } => {\n+                print_indented!(self, \"InlineAsmOperand::Const {\", depth_lvl);\n+                print_indented!(self, format!(\"value: {:?}\", value), depth_lvl + 1);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SymFn { value, span } => {\n+                print_indented!(self, \"InlineAsmOperand::SymFn {\", depth_lvl);\n+                print_indented!(self, format!(\"value: {:?}\", *value), depth_lvl + 1);\n+                print_indented!(self, format!(\"span: {:?}\", span), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+            InlineAsmOperand::SymStatic { def_id } => {\n+                print_indented!(self, \"InlineAsmOperand::SymStatic {\", depth_lvl);\n+                print_indented!(self, format!(\"def_id: {:?}\", def_id), depth_lvl + 1);\n+                print_indented!(self, \"}\", depth_lvl + 1);\n+            }\n+        }\n+    }\n+}"}, {"sha": "cf3dce48064923a0b582c25ca028827c673eecdf", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -18,7 +18,8 @@ use crate::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n+use rustc_span::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n@@ -36,7 +37,7 @@ pub use self::chalk::{ChalkEnvironmentAndGoal, RustInterner as ChalkRustInterner\n \n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable, Encodable, Decodable)]\n pub enum Reveal {\n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types\n@@ -89,7 +90,8 @@ pub enum Reveal {\n ///\n /// We do not want to intern this as there are a lot of obligation causes which\n /// only live for a short period of time.\n-#[derive(Clone, Debug, PartialEq, Eq, Lift)]\n+#[derive(Clone, Debug, PartialEq, Eq, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n@@ -99,7 +101,7 @@ pub struct ObligationCause<'tcx> {\n     /// (in particular, closures can add new assumptions). See the\n     /// field `region_obligations` of the `FulfillmentContext` for more\n     /// information.\n-    pub body_id: hir::HirId,\n+    pub body_id: LocalDefId,\n \n     code: InternedObligationCauseCode<'tcx>,\n }\n@@ -120,13 +122,13 @@ impl<'tcx> ObligationCause<'tcx> {\n     #[inline]\n     pub fn new(\n         span: Span,\n-        body_id: hir::HirId,\n+        body_id: LocalDefId,\n         code: ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {\n         ObligationCause { span, body_id, code: code.into() }\n     }\n \n-    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+    pub fn misc(span: Span, body_id: LocalDefId) -> ObligationCause<'tcx> {\n         ObligationCause::new(span, body_id, MiscObligation)\n     }\n \n@@ -137,7 +139,7 @@ impl<'tcx> ObligationCause<'tcx> {\n \n     #[inline(always)]\n     pub fn dummy_with_span(span: Span) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id: hir::CRATE_HIR_ID, code: Default::default() }\n+        ObligationCause { span, body_id: CRATE_DEF_ID, code: Default::default() }\n     }\n \n     pub fn span(&self) -> Span {\n@@ -196,14 +198,16 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub struct UnifyReceiverContext<'tcx> {\n     pub assoc_item: ty::AssocItem,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Lift, Default)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift, Default, HashStable)]\n+#[derive(TypeVisitable, TypeFoldable, TyEncodable, TyDecodable)]\n pub struct InternedObligationCauseCode<'tcx> {\n     /// `None` for `ObligationCauseCode::MiscObligation` (a common case, occurs ~60% of\n     /// the time). `Some` otherwise.\n@@ -238,7 +242,8 @@ impl<'tcx> std::ops::Deref for InternedObligationCauseCode<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from the span.\n     MiscObligation,\n@@ -446,7 +451,8 @@ pub enum ObligationCauseCode<'tcx> {\n /// This information is used to obtain an `hir::Ty`, which\n /// we can walk in order to obtain precise spans for any\n /// 'nested' types (e.g. `Foo` in `Option<Foo>`).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable, Encodable, Decodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub enum WellFormedLoc {\n     /// Use the type of the provided definition.\n     Ty(LocalDefId),\n@@ -463,7 +469,8 @@ pub enum WellFormedLoc {\n     },\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n     pub impl_def_id: DefId,\n@@ -517,7 +524,8 @@ impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_block_id: Option<hir::HirId>,\n     pub arm_ty: Ty<'tcx>,\n@@ -533,7 +541,7 @@ pub struct MatchExpressionArmCause<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-#[derive(Lift, TypeFoldable, TypeVisitable)]\n+#[derive(Lift, TypeFoldable, TypeVisitable, HashStable, TyEncodable, TyDecodable)]\n pub struct IfExpressionCause<'tcx> {\n     pub then_id: hir::HirId,\n     pub else_id: hir::HirId,\n@@ -543,7 +551,8 @@ pub struct IfExpressionCause<'tcx> {\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, HashStable, TyEncodable, TyDecodable)]\n+#[derive(TypeVisitable, TypeFoldable)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait predicate of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to"}, {"sha": "099a784511827b2ffe69250ccf2155b7200f4765", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -188,7 +188,7 @@ impl<'tcx> AdtDef<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, HashStable, TyEncodable, TyDecodable)]\n pub enum AdtKind {\n     Struct,\n     Union,"}, {"sha": "71cecfb558fb282c48055ff139d96fb399c88a07", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -79,7 +79,7 @@ impl AssocItem {\n                 // late-bound regions, and we don't want method signatures to show up\n                 // `as for<'r> fn(&'r MyType)`. Pretty-printing handles late-bound\n                 // regions just fine, showing `fn(&MyType)`.\n-                tcx.fn_sig(self.def_id).skip_binder().to_string()\n+                tcx.fn_sig(self.def_id).subst_identity().skip_binder().to_string()\n             }\n             ty::AssocKind::Type => format!(\"type {};\", self.name),\n             ty::AssocKind::Const => {\n@@ -130,7 +130,7 @@ impl std::fmt::Display for AssocKind {\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n pub struct AssocItems<'tcx> {\n-    pub(super) items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n }\n \n impl<'tcx> AssocItems<'tcx> {"}, {"sha": "b9a1e23879cca7f9b407633698f06c8717f74401", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -157,6 +157,14 @@ impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AllocId {\n     }\n }\n \n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::ParamEnv<'tcx> {\n+    fn encode(&self, e: &mut E) {\n+        self.caller_bounds().encode(e);\n+        self.reveal().encode(e);\n+        self.constness().encode(e);\n+    }\n+}\n+\n #[inline]\n fn decode_arena_allocable<\n     'tcx,\n@@ -280,8 +288,17 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::SymbolName<'tcx>\n     }\n }\n \n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::ParamEnv<'tcx> {\n+    fn decode(d: &mut D) -> Self {\n+        let caller_bounds = Decodable::decode(d);\n+        let reveal = Decodable::decode(d);\n+        let constness = Decodable::decode(d);\n+        ty::ParamEnv::new(caller_bounds, reveal, constness)\n+    }\n+}\n+\n macro_rules! impl_decodable_via_ref {\n-    ($($t:ty),+) => {\n+    ($($t:ty,)+) => {\n         $(impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for $t {\n             fn decode(decoder: &mut D) -> Self {\n                 RefDecodable::decode(decoder)\n@@ -373,6 +390,15 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<ty\n     }\n }\n \n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<ty::Predicate<'tcx>> {\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        let len = decoder.read_usize();\n+        let predicates: Vec<_> =\n+            (0..len).map::<ty::Predicate<'tcx>, _>(|_| Decodable::decode(decoder)).collect();\n+        decoder.interner().intern_predicates(&predicates)\n+    }\n+}\n+\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n@@ -382,7 +408,8 @@ impl_decodable_via_ref! {\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n     &'tcx mir::coverage::CodeRegion,\n-    &'tcx ty::List<ty::BoundVariableKind>\n+    &'tcx ty::List<ty::BoundVariableKind>,\n+    &'tcx ty::List<ty::Predicate<'tcx>>,\n }\n \n #[macro_export]\n@@ -519,6 +546,8 @@ macro_rules! impl_binder_encode_decode {\n impl_binder_encode_decode! {\n     &'tcx ty::List<Ty<'tcx>>,\n     ty::FnSig<'tcx>,\n+    ty::Predicate<'tcx>,\n+    ty::TraitPredicate<'tcx>,\n     ty::ExistentialPredicate<'tcx>,\n     ty::TraitRef<'tcx>,\n     Vec<ty::GeneratorInteriorTypeCause<'tcx>>,"}, {"sha": "b63b9e754cf466a963adc68740971e5f6fa0e0ff", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 40, "deletions": 183, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -2,6 +2,8 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n+pub mod tls;\n+\n use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n@@ -75,6 +77,8 @@ use std::iter;\n use std::mem;\n use std::ops::{Bound, Deref};\n \n+const TINY_CONST_EVAL_LIMIT: Limit = Limit(20);\n+\n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n     fn new(sess: &'tcx Session, data: Mmap, start_pos: usize) -> Self\n@@ -997,6 +1001,30 @@ impl<'tcx> TyCtxt<'tcx> {\n         v.0\n     }\n \n+    /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type and associated alias span when type alias is used\n+    pub fn return_type_impl_or_dyn_traits_with_type_alias(\n+        self,\n+        scope_def_id: LocalDefId,\n+    ) -> Option<(Vec<&'tcx hir::Ty<'tcx>>, Span)> {\n+        let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n+        let mut v = TraitObjectVisitor(vec![], self.hir());\n+        // when the return type is a type alias\n+        if let Some(hir::FnDecl { output: hir::FnRetTy::Return(hir_output), .. }) = self.hir().fn_decl_by_hir_id(hir_id)\n+            && let hir::TyKind::Path(hir::QPath::Resolved(\n+                None,\n+                hir::Path { res: hir::def::Res::Def(DefKind::TyAlias, def_id), .. }, )) = hir_output.kind\n+            && let Some(local_id) = def_id.as_local()\n+            && let Some(alias_ty) = self.hir().get_by_def_id(local_id).alias_ty() // it is type alias\n+            && let Some(alias_generics) = self.hir().get_by_def_id(local_id).generics()\n+        {\n+            v.visit_ty(alias_ty);\n+            if !v.0.is_empty() {\n+                return Some((v.0, alias_generics.span));\n+            }\n+        }\n+        return None;\n+    }\n+\n     pub fn return_type_impl_trait(self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // `type_of()` will fail on these (#55796, #86483), so only allow `fn`s or closures.\n         match self.hir().get_by_def_id(scope_def_id) {\n@@ -1078,7 +1106,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn const_eval_limit(self) -> Limit {\n-        self.limits(()).const_eval_limit\n+        if self.sess.opts.unstable_opts.tiny_const_eval_limit {\n+            TINY_CONST_EVAL_LIMIT\n+        } else {\n+            self.limits(()).const_eval_limit\n+        }\n     }\n \n     pub fn all_traits(self) -> impl Iterator<Item = DefId> + 'tcx {\n@@ -1188,178 +1220,6 @@ CloneLiftImpls! { for<'tcx> {\n     Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n } }\n \n-pub mod tls {\n-    use super::{ptr_eq, GlobalCtxt, TyCtxt};\n-\n-    use crate::dep_graph::TaskDepsRef;\n-    use crate::ty::query;\n-    use rustc_data_structures::sync::{self, Lock};\n-    use rustc_errors::Diagnostic;\n-    use std::mem;\n-    use thin_vec::ThinVec;\n-\n-    #[cfg(not(parallel_compiler))]\n-    use std::cell::Cell;\n-\n-    #[cfg(parallel_compiler)]\n-    use rustc_rayon_core as rayon_core;\n-\n-    /// This is the implicit state of rustc. It contains the current\n-    /// `TyCtxt` and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a `TyCtxt` value available\n-    /// you should also have access to an `ImplicitCtxt` through the functions\n-    /// in this module.\n-    #[derive(Clone)]\n-    pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current `TyCtxt`.\n-        pub tcx: TyCtxt<'tcx>,\n-\n-        /// The current query job, if any. This is updated by `JobOwner::start` in\n-        /// `ty::query::plumbing` when executing a query.\n-        pub query: Option<query::QueryJobId>,\n-\n-        /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n-        pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n-\n-        /// Used to prevent queries from calling too deeply.\n-        pub query_depth: usize,\n-\n-        /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them.\n-        pub task_deps: TaskDepsRef<'a>,\n-    }\n-\n-    impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n-        pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n-            let tcx = TyCtxt { gcx };\n-            ImplicitCtxt {\n-                tcx,\n-                query: None,\n-                diagnostics: None,\n-                query_depth: 0,\n-                task_deps: TaskDepsRef::Ignore,\n-            }\n-        }\n-    }\n-\n-    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n-    /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        rayon_core::tlv::with(value, f)\n-    }\n-\n-    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current `ImplicitCtxt`.\n-    #[cfg(parallel_compiler)]\n-    #[inline]\n-    pub fn get_tlv() -> usize {\n-        rayon_core::tlv::get()\n-    }\n-\n-    #[cfg(not(parallel_compiler))]\n-    thread_local! {\n-        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n-        static TLV: Cell<usize> = const { Cell::new(0) };\n-    }\n-\n-    /// Sets TLV to `value` during the call to `f`.\n-    /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n-        let old = get_tlv();\n-        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n-        TLV.with(|tlv| tlv.set(value));\n-        f()\n-    }\n-\n-    /// Gets the pointer to the current `ImplicitCtxt`.\n-    #[cfg(not(parallel_compiler))]\n-    #[inline]\n-    fn get_tlv() -> usize {\n-        TLV.with(|tlv| tlv.get())\n-    }\n-\n-    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n-    #[inline]\n-    pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        set_tlv(context as *const _ as usize, || f(&context))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n-    #[inline]\n-    pub fn with_context_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n-    {\n-        let context = get_tlv();\n-        if context == 0 {\n-            f(None)\n-        } else {\n-            // We could get an `ImplicitCtxt` pointer from another thread.\n-            // Ensure that `ImplicitCtxt` is `Sync`.\n-            sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n-\n-            unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n-        }\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_context<F, R>(f: F) -> R\n-    where\n-        F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n-    }\n-\n-    /// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n-    /// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n-    /// as the `TyCtxt` passed in.\n-    /// This will panic if you pass it a `TyCtxt` which is different from the current\n-    /// `ImplicitCtxt`'s `tcx` field.\n-    #[inline]\n-    pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n-    where\n-        F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n-    {\n-        with_context(|context| unsafe {\n-            assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-            let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n-            f(context)\n-        })\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// Panics if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n-    {\n-        with_context(|context| f(context.tcx))\n-    }\n-\n-    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n-    /// The closure is passed None if there is no `ImplicitCtxt` available.\n-    #[inline]\n-    pub fn with_opt<F, R>(f: F) -> R\n-    where\n-        F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n-    {\n-        with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n-    }\n-}\n-\n macro_rules! sty_debug_print {\n     ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as\n@@ -1452,6 +1312,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     Placeholder,\n                     Generator,\n                     GeneratorWitness,\n+                    GeneratorWitnessMIR,\n                     Dynamic,\n                     Closure,\n                     Tuple,\n@@ -1961,6 +1822,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_mut_ref(self.lifetimes.re_erased, context_ty)\n     }\n \n+    #[inline]\n+    pub fn mk_generator_witness_mir(self, id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(GeneratorWitnessMIR(id, substs))\n+    }\n+\n     #[inline]\n     pub fn mk_ty_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_ty_infer(TyVar(v))\n@@ -2297,10 +2163,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner.def_id).map_or(false, |set| {\n-            let def_id = self.hir().local_def_id(id);\n-            set.contains(&def_id)\n-        })\n+        self.is_late_bound_map(id.owner).map_or(false, |set| set.contains(&id.local_id))\n     }\n \n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n@@ -2392,12 +2255,6 @@ pub struct DeducedParamAttrs {\n     pub read_only: bool,\n }\n \n-// We are comparing types with different invariant lifetimes, so `ptr::eq`\n-// won't work for us.\n-fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n-    t as *const () == u as *const ()\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);"}, {"sha": "71b025dc1be4b6523d343cdc3269508141a92560", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,187 @@\n+use super::{GlobalCtxt, TyCtxt};\n+\n+use crate::dep_graph::TaskDepsRef;\n+use crate::ty::query;\n+use rustc_data_structures::sync::{self, Lock};\n+use rustc_errors::Diagnostic;\n+use std::mem;\n+use std::ptr;\n+use thin_vec::ThinVec;\n+\n+/// This is the implicit state of rustc. It contains the current\n+/// `TyCtxt` and query. It is updated when creating a local interner or\n+/// executing a new query. Whenever there's a `TyCtxt` value available\n+/// you should also have access to an `ImplicitCtxt` through the functions\n+/// in this module.\n+#[derive(Clone)]\n+pub struct ImplicitCtxt<'a, 'tcx> {\n+    /// The current `TyCtxt`.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// The current query job, if any. This is updated by `JobOwner::start` in\n+    /// `ty::query::plumbing` when executing a query.\n+    pub query: Option<query::QueryJobId>,\n+\n+    /// Where to store diagnostics for the current query job, if any.\n+    /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n+    pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n+\n+    /// Used to prevent queries from calling too deeply.\n+    pub query_depth: usize,\n+\n+    /// The current dep graph task. This is used to add dependencies to queries\n+    /// when executing them.\n+    pub task_deps: TaskDepsRef<'a>,\n+}\n+\n+impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n+    pub fn new(gcx: &'tcx GlobalCtxt<'tcx>) -> Self {\n+        let tcx = TyCtxt { gcx };\n+        ImplicitCtxt {\n+            tcx,\n+            query: None,\n+            diagnostics: None,\n+            query_depth: 0,\n+            task_deps: TaskDepsRef::Ignore,\n+        }\n+    }\n+}\n+\n+#[cfg(parallel_compiler)]\n+mod tlv {\n+    use rustc_rayon_core as rayon_core;\n+    use std::ptr;\n+\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn get_tlv() -> *const () {\n+        ptr::from_exposed_addr(rayon_core::tlv::get())\n+    }\n+\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n+    /// to `value` during the call to `f`. It is restored to its previous value after.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n+        rayon_core::tlv::with(value.expose_addr(), f)\n+    }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+mod tlv {\n+    use std::cell::Cell;\n+    use std::ptr;\n+\n+    thread_local! {\n+        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n+        static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n+    }\n+\n+    /// Gets the pointer to the current `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn get_tlv() -> *const () {\n+        TLV.with(|tlv| tlv.get())\n+    }\n+\n+    /// Sets TLV to `value` during the call to `f`.\n+    /// It is restored to its previous value after.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n+    #[inline]\n+    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n+        let old = get_tlv();\n+        let _reset = rustc_data_structures::OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n+        TLV.with(|tlv| tlv.set(value));\n+        f()\n+    }\n+}\n+\n+#[inline]\n+fn erase(context: &ImplicitCtxt<'_, '_>) -> *const () {\n+    context as *const _ as *const ()\n+}\n+\n+#[inline]\n+unsafe fn downcast<'a, 'tcx>(context: *const ()) -> &'a ImplicitCtxt<'a, 'tcx> {\n+    &*(context as *const ImplicitCtxt<'a, 'tcx>)\n+}\n+\n+/// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n+#[inline]\n+pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    tlv::with_tlv(erase(context), || f(&context))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n+#[inline]\n+pub fn with_context_opt<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n+{\n+    let context = tlv::get_tlv();\n+    if context.is_null() {\n+        f(None)\n+    } else {\n+        // We could get an `ImplicitCtxt` pointer from another thread.\n+        // Ensure that `ImplicitCtxt` is `Sync`.\n+        sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n+\n+        unsafe { f(Some(downcast(context))) }\n+    }\n+}\n+\n+/// Allows access to the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_context<F, R>(f: F) -> R\n+where\n+    F: for<'a, 'tcx> FnOnce(&ImplicitCtxt<'a, 'tcx>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+}\n+\n+/// Allows access to the current `ImplicitCtxt` whose tcx field is the same as the tcx argument\n+/// passed in. This means the closure is given an `ImplicitCtxt` with the same `'tcx` lifetime\n+/// as the `TyCtxt` passed in.\n+/// This will panic if you pass it a `TyCtxt` which is different from the current\n+/// `ImplicitCtxt`'s `tcx` field.\n+#[inline]\n+pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n+where\n+    F: FnOnce(&ImplicitCtxt<'_, 'tcx>) -> R,\n+{\n+    with_context(|context| {\n+        // The two gcx have different invariant lifetimes, so we need to erase them for the comparison.\n+        assert!(ptr::eq(\n+            context.tcx.gcx as *const _ as *const (),\n+            tcx.gcx as *const _ as *const ()\n+        ));\n+\n+        let context: &ImplicitCtxt<'_, '_> = unsafe { mem::transmute(context) };\n+\n+        f(context)\n+    })\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// Panics if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n+{\n+    with_context(|context| f(context.tcx))\n+}\n+\n+/// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+/// The closure is passed None if there is no `ImplicitCtxt` available.\n+#[inline]\n+pub fn with_opt<F, R>(f: F) -> R\n+where\n+    F: for<'tcx> FnOnce(Option<TyCtxt<'tcx>>) -> R,\n+{\n+    with_context_opt(|opt_context| f(opt_context.map(|context| context.tcx)))\n+}"}, {"sha": "d83fc95ac4eeb04995110044354443608befb283", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 8, "deletions": 634, "changes": 642, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,24 +1,18 @@\n-use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty::diagnostics::suggest_constraining_type_param;\n-use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, Printer};\n+use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, PrettyPrinter};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n-use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n-use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n+use rustc_errors::pluralize;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::Symbol;\n use rustc_target::spec::abi;\n-\n use std::borrow::Cow;\n use std::collections::hash_map::DefaultHasher;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+use std::hash::Hasher;\n use std::path::PathBuf;\n \n-use super::print::PrettyPrinter;\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExpectedFound<T> {\n     pub expected: T,\n@@ -331,7 +325,8 @@ impl<'tcx> Ty<'tcx> {\n             ty::Dynamic(..) => \"trait object\".into(),\n             ty::Closure(..) => \"closure\".into(),\n             ty::Generator(def_id, ..) => tcx.generator_kind(def_id).unwrap().descr().into(),\n-            ty::GeneratorWitness(..) => \"generator witness\".into(),\n+            ty::GeneratorWitness(..) |\n+            ty::GeneratorWitnessMIR(..) => \"generator witness\".into(),\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Infer(ty::TyVar(_)) => \"inferred type\".into(),\n             ty::Infer(ty::IntVar(_)) => \"integer\".into(),\n@@ -379,7 +374,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Dynamic(..) => \"trait object\".into(),\n             ty::Closure(..) => \"closure\".into(),\n             ty::Generator(def_id, ..) => tcx.generator_kind(def_id).unwrap().descr().into(),\n-            ty::GeneratorWitness(..) => \"generator witness\".into(),\n+            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) => \"generator witness\".into(),\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n@@ -391,620 +386,6 @@ impl<'tcx> Ty<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(\n-        self,\n-        diag: &mut Diagnostic,\n-        err: TypeError<'tcx>,\n-        cause: &ObligationCause<'tcx>,\n-        sp: Span,\n-        body_owner_def_id: DefId,\n-    ) {\n-        use self::TypeError::*;\n-        debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n-        match err {\n-            ArgumentSorts(values, _) | Sorts(values) => {\n-                match (values.expected.kind(), values.found.kind()) {\n-                    (ty::Closure(..), ty::Closure(..)) => {\n-                        diag.note(\"no two closures, even if identical, have the same type\");\n-                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n-                    }\n-                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n-                        // Issue #63167\n-                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n-                    }\n-                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n-                        if let Ok(\n-                            // Issue #53280\n-                            snippet,\n-                        ) = self.sess.source_map().span_to_snippet(sp) =>\n-                    {\n-                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                            diag.span_suggestion(\n-                                sp,\n-                                \"use a float literal\",\n-                                format!(\"{}.0\", snippet),\n-                                MachineApplicable,\n-                            );\n-                        }\n-                    }\n-                    (ty::Param(expected), ty::Param(found)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let e_span = self.def_span(generics.type_param(expected, self).def_id);\n-                        if !sp.contains(e_span) {\n-                            diag.span_label(e_span, \"expected type parameter\");\n-                        }\n-                        let f_span = self.def_span(generics.type_param(found, self).def_id);\n-                        if !sp.contains(f_span) {\n-                            diag.span_label(f_span, \"found type parameter\");\n-                        }\n-                        diag.note(\n-                            \"a type parameter was expected, but a different one was found; \\\n-                             you might be missing a type parameter or trait bound\",\n-                        );\n-                        diag.note(\n-                            \"for more information, visit \\\n-                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                             #traits-as-parameters\",\n-                        );\n-                    }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n-                        diag.note(\"an associated type was expected, but a different one was found\");\n-                    }\n-                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n-                        if self.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n-                    {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        let hir = self.hir();\n-                        let mut note = true;\n-                        if let Some(generics) = generics\n-                            .type_param(p, self)\n-                            .def_id\n-                            .as_local()\n-                            .map(|id| hir.local_def_id_to_hir_id(id))\n-                            .and_then(|id| self.hir().find_parent(id))\n-                            .as_ref()\n-                            .and_then(|node| node.generics())\n-                        {\n-                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n-                            // FIXME: extract this logic for use in other diagnostics.\n-                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n-                            let path =\n-                                self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n-                            let item_name = self.item_name(proj.def_id);\n-                            let item_args = self.format_generic_args(assoc_substs);\n-\n-                            let path = if path.ends_with('>') {\n-                                format!(\n-                                    \"{}, {}{} = {}>\",\n-                                    &path[..path.len() - 1],\n-                                    item_name,\n-                                    item_args,\n-                                    p\n-                                )\n-                            } else {\n-                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n-                            };\n-                            note = !suggest_constraining_type_param(\n-                                self,\n-                                generics,\n-                                diag,\n-                                &format!(\"{}\", proj.self_ty()),\n-                                &path,\n-                                None,\n-                            );\n-                        }\n-                        if note {\n-                            diag.note(\"you might be missing a type parameter or trait bound\");\n-                        }\n-                    }\n-                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n-                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        diag.help(\"type parameters must be constrained to match other types\");\n-                        if self.sess.teach(&diag.get_code().unwrap()) {\n-                            diag.help(\n-                                \"given a type parameter `T` and a method `foo`:\n-```\n-trait Trait<T> { fn foo(&self) -> T; }\n-```\n-the only ways to implement method `foo` are:\n-- constrain `T` with an explicit type:\n-```\n-impl Trait<String> for X {\n-    fn foo(&self) -> String { String::new() }\n-}\n-```\n-- add a trait bound to `T` and call a method on that trait that returns `Self`:\n-```\n-impl<T: std::default::Default> Trait<T> for X {\n-    fn foo(&self) -> T { <T as std::default::Default>::default() }\n-}\n-```\n-- change `foo` to return an argument of type `T`:\n-```\n-impl<T> Trait<T> for X {\n-    fn foo(&self, x: T) -> T { x }\n-}\n-```\",\n-                            );\n-                        }\n-                        diag.note(\n-                            \"for more information, visit \\\n-                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                             #traits-as-parameters\",\n-                        );\n-                    }\n-                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        diag.help(&format!(\n-                            \"every closure has a distinct type and so could not always match the \\\n-                             caller-chosen type of parameter `{}`\",\n-                            p\n-                        ));\n-                    }\n-                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                    }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n-                        self.expected_projection(\n-                            diag,\n-                            proj_ty,\n-                            values,\n-                            body_owner_def_id,\n-                            cause.code(),\n-                        );\n-                    }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n-                        let msg = format!(\n-                            \"consider constraining the associated type `{}` to `{}`\",\n-                            values.found, values.expected,\n-                        );\n-                        if !(self.suggest_constraining_opaque_associated_type(\n-                            diag,\n-                            &msg,\n-                            proj_ty,\n-                            values.expected,\n-                        ) || self.suggest_constraint(\n-                            diag,\n-                            &msg,\n-                            body_owner_def_id,\n-                            proj_ty,\n-                            values.expected,\n-                        )) {\n-                            diag.help(&msg);\n-                            diag.note(\n-                                \"for more information, visit \\\n-                                https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n-                            );\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-                debug!(\n-                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n-                    values.expected,\n-                    values.expected.kind(),\n-                    values.found,\n-                    values.found.kind(),\n-                );\n-            }\n-            CyclicTy(ty) => {\n-                // Watch out for various cases of cyclic types and try to explain.\n-                if ty.is_closure() || ty.is_generator() {\n-                    diag.note(\n-                        \"closures cannot capture themselves or take themselves as argument;\\n\\\n-                         this error may be the result of a recent compiler bug-fix,\\n\\\n-                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n-                         for more information\",\n-                    );\n-                }\n-            }\n-            TargetFeatureCast(def_id) => {\n-                let target_spans =\n-                    self.get_attrs(def_id, sym::target_feature).map(|attr| attr.span);\n-                diag.note(\n-                    \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n-                );\n-                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn suggest_constraint(\n-        self,\n-        diag: &mut Diagnostic,\n-        msg: &str,\n-        body_owner_def_id: DefId,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n-        if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n-            if let Some(hir_generics) = item.generics() {\n-                // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n-                // This will also work for `impl Trait`.\n-                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n-                    let generics = self.generics_of(body_owner_def_id);\n-                    generics.type_param(param_ty, self).def_id\n-                } else {\n-                    return false;\n-                };\n-                let Some(def_id) = def_id.as_local() else {\n-                    return false;\n-                };\n-\n-                // First look in the `where` clause, as this might be\n-                // `fn foo<T>(x: T) where T: Trait`.\n-                for pred in hir_generics.bounds_for_param(def_id) {\n-                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                        diag,\n-                        &trait_ref,\n-                        pred.bounds,\n-                        &assoc,\n-                        assoc_substs,\n-                        ty,\n-                        msg,\n-                        false,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n-    /// An associated type was expected and a different type was found.\n-    ///\n-    /// We perform a few different checks to see what we can suggest:\n-    ///\n-    ///  - In the current item, look for associated functions that return the expected type and\n-    ///    suggest calling them. (Not a structured suggestion.)\n-    ///  - If any of the item's generic bounds can be constrained, we suggest constraining the\n-    ///    associated type to the found type.\n-    ///  - If the associated type has a default type and was expected inside of a `trait`, we\n-    ///    mention that this is disallowed.\n-    ///  - If all other things fail, and the error is not because of a mismatch between the `trait`\n-    ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n-    ///    fn that returns the type.\n-    fn expected_projection(\n-        self,\n-        diag: &mut Diagnostic,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        values: ExpectedFound<Ty<'tcx>>,\n-        body_owner_def_id: DefId,\n-        cause_code: &ObligationCauseCode<'_>,\n-    ) {\n-        let msg = format!(\n-            \"consider constraining the associated type `{}` to `{}`\",\n-            values.expected, values.found\n-        );\n-        let body_owner = self.hir().get_if_local(body_owner_def_id);\n-        let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n-\n-        // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n-        let callable_scope = matches!(\n-            body_owner,\n-            Some(\n-                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                    | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n-                    | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n-            )\n-        );\n-        let impl_comparison =\n-            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        if !callable_scope || impl_comparison {\n-            // We do not want to suggest calling functions when the reason of the\n-            // type error is a comparison of an `impl` with its `trait` or when the\n-            // scope is outside of a `Body`.\n-        } else {\n-            // If we find a suitable associated function that returns the expected type, we don't\n-            // want the more general suggestion later in this method about \"consider constraining\n-            // the associated type or calling a method that returns the associated type\".\n-            let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n-                diag,\n-                assoc.container_id(self),\n-                current_method_ident,\n-                proj_ty.def_id,\n-                values.expected,\n-            );\n-            // Possibly suggest constraining the associated type to conform to the\n-            // found type.\n-            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n-                || point_at_assoc_fn\n-            {\n-                return;\n-            }\n-        }\n-\n-        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n-\n-        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n-            return;\n-        }\n-\n-        if !impl_comparison {\n-            // Generic suggestion when we can't be more specific.\n-            if callable_scope {\n-                diag.help(&format!(\n-                    \"{} or calling a method that returns `{}`\",\n-                    msg, values.expected\n-                ));\n-            } else {\n-                diag.help(&msg);\n-            }\n-            diag.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n-            );\n-        }\n-        if self.sess.teach(&diag.get_code().unwrap()) {\n-            diag.help(\n-                \"given an associated type `T` and a method `foo`:\n-```\n-trait Trait {\n-type T;\n-fn foo(&self) -> Self::T;\n-}\n-```\n-the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n-```\n-impl Trait for X {\n-type T = String;\n-fn foo(&self) -> Self::T { String::new() }\n-}\n-```\",\n-            );\n-        }\n-    }\n-\n-    /// When the expected `impl Trait` is not defined in the current item, it will come from\n-    /// a return type. This can occur when dealing with `TryStream` (#71035).\n-    fn suggest_constraining_opaque_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        msg: &str,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n-            let opaque_local_def_id = def_id.as_local();\n-            let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n-                match &self.hir().expect_item(opaque_local_def_id).kind {\n-                    hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n-                    _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n-                }\n-            } else {\n-                return false;\n-            };\n-\n-            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n-\n-            self.constrain_generic_bound_associated_type_structured_suggestion(\n-                diag,\n-                &trait_ref,\n-                opaque_hir_ty.bounds,\n-                assoc,\n-                assoc_substs,\n-                ty,\n-                msg,\n-                true,\n-            )\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn point_at_methods_that_satisfy_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        assoc_container_id: DefId,\n-        current_method_ident: Option<Symbol>,\n-        proj_ty_item_def_id: DefId,\n-        expected: Ty<'tcx>,\n-    ) -> bool {\n-        let items = self.associated_items(assoc_container_id);\n-        // Find all the methods in the trait that could be called to construct the\n-        // expected associated type.\n-        // FIXME: consider suggesting the use of associated `const`s.\n-        let methods: Vec<(Span, String)> = items\n-            .items\n-            .iter()\n-            .filter(|(name, item)| {\n-                ty::AssocKind::Fn == item.kind && Some(**name) != current_method_ident\n-            })\n-            .filter_map(|(_, item)| {\n-                let method = self.fn_sig(item.def_id);\n-                match *method.output().skip_binder().kind() {\n-                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n-                        if item_def_id == proj_ty_item_def_id =>\n-                    {\n-                        Some((\n-                            self.def_span(item.def_id),\n-                            format!(\"consider calling `{}`\", self.def_path_str(item.def_id)),\n-                        ))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect();\n-        if !methods.is_empty() {\n-            // Use a single `help:` to show all the methods in the trait that can\n-            // be used to construct the expected associated type.\n-            let mut span: MultiSpan =\n-                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n-            let msg = format!(\n-                \"{some} method{s} {are} available that return{r} `{ty}`\",\n-                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n-                s = pluralize!(methods.len()),\n-                are = pluralize!(\"is\", methods.len()),\n-                r = if methods.len() == 1 { \"s\" } else { \"\" },\n-                ty = expected\n-            );\n-            for (sp, label) in methods.into_iter() {\n-                span.push_span_label(sp, label);\n-            }\n-            diag.span_help(span, &msg);\n-            return true;\n-        }\n-        false\n-    }\n-\n-    fn point_at_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        body_owner_def_id: DefId,\n-        found: Ty<'tcx>,\n-    ) -> bool {\n-        let Some(hir_id) = body_owner_def_id.as_local() else {\n-            return false;\n-        };\n-        let hir_id = self.hir().local_def_id_to_hir_id(hir_id);\n-        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n-        // `expected` and point at it.\n-        let parent_id = self.hir().get_parent_item(hir_id);\n-        let item = self.hir().find_by_def_id(parent_id.def_id);\n-        debug!(\"expected_projection parent item {:?}\", item);\n-        match item {\n-            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n-                // FIXME: account for `#![feature(specialization)]`\n-                for item in &items[..] {\n-                    match item.kind {\n-                        hir::AssocItemKind::Type => {\n-                            // FIXME: account for returning some type in a trait fn impl that has\n-                            // an assoc type as a return type (#72076).\n-                            if let hir::Defaultness::Default { has_value: true } =\n-                                self.impl_defaultness(item.id.owner_id)\n-                            {\n-                                if self.type_of(item.id.owner_id) == found {\n-                                    diag.span_label(\n-                                        item.span,\n-                                        \"associated type defaults can't be assumed inside the \\\n-                                            trait defining them\",\n-                                    );\n-                                    return true;\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Impl(hir::Impl { items, .. }),\n-                ..\n-            })) => {\n-                for item in &items[..] {\n-                    if let hir::AssocItemKind::Type = item.kind {\n-                        if self.type_of(item.id.owner_id) == found {\n-                            diag.span_label(item.span, \"expected this associated type\");\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        false\n-    }\n-\n-    /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n-    /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n-    ///\n-    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n-    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n-    /// trait bound as the one we're looking for. This can help in cases where the associated\n-    /// type is defined on a supertrait of the one present in the bounds.\n-    fn constrain_generic_bound_associated_type_structured_suggestion(\n-        self,\n-        diag: &mut Diagnostic,\n-        trait_ref: &ty::TraitRef<'tcx>,\n-        bounds: hir::GenericBounds<'_>,\n-        assoc: &ty::AssocItem,\n-        assoc_substs: &[ty::GenericArg<'tcx>],\n-        ty: Ty<'tcx>,\n-        msg: &str,\n-        is_bound_surely_present: bool,\n-    ) -> bool {\n-        // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-\n-        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n-            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n-            _ => None,\n-        });\n-\n-        let matching_trait_bounds = trait_bounds\n-            .clone()\n-            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n-            .collect::<Vec<_>>();\n-\n-        let span = match &matching_trait_bounds[..] {\n-            &[ptr] => ptr.span,\n-            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n-                &[ptr] => ptr.span,\n-                _ => return false,\n-            },\n-            _ => return false,\n-        };\n-\n-        self.constrain_associated_type_structured_suggestion(\n-            diag,\n-            span,\n-            assoc,\n-            assoc_substs,\n-            ty,\n-            msg,\n-        )\n-    }\n-\n-    /// Given a span corresponding to a bound, provide a structured suggestion to set an\n-    /// associated type to a given type `ty`.\n-    fn constrain_associated_type_structured_suggestion(\n-        self,\n-        diag: &mut Diagnostic,\n-        span: Span,\n-        assoc: &ty::AssocItem,\n-        assoc_substs: &[ty::GenericArg<'tcx>],\n-        ty: Ty<'tcx>,\n-        msg: &str,\n-    ) -> bool {\n-        if let Ok(has_params) =\n-            self.sess.source_map().span_to_snippet(span).map(|snippet| snippet.ends_with('>'))\n-        {\n-            let (span, sugg) = if has_params {\n-                let pos = span.hi() - BytePos(1);\n-                let span = Span::new(pos, pos, span.ctxt(), span.parent());\n-                (span, format!(\", {} = {}\", assoc.ident(self), ty))\n-            } else {\n-                let item_args = self.format_generic_args(assoc_substs);\n-                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(self), item_args, ty))\n-            };\n-            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n-            return true;\n-        }\n-        false\n-    }\n-\n     pub fn short_ty_string(self, ty: Ty<'tcx>) -> (String, Option<PathBuf>) {\n         let width = self.sess.diagnostic_width();\n         let length_limit = width.saturating_sub(30);\n@@ -1047,11 +428,4 @@ fn foo(&self) -> Self::T { String::new() }\n             Err(_) => (regular, None),\n         }\n     }\n-\n-    fn format_generic_args(self, args: &[ty::GenericArg<'tcx>]) -> String {\n-        FmtPrinter::new(self, hir::def::Namespace::TypeNS)\n-            .path_generic_args(Ok, args)\n-            .expect(\"could not write to `String`.\")\n-            .into_buffer()\n-    }\n }"}, {"sha": "9afa37e9ef3ee137467dcaf2c7d1944b090bead5", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -32,6 +32,7 @@ pub enum SimplifiedType {\n     ClosureSimplifiedType(DefId),\n     GeneratorSimplifiedType(DefId),\n     GeneratorWitnessSimplifiedType(usize),\n+    GeneratorWitnessMIRSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n     PlaceholderSimplifiedType,\n }\n@@ -108,6 +109,7 @@ pub fn simplify_type<'tcx>(\n         ty::FnDef(def_id, _) | ty::Closure(def_id, _) => Some(ClosureSimplifiedType(def_id)),\n         ty::Generator(def_id, _, _) => Some(GeneratorSimplifiedType(def_id)),\n         ty::GeneratorWitness(tys) => Some(GeneratorWitnessSimplifiedType(tys.skip_binder().len())),\n+        ty::GeneratorWitnessMIR(def_id, _) => Some(GeneratorWitnessMIRSimplifiedType(def_id)),\n         ty::Never => Some(NeverSimplifiedType),\n         ty::Tuple(tys) => Some(TupleSimplifiedType(tys.len())),\n         ty::FnPtr(f) => Some(FunctionSimplifiedType(f.skip_binder().inputs().len())),\n@@ -139,7 +141,8 @@ impl SimplifiedType {\n             | ForeignSimplifiedType(d)\n             | TraitSimplifiedType(d)\n             | ClosureSimplifiedType(d)\n-            | GeneratorSimplifiedType(d) => Some(d),\n+            | GeneratorSimplifiedType(d)\n+            | GeneratorWitnessMIRSimplifiedType(d) => Some(d),\n             _ => None,\n         }\n     }\n@@ -208,6 +211,7 @@ impl DeepRejectCtxt {\n             | ty::Closure(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Placeholder(..)\n             | ty::Bound(..)\n             | ty::Infer(_) => bug!(\"unexpected impl_ty: {impl_ty}\"),\n@@ -306,7 +310,7 @@ impl DeepRejectCtxt {\n \n             ty::Error(_) => true,\n \n-            ty::GeneratorWitness(..) | ty::Bound(..) => {\n+            ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) | ty::Bound(..) => {\n                 bug!(\"unexpected obligation type: {:?}\", obligation_ty)\n             }\n         }"}, {"sha": "dc6f5851b7d883ad6a2fd843615d23446f06a87b", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -125,6 +125,16 @@ impl FlagComputation {\n                 self.bound_computation(ts, |flags, ts| flags.add_tys(ts));\n             }\n \n+            &ty::GeneratorWitnessMIR(_, ref substs) => {\n+                let should_remove_further_specializable =\n+                    !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n+                self.add_substs(substs);\n+                if should_remove_further_specializable {\n+                    self.flags -= TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n+                }\n+                self.add_flags(TypeFlags::HAS_TY_GENERATOR);\n+            }\n+\n             &ty::Closure(_, substs) => {\n                 let substs = substs.as_closure();\n                 let should_remove_further_specializable ="}, {"sha": "8b4fccc58bd4447819f4ad763867891d7a9acae0", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -459,7 +459,7 @@ impl<'tcx> Instance<'tcx> {\n         substs: SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve_for_vtable(def_id={:?}, substs={:?})\", def_id, substs);\n-        let fn_sig = tcx.fn_sig(def_id);\n+        let fn_sig = tcx.fn_sig(def_id).subst_identity();\n         let is_vtable_shim = !fn_sig.inputs().skip_binder().is_empty()\n             && fn_sig.input(0).skip_binder().is_param(0)\n             && tcx.generics_of(def_id).has_self;"}, {"sha": "cdcd6281f209bb4d25761ebb9e0a6cd9d1fac8f3", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 111, "deletions": 112, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -128,7 +128,8 @@ impl PrimitiveExt for Primitive {\n             Int(i, signed) => i.to_ty(tcx, signed),\n             F32 => tcx.types.f32,\n             F64 => tcx.types.f64,\n-            Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            Pointer(_) => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n \n@@ -138,7 +139,11 @@ impl PrimitiveExt for Primitive {\n     fn to_int_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             Int(i, signed) => i.to_ty(tcx, signed),\n-            Pointer => tcx.types.usize,\n+            // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+            Pointer(_) => {\n+                let signed = false;\n+                tcx.data_layout().ptr_sized_integer().to_ty(tcx, signed)\n+            }\n             F32 | F64 => bug!(\"floats do not have an int type\"),\n         }\n     }\n@@ -640,6 +645,7 @@ where\n                 | ty::Never\n                 | ty::FnDef(..)\n                 | ty::GeneratorWitness(..)\n+                | ty::GeneratorWitnessMIR(..)\n                 | ty::Foreign(..)\n                 | ty::Dynamic(_, _, ty::Dyn) => {\n                     bug!(\"TyAndLayout::field({:?}): not applicable\", this)\n@@ -812,132 +818,125 @@ where\n         let tcx = cx.tcx();\n         let param_env = cx.param_env();\n \n-        let addr_space_of_ty = |ty: Ty<'tcx>| {\n-            if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n-        };\n-\n-        let pointee_info = match *this.ty.kind() {\n-            ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: None,\n-                    address_space: addr_space_of_ty(mt.ty),\n-                })\n-            }\n-            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: None,\n-                    address_space: cx.data_layout().instruction_address_space,\n-                })\n-            }\n-            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                let address_space = addr_space_of_ty(ty);\n-                let kind = if tcx.sess.opts.optimize == OptLevel::No {\n-                    // Use conservative pointer kind if not optimizing. This saves us the\n-                    // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                    // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                    PointerKind::SharedMutable\n-                } else {\n-                    match mt {\n-                        hir::Mutability::Not => {\n-                            if ty.is_freeze(tcx, cx.param_env()) {\n-                                PointerKind::Frozen\n-                            } else {\n-                                PointerKind::SharedMutable\n+        let pointee_info =\n+            match *this.ty.kind() {\n+                ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                    tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: None,\n+                    })\n+                }\n+                ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                    tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| {\n+                        PointeeInfo { size: layout.size, align: layout.align.abi, safe: None }\n+                    })\n+                }\n+                ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                    let kind = if tcx.sess.opts.optimize == OptLevel::No {\n+                        // Use conservative pointer kind if not optimizing. This saves us the\n+                        // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                        // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                        PointerKind::SharedMutable\n+                    } else {\n+                        match mt {\n+                            hir::Mutability::Not => {\n+                                if ty.is_freeze(tcx, cx.param_env()) {\n+                                    PointerKind::Frozen\n+                                } else {\n+                                    PointerKind::SharedMutable\n+                                }\n                             }\n-                        }\n-                        hir::Mutability::Mut => {\n-                            // References to self-referential structures should not be considered\n-                            // noalias, as another pointer to the structure can be obtained, that\n-                            // is not based-on the original reference. We consider all !Unpin\n-                            // types to be potentially self-referential here.\n-                            if ty.is_unpin(tcx, cx.param_env()) {\n-                                PointerKind::UniqueBorrowed\n-                            } else {\n-                                PointerKind::UniqueBorrowedPinned\n+                            hir::Mutability::Mut => {\n+                                // References to self-referential structures should not be considered\n+                                // noalias, as another pointer to the structure can be obtained, that\n+                                // is not based-on the original reference. We consider all !Unpin\n+                                // types to be potentially self-referential here.\n+                                if ty.is_unpin(tcx, cx.param_env()) {\n+                                    PointerKind::UniqueBorrowed\n+                                } else {\n+                                    PointerKind::UniqueBorrowedPinned\n+                                }\n                             }\n                         }\n-                    }\n-                };\n+                    };\n \n-                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n-                    size: layout.size,\n-                    align: layout.align.abi,\n-                    safe: Some(kind),\n-                    address_space,\n-                })\n-            }\n+                    tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: Some(kind),\n+                    })\n+                }\n \n-            _ => {\n-                let mut data_variant = match this.variants {\n-                    // Within the discriminant field, only the niche itself is\n-                    // always initialized, so we only check for a pointer at its\n-                    // offset.\n-                    //\n-                    // If the niche is a pointer, it's either valid (according\n-                    // to its type), or null (which the niche field's scalar\n-                    // validity range encodes). This allows using\n-                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                    // this will continue to work as long as we don't start\n-                    // using more niches than just null (e.g., the first page of\n-                    // the address space, or unaligned pointers).\n-                    Variants::Multiple {\n-                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n-                        tag_field,\n-                        ..\n-                    } if this.fields.offset(tag_field) == offset => {\n-                        Some(this.for_variant(cx, untagged_variant))\n-                    }\n-                    _ => Some(this),\n-                };\n+                _ => {\n+                    let mut data_variant = match this.variants {\n+                        // Within the discriminant field, only the niche itself is\n+                        // always initialized, so we only check for a pointer at its\n+                        // offset.\n+                        //\n+                        // If the niche is a pointer, it's either valid (according\n+                        // to its type), or null (which the niche field's scalar\n+                        // validity range encodes). This allows using\n+                        // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                        // this will continue to work as long as we don't start\n+                        // using more niches than just null (e.g., the first page of\n+                        // the address space, or unaligned pointers).\n+                        Variants::Multiple {\n+                            tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n+                            tag_field,\n+                            ..\n+                        } if this.fields.offset(tag_field) == offset => {\n+                            Some(this.for_variant(cx, untagged_variant))\n+                        }\n+                        _ => Some(this),\n+                    };\n \n-                if let Some(variant) = data_variant {\n-                    // We're not interested in any unions.\n-                    if let FieldsShape::Union(_) = variant.fields {\n-                        data_variant = None;\n+                    if let Some(variant) = data_variant {\n+                        // We're not interested in any unions.\n+                        if let FieldsShape::Union(_) = variant.fields {\n+                            data_variant = None;\n+                        }\n                     }\n-                }\n \n-                let mut result = None;\n-\n-                if let Some(variant) = data_variant {\n-                    let ptr_end = offset + Pointer.size(cx);\n-                    for i in 0..variant.fields.count() {\n-                        let field_start = variant.fields.offset(i);\n-                        if field_start <= offset {\n-                            let field = variant.field(cx, i);\n-                            result = field.to_result().ok().and_then(|field| {\n-                                if ptr_end <= field_start + field.size {\n-                                    // We found the right field, look inside it.\n-                                    let field_info =\n-                                        field.pointee_info_at(cx, offset - field_start);\n-                                    field_info\n-                                } else {\n-                                    None\n+                    let mut result = None;\n+\n+                    if let Some(variant) = data_variant {\n+                        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                        // (requires passing in the expected address space from the caller)\n+                        let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n+                        for i in 0..variant.fields.count() {\n+                            let field_start = variant.fields.offset(i);\n+                            if field_start <= offset {\n+                                let field = variant.field(cx, i);\n+                                result = field.to_result().ok().and_then(|field| {\n+                                    if ptr_end <= field_start + field.size {\n+                                        // We found the right field, look inside it.\n+                                        let field_info =\n+                                            field.pointee_info_at(cx, offset - field_start);\n+                                        field_info\n+                                    } else {\n+                                        None\n+                                    }\n+                                });\n+                                if result.is_some() {\n+                                    break;\n                                 }\n-                            });\n-                            if result.is_some() {\n-                                break;\n                             }\n                         }\n                     }\n-                }\n \n-                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = this.ty.kind() {\n-                        if def.is_box() && offset.bytes() == 0 {\n-                            pointee.safe = Some(PointerKind::UniqueOwned);\n+                    // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                    if let Some(ref mut pointee) = result {\n+                        if let ty::Adt(def, _) = this.ty.kind() {\n+                            if def.is_box() && offset.bytes() == 0 {\n+                                pointee.safe = Some(PointerKind::UniqueOwned);\n+                            }\n                         }\n                     }\n-                }\n \n-                result\n-            }\n-        };\n+                    result\n+                }\n+            };\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\","}, {"sha": "25c6777a14c7084aa65ecdc7a933d66e78421056", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -31,7 +31,6 @@ pub use generics::*;\n use rustc_ast as ast;\n use rustc_ast::node_id::NodeMap;\n use rustc_attr as attr;\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -453,18 +452,6 @@ pub struct CReaderCacheKey {\n #[rustc_pass_by_value]\n pub struct Ty<'tcx>(Interned<'tcx, WithCachedTypeInfo<TyKind<'tcx>>>);\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// A \"bool\" type used in rustc_mir_transform unit tests when we\n-    /// have not spun up a TyCtxt.\n-    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> =\n-        Ty(Interned::new_unchecked(&WithCachedTypeInfo {\n-            internee: ty::Bool,\n-            stable_hash: Fingerprint::ZERO,\n-            flags: TypeFlags::empty(),\n-            outer_exclusive_binder: DebruijnIndex::from_usize(0),\n-        }));\n-}\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n@@ -2437,6 +2424,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         ident\n     }\n \n+    // FIXME(vincenzoapalzzo): move the HirId to a LocalDefId\n     pub fn adjust_ident_and_get_scope(\n         self,\n         mut ident: Ident,\n@@ -2470,10 +2458,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n     }\n \n-    pub fn is_object_safe(self, key: DefId) -> bool {\n-        self.object_safety_violations(key).is_empty()\n-    }\n-\n     #[inline]\n     pub fn is_const_fn_raw(self, def_id: DefId) -> bool {\n         matches!("}, {"sha": "7ff58f02623dc1aa399f0c8cda4844a62f51d6b2", "filename": "compiler/rustc_middle/src/ty/opaque_types.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fopaque_types.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,6 +3,7 @@ use crate::ty::fold::{TypeFolder, TypeSuperFoldable};\n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n /// Converts generic params of a TypeFoldable from one\n@@ -47,6 +48,47 @@ impl<'tcx> ReverseMapper<'tcx> {\n         assert!(!self.do_not_error);\n         kind.fold_with(self)\n     }\n+\n+    fn fold_closure_substs(\n+        &mut self,\n+        def_id: DefId,\n+        substs: ty::SubstsRef<'tcx>,\n+    ) -> ty::SubstsRef<'tcx> {\n+        // I am a horrible monster and I pray for death. When\n+        // we encounter a closure here, it is always a closure\n+        // from within the function that we are currently\n+        // type-checking -- one that is now being encapsulated\n+        // in an opaque type. Ideally, we would\n+        // go through the types/lifetimes that it references\n+        // and treat them just like we would any other type,\n+        // which means we would error out if we find any\n+        // reference to a type/region that is not in the\n+        // \"reverse map\".\n+        //\n+        // **However,** in the case of closures, there is a\n+        // somewhat subtle (read: hacky) consideration. The\n+        // problem is that our closure types currently include\n+        // all the lifetime parameters declared on the\n+        // enclosing function, even if they are unused by the\n+        // closure itself. We can't readily filter them out,\n+        // so here we replace those values with `'empty`. This\n+        // can't really make a difference to the rest of the\n+        // compiler; those regions are ignored for the\n+        // outlives relation, and hence don't affect trait\n+        // selection or auto traits, and they are erased\n+        // during codegen.\n+\n+        let generics = self.tcx.generics_of(def_id);\n+        self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n+            if index < generics.parent_count {\n+                // Accommodate missing regions in the parent kinds...\n+                self.fold_kind_no_missing_regions_error(kind)\n+            } else {\n+                // ...but not elsewhere.\n+                self.fold_kind_normally(kind)\n+            }\n+        }))\n+    }\n }\n \n impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n@@ -104,59 +146,20 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         match *ty.kind() {\n             ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n+                let substs = self.fold_closure_substs(def_id, substs);\n                 self.tcx.mk_closure(def_id, substs)\n             }\n \n             ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n+                let substs = self.fold_closure_substs(def_id, substs);\n                 self.tcx.mk_generator(def_id, substs, movability)\n             }\n \n+            ty::GeneratorWitnessMIR(def_id, substs) => {\n+                let substs = self.fold_closure_substs(def_id, substs);\n+                self.tcx.mk_generator_witness_mir(def_id, substs)\n+            }\n+\n             ty::Param(param) => {\n                 // Look it up in the substitution list.\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {"}, {"sha": "84edb5f2a4288fd4cfa12327c9504877866dd6f6", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -117,6 +117,7 @@ macro_rules! parameterized_over_tcx {\n parameterized_over_tcx! {\n     crate::middle::exported_symbols::ExportedSymbol,\n     crate::mir::Body,\n+    crate::mir::GeneratorLayout,\n     ty::Ty,\n     ty::FnSig,\n     ty::GenericPredicates,"}, {"sha": "90bf3288ccf5489946a63560ca32c066c30f5e6d", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -265,6 +265,7 @@ fn characteristic_def_id_of_type_cached<'a>(\n         ty::FnDef(def_id, _)\n         | ty::Closure(def_id, _)\n         | ty::Generator(def_id, _, _)\n+        | ty::GeneratorWitnessMIR(def_id, _)\n         | ty::Foreign(def_id) => Some(def_id),\n \n         ty::Bool"}, {"sha": "f2abec216b7b371d594bd85f5a657fbca09e7f05", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -675,7 +675,7 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(\")\")\n             }\n             ty::FnDef(def_id, substs) => {\n-                let sig = self.tcx().bound_fn_sig(def_id).subst(self.tcx(), substs);\n+                let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n                 p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n@@ -811,6 +811,28 @@ pub trait PrettyPrinter<'tcx>:\n             ty::GeneratorWitness(types) => {\n                 p!(in_binder(&types));\n             }\n+            ty::GeneratorWitnessMIR(did, substs) => {\n+                p!(write(\"[\"));\n+                if !self.tcx().sess.verbose() {\n+                    p!(\"generator witness\");\n+                    // FIXME(eddyb) should use `def_span`.\n+                    if let Some(did) = did.as_local() {\n+                        let span = self.tcx().def_span(did);\n+                        p!(write(\n+                            \"@{}\",\n+                            // This may end up in stderr diagnostics but it may also be emitted\n+                            // into MIR. Hence we use the remapped path if available\n+                            self.tcx().sess.source_map().span_to_embeddable_string(span)\n+                        ));\n+                    } else {\n+                        p!(write(\"@\"), print_def_path(did, substs));\n+                    }\n+                } else {\n+                    p!(print_def_path(did, substs));\n+                }\n+\n+                p!(\"]\")\n+            }\n             ty::Closure(did, substs) => {\n                 p!(write(\"[\"));\n                 if !self.should_print_verbose() {"}, {"sha": "1be819ca610c7c644f7b3c9c9325f4c52bf81494", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -118,6 +118,7 @@ fn copy<T: Copy>(x: &T) -> T {\n \n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n+    (LocalDefId) => { impl IntoQueryParam<LocalDefId> };\n     ($K:ty) => { $K };\n }\n \n@@ -418,6 +419,13 @@ mod sealed {\n         }\n     }\n \n+    impl IntoQueryParam<LocalDefId> for OwnerId {\n+        #[inline(always)]\n+        fn into_query_param(self) -> LocalDefId {\n+            self.def_id\n+        }\n+    }\n+\n     impl IntoQueryParam<DefId> for LocalDefId {\n         #[inline(always)]\n         fn into_query_param(self) -> DefId {\n@@ -441,6 +449,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.opt_def_kind(def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n     }\n+\n+    pub fn bound_type_of(self, def_id: impl IntoQueryParam<DefId>) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n+    }\n }\n \n impl<'tcx> TyCtxtAt<'tcx> {\n@@ -449,4 +461,8 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         self.opt_def_kind(def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", def_id))\n     }\n+\n+    pub fn bound_type_of(self, def_id: impl IntoQueryParam<DefId>) -> ty::EarlyBinder<Ty<'tcx>> {\n+        ty::EarlyBinder(self.type_of(def_id))\n+    }\n }"}, {"sha": "fa87301df7e779f09d0eb8f002164b7fe9e82221", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -443,12 +443,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             if a_repr == b_repr =>\n         {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n-                relation.relate_with_variance(\n-                    ty::Contravariant,\n-                    ty::VarianceDiagInfo::default(),\n-                    a_region,\n-                    b_region,\n-                )\n+                relation.relate(a_region, b_region)\n             })?;\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound, a_repr))\n         }\n@@ -473,6 +468,16 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_generator_witness(types))\n         }\n \n+        (&ty::GeneratorWitnessMIR(a_id, a_substs), &ty::GeneratorWitnessMIR(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            // All GeneratorWitness types with the same id represent\n+            // the (anonymous) type of the same generator expression. So\n+            // all of their regions should be equated.\n+            let substs = relation.relate(a_substs, b_substs)?;\n+            Ok(tcx.mk_generator_witness_mir(a_id, substs))\n+        }\n+\n         (&ty::Closure(a_id, a_substs), &ty::Closure(b_id, b_substs)) if a_id == b_id => {\n             // All Closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n@@ -487,12 +492,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(\n-                ty::Contravariant,\n-                ty::VarianceDiagInfo::default(),\n-                a_r,\n-                b_r,\n-            )?;\n+            let r = relation.relate(a_r, b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n             let mt = relate_type_and_mut(relation, a_mt, b_mt, a)?;"}, {"sha": "034aab0c38ea32a9a60d4be70d82bd37460c43a3", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -11,6 +11,7 @@ use crate::ty::{self, AliasTy, InferConst, Lift, Term, TermKind, Ty, TyCtxt};\n use rustc_data_structures::functor::IdFunctor;\n use rustc_hir::def::Namespace;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_target::abi::TyAndLayout;\n \n use std::fmt;\n use std::mem::ManuallyDrop;\n@@ -200,6 +201,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     bool,\n     usize,\n     ::rustc_target::abi::VariantIdx,\n+    u16,\n     u32,\n     u64,\n     String,\n@@ -654,6 +656,9 @@ impl<'tcx> TypeSuperFoldable<'tcx> for Ty<'tcx> {\n                 ty::Generator(did, substs.try_fold_with(folder)?, movability)\n             }\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.try_fold_with(folder)?),\n+            ty::GeneratorWitnessMIR(did, substs) => {\n+                ty::GeneratorWitnessMIR(did, substs.try_fold_with(folder)?)\n+            }\n             ty::Closure(did, substs) => ty::Closure(did, substs.try_fold_with(folder)?),\n             ty::Alias(kind, data) => ty::Alias(kind, data.try_fold_with(folder)?),\n \n@@ -699,6 +704,7 @@ impl<'tcx> TypeSuperVisitable<'tcx> for Ty<'tcx> {\n             }\n             ty::Generator(_did, ref substs, _) => substs.visit_with(visitor),\n             ty::GeneratorWitness(ref types) => types.visit_with(visitor),\n+            ty::GeneratorWitnessMIR(_did, ref substs) => substs.visit_with(visitor),\n             ty::Closure(_did, ref substs) => substs.visit_with(visitor),\n             ty::Alias(_, ref data) => data.visit_with(visitor),\n \n@@ -853,3 +859,9 @@ impl<'tcx> TypeSuperVisitable<'tcx> for ty::UnevaluatedConst<'tcx> {\n         self.substs.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx> TypeVisitable<'tcx> for TyAndLayout<'tcx, Ty<'tcx>> {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        visitor.visit_ty(self.ty)\n+    }\n+}"}, {"sha": "f97d2e753a3b6d0ee1a5fb065b46d74cf7c26a0f", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -571,9 +571,9 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     ) -> impl Iterator<Item = impl Iterator<Item = Ty<'tcx>> + Captures<'tcx>> {\n         let layout = tcx.generator_layout(def_id).unwrap();\n         layout.variant_fields.iter().map(move |variant| {\n-            variant\n-                .iter()\n-                .map(move |field| ty::EarlyBinder(layout.field_tys[*field]).subst(tcx, self.substs))\n+            variant.iter().map(move |field| {\n+                ty::EarlyBinder(layout.field_tys[*field].ty).subst(tcx, self.substs)\n+            })\n         })\n     }\n \n@@ -2059,7 +2059,7 @@ impl<'tcx> Ty<'tcx> {\n \n     pub fn fn_sig(self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n         match self.kind() {\n-            FnDef(def_id, substs) => tcx.bound_fn_sig(*def_id).subst(tcx, substs),\n+            FnDef(def_id, substs) => tcx.fn_sig(*def_id).subst(tcx, substs),\n             FnPtr(f) => *f,\n             Error(_) => {\n                 // ignore errors (#54954)\n@@ -2175,6 +2175,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Dynamic(..)\n             | ty::Closure(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Never\n             | ty::Tuple(_)\n             | ty::Error(_)\n@@ -2210,6 +2211,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Ref(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Array(..)\n             | ty::Closure(..)\n             | ty::Never\n@@ -2296,6 +2298,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Ref(..)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Array(..)\n             | ty::Closure(..)\n             | ty::Never\n@@ -2360,7 +2363,7 @@ impl<'tcx> Ty<'tcx> {\n             // anything with custom metadata it might be more complicated.\n             ty::Ref(_, _, hir::Mutability::Not) | ty::RawPtr(..) => false,\n \n-            ty::Generator(..) | ty::GeneratorWitness(..) => false,\n+            ty::Generator(..) | ty::GeneratorWitness(..) | ty::GeneratorWitnessMIR(..) => false,\n \n             // Might be, but not \"trivial\" so just giving the safe answer.\n             ty::Adt(..) | ty::Closure(..) => false,"}, {"sha": "cf1bb5f8ac8db27900054ae4415777b520f93e52", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -758,6 +758,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> ty::EarlyBinder<T> {\n     pub fn subst_identity(self) -> T {\n         self.0\n     }\n+\n+    /// Returns the inner value, but only if it contains no bound vars.\n+    pub fn no_bound_vars(self) -> Option<T> {\n+        if !self.0.needs_subst() { Some(self.0) } else { None }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "79a6c730d7159a5abcbf323ae029566c709952e6", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,6 +1,7 @@\n use crate::{\n     hir::place::Place as HirPlace,\n     infer::canonical::Canonical,\n+    traits::ObligationCause,\n     ty::{\n         self, tls, BindingMode, BoundVar, CanonicalPolyFnSig, ClosureSizeProfileData,\n         GenericArgKind, InternalSubsts, SubstsRef, Ty, UserSubsts,\n@@ -193,6 +194,11 @@ pub struct TypeckResults<'tcx> {\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n+    /// Stores the predicates that apply on generator witness types.\n+    /// formatting modified file tests/ui/generator/retain-resume-ref.rs\n+    pub generator_interior_predicates:\n+        FxHashMap<LocalDefId, Vec<(ty::Predicate<'tcx>, ObligationCause<'tcx>)>>,\n+\n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n     /// as `&[u8]`, depending on the pattern in which they are used.\n     /// This hashset records all instances where we behave\n@@ -271,6 +277,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             closure_fake_reads: Default::default(),\n             rvalue_scopes: Default::default(),\n             generator_interior_types: ty::Binder::dummy(Default::default()),\n+            generator_interior_predicates: Default::default(),\n             treat_byte_string_as_slice: Default::default(),\n             closure_size_eval: Default::default(),\n         }"}, {"sha": "796164b0d6af39652c2f64f1f019b54267071a80", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -3,7 +3,6 @@\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n use crate::ty::layout::IntegerExt;\n-use crate::ty::query::TyCtxtAt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n     TypeVisitable,\n@@ -616,6 +615,36 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Return the set of types that should be taken into accound when checking\n+    /// trait bounds on a generator's internal state.\n+    pub fn generator_hidden_types(\n+        self,\n+        def_id: DefId,\n+    ) -> impl Iterator<Item = ty::EarlyBinder<Ty<'tcx>>> {\n+        let generator_layout = &self.mir_generator_witnesses(def_id);\n+        generator_layout\n+            .field_tys\n+            .iter()\n+            .filter(|decl| !decl.ignore_for_traits)\n+            .map(|decl| ty::EarlyBinder(decl.ty))\n+    }\n+\n+    /// Normalizes all opaque types in the given value, replacing them\n+    /// with their underlying types.\n+    pub fn expand_opaque_types(self, val: Ty<'tcx>) -> Ty<'tcx> {\n+        let mut visitor = OpaqueTypeExpander {\n+            seen_opaque_tys: FxHashSet::default(),\n+            expanded_cache: FxHashMap::default(),\n+            primary_def_id: None,\n+            found_recursion: false,\n+            found_any_recursion: false,\n+            check_recursion: false,\n+            expand_generators: false,\n+            tcx: self,\n+        };\n+        val.fold_with(&mut visitor)\n+    }\n+\n     /// Expands the given impl trait type, stopping if the type is recursive.\n     #[instrument(skip(self), level = \"debug\", ret)]\n     pub fn try_expand_impl_trait_type(\n@@ -630,28 +659,21 @@ impl<'tcx> TyCtxt<'tcx> {\n             found_recursion: false,\n             found_any_recursion: false,\n             check_recursion: true,\n+            expand_generators: true,\n             tcx: self,\n         };\n \n         let expanded_type = visitor.expand_opaque_ty(def_id, substs).unwrap();\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n \n-    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.type_of(def_id))\n-    }\n-\n     pub fn bound_return_position_impl_trait_in_trait_tys(\n         self,\n         def_id: DefId,\n     ) -> ty::EarlyBinder<Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>> {\n         ty::EarlyBinder(self.collect_return_position_impl_trait_in_trait_tys(def_id))\n     }\n \n-    pub fn bound_fn_sig(self, def_id: DefId) -> ty::EarlyBinder<ty::PolyFnSig<'tcx>> {\n-        ty::EarlyBinder(self.fn_sig(def_id))\n-    }\n-\n     pub fn bound_explicit_item_bounds(\n         self,\n         def_id: DefId,\n@@ -738,12 +760,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxtAt<'tcx> {\n-    pub fn bound_type_of(self, def_id: DefId) -> ty::EarlyBinder<Ty<'tcx>> {\n-        ty::EarlyBinder(self.type_of(def_id))\n-    }\n-}\n-\n struct OpaqueTypeExpander<'tcx> {\n     // Contains the DefIds of the opaque types that are currently being\n     // expanded. When we expand an opaque type we insert the DefId of\n@@ -756,6 +772,7 @@ struct OpaqueTypeExpander<'tcx> {\n     primary_def_id: Option<DefId>,\n     found_recursion: bool,\n     found_any_recursion: bool,\n+    expand_generators: bool,\n     /// Whether or not to check for recursive opaque types.\n     /// This is `true` when we're explicitly checking for opaque type\n     /// recursion, and 'false' otherwise to avoid unnecessary work.\n@@ -792,6 +809,37 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n             None\n         }\n     }\n+\n+    fn expand_generator(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) -> Option<Ty<'tcx>> {\n+        if self.found_any_recursion {\n+            return None;\n+        }\n+        let substs = substs.fold_with(self);\n+        if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n+            let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n+                Some(expanded_ty) => *expanded_ty,\n+                None => {\n+                    for bty in self.tcx.generator_hidden_types(def_id) {\n+                        let hidden_ty = bty.subst(self.tcx, substs);\n+                        self.fold_ty(hidden_ty);\n+                    }\n+                    let expanded_ty = self.tcx.mk_generator_witness_mir(def_id, substs);\n+                    self.expanded_cache.insert((def_id, substs), expanded_ty);\n+                    expanded_ty\n+                }\n+            };\n+            if self.check_recursion {\n+                self.seen_opaque_tys.remove(&def_id);\n+            }\n+            Some(expanded_ty)\n+        } else {\n+            // If another opaque type that we contain is recursive, then it\n+            // will report the error, so we don't have to.\n+            self.found_any_recursion = true;\n+            self.found_recursion = def_id == *self.primary_def_id.as_ref().unwrap();\n+            None\n+        }\n+    }\n }\n \n impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n@@ -800,13 +848,19 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) = *t.kind() {\n+        let mut t = if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-        } else if t.has_opaque_types() {\n+        } else if t.has_opaque_types() || t.has_generators() {\n             t.super_fold_with(self)\n         } else {\n             t\n+        };\n+        if self.expand_generators {\n+            if let ty::GeneratorWitnessMIR(def_id, substs) = *t.kind() {\n+                t = self.expand_generator(def_id, substs).unwrap_or(t);\n+            }\n         }\n+        t\n     }\n }\n \n@@ -911,6 +965,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Foreign(_)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Infer(_)\n             | ty::Alias(..)\n             | ty::Param(_)\n@@ -950,6 +1005,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::Foreign(_)\n             | ty::Generator(..)\n             | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(..)\n             | ty::Infer(_)\n             | ty::Alias(..)\n             | ty::Param(_)\n@@ -1077,7 +1133,10 @@ impl<'tcx> Ty<'tcx> {\n                 false\n             }\n \n-            ty::Foreign(_) | ty::GeneratorWitness(..) | ty::Error(_) => false,\n+            ty::Foreign(_)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Error(_) => false,\n         }\n     }\n \n@@ -1173,6 +1232,7 @@ pub fn needs_drop_components<'tcx>(\n         | ty::FnPtr(_)\n         | ty::Char\n         | ty::GeneratorWitness(..)\n+        | ty::GeneratorWitnessMIR(..)\n         | ty::RawPtr(_)\n         | ty::Ref(..)\n         | ty::Str => Ok(SmallVec::new()),\n@@ -1243,7 +1303,11 @@ pub fn is_trivially_const_drop(ty: Ty<'_>) -> bool {\n \n         // Not trivial because they have components, and instead of looking inside,\n         // we'll just perform trait selection.\n-        ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(_) | ty::Adt(..) => false,\n+        ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(_)\n+        | ty::GeneratorWitnessMIR(..)\n+        | ty::Adt(..) => false,\n \n         ty::Array(ty, _) | ty::Slice(ty) => is_trivially_const_drop(ty),\n \n@@ -1304,6 +1368,7 @@ pub fn reveal_opaque_types_in_bounds<'tcx>(\n         found_recursion: false,\n         found_any_recursion: false,\n         check_recursion: false,\n+        expand_generators: false,\n         tcx,\n     };\n     val.fold_with(&mut visitor)\n@@ -1326,7 +1391,7 @@ pub fn is_doc_notable_trait(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n /// Determines whether an item is an intrinsic by Abi.\n pub fn is_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    matches!(tcx.fn_sig(def_id).abi(), Abi::RustIntrinsic | Abi::PlatformIntrinsic)\n+    matches!(tcx.fn_sig(def_id).skip_binder().abi(), Abi::RustIntrinsic | Abi::PlatformIntrinsic)\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "d7b7a094737266e4d348a958b2f0b92cff7f708b", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -100,6 +100,9 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n     fn has_opaque_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n     }\n+    fn has_generators(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_GENERATOR)\n+    }\n     fn references_error(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_ERROR)\n     }"}, {"sha": "182945b9c3db1ba01c210154cee3c1ecc015f0c6", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -190,6 +190,7 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             ty::Adt(_, substs)\n             | ty::Closure(_, substs)\n             | ty::Generator(_, substs, _)\n+            | ty::GeneratorWitnessMIR(_, substs)\n             | ty::FnDef(_, substs) => {\n                 stack.extend(substs.iter().rev());\n             }"}, {"sha": "dbba529aef7a5ea6adbf1959bd923111b42db8fd", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -18,6 +18,9 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_storage_dead\", args) => {\n                 Ok(StatementKind::StorageDead(self.parse_local(args[0])?))\n             },\n+            @call(\"mir_deinit\", args) => {\n+                Ok(StatementKind::Deinit(Box::new(self.parse_place(args[0])?)))\n+            },\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n@@ -141,12 +144,29 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n         parse_by_kind!(self, expr_id, _, \"rvalue\",\n             @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),\n+            @call(\"mir_checked\", args) => {\n+                parse_by_kind!(self, args[0], _, \"binary op\",\n+                    ExprKind::Binary { op, lhs, rhs } => Ok(Rvalue::CheckedBinaryOp(\n+                        *op, Box::new((self.parse_operand(*lhs)?, self.parse_operand(*rhs)?))\n+                    )),\n+                )\n+            },\n+            @call(\"mir_len\", args) => Ok(Rvalue::Len(self.parse_place(args[0])?)),\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n             ExprKind::AddressOf { mutability, arg } => Ok(\n                 Rvalue::AddressOf(*mutability, self.parse_place(*arg)?)\n             ),\n+            ExprKind::Binary { op, lhs, rhs } =>  Ok(\n+                Rvalue::BinaryOp(*op, Box::new((self.parse_operand(*lhs)?, self.parse_operand(*rhs)?)))\n+            ),\n+            ExprKind::Unary { op, arg } => Ok(\n+                Rvalue::UnaryOp(*op, self.parse_operand(*arg)?)\n+            ),\n+            ExprKind::Repeat { value, count } => Ok(\n+                Rvalue::Repeat(self.parse_operand(*value)?, *count)\n+            ),\n             _ => self.parse_operand(expr_id).map(Rvalue::Use),\n         )\n     }"}, {"sha": "6b960ebdb16f1291c4a6461049e9347e942daf17", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1747,8 +1747,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n                 let fake_borrow_ty = tcx.mk_imm_ref(tcx.lifetimes.re_erased, fake_borrow_deref_ty);\n-                let fake_borrow_temp =\n-                    self.local_decls.push(LocalDecl::new(fake_borrow_ty, temp_span));\n+                let mut fake_borrow_temp = LocalDecl::new(fake_borrow_ty, temp_span);\n+                fake_borrow_temp.internal = self.local_decls[matched_place.local].internal;\n+                fake_borrow_temp.local_info = Some(Box::new(LocalInfo::FakeBorrow));\n+                let fake_borrow_temp = self.local_decls.push(fake_borrow_temp);\n \n                 (matched_place, fake_borrow_temp)\n             })"}, {"sha": "1655e224ddbb5b68f16f9710bdf509f18607d922", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -439,6 +439,10 @@ fn construct_fn<'tcx>(\n     let fn_id = tcx.hir().local_def_id_to_hir_id(fn_def.did);\n     let generator_kind = tcx.generator_kind(fn_def.did);\n \n+    // The representation of thir for `-Zunpretty=thir-tree` relies on\n+    // the entry expression being the last element of `thir.exprs`.\n+    assert_eq!(expr.as_usize(), thir.exprs.len() - 1);\n+\n     // Figure out what primary body this item has.\n     let body_id = tcx.hir().body_owned_by(fn_def.did);\n     let span_with_body = tcx.hir().span_with_body(fn_id);\n@@ -637,7 +641,7 @@ fn construct_error(\n \n     let ty = tcx.ty_error();\n     let num_params = match body_owner_kind {\n-        hir::BodyOwnerKind::Fn => tcx.fn_sig(def).inputs().skip_binder().len(),\n+        hir::BodyOwnerKind::Fn => tcx.fn_sig(def).skip_binder().inputs().skip_binder().len(),\n         hir::BodyOwnerKind::Closure => {\n             let ty = tcx.type_of(def);\n             match ty.kind() {"}, {"sha": "ced251267d36f9deb95438e76ca848604a6b8b3a", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -600,32 +600,56 @@ pub struct BorrowOfMovedValue<'tcx> {\n pub struct MultipleMutBorrows {\n     #[primary_span]\n     pub span: Span,\n-    #[label]\n-    pub binding_span: Span,\n     #[subdiagnostic]\n-    pub occurences: Vec<MultipleMutBorrowOccurence>,\n-    pub name: Ident,\n+    pub occurences: Vec<Conflict>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_already_borrowed)]\n+pub struct AlreadyBorrowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<Conflict>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_already_mut_borrowed)]\n+pub struct AlreadyMutBorrowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<Conflict>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(mir_build_moved_while_borrowed)]\n+pub struct MovedWhileBorrowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub occurences: Vec<Conflict>,\n }\n \n #[derive(Subdiagnostic)]\n-pub enum MultipleMutBorrowOccurence {\n-    #[label(mutable_borrow)]\n-    Mutable {\n+pub enum Conflict {\n+    #[label(mir_build_mutable_borrow)]\n+    Mut {\n         #[primary_span]\n         span: Span,\n-        name_mut: Ident,\n+        name: Ident,\n     },\n-    #[label(immutable_borrow)]\n-    Immutable {\n+    #[label(mir_build_borrow)]\n+    Ref {\n         #[primary_span]\n         span: Span,\n-        name_immut: Ident,\n+        name: Ident,\n     },\n-    #[label(moved)]\n+    #[label(mir_build_moved)]\n     Moved {\n         #[primary_span]\n         span: Span,\n-        name_moved: Ident,\n+        name: Ident,\n     },\n }\n "}, {"sha": "94dae36154c26181757616366db754e6412999b6", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -34,4 +34,5 @@ pub fn provide(providers: &mut Providers) {\n     providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;\n     providers.thir_body = thir::cx::thir_body;\n     providers.thir_tree = thir::cx::thir_tree;\n+    providers.thir_flat = thir::cx::thir_flat;\n }"}, {"sha": "10df4b229520f3bd1f8f572353b994cb14ae273e", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -53,6 +53,16 @@ pub(crate) fn thir_body(\n }\n \n pub(crate) fn thir_tree(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n+    match thir_body(tcx, owner_def) {\n+        Ok((thir, _)) => {\n+            let thir = thir.steal();\n+            tcx.thir_tree_representation(&thir)\n+        }\n+        Err(_) => \"error\".into(),\n+    }\n+}\n+\n+pub(crate) fn thir_flat(tcx: TyCtxt<'_>, owner_def: ty::WithOptConstParam<LocalDefId>) -> String {\n     match thir_body(tcx, owner_def) {\n         Ok((thir, _)) => format!(\"{:#?}\", thir.steal()),\n         Err(_) => \"error\".into(),"}, {"sha": "2640ca56b00e9764bdab912961dfa530798e3aac", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -208,9 +208,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             // Don't report arm reachability of desugared `match $iter.into_iter() { iter => .. }`\n             // when the iterator is an uninhabited type. unreachable_code will trigger instead.\n             hir::MatchSource::ForLoopDesugar if arms.len() == 1 => {}\n-            hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n-                report_arm_reachability(&cx, &report)\n-            }\n+            hir::MatchSource::ForLoopDesugar\n+            | hir::MatchSource::Normal\n+            | hir::MatchSource::FormatArgs => report_arm_reachability(&cx, &report),\n             // Unreachable patterns in try and await expressions occur when one of\n             // the arms are an uninhabited type. Which is OK.\n             hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n@@ -926,58 +926,55 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n     sub.each_binding(|_, hir_id, span, name| {\n         match typeck_results.extract_binding_mode(sess, hir_id, span) {\n             Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n-                (Mutability::Not, Mutability::Not) => {} // Both sides are `ref`.\n-                (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`.\n-                _ => conflicts_mut_ref.push((span, name)), // `ref` + `ref mut` in either direction.\n+                // Both sides are `ref`.\n+                (Mutability::Not, Mutability::Not) => {}\n+                // 2x `ref mut`.\n+                (Mutability::Mut, Mutability::Mut) => {\n+                    conflicts_mut_mut.push(Conflict::Mut { span, name })\n+                }\n+                (Mutability::Not, Mutability::Mut) => {\n+                    conflicts_mut_ref.push(Conflict::Mut { span, name })\n+                }\n+                (Mutability::Mut, Mutability::Not) => {\n+                    conflicts_mut_ref.push(Conflict::Ref { span, name })\n+                }\n             },\n             Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n-                conflicts_move.push((span, name)) // `ref mut?` + by-move conflict.\n+                conflicts_move.push(Conflict::Moved { span, name }) // `ref mut?` + by-move conflict.\n             }\n             Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine.\n         }\n     });\n \n+    let report_mut_mut = !conflicts_mut_mut.is_empty();\n+    let report_mut_ref = !conflicts_mut_ref.is_empty();\n+    let report_move_conflict = !conflicts_move.is_empty();\n+\n+    let mut occurences = match mut_outer {\n+        Mutability::Mut => vec![Conflict::Mut { span: binding_span, name }],\n+        Mutability::Not => vec![Conflict::Ref { span: binding_span, name }],\n+    };\n+    occurences.extend(conflicts_mut_mut);\n+    occurences.extend(conflicts_mut_ref);\n+    occurences.extend(conflicts_move);\n+\n     // Report errors if any.\n-    if !conflicts_mut_mut.is_empty() {\n+    if report_mut_mut {\n         // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-        let mut occurences = vec![];\n-\n-        for (span, name_mut) in conflicts_mut_mut {\n-            occurences.push(MultipleMutBorrowOccurence::Mutable { span, name_mut });\n-        }\n-        for (span, name_immut) in conflicts_mut_ref {\n-            occurences.push(MultipleMutBorrowOccurence::Immutable { span, name_immut });\n-        }\n-        for (span, name_moved) in conflicts_move {\n-            occurences.push(MultipleMutBorrowOccurence::Moved { span, name_moved });\n-        }\n-        sess.emit_err(MultipleMutBorrows { span: pat.span, binding_span, occurences, name });\n-    } else if !conflicts_mut_ref.is_empty() {\n+        sess.emit_err(MultipleMutBorrows { span: pat.span, occurences });\n+    } else if report_mut_ref {\n         // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n-        let (primary, also) = match mut_outer {\n-            Mutability::Mut => (\"mutable\", \"immutable\"),\n-            Mutability::Not => (\"immutable\", \"mutable\"),\n+        match mut_outer {\n+            Mutability::Mut => {\n+                sess.emit_err(AlreadyMutBorrowed { span: pat.span, occurences });\n+            }\n+            Mutability::Not => {\n+                sess.emit_err(AlreadyBorrowed { span: pat.span, occurences });\n+            }\n         };\n-        let msg =\n-            format!(\"cannot borrow value as {} because it is also borrowed as {}\", also, primary);\n-        let mut err = sess.struct_span_err(pat.span, &msg);\n-        err.span_label(binding_span, format!(\"{} borrow, by `{}`, occurs here\", primary, name));\n-        for (span, name) in conflicts_mut_ref {\n-            err.span_label(span, format!(\"{} borrow, by `{}`, occurs here\", also, name));\n-        }\n-        for (span, name) in conflicts_move {\n-            err.span_label(span, format!(\"also moved into `{}` here\", name));\n-        }\n-        err.emit();\n-    } else if !conflicts_move.is_empty() {\n+    } else if report_move_conflict {\n         // Report by-ref and by-move conflicts, e.g. `ref x @ y`.\n-        let mut err =\n-            sess.struct_span_err(pat.span, \"cannot move out of value because it is borrowed\");\n-        err.span_label(binding_span, format!(\"value borrowed, by `{}`, here\", name));\n-        for (span, name) in conflicts_move {\n-            err.span_label(span, format!(\"value moved into `{}` here\", name));\n-        }\n-        err.emit();\n+        sess.emit_err(MovedWhileBorrowed { span: pat.span, occurences });\n     }\n }\n "}, {"sha": "ff88d00135173ec90be84ffdef34170ea2d1f005", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -192,7 +192,7 @@ impl<'tcx> ConstToPat<'tcx> {\n         let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n             self.tcx(),\n             self.param_env,\n-            ObligationCause::misc(self.span, self.id),\n+            ObligationCause::misc(self.span, self.id.owner.def_id),\n             partial_eq_trait_id,\n             0,\n             [ty, ty],"}, {"sha": "2890fa32cc915fdf540f2ee66ce73d7afc44c31b", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -271,6 +271,7 @@ impl<'a, 'tcx> Analysis<'tcx> for MaybeTransitiveLiveLocals<'a> {\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => None,\n         };\n         if let Some(destination) = destination {"}, {"sha": "fcf0ce9d82118815eadbb0229be5bac3e49afe21", "filename": "compiler/rustc_mir_dataflow/src/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fstorage_liveness.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -141,6 +141,7 @@ impl<'mir, 'tcx> crate::GenKillAnalysis<'tcx> for MaybeRequiresStorage<'mir, 'tc\n             StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::FakeRead(..)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop\n             | StatementKind::Retag(..)\n             | StatementKind::Intrinsic(..)"}, {"sha": "0195693a7cb0e6d9bf8639e83d8e96a5b59797a3", "filename": "compiler/rustc_mir_dataflow/src/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fbuilder.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -331,6 +331,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {}\n         }\n     }"}, {"sha": "6bdbda909d7bdf02da963730db84fa2a3d2be991", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -84,7 +84,8 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::Retag(..) => {\n                 // We don't track references.\n             }\n-            StatementKind::Nop\n+            StatementKind::ConstEvalCounter\n+            | StatementKind::Nop\n             | StatementKind::FakeRead(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::AscribeUserType(..) => (),"}, {"sha": "3e7571aa7a2e7f303fa0e02cc6fbd1f51f7906ac", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -1,17 +1,11 @@\n-use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n \n use crate::util;\n use crate::MirLint;\n \n-pub(crate) fn provide(providers: &mut Providers) {\n-    *providers = Providers { unsafe_derive_on_repr_packed, ..*providers };\n-}\n-\n pub struct CheckPackedRef;\n \n impl<'tcx> MirLint<'tcx> for CheckPackedRef {\n@@ -30,32 +24,6 @@ struct PackedRefChecker<'a, 'tcx> {\n     source_info: SourceInfo,\n }\n \n-fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    // FIXME: when we make this a hard error, this should have its\n-    // own error code.\n-\n-    let extra = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-        \"with type or const parameters\"\n-    } else {\n-        \"that does not derive `Copy`\"\n-    };\n-    let message = format!(\n-        \"`{}` can't be derived on this `#[repr(packed)]` struct {}\",\n-        tcx.item_name(tcx.trait_id_of_impl(def_id.to_def_id()).expect(\"derived trait name\")),\n-        extra\n-    );\n-\n-    tcx.struct_span_lint_hir(\n-        UNALIGNED_REFERENCES,\n-        lint_hir_id,\n-        tcx.def_span(def_id),\n-        message,\n-        |lint| lint,\n-    );\n-}\n-\n impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         // Make sure we know where in the MIR we are.\n@@ -73,14 +41,13 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 let def_id = self.body.source.instance.def_id();\n-                if let Some(impl_def_id) = self\n-                    .tcx\n-                    .impl_of_method(def_id)\n-                    .filter(|&def_id| self.tcx.is_builtin_derive(def_id))\n+                if let Some(impl_def_id) = self.tcx.impl_of_method(def_id)\n+                    && self.tcx.is_builtin_derive(impl_def_id)\n                 {\n-                    // If a method is defined in the local crate,\n-                    // the impl containing that method should also be.\n-                    self.tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());\n+                    // If we ever reach here it means that the generated derive\n+                    // code is somehow doing an unaligned reference, which it\n+                    // shouldn't do.\n+                    unreachable!();\n                 } else {\n                     let source_info = self.source_info;\n                     let lint_root = self.body.source_scopes[source_info.scope]"}, {"sha": "8afa53313fc2840e838cc13e8d5d4170a3151de3", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -104,6 +104,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n             | StatementKind::AscribeUserType(..)\n             | StatementKind::Coverage(..)\n             | StatementKind::Intrinsic(..)\n+            | StatementKind::ConstEvalCounter\n             | StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }\n@@ -445,7 +446,7 @@ impl<'tcx> intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'_, 'tcx> {\n         _fd: &'tcx hir::FnDecl<'tcx>,\n         b: hir::BodyId,\n         _s: rustc_span::Span,\n-        _id: HirId,\n+        _id: LocalDefId,\n     ) {\n         if matches!(fk, intravisit::FnKind::Closure) {\n             self.visit_body(self.tcx.hir().body(b))"}, {"sha": "da101ca7ad279e32a64967ba76fa7ef75c999d2e", "filename": "compiler/rustc_mir_transform/src/const_goto.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -57,6 +57,15 @@ impl<'tcx> MirPass<'tcx> for ConstGoto {\n }\n \n impl<'tcx> Visitor<'tcx> for ConstGotoOptimizationFinder<'_, 'tcx> {\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        if data.is_cleanup {\n+            // Because of the restrictions around control flow in cleanup blocks, we don't perform\n+            // this optimization at all in such blocks.\n+            return;\n+        }\n+        self.super_basic_block_data(block, data);\n+    }\n+\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         let _: Option<_> = try {\n             let target = terminator.kind.as_goto()?;"}, {"sha": "182b3015dd7d784c4ad215d834d749e2915d73e6", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aaa9ea5c05519f8e4676333cade3183b60fcc87/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=0aaa9ea5c05519f8e4676333cade3183b60fcc87", "patch": "@@ -0,0 +1,178 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::visit::*;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_mir_dataflow::impls::borrowed_locals;\n+\n+use crate::ssa::SsaLocals;\n+use crate::MirPass;\n+\n+/// Unify locals that copy each other.\n+///\n+/// We consider patterns of the form\n+///   _a = rvalue\n+///   _b = move? _a\n+///   _c = move? _a\n+///   _d = move? _c\n+/// where each of the locals is only assigned once.\n+///\n+/// We want to replace all those locals by `_a`, either copied or moved.\n+pub struct CopyProp;\n+\n+impl<'tcx> MirPass<'tcx> for CopyProp {\n+    fn is_enabled(&self, sess: &rustc_session::Session) -> bool {\n+        sess.mir_opt_level() >= 4\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self, tcx, body))]\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(def_id = ?body.source.def_id());\n+        propagate_ssa(tcx, body);\n+    }\n+}\n+\n+fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n+    let borrowed_locals = borrowed_locals(body);\n+    let ssa = SsaLocals::new(tcx, param_env, body, &borrowed_locals);\n+\n+    let fully_moved = fully_moved_locals(&ssa, body);\n+    debug!(?fully_moved);\n+\n+    let mut storage_to_remove = BitSet::new_empty(fully_moved.domain_size());\n+    for (local, &head) in ssa.copy_classes().iter_enumerated() {\n+        if local != head {\n+            storage_to_remove.insert(head);\n+        }\n+    }\n+\n+    let any_replacement = ssa.copy_classes().iter_enumerated().any(|(l, &h)| l != h);\n+\n+    Replacer {\n+        tcx,\n+        copy_classes: &ssa.copy_classes(),\n+        fully_moved,\n+        borrowed_locals,\n+        storage_to_remove,\n+    }\n+    .visit_body_preserves_cfg(body);\n+\n+    if any_replacement {\n+        crate::simplify::remove_unused_definitions(body);\n+    }\n+}\n+\n+/// `SsaLocals` computed equivalence classes between locals considering copy/move assignments.\n+///\n+/// This function also returns whether all the `move?` in the pattern are `move` and not copies.\n+/// A local which is in the bitset can be replaced by `move _a`. Otherwise, it must be\n+/// replaced by `copy _a`, as we cannot move multiple times from `_a`.\n+///\n+/// If an operand copies `_c`, it must happen before the assignment `_d = _c`, otherwise it is UB.\n+/// This means that replacing it by a copy of `_a` if ok, since this copy happens before `_c` is\n+/// moved, and therefore that `_d` is moved.\n+#[instrument(level = \"trace\", skip(ssa, body))]\n+fn fully_moved_locals(ssa: &SsaLocals, body: &Body<'_>) -> BitSet<Local> {\n+    let mut fully_moved = BitSet::new_filled(body.local_decls.len());\n+\n+    for (_, rvalue) in ssa.assignments(body) {\n+        let (Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) | Rvalue::CopyForDeref(place))\n+            = rvalue\n+        else { continue };\n+\n+        let Some(rhs) = place.as_local() else { continue };\n+        if !ssa.is_ssa(rhs) {\n+            continue;\n+        }\n+\n+        if let Rvalue::Use(Operand::Copy(_)) | Rvalue::CopyForDeref(_) = rvalue {\n+            fully_moved.remove(rhs);\n+        }\n+    }\n+\n+    ssa.meet_copy_equivalence(&mut fully_moved);\n+\n+    fully_moved\n+}\n+\n+/// Utility to help performing subtitution of `*pattern` by `target`.\n+struct Replacer<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    fully_moved: BitSet<Local>,\n+    storage_to_remove: BitSet<Local>,\n+    borrowed_locals: BitSet<Local>,\n+    copy_classes: &'a IndexVec<Local, Local>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_local(&mut self, local: &mut Local, ctxt: PlaceContext, _: Location) {\n+        let new_local = self.copy_classes[*local];\n+        match ctxt {\n+            // Do not modify the local in storage statements.\n+            PlaceContext::NonUse(NonUseContext::StorageLive | NonUseContext::StorageDead) => {}\n+            // The local should have been marked as non-SSA.\n+            PlaceContext::MutatingUse(_) => assert_eq!(*local, new_local),\n+            // We access the value.\n+            _ => *local = new_local,\n+        }\n+    }\n+\n+    fn visit_place(&mut self, place: &mut Place<'tcx>, ctxt: PlaceContext, loc: Location) {\n+        if let Some(new_projection) = self.process_projection(&place.projection, loc) {\n+            place.projection = self.tcx().intern_place_elems(&new_projection);\n+        }\n+\n+        let observes_address = match ctxt {\n+            PlaceContext::NonMutatingUse(\n+                NonMutatingUseContext::SharedBorrow\n+                | NonMutatingUseContext::ShallowBorrow\n+                | NonMutatingUseContext::UniqueBorrow\n+                | NonMutatingUseContext::AddressOf,\n+            ) => true,\n+            // For debuginfo, merging locals is ok.\n+            PlaceContext::NonUse(NonUseContext::VarDebugInfo) => {\n+                self.borrowed_locals.contains(place.local)\n+            }\n+            _ => false,\n+        };\n+        if observes_address && !place.is_indirect() {\n+            // We observe the address of `place.local`. Do not replace it.\n+        } else {\n+            self.visit_local(\n+                &mut place.local,\n+                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                loc,\n+            )\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, loc: Location) {\n+        if let Operand::Move(place) = *operand\n+            && let Some(local) = place.as_local()\n+            && !self.fully_moved.contains(local)\n+        {\n+            *operand = Operand::Copy(place);\n+        }\n+        self.super_operand(operand, loc);\n+    }\n+\n+    fn visit_statement(&mut self, stmt: &mut Statement<'tcx>, loc: Location) {\n+        if let StatementKind::StorageDead(l) = stmt.kind\n+            && self.storage_to_remove.contains(l)\n+        {\n+            stmt.make_nop();\n+        } else if let StatementKind::Assign(box (ref place, ref mut rvalue)) = stmt.kind\n+            && place.as_local().is_some()\n+        {\n+            // Do not replace assignments.\n+            self.visit_rvalue(rvalue, loc)\n+        } else {\n+            self.super_statement(stmt, loc);\n+        }\n+    }\n+}"}]}