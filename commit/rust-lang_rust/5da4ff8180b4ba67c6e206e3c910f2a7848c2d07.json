{"sha": "5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYTRmZjgxODBiNGJhNjdjNmUyMDZlM2M5MTBmMmE3ODQ4YzJkMDc=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-04-13T20:58:16Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2018-06-24T21:10:20Z"}, "message": "Attempt to fix hygiene for global_allocator", "tree": {"sha": "91a0f13d45e1de8189316ca32a711902cc5a9a56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a0f13d45e1de8189316ca32a711902cc5a9a56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "html_url": "https://github.com/rust-lang/rust/commit/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01cc982e936120acb0424e41de14e42ba2d88c6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/01cc982e936120acb0424e41de14e42ba2d88c6f", "html_url": "https://github.com/rust-lang/rust/commit/01cc982e936120acb0424e41de14e42ba2d88c6f"}], "stats": {"total": 95, "additions": 74, "deletions": 21}, "files": [{"sha": "cea1807cfba63081d79d18a673b66a2def7c4d9d", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_imports, unused_variables, dead_code)]\n+\n use rustc::middle::allocator::AllocatorKind;\n use rustc_errors;\n use syntax::ast::{Attribute, Crate, LitKind, StrStyle};\n@@ -34,13 +36,15 @@ pub fn modify(\n     sess: &ParseSess,\n     resolver: &mut Resolver,\n     krate: Crate,\n+    crate_name: String,\n     handler: &rustc_errors::Handler,\n ) -> ast::Crate {\n     ExpandAllocatorDirectives {\n         handler,\n         sess,\n         resolver,\n         found: false,\n+        crate_name: Some(crate_name),\n     }.fold_crate(krate)\n }\n \n@@ -49,6 +53,7 @@ struct ExpandAllocatorDirectives<'a> {\n     handler: &'a rustc_errors::Handler,\n     sess: &'a ParseSess,\n     resolver: &'a mut Resolver,\n+    crate_name: Option<String>,\n }\n \n impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n@@ -77,44 +82,44 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n         }\n         self.found = true;\n \n+        // Create a fresh Mark for the new macro expansion we are about to do\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n+            call_site: item.span,\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(name)),\n             allow_internal_unstable: true,\n             allow_internal_unsafe: false,\n             edition: hygiene::default_edition(),\n         });\n+\n+        // Tie the span to the macro expansion info we just created\n         let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-        let ecfg = ExpansionConfig::default(name.to_string());\n+\n+        // Create an expansion config\n+        let ecfg = ExpansionConfig::default(self.crate_name.take().unwrap());\n+\n+        // Generate a bunch of new items using the AllocFnFactory\n         let mut f = AllocFnFactory {\n             span,\n             kind: AllocatorKind::Global,\n             global: item.ident,\n-            core: Ident::from_str(\"core\"),\n+            core: Ident::with_empty_ctxt(Symbol::gensym(\"core\")),\n             cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n         };\n-        let super_path = f.cx.path(f.span, vec![Ident::from_str(\"super\"), f.global]);\n-        let mut items = vec![\n-            f.cx.item_extern_crate(f.span, f.core),\n-            f.cx.item_use_simple(\n-                f.span,\n-                respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n-                super_path,\n-            ),\n-        ];\n-        for method in ALLOCATOR_METHODS {\n-            items.push(f.allocator_fn(method));\n-        }\n-        let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n-        let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n-        let module = f.cx.monotonic_expander().fold_item(module).pop().unwrap();\n+\n+        let extcore = {\n+            let extcore = f.cx.item_extern_crate(item.span, f.core);\n+            f.cx.monotonic_expander().fold_item(extcore).pop().unwrap()\n+        };\n \n         let mut ret = SmallVector::new();\n         ret.push(item);\n-        ret.push(module);\n+        ret.push(extcore);\n+        ret.extend(ALLOCATOR_METHODS.iter().map(|method| {\n+            let method = f.allocator_fn(method);\n+            f.cx.monotonic_expander().fold_item(method).pop().unwrap()\n+        }));\n         return ret;\n     }\n \n@@ -168,6 +173,7 @@ impl<'a> AllocFnFactory<'a> {\n         let method = self.cx.path(\n             self.span,\n             vec![\n+                Ident::from_str(\"self\"),\n                 self.core,\n                 Ident::from_str(\"alloc\"),\n                 Ident::from_str(\"GlobalAlloc\"),\n@@ -218,6 +224,7 @@ impl<'a> AllocFnFactory<'a> {\n                 let layout_new = self.cx.path(\n                     self.span,\n                     vec![\n+                        Ident::from_str(\"self\"),\n                         self.core,\n                         Ident::from_str(\"alloc\"),\n                         Ident::from_str(\"Layout\"),"}, {"sha": "feeac9d938b6a4b01a352293d6fa54b0a355d2b6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "patch": "@@ -1051,10 +1051,19 @@ where\n         });\n     }\n \n+    // Expand global allocators, which are treated as an in-tree proc macro\n     krate = time(sess, \"creating allocators\", || {\n-        allocator::expand::modify(&sess.parse_sess, &mut resolver, krate, sess.diagnostic())\n+        allocator::expand::modify(\n+            &sess.parse_sess,\n+            &mut resolver,\n+            krate,\n+            crate_name.to_string(),\n+            sess.diagnostic(),\n+        )\n     });\n \n+    // Done with macro expansion!\n+\n     after_expand(&krate)?;\n \n     if sess.opts.debugging_opts.input_stats {"}, {"sha": "b73068244b10b85c5ad7844054bc61180f1bab12", "filename": "src/test/ui/allocator-submodule.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/src%2Ftest%2Fui%2Fallocator-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da4ff8180b4ba67c6e206e3c910f2a7848c2d07/src%2Ftest%2Fui%2Fallocator-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.rs?ref=5da4ff8180b4ba67c6e206e3c910f2a7848c2d07", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that it is possible to create a global allocator in a submodule, rather than in the crate\n+// root.\n+\n+#![feature(alloc, allocator_api, global_allocator)]\n+\n+extern crate alloc;\n+\n+use std::alloc::{GlobalAlloc, Layout, Opaque};\n+\n+struct MyAlloc;\n+\n+unsafe impl GlobalAlloc for MyAlloc {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        0 as usize as *mut Opaque\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {}\n+}\n+\n+mod submod {\n+    use super::MyAlloc;\n+\n+    #[global_allocator]\n+    static MY_HEAP: MyAlloc = MyAlloc;\n+}\n+\n+fn main() {}"}]}