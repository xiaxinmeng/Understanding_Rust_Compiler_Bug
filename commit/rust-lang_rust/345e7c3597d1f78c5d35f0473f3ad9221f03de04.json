{"sha": "345e7c3597d1f78c5d35f0473f3ad9221f03de04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NWU3YzM1OTdkMWY3OGM1ZDM1ZjA0NzNmM2FkOTIyMWYwM2RlMDQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-28T19:13:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-30T19:21:50Z"}, "message": "resolve: Make sure indeterminate and inconsistent macro resolutions always generate errors", "tree": {"sha": "84e6962b2d713433726aea9beae43a073ce8878f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84e6962b2d713433726aea9beae43a073ce8878f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/345e7c3597d1f78c5d35f0473f3ad9221f03de04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/345e7c3597d1f78c5d35f0473f3ad9221f03de04", "html_url": "https://github.com/rust-lang/rust/commit/345e7c3597d1f78c5d35f0473f3ad9221f03de04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/345e7c3597d1f78c5d35f0473f3ad9221f03de04/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d09399c1289a20b1c258153f005f2604f9ec46", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d09399c1289a20b1c258153f005f2604f9ec46", "html_url": "https://github.com/rust-lang/rust/commit/74d09399c1289a20b1c258153f005f2604f9ec46"}], "stats": {"total": 86, "additions": 69, "deletions": 17}, "files": [{"sha": "ae1cf6046fbd4802526889d010bdf57aaa75a9cd", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=345e7c3597d1f78c5d35f0473f3ad9221f03de04", "patch": "@@ -210,7 +210,7 @@ impl Def {\n             Def::Upvar(..) => \"closure capture\",\n             Def::Label(..) => \"label\",\n             Def::SelfTy(..) => \"self type\",\n-            Def::Macro(..) => \"macro\",\n+            Def::Macro(.., macro_kind) => macro_kind.descr(),\n             Def::GlobalAsm(..) => \"global asm\",\n             Def::Err => \"unresolved item\",\n         }"}, {"sha": "e05c6bf59edbeaed59b0d229a72a8f24f1772a5d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=345e7c3597d1f78c5d35f0473f3ad9221f03de04", "patch": "@@ -1000,7 +1000,7 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span, MacroKind)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, MacroKind, Option<Def>)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n \n     // Macro invocations that can expand into items in this module."}, {"sha": "0cc59e3129c30eb55550d9d21344a0783beb6314", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=345e7c3597d1f78c5d35f0473f3ad9221f03de04", "patch": "@@ -107,6 +107,14 @@ impl<'a> MacroBinding<'a> {\n             MacroBinding::Legacy(_) => panic!(\"unexpected MacroBinding::Legacy\"),\n         }\n     }\n+\n+    pub fn def_ignoring_ambiguity(self) -> Def {\n+        match self {\n+            MacroBinding::Legacy(binding) => Def::Macro(binding.def_id, MacroKind::Bang),\n+            MacroBinding::Global(binding) | MacroBinding::Modern(binding) =>\n+                binding.def_ignoring_ambiguity(),\n+        }\n+    }\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n@@ -476,7 +484,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         self.current_module.nearest_item_scope().legacy_macro_resolutions.borrow_mut()\n-            .push((scope, path[0], span, kind));\n+            .push((scope, path[0], kind, result.ok()));\n \n         result\n     }\n@@ -622,10 +630,33 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, ident, span, kind) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, kind, def) in module.legacy_macro_resolutions.borrow().iter() {\n+            let span = ident.span;\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n             let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident, true);\n             let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, true, span);\n+\n+            let check_consistency = |this: &Self, binding: MacroBinding| {\n+                if let Some(def) = def {\n+                    if this.ambiguity_errors.is_empty() && this.disallowed_shadowing.is_empty() &&\n+                       binding.def_ignoring_ambiguity() != def {\n+                        // Make sure compilation does not succeed if preferred macro resolution\n+                        // has changed after the macro had been expanded. In theory all such\n+                        // situations should be reported as ambiguity errors, so this is span-bug.\n+                        span_bug!(span, \"inconsistent resolution for a macro\");\n+                    }\n+                } else {\n+                    // It's possible that the macro was unresolved (indeterminate) and silently\n+                    // expanded into a dummy fragment for recovery during expansion.\n+                    // Now, post-expansion, the resolution may succeed, but we can't change the\n+                    // past and need to report an error.\n+                    let msg =\n+                        format!(\"cannot determine resolution for the {} `{}`\", kind.descr(), ident);\n+                    let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n+                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n+                }\n+            };\n+\n             match (legacy_resolution, resolution) {\n                 (Some(MacroBinding::Legacy(legacy_binding)), Ok(MacroBinding::Modern(binding))) => {\n                     let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n@@ -635,24 +666,35 @@ impl<'a> Resolver<'a> {\n                         .span_note(binding.span, &msg2)\n                         .emit();\n                 },\n-                (Some(MacroBinding::Global(binding)), Ok(MacroBinding::Global(_))) => {\n-                    self.record_use(ident, MacroNS, binding, span);\n-                    self.err_if_macro_use_proc_macro(ident.name, span, binding);\n-                },\n                 (None, Err(_)) => {\n-                    let msg = match kind {\n-                        MacroKind::Bang =>\n-                            format!(\"cannot find macro `{}!` in this scope\", ident),\n-                        MacroKind::Attr =>\n-                            format!(\"cannot find attribute macro `{}` in this scope\", ident),\n-                        MacroKind::Derive =>\n-                            format!(\"cannot find derive macro `{}` in this scope\", ident),\n-                    };\n+                    assert!(def.is_none());\n+                    let bang = if kind == MacroKind::Bang { \"!\" } else { \"\" };\n+                    let msg =\n+                        format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n                     let mut err = self.session.struct_span_err(span, &msg);\n                     self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n-                _ => {},\n+                (Some(MacroBinding::Modern(_)), _) | (_, Ok(MacroBinding::Legacy(_))) => {\n+                    span_bug!(span, \"impossible macro resolution result\");\n+                }\n+                // OK, unambiguous resolution\n+                (Some(binding), Err(_)) | (None, Ok(binding)) |\n+                // OK, legacy wins over global even if their definitions are different\n+                (Some(binding @ MacroBinding::Legacy(_)), Ok(MacroBinding::Global(_))) |\n+                // OK, modern wins over global even if their definitions are different\n+                (Some(MacroBinding::Global(_)), Ok(binding @ MacroBinding::Modern(_))) => {\n+                    check_consistency(self, binding);\n+                }\n+                (Some(MacroBinding::Global(binding1)), Ok(MacroBinding::Global(binding2))) => {\n+                    if binding1.def() != binding2.def() {\n+                        span_bug!(span, \"mismatch between same global macro resolutions\");\n+                    }\n+                    check_consistency(self, MacroBinding::Global(binding1));\n+\n+                    self.record_use(ident, MacroNS, binding1, span);\n+                    self.err_if_macro_use_proc_macro(ident.name, span, binding1);\n+                },\n             };\n         }\n     }"}, {"sha": "7c2eb540a30bb1da09530b74b93b002ea1016db0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/345e7c3597d1f78c5d35f0473f3ad9221f03de04/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=345e7c3597d1f78c5d35f0473f3ad9221f03de04", "patch": "@@ -572,6 +572,16 @@ pub enum MacroKind {\n     Derive,\n }\n \n+impl MacroKind {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            MacroKind::Bang => \"macro\",\n+            MacroKind::Attr => \"attribute macro\",\n+            MacroKind::Derive => \"derive macro\",\n+        }\n+    }\n+}\n+\n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n     /// A syntax extension that is attached to an item and creates new items"}]}