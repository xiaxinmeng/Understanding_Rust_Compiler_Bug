{"sha": "2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkYzViNjAyZWVlMzVkNzBlOGU2ZTUwNmE3ZWEwN2I2YzdlMDE5N2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-22T03:50:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-22T03:50:02Z"}, "message": "Auto merge of #71410 - JohnTitor:rollup-vh6dut5, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #70998 (Suggest `-> impl Trait` and `-> Box<dyn Trait>` on fn that doesn't return)\n - #71236 (Remove unused rustc_serialize::hex module)\n - #71366 (Use assoc int consts3)\n - #71372 (Fix #! (shebang) stripping account space issue)\n - #71384 (Fix stage0.txt version number comment)\n - #71390 (Fix incorrect description of E0690)\n - #71399 (Clean up E0554 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "43279f0eee2bf88591559449b56f87b217873337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43279f0eee2bf88591559449b56f87b217873337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "html_url": "https://github.com/rust-lang/rust/commit/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70f4f320b02cfd511c78389a6db1628285277410", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f4f320b02cfd511c78389a6db1628285277410", "html_url": "https://github.com/rust-lang/rust/commit/70f4f320b02cfd511c78389a6db1628285277410"}, {"sha": "66eaead0e2088e5bad6e5c24287a5f061aab4844", "url": "https://api.github.com/repos/rust-lang/rust/commits/66eaead0e2088e5bad6e5c24287a5f061aab4844", "html_url": "https://github.com/rust-lang/rust/commit/66eaead0e2088e5bad6e5c24287a5f061aab4844"}], "stats": {"total": 533, "additions": 209, "deletions": 324}, "files": [{"sha": "0ee4e9dc3c1ddce9fb927a938b549804d73c47a3", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -3577,7 +3577,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"rustc_ast\",\n- \"rustc_data_structures\",\n  \"rustc_span\",\n ]\n \n@@ -3594,7 +3593,6 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n ]\n \n [[package]]\n@@ -3666,7 +3664,6 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_incremental\",\n  \"rustc_index\",\n- \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3809,7 +3806,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n- \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3879,7 +3875,6 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_incremental\",\n- \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_middle\",\n@@ -3924,7 +3919,6 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n- \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3986,10 +3980,8 @@ dependencies = [\n  \"backtrace\",\n  \"bitflags\",\n  \"byteorder\",\n- \"jobserver\",\n  \"log\",\n  \"measureme\",\n- \"parking_lot 0.10.2\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -4023,7 +4015,6 @@ dependencies = [\n  \"polonius-engine\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n- \"rustc_ast_pretty\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4079,7 +4070,6 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.0.0\",\n  \"unicode-normalization\",\n ]\n \n@@ -4092,10 +4082,8 @@ dependencies = [\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n- \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4143,7 +4131,6 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n- \"rustc_macros\",\n  \"rustc_span\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -4296,10 +4283,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_infer\",\n- \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_span\",\n- \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"smallvec 1.0.0\",\n ]"}, {"sha": "e9fc1b612dd39aa385edd5a5912ae0a44acbadd5", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -2,7 +2,6 @@ use crate::cmp;\n use crate::fmt;\n use crate::intrinsics;\n use crate::ops::{Add, AddAssign, Try};\n-use crate::usize;\n \n use super::{from_fn, LoopState};\n use super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};"}, {"sha": "37369289c512e9b3314d1b7c1b79dc7d48bdb3d6", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -1,7 +1,6 @@\n use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Add, Sub, Try};\n-use crate::usize;\n \n use super::{FusedIterator, TrustedLen};\n "}, {"sha": "d76fa89bd012c22f4167b25e336a4aa917d321f0", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -1,6 +1,5 @@\n use crate::fmt;\n use crate::marker;\n-use crate::usize;\n \n use super::{FusedIterator, TrustedLen};\n "}, {"sha": "32f4956328975b4c9b748f9cf86df5482e605061", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -265,7 +265,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_infinite(self) -> bool {\n-        self.abs_private() == INFINITY\n+        self.abs_private() == Self::INFINITY\n     }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n@@ -287,7 +287,7 @@ impl f32 {\n     pub fn is_finite(self) -> bool {\n         // There's no need to handle NaN separately: if self is NaN,\n         // the comparison is not true, exactly as desired.\n-        self.abs_private() < INFINITY\n+        self.abs_private() < Self::INFINITY\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,"}, {"sha": "b38fd804ee80fc9cddec632247aa8c370170e1cd", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -264,7 +264,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_infinite(self) -> bool {\n-        self.abs_private() == INFINITY\n+        self.abs_private() == Self::INFINITY\n     }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n@@ -286,7 +286,7 @@ impl f64 {\n     pub fn is_finite(self) -> bool {\n         // There's no need to handle NaN separately: if self is NaN,\n         // the comparison is not true, exactly as desired.\n-        self.abs_private() < INFINITY\n+        self.abs_private() < Self::INFINITY\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,"}, {"sha": "c43536c6fcca86585db29821f1772c2f3fbc94dc", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -2,7 +2,6 @@\n \n use crate::num::dec2flt::rawfp::RawFloat;\n use crate::num::FpCategory;\n-use crate::{f32, f64};\n \n /// Decoded unsigned finite value, such that:\n ///"}, {"sha": "9bf56e93d896f1d96db0c7de7b6e0053ea62b1e6", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -123,7 +123,6 @@ functions.\n )]\n \n pub use self::decoder::{decode, DecodableFloat, Decoded, FullDecoded};\n-use crate::i16;\n \n pub mod decoder;\n pub mod estimator;"}, {"sha": "5035445ba939fe7a0e23969ac51ad65fd93bed4b", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -14,14 +14,14 @@ macro_rules! int_module {\n             concat!(\"The smallest value that can be represented by this integer type.\n Use [`\", stringify!($T), \"::MIN\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MIN) instead.\"),\n             #[$attr]\n-            pub const MIN: $T = $T::min_value();\n+            pub const MIN: $T = $T::MIN;\n         }\n \n         doc_comment! {\n             concat!(\"The largest value that can be represented by this integer type.\n Use [`\", stringify!($T), \"::MAX\", \"`](../../std/primitive.\", stringify!($T), \".html#associatedconstant.MAX) instead.\"),\n             #[$attr]\n-            pub const MAX: $T = $T::max_value();\n+            pub const MAX: $T = $T::MAX;\n         }\n     )\n }"}, {"sha": "3b13ed5fed396918ac7ab575eb6e17ba3a3ab54b", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -34,7 +34,7 @@ fn repeat_byte(b: u8) -> usize {\n #[cfg(not(target_pointer_width = \"16\"))]\n #[inline]\n fn repeat_byte(b: u8) -> usize {\n-    (b as usize) * (crate::usize::MAX / 255)\n+    (b as usize) * (usize::MAX / 255)\n }\n \n /// Returns the first index matching the byte `x` in `text`."}, {"sha": "dc395bcfba5ccf5be2d38f62cdf686da8bf27910", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -28,7 +28,6 @@ use crate::cmp;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::fmt;\n use crate::intrinsics::{assume, exact_div, is_aligned_and_not_null, unchecked_sub};\n-use crate::isize;\n use crate::iter::*;\n use crate::marker::{self, Copy, Send, Sized, Sync};\n use crate::mem;"}, {"sha": "1a2b612b2f95c531787802548b8e31f28a9fd1db", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -46,7 +46,6 @@\n use crate::cmp;\n use crate::fmt;\n use crate::slice::memchr;\n-use crate::usize;\n \n // Pattern\n "}, {"sha": "ed1d5d46db5c4c02c7b793f3ad240edb9f68d007", "filename": "src/libcore/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -12,9 +12,9 @@\n //! assert_eq!(Duration::new(5, 0), Duration::from_secs(5));\n //! ```\n \n+use crate::fmt;\n use crate::iter::Sum;\n use crate::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n-use crate::{fmt, u64};\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;"}, {"sha": "81d98721089f59da3e6853902771752da3f83026", "filename": "src/librustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -12,5 +12,4 @@ doctest = false\n [dependencies]\n log = \"0.4\"\n rustc_span = { path = \"../librustc_span\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "a7a7e3dcc5f028ef935d1b78d6c2bd654630a76c", "filename": "src/librustc_attr/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -17,6 +17,5 @@ rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_macros = { path = \"../librustc_macros\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_session = { path = \"../librustc_session\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "e8bfc87aef5ea58ab1c350777cc4cfd5e512809a", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -34,4 +34,3 @@ rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_session = { path = \"../librustc_session\" }\n-rustc_metadata = { path = \"../librustc_metadata\" }"}, {"sha": "bc2da535fd3728b8cd412cd42746c96575e17447", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -29,8 +29,6 @@ extern crate log;\n #[macro_use]\n extern crate cfg_if;\n \n-pub use rustc_serialize::hex::ToHex;\n-\n #[inline(never)]\n #[cold]\n pub fn cold_path<F: FnOnce() -> R, R>(f: F) -> R {"}, {"sha": "e55fa4c6ede8b458a1db11b2ab3f24ba088a5b45", "filename": "src/librustc_error_codes/error_codes/E0554.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0554.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0554.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0554.md?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -1,7 +1,7 @@\n Feature attributes are only allowed on the nightly release channel. Stable or\n beta compilers will not comply.\n \n-Example of erroneous code (on a stable compiler):\n+Erroneous code example:\n \n ```ignore (depends on release channel)\n #![feature(non_ascii_idents)] // error: `#![feature]` may not be used on the"}, {"sha": "1673456580a85ad33c61a5b8447ac0604e9f243e", "filename": "src/librustc_error_codes/error_codes/E0690.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0690.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0690.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0690.md?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -14,7 +14,7 @@ struct LengthWithUnit<U> { // error: transparent struct needs exactly one\n Because transparent structs are represented exactly like one of their fields at\n run time, said field must be uniquely determined. If there is no field, or if\n there are multiple fields, it is not clear how the struct should be represented.\n-Note that fields of zero-typed types (e.g., `PhantomData`) can also exist\n+Note that fields of zero-sized types (e.g., `PhantomData`) can also exist\n alongside the field that contains the actual data, they do not count for this\n error. When generic types are involved (as in the above example), an error is\n reported because the type parameter could be non-zero-sized."}, {"sha": "305667e58f8fb3afb669fd325738051b23763842", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -2,8 +2,7 @@ Return types cannot be `dyn Trait`s as they must be `Sized`.\n \n Erroneous code example:\n \n-```compile_fail,E0277\n-# // FIXME: after E0746 is in beta, change the above\n+```compile_fail,E0746\n trait T {\n     fn bar(&self);\n }"}, {"sha": "ccd3e9b6e43c3f5f341e67b2269d9ed184f8adbd", "filename": "src/librustc_hir_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_hir_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_hir_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -13,6 +13,5 @@ doctest = false\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "2963eb29bc170ef3b5ba438d171c52a8512af7ce", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -32,7 +32,6 @@ rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_symbol_mangling = { path = \"../librustc_symbol_mangling\" }\n rustc_codegen_llvm = { path = \"../librustc_codegen_llvm\", optional = true }\n rustc_hir = { path = \"../librustc_hir\" }\n-rustc_infer = { path = \"../librustc_infer\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_mir_build = { path = \"../librustc_mir_build\" }"}, {"sha": "be85a34bd395a5842e40441203169d56960f6511", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -236,12 +236,17 @@ pub enum Base {\n /// (e.g. \"#![deny(missing_docs)]\").\n pub fn strip_shebang(input: &str) -> Option<usize> {\n     debug_assert!(!input.is_empty());\n-    if !input.starts_with(\"#!\") || input.starts_with(\"#![\") {\n+    let s: &str = &remove_whitespace(input);\n+    if !s.starts_with(\"#!\") || s.starts_with(\"#![\") {\n         return None;\n     }\n     Some(input.find('\\n').unwrap_or(input.len()))\n }\n \n+fn remove_whitespace(s: &str) -> String {\n+    s.chars().filter(|c| !c.is_whitespace()).collect()\n+}\n+\n /// Parses the first token from the provided input string.\n pub fn first_token(input: &str) -> Token {\n     debug_assert!(!input.is_empty());"}, {"sha": "065e8f3f646fb7184ad0ebc8c4ce017f24e394b9", "filename": "src/librustc_lexer/src/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Ftests.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -145,4 +145,22 @@ mod tests {\n             }),\n         );\n     }\n+\n+    #[test]\n+    fn test_valid_shebang() {\n+        // https://github.com/rust-lang/rust/issues/70528\n+        let input = \"#!/usr/bin/rustrun\";\n+        let actual = strip_shebang(input);\n+        let expected: Option<usize> = Some(18);\n+        assert_eq!(expected, actual);\n+    }\n+\n+    #[test]\n+    fn test_invalid_shebang_valid_rust_syntax() {\n+        // https://github.com/rust-lang/rust/issues/70528\n+        let input = \"#!    [bad_attribute]\";\n+        let actual = strip_shebang(input);\n+        let expected: Option<usize> = None;\n+        assert_eq!(expected, actual);\n+    }\n }"}, {"sha": "b238a3156fae55b890716efc7b77eb779be2ad5f", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -23,5 +23,4 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_session = { path = \"../librustc_session\" }\n-rustc_infer = { path = \"../librustc_infer\" }\n rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "8e27e03ea4ffe70f589761479a76b181e9995896", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -12,7 +12,6 @@ doctest = false\n [dependencies]\n arena = { path = \"../libarena\" }\n bitflags = \"1.2.1\"\n-jobserver = \"0.1\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.3.0\"\n@@ -32,7 +31,6 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n backtrace = \"0.3.40\"\n-parking_lot = \"0.10\"\n byteorder = { version = \"1.3\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\""}, {"sha": "d922a8323290177a7eebd0b5e539433a3116144f", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -17,7 +17,6 @@ log = \"0.4\"\n log_settings = \"0.1.1\"\n polonius-engine = \"0.12.0\"\n rustc_middle = { path = \"../librustc_middle\" }\n-rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "7164c6788086398bf2535dc58807afc714b48af6", "filename": "src/librustc_parse/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -17,7 +17,6 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "69048cbf24a3085d335cb8f6ac2dc399c80c13a1", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -14,10 +14,8 @@ rustc_middle = { path = \"../librustc_middle\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n-rustc_infer = { path = \"../librustc_infer\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "6629d841fc8bbc9486c76231ce2c7cf49f7e1e33", "filename": "src/librustc_query_system/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -15,7 +15,6 @@ rustc-rayon-core = \"0.3.0\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_index = { path = \"../librustc_index\" }\n-rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n parking_lot = \"0.10\""}, {"sha": "e698335b2c240406d5703148cafb611f3ac5e371", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 92, "deletions": 32, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n-    self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+    self, AdtKind, DefIdTree, Infer, InferTy, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n@@ -826,12 +826,28 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             .iter()\n             .filter_map(|expr| tables.node_type_opt(expr.hir_id))\n             .map(|ty| self.resolve_vars_if_possible(&ty));\n-        let (last_ty, all_returns_have_same_type) = ret_types.clone().fold(\n-            (None, true),\n-            |(last_ty, mut same): (std::option::Option<Ty<'_>>, bool), ty| {\n+        let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n+            (None, true, true),\n+            |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n+             ty| {\n                 let ty = self.resolve_vars_if_possible(&ty);\n-                same &= last_ty.map_or(true, |last_ty| last_ty == ty) && ty.kind != ty::Error;\n-                (Some(ty), same)\n+                same &=\n+                    ty.kind != ty::Error\n+                        && last_ty.map_or(true, |last_ty| {\n+                            // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n+                            // *after* in the dependency graph.\n+                            match (&ty.kind, &last_ty.kind) {\n+                                (Infer(InferTy::IntVar(_)), Infer(InferTy::IntVar(_)))\n+                                | (Infer(InferTy::FloatVar(_)), Infer(InferTy::FloatVar(_)))\n+                                | (Infer(InferTy::FreshIntTy(_)), Infer(InferTy::FreshIntTy(_)))\n+                                | (\n+                                    Infer(InferTy::FreshFloatTy(_)),\n+                                    Infer(InferTy::FreshFloatTy(_)),\n+                                ) => true,\n+                                _ => ty == last_ty,\n+                            }\n+                        });\n+                (Some(ty), same, only_never_return && matches!(ty.kind, ty::Never))\n             },\n         );\n         let all_returns_conform_to_trait =\n@@ -840,13 +856,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ty::Dynamic(predicates, _) => {\n                         let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n                         let param_env = ty::ParamEnv::empty();\n-                        ret_types.all(|returned_ty| {\n-                            predicates.iter().all(|predicate| {\n-                                let pred = predicate.with_self_ty(self.tcx, returned_ty);\n-                                let obl = Obligation::new(cause.clone(), param_env, pred);\n-                                self.predicate_may_hold(&obl)\n+                        only_never_return\n+                            || ret_types.all(|returned_ty| {\n+                                predicates.iter().all(|predicate| {\n+                                    let pred = predicate.with_self_ty(self.tcx, returned_ty);\n+                                    let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                    self.predicate_may_hold(&obl)\n+                                })\n                             })\n-                        })\n                     }\n                     _ => false,\n                 }\n@@ -855,21 +872,19 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n         let sm = self.tcx.sess.source_map();\n-        let (snippet, last_ty) =\n-            if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n-                // Verify that we're dealing with a return `dyn Trait`\n-                ret_ty.span.overlaps(span),\n-                &ret_ty.kind,\n-                sm.span_to_snippet(ret_ty.span),\n-                // If any of the return types does not conform to the trait, then we can't\n-                // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n-                all_returns_conform_to_trait,\n-                last_ty,\n-            ) {\n-                (snippet, last_ty)\n-            } else {\n-                return false;\n-            };\n+        let snippet = if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true) = (\n+            // Verify that we're dealing with a return `dyn Trait`\n+            ret_ty.span.overlaps(span),\n+            &ret_ty.kind,\n+            sm.span_to_snippet(ret_ty.span),\n+            // If any of the return types does not conform to the trait, then we can't\n+            // suggest `impl Trait` nor trait objects: it is a type mismatch error.\n+            all_returns_conform_to_trait,\n+        ) {\n+            snippet\n+        } else {\n+            return false;\n+        };\n         err.code(error_code!(E0746));\n         err.set_primary_message(\"return type cannot have an unboxed trait object\");\n         err.children.clear();\n@@ -881,13 +896,22 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             #using-trait-objects-that-allow-for-values-of-different-types>\";\n         let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n         let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n-        if all_returns_have_same_type {\n+        if only_never_return {\n+            // No return paths, probably using `panic!()` or similar.\n+            // Suggest `-> T`, `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n+            suggest_trait_object_return_type_alternatives(\n+                err,\n+                ret_ty.span,\n+                trait_obj,\n+                is_object_safe,\n+            );\n+        } else if let (Some(last_ty), true) = (last_ty, all_returns_have_same_type) {\n             // Suggest `-> impl Trait`.\n             err.span_suggestion(\n                 ret_ty.span,\n                 &format!(\n-                    \"return `impl {1}` instead, as all return paths are of type `{}`, \\\n-                        which implements `{1}`\",\n+                    \"use `impl {1}` as the return type, as all return paths are of type `{}`, \\\n+                     which implements `{1}`\",\n                     last_ty, trait_obj,\n                 ),\n                 format!(\"impl {}\", trait_obj),\n@@ -925,8 +949,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n             err.note(trait_obj_msg);\n             err.note(&format!(\n-                \"if all the returned values were of the same type you could use \\\n-                    `impl {}` as the return type\",\n+                \"if all the returned values were of the same type you could use `impl {}` as the \\\n+                 return type\",\n                 trait_obj,\n             ));\n             err.note(impl_trait_msg);\n@@ -1813,3 +1837,39 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n             .to_string()\n     }\n }\n+\n+fn suggest_trait_object_return_type_alternatives(\n+    err: &mut DiagnosticBuilder<'tcx>,\n+    ret_ty: Span,\n+    trait_obj: &str,\n+    is_object_safe: bool,\n+) {\n+    err.span_suggestion(\n+        ret_ty,\n+        \"use some type `T` that is `T: Sized` as the return type if all return paths have the \\\n+            same type\",\n+        \"T\".to_string(),\n+        Applicability::MaybeIncorrect,\n+    );\n+    err.span_suggestion(\n+        ret_ty,\n+        &format!(\n+            \"use `impl {}` as the return type if all return paths have the same type but you \\\n+                want to expose only the trait in the signature\",\n+            trait_obj,\n+        ),\n+        format!(\"impl {}\", trait_obj),\n+        Applicability::MaybeIncorrect,\n+    );\n+    if is_object_safe {\n+        err.span_suggestion(\n+            ret_ty,\n+            &format!(\n+                \"use a boxed trait object if all return paths implement trait `{}`\",\n+                trait_obj,\n+            ),\n+            format!(\"Box<dyn {}>\", trait_obj),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}"}, {"sha": "839558f38fddd2ec744c6cc80375362e8962527b", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -13,8 +13,6 @@ log = { version = \"0.4\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n-rustc_macros = { path = \"../librustc_macros\" }\n-rustc_target = { path = \"../librustc_target\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "65bcb19b20a8914437cc7ba0ae2fa5a5218f3fe0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -1305,7 +1305,6 @@ fn check_fn<'a, 'tcx>(\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n-    fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n@@ -1374,7 +1373,25 @@ fn check_fn<'a, 'tcx>(\n \n     inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.check_return_expr(&body.value);\n+    if let ty::Dynamic(..) = declared_ret_ty.kind {\n+        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n+        // been evaluated so that we have types available for all the nodes being returned, but that\n+        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n+        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n+        // while keeping the current ordering we will ignore the tail expression's type because we\n+        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n+        // because we will trigger \"unreachable expression\" lints unconditionally.\n+        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n+        // case that a newcomer might make, returning a bare trait, and in that case we populate\n+        // the tail expression's type so that the suggestion will be correct, but ignore all other\n+        // possible cases.\n+        fcx.check_expr(&body.value);\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        tcx.sess.delay_span_bug(decl.output.span(), \"`!Sized` return type\");\n+    } else {\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        fcx.check_return_expr(&body.value);\n+    }\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "cfb165a3d4397d4848774f6e1b0aece763a49c24", "filename": "src/libserialize/hex.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/70f4f320b02cfd511c78389a6db1628285277410/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f4f320b02cfd511c78389a6db1628285277410/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=70f4f320b02cfd511c78389a6db1628285277410", "patch": "@@ -1,137 +0,0 @@\n-//! Hex binary-to-text encoding\n-\n-pub use self::FromHexError::*;\n-\n-use std::error;\n-use std::fmt;\n-\n-/// A trait for converting a value to hexadecimal encoding\n-pub trait ToHex {\n-    /// Converts the value of `self` to a hex value, returning the owned\n-    /// string.\n-    fn to_hex(&self) -> String;\n-}\n-\n-const CHARS: &[u8] = b\"0123456789abcdef\";\n-\n-impl ToHex for [u8] {\n-    /// Turn a vector of `u8` bytes into a hexadecimal string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(rustc_private)]\n-    ///\n-    /// extern crate serialize;\n-    /// use serialize::hex::ToHex;\n-    ///\n-    /// fn main () {\n-    ///     let str = [52,32].to_hex();\n-    ///     println!(\"{}\", str);\n-    /// }\n-    /// ```\n-    fn to_hex(&self) -> String {\n-        let mut v = Vec::with_capacity(self.len() * 2);\n-        for &byte in self {\n-            v.push(CHARS[(byte >> 4) as usize]);\n-            v.push(CHARS[(byte & 0xf) as usize]);\n-        }\n-\n-        unsafe { String::from_utf8_unchecked(v) }\n-    }\n-}\n-\n-/// A trait for converting hexadecimal encoded values\n-pub trait FromHex {\n-    /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n-    /// into an owned vector of bytes, returning the vector.\n-    fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;\n-}\n-\n-/// Errors that can occur when decoding a hex encoded string\n-#[derive(Copy, Clone, Debug)]\n-pub enum FromHexError {\n-    /// The input contained a character not part of the hex format\n-    InvalidHexCharacter(char, usize),\n-    /// The input had an invalid length\n-    InvalidHexLength,\n-}\n-\n-impl fmt::Display for FromHexError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InvalidHexCharacter(ch, idx) => {\n-                write!(f, \"Invalid character '{}' at position {}\", ch, idx)\n-            }\n-            InvalidHexLength => write!(f, \"Invalid input length\"),\n-        }\n-    }\n-}\n-\n-impl error::Error for FromHexError {}\n-\n-impl FromHex for str {\n-    /// Converts any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n-    /// to the byte values it encodes.\n-    ///\n-    /// You can use the `String::from_utf8` function to turn a\n-    /// `Vec<u8>` into a string with characters corresponding to those values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This converts a string literal to hexadecimal and back.\n-    ///\n-    /// ```\n-    /// #![feature(rustc_private)]\n-    ///\n-    /// extern crate serialize;\n-    /// use serialize::hex::{FromHex, ToHex};\n-    ///\n-    /// fn main () {\n-    ///     let hello_str = \"Hello, World\".as_bytes().to_hex();\n-    ///     println!(\"{}\", hello_str);\n-    ///     let bytes = hello_str.from_hex().unwrap();\n-    ///     println!(\"{:?}\", bytes);\n-    ///     let result_str = String::from_utf8(bytes).unwrap();\n-    ///     println!(\"{}\", result_str);\n-    /// }\n-    /// ```\n-    fn from_hex(&self) -> Result<Vec<u8>, FromHexError> {\n-        // This may be an overestimate if there is any whitespace\n-        let mut b = Vec::with_capacity(self.len() / 2);\n-        let mut modulus = 0;\n-        let mut buf = 0;\n-\n-        for (idx, byte) in self.bytes().enumerate() {\n-            buf <<= 4;\n-\n-            match byte {\n-                b'A'..=b'F' => buf |= byte - b'A' + 10,\n-                b'a'..=b'f' => buf |= byte - b'a' + 10,\n-                b'0'..=b'9' => buf |= byte - b'0',\n-                b' ' | b'\\r' | b'\\n' | b'\\t' => {\n-                    buf >>= 4;\n-                    continue;\n-                }\n-                _ => {\n-                    let ch = self[idx..].chars().next().unwrap();\n-                    return Err(InvalidHexCharacter(ch, idx));\n-                }\n-            }\n-\n-            modulus += 1;\n-            if modulus == 2 {\n-                modulus = 0;\n-                b.push(buf);\n-            }\n-        }\n-\n-        match modulus {\n-            0 => Ok(b),\n-            _ => Err(InvalidHexLength),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "ce62c0ff2329db6d2f72ba872907ebde2aed7893", "filename": "src/libserialize/hex/tests.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/70f4f320b02cfd511c78389a6db1628285277410/src%2Flibserialize%2Fhex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70f4f320b02cfd511c78389a6db1628285277410/src%2Flibserialize%2Fhex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex%2Ftests.rs?ref=70f4f320b02cfd511c78389a6db1628285277410", "patch": "@@ -1,67 +0,0 @@\n-extern crate test;\n-use crate::hex::{FromHex, ToHex};\n-use test::Bencher;\n-\n-#[test]\n-pub fn test_to_hex() {\n-    assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n-}\n-\n-#[test]\n-pub fn test_from_hex_okay() {\n-    assert_eq!(\"666f6f626172\".from_hex().unwrap(), b\"foobar\");\n-    assert_eq!(\"666F6F626172\".from_hex().unwrap(), b\"foobar\");\n-}\n-\n-#[test]\n-pub fn test_from_hex_odd_len() {\n-    assert!(\"666\".from_hex().is_err());\n-    assert!(\"66 6\".from_hex().is_err());\n-}\n-\n-#[test]\n-pub fn test_from_hex_invalid_char() {\n-    assert!(\"66y6\".from_hex().is_err());\n-}\n-\n-#[test]\n-pub fn test_from_hex_ignores_whitespace() {\n-    assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(), b\"foobar\");\n-}\n-\n-#[test]\n-pub fn test_to_hex_all_bytes() {\n-    for i in 0..256 {\n-        assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n-    }\n-}\n-\n-#[test]\n-pub fn test_from_hex_all_bytes() {\n-    for i in 0..256 {\n-        let ii: &[u8] = &[i as u8];\n-        assert_eq!(format!(\"{:02x}\", i as usize).from_hex().unwrap(), ii);\n-        assert_eq!(format!(\"{:02X}\", i as usize).from_hex().unwrap(), ii);\n-    }\n-}\n-\n-#[bench]\n-pub fn bench_to_hex(b: &mut Bencher) {\n-    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-    b.iter(|| {\n-        s.as_bytes().to_hex();\n-    });\n-    b.bytes = s.len() as u64;\n-}\n-\n-#[bench]\n-pub fn bench_from_hex(b: &mut Bencher) {\n-    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-    let sb = s.as_bytes().to_hex();\n-    b.iter(|| {\n-        sb.from_hex().unwrap();\n-    });\n-    b.bytes = sb.len() as u64;\n-}"}, {"sha": "c0011fddf4ff3552641d23eb8a85a51922334013", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -25,7 +25,6 @@ pub use self::serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n mod collection_impls;\n mod serialize;\n \n-pub mod hex;\n pub mod json;\n \n pub mod leb128;"}, {"sha": "8e743ace99bfbddde05b22d12495bdbb0ed87613", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -171,7 +171,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f32 {\n-        if self.is_nan() { NAN } else { 1.0_f32.copysign(self) }\n+        if self.is_nan() { Self::NAN } else { 1.0_f32.copysign(self) }\n     }\n \n     /// Returns a number composed of the magnitude of `self` and the sign of\n@@ -832,8 +832,8 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f32 {\n-        if self == NEG_INFINITY {\n-            NEG_INFINITY\n+        if self == Self::NEG_INFINITY {\n+            Self::NEG_INFINITY\n         } else {\n             (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n         }\n@@ -855,7 +855,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f32 {\n-        if self < 1.0 { crate::f32::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n+        if self < 1.0 { Self::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n     }\n \n     /// Inverse hyperbolic tangent function."}, {"sha": "fe64d27b1efc8fb9a7441c7f47b41ec0c82a381d", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -171,7 +171,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f64 {\n-        if self.is_nan() { NAN } else { 1.0_f64.copysign(self) }\n+        if self.is_nan() { Self::NAN } else { 1.0_f64.copysign(self) }\n     }\n \n     /// Returns a number composed of the magnitude of `self` and the sign of\n@@ -834,8 +834,8 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f64 {\n-        if self == NEG_INFINITY {\n-            NEG_INFINITY\n+        if self == Self::NEG_INFINITY {\n+            Self::NEG_INFINITY\n         } else {\n             (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n         }\n@@ -857,7 +857,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn acosh(self) -> f64 {\n-        if self < 1.0 { NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n+        if self < 1.0 { Self::NAN } else { (self + ((self * self) - 1.0).sqrt()).ln() }\n     }\n \n     /// Inverse hyperbolic tangent function.\n@@ -926,16 +926,16 @@ impl f64 {\n                 if self > 0.0 {\n                     log_fn(self)\n                 } else if self == 0.0 {\n-                    NEG_INFINITY // log(0) = -Inf\n+                    Self::NEG_INFINITY // log(0) = -Inf\n                 } else {\n-                    NAN // log(-n) = NaN\n+                    Self::NAN // log(-n) = NaN\n                 }\n             } else if self.is_nan() {\n                 self // log(NaN) = NaN\n             } else if self > 0.0 {\n                 self // log(Inf) = Inf\n             } else {\n-                NAN // log(-Inf) = NaN\n+                Self::NAN // log(-Inf) = NaN\n             }\n         }\n     }"}, {"sha": "7a3cbbe4562ff70f8ff480c85e703ed2614d593e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -1062,7 +1062,7 @@ impl ThreadId {\n \n             // If we somehow use up all our bits, panic so that we're not\n             // covering up subtle bugs of IDs being reused.\n-            if COUNTER == crate::u64::MAX {\n+            if COUNTER == u64::MAX {\n                 panic!(\"failed to generate unique thread ID: bitspace exhausted\");\n             }\n "}, {"sha": "1c7c9f9aff09558ec9feb7581fb1a7acfc8259dd", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -10,7 +10,7 @@\n # If you're looking at this file on the master branch, you'll likely see that\n # rustc and cargo are configured to `beta`, whereas if you're looking at a\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n-# `0.x.0` for Cargo where they were released on `date`.\n+# `0.(x+1).0` for Cargo where they were released on `date`.\n \n date: 2020-03-12\n rustc: beta"}, {"sha": "b35f67ef9124338f05e4d152726af3ac5ab69fb2", "filename": "src/test/rustdoc/show-const-contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fshow-const-contents.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -51,7 +51,7 @@ pub const MY_TYPE_WITH_STR: MyTypeWithStr = MyTypeWithStr(\"show this\");\n // @has show_const_contents/constant.PI.html '; // 3.14159274f32'\n pub use std::f32::consts::PI;\n \n-// @has show_const_contents/constant.MAX.html '= i32::max_value(); // 2_147_483_647i32'\n+// @has show_const_contents/constant.MAX.html '= i32::MAX; // 2_147_483_647i32'\n pub use std::i32::MAX;\n \n macro_rules! int_module {"}, {"sha": "3757ed6d0926eb1b45e5686ab500e1620a28186a", "filename": "src/test/ui/error-codes/E0746.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -5,7 +5,7 @@ LL | fn foo() -> dyn Trait { Struct }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n    |\n LL | fn foo() -> impl Trait { Struct }\n    |             ^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL | fn bar() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n    |\n LL | fn bar() -> impl Trait {\n    |             ^^^^^^^^^^"}, {"sha": "cbf1daabe2b4e69e0af6b205283b75f60a4e1c45", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -14,7 +14,7 @@ fn bap() -> Trait { Struct }\n //~^ ERROR E0746\n fn ban() -> dyn Trait { Struct }\n //~^ ERROR E0746\n-fn bak() -> dyn Trait { unimplemented!() } //~ ERROR E0277\n+fn bak() -> dyn Trait { unimplemented!() } //~ ERROR E0746\n // Suggest using `Box<dyn Trait>`\n fn bal() -> dyn Trait { //~ ERROR E0746\n     if true {\n@@ -26,7 +26,7 @@ fn bax() -> dyn Trait { //~ ERROR E0746\n     if true {\n         Struct\n     } else {\n-        42\n+        42 //~ ERROR `if` and `else` have incompatible types\n     }\n }\n fn bam() -> Box<dyn Trait> {"}, {"sha": "c55dbd7d2fafe9559d669780b399b9e2bc9d0929", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -49,7 +49,7 @@ LL | fn bap() -> Trait { Struct }\n    |             ^^^^^ doesn't have a size known at compile-time\n    |\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n    |\n LL | fn bap() -> impl Trait { Struct }\n    |             ^^^^^^^^^^\n@@ -61,20 +61,29 @@ LL | fn ban() -> dyn Trait { Struct }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n    |\n LL | fn ban() -> impl Trait { Struct }\n    |             ^^^^^^^^^^\n \n-error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:17:13\n    |\n LL | fn bak() -> dyn Trait { unimplemented!() }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = help: the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = note: the return type of a function must have a statically known size\n+help: use some type `T` that is `T: Sized` as the return type if all return paths have the same type\n+   |\n+LL | fn bak() -> T { unimplemented!() }\n+   |             ^\n+help: use `impl Trait` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n+   |\n+LL | fn bak() -> impl Trait { unimplemented!() }\n+   |             ^^^^^^^^^^\n+help: use a boxed trait object if all return paths implement trait `Trait`\n+   |\n+LL | fn bak() -> Box<dyn Trait> { unimplemented!() }\n+   |             ^^^^^^^^^^^^^^\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n@@ -95,6 +104,18 @@ LL |     }\n LL |     Box::new(42)\n    |\n \n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:29:9\n+   |\n+LL | /     if true {\n+LL | |         Struct\n+   | |         ------ expected because of this\n+LL | |     } else {\n+LL | |         42\n+   | |         ^^ expected struct `Struct`, found integer\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+\n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:25:13\n    |\n@@ -249,7 +270,7 @@ LL | fn bat() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n    |\n LL | fn bat() -> impl Trait {\n    |             ^^^^^^^^^^\n@@ -261,12 +282,12 @@ LL | fn bay() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n    |\n LL | fn bay() -> impl Trait {\n    |             ^^^^^^^^^^\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 20 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0746.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "4bf5b6c0f30322fa7562a4dfbcb11617cdc8cd25", "filename": "src/test/ui/issues/issue-18107.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fissues%2Fissue-18107.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fissues%2Fissue-18107.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18107.rs?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -2,7 +2,7 @@ pub trait AbstractRenderer {}\n \n fn _create_render(_: &()) ->\n     dyn AbstractRenderer\n-//~^ ERROR the size for values of type\n+//~^ ERROR return type cannot have an unboxed trait object\n {\n     match 0 {\n         _ => unimplemented!()"}, {"sha": "1eb6822b8a11abb20467db9d06bfda7daa94af32", "filename": "src/test/ui/issues/issue-18107.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr?ref=2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "patch": "@@ -1,13 +1,22 @@\n-error[E0277]: the size for values of type `(dyn AbstractRenderer + 'static)` cannot be known at compilation time\n+error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/issue-18107.rs:4:5\n    |\n LL |     dyn AbstractRenderer\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = help: the trait `std::marker::Sized` is not implemented for `(dyn AbstractRenderer + 'static)`\n-   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = note: the return type of a function must have a statically known size\n+help: use some type `T` that is `T: Sized` as the return type if all return paths have the same type\n+   |\n+LL |     T\n+   |\n+help: use `impl AbstractRenderer` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n+   |\n+LL |     impl AbstractRenderer\n+   |\n+help: use a boxed trait object if all return paths implement trait `AbstractRenderer`\n+   |\n+LL |     Box<dyn AbstractRenderer>\n+   |\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0277`.\n+For more information about this error, try `rustc --explain E0746`."}]}