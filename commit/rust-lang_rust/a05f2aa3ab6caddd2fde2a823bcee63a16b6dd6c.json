{"sha": "a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNWYyYWEzYWI2Y2FkZGQyZmRlMmE4MjNiY2VlNjNhMTZiNmRkNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-23T16:52:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-23T16:52:52Z"}, "message": "Auto merge of #993 - christianpoveda:os_string_helper, r=RalfJung\n\nAdd OsString from/to bytes helper functions\n\nRelated issue: https://github.com/rust-lang/miri/issues/989\n\nr? @RalfJung", "tree": {"sha": "ef62c00d81513d9bdc19af7c04783438c3b14432", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef62c00d81513d9bdc19af7c04783438c3b14432"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "html_url": "https://github.com/rust-lang/rust/commit/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e8b17c85f7b0ea9ff84d0c93d4fdb1070f853eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e8b17c85f7b0ea9ff84d0c93d4fdb1070f853eb", "html_url": "https://github.com/rust-lang/rust/commit/7e8b17c85f7b0ea9ff84d0c93d4fdb1070f853eb"}, {"sha": "de12cbcb32a53a06e1f73e7d9cdfa11e41d79ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/de12cbcb32a53a06e1f73e7d9cdfa11e41d79ded", "html_url": "https://github.com/rust-lang/rust/commit/de12cbcb32a53a06e1f73e7d9cdfa11e41d79ded"}], "stats": {"total": 105, "additions": 63, "deletions": 42}, "files": [{"sha": "0245540debbe74bf18b5d18c4d1b3b3df6781fc1", "filename": "src/helpers.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "patch": "@@ -1,4 +1,5 @@\n use std::mem;\n+use std::ffi::{OsStr, OsString};\n \n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n@@ -402,4 +403,60 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n     }\n+\n+    /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n+    /// the Unix APIs usually handle.\n+    fn read_os_string_from_c_string(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx, OsString> {\n+        let bytes = self.eval_context_mut().memory.read_c_str(scalar)?;\n+        Ok(bytes_to_os_str(bytes)?.into())\n+    }\n+\n+    /// Helper function to write an OsStr as a null-terminated sequence of bytes, which is what\n+    /// the Unix APIs usually handle. This function returns `Ok(false)` without trying to write if\n+    /// `size` is not large enough to fit the contents of `os_string` plus a null terminator. It\n+    /// returns `Ok(true)` if the writing process was successful.\n+    fn write_os_str_to_c_string(\n+        &mut self,\n+        os_str: &OsStr,\n+        scalar: Scalar<Tag>,\n+        size: u64\n+    ) -> InterpResult<'tcx, bool> {\n+        let bytes = os_str_to_bytes(os_str)?;\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n+        // terminator to memory using the `ptr` pointer would cause an overflow.\n+        if size <= bytes.len() as u64 {\n+            return Ok(false);\n+        }\n+        // FIXME: We should use `Iterator::chain` instead when rust-lang/rust#65704 lands.\n+        self.eval_context_mut().memory.write_bytes(scalar, [bytes, &[0]].concat())?;\n+        Ok(true)\n+    }\n+}\n+\n+#[cfg(target_os = \"unix\")]\n+fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+    std::os::unix::ffi::OsStringExt::into_bytes(os_str)\n+}\n+\n+#[cfg(target_os = \"unix\")]\n+fn bytes_to_os_str<'tcx, 'a>(bytes: &'a[u8]) -> InterpResult<'tcx, &'a OsStr> {\n+    Ok(std::os::unix::ffi::OsStringExt::from_bytes(bytes))\n+}\n+\n+// On non-unix platforms the best we can do to transform bytes from/to OS strings is to do the\n+// intermediate transformation into strings. Which invalidates non-utf8 paths that are actually\n+// valid.\n+#[cfg(not(target_os = \"unix\"))]\n+fn os_str_to_bytes<'tcx, 'a>(os_str: &'a OsStr) -> InterpResult<'tcx, &'a [u8]> {\n+    os_str\n+        .to_str()\n+        .map(|s| s.as_bytes())\n+        .ok_or_else(|| err_unsup_format!(\"{:?} is not a valid utf-8 string\", os_str).into())\n+}\n+\n+#[cfg(not(target_os = \"unix\"))]\n+fn bytes_to_os_str<'tcx, 'a>(bytes: &'a[u8]) -> InterpResult<'tcx, &'a OsStr> {\n+    let s = std::str::from_utf8(bytes)\n+        .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", bytes))?;\n+    Ok(&OsStr::new(s))\n }"}, {"sha": "2dc47d74ffb82b6334e303137cda9530ca8336a8", "filename": "src/shims/env.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "patch": "@@ -1,9 +1,10 @@\n use std::collections::HashMap;\n+use std::ffi::OsString;\n use std::env;\n-use std::path::Path;\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n+\n use rustc::ty::layout::Size;\n use rustc_mir::interpret::{Memory, Pointer};\n \n@@ -127,18 +128,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {\n-                // It is not clear what happens with non-utf8 paths here\n-                let mut bytes = cwd.display().to_string().into_bytes();\n-                // If `size` is smaller or equal than the `bytes.len()`, writing `bytes` plus the\n-                // required null terminator to memory using the `buf` pointer would cause an\n-                // overflow. The desired behavior in this case is to return null.\n-                if (bytes.len() as u64) < size {\n-                    // We add a `/0` terminator\n-                    bytes.push(0);\n-                    // This is ok because the buffer was strictly larger than `bytes`, so after\n-                    // adding the null terminator, the buffer size is larger or equal to\n-                    // `bytes.len()`, meaning that `bytes` actually fit inside tbe buffer.\n-                    this.memory.write_bytes(buf, bytes.iter().copied())?;\n+                if this.write_os_str_to_c_string(&OsString::from(cwd), buf, size)? {\n                     return Ok(buf);\n                 }\n                 let erange = this.eval_libc(\"ERANGE\")?;\n@@ -154,14 +144,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"chdir\")?;\n \n-        let path_bytes = this\n-            .memory\n-            .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n-\n-        let path = Path::new(\n-            std::str::from_utf8(path_bytes)\n-                .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?,\n-        );\n+        let path = this.read_os_string_from_c_string(this.read_scalar(path_op)?.not_undef()?)?;\n \n         match env::set_current_dir(path) {\n             Ok(()) => Ok(0),"}, {"sha": "08c9f3ec06e78cdb39e9c51cd387d42b9aedfdbb", "filename": "src/shims/fs.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=a05f2aa3ab6caddd2fde2a823bcee63a16b6dd6c", "patch": "@@ -95,11 +95,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n-        let path_bytes = this\n-            .memory\n-            .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n-        let path = std::str::from_utf8(path_bytes)\n-            .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?;\n+        let path: std::path::PathBuf = this.read_os_string_from_c_string(this.read_scalar(path_op)?.not_undef()?)?.into();\n \n         let fd = options.open(path).map(|file| {\n             let mut fh = &mut this.machine.file_handler;\n@@ -214,11 +210,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"unlink\")?;\n \n-        let path_bytes = this\n-            .memory\n-            .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n-        let path = std::str::from_utf8(path_bytes)\n-            .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?;\n+        let path = this.read_os_string_from_c_string(this.read_scalar(path_op)?.not_undef()?)?;\n \n         let result = remove_file(path).map(|_| 0);\n "}, {"sha": "22b0d723aad8c8c7ff13434929db5029a6f63508", "filename": "tests/compile-fail/chdir_invalid_path.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e8b17c85f7b0ea9ff84d0c93d4fdb1070f853eb/tests%2Fcompile-fail%2Fchdir_invalid_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e8b17c85f7b0ea9ff84d0c93d4fdb1070f853eb/tests%2Fcompile-fail%2Fchdir_invalid_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fchdir_invalid_path.rs?ref=7e8b17c85f7b0ea9ff84d0c93d4fdb1070f853eb", "patch": "@@ -1,11 +0,0 @@\n-// compile-flags: -Zmiri-disable-isolation\n-\n-extern {\n-    pub fn chdir(dir: *const u8) -> i32;\n-}\n-\n-fn main() {\n-    let path = vec![0xc3u8, 0x28, 0];\n-    // test that `chdir` errors with invalid utf-8 path\n-    unsafe { chdir(path.as_ptr()) };  //~ ERROR is not a valid utf-8 string\n-}"}]}