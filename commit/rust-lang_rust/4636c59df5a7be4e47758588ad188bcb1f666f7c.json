{"sha": "4636c59df5a7be4e47758588ad188bcb1f666f7c", "node_id": "C_kwDOAAsO6NoAKDQ2MzZjNTlkZjVhN2JlNGU0Nzc1ODU4OGFkMTg4YmNiMWY2NjZmN2M", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-04-30T03:14:26Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-03T21:47:46Z"}, "message": "Add more SIMD", "tree": {"sha": "5c150aa361307fe3072137a34f718aa05506647c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c150aa361307fe3072137a34f718aa05506647c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4636c59df5a7be4e47758588ad188bcb1f666f7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4636c59df5a7be4e47758588ad188bcb1f666f7c", "html_url": "https://github.com/rust-lang/rust/commit/4636c59df5a7be4e47758588ad188bcb1f666f7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4636c59df5a7be4e47758588ad188bcb1f666f7c/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5088fb3d3b20fa20a72425e1d214343c9ed7251a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5088fb3d3b20fa20a72425e1d214343c9ed7251a", "html_url": "https://github.com/rust-lang/rust/commit/5088fb3d3b20fa20a72425e1d214343c9ed7251a"}], "stats": {"total": 132, "additions": 102, "deletions": 30}, "files": [{"sha": "f0b93c3d51700a6dc07f0d7260e29403f3a6ab0e", "filename": "src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=4636c59df5a7be4e47758588ad188bcb1f666f7c", "patch": "@@ -1343,7 +1343,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 }\n                 // TODO(antoyo): switch to using new_vector_access.\n                 let array = self.context.new_bitcast(None, v2, array_type);\n-                for i in 0..vec_num_units {\n+                for i in 0..(mask_num_units - vec_num_units) {\n                     elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n                 let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);"}, {"sha": "4b517fd85f052ab2db3a19737392ae1cf7ab314f", "filename": "src/consts.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=4636c59df5a7be4e47758588ad188bcb1f666f7c", "patch": "@@ -27,12 +27,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         }\n         // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n         // SIMD builtins require a constant value.\n-        if value.get_type() != typ {\n-            self.context.new_bitcast(None, value, typ)\n-        }\n-        else {\n-            value\n-        }\n+        self.bitcast_if_needed(value, typ)\n     }\n }\n \n@@ -86,13 +81,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         // TODO(antoyo): set alignment.\n \n-        let value =\n-            if value.get_type() != gcc_type {\n-                self.context.new_bitcast(None, value, gcc_type)\n-            }\n-            else {\n-                value\n-            };\n+        let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n \n         // As an optimization, all shared statics which do not have interior"}, {"sha": "92b30ef9b4d81beaf513cd7f1ce6aa670b3ea079", "filename": "src/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcontext.rs?ref=4636c59df5a7be4e47758588ad188bcb1f666f7c", "patch": "@@ -279,6 +279,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n+\n+    pub fn bitcast_if_needed(&self, value: RValue<'gcc>, expected_type: Type<'gcc>) -> RValue<'gcc> {\n+        if value.get_type() != expected_type {\n+            self.context.new_bitcast(None, value, expected_type)\n+        }\n+        else {\n+            value\n+        }\n+    }\n }\n \n impl<'gcc, 'tcx> BackendTypes for CodegenCx<'gcc, 'tcx> {"}, {"sha": "aab93b9275582a24f6a629ca81b06988aba7a37f", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=4636c59df5a7be4e47758588ad188bcb1f666f7c", "patch": "@@ -21,6 +21,25 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n         // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n+\n+        // The above doc points to unknown builtins for the following, so override them:\n+        \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n+        \"llvm.x86.avx2.gather.d.d.256\" => \"__builtin_ia32_gathersiv8si\",\n+        \"llvm.x86.avx2.gather.d.ps\" => \"__builtin_ia32_gathersiv4sf\",\n+        \"llvm.x86.avx2.gather.d.ps.256\" => \"__builtin_ia32_gathersiv8sf\",\n+        \"llvm.x86.avx2.gather.d.q\" => \"__builtin_ia32_gathersiv2di\",\n+        \"llvm.x86.avx2.gather.d.q.256\" => \"__builtin_ia32_gathersiv4di\",\n+        \"llvm.x86.avx2.gather.d.pd\" => \"__builtin_ia32_gathersiv2df\",\n+        \"llvm.x86.avx2.gather.d.pd.256\" => \"__builtin_ia32_gathersiv4df\",\n+        \"llvm.x86.avx2.gather.q.d\" => \"__builtin_ia32_gatherdiv4si\",\n+        \"llvm.x86.avx2.gather.q.d.256\" => \"__builtin_ia32_gatherdiv4si256\",\n+        \"llvm.x86.avx2.gather.q.ps\" => \"__builtin_ia32_gatherdiv4sf\",\n+        \"llvm.x86.avx2.gather.q.ps.256\" => \"__builtin_ia32_gatherdiv4sf256\",\n+        \"llvm.x86.avx2.gather.q.q\" => \"__builtin_ia32_gatherdiv2di\",\n+        \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n+        \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n+        \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n+        \"\" => \"\",\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "9204fbdfaba7ca8e9310f5dce2bc44c5b9c07228", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4636c59df5a7be4e47758588ad188bcb1f666f7c/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=4636c59df5a7be4e47758588ad188bcb1f666f7c", "patch": "@@ -202,14 +202,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             };\n         let builtin = bx.context.get_target_builtin_function(func_name);\n         let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        let vector =\n-            if vector.get_type() != param1_type {\n-                // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-                bx.context.new_bitcast(None, vector, param1_type)\n-            }\n-            else {\n-                vector\n-            };\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n         let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n         return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n@@ -539,18 +533,79 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n \n         let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_parameter(0).get_type();\n-        let lhs =\n-            if lhs.get_type() != param1_type {\n-                bx.context.new_bitcast(None, lhs, param1_type)\n-            }\n-            else {\n-                lhs\n-            };\n+        let param1_type = func.get_param(0).to_rvalue().get_type();\n+        let param2_type = func.get_param(1).to_rvalue().get_type();\n+        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n+        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n         let result = bx.context.new_call(None, func, &[lhs, rhs]);\n         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n         return Ok(bx.context.new_bitcast(None, result, vec_ty));\n     }\n \n+    macro_rules! arith_red {\n+        ($name:ident : $integer_reduce:ident, $float_reduce:ident, $ordered:expr, $op:ident,\n+         $identity:expr) => {\n+            if name == sym::$name {\n+                require!(\n+                    ret_ty == in_elem,\n+                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                    in_elem,\n+                    in_ty,\n+                    ret_ty\n+                );\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) => {\n+                        let r = bx.$integer_reduce(args[0].immediate());\n+                        if $ordered {\n+                            // if overflow occurs, the result is the\n+                            // mathematical result modulo 2^n:\n+                            Ok(bx.$op(args[1].immediate(), r))\n+                        } else {\n+                            Ok(bx.$integer_reduce(args[0].immediate()))\n+                        }\n+                    }\n+                    ty::Float(f) => {\n+                        let acc = if $ordered {\n+                            // ordered arithmetic reductions take an accumulator\n+                            args[1].immediate()\n+                        } else {\n+                            // unordered arithmetic reductions use the identity accumulator\n+                            match f.bit_width() {\n+                                32 => bx.const_real(bx.type_f32(), $identity),\n+                                64 => bx.const_real(bx.type_f64(), $identity),\n+                                v => return_error!(\n+                                    r#\"\n+unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n+                                    sym::$name,\n+                                    in_ty,\n+                                    in_elem,\n+                                    v,\n+                                    ret_ty\n+                                ),\n+                            }\n+                        };\n+                        Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                    }\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    // TODO: use a recursive algorithm a-la Hacker's Delight.\n+    arith_red!(\n+        simd_reduce_add_unordered: vector_reduce_add,\n+        vector_reduce_fadd_fast,\n+        false,\n+        add,\n+        0.0\n+    );\n+\n     unimplemented!(\"simd {}\", name);\n }"}]}