{"sha": "cec980a1a706fd6afc27dd54c1eed7c51800d753", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYzk4MGExYTcwNmZkNmFmYzI3ZGQ1NGMxZWVkN2M1MTgwMGQ3NTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-20T13:58:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-20T13:58:10Z"}, "message": "Auto merge of #25645 - luqmana:lnr, r=eddyb\n\nThis micro-optimization actually led to generating broken IR in certain cases.\r\n\r\nFixes #18845.\r\nFixes #25497.", "tree": {"sha": "bed287df8fa4f130dce8faf3e5f83032a8294646", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bed287df8fa4f130dce8faf3e5f83032a8294646"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cec980a1a706fd6afc27dd54c1eed7c51800d753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cec980a1a706fd6afc27dd54c1eed7c51800d753", "html_url": "https://github.com/rust-lang/rust/commit/cec980a1a706fd6afc27dd54c1eed7c51800d753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cec980a1a706fd6afc27dd54c1eed7c51800d753/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bacd8bc4b7712ad40a0fca6d14addd296597015f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bacd8bc4b7712ad40a0fca6d14addd296597015f", "html_url": "https://github.com/rust-lang/rust/commit/bacd8bc4b7712ad40a0fca6d14addd296597015f"}, {"sha": "54dbd0baadae58c811b0c85de4223cbf81f24725", "url": "https://api.github.com/repos/rust-lang/rust/commits/54dbd0baadae58c811b0c85de4223cbf81f24725", "html_url": "https://github.com/rust-lang/rust/commit/54dbd0baadae58c811b0c85de4223cbf81f24725"}], "stats": {"total": 121, "additions": 60, "deletions": 61}, "files": [{"sha": "dd32ed3bc1e59651580817efafeef0c917bac3fb", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=cec980a1a706fd6afc27dd54c1eed7c51800d753", "patch": "@@ -74,17 +74,6 @@\n //! `&foo()` or `match foo() { ref x => ... }`, where the user is\n //! implicitly requesting a temporary.\n //!\n-//! Somewhat surprisingly, not all lvalue expressions yield lvalue datums\n-//! when trans'd. Ultimately the reason for this is to micro-optimize\n-//! the resulting LLVM. For example, consider the following code:\n-//!\n-//!     fn foo() -> Box<int> { ... }\n-//!     let x = *foo();\n-//!\n-//! The expression `*foo()` is an lvalue, but if you invoke `expr::trans`,\n-//! it will return an rvalue datum. See `deref_once` in expr.rs for\n-//! more details.\n-//!\n //! ### Rvalues in detail\n //!\n //! Rvalues datums are values with no cleanup scheduled. One must be"}, {"sha": "3ebb56d1dd899d1d16d093646a4380d962beeffd", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=cec980a1a706fd6afc27dd54c1eed7c51800d753", "patch": "@@ -2248,16 +2248,20 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let r = match datum.ty.sty {\n         ty::ty_uniq(content_ty) => {\n+            // Make sure we have an lvalue datum here to get the\n+            // proper cleanups scheduled\n+            let datum = unpack_datum!(\n+                bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n+\n             if type_is_sized(bcx.tcx(), content_ty) {\n-                deref_owned_pointer(bcx, expr, datum, content_ty)\n+                let ptr = load_ty(bcx, datum.val, datum.ty);\n+                DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n             } else {\n                 // A fat pointer and a DST lvalue have the same representation\n                 // just different types. Since there is no temporary for `*e`\n                 // here (because it is unsized), we cannot emulate the sized\n                 // object code path for running drop glue and free. Instead,\n                 // we schedule cleanup for `e`, turning it into an lvalue.\n-                let datum = unpack_datum!(\n-                    bcx, datum.to_lvalue_datum(bcx, \"deref\", expr.id));\n \n                 let datum = Datum::new(datum.val, content_ty, LvalueExpr);\n                 DatumBlock::new(bcx, datum)\n@@ -2294,53 +2298,6 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            expr.id, method_call, r.datum.to_string(ccx));\n \n     return r;\n-\n-    /// We microoptimize derefs of owned pointers a bit here. Basically, the idea is to make the\n-    /// deref of an rvalue result in an rvalue. This helps to avoid intermediate stack slots in the\n-    /// resulting LLVM. The idea here is that, if the `Box<T>` pointer is an rvalue, then we can\n-    /// schedule a *shallow* free of the `Box<T>` pointer, and then return a ByRef rvalue into the\n-    /// pointer. Because the free is shallow, it is legit to return an rvalue, because we know that\n-    /// the contents are not yet scheduled to be freed. The language rules ensure that the contents\n-    /// will be used (or moved) before the free occurs.\n-    fn deref_owned_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       expr: &ast::Expr,\n-                                       datum: Datum<'tcx, Expr>,\n-                                       content_ty: Ty<'tcx>)\n-                                       -> DatumBlock<'blk, 'tcx, Expr> {\n-        match datum.kind {\n-            RvalueExpr(Rvalue { mode: ByRef }) => {\n-                let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n-                let ptr = Load(bcx, datum.val);\n-                if !type_is_zero_size(bcx.ccx(), content_ty) {\n-                    bcx.fcx.schedule_free_value(scope, ptr, cleanup::HeapExchange, content_ty);\n-                }\n-            }\n-            RvalueExpr(Rvalue { mode: ByValue }) => {\n-                let scope = cleanup::temporary_scope(bcx.tcx(), expr.id);\n-                if !type_is_zero_size(bcx.ccx(), content_ty) {\n-                    bcx.fcx.schedule_free_value(scope, datum.val, cleanup::HeapExchange,\n-                                                content_ty);\n-                }\n-            }\n-            LvalueExpr => { }\n-        }\n-\n-        // If we had an rvalue in, we produce an rvalue out.\n-        let (llptr, kind) = match datum.kind {\n-            LvalueExpr => {\n-                (Load(bcx, datum.val), LvalueExpr)\n-            }\n-            RvalueExpr(Rvalue { mode: ByRef }) => {\n-                (Load(bcx, datum.val), RvalueExpr(Rvalue::new(ByRef)))\n-            }\n-            RvalueExpr(Rvalue { mode: ByValue }) => {\n-                (datum.val, RvalueExpr(Rvalue::new(ByRef)))\n-            }\n-        };\n-\n-        let datum = Datum { ty: content_ty, val: llptr, kind: kind };\n-        DatumBlock { bcx: bcx, datum: datum }\n-    }\n }\n \n #[derive(Debug)]"}, {"sha": "3d8e0556a560e1851ee8885e8734685ed385249a", "filename": "src/test/run-pass/issue-18845.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Ftest%2Frun-pass%2Fissue-18845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Ftest%2Frun-pass%2Fissue-18845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18845.rs?ref=cec980a1a706fd6afc27dd54c1eed7c51800d753", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This used to generate invalid IR in that even if we took the\n+// `false` branch we'd still try to free the Box from the other\n+// arm. This was due to treating `*Box::new(9)` as an rvalue datum\n+// instead of as an lvalue.\n+\n+fn test(foo: bool) -> u8 {\n+    match foo {\n+        true => *Box::new(9),\n+        false => 0\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(9, test(true));\n+}"}, {"sha": "730b0a274bfa59715f3238aed725f9225bf9056b", "filename": "src/test/run-pass/issue-25497.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Ftest%2Frun-pass%2Fissue-25497.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cec980a1a706fd6afc27dd54c1eed7c51800d753/src%2Ftest%2Frun-pass%2Fissue-25497.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25497.rs?ref=cec980a1a706fd6afc27dd54c1eed7c51800d753", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum Expression {\n+    Dummy,\n+    Add(Box<Expression>),\n+}\n+\n+use Expression::*;\n+\n+fn simplify(exp: Expression) -> Expression {\n+    match exp {\n+        Add(n) => *n.clone(),\n+        _ => Dummy\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(simplify(Add(Box::new(Dummy))), Dummy);\n+}"}]}