{"sha": "4be778633073cb3b4a036b8ecc469b2892f12367", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZTc3ODYzMzA3M2NiM2I0YTAzNmI4ZWNjNDY5YjI4OTJmMTIzNjc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-20T01:42:54Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-23T23:40:56Z"}, "message": "rustdoc: we can now assume DocContext always has a TyCtxt.", "tree": {"sha": "36ef5f3e6e2e661f6549dd57982067f64e33ffa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ef5f3e6e2e661f6549dd57982067f64e33ffa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be778633073cb3b4a036b8ecc469b2892f12367", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be778633073cb3b4a036b8ecc469b2892f12367", "html_url": "https://github.com/rust-lang/rust/commit/4be778633073cb3b4a036b8ecc469b2892f12367", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be778633073cb3b4a036b8ecc469b2892f12367/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d", "html_url": "https://github.com/rust-lang/rust/commit/e68ad42dfa94a25a6b1a30bba3bbddb1fde7ba2d"}], "stats": {"total": 548, "additions": 220, "deletions": 328}, "files": [{"sha": "c5562ae3b7febf5753f6a649a011ccc824847e1c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 84, "deletions": 105, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4be778633073cb3b4a036b8ecc469b2892f12367", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n use rustc_const_eval::lookup_const_by_id;\n@@ -43,17 +43,13 @@ use super::Clean;\n /// of a vector of items if it was successfully expanded.\n pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n                   -> Option<Vec<clean::Item>> {\n-    let tcx = match cx.tcx_opt() {\n-        Some(tcx) => tcx,\n-        None => return None,\n-    };\n-    let def = match tcx.expect_def_or_none(id) {\n+    let def = match cx.tcx.expect_def_or_none(id) {\n         Some(def) => def,\n         None => return None,\n     };\n     let did = def.def_id();\n     if did.is_local() { return None }\n-    try_inline_def(cx, tcx, def).map(|vec| {\n+    try_inline_def(cx, def).map(|vec| {\n         vec.into_iter().map(|mut item| {\n             match into {\n                 Some(into) if item.name.is_some() => {\n@@ -66,39 +62,38 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n     })\n }\n \n-fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def: Def) -> Option<Vec<clean::Item>> {\n+fn try_inline_def(cx: &DocContext, def: Def) -> Option<Vec<clean::Item>> {\n+    let tcx = cx.tcx;\n     let mut ret = Vec::new();\n-    let did = def.def_id();\n     let inner = match def {\n         Def::Trait(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::TraitItem(build_external_trait(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::TraitItem(build_external_trait(cx, did))\n         }\n         Def::Fn(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Function);\n-            clean::FunctionItem(build_external_function(cx, tcx, did))\n+            clean::FunctionItem(build_external_function(cx, did))\n         }\n         Def::Struct(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::StructItem(build_struct(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::StructItem(build_struct(cx, did))\n         }\n         Def::Union(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::UnionItem(build_union(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::UnionItem(build_union(cx, did))\n         }\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::TypedefItem(build_type_alias(cx, tcx, did), false)\n+            ret.extend(build_impls(cx, did));\n+            clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, tcx, did));\n-            clean::EnumItem(build_enum(cx, tcx, did))\n+            ret.extend(build_impls(cx, did));\n+            clean::EnumItem(build_enum(cx, did))\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n@@ -108,23 +103,24 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Def::StructCtor(..) => return Some(Vec::new()),\n         Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n-            clean::ModuleItem(build_module(cx, tcx, did))\n+            clean::ModuleItem(build_module(cx, did))\n         }\n         Def::Static(did, mtbl) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Static);\n-            clean::StaticItem(build_static(cx, tcx, did, mtbl))\n+            clean::StaticItem(build_static(cx, did, mtbl))\n         }\n         Def::Const(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n-            clean::ConstantItem(build_const(cx, tcx, did))\n+            clean::ConstantItem(build_const(cx, did))\n         }\n         _ => return None,\n     };\n+    let did = def.def_id();\n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(tcx.item_name(did).to_string()),\n-        attrs: load_attrs(cx, tcx, did),\n+        attrs: load_attrs(cx, did),\n         inner: inner,\n         visibility: Some(clean::Public),\n         stability: tcx.lookup_stability(did).clean(cx),\n@@ -134,37 +130,33 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Some(ret)\n }\n \n-pub fn load_attrs<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            did: DefId) -> clean::Attributes {\n-    tcx.get_attrs(did).clean(cx)\n+pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n+    cx.tcx.get_attrs(did).clean(cx)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    if let Some(tcx) = cx.tcx_opt() {\n-        let crate_name = tcx.sess.cstore.crate_name(did.krate).to_string();\n-        let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-            // extern blocks have an empty name\n-            let s = elem.data.to_string();\n-            if !s.is_empty() {\n-                Some(s)\n-            } else {\n-                None\n-            }\n-        });\n-        let fqn = once(crate_name).chain(relative).collect();\n-        cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n-    }\n+    let crate_name = cx.tcx.sess.cstore.crate_name(did.krate).to_string();\n+    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n+        // extern blocks have an empty name\n+        let s = elem.data.to_string();\n+        if !s.is_empty() {\n+            Some(s)\n+        } else {\n+            None\n+        }\n+    });\n+    let fqn = once(crate_name).chain(relative).collect();\n+    cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n }\n \n-pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      did: DefId) -> clean::Trait {\n-    let def = tcx.lookup_trait_def(did);\n-    let trait_items = tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n-    let predicates = tcx.item_predicates(did);\n+pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n+    let def = cx.tcx.lookup_trait_def(did);\n+    let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n+    let predicates = cx.tcx.item_predicates(did);\n     let generics = (def.generics, &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n@@ -176,90 +168,84 @@ pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tc\n     }\n }\n \n-fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     did: DefId) -> clean::Function {\n-    let ty = tcx.item_type(did);\n+fn build_external_function(cx: &DocContext, did: DefId) -> clean::Function {\n+    let ty = cx.tcx.item_type(did);\n     let (decl, style, abi) = match ty.sty {\n         ty::TyFnDef(.., ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n         _ => panic!(\"bad function\"),\n     };\n \n-    let constness = if tcx.sess.cstore.is_const_fn(did) {\n+    let constness = if cx.tcx.sess.cstore.is_const_fn(did) {\n         hir::Constness::Const\n     } else {\n         hir::Constness::NotConst\n     };\n \n-    let predicates = tcx.item_predicates(did);\n+    let predicates = cx.tcx.item_predicates(did);\n     clean::Function {\n         decl: decl,\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         unsafety: style,\n         constness: constness,\n         abi: abi,\n     }\n }\n \n-fn build_enum<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        did: DefId) -> clean::Enum {\n-    let predicates = tcx.item_predicates(did);\n+fn build_enum(cx: &DocContext, did: DefId) -> clean::Enum {\n+    let predicates = cx.tcx.item_predicates(did);\n \n     clean::Enum {\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         variants_stripped: false,\n-        variants: tcx.lookup_adt_def(did).variants.clean(cx),\n+        variants: cx.tcx.lookup_adt_def(did).variants.clean(cx),\n     }\n }\n \n-fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId) -> clean::Struct {\n-    let predicates = tcx.item_predicates(did);\n-    let variant = tcx.lookup_adt_def(did).struct_variant();\n+fn build_struct(cx: &DocContext, did: DefId) -> clean::Struct {\n+    let predicates = cx.tcx.item_predicates(did);\n+    let variant = cx.tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n         struct_type: match variant.ctor_kind {\n             CtorKind::Fictive => doctree::Plain,\n             CtorKind::Fn => doctree::Tuple,\n             CtorKind::Const => doctree::Unit,\n         },\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n-fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId) -> clean::Union {\n-    let predicates = tcx.item_predicates(did);\n-    let variant = tcx.lookup_adt_def(did).struct_variant();\n+fn build_union(cx: &DocContext, did: DefId) -> clean::Union {\n+    let predicates = cx.tcx.item_predicates(did);\n+    let variant = cx.tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Union {\n         struct_type: doctree::Plain,\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n         fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n-fn build_type_alias<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              did: DefId) -> clean::Typedef {\n-    let predicates = tcx.item_predicates(did);\n+fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n+    let predicates = cx.tcx.item_predicates(did);\n \n     clean::Typedef {\n-        type_: tcx.item_type(did).clean(cx),\n-        generics: (tcx.item_generics(did), &predicates).clean(cx),\n+        type_: cx.tcx.item_type(did).clean(cx),\n+        generics: (cx.tcx.item_generics(did), &predicates).clean(cx),\n     }\n }\n \n-pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n+    let tcx = cx.tcx;\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n     if let Some(i) = tcx.inherent_impls.borrow().get(&did) {\n         for &did in i.iter() {\n-            build_impl(cx, tcx, did, &mut impls);\n+            build_impl(cx, did, &mut impls);\n         }\n     }\n     // If this is the first time we've inlined something from another crate, then\n@@ -277,7 +263,7 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n     cx.populated_all_crate_impls.set(true);\n \n     for did in tcx.sess.cstore.implementations_of_trait(None) {\n-        build_impl(cx, tcx, did, &mut impls);\n+        build_impl(cx, did, &mut impls);\n     }\n \n     // Also try to inline primitive impls from other crates.\n@@ -303,22 +289,20 @@ pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n         if !def_id.is_local() {\n-            build_impl(cx, tcx, def_id, &mut impls);\n+            build_impl(cx, def_id, &mut impls);\n         }\n     }\n \n     impls\n }\n \n-pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            did: DefId,\n-                            ret: &mut Vec<clean::Item>) {\n+pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n \n-    let attrs = load_attrs(cx, tcx, did);\n+    let attrs = load_attrs(cx, did);\n+    let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);\n \n     // Only inline impl if the implemented trait is\n@@ -440,15 +424,15 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n             clean::RegionBound(..) => unreachable!(),\n         }\n     });\n-    if trait_.def_id() == cx.deref_trait_did.get() {\n+    if trait_.def_id() == tcx.lang_items.deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n \n     let provided = trait_.def_id().map(|did| {\n-        cx.tcx().provided_trait_methods(did)\n-                .into_iter()\n-                .map(|meth| meth.name.to_string())\n-                .collect()\n+        tcx.provided_trait_methods(did)\n+            .into_iter()\n+            .map(|meth| meth.name.to_string())\n+            .collect()\n     }).unwrap_or(FxHashSet());\n \n     ret.push(clean::Item {\n@@ -471,53 +455,48 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     });\n }\n \n-fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId) -> clean::Module {\n+fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n     let mut items = Vec::new();\n-    fill_in(cx, tcx, did, &mut items);\n+    fill_in(cx, did, &mut items);\n     return clean::Module {\n         items: items,\n         is_crate: false,\n     };\n \n-    fn fill_in<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         did: DefId, items: &mut Vec<clean::Item>) {\n+    fn fill_in(cx: &DocContext, did: DefId, items: &mut Vec<clean::Item>) {\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n         let mut visited = FxHashSet();\n-        for item in tcx.sess.cstore.item_children(did) {\n+        for item in cx.tcx.sess.cstore.item_children(did) {\n             let def_id = item.def.def_id();\n-            if tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n+            if cx.tcx.sess.cstore.visibility(def_id) == ty::Visibility::Public {\n                 if !visited.insert(def_id) { continue }\n-                if let Some(i) = try_inline_def(cx, tcx, item.def) {\n+                if let Some(i) = try_inline_def(cx, item.def) {\n                     items.extend(i)\n                 }\n             }\n         }\n     }\n }\n \n-fn build_const<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         did: DefId) -> clean::Constant {\n-    let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n+fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n+    let (expr, ty) = lookup_const_by_id(cx.tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n     debug!(\"converting constant expr {:?} to snippet\", expr);\n     let sn = pprust::expr_to_string(expr);\n     debug!(\"got snippet {}\", sn);\n \n     clean::Constant {\n-        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| tcx.item_type(did).clean(cx)),\n+        type_: ty.map(|t| t.clean(cx)).unwrap_or_else(|| cx.tcx.item_type(did).clean(cx)),\n         expr: sn\n     }\n }\n \n-fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          did: DefId,\n-                          mutable: bool) -> clean::Static {\n+fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n-        type_: tcx.item_type(did).clean(cx),\n+        type_: cx.tcx.item_type(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }"}, {"sha": "a19ec4e8b5edbf6bd57d71163b324764f2f7db5b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 116, "deletions": 167, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4be778633073cb3b4a036b8ecc469b2892f12367", "patch": "@@ -58,11 +58,11 @@ mod simplify;\n \n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n-    cx.tcx_opt().and_then(|tcx| tcx.lookup_stability(def_id)).clean(cx)\n+    cx.tcx.lookup_stability(def_id).clean(cx)\n }\n \n fn get_deprecation(cx: &DocContext, def_id: DefId) -> Option<Deprecation> {\n-    cx.tcx_opt().and_then(|tcx| tcx.lookup_deprecation(def_id)).clean(cx)\n+    cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n pub trait Clean<T> {\n@@ -125,20 +125,17 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n         use rustc::session::config::Input;\n         use ::visit_lib::LibEmbargoVisitor;\n \n-        if let Some(t) = cx.tcx_opt() {\n-            cx.deref_trait_did.set(t.lang_items.deref_trait());\n-            cx.renderinfo.borrow_mut().deref_trait_did = cx.deref_trait_did.get();\n-            cx.deref_mut_trait_did.set(t.lang_items.deref_mut_trait());\n-            cx.renderinfo.borrow_mut().deref_mut_trait_did = cx.deref_mut_trait_did.get();\n+        {\n+            let mut r = cx.renderinfo.borrow_mut();\n+            r.deref_trait_did = cx.tcx.lang_items.deref_trait();\n+            r.deref_mut_trait_did = cx.tcx.lang_items.deref_mut_trait();\n         }\n \n         let mut externs = Vec::new();\n         for cnum in cx.sess().cstore.crates() {\n             externs.push((cnum, CrateNum(cnum).clean(cx)));\n-            if cx.tcx_opt().is_some() {\n-                // Analyze doc-reachability for extern items\n-                LibEmbargoVisitor::new(cx).visit_lib(cnum);\n-            }\n+            // Analyze doc-reachability for extern items\n+            LibEmbargoVisitor::new(cx).visit_lib(cnum);\n         }\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n@@ -234,12 +231,10 @@ impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext) -> ExternalCrate {\n         let mut primitives = Vec::new();\n         let root = DefId { krate: self.0, index: CRATE_DEF_INDEX };\n-        cx.tcx_opt().map(|tcx| {\n-            for item in tcx.sess.cstore.item_children(root) {\n-                let attrs = inline::load_attrs(cx, tcx, item.def.def_id());\n-                PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n-            }\n-        });\n+        for item in cx.tcx.sess.cstore.item_children(root) {\n+            let attrs = inline::load_attrs(cx, item.def.def_id());\n+            PrimitiveType::find(&attrs).map(|prim| primitives.push(prim));\n+        }\n         ExternalCrate {\n             name: cx.sess().cstore.crate_name(self.0).to_string(),\n             attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n@@ -449,7 +444,7 @@ impl Clean<Item> for doctree::Module {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n                items: items\n@@ -571,7 +566,7 @@ impl Clean<TyParam> for hir::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n             name: self.name.clean(cx),\n-            did: cx.map.local_def_id(self.id),\n+            did: cx.tcx.map.local_def_id(self.id),\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n         }\n@@ -608,11 +603,9 @@ impl TyParamBound {\n \n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n-        if let Some(tcx) = cx.tcx_opt() {\n-            if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-                if trait_.def_id() == tcx.lang_items.sized_trait() {\n-                    return true;\n-                }\n+        if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n+            if trait_.def_id() == cx.tcx.lang_items.sized_trait() {\n+                return true;\n             }\n         }\n         false\n@@ -633,9 +626,9 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n     let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n-    match (trait_did, cx.tcx_opt()) {\n+    match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        (Some(did), Some(ref tcx)) if tcx.lang_items.fn_trait_kind(did).is_some() => {\n+        Some(did) if cx.tcx.lang_items.fn_trait_kind(did).is_some() => {\n             assert_eq!(types.len(), 1);\n             let inputs = match types[0].sty {\n                 ty::TyTuple(ref tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n@@ -658,7 +651,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: boo\n                 output: output\n             }\n         },\n-        (..) => {\n+        _ => {\n             PathParameters::AngleBracketed {\n                 lifetimes: lifetimes,\n                 types: types.clean(cx),\n@@ -683,10 +676,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n \n impl Clean<TyParamBound> for ty::BuiltinBound {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        let tcx = match cx.tcx_opt() {\n-            Some(tcx) => tcx,\n-            None => return RegionBound(Lifetime::statik())\n-        };\n+        let tcx = cx.tcx;\n         let empty = tcx.intern_substs(&[]);\n         let (did, path) = match *self {\n             ty::BoundSend =>\n@@ -717,12 +707,8 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n \n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n-        let tcx = match cx.tcx_opt() {\n-            Some(tcx) => tcx,\n-            None => return RegionBound(Lifetime::statik())\n-        };\n         inline::record_extern_fqn(cx, self.def_id, TypeKind::Trait);\n-        let path = external_path(cx, &tcx.item_name(self.def_id).as_str(),\n+        let path = external_path(cx, &cx.tcx.item_name(self.def_id).as_str(),\n                                  Some(self.def_id), true, vec![], self.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", self.substs);\n@@ -789,18 +775,16 @@ impl Lifetime {\n \n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext) -> Lifetime {\n-        if let Some(tcx) = cx.tcx_opt() {\n-            let def = tcx.named_region_map.defs.get(&self.id).cloned();\n-            match def {\n-                Some(DefEarlyBoundRegion(_, node_id)) |\n-                Some(DefLateBoundRegion(_, node_id)) |\n-                Some(DefFreeRegion(_, node_id)) => {\n-                    if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n-                        return lt;\n-                    }\n+        let def = cx.tcx.named_region_map.defs.get(&self.id).cloned();\n+        match def {\n+            Some(DefEarlyBoundRegion(_, node_id)) |\n+            Some(DefLateBoundRegion(_, node_id)) |\n+            Some(DefFreeRegion(_, node_id)) => {\n+                if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n+                    return lt;\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n         Lifetime(self.name.to_string())\n     }\n@@ -1122,7 +1106,7 @@ impl Clean<Item> for doctree::Function {\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(cx),\n                 generics: self.generics.clean(cx),\n@@ -1173,10 +1157,10 @@ impl Clean<FnDecl> for hir::FnDecl {\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.map.as_local_node_id(did).is_some() {\n+        let mut names = if cx.tcx.map.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n-            cx.tcx().sess.cstore.fn_arg_names(did).into_iter()\n+            cx.tcx.sess.cstore.fn_arg_names(did).into_iter()\n         }.peekable();\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n@@ -1264,7 +1248,7 @@ impl Clean<Item> for doctree::Trait {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -1314,10 +1298,10 @@ impl Clean<Item> for hir::TraitItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: None,\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1346,10 +1330,10 @@ impl Clean<Item> for hir::ImplItem {\n             name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n             inner: inner\n         }\n     }\n@@ -1359,13 +1343,13 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n-                let ty = cx.tcx().item_type(self.def_id);\n+                let ty = cx.tcx.item_type(self.def_id);\n                 AssociatedConstItem(ty.clean(cx), None)\n             }\n             ty::AssociatedKind::Method => {\n-                let generics = (cx.tcx().item_generics(self.def_id),\n-                                &cx.tcx().item_predicates(self.def_id)).clean(cx);\n-                let fty = match cx.tcx().item_type(self.def_id).sty {\n+                let generics = (cx.tcx.item_generics(self.def_id),\n+                                &cx.tcx.item_predicates(self.def_id)).clean(cx);\n+                let fty = match cx.tcx.item_type(self.def_id).sty {\n                     ty::TyFnDef(_, _, f) => f,\n                     _ => unreachable!()\n                 };\n@@ -1374,9 +1358,9 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 if self.method_has_self_argument {\n                     let self_ty = match self.container {\n                         ty::ImplContainer(def_id) => {\n-                            cx.tcx().item_type(def_id)\n+                            cx.tcx.item_type(def_id)\n                         }\n-                        ty::TraitContainer(_) => cx.tcx().mk_self_type()\n+                        ty::TraitContainer(_) => cx.tcx.mk_self_type()\n                     };\n                     let self_arg_ty = *fty.sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n@@ -1422,8 +1406,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // are actually located on the trait/impl itself, so we need to load\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n-                    let def = cx.tcx().lookup_trait_def(did);\n-                    let predicates = cx.tcx().item_predicates(did);\n+                    let def = cx.tcx.lookup_trait_def(did);\n+                    let predicates = cx.tcx.item_predicates(did);\n                     let generics = (def.generics, &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n@@ -1459,7 +1443,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n \n                 let ty = if self.defaultness.has_value() {\n-                    Some(cx.tcx().item_type(self.def_id))\n+                    Some(cx.tcx.item_type(self.def_id))\n                 } else {\n                     None\n                 };\n@@ -1474,7 +1458,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.def_id),\n+            attrs: inline::load_attrs(cx, self.def_id),\n             source: Span::empty(),\n             inner: inner,\n         }\n@@ -1727,53 +1711,44 @@ impl Clean<Type> for hir::Ty {\n                              type_: box m.ty.clean(cx)},\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n             TyArray(ref ty, ref e) => {\n-                let n = if let Some(tcx) = cx.tcx_opt() {\n-                    use rustc_const_math::{ConstInt, ConstUsize};\n-                    use rustc_const_eval::eval_const_expr;\n-                    use rustc::middle::const_val::ConstVal;\n-                    match eval_const_expr(tcx, e) {\n-                        ConstVal::Integral(ConstInt::Usize(u)) => match u {\n-                            ConstUsize::Us16(u) => u.to_string(),\n-                            ConstUsize::Us32(u) => u.to_string(),\n-                            ConstUsize::Us64(u) => u.to_string(),\n-                        },\n-                        // after type checking this can't fail\n-                        _ => unreachable!(),\n-                    }\n-                } else {\n-                    pprust::expr_to_string(e)\n+                use rustc_const_math::{ConstInt, ConstUsize};\n+                use rustc_const_eval::eval_const_expr;\n+                use rustc::middle::const_val::ConstVal;\n+\n+                let n = match eval_const_expr(cx.tcx, e) {\n+                    ConstVal::Integral(ConstInt::Usize(u)) => match u {\n+                        ConstUsize::Us16(u) => u.to_string(),\n+                        ConstUsize::Us32(u) => u.to_string(),\n+                        ConstUsize::Us64(u) => u.to_string(),\n+                    },\n+                    // after type checking this can't fail\n+                    _ => unreachable!(),\n                 };\n                 FixedVector(box ty.clean(cx), n)\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref path) => {\n-                let tcx_and_def = cx.tcx_opt().map(|tcx| (tcx, tcx.expect_def(self.id)));\n-                if let Some((_, def)) = tcx_and_def {\n-                    if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n-                        return new_ty;\n-                    }\n+                let def = cx.tcx.expect_def(self.id);\n+                if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n+                    return new_ty;\n                 }\n \n-                let tcx_and_alias = tcx_and_def.and_then(|(tcx, def)| {\n-                    if let Def::TyAlias(def_id) = def {\n-                        // Substitute private type aliases\n-                        tcx.map.as_local_node_id(def_id).and_then(|node_id| {\n-                            if !cx.access_levels.borrow().is_exported(def_id) {\n-                                Some((tcx, &tcx.map.expect_item(node_id).node))\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                    } else {\n-                        None\n+                let mut alias = None;\n+                if let Def::TyAlias(def_id) = def {\n+                    // Substitute private type aliases\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def_id) {\n+                        if !cx.access_levels.borrow().is_exported(def_id) {\n+                            alias = Some(&cx.tcx.map.expect_item(node_id).node);\n+                        }\n                     }\n-                });\n-                if let Some((tcx, &hir::ItemTy(ref ty, ref generics))) = tcx_and_alias {\n+                };\n+\n+                if let Some(&hir::ItemTy(ref ty, ref generics)) = alias {\n                     let provided_params = &path.segments.last().unwrap().parameters;\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = tcx.expect_def(ty_param.id);\n+                        let ty_param_def = cx.tcx.expect_def(ty_param.id);\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n                                                                         .cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n@@ -1841,9 +1816,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n             ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TyBox(t) => {\n-                let box_did = cx.tcx_opt().and_then(|tcx| {\n-                    tcx.lang_items.owned_box()\n-                });\n+                let box_did = cx.tcx.lang_items.owned_box();\n                 lang_struct(cx, box_did, t, \"Box\", Unique)\n             }\n             ty::TySlice(ty) => Vector(box ty.clean(cx)),\n@@ -1863,7 +1836,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (cx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n+                decl: (cx.tcx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n                 abi: fty.abi,\n             }),\n             ty::TyAdt(def, substs) => {\n@@ -1874,7 +1847,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     AdtKind::Enum => TypeKind::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          None, false, vec![], substs);\n                 ResolvedPath {\n                     path: path,\n@@ -1901,7 +1874,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     });\n                 }\n \n-                let path = external_path(cx, &cx.tcx().item_name(did).as_str(),\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n                                          Some(did), false, bindings, obj.principal.0.substs);\n                 ResolvedPath {\n                     path: path,\n@@ -1919,9 +1892,9 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             ty::TyAnon(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                 // by looking up the projections associated with the def_id.\n-                let item_predicates = cx.tcx().item_predicates(def_id);\n-                let substs = cx.tcx().lift(&substs).unwrap();\n-                let bounds = item_predicates.instantiate(cx.tcx(), substs);\n+                let item_predicates = cx.tcx.item_predicates(def_id);\n+                let substs = cx.tcx.lift(&substs).unwrap();\n+                let bounds = item_predicates.instantiate(cx.tcx, substs);\n                 ImplTrait(bounds.predicates.into_iter().filter_map(|predicate| {\n                     predicate.to_opt_poly_trait_ref().clean(cx)\n                 }).collect())\n@@ -1942,9 +1915,9 @@ impl Clean<Item> for hir::StructField {\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n-            def_id: cx.map.local_def_id(self.id),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n@@ -1954,7 +1927,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             name: Some(self.name).clean(cx),\n-            attrs: cx.tcx().get_attrs(self.did).clean(cx),\n+            attrs: cx.tcx.get_attrs(self.did).clean(cx),\n             source: Span::empty(),\n             visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n@@ -2005,7 +1978,7 @@ impl Clean<Item> for doctree::Struct {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2025,7 +1998,7 @@ impl Clean<Item> for doctree::Union {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2072,7 +2045,7 @@ impl Clean<Item> for doctree::Enum {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2099,7 +2072,7 @@ impl Clean<Item> for doctree::Variant {\n             visibility: None,\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.def.id()),\n+            def_id: cx.tcx.map.local_def_id(self.def.id()),\n             inner: VariantItem(Variant {\n                 kind: self.def.clean(cx),\n             }),\n@@ -2124,7 +2097,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                         Item {\n                             source: Span::empty(),\n                             name: Some(field.name.clean(cx)),\n-                            attrs: cx.tcx().get_attrs(field.did).clean(cx),\n+                            attrs: cx.tcx.get_attrs(field.did).clean(cx),\n                             visibility: field.vis.clean(cx),\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n@@ -2137,7 +2110,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n         };\n         Item {\n             name: Some(self.name.clean(cx)),\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.did),\n+            attrs: inline::load_attrs(cx, self.did),\n             source: Span::empty(),\n             visibility: Some(Inherited),\n             def_id: self.did,\n@@ -2322,7 +2295,7 @@ impl Clean<Item> for doctree::Typedef {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id.clone()),\n+            def_id: cx.tcx.map.local_def_id(self.id.clone()),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2374,7 +2347,7 @@ impl Clean<Item> for doctree::Static {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2399,7 +2372,7 @@ impl Clean<Item> for doctree::Constant {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2460,24 +2433,22 @@ impl Clean<Vec<Item>> for doctree::Impl {\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n-        if trait_.def_id() == cx.deref_trait_did.get() {\n+        if trait_.def_id() == cx.tcx.lang_items.deref_trait() {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n-        let provided = trait_.def_id().and_then(|did| {\n-            cx.tcx_opt().map(|tcx| {\n-                tcx.provided_trait_methods(did)\n-                   .into_iter()\n-                   .map(|meth| meth.name.to_string())\n-                   .collect()\n-            })\n+        let provided = trait_.def_id().map(|did| {\n+            cx.tcx.provided_trait_methods(did)\n+                  .into_iter()\n+                  .map(|meth| meth.name.to_string())\n+                  .collect()\n         }).unwrap_or(FxHashSet());\n \n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n@@ -2498,10 +2469,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n fn build_deref_target_impls(cx: &DocContext,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n-    let tcx = match cx.tcx_opt() {\n-        Some(t) => t,\n-        None => return,\n-    };\n+    let tcx = cx.tcx;\n \n     for item in items {\n         let target = match item.inner {\n@@ -2511,7 +2479,7 @@ fn build_deref_target_impls(cx: &DocContext,\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, tcx, did));\n+                ret.extend(inline::build_impls(cx, did));\n                 continue\n             }\n             _ => match target.primitive_type() {\n@@ -2542,7 +2510,7 @@ fn build_deref_target_impls(cx: &DocContext,\n         };\n         if let Some(did) = did {\n             if !did.is_local() {\n-                inline::build_impl(cx, tcx, did, ret);\n+                inline::build_impl(cx, did, ret);\n             }\n         }\n     }\n@@ -2560,7 +2528,7 @@ impl Clean<Item> for doctree::DefaultImpl {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: Some(Public),\n             stability: None,\n             deprecation: None,\n@@ -2644,7 +2612,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(ast::CRATE_NODE_ID),\n+            def_id: cx.tcx.map.local_def_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,\n@@ -2723,10 +2691,10 @@ impl Clean<Item> for hir::ForeignItem {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, cx.map.local_def_id(self.id)),\n-            deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n+            stability: get_stability(cx, cx.tcx.map.local_def_id(self.id)),\n+            deprecation: get_deprecation(cx, cx.tcx.map.local_def_id(self.id)),\n             inner: inner,\n         }\n     }\n@@ -2793,22 +2761,7 @@ fn resolve_type(cx: &DocContext,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n-    let tcx = match cx.tcx_opt() {\n-        Some(tcx) => tcx,\n-        // If we're extracting tests, this return value's accuracy is not\n-        // important, all we want is a string representation to help people\n-        // figure out what doctests are failing.\n-        None => {\n-            let did = DefId::local(DefIndex::from_u32(0));\n-            return ResolvedPath {\n-                path: path,\n-                typarams: None,\n-                did: did,\n-                is_generic: false\n-            };\n-        }\n-    };\n-    let def = tcx.expect_def(id);\n+    let def = cx.tcx.expect_def(id);\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n@@ -2833,8 +2786,6 @@ fn resolve_type(cx: &DocContext,\n fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n-    let tcx = cx.tcx();\n-\n     let (did, kind) = match def {\n         Def::Fn(i) => (i, TypeKind::Function),\n         Def::TyAlias(i) => (i, TypeKind::Typedef),\n@@ -2844,7 +2795,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Union(i) => (i, TypeKind::Union),\n         Def::Mod(i) => (i, TypeKind::Module),\n         Def::Static(i, _) => (i, TypeKind::Static),\n-        Def::Variant(i) => (tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n@@ -2854,7 +2805,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     if did.is_local() { return did }\n     inline::record_extern_fqn(cx, did, kind);\n     if let TypeKind::Trait = kind {\n-        let t = inline::build_external_trait(cx, tcx, did);\n+        let t = inline::build_external_trait(cx, did);\n         cx.external_traits.borrow_mut().insert(did, t);\n     }\n     did\n@@ -2868,9 +2819,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n }\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n-    cx.tcx_opt().and_then(|tcx| {\n-        tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n-    })\n+    cx.tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2889,7 +2838,7 @@ impl Clean<Item> for doctree::Macro {\n             visibility: Some(Public),\n             stability: self.stab.clean(cx),\n             deprecation: self.depr.clean(cx),\n-            def_id: cx.map.local_def_id(self.id),\n+            def_id: cx.tcx.map.local_def_id(self.id),\n             inner: MacroItem(Macro {\n                 source: format!(\"macro_rules! {} {{\\n{}}}\",\n                                 name,"}, {"sha": "7240f0aedbd2770fd38ab4da16a0fdff138faa41", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=4be778633073cb3b4a036b8ecc469b2892f12367", "patch": "@@ -153,7 +153,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext, child: DefId,\n     if child == trait_ {\n         return true\n     }\n-    let predicates = cx.tcx().item_super_predicates(child).predicates;\n+    let predicates = cx.tcx.item_super_predicates(child).predicates;\n     predicates.iter().filter_map(|pred| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n             if pred.0.trait_ref.self_ty().is_self() {"}, {"sha": "7d7b7fead5854d9fbd9944dc32f7e904fb6e8d32", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4be778633073cb3b4a036b8ecc469b2892f12367", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-pub use self::MaybeTyped::*;\n \n use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n@@ -42,21 +41,12 @@ use html::render::RenderInfo;\n pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n \n-/// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n-pub enum MaybeTyped<'a, 'tcx: 'a> {\n-    Typed(TyCtxt<'a, 'tcx, 'tcx>),\n-    NotTyped(&'a session::Session)\n-}\n-\n pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n-    pub map: &'a hir_map::Map<'tcx>,\n-    pub maybe_typed: MaybeTyped<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub input: Input,\n     pub populated_all_crate_impls: Cell<bool>,\n-    pub deref_trait_did: Cell<Option<DefId>>,\n-    pub deref_mut_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n@@ -77,24 +67,9 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub export_map: ExportMap,\n }\n \n-impl<'b, 'tcx> DocContext<'b, 'tcx> {\n-    pub fn sess<'a>(&'a self) -> &'a session::Session {\n-        match self.maybe_typed {\n-            Typed(tcx) => &tcx.sess,\n-            NotTyped(ref sess) => sess\n-        }\n-    }\n-\n-    pub fn tcx_opt<'a>(&'a self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n-        match self.maybe_typed {\n-            Typed(tcx) => Some(tcx),\n-            NotTyped(_) => None\n-        }\n-    }\n-\n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        let tcx_opt = self.tcx_opt();\n-        tcx_opt.expect(\"tcx not present\")\n+impl<'a, 'tcx> DocContext<'a, 'tcx> {\n+    pub fn sess(&self) -> &session::Session {\n+        &self.tcx.sess\n     }\n \n     /// Call the closure with the given parameters set as\n@@ -208,24 +183,21 @@ pub fn run_core(search_paths: SearchPaths,\n         };\n \n         let ctxt = DocContext {\n-            map: &tcx.map,\n-            maybe_typed: Typed(tcx),\n+            tcx: tcx,\n             input: input,\n             populated_all_crate_impls: Cell::new(false),\n-            deref_trait_did: Cell::new(None),\n-            deref_mut_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),\n             external_traits: Default::default(),\n             renderinfo: Default::default(),\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n             export_map: export_map,\n         };\n-        debug!(\"crate: {:?}\", ctxt.map.krate());\n+        debug!(\"crate: {:?}\", tcx.map.krate());\n \n         let krate = {\n             let mut v = RustdocVisitor::new(&ctxt);\n-            v.visit(ctxt.map.krate());\n+            v.visit(tcx.map.krate());\n             v.clean(&ctxt)\n         };\n "}, {"sha": "8ed0567d820ac4af27ea5df04f26f3700374e3ee", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4be778633073cb3b4a036b8ecc469b2892f12367", "patch": "@@ -65,18 +65,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx_opt().and_then(|tcx| {\n-            self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| tcx.lookup_stability(def_id))\n-                       .cloned()\n-        })\n+        self.cx.tcx.map.opt_local_def_id(id)\n+            .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n     }\n \n     fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n-        self.cx.tcx_opt().and_then(|tcx| {\n-            self.cx.map.opt_local_def_id(id)\n-                       .and_then(|def_id| tcx.lookup_deprecation(def_id))\n-        })\n+        self.cx.tcx.map.opt_local_def_id(id)\n+            .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n     pub fn visit(&mut self, krate: &hir::Crate) {\n@@ -196,7 +191,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis == hir::Public;\n         for i in &m.item_ids {\n-            let item = self.cx.map.expect_item(i.id);\n+            let item = self.cx.tcx.map.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -279,9 +274,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                   glob: bool, om: &mut Module, please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n-            while let Some(id) = cx.map.get_enclosing_scope(node) {\n+            while let Some(id) = cx.tcx.map.get_enclosing_scope(node) {\n                 node = id;\n-                if cx.map.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n+                if cx.tcx.map.attrs(node).lists(\"doc\").has_word(\"hidden\") {\n                     return true;\n                 }\n                 if node == ast::CRATE_NODE_ID {\n@@ -291,10 +286,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             false\n         }\n \n-        let tcx = match self.cx.tcx_opt() {\n-            Some(tcx) => tcx,\n-            None => return false\n-        };\n+        let tcx = self.cx.tcx;\n         let def = tcx.expect_def(id);\n         let def_did = def.def_id();\n \n@@ -308,7 +300,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront)\n         if !def_did.is_local() && !is_no_inline {\n-            let attrs = clean::inline::load_attrs(self.cx, tcx, def_did);\n+            let attrs = clean::inline::load_attrs(self.cx, def_did);\n             let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n             match def {\n                 Def::Trait(did) |\n@@ -347,7 +339,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     match it.node {\n                         hir::ItemMod(ref m) => {\n                             for i in &m.item_ids {\n-                                let i = self.cx.map.expect_item(i.id);\n+                                let i = self.cx.tcx.map.expect_item(i.id);\n                                 self.visit_item(i, None, om);\n                             }\n                         }\n@@ -506,7 +498,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // regardless of where they're located.\n                 if !self.inlining {\n                     let items = item_ids.iter()\n-                                        .map(|ii| self.cx.map.impl_item(ii.id).clone())\n+                                        .map(|ii| self.cx.tcx.map.impl_item(ii.id).clone())\n                                         .collect();\n                     let i = Impl {\n                         unsafety: unsafety,"}, {"sha": "cee292f99153e4fc318463094d1633f8ac8e6074", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be778633073cb3b4a036b8ecc469b2892f12367/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=4be778633073cb3b4a036b8ecc469b2892f12367", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n \n     // Updates node level and returns the updated level\n     fn update(&mut self, did: DefId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n-        let is_hidden = self.cx.tcx().get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n+        let is_hidden = self.cx.tcx.get_attrs(did).lists(\"doc\").has_word(\"hidden\");\n \n         let old_level = self.access_levels.map.get(&did).cloned();\n         // Accessibility levels can only grow"}]}