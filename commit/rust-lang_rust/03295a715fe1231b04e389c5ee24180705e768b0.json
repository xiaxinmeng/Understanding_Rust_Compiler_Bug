{"sha": "03295a715fe1231b04e389c5ee24180705e768b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMjk1YTcxNWZlMTIzMWIwNGUzODljNWVlMjQxODA3MDVlNzY4YjA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-29T11:57:06Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-16T15:13:42Z"}, "message": "rustc: qualify expressions in check_const for potential promotion.", "tree": {"sha": "eebebbb6290472ffdb002531efb1acd9b5546020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eebebbb6290472ffdb002531efb1acd9b5546020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03295a715fe1231b04e389c5ee24180705e768b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03295a715fe1231b04e389c5ee24180705e768b0", "html_url": "https://github.com/rust-lang/rust/commit/03295a715fe1231b04e389c5ee24180705e768b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03295a715fe1231b04e389c5ee24180705e768b0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7be460ff37f598d011cbe5fdb36417351159dfb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7be460ff37f598d011cbe5fdb36417351159dfb5", "html_url": "https://github.com/rust-lang/rust/commit/7be460ff37f598d011cbe5fdb36417351159dfb5"}], "stats": {"total": 594, "additions": 454, "deletions": 140}, "files": [{"sha": "133bef30e4083afba1d8d9f2c7f09895e28b3770", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=03295a715fe1231b04e389c5ee24180705e768b0", "patch": "@@ -59,6 +59,7 @@ register_diagnostics! {\n     E0010,\n     E0011,\n     E0012,\n+    E0013,\n     E0014,\n     E0015,\n     E0016,"}, {"sha": "4930eddb35a53213ebad184791eebf6c9b4d8713", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=03295a715fe1231b04e389c5ee24180705e768b0", "patch": "@@ -143,6 +143,7 @@ pub enum astencode_tag { // Reserves 0x40 -- 0x5f\n     tag_table_upvar_capture_map = 0x56,\n     tag_table_capture_modes = 0x57,\n     tag_table_object_cast_map = 0x58,\n+    tag_table_const_qualif = 0x59,\n }\n \n pub const tag_item_trait_item_sort: uint = 0x60;"}, {"sha": "c3302debdfaff0e545e9aea32bc210159b75ea0e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=03295a715fe1231b04e389c5ee24180705e768b0", "patch": "@@ -23,6 +23,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n+use middle::check_const::ConstQualif;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n@@ -1306,6 +1307,15 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             })\n         })\n     }\n+\n+    for &qualif in tcx.const_qualif_map.borrow().get(&id).iter() {\n+        rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n+            rbml_w.id(id);\n+            rbml_w.tag(c::tag_table_val, |rbml_w| {\n+                qualif.encode(rbml_w).unwrap()\n+            })\n+        })\n+    }\n }\n \n trait doc_decoder_helpers {\n@@ -1920,6 +1930,10 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n+                    c::tag_table_const_qualif => {\n+                        let qualif: ConstQualif = Decodable::decode(val_dsr).unwrap();\n+                        dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n+                    }\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             &format!(\"unknown tag found in side tables: {:x}\","}, {"sha": "41d425cd2f6652c54c579f30672dfb4dbf2b734a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 433, "deletions": 140, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=03295a715fe1231b04e389c5ee24180705e768b0", "patch": "@@ -24,49 +24,142 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n-use self::Mode::*;\n-\n+use middle::const_eval;\n use middle::def;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::traits;\n-use middle::ty;\n+use middle::ty::{self, Ty};\n+use util::nodemap::NodeMap;\n use util::ppaux;\n \n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n \n+use std::collections::hash_map::Entry;\n+\n+// Const qualification, from partial to completely promotable.\n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable)]\n+    flags ConstQualif: u8 {\n+        // Const rvalue which can be placed behind a reference.\n+        const PURE_CONST          = 0b000000,\n+        // Inner mutability (can not be placed behind a reference) or behind\n+        // &mut in a non-global expression. Can be copied from static memory.\n+        const MUTABLE_MEM         = 0b000001,\n+        // Constant value with a type that implements Drop. Can be copied\n+        // from static memory, similar to MUTABLE_MEM.\n+        const NEEDS_DROP          = 0b000010,\n+        // Even if the value can be placed in static memory, copying it from\n+        // there is more expensive than in-place instantiation, and/or it may\n+        // be too large. This applies to [T; N] and everything containing it.\n+        // N.B.: references need to clear this flag to not end up on the stack.\n+        const PREFER_IN_PLACE     = 0b000100,\n+        // May use more than 0 bytes of memory, doesn't impact the constness\n+        // directly, but is not allowed to be borrowed mutably in a constant.\n+        const NON_ZERO_SIZED      = 0b001000,\n+        // Actually borrowed, has to always be in static memory. Does not\n+        // propagate, and requires the expression to behave like a 'static\n+        // lvalue. The set of expressions with this flag is the minimum\n+        // that have to be promoted.\n+        const HAS_STATIC_BORROWS  = 0b010000,\n+        // Invalid const for miscellaneous reasons (e.g. not implemented).\n+        const NOT_CONST           = 0b100000,\n+\n+        // Borrowing the expression won't produce &'static T if any of these\n+        // bits are set, though the value could be copied from static memory\n+        // if `NOT_CONST` isn't set.\n+        const NON_STATIC_BORROWS = MUTABLE_MEM.bits | NEEDS_DROP.bits | NOT_CONST.bits\n+    }\n+}\n+\n #[derive(Copy, Eq, PartialEq)]\n enum Mode {\n-    InConstant,\n-    InStatic,\n-    InStaticMut,\n-    InNothing,\n+    Const,\n+    Static,\n+    StaticMut,\n+\n+    // An expression that occurs outside of any constant context\n+    // (i.e. `const`, `static`, array lengths, etc.). The value\n+    // can be variable at runtime, but will be promotable to\n+    // static memory if we can prove it is actually constant.\n+    Var,\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     mode: Mode,\n+    qualif: ConstQualif,\n+    rvalue_borrows: NodeMap<ast::Mutability>\n }\n \n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n-    fn with_mode<F>(&mut self, mode: Mode, f: F) where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>),\n+    fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R where\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>) -> R,\n     {\n-        let old = self.mode;\n+        let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n-        f(self);\n-        self.mode = old;\n+        self.qualif = PURE_CONST;\n+        let r = f(self);\n+        self.mode = old_mode;\n+        self.qualif = old_qualif;\n+        r\n+    }\n+\n+    fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n+        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'tcx,\n+                                    ty::ParameterEnvironment<'a, 'tcx>>) -> R,\n+    {\n+        let param_env = match item_id {\n+            Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n+            None => ty::empty_parameter_environment(self.tcx)\n+        };\n+        f(&mut euv::ExprUseVisitor::new(self, &param_env))\n+    }\n+\n+    fn global_expr(&mut self, mode: Mode, expr: &ast::Expr) -> ConstQualif {\n+        assert!(mode != Mode::Var);\n+        match self.tcx.const_qualif_map.borrow_mut().entry(expr.id) {\n+            Entry::Occupied(entry) => return *entry.get(),\n+            Entry::Vacant(entry) => {\n+                // Prevent infinite recursion on re-entry.\n+                entry.insert(PURE_CONST);\n+            }\n+        }\n+        self.with_mode(mode, |this| {\n+            this.with_euv(None, |euv| euv.consume_expr(expr));\n+            this.visit_expr(expr);\n+            this.qualif\n+        })\n+    }\n+\n+    fn add_qualif(&mut self, qualif: ConstQualif) {\n+        self.qualif = self.qualif | qualif;\n+    }\n+\n+    fn record_borrow(&mut self, id: ast::NodeId, mutbl: ast::Mutability) {\n+        match self.rvalue_borrows.entry(id) {\n+            Entry::Occupied(mut entry) => {\n+                // Merge the two borrows, taking the most demanding\n+                // one, mutability-wise.\n+                if mutbl == ast::MutMutable {\n+                    entry.insert(mutbl);\n+                }\n+            }\n+            Entry::Vacant(entry) => {\n+                entry.insert(mutbl);\n+            }\n+        }\n     }\n \n     fn msg(&self) -> &'static str {\n         match self.mode {\n-            InConstant => \"constant\",\n-            InStaticMut | InStatic => \"static\",\n-            InNothing => unreachable!(),\n+            Mode::Const => \"constant\",\n+            Mode::StaticMut | Mode::Static => \"static\",\n+            Mode::Var => unreachable!(),\n         }\n     }\n \n@@ -108,76 +201,219 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         match i.node {\n             ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);\n-                self.with_mode(InStatic, |v| v.visit_expr(&**expr));\n+                self.global_expr(Mode::Static, &**expr);\n             }\n             ast::ItemStatic(_, ast::MutMutable, ref expr) => {\n                 self.check_static_mut_type(&**expr);\n-                self.with_mode(InStaticMut, |v| v.visit_expr(&**expr));\n+                self.global_expr(Mode::StaticMut, &**expr);\n             }\n             ast::ItemConst(_, ref expr) => {\n-                self.with_mode(InConstant, |v| v.visit_expr(&**expr));\n+                self.global_expr(Mode::Const, &**expr);\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n-                self.with_mode(InConstant, |v| {\n-                    for var in &enum_definition.variants {\n-                        if let Some(ref ex) = var.node.disr_expr {\n-                            v.visit_expr(&**ex);\n-                        }\n+                for var in &enum_definition.variants {\n+                    if let Some(ref ex) = var.node.disr_expr {\n+                        self.global_expr(Mode::Const, &**ex);\n                     }\n-                });\n+                }\n             }\n             _ => {\n-                self.with_mode(InNothing, |v| visit::walk_item(v, i));\n+                self.with_mode(Mode::Var, |v| visit::walk_item(v, i));\n             }\n         }\n     }\n \n+    fn visit_fn(&mut self,\n+                fk: visit::FnKind<'v>,\n+                fd: &'v ast::FnDecl,\n+                b: &'v ast::Block,\n+                s: Span,\n+                fn_id: ast::NodeId) {\n+        assert!(self.mode == Mode::Var);\n+        self.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n+        visit::walk_fn(self, fk, fd, b, s);\n+    }\n+\n     fn visit_pat(&mut self, p: &ast::Pat) {\n-        let mode = match p.node {\n-            ast::PatLit(_) | ast::PatRange(..) => InConstant,\n-            _ => InNothing\n-        };\n-        self.with_mode(mode, |v| visit::walk_pat(v, p))\n+        match p.node {\n+            ast::PatLit(ref lit) => {\n+                self.global_expr(Mode::Const, &**lit);\n+            }\n+            ast::PatRange(ref start, ref end) => {\n+                self.global_expr(Mode::Const, &**start);\n+                self.global_expr(Mode::Const, &**end);\n+            }\n+            _ => visit::walk_pat(self, p)\n+        }\n     }\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n-        if self.mode != InNothing {\n-            check_expr(self, ex);\n+        let mut outer = self.qualif;\n+        self.qualif = PURE_CONST;\n+\n+        let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n+        check_expr(self, ex, node_ty);\n+\n+        // Special-case some expressions to avoid certain flags bubbling up.\n+        match ex.node {\n+            ast::ExprCall(ref callee, ref args) => {\n+                for arg in args.iter() {\n+                    self.visit_expr(&**arg)\n+                }\n+\n+                let inner = self.qualif;\n+                self.visit_expr(&**callee);\n+                // The callee's size doesn't count in the call.\n+                let added = self.qualif - inner;\n+                self.qualif = inner | (added - NON_ZERO_SIZED);\n+            }\n+            ast::ExprRepeat(ref element, _) => {\n+                self.visit_expr(&**element);\n+                // The count is checked elsewhere (typeck).\n+                let count = match node_ty.sty {\n+                    ty::ty_vec(_, Some(n)) => n,\n+                    _ => unreachable!()\n+                };\n+                // [element; 0] is always zero-sized.\n+                if count == 0 {\n+                    self.qualif = self.qualif - (NON_ZERO_SIZED | PREFER_IN_PLACE);\n+                }\n+            }\n+            ast::ExprMatch(ref discr, ref arms, _) => {\n+                // Compute the most demanding borrow from all the arms'\n+                // patterns and set that on the discriminator.\n+                let mut borrow = None;\n+                for pat in arms.iter().flat_map(|arm| arm.pats.iter()) {\n+                    let pat_borrow = self.rvalue_borrows.remove(&pat.id);\n+                    match (borrow, pat_borrow) {\n+                        (None, _) | (_, Some(ast::MutMutable)) => {\n+                            borrow = pat_borrow;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                if let Some(mutbl) = borrow {\n+                    self.record_borrow(discr.id, mutbl);\n+                }\n+                visit::walk_expr(self, ex);\n+            }\n+            // Division by zero and overflow checking.\n+            ast::ExprBinary(op, _, _) => {\n+                visit::walk_expr(self, ex);\n+                let div_or_rem = op.node == ast::BiDiv || op.node == ast::BiRem;\n+                match node_ty.sty {\n+                    ty::ty_uint(_) | ty::ty_int(_) if div_or_rem => {\n+                        if !self.qualif.intersects(NOT_CONST) {\n+                            match const_eval::eval_const_expr_partial(self.tcx, ex, None) {\n+                                Ok(_) => {}\n+                                Err(msg) => {\n+                                    span_err!(self.tcx.sess, ex.span, E0020,\n+                                              \"{} in a constant expression\", msg)\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => visit::walk_expr(self, ex)\n+        }\n+\n+        // Handle borrows on (or inside the autorefs of) this expression.\n+        match self.rvalue_borrows.remove(&ex.id) {\n+            Some(ast::MutImmutable) => {\n+                // Constants cannot be borrowed if they contain interior mutability as\n+                // it means that our \"silent insertion of statics\" could change\n+                // initializer values (very bad).\n+                // If the type doesn't have interior mutability, then `MUTABLE_MEM` has\n+                // propagated from another error, so erroring again would be just noise.\n+                let tc = ty::type_contents(self.tcx, node_ty);\n+                if self.qualif.intersects(MUTABLE_MEM) && tc.interior_unsafe() {\n+                    outer = outer | NOT_CONST;\n+                    if self.mode != Mode::Var {\n+                        self.tcx.sess.span_err(ex.span,\n+                            \"cannot borrow a constant which contains \\\n+                             interior mutability, create a static instead\");\n+                    }\n+                }\n+                // If the reference has to be 'static, avoid in-place initialization\n+                // as that will end up pointing to the stack instead.\n+                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n+                    self.qualif = self.qualif - PREFER_IN_PLACE;\n+                    self.add_qualif(HAS_STATIC_BORROWS);\n+                }\n+            }\n+            Some(ast::MutMutable) => {\n+                // `&mut expr` means expr could be mutated, unless it's zero-sized.\n+                if self.qualif.intersects(NON_ZERO_SIZED) {\n+                    if self.mode == Mode::Var {\n+                        outer = outer | NOT_CONST;\n+                        self.add_qualif(MUTABLE_MEM);\n+                    } else {\n+                        span_err!(self.tcx.sess, ex.span, E0017,\n+                            \"references in {}s may only refer \\\n+                             to immutable values\", self.msg())\n+                    }\n+                }\n+                if !self.qualif.intersects(NON_STATIC_BORROWS) {\n+                    self.add_qualif(HAS_STATIC_BORROWS);\n+                }\n+            }\n+            None => {}\n         }\n-        visit::walk_expr(self, ex);\n+        self.tcx.const_qualif_map.borrow_mut().insert(ex.id, self.qualif);\n+        // Don't propagate certain flags.\n+        self.qualif = outer | (self.qualif - HAS_STATIC_BORROWS);\n     }\n }\n \n /// This function is used to enforce the constraints on\n /// const/static items. It walks through the *value*\n /// of the item walking down the expression and evaluating\n /// every nested expression. If the expression is not part\n-/// of a const/static item, this function does nothing but\n-/// walking down through it.\n-fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n-    let node_ty = ty::node_id_to_type(v.tcx, e.id);\n-\n+/// of a const/static item, it is qualified for promotion\n+/// instead of producing errors.\n+fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n+                        e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::ty_struct(did, _) |\n         ty::ty_enum(did, _) if ty::has_dtor(v.tcx, did) => {\n-            v.tcx.sess.span_err(e.span,\n-                                &format!(\"{}s are not allowed to have destructors\",\n-                                         v.msg())[])\n+            v.add_qualif(NEEDS_DROP);\n+            if v.mode != Mode::Var {\n+                v.tcx.sess.span_err(e.span,\n+                                    &format!(\"{}s are not allowed to have destructors\",\n+                                             v.msg())[]);\n+            }\n         }\n         _ => {}\n     }\n \n+    let method_call = ty::MethodCall::expr(e.id);\n     match e.node {\n+        ast::ExprUnary(..) |\n+        ast::ExprBinary(..) |\n+        ast::ExprIndex(..) if v.tcx.method_map.borrow().contains_key(&method_call) => {\n+            v.add_qualif(NOT_CONST);\n+            if v.mode != Mode::Var {\n+                span_err!(v.tcx.sess, e.span, E0011,\n+                            \"user-defined operators are not allowed in {}s\", v.msg());\n+            }\n+        }\n         ast::ExprBox(..) |\n         ast::ExprUnary(ast::UnUniq, _) => {\n-            span_err!(v.tcx.sess, e.span, E0010,\n-                      \"allocations are not allowed in {}s\", v.msg());\n+            v.add_qualif(NOT_CONST);\n+            if v.mode != Mode::Var {\n+                span_err!(v.tcx.sess, e.span, E0010,\n+                          \"allocations are not allowed in {}s\", v.msg());\n+            }\n         }\n-        ast::ExprBinary(..) | ast::ExprUnary(..) => {\n-            let method_call = ty::MethodCall::expr(e.id);\n-            if v.tcx.method_map.borrow().contains_key(&method_call) {\n-                span_err!(v.tcx.sess, e.span, E0011,\n-                          \"user-defined operators are not allowed in {}s\", v.msg());\n+        ast::ExprUnary(ast::UnDeref, ref ptr) => {\n+            match ty::node_id_to_type(v.tcx, ptr.id).sty {\n+                ty::ty_ptr(_) => {\n+                    // This shouldn't be allowed in constants at all.\n+                    v.add_qualif(NOT_CONST);\n+                }\n+                _ => {}\n             }\n         }\n         ast::ExprCast(ref from, _) => {\n@@ -188,51 +424,110 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 ty::type_is_unsafe_ptr(toty) ||\n                 (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n             if !is_legal_cast {\n-                span_err!(v.tcx.sess, e.span, E0012,\n-                          \"can not cast to `{}` in {}s\",\n-                          ppaux::ty_to_string(v.tcx, toty), v.msg());\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0012,\n+                              \"can not cast to `{}` in {}s\",\n+                              ppaux::ty_to_string(v.tcx, toty), v.msg());\n+                }\n             }\n             if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                span_err!(v.tcx.sess, e.span, E0018,\n-                          \"can not cast a pointer to an integer in {}s\", v.msg());\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0018,\n+                              \"can not cast a pointer to an integer in {}s\", v.msg());\n+                }\n             }\n         }\n         ast::ExprPath(_) | ast::ExprQPath(_) => {\n-            match v.tcx.def_map.borrow()[e.id] {\n-                def::DefStatic(..) if v.mode == InConstant => {\n-                    span_err!(v.tcx.sess, e.span, E0013,\n-                              \"constants cannot refer to other statics, \\\n-                               insert an intermediate constant instead\");\n+            let def = v.tcx.def_map.borrow().get(&e.id).cloned();\n+            match def {\n+                Some(def::DefVariant(_, _, _)) => {\n+                    // Count the discriminator or function pointer.\n+                    v.add_qualif(NON_ZERO_SIZED);\n+                }\n+                Some(def::DefStruct(_)) => {\n+                    if let ty::ty_bare_fn(..) = node_ty.sty {\n+                        // Count the function pointer.\n+                        v.add_qualif(NON_ZERO_SIZED);\n+                    }\n+                }\n+                Some(def::DefFn(..)) |\n+                Some(def::DefStaticMethod(..)) | Some(def::DefMethod(..)) => {\n+                    // Count the function pointer.\n+                    v.add_qualif(NON_ZERO_SIZED);\n+                }\n+                Some(def::DefStatic(..)) => {\n+                    match v.mode {\n+                        Mode::Static | Mode::StaticMut => {}\n+                        Mode::Const => {\n+                            span_err!(v.tcx.sess, e.span, E0013,\n+                                \"constants cannot refer to other statics, \\\n+                                 insert an intermediate constant instead\");\n+                        }\n+                        Mode::Var => v.add_qualif(NOT_CONST)\n+                    }\n+                }\n+                Some(def::DefConst(did)) => {\n+                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did) {\n+                        let inner = v.global_expr(Mode::Const, expr);\n+                        v.add_qualif(inner);\n+                    } else {\n+                        v.tcx.sess.span_bug(e.span, \"DefConst doesn't point \\\n+                                                     to an ItemConst\");\n+                    }\n                 }\n-                def::DefStatic(..) | def::DefConst(..) |\n-                def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) |\n-                def::DefStruct(_) | def::DefVariant(_, _, _) => {}\n-\n                 def => {\n-                    debug!(\"(checking const) found bad def: {:?}\", def);\n-                    span_err!(v.tcx.sess, e.span, E0014,\n-                              \"paths in constants may only refer to constants \\\n-                               or functions\");\n+                    v.add_qualif(NOT_CONST);\n+                    if v.mode != Mode::Var {\n+                        debug!(\"(checking const) found bad def: {:?}\", def);\n+                        span_err!(v.tcx.sess, e.span, E0014,\n+                                  \"paths in {}s may only refer to constants \\\n+                                   or functions\", v.msg());\n+                    }\n                 }\n             }\n         }\n         ast::ExprCall(ref callee, _) => {\n-            match v.tcx.def_map.borrow()[callee.id] {\n-                def::DefStruct(..) | def::DefVariant(..) => {}    // OK.\n+            let mut callee = &**callee;\n+            loop {\n+                callee = match callee.node {\n+                    ast::ExprParen(ref inner) => &**inner,\n+                    ast::ExprBlock(ref block) => match block.expr {\n+                        Some(ref tail) => &**tail,\n+                        None => break\n+                    },\n+                    _ => break\n+                };\n+            }\n+            let def = v.tcx.def_map.borrow().get(&callee.id).cloned();\n+            match def {\n+                Some(def::DefStruct(..)) => {}\n+                Some(def::DefVariant(..)) => {\n+                    // Count the discriminator.\n+                    v.add_qualif(NON_ZERO_SIZED);\n+                }\n                 _ => {\n-                    span_err!(v.tcx.sess, e.span, E0015,\n-                              \"function calls in constants are limited to \\\n-                               struct and enum constructors\");\n+                    v.add_qualif(NOT_CONST);\n+                    if v.mode != Mode::Var {\n+                        span_err!(v.tcx.sess, e.span, E0015,\n+                                  \"function calls in {}s are limited to \\\n+                                   struct and enum constructors\", v.msg());\n+                    }\n                 }\n             }\n         }\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n-            for stmt in &block.stmts {\n-                let block_span_err = |span|\n+            let mut block_span_err = |span| {\n+                v.add_qualif(NOT_CONST);\n+                if v.mode != Mode::Var {\n                     span_err!(v.tcx.sess, span, E0016,\n-                              \"blocks in constants are limited to items and \\\n-                               tail expressions\");\n+                              \"blocks in {}s are limited to items and \\\n+                               tail expressions\", v.msg());\n+                }\n+            };\n+            for stmt in &block.stmts {\n                 match stmt.node {\n                     ast::StmtDecl(ref decl, _) => {\n                         match decl.node {\n@@ -251,26 +546,40 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n                 }\n             }\n         }\n-        ast::ExprAddrOf(ast::MutMutable, ref inner) => {\n-            match inner.node {\n-                // Mutable slices are allowed. Only in `static mut`.\n-                ast::ExprVec(_) if v.mode == InStaticMut => {}\n-                _ => span_err!(v.tcx.sess, e.span, E0017,\n-                               \"references in {}s may only refer \\\n-                                to immutable values\", v.msg())\n+        ast::ExprStruct(..) => {\n+            let did = v.tcx.def_map.borrow().get(&e.id).map(|def| def.def_id());\n+            if did == v.tcx.lang_items.unsafe_cell_type() {\n+                v.add_qualif(MUTABLE_MEM);\n             }\n         }\n \n         ast::ExprLit(_) |\n-        ast::ExprVec(_) |\n-        ast::ExprAddrOf(ast::MutImmutable, _) |\n-        ast::ExprParen(..) |\n+        ast::ExprAddrOf(..) => {\n+            v.add_qualif(NON_ZERO_SIZED);\n+        }\n+\n+        ast::ExprRepeat(..) => {\n+            v.add_qualif(PREFER_IN_PLACE);\n+        }\n+\n+        ast::ExprClosure(..) => {\n+            // Paths in constant constexts cannot refer to local variables,\n+            // as there are none, and thus closures can't have upvars there.\n+            if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n+                assert!(v.mode == Mode::Var,\n+                        \"global closures can't capture anything\");\n+                v.add_qualif(NOT_CONST);\n+            }\n+        }\n+\n+        ast::ExprUnary(..) |\n+        ast::ExprBinary(..) |\n+        ast::ExprIndex(..) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n-        ast::ExprIndex(..) |\n-        ast::ExprTup(..) |\n-        ast::ExprRepeat(..) |\n-        ast::ExprStruct(..) => {}\n+        ast::ExprVec(_) |\n+        ast::ExprParen(..) |\n+        ast::ExprTup(..) => {}\n \n         // Conditional control flow (possible to implement).\n         ast::ExprMatch(..) |\n@@ -289,7 +598,6 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         ast::ExprRet(_) |\n \n         // Miscellaneous expressions that could be implemented.\n-        ast::ExprClosure(..) |\n         ast::ExprRange(..) |\n \n         // Various other expressions.\n@@ -298,50 +606,27 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) {\n         ast::ExprAssignOp(..) |\n         ast::ExprInlineAsm(_) |\n         ast::ExprMac(_) => {\n-            span_err!(v.tcx.sess, e.span, E0019,\n-                      \"{} contains unimplemented expression type\", v.msg());\n+            v.add_qualif(NOT_CONST);\n+            if v.mode != Mode::Var {\n+                span_err!(v.tcx.sess, e.span, E0019,\n+                          \"{} contains unimplemented expression type\", v.msg());\n+            }\n         }\n     }\n }\n \n-struct GlobalVisitor<'a,'b,'tcx:'a+'b>(\n-    euv::ExprUseVisitor<'a,'b,'tcx,ty::ParameterEnvironment<'b,'tcx>>);\n-\n-struct GlobalChecker<'a,'tcx:'a> {\n-    tcx: &'a ty::ctxt<'tcx>\n-}\n-\n pub fn check_crate(tcx: &ty::ctxt) {\n-    let param_env = ty::empty_parameter_environment(tcx);\n-    let mut checker = GlobalChecker {\n-        tcx: tcx\n-    };\n-    let visitor = euv::ExprUseVisitor::new(&mut checker, &param_env);\n-    visit::walk_crate(&mut GlobalVisitor(visitor), tcx.map.krate());\n-\n     visit::walk_crate(&mut CheckCrateVisitor {\n         tcx: tcx,\n-        mode: InNothing,\n+        mode: Mode::Var,\n+        qualif: NOT_CONST,\n+        rvalue_borrows: NodeMap()\n     }, tcx.map.krate());\n \n     tcx.sess.abort_if_errors();\n }\n \n-impl<'a,'b,'t,'v> Visitor<'v> for GlobalVisitor<'a,'b,'t> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemConst(_, ref e) |\n-            ast::ItemStatic(_, _, ref e) => {\n-                let GlobalVisitor(ref mut v) = *self;\n-                v.consume_expr(&**e);\n-            }\n-            _ => {}\n-        }\n-        visit::walk_item(self, item);\n-    }\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for GlobalChecker<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                consume_span: Span,\n@@ -351,12 +636,14 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GlobalChecker<'a, 'tcx> {\n         loop {\n             match cur.cat {\n                 mc::cat_static_item => {\n-                    // statics cannot be consumed by value at any time, that would imply\n-                    // that they're an initializer (what a const is for) or kept in sync\n-                    // over time (not feasible), so deny it outright.\n-                    self.tcx.sess.span_err(consume_span,\n-                        \"cannot refer to other statics by value, use the \\\n-                         address-of operator or a constant instead\");\n+                    if self.mode != Mode::Var {\n+                        // statics cannot be consumed by value at any time, that would imply\n+                        // that they're an initializer (what a const is for) or kept in sync\n+                        // over time (not feasible), so deny it outright.\n+                        self.tcx.sess.span_err(consume_span,\n+                            \"cannot refer to other statics by value, use the \\\n+                             address-of operator or a constant instead\");\n+                    }\n                     break;\n                 }\n                 mc::cat_deref(ref cmt, _, _) |\n@@ -370,29 +657,35 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GlobalChecker<'a, 'tcx> {\n         }\n     }\n     fn borrow(&mut self,\n-              _borrow_id: ast::NodeId,\n+              borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n               _loan_region: ty::Region,\n-              _bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause) {\n+              bk: ty::BorrowKind,\n+              loan_cause: euv::LoanCause) {\n         let mut cur = &cmt;\n         let mut is_interior = false;\n         loop {\n             match cur.cat {\n                 mc::cat_rvalue(..) => {\n-                    // constants cannot be borrowed if they contain interior mutability as\n-                    // it means that our \"silent insertion of statics\" could change\n-                    // initializer values (very bad).\n-                    if ty::type_contents(self.tcx, cur.ty).interior_unsafe() {\n-                        self.tcx.sess.span_err(borrow_span,\n-                            \"cannot borrow a constant which contains \\\n-                            interior mutability, create a static instead\");\n+                    if loan_cause == euv::MatchDiscriminant {\n+                        // Ignore the dummy immutable borrow created by EUV.\n+                        break;\n                     }\n+                    let mutbl = bk.to_mutbl_lossy();\n+                    if mutbl == ast::MutMutable && self.mode == Mode::StaticMut {\n+                        // Mutable slices are the only `&mut` allowed in globals,\n+                        // but only in `static mut`, nowhere else.\n+                        match cmt.ty.sty {\n+                            ty::ty_vec(_, _) => break,\n+                            _ => {}\n+                        }\n+                    }\n+                    self.record_borrow(borrow_id, mutbl);\n                     break;\n                 }\n                 mc::cat_static_item => {\n-                    if is_interior {\n+                    if is_interior && self.mode != Mode::Var {\n                         // Borrowed statics can specifically *only* have their address taken,\n                         // not any number of other borrows such as borrowing fields, reading\n                         // elements of an array, etc.\n@@ -433,4 +726,4 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GlobalChecker<'a, 'tcx> {\n                    _consume_pat: &ast::Pat,\n                    _cmt: mc::cmt,\n                    _mode: euv::ConsumeMode) {}\n-}\n\\ No newline at end of file\n+}"}, {"sha": "fe5c81bf2c0b3ecb5f75ced54f1ebfc6cfdf699b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03295a715fe1231b04e389c5ee24180705e768b0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=03295a715fe1231b04e389c5ee24180705e768b0", "patch": "@@ -44,6 +44,7 @@ use session::Session;\n use lint;\n use metadata::csearch;\n use middle;\n+use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n@@ -838,6 +839,9 @@ pub struct ctxt<'tcx> {\n \n     /// Caches whether traits are object safe\n     pub object_safety_cache: RefCell<DefIdMap<bool>>,\n+\n+    /// Maps Expr NodeId's to their constant qualification.\n+    pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2472,6 +2476,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n         object_safety_cache: RefCell::new(DefIdMap()),\n+        const_qualif_map: RefCell::new(NodeMap()),\n    }\n }\n "}]}