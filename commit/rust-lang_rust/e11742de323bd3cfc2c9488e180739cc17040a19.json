{"sha": "e11742de323bd3cfc2c9488e180739cc17040a19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMTc0MmRlMzIzYmQzY2ZjMmM5NDg4ZTE4MDczOWNjMTcwNDBhMTk=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-26T00:00:45Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-26T00:55:55Z"}, "message": "More refactoring on a quest to understand region types.", "tree": {"sha": "74d2fbe0e4d500f98f18cf4bb4675bb6c09d1b1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74d2fbe0e4d500f98f18cf4bb4675bb6c09d1b1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e11742de323bd3cfc2c9488e180739cc17040a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e11742de323bd3cfc2c9488e180739cc17040a19", "html_url": "https://github.com/rust-lang/rust/commit/e11742de323bd3cfc2c9488e180739cc17040a19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e11742de323bd3cfc2c9488e180739cc17040a19/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "269bc6fb5ca2e507eba2a731a9e5010a0258e17a", "url": "https://api.github.com/repos/rust-lang/rust/commits/269bc6fb5ca2e507eba2a731a9e5010a0258e17a", "html_url": "https://github.com/rust-lang/rust/commit/269bc6fb5ca2e507eba2a731a9e5010a0258e17a"}], "stats": {"total": 84, "additions": 62, "deletions": 22}, "files": [{"sha": "0481a06707c2ab24ee932d534ab33b19e4a698ad", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e11742de323bd3cfc2c9488e180739cc17040a19/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11742de323bd3cfc2c9488e180739cc17040a19/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e11742de323bd3cfc2c9488e180739cc17040a19", "patch": "@@ -5,7 +5,7 @@ import syntax::print::pprust::{expr_to_str};\n // Extracts the bound regions from bound_tys and then replaces those same\n // regions in `sty` with fresh region variables, returning the resulting type.\n // Does not descend into fn types.  This is used when deciding whether an impl\n-// applies at a given call site.  See also universally_quantify_before_call().\n+// applies at a given call site.\n fn universally_quantify_from_sty(fcx: @fn_ctxt,\n                                  span: span,\n                                  bound_tys: [ty::t],\n@@ -31,6 +31,11 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n     }\n }\n \n+// Takes `isr`, a mapping from in-scope region names (\"isr\"s) to their\n+// corresponding regions (possibly produced by a call to\n+// collect_bound_regions_in_tys; and `ty`, a type.  Returns an updated\n+// version of `ty`, in which bound regions in `ty` have been replaced\n+// with the corresponding bindings in `isr`.\n fn replace_bound_regions(\n     tcx: ty::ctxt,\n     span: span,\n@@ -140,23 +145,29 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n     }\n }\n \n+// Takes `isr`, a (possibly empty) mapping from in-scope region names (\"isr\"s)\n+// to their corresponding regions; `tys`, a list of types, and `to_r`, a\n+// closure that takes a bound_region and returns a region.  Returns an updated\n+// version of `isr`, extended with the in-scope region names from all of the\n+// bound regions appearing in the types in the `tys` list (if they're not in\n+// `isr` already), with each of those in-scope region names mapped to a region\n+// that's the result of applying `to_r` to itself.\n+\n+// \"collect\" is something of a misnomer -- we're not merely collecting\n+// a list of the bound regions, but also doing the work of applying\n+// `to_r` to them!\n fn collect_bound_regions_in_tys(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n     tys: [ty::t],\n     to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n \n-    tys.foldl(isr) { |isr, t|\n-        collect_bound_regions_in_ty(tcx, isr, t, to_r)\n-    }\n-}\n-\n-fn collect_bound_regions_in_ty(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    ty: ty::t,\n-    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n-\n+    // Takes `isr` (described above), `to_r` (described above), and `r`, a\n+    // region.  If `r` is anything other than a bound region, or if it's a\n+    // bound region that already appears in `isr`, then we return `isr`\n+    // unchanged.  If `r` is a bound region that doesn't already appear in\n+    // `isr`, we return an updated isr_alist that now contains a mapping from\n+    // `r` to the result of calling `to_r` on it.\n     fn append_isr(isr: isr_alist,\n                   to_r: fn(ty::bound_region) -> ty::region,\n                   r: ty::region) -> isr_alist {\n@@ -174,16 +185,30 @@ fn collect_bound_regions_in_ty(\n         }\n     }\n \n-    let mut isr = isr;\n+    // For each region in `t`, apply the `append_isr` function to that\n+    // region, accumulating and returning the results in an isr_alist.\n+    fn fold_over_regions_in_type(\n+        tcx: ty::ctxt,\n+        isr: isr_alist,\n+        ty: ty::t,\n+        to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n+\n+        let mut isr = isr;\n+\n+        // Using fold_regions is inefficient, because it constructs new types,\n+        // but it avoids code duplication in terms of locating all the regions\n+        // within the various kinds of types.  This had already caused me\n+        // several bugs so I decided to switch over.\n+        ty::fold_regions(tcx, ty) { |r, in_fn|\n+            if !in_fn { isr = append_isr(isr, to_r, r); }\n+            r\n+        };\n \n-    // Using fold_regions is inefficient, because it constructs new types, but\n-    // it avoids code duplication in terms of locating all the regions within\n-    // the various kinds of types.  This had already caused me several bugs\n-    // so I decided to switch over.\n-    ty::fold_regions(tcx, ty) { |r, in_fn|\n-        if !in_fn { isr = append_isr(isr, to_r, r); }\n-        r\n-    };\n+        ret isr;\n+    }\n \n-    ret isr;\n+    // For each type `t` in `tys`...\n+    tys.foldl(isr) { |isr, t|\n+        fold_over_regions_in_type(tcx, isr, t, to_r)\n+    }\n }"}, {"sha": "02349614e55e55d0e3845fdc30079d587d9c08ec", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e11742de323bd3cfc2c9488e180739cc17040a19/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e11742de323bd3cfc2c9488e180739cc17040a19/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=e11742de323bd3cfc2c9488e180739cc17040a19", "patch": "@@ -1618,11 +1618,23 @@ impl of combine for sub {\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n+\n+        // FIXME: This code is kinda redundant with\n+        // regionmanip::universally_quantify_from_sty, except for the\n+        // `sty` part.  Fix somehow?\n+\n+        // a_isr is a mapping from all the bound regions in `a` to\n+        // freshly created region variables for them.\n         let a_isr =\n             collect_bound_regions_in_tys(self.tcx,\n                                          @nil,\n                                          tys_in_fn_ty(a)) {\n             |br|\n+\n+            // N.B.: The name of the bound region doesn't have\n+            // anything to do with the region variable that's created\n+            // for it.  The only thing we're doing with `br` here is\n+            // using it in the debug message.\n             let rvar = self.infcx().next_region_var();\n             #debug[\"Bound region %s maps to %s\",\n                    bound_region_to_str(self.tcx, br),\n@@ -1638,6 +1650,9 @@ impl of combine for sub {\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n+\n+        // a_isr is a mapping from all the bound regions in `b` to\n+        // the result of calling re_bound on them.\n         let b_isr =\n             collect_bound_regions_in_tys(self.tcx,\n                                          @nil,"}]}