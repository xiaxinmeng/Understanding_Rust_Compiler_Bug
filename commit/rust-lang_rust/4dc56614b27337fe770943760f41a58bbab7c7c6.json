{"sha": "4dc56614b27337fe770943760f41a58bbab7c7c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYzU2NjE0YjI3MzM3ZmU3NzA5NDM3NjBmNDFhNThiYmFiN2M3YzY=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-05-22T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-05-29T15:46:38Z"}, "message": "liveness: Warn about unused captured variables", "tree": {"sha": "a26e117a830a317e6c0da940fa4a3b9349e4c4de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a26e117a830a317e6c0da940fa4a3b9349e4c4de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dc56614b27337fe770943760f41a58bbab7c7c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc56614b27337fe770943760f41a58bbab7c7c6", "html_url": "https://github.com/rust-lang/rust/commit/4dc56614b27337fe770943760f41a58bbab7c7c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dc56614b27337fe770943760f41a58bbab7c7c6/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74fcbfb49149c07ad9beea0ddd47d11b125e0e13", "url": "https://api.github.com/repos/rust-lang/rust/commits/74fcbfb49149c07ad9beea0ddd47d11b125e0e13", "html_url": "https://github.com/rust-lang/rust/commit/74fcbfb49149c07ad9beea0ddd47d11b125e0e13"}], "stats": {"total": 569, "additions": 505, "deletions": 64}, "files": [{"sha": "55978afc59437c74dbfe750d0d1b5530ac82b924", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 170, "deletions": 54, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -76,13 +76,10 @@\n //!   is not just used to generate a new value. For example, `x += 1` is\n //!   a read but not a use. This is used to generate better warnings.\n //!\n-//! ## Special Variables\n+//! ## Special nodes and variables\n //!\n-//! We generate various special variables for various, well, special purposes.\n-//! These are described in the `specials` struct:\n-//!\n-//! - `exit_ln`: a live node that is generated to represent every 'exit' from\n-//!   the function, whether it be by explicit return, panic, or other means.\n+//! We generate various special nodes for various, well, special purposes.\n+//! These are described in the `Specials` struct.\n \n use self::LiveNodeKind::*;\n use self::VarKind::*;\n@@ -131,6 +128,7 @@ enum LiveNodeKind {\n     UpvarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n+    ClosureNode,\n     ExitNode,\n }\n \n@@ -140,6 +138,7 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_>) -> String {\n         UpvarNode(s) => format!(\"Upvar node [{}]\", sm.span_to_string(s)),\n         ExprNode(s) => format!(\"Expr node [{}]\", sm.span_to_string(s)),\n         VarDefNode(s) => format!(\"Var def node [{}]\", sm.span_to_string(s)),\n+        ClosureNode => \"Closure node\".to_owned(),\n         ExitNode => \"Exit node\".to_owned(),\n     }\n }\n@@ -396,10 +395,12 @@ fn visit_fn<'tcx>(\n \n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, def_id);\n-    let entry_ln = lsets.compute(&body.value);\n+    let entry_ln = lsets.compute(fk, &body, sp, id);\n+    lsets.log_liveness(entry_ln, id);\n \n     // check for various error conditions\n     lsets.visit_body(body);\n+    lsets.warn_about_unused_upvars(entry_ln);\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n@@ -634,6 +635,12 @@ impl RWUTable {\n \n #[derive(Copy, Clone)]\n struct Specials {\n+    /// A live node representing a point of execution before closure entry &\n+    /// after closure exit. Used to calculate liveness of captured variables\n+    /// through calls to the same closure. Used for Fn & FnMut closures only.\n+    closure_ln: LiveNode,\n+    /// A live node representing every 'exit' from the function, whether it be\n+    /// by explicit return, panic, or other means.\n     exit_ln: LiveNode,\n }\n \n@@ -658,11 +665,8 @@ struct Liveness<'a, 'tcx> {\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n-        // Special nodes and variables:\n-        // - exit_ln represents the end of the fn, either by return or panic\n-        // - implicit_ret_var is a pseudo-variable that represents\n-        //   an implicit return\n         let specials = Specials {\n+            closure_ln: ir.add_live_node(ClosureNode),\n             exit_ln: ir.add_live_node(ExitNode),\n         };\n \n@@ -789,6 +793,20 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         String::from_utf8(wr).unwrap()\n     }\n \n+    fn log_liveness(&self, entry_ln: LiveNode, hir_id: hir::HirId) {\n+        // hack to skip the loop unless debug! is enabled:\n+        debug!(\n+            \"^^ liveness computation results for body {} (entry={:?})\",\n+            {\n+                for ln_idx in 0..self.ir.num_live_nodes {\n+                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n+                }\n+                hir_id\n+            },\n+            entry_ln\n+        );\n+    }\n+\n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[ln.get()] = succ_ln;\n \n@@ -889,33 +907,87 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.rwu_table.assign_unpacked(idx, rwu);\n     }\n \n-    fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n-        debug!(\"compute: using id for body, {:?}\", body);\n+    fn compute(\n+        &mut self,\n+        fk: FnKind<'_>,\n+        body: &hir::Body<'_>,\n+        span: Span,\n+        id: hir::HirId,\n+    ) -> LiveNode {\n+        debug!(\"compute: using id for body, {:?}\", body.value);\n \n-        let s = self.s;\n+        // # Liveness of captured variables\n+        //\n+        // When computing the liveness for captured variables we take into\n+        // account how variable is captured (ByRef vs ByValue) and what is the\n+        // closure kind (Generator / FnOnce vs Fn / FnMut).\n+        //\n+        // Variables captured by reference are assumed to be used on the exit\n+        // from the closure.\n+        //\n+        // In FnOnce closures, variables captured by value are known to be dead\n+        // on exit since it is impossible to call the closure again.\n+        //\n+        // In Fn / FnMut closures, variables captured by value are live on exit\n+        // if they are live on the entry to the closure, since only the closure\n+        // itself can access them on subsequent calls.\n \n         if let Some(upvars) = self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+            // Mark upvars captured by reference as used after closure exits.\n             for (&var_hir_id, upvar) in upvars.iter().rev() {\n-                let var = self.variable(var_hir_id, upvar.span);\n-                self.acc(s.exit_ln, var, ACC_READ | ACC_USE);\n+                let upvar_id = ty::UpvarId {\n+                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                    closure_expr_id: self.ir.body_owner.expect_local(),\n+                };\n+                match self.tables.upvar_capture(upvar_id) {\n+                    ty::UpvarCapture::ByRef(_) => {\n+                        let var = self.variable(var_hir_id, upvar.span);\n+                        self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n+                    }\n+                    ty::UpvarCapture::ByValue => {}\n+                }\n             }\n         }\n \n-        let entry_ln = self.propagate_through_expr(body, s.exit_ln);\n+        let succ = self.propagate_through_expr(&body.value, self.s.exit_ln);\n \n-        // hack to skip the loop unless debug! is enabled:\n-        debug!(\n-            \"^^ liveness computation results for body {} (entry={:?})\",\n-            {\n-                for ln_idx in 0..self.ir.num_live_nodes {\n-                    debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n-                }\n-                body.hir_id\n+        match fk {\n+            FnKind::Method(..) | FnKind::ItemFn(..) => return succ,\n+            FnKind::Closure(..) => {}\n+        }\n+\n+        let ty = self.tables.node_type(id);\n+        match ty.kind {\n+            ty::Closure(_def_id, substs) => match substs.as_closure().kind() {\n+                ty::ClosureKind::Fn => {}\n+                ty::ClosureKind::FnMut => {}\n+                ty::ClosureKind::FnOnce => return succ,\n             },\n-            entry_ln\n-        );\n+            ty::Generator(..) => return succ,\n+            _ => {\n+                span_bug!(span, \"type of closure expr {:?} is not a closure {:?}\", id, ty,);\n+            }\n+        };\n \n-        entry_ln\n+        // Propagate through calls to the closure.\n+        let mut first_merge = true;\n+        loop {\n+            self.init_from_succ(self.s.closure_ln, succ);\n+            for param in body.params {\n+                param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+                    let var = self.variable(hir_id, ident.span);\n+                    self.define(self.s.closure_ln, var);\n+                })\n+            }\n+\n+            if !self.merge_from_succ(self.s.exit_ln, self.s.closure_ln, first_merge) {\n+                break;\n+            }\n+            first_merge = false;\n+            assert_eq!(succ, self.propagate_through_expr(&body.value, self.s.exit_ln));\n+        }\n+\n+        succ\n     }\n \n     fn propagate_through_block(&mut self, blk: &hir::Block<'_>, succ: LiveNode) -> LiveNode {\n@@ -1533,11 +1605,60 @@ impl<'tcx> Liveness<'_, 'tcx> {\n         if name.is_empty() || name.as_bytes()[0] == b'_' { None } else { Some(name) }\n     }\n \n+    fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n+        let upvars = match self.ir.tcx.upvars_mentioned(self.ir.body_owner) {\n+            None => return,\n+            Some(upvars) => upvars,\n+        };\n+        for (&var_hir_id, upvar) in upvars.iter() {\n+            let var = self.variable(var_hir_id, upvar.span);\n+            let upvar_id = ty::UpvarId {\n+                var_path: ty::UpvarPath { hir_id: var_hir_id },\n+                closure_expr_id: self.ir.body_owner.expect_local(),\n+            };\n+            match self.tables.upvar_capture(upvar_id) {\n+                ty::UpvarCapture::ByValue => {}\n+                ty::UpvarCapture::ByRef(..) => continue,\n+            };\n+            if self.used_on_entry(entry_ln, var) {\n+                if self.live_on_entry(entry_ln, var).is_none() {\n+                    if let Some(name) = self.should_warn(var) {\n+                        self.ir.tcx.struct_span_lint_hir(\n+                            lint::builtin::UNUSED_ASSIGNMENTS,\n+                            var_hir_id,\n+                            vec![upvar.span],\n+                            |lint| {\n+                                lint.build(&format!(\"value captured by `{}` is never read\", name))\n+                                    .help(\"did you mean to capture by reference instead?\")\n+                                    .emit();\n+                            },\n+                        );\n+                    }\n+                }\n+            } else {\n+                if let Some(name) = self.should_warn(var) {\n+                    self.ir.tcx.struct_span_lint_hir(\n+                        lint::builtin::UNUSED_VARIABLES,\n+                        var_hir_id,\n+                        vec![upvar.span],\n+                        |lint| {\n+                            lint.build(&format!(\"unused variable: `{}`\", name))\n+                                .help(\"did you mean to capture by reference instead?\")\n+                                .emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n     fn warn_about_unused_args(&self, body: &hir::Body<'_>, entry_ln: LiveNode) {\n         for p in body.params {\n             self.check_unused_vars_in_pat(&p.pat, Some(entry_ln), |spans, hir_id, ln, var| {\n                 if self.live_on_entry(ln, var).is_none() {\n-                    self.report_dead_assign(hir_id, spans, var, true);\n+                    self.report_unsed_assign(hir_id, spans, var, |name| {\n+                        format!(\"value passed to `{}` is never read\", name)\n+                    });\n                 }\n             });\n         }\n@@ -1651,35 +1772,30 @@ impl<'tcx> Liveness<'_, 'tcx> {\n \n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(hir_id, spans, var, false);\n+            self.report_unsed_assign(hir_id, spans, var, |name| {\n+                format!(\"value assigned to `{}` is never read\", name)\n+            });\n         }\n     }\n \n-    fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n+    fn report_unsed_assign(\n+        &self,\n+        hir_id: HirId,\n+        spans: Vec<Span>,\n+        var: Variable,\n+        message: impl Fn(&str) -> String,\n+    ) {\n         if let Some(name) = self.should_warn(var) {\n-            if is_param {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_ASSIGNMENTS,\n-                    hir_id,\n-                    spans,\n-                    |lint| {\n-                        lint.build(&format!(\"value passed to `{}` is never read\", name))\n-                            .help(\"maybe it is overwritten before being read?\")\n-                            .emit();\n-                    },\n-                )\n-            } else {\n-                self.ir.tcx.struct_span_lint_hir(\n-                    lint::builtin::UNUSED_ASSIGNMENTS,\n-                    hir_id,\n-                    spans,\n-                    |lint| {\n-                        lint.build(&format!(\"value assigned to `{}` is never read\", name))\n-                            .help(\"maybe it is overwritten before being read?\")\n-                            .emit();\n-                    },\n-                )\n-            }\n+            self.ir.tcx.struct_span_lint_hir(\n+                lint::builtin::UNUSED_ASSIGNMENTS,\n+                hir_id,\n+                spans,\n+                |lint| {\n+                    lint.build(&message(&name))\n+                        .help(\"maybe it is overwritten before being read?\")\n+                        .emit();\n+                },\n+            )\n         }\n     }\n }"}, {"sha": "1b0feede34ecfc0a8714e340d58af8985b66f464", "filename": "src/test/ui/closures/closure-immutable-outer-variable.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.fixed?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -8,6 +8,6 @@ fn foo(mut f: Box<dyn FnMut()>) {\n \n fn main() {\n     let mut y = true;\n-    foo(Box::new(move || y = false) as Box<_>);\n+    foo(Box::new(move || y = !y) as Box<_>);\n     //~^ ERROR cannot assign to `y`, as it is not declared as mutable\n }"}, {"sha": "50ec1c6148a046cfe39fc815ee16b9fce849df04", "filename": "src/test/ui/closures/closure-immutable-outer-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.rs?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -8,6 +8,6 @@ fn foo(mut f: Box<dyn FnMut()>) {\n \n fn main() {\n     let y = true;\n-    foo(Box::new(move || y = false) as Box<_>);\n+    foo(Box::new(move || y = !y) as Box<_>);\n     //~^ ERROR cannot assign to `y`, as it is not declared as mutable\n }"}, {"sha": "799097889cd30f40e16d8c3cbcd15b7059b94595", "filename": "src/test/ui/closures/closure-immutable-outer-variable.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-immutable-outer-variable.stderr?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -3,8 +3,8 @@ error[E0594]: cannot assign to `y`, as it is not declared as mutable\n    |\n LL |     let y = true;\n    |         - help: consider changing this to be mutable: `mut y`\n-LL |     foo(Box::new(move || y = false) as Box<_>);\n-   |                          ^^^^^^^^^ cannot assign\n+LL |     foo(Box::new(move || y = !y) as Box<_>);\n+   |                          ^^^^^^ cannot assign\n \n error: aborting due to previous error\n "}, {"sha": "a7af01e25b4e2899512d0d8cc0a00c91bf8c13d1", "filename": "src/test/ui/issues/issue-11958.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11958.rs?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -1,10 +1,11 @@\n // run-pass\n-#![forbid(warnings)]\n \n // We shouldn't need to rebind a moved upvar as mut if it's already\n // marked as mut\n \n pub fn main() {\n     let mut x = 1;\n     let _thunk = Box::new(move|| { x = 2; });\n+    //~^ WARN value assigned to `x` is never read\n+    //~| WARN unused variable: `x`\n }"}, {"sha": "25de6ff4c118c033083e9d4cc20b92212726bea8", "filename": "src/test/ui/issues/issue-11958.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11958.stderr?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -0,0 +1,20 @@\n+warning: value assigned to `x` is never read\n+  --> $DIR/issue-11958.rs:8:36\n+   |\n+LL |     let _thunk = Box::new(move|| { x = 2; });\n+   |                                    ^\n+   |\n+   = note: `#[warn(unused_assignments)]` on by default\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `x`\n+  --> $DIR/issue-11958.rs:8:36\n+   |\n+LL |     let _thunk = Box::new(move|| { x = 2; });\n+   |                                    ^\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "b2837e74b8c5161668e07a2e27e7b6eae5c69581", "filename": "src/test/ui/liveness/liveness-upvars.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.rs?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -0,0 +1,108 @@\n+// edition:2018\n+// check-pass\n+#![warn(unused)]\n+#![allow(unreachable_code)]\n+\n+pub fn unintentional_copy_one() {\n+    let mut last = None;\n+    let mut f = move |s| {\n+        last = Some(s); //~  WARN value assigned to `last` is never read\n+                        //~| WARN unused variable: `last`\n+    };\n+    f(\"a\");\n+    f(\"b\");\n+    f(\"c\");\n+    dbg!(last.unwrap());\n+}\n+\n+pub fn unintentional_copy_two() {\n+    let mut sum = 0;\n+    (1..10).for_each(move |x| {\n+        sum += x; //~ WARN unused variable: `sum`\n+    });\n+    dbg!(sum);\n+}\n+\n+pub fn f() {\n+    let mut c = 0;\n+\n+    // Captured by value, but variable is dead on entry.\n+    move || {\n+        c = 1; //~ WARN value captured by `c` is never read\n+        println!(\"{}\", c);\n+    };\n+    let _ = async move {\n+        c = 1; //~ WARN value captured by `c` is never read\n+        println!(\"{}\", c);\n+    };\n+\n+    // Read and written to, but never actually used.\n+    move || {\n+        c += 1; //~ WARN unused variable: `c`\n+    };\n+    let _ = async move {\n+        c += 1; //~  WARN value assigned to `c` is never read\n+                //~| WARN unused variable: `c`\n+    };\n+\n+    move || {\n+        println!(\"{}\", c);\n+        // Value is read by closure itself on later invocations.\n+        c += 1;\n+    };\n+    let b = Box::new(42);\n+    move || {\n+        println!(\"{}\", c);\n+        // Never read because this is FnOnce closure.\n+        c += 1; //~  WARN value assigned to `c` is never read\n+        drop(b);\n+    };\n+    let _ = async move {\n+        println!(\"{}\", c);\n+        // Never read because this is a generator.\n+        c += 1; //~  WARN value assigned to `c` is never read\n+    };\n+}\n+\n+pub fn nested() {\n+    let mut d = None;\n+    let mut e = None;\n+    || {\n+        || {\n+            d = Some(\"d1\"); //~ WARN value assigned to `d` is never read\n+            d = Some(\"d2\");\n+        };\n+        move || {\n+            e = Some(\"e1\"); //~  WARN value assigned to `e` is never read\n+                            //~| WARN unused variable: `e`\n+            e = Some(\"e2\"); //~  WARN value assigned to `e` is never read\n+        };\n+    };\n+}\n+\n+pub fn g<T: Default>(mut v: T) {\n+    |r| {\n+        if r {\n+            v = T::default(); //~ WARN value assigned to `v` is never read\n+        } else {\n+            drop(v);\n+        }\n+    };\n+}\n+\n+pub fn h<T: Copy + Default + std::fmt::Debug>() {\n+    let mut z = T::default();\n+    move |b| {\n+        loop {\n+            if b {\n+                z = T::default(); //~  WARN value assigned to `z` is never read\n+                                  //~| WARN unused variable: `z`\n+            } else {\n+                return;\n+            }\n+        }\n+        dbg!(z);\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "14fed917864361d0810912e8704066fca84fbcbc", "filename": "src/test/ui/liveness/liveness-upvars.stderr", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -0,0 +1,150 @@\n+warning: value assigned to `last` is never read\n+  --> $DIR/liveness-upvars.rs:9:9\n+   |\n+LL |         last = Some(s);\n+   |         ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-upvars.rs:3:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `last`\n+  --> $DIR/liveness-upvars.rs:9:9\n+   |\n+LL |         last = Some(s);\n+   |         ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/liveness-upvars.rs:3:9\n+   |\n+LL | #![warn(unused)]\n+   |         ^^^^^^\n+   = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `sum`\n+  --> $DIR/liveness-upvars.rs:21:9\n+   |\n+LL |         sum += x;\n+   |         ^^^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value captured by `c` is never read\n+  --> $DIR/liveness-upvars.rs:31:9\n+   |\n+LL |         c = 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value captured by `c` is never read\n+  --> $DIR/liveness-upvars.rs:35:9\n+   |\n+LL |         c = 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `c`\n+  --> $DIR/liveness-upvars.rs:41:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:44:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `c`\n+  --> $DIR/liveness-upvars.rs:44:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:57:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `c` is never read\n+  --> $DIR/liveness-upvars.rs:63:9\n+   |\n+LL |         c += 1;\n+   |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `d` is never read\n+  --> $DIR/liveness-upvars.rs:72:13\n+   |\n+LL |             d = Some(\"d1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `e` is never read\n+  --> $DIR/liveness-upvars.rs:76:13\n+   |\n+LL |             e = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `e` is never read\n+  --> $DIR/liveness-upvars.rs:78:13\n+   |\n+LL |             e = Some(\"e2\");\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `e`\n+  --> $DIR/liveness-upvars.rs:76:13\n+   |\n+LL |             e = Some(\"e1\");\n+   |             ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: value assigned to `v` is never read\n+  --> $DIR/liveness-upvars.rs:86:13\n+   |\n+LL |             v = T::default();\n+   |             ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: value assigned to `z` is never read\n+  --> $DIR/liveness-upvars.rs:98:17\n+   |\n+LL |                 z = T::default();\n+   |                 ^\n+   |\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `z`\n+  --> $DIR/liveness-upvars.rs:98:17\n+   |\n+LL |                 z = T::default();\n+   |                 ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 17 warnings emitted\n+"}, {"sha": "390386e57fa72db7dca488f0ff1c1c9511ee7c13", "filename": "src/test/ui/unboxed-closures/unboxed-closures-counter-not-moved.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.rs?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![allow(unused_variables)]\n // Test that we mutate a counter on the stack only when we expect to.\n \n fn call<F>(f: F) where F : FnOnce() {\n@@ -13,7 +12,7 @@ fn main() {\n     call(|| {\n         // Move `y`, but do not move `counter`, even though it is read\n         // by value (note that it is also mutated).\n-        for item in y {\n+        for item in y { //~ WARN unused variable: `item`\n             let v = counter;\n             counter += v;\n         }\n@@ -22,7 +21,8 @@ fn main() {\n \n     call(move || {\n         // this mutates a moved copy, and hence doesn't affect original\n-        counter += 1;\n+        counter += 1; //~  WARN value assigned to `counter` is never read\n+                      //~| WARN unused variable: `counter`\n     });\n     assert_eq!(counter, 88);\n }"}, {"sha": "ba4b3dac6705e0bc41204e16de8bceb09ca10fb5", "filename": "src/test/ui/unboxed-closures/unboxed-closures-counter-not-moved.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-counter-not-moved.stderr?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -0,0 +1,27 @@\n+warning: unused variable: `item`\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:15:13\n+   |\n+LL |         for item in y {\n+   |             ^^^^ help: if this is intentional, prefix it with an underscore: `_item`\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+\n+warning: value assigned to `counter` is never read\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:24:9\n+   |\n+LL |         counter += 1;\n+   |         ^^^^^^^\n+   |\n+   = note: `#[warn(unused_assignments)]` on by default\n+   = help: maybe it is overwritten before being read?\n+\n+warning: unused variable: `counter`\n+  --> $DIR/unboxed-closures-counter-not-moved.rs:24:9\n+   |\n+LL |         counter += 1;\n+   |         ^^^^^^^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "e5b19db78223123f78c73d9cab8feda4aeac7a5e", "filename": "src/test/ui/unboxed-closures/unboxed-closures-move-mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.rs?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -13,11 +13,11 @@ fn set(x: &mut usize) { *x = 42; }\n fn main() {\n     {\n         let mut x = 0_usize;\n-        move || x += 1;\n+        move || x += 1; //~ WARN unused variable: `x`\n     }\n     {\n         let mut x = 0_usize;\n-        move || x += 1;\n+        move || x += 1; //~ WARN unused variable: `x`\n     }\n     {\n         let mut x = 0_usize;"}, {"sha": "4dfd1bb307574e7d0c94350bbd111d1bb49899a2", "filename": "src/test/ui/unboxed-closures/unboxed-closures-move-mutable.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4dc56614b27337fe770943760f41a58bbab7c7c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-move-mutable.stderr?ref=4dc56614b27337fe770943760f41a58bbab7c7c6", "patch": "@@ -0,0 +1,19 @@\n+warning: unused variable: `x`\n+  --> $DIR/unboxed-closures-move-mutable.rs:16:17\n+   |\n+LL |         move || x += 1;\n+   |                 ^\n+   |\n+   = note: `#[warn(unused_variables)]` on by default\n+   = help: did you mean to capture by reference instead?\n+\n+warning: unused variable: `x`\n+  --> $DIR/unboxed-closures-move-mutable.rs:20:17\n+   |\n+LL |         move || x += 1;\n+   |                 ^\n+   |\n+   = help: did you mean to capture by reference instead?\n+\n+warning: 2 warnings emitted\n+"}]}