{"sha": "521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMTczNDc4N2VjZjgwZmYxMmRmN2NhNTk5OGY3ZWMwYjNiN2IyYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-20T11:00:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-20T11:00:55Z"}, "message": "Auto merge of #87329 - sunfishcode:sunfishcode/io-safety, r=joshtriplett\n\nI/O safety.\n\nIntroduce `OwnedFd` and `BorrowedFd`, and the `AsFd` trait, and\nimplementations of `AsFd`, `From<OwnedFd>` and `From<T> for OwnedFd`\nfor relevant types, along with Windows counterparts for handles and\nsockets.\n\nTracking issue: <https://github.com/rust-lang/rust/issues/87074>\n\nRFC: <https://github.com/rust-lang/rfcs/blob/master/text/3128-io-safety.md>\n\nHighlights:\n - The doc comments at the top of library/std/src/os/unix/io/mod.rs and library/std/src/os/windows/io/mod.rs\n - The new types and traits in library/std/src/os/unix/io/fd.rs and library/std/src/os/windows/io/handle.rs\n - The removal of the `RawHandle` struct the Windows impl, which had the same name as the `RawHandle` type alias, and its functionality is now folded into `Handle`.\n\nManaging five levels of wrapping (File wraps sys::fs::File wraps sys::fs::FileDesc wraps OwnedFd wraps RawFd, etc.) made for a fair amount of churn and verbose as/into/from sequences in some places. I've managed to simplify some of them, but I'm open to ideas here.\n\nr? `@joshtriplett`", "tree": {"sha": "14d6353b5d2990f5572b35cfbf0c13422f0fd6f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14d6353b5d2990f5572b35cfbf0c13422f0fd6f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "html_url": "https://github.com/rust-lang/rust/commit/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ccf661694423895b02e513c69e6ad263b2f3d8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ccf661694423895b02e513c69e6ad263b2f3d8e", "html_url": "https://github.com/rust-lang/rust/commit/9ccf661694423895b02e513c69e6ad263b2f3d8e"}, {"sha": "b4dfa198bf4879bc159c7119bd4188ccd625f71d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4dfa198bf4879bc159c7119bd4188ccd625f71d", "html_url": "https://github.com/rust-lang/rust/commit/b4dfa198bf4879bc159c7119bd4188ccd625f71d"}], "stats": {"total": 2940, "additions": 2229, "deletions": 711}, "files": [{"sha": "bdb172907ffed39b770d802093c2ea416d485365", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -587,6 +587,12 @@ impl File {\n     }\n }\n \n+// In addition to the `impl`s here, `File` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and\n+// `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.\n+\n impl AsInner<fs_imp::File> for File {\n     fn as_inner(&self) -> &fs_imp::File {\n         &self.inner"}, {"sha": "336891ec1eb9479ff5b8bd097eced0db91d6c785", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -546,6 +546,12 @@ impl TcpStream {\n     }\n }\n \n+// In addition to the `impl`s here, `TcpStream` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` and\n+// `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` on Windows.\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -915,6 +921,12 @@ impl TcpListener {\n     }\n }\n \n+// In addition to the `impl`s here, `TcpListener` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` and\n+// `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` on Windows.\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Incoming<'a> {\n     type Item = io::Result<TcpStream>;"}, {"sha": "871505843af23c5ca513c85c0e45d40d0fe1a382", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -779,6 +779,12 @@ impl UdpSocket {\n     }\n }\n \n+// In addition to the `impl`s here, `UdpSocket` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsSocket`/`From<OwnedSocket>`/`Into<OwnedSocket>` and\n+// `AsRawSocket`/`IntoRawSocket`/`FromRawSocket` on Windows.\n+\n impl AsInner<net_imp::UdpSocket> for UdpSocket {\n     fn as_inner(&self) -> &net_imp::UdpSocket {\n         &self.0"}, {"sha": "a51113dd9e74925aa6199dc7a579cfd99f830442", "filename": "library/std/src/net/udp/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -2,7 +2,6 @@ use crate::io::ErrorKind;\n use crate::net::test::{next_test_ip4, next_test_ip6};\n use crate::net::*;\n use crate::sync::mpsc::channel;\n-use crate::sys_common::AsInner;\n use crate::thread;\n use crate::time::{Duration, Instant};\n \n@@ -173,7 +172,7 @@ fn debug() {\n     let socket_addr = next_test_ip4();\n \n     let udpsock = t!(UdpSocket::bind(&socket_addr));\n-    let udpsock_inner = udpsock.0.socket().as_inner();\n+    let udpsock_inner = udpsock.0.socket().as_raw();\n     let compare = format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\", socket_addr, name, udpsock_inner);\n     assert_eq!(format!(\"{:?}\", udpsock), compare);\n }"}, {"sha": "df11dc21aa7a6da91f92fc622feb8c0b3346683d", "filename": "library/std/src/os/fd/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,13 @@\n+//! Owned and borrowed Unix-like file descriptors.\n+\n+#![unstable(feature = \"io_safety\", issue = \"87074\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n+// `RawFd`, `AsRawFd`, etc.\n+pub mod raw;\n+\n+// `OwnedFd`, `AsFd`, etc.\n+pub mod owned;\n+\n+// Implementations for `AsRawFd` etc. for network types.\n+mod net;"}, {"sha": "843f45f7f5f9820bfd2641d59bde3c4e99405349", "filename": "library/std/src/os/fd/net.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fnet.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,4 +1,5 @@\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::os::fd::owned::OwnedFd;\n+use crate::os::fd::raw::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n use crate::{net, sys};\n \n@@ -8,7 +9,7 @@ macro_rules! impl_as_raw_fd {\n         impl AsRawFd for net::$t {\n             #[inline]\n             fn as_raw_fd(&self) -> RawFd {\n-                *self.as_inner().socket().as_inner()\n+                self.as_inner().socket().as_raw_fd()\n             }\n         }\n     )*};\n@@ -21,8 +22,10 @@ macro_rules! impl_from_raw_fd {\n         impl FromRawFd for net::$t {\n             #[inline]\n             unsafe fn from_raw_fd(fd: RawFd) -> net::$t {\n-                let socket = sys::net::Socket::from_inner(fd);\n-                net::$t::from_inner(sys_common::net::$t::from_inner(socket))\n+                unsafe {\n+                    let socket = sys::net::Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd)));\n+                    net::$t::from_inner(sys_common::net::$t::from_inner(socket))\n+                }\n             }\n         }\n     )*};\n@@ -35,7 +38,7 @@ macro_rules! impl_into_raw_fd {\n         impl IntoRawFd for net::$t {\n             #[inline]\n             fn into_raw_fd(self) -> RawFd {\n-                self.into_inner().into_socket().into_inner()\n+                self.into_inner().into_socket().into_inner().into_inner().into_raw_fd()\n             }\n         }\n     )*};", "previous_filename": "library/std/src/os/unix/net/raw_fd.rs"}, {"sha": "52d7d4690d39fe9f8414aca445e27f91aa84b057", "filename": "library/std/src/os/fd/owned.rs", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,289 @@\n+//! Owned and borrowed Unix-like file descriptors.\n+\n+#![unstable(feature = \"io_safety\", issue = \"87074\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n+use super::raw::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::fmt;\n+use crate::fs;\n+use crate::marker::PhantomData;\n+use crate::mem::forget;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// A borrowed file descriptor.\n+///\n+/// This has a lifetime parameter to tie it to the lifetime of something that\n+/// owns the file descriptor.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host file\n+/// descriptor, so it can be used in FFI in places where a file descriptor is\n+/// passed as an argument, it is not captured or consumed, and it never has the\n+/// value `-1`.\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n+// 32-bit c_int. Below is -2, in two's complement, but that only works out\n+// because c_int is 32 bits.\n+#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub struct BorrowedFd<'fd> {\n+    fd: RawFd,\n+    _phantom: PhantomData<&'fd OwnedFd>,\n+}\n+\n+/// An owned file descriptor.\n+///\n+/// This closes the file descriptor on drop.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host file\n+/// descriptor, so it can be used in FFI in places where a file descriptor is\n+/// passed as a consumed argument or returned as an owned value, and it never\n+/// has the value `-1`.\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n+// 32-bit c_int. Below is -2, in two's complement, but that only works out\n+// because c_int is 32 bits.\n+#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub struct OwnedFd {\n+    fd: RawFd,\n+}\n+\n+impl BorrowedFd<'_> {\n+    /// Return a `BorrowedFd` holding the given raw file descriptor.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `fd` must remain open for the duration of\n+    /// the returned `BorrowedFd`, and it must not have the value `-1`.\n+    #[inline]\n+    #[unstable(feature = \"io_safety\", issue = \"87074\")]\n+    pub unsafe fn borrow_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, u32::MAX as RawFd);\n+        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n+        unsafe { Self { fd, _phantom: PhantomData } }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsRawFd for BorrowedFd<'_> {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsRawFd for OwnedFd {\n+    #[inline]\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl IntoRawFd for OwnedFd {\n+    #[inline]\n+    fn into_raw_fd(self) -> RawFd {\n+        let fd = self.fd;\n+        forget(self);\n+        fd\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl FromRawFd for OwnedFd {\n+    /// Constructs a new instance of `Self` from the given raw file descriptor.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `fd` must be open and suitable for assuming\n+    /// ownership. The resource must not require any cleanup other than `close`.\n+    #[inline]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        assert_ne!(fd, u32::MAX as RawFd);\n+        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n+        unsafe { Self { fd } }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl Drop for OwnedFd {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Note that errors are ignored when closing a file descriptor. The\n+            // reason for this is that if an error occurs we don't actually know if\n+            // the file descriptor was closed or not, and if we retried (for\n+            // something like EINTR), we might close another valid file descriptor\n+            // opened after we closed ours.\n+            let _ = libc::close(self.fd);\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl fmt::Debug for BorrowedFd<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"BorrowedFd\").field(\"fd\", &self.fd).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl fmt::Debug for OwnedFd {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OwnedFd\").field(\"fd\", &self.fd).finish()\n+    }\n+}\n+\n+/// A trait to borrow the file descriptor from an underlying object.\n+///\n+/// This is only available on unix platforms and must be imported in order to\n+/// call the method. Windows platforms have a corresponding `AsHandle` and\n+/// `AsSocket` set of traits.\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub trait AsFd {\n+    /// Borrows the file descriptor.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,no_run\n+    /// # #![feature(io_safety)]\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// # #[cfg(target_os = \"wasi\")]\n+    /// # use std::os::wasi::io::{AsFd, BorrowedFd};\n+    /// # #[cfg(unix)]\n+    /// # use std::os::unix::io::{AsFd, BorrowedFd};\n+    ///\n+    /// let mut f = File::open(\"foo.txt\")?;\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n+    /// let borrowed_fd: BorrowedFd<'_> = f.as_fd();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n+    #[unstable(feature = \"io_safety\", issue = \"87074\")]\n+    fn as_fd(&self) -> BorrowedFd<'_>;\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for BorrowedFd<'_> {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        *self\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for OwnedFd {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        // Safety: `OwnedFd` and `BorrowedFd` have the same validity\n+        // invariants, and the `BorrowdFd` is bounded by the lifetime\n+        // of `&self`.\n+        unsafe { BorrowedFd::borrow_raw_fd(self.as_raw_fd()) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for fs::File {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<fs::File> for OwnedFd {\n+    #[inline]\n+    fn from(file: fs::File) -> OwnedFd {\n+        file.into_inner().into_inner().into_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for fs::File {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(owned_fd)))\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for crate::net::TcpStream {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().socket().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<crate::net::TcpStream> for OwnedFd {\n+    #[inline]\n+    fn from(tcp_stream: crate::net::TcpStream) -> OwnedFd {\n+        tcp_stream.into_inner().into_socket().into_inner().into_inner().into()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for crate::net::TcpStream {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(\n+            owned_fd,\n+        ))))\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for crate::net::TcpListener {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().socket().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<crate::net::TcpListener> for OwnedFd {\n+    #[inline]\n+    fn from(tcp_listener: crate::net::TcpListener) -> OwnedFd {\n+        tcp_listener.into_inner().into_socket().into_inner().into_inner().into()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for crate::net::TcpListener {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(\n+            owned_fd,\n+        ))))\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for crate::net::UdpSocket {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().socket().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<crate::net::UdpSocket> for OwnedFd {\n+    #[inline]\n+    fn from(udp_socket: crate::net::UdpSocket) -> OwnedFd {\n+        udp_socket.into_inner().into_socket().into_inner().into_inner().into()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for crate::net::UdpSocket {\n+    #[inline]\n+    fn from(owned_fd: OwnedFd) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(FromInner::from_inner(\n+            owned_fd,\n+        ))))\n+    }\n+}"}, {"sha": "f874cf0b42d74fefbe97ae3929675b8a31f84398", "filename": "library/std/src/os/fd/raw.rs", "status": "renamed", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fraw.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,23 +1,25 @@\n-//! Unix-specific extensions to general I/O primitives.\n+//! Raw Unix-like file descriptors.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fs;\n use crate::io;\n use crate::os::raw;\n-use crate::sys;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+#[cfg(unix)]\n+use crate::os::unix::io::OwnedFd;\n+#[cfg(target_os = \"wasi\")]\n+use crate::os::wasi::io::OwnedFd;\n+use crate::sys_common::{AsInner, IntoInner};\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type RawFd = raw::c_int;\n \n-/// A trait to extract the raw unix file descriptor from an underlying\n-/// object.\n+/// A trait to extract the raw file descriptor from an underlying object.\n ///\n-/// This is only available on unix platforms and must be imported in order\n-/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n-/// and `AsRawSocket` set of traits.\n+/// This is only available on unix and WASI platforms and must be imported in\n+/// order to call the method. Windows platforms have a corresponding\n+/// `AsRawHandle` and `AsRawSocket` set of traits.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait AsRawFd {\n     /// Extracts the raw file descriptor.\n@@ -31,10 +33,14 @@ pub trait AsRawFd {\n     /// ```no_run\n     /// use std::fs::File;\n     /// # use std::io;\n+    /// #[cfg(unix)]\n     /// use std::os::unix::io::{AsRawFd, RawFd};\n+    /// #[cfg(target_os = \"wasi\")]\n+    /// use std::os::wasi::io::{AsRawFd, RawFd};\n     ///\n     /// let mut f = File::open(\"foo.txt\")?;\n     /// // Note that `raw_fd` is only valid as long as `f` exists.\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n     /// let raw_fd: RawFd = f.as_raw_fd();\n     /// # Ok::<(), io::Error>(())\n     /// ```\n@@ -64,12 +70,17 @@ pub trait FromRawFd {\n     /// ```no_run\n     /// use std::fs::File;\n     /// # use std::io;\n+    /// #[cfg(unix)]\n     /// use std::os::unix::io::{FromRawFd, IntoRawFd, RawFd};\n+    /// #[cfg(target_os = \"wasi\")]\n+    /// use std::os::wasi::io::{FromRawFd, IntoRawFd, RawFd};\n     ///\n     /// let f = File::open(\"foo.txt\")?;\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n     /// let raw_fd: RawFd = f.into_raw_fd();\n     /// // SAFETY: no other functions should call `from_raw_fd`, so there\n     /// // is only one owner for the file descriptor.\n+    /// # #[cfg(any(unix, target_os = \"wasi\"))]\n     /// let f = unsafe { File::from_raw_fd(raw_fd) };\n     /// # Ok::<(), io::Error>(())\n     /// ```\n@@ -92,9 +103,13 @@ pub trait IntoRawFd {\n     /// ```no_run\n     /// use std::fs::File;\n     /// # use std::io;\n+    /// #[cfg(unix)]\n     /// use std::os::unix::io::{IntoRawFd, RawFd};\n+    /// #[cfg(target_os = \"wasi\")]\n+    /// use std::os::wasi::io::{IntoRawFd, RawFd};\n     ///\n     /// let f = File::open(\"foo.txt\")?;\n+    /// #[cfg(any(unix, target_os = \"wasi\"))]\n     /// let raw_fd: RawFd = f.into_raw_fd();\n     /// # Ok::<(), io::Error>(())\n     /// ```\n@@ -128,21 +143,21 @@ impl FromRawFd for RawFd {\n impl AsRawFd for fs::File {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n+        self.as_inner().as_raw_fd()\n     }\n }\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for fs::File {\n     #[inline]\n     unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-        fs::File::from_inner(sys::fs::File::from_inner(fd))\n+        unsafe { fs::File::from(OwnedFd::from_raw_fd(fd)) }\n     }\n }\n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for fs::File {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n+        self.into_inner().into_inner().into_raw_fd()\n     }\n }\n ", "previous_filename": "library/std/src/os/unix/io.rs"}, {"sha": "e3e7143c851efaebb92d1a69b3e6864238a1d6cf", "filename": "library/std/src/os/linux/process.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -3,7 +3,7 @@\n #![unstable(feature = \"linux_pidfd\", issue = \"82971\")]\n \n use crate::io::Result;\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::process;\n use crate::sealed::Sealed;\n #[cfg(not(doc))]\n@@ -69,19 +69,37 @@ impl IntoInner<FileDesc> for PidFd {\n \n impl AsRawFd for PidFd {\n     fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().raw()\n+        self.as_inner().as_raw_fd()\n     }\n }\n \n impl FromRawFd for PidFd {\n     unsafe fn from_raw_fd(fd: RawFd) -> Self {\n-        Self::from_inner(FileDesc::new(fd))\n+        Self::from_inner(FileDesc::from_raw_fd(fd))\n     }\n }\n \n impl IntoRawFd for PidFd {\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_raw()\n+        self.into_inner().into_raw_fd()\n+    }\n+}\n+\n+impl AsFd for PidFd {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().as_fd()\n+    }\n+}\n+\n+impl From<OwnedFd> for PidFd {\n+    fn from(fd: OwnedFd) -> Self {\n+        Self::from_inner(FileDesc::from_inner(fd))\n+    }\n+}\n+\n+impl From<PidFd> for OwnedFd {\n+    fn from(pid_fd: PidFd) -> Self {\n+        pid_fd.into_inner().into_inner()\n     }\n }\n "}, {"sha": "79e6967300767e463a5b6c06f5b2b663c9742809", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -121,3 +121,6 @@ mod imp {\n #[cfg(not(doc))]\n #[stable(feature = \"os\", since = \"1.0.0\")]\n pub use imp::*;\n+\n+#[cfg(any(unix, target_os = \"wasi\", doc))]\n+mod fd;"}, {"sha": "7795db7abc01def170058fbb567d50df1c8bce6d", "filename": "library/std/src/os/unix/io/fd.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,9 @@\n+//! Owned and borrowed file descriptors.\n+\n+#![unstable(feature = \"io_safety\", issue = \"87074\")]\n+\n+// Tests for this module\n+#[cfg(test)]\n+mod tests;\n+\n+pub use crate::os::fd::owned::*;"}, {"sha": "84d2a7a1a91b4f391f5c79161708c01664d93273", "filename": "library/std/src/os/unix/io/fd/tests.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Ffd%2Ftests.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,11 @@\n+use crate::mem::size_of;\n+use crate::os::unix::io::RawFd;\n+\n+#[test]\n+fn test_raw_fd_layout() {\n+    // `OwnedFd` and `BorrowedFd` use `rustc_layout_scalar_valid_range_start`\n+    // and `rustc_layout_scalar_valid_range_end`, with values that depend on\n+    // the bit width of `RawFd`. If this ever changes, those values will need\n+    // to be updated.\n+    assert_eq!(size_of::<RawFd>(), 4);\n+}"}, {"sha": "0fd9591b0165ad14af07a387e9d63ce58e4da009", "filename": "library/std/src/os/unix/io/mod.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,57 @@\n+//! Unix-specific extensions to general I/O primitives.\n+//!\n+//! Just like raw pointers, raw file descriptors point to resources with\n+//! dynamic lifetimes, and they can dangle if they outlive their resources\n+//! or be forged if they're created from invalid values.\n+//!\n+//! This module provides three types for representing file descriptors,\n+//! with different ownership properties: raw, borrowed, and owned, which are\n+//! analogous to types used for representing pointers:\n+//!\n+//! | Type               | Analogous to |\n+//! | ------------------ | ------------ |\n+//! | [`RawFd`]          | `*const _`   |\n+//! | [`BorrowedFd<'a>`] | `&'a _`      |\n+//! | [`OwnedFd`]        | `Box<_>`     |\n+//!\n+//! Like raw pointers, `RawFd` values are primitive values. And in new code,\n+//! they should be considered unsafe to do I/O on (analogous to dereferencing\n+//! them). Rust did not always provide this guidance, so existing code in the\n+//! Rust ecosystem often doesn't mark `RawFd` usage as unsafe. Once the\n+//! `io_safety` feature is stable, libraries will be encouraged to migrate,\n+//! either by adding `unsafe` to APIs that dereference `RawFd` values, or by\n+//! using to `BorrowedFd` or `OwnedFd` instead.\n+//!\n+//! Like references, `BorrowedFd` values are tied to a lifetime, to ensure\n+//! that they don't outlive the resource they point to. These are safe to\n+//! use. `BorrowedFd` values may be used in APIs which provide safe access to\n+//! any system call except for:\n+//!  - `close`, because that would end the dynamic lifetime of the resource\n+//!    without ending the lifetime of the file descriptor.\n+//!  - `dup2`/`dup3`, in the second argument, because this argument is\n+//!    closed and assigned a new resource, which may break the assumptions\n+//!    other code using that file descriptor.\n+//! This list doesn't include `mmap`, since `mmap` does do a proper borrow of\n+//! its file descriptor argument. That said, `mmap` is unsafe for other\n+//! reasons: it operates on raw pointers, and it can have undefined behavior if\n+//! the underlying storage is mutated. Mutations may come from other processes,\n+//! or from the same process if the API provides `BorrowedFd` access, since as\n+//! mentioned earlier, `BorrowedFd` values may be used in APIs which provide\n+//! safe access to any system call. Consequently, code using `mmap` and\n+//! presenting a safe API must take full responsibility for ensuring that safe\n+//! Rust code cannot evoke undefined behavior through it.\n+//!\n+//! Like boxes, `OwnedFd` values conceptually own the resource they point to,\n+//! and free (close) it when they are dropped.\n+//!\n+//! [`BorrowedFd<'a>`]: crate::os::unix::io::BorrowedFd\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+mod fd;\n+mod raw;\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub use fd::*;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use raw::*;"}, {"sha": "6317e317471199a02794fe55fcb560ca8593f4f3", "filename": "library/std/src/os/unix/io/raw.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fio%2Fraw.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,5 @@\n+//! Unix-specific extensions to general I/O primitives.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub use crate::os::fd::raw::*;"}, {"sha": "17a0259572446bf3337192ad10575279e1e2d4ee", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -108,7 +108,7 @@ pub mod prelude {\n     pub use super::fs::{FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt};\n     #[doc(no_inline)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+    pub use super::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n     #[doc(no_inline)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::process::{CommandExt, ExitStatusExt};"}, {"sha": "f11eec18cc5219ac5a91467ce9e552f7cf644051", "filename": "library/std/src/os/unix/net/datagram.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -21,7 +21,7 @@ use super::{sockaddr_un, SocketAddr};\n ))]\n use crate::io::{IoSlice, IoSliceMut};\n use crate::net::Shutdown;\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::path::Path;\n use crate::sys::cvt;\n use crate::sys::net::Socket;\n@@ -106,7 +106,7 @@ impl UnixDatagram {\n             let socket = UnixDatagram::unbound()?;\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n \n-            cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n+            cvt(libc::bind(socket.as_raw_fd(), &addr as *const _ as *const _, len as _))?;\n \n             Ok(socket)\n         }\n@@ -187,7 +187,7 @@ impl UnixDatagram {\n         unsafe {\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n \n-            cvt(libc::connect(*self.0.as_inner(), &addr as *const _ as *const _, len))?;\n+            cvt(libc::connect(self.as_raw_fd(), &addr as *const _ as *const _, len))?;\n         }\n         Ok(())\n     }\n@@ -229,7 +229,7 @@ impl UnixDatagram {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(self.as_raw_fd(), addr, len) })\n     }\n \n     /// Returns the address of this socket's peer.\n@@ -253,7 +253,7 @@ impl UnixDatagram {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(self.as_raw_fd(), addr, len) })\n     }\n \n     fn recv_from_flags(\n@@ -264,7 +264,7 @@ impl UnixDatagram {\n         let mut count = 0;\n         let addr = SocketAddr::new(|addr, len| unsafe {\n             count = libc::recvfrom(\n-                *self.0.as_inner(),\n+                self.as_raw_fd(),\n                 buf.as_mut_ptr() as *mut _,\n                 buf.len(),\n                 flags,\n@@ -462,7 +462,7 @@ impl UnixDatagram {\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n \n             let count = cvt(libc::sendto(\n-                *self.0.as_inner(),\n+                self.as_raw_fd(),\n                 buf.as_ptr() as *const _,\n                 buf.len(),\n                 MSG_NOSIGNAL,\n@@ -881,22 +881,46 @@ impl UnixDatagram {\n impl AsRawFd for UnixDatagram {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n+        self.0.as_inner().as_raw_fd()\n     }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl FromRawFd for UnixDatagram {\n     #[inline]\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n-        UnixDatagram(Socket::from_inner(fd))\n+        UnixDatagram(Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd))))\n     }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl IntoRawFd for UnixDatagram {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n+        self.0.into_inner().into_inner().into_raw_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for UnixDatagram {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_inner().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<UnixDatagram> for OwnedFd {\n+    #[inline]\n+    fn from(unix_datagram: UnixDatagram) -> OwnedFd {\n+        unsafe { OwnedFd::from_raw_fd(unix_datagram.into_raw_fd()) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for UnixDatagram {\n+    #[inline]\n+    fn from(owned: OwnedFd) -> Self {\n+        unsafe { Self::from_raw_fd(owned.into_raw_fd()) }\n     }\n }"}, {"sha": "9066c71794fadbf32a728eb157a77b36a4c621a4", "filename": "library/std/src/os/unix/net/listener.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,5 +1,5 @@\n use super::{sockaddr_un, SocketAddr, UnixStream};\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::path::Path;\n use crate::sys::cvt;\n use crate::sys::net::Socket;\n@@ -74,8 +74,8 @@ impl UnixListener {\n             let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n \n-            cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-            cvt(libc::listen(*inner.as_inner(), 128))?;\n+            cvt(libc::bind(inner.as_inner().as_raw_fd(), &addr as *const _ as *const _, len as _))?;\n+            cvt(libc::listen(inner.as_inner().as_raw_fd(), 128))?;\n \n             Ok(UnixListener(inner))\n         }\n@@ -150,7 +150,7 @@ impl UnixListener {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(self.as_raw_fd(), addr, len) })\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n@@ -242,23 +242,23 @@ impl UnixListener {\n impl AsRawFd for UnixListener {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n+        self.0.as_inner().as_raw_fd()\n     }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl FromRawFd for UnixListener {\n     #[inline]\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n+        UnixListener(Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd))))\n     }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl IntoRawFd for UnixListener {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n+        self.0.into_inner().into_inner().into_raw_fd()\n     }\n }\n "}, {"sha": "d462bd4b5f75e8765e39424f19cb2d5555ef83cb", "filename": "library/std/src/os/unix/net/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -25,7 +25,6 @@ mod addr;\n mod ancillary;\n mod datagram;\n mod listener;\n-mod raw_fd;\n mod stream;\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n@@ -48,7 +47,5 @@ pub use self::ancillary::*;\n pub use self::datagram::*;\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub use self::listener::*;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::raw_fd::*;\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub use self::stream::*;"}, {"sha": "4119de3c03cbecf0e2880b4390c3cc376aedb8e6", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -13,7 +13,7 @@ use super::{sockaddr_un, SocketAddr};\n use crate::fmt;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n use crate::net::Shutdown;\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n #[cfg(any(\n     target_os = \"android\",\n     target_os = \"linux\",\n@@ -28,7 +28,7 @@ use crate::os::unix::ucred;\n use crate::path::Path;\n use crate::sys::cvt;\n use crate::sys::net::Socket;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, FromInner};\n use crate::time::Duration;\n \n #[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n@@ -101,7 +101,7 @@ impl UnixStream {\n             let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n \n-            cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+            cvt(libc::connect(inner.as_raw_fd(), &addr as *const _ as *const _, len))?;\n             Ok(UnixStream(inner))\n         }\n     }\n@@ -167,7 +167,7 @@ impl UnixStream {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(self.as_raw_fd(), addr, len) })\n     }\n \n     /// Returns the socket address of the remote half of this connection.\n@@ -185,7 +185,7 @@ impl UnixStream {\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(self.as_raw_fd(), addr, len) })\n     }\n \n     /// Gets the peer credentials for this Unix domain socket.\n@@ -659,22 +659,46 @@ impl<'a> io::Write for &'a UnixStream {\n impl AsRawFd for UnixStream {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n+        self.0.as_raw_fd()\n     }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl FromRawFd for UnixStream {\n     #[inline]\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n+        UnixStream(Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd))))\n     }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n impl IntoRawFd for UnixStream {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n+        self.0.into_raw_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for UnixStream {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<UnixStream> for OwnedFd {\n+    #[inline]\n+    fn from(unix_stream: UnixStream) -> OwnedFd {\n+        unsafe { OwnedFd::from_raw_fd(unix_stream.into_raw_fd()) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for UnixStream {\n+    #[inline]\n+    fn from(owned: OwnedFd) -> Self {\n+        unsafe { Self::from_raw_fd(owned.into_raw_fd()) }\n     }\n }"}, {"sha": "650dcbabbae8c0beeb753bbad5b9fb7284b351b9", "filename": "library/std/src/os/unix/process.rs", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fprocess.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -4,7 +4,7 @@\n \n use crate::ffi::OsStr;\n use crate::io;\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::process;\n use crate::sealed::Sealed;\n use crate::sys;\n@@ -321,7 +321,17 @@ impl ExitStatusExt for process::ExitStatusError {\n impl FromRawFd for process::Stdio {\n     #[inline]\n     unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n-        let fd = sys::fd::FileDesc::new(fd);\n+        let fd = sys::fd::FileDesc::from_raw_fd(fd);\n+        let io = sys::process::Stdio::Fd(fd);\n+        process::Stdio::from_inner(io)\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedFd> for process::Stdio {\n+    #[inline]\n+    fn from(fd: OwnedFd) -> process::Stdio {\n+        let fd = sys::fd::FileDesc::from_inner(fd);\n         let io = sys::process::Stdio::Fd(fd);\n         process::Stdio::from_inner(io)\n     }\n@@ -331,47 +341,95 @@ impl FromRawFd for process::Stdio {\n impl AsRawFd for process::ChildStdin {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n+        self.as_inner().as_raw_fd()\n     }\n }\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl AsRawFd for process::ChildStdout {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n+        self.as_inner().as_raw_fd()\n     }\n }\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl AsRawFd for process::ChildStderr {\n     #[inline]\n     fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n+        self.as_inner().as_raw_fd()\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for process::ChildStdin {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n+        self.into_inner().into_inner().into_raw_fd()\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for process::ChildStdout {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n+        self.into_inner().into_inner().into_raw_fd()\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawFd for process::ChildStderr {\n     #[inline]\n     fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n+        self.into_inner().into_inner().into_raw_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for crate::process::ChildStdin {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<crate::process::ChildStdin> for OwnedFd {\n+    #[inline]\n+    fn from(child_stdin: crate::process::ChildStdin) -> OwnedFd {\n+        child_stdin.into_inner().into_inner().into_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for crate::process::ChildStdout {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<crate::process::ChildStdout> for OwnedFd {\n+    #[inline]\n+    fn from(child_stdout: crate::process::ChildStdout) -> OwnedFd {\n+        child_stdout.into_inner().into_inner().into_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for crate::process::ChildStderr {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.as_inner().as_fd()\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<crate::process::ChildStderr> for OwnedFd {\n+    #[inline]\n+    fn from(child_stderr: crate::process::ChildStderr) -> OwnedFd {\n+        child_stderr.into_inner().into_inner().into_inner()\n     }\n }\n "}, {"sha": "3df27563e21e9aafd5bc8f2eb0d0220f61faec12", "filename": "library/std/src/os/wasi/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Ffs.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -228,35 +228,35 @@ pub trait FileExt {\n \n impl FileExt for fs::File {\n     fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n-        self.as_inner().fd().pread(bufs, offset)\n+        self.as_inner().as_inner().pread(bufs, offset)\n     }\n \n     fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n-        self.as_inner().fd().pwrite(bufs, offset)\n+        self.as_inner().as_inner().pwrite(bufs, offset)\n     }\n \n     fn tell(&self) -> io::Result<u64> {\n-        self.as_inner().fd().tell()\n+        self.as_inner().as_inner().tell()\n     }\n \n     fn fdstat_set_flags(&self, flags: u16) -> io::Result<()> {\n-        self.as_inner().fd().set_flags(flags)\n+        self.as_inner().as_inner().set_flags(flags)\n     }\n \n     fn fdstat_set_rights(&self, rights: u64, inheriting: u64) -> io::Result<()> {\n-        self.as_inner().fd().set_rights(rights, inheriting)\n+        self.as_inner().as_inner().set_rights(rights, inheriting)\n     }\n \n     fn advise(&self, offset: u64, len: u64, advice: u8) -> io::Result<()> {\n-        self.as_inner().fd().advise(offset, len, advice)\n+        self.as_inner().as_inner().advise(offset, len, advice)\n     }\n \n     fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n-        self.as_inner().fd().allocate(offset, len)\n+        self.as_inner().as_inner().allocate(offset, len)\n     }\n \n     fn create_directory<P: AsRef<Path>>(&self, dir: P) -> io::Result<()> {\n-        self.as_inner().fd().create_directory(osstr2str(dir.as_ref().as_ref())?)\n+        self.as_inner().as_inner().create_directory(osstr2str(dir.as_ref().as_ref())?)\n     }\n \n     fn read_link<P: AsRef<Path>>(&self, path: P) -> io::Result<PathBuf> {\n@@ -269,11 +269,11 @@ impl FileExt for fs::File {\n     }\n \n     fn remove_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        self.as_inner().fd().unlink_file(osstr2str(path.as_ref().as_ref())?)\n+        self.as_inner().as_inner().unlink_file(osstr2str(path.as_ref().as_ref())?)\n     }\n \n     fn remove_directory<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        self.as_inner().fd().remove_directory(osstr2str(path.as_ref().as_ref())?)\n+        self.as_inner().as_inner().remove_directory(osstr2str(path.as_ref().as_ref())?)\n     }\n }\n \n@@ -486,10 +486,10 @@ pub fn link<P: AsRef<Path>, U: AsRef<Path>>(\n     new_fd: &File,\n     new_path: U,\n ) -> io::Result<()> {\n-    old_fd.as_inner().fd().link(\n+    old_fd.as_inner().as_inner().link(\n         old_flags,\n         osstr2str(old_path.as_ref().as_ref())?,\n-        new_fd.as_inner().fd(),\n+        new_fd.as_inner().as_inner(),\n         osstr2str(new_path.as_ref().as_ref())?,\n     )\n }\n@@ -503,9 +503,9 @@ pub fn rename<P: AsRef<Path>, U: AsRef<Path>>(\n     new_fd: &File,\n     new_path: U,\n ) -> io::Result<()> {\n-    old_fd.as_inner().fd().rename(\n+    old_fd.as_inner().as_inner().rename(\n         osstr2str(old_path.as_ref().as_ref())?,\n-        new_fd.as_inner().fd(),\n+        new_fd.as_inner().as_inner(),\n         osstr2str(new_path.as_ref().as_ref())?,\n     )\n }\n@@ -519,7 +519,7 @@ pub fn symlink<P: AsRef<Path>, U: AsRef<Path>>(\n     new_path: U,\n ) -> io::Result<()> {\n     fd.as_inner()\n-        .fd()\n+        .as_inner()\n         .symlink(osstr2str(old_path.as_ref().as_ref())?, osstr2str(new_path.as_ref().as_ref())?)\n }\n "}, {"sha": "b6bc74da8e7b5b5dc0f525747df6676eb41badb8", "filename": "library/std/src/os/wasi/io.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/9ccf661694423895b02e513c69e6ad263b2f3d8e/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ccf661694423895b02e513c69e6ad263b2f3d8e/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio.rs?ref=9ccf661694423895b02e513c69e6ad263b2f3d8e", "patch": "@@ -1,208 +0,0 @@\n-//! WASI-specific extensions to general I/O primitives\n-\n-#![deny(unsafe_op_in_unsafe_fn)]\n-#![unstable(feature = \"wasi_ext\", issue = \"71213\")]\n-\n-use crate::fs;\n-use crate::io;\n-use crate::net;\n-use crate::os::raw;\n-use crate::sys;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-\n-/// Raw file descriptors.\n-///\n-/// This has type `c_int` to ease compatibility with code that also compiles on\n-/// Unix configurations, however unlike Unix and POSIX, in WASI negative file\n-/// descriptors are valid. Only `-1` is reserved for indicating errors. Code\n-/// intending to be portable across Unix platforms and WASI should avoid\n-/// assuming that negative file descriptors are invalid.\n-pub type RawFd = raw::c_int;\n-\n-/// A trait to extract the raw WASI file descriptor from an underlying\n-/// object.\n-pub trait AsRawFd {\n-    /// Extracts the raw file descriptor.\n-    ///\n-    /// This method does **not** pass ownership of the raw file descriptor\n-    /// to the caller. The descriptor is only guaranteed to be valid while\n-    /// the original object has not yet been destroyed.\n-    fn as_raw_fd(&self) -> RawFd;\n-}\n-\n-/// A trait to express the ability to construct an object from a raw file\n-/// descriptor.\n-pub trait FromRawFd {\n-    /// Constructs a new instance of `Self` from the given raw file\n-    /// descriptor.\n-    ///\n-    /// This function **consumes ownership** of the specified file\n-    /// descriptor. The returned object will take responsibility for closing\n-    /// it when the object goes out of scope.\n-    ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n-    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n-}\n-\n-/// A trait to express the ability to consume an object and acquire ownership of\n-/// its raw file descriptor.\n-pub trait IntoRawFd {\n-    /// Consumes this object, returning the raw underlying file descriptor.\n-    ///\n-    /// This function **transfers ownership** of the underlying file descriptor\n-    /// to the caller. Callers are then the unique owners of the file descriptor\n-    /// and must close the descriptor once it's no longer needed.\n-    fn into_raw_fd(self) -> RawFd;\n-}\n-\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl AsRawFd for RawFd {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self\n-    }\n-}\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl IntoRawFd for RawFd {\n-    #[inline]\n-    fn into_raw_fd(self) -> RawFd {\n-        self\n-    }\n-}\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl FromRawFd for RawFd {\n-    #[inline]\n-    unsafe fn from_raw_fd(fd: RawFd) -> RawFd {\n-        fd\n-    }\n-}\n-\n-impl AsRawFd for net::TcpStream {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().as_raw()\n-    }\n-}\n-\n-impl FromRawFd for net::TcpStream {\n-    #[inline]\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        net::TcpStream::from_inner(sys::net::TcpStream::from_inner(fd))\n-    }\n-}\n-\n-impl IntoRawFd for net::TcpStream {\n-    #[inline]\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-impl AsRawFd for net::TcpListener {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().as_raw()\n-    }\n-}\n-\n-impl FromRawFd for net::TcpListener {\n-    #[inline]\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        net::TcpListener::from_inner(sys::net::TcpListener::from_inner(fd))\n-    }\n-}\n-\n-impl IntoRawFd for net::TcpListener {\n-    #[inline]\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-impl AsRawFd for net::UdpSocket {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().as_raw()\n-    }\n-}\n-\n-impl FromRawFd for net::UdpSocket {\n-    #[inline]\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        net::UdpSocket::from_inner(sys::net::UdpSocket::from_inner(fd))\n-    }\n-}\n-\n-impl IntoRawFd for net::UdpSocket {\n-    #[inline]\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-impl AsRawFd for fs::File {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().as_raw()\n-    }\n-}\n-\n-impl FromRawFd for fs::File {\n-    #[inline]\n-    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-        fs::File::from_inner(sys::fs::File::from_inner(fd))\n-    }\n-}\n-\n-impl IntoRawFd for fs::File {\n-    #[inline]\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-impl AsRawFd for io::Stdin {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO\n-    }\n-}\n-\n-impl AsRawFd for io::Stdout {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO\n-    }\n-}\n-\n-impl AsRawFd for io::Stderr {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO\n-    }\n-}\n-\n-impl<'a> AsRawFd for io::StdinLock<'a> {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO\n-    }\n-}\n-\n-impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO\n-    }\n-}\n-\n-impl<'a> AsRawFd for io::StderrLock<'a> {\n-    #[inline]\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO\n-    }\n-}"}, {"sha": "930aca887e3c456ab52dda459f8b1040b793425f", "filename": "library/std/src/os/wasi/io/fd.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,9 @@\n+//! Owned and borrowed file descriptors.\n+\n+#![unstable(feature = \"wasi_ext\", issue = \"71213\")]\n+\n+// Tests for this module\n+#[cfg(test)]\n+mod tests;\n+\n+pub use crate::os::fd::owned::*;"}, {"sha": "418274752b0ad429e3ce7ec961337fe22e43ab7f", "filename": "library/std/src/os/wasi/io/fd/tests.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Ffd%2Ftests.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,11 @@\n+use crate::mem::size_of;\n+use crate::os::wasi::io::RawFd;\n+\n+#[test]\n+fn test_raw_fd_layout() {\n+    // `OwnedFd` and `BorrowedFd` use `rustc_layout_scalar_valid_range_start`\n+    // and `rustc_layout_scalar_valid_range_end`, with values that depend on\n+    // the bit width of `RawFd`. If this ever changes, those values will need\n+    // to be updated.\n+    assert_eq!(size_of::<RawFd>(), 4);\n+}"}, {"sha": "6c884e2eaf4717b7c2424ad5539efdfae5596055", "filename": "library/std/src/os/wasi/io/mod.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,12 @@\n+//! WASI-specific extensions to general I/O primitives.\n+\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![unstable(feature = \"wasi_ext\", issue = \"71213\")]\n+\n+mod fd;\n+mod raw;\n+\n+#[unstable(feature = \"wasi_ext\", issue = \"71213\")]\n+pub use fd::*;\n+#[unstable(feature = \"wasi_ext\", issue = \"71213\")]\n+pub use raw::*;"}, {"sha": "0e0c5824e340456bfbe352348ae09a8414897ea5", "filename": "library/std/src/os/wasi/io/raw.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fio%2Fraw.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,5 @@\n+//! WASI-specific extensions to general I/O primitives.\n+\n+#![unstable(feature = \"wasi_ext\", issue = \"71213\")]\n+\n+pub use crate::os::fd::raw::*;"}, {"sha": "d767c149dc5d08064f2e58cdec979ef80d1b8368", "filename": "library/std/src/os/wasi/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -32,6 +32,7 @@\n pub mod ffi;\n pub mod fs;\n pub mod io;\n+pub mod net;\n \n /// A prelude for conveniently writing platform-specific code.\n ///\n@@ -49,5 +50,5 @@ pub mod prelude {\n     pub use super::fs::{DirEntryExt, FileExt, MetadataExt, OpenOptionsExt};\n     #[doc(no_inline)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+    pub use super::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n }"}, {"sha": "e6bcf87887f036c1c99b47a2209b55369a4abfac", "filename": "library/std/src/os/wasi/net/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwasi%2Fnet%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,3 @@\n+//! WASI-specific networking functionality\n+\n+#![unstable(feature = \"wasi_ext\", issue = \"71213\")]"}, {"sha": "72a17adb3b4707b3353a63c27073c98ad43b338c", "filename": "library/std/src/os/windows/io/handle.rs", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,386 @@\n+//! Owned and borrowed OS handles.\n+\n+#![unstable(feature = \"io_safety\", issue = \"87074\")]\n+\n+use super::raw::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n+use crate::convert::TryFrom;\n+use crate::ffi::c_void;\n+use crate::fmt;\n+use crate::fs;\n+use crate::marker::PhantomData;\n+use crate::mem::forget;\n+use crate::ptr::NonNull;\n+use crate::sys::c;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// A borrowed handle.\n+///\n+/// This has a lifetime parameter to tie it to the lifetime of something that\n+/// owns the handle.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host handle,\n+/// so it can be used in FFI in places where a handle is passed as an argument,\n+/// it is not captured or consumed, and it is never null.\n+///\n+/// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n+/// sometimes a valid handle value. See [here] for the full story.\n+///\n+/// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub struct BorrowedHandle<'handle> {\n+    handle: NonNull<c_void>,\n+    _phantom: PhantomData<&'handle OwnedHandle>,\n+}\n+\n+/// An owned handle.\n+///\n+/// This closes the handle on drop.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host handle,\n+/// so it can be used in FFI in places where a handle is passed as a consumed\n+/// argument or returned as an owned value, and is never null.\n+///\n+/// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n+/// sometimes a valid handle value. See [here] for the full story. For APIs\n+/// like `CreateFileW` which report errors with `INVALID_HANDLE_VALUE` instead\n+/// of null, use [`HandleOrInvalid`] instead of `Option<OwnedHandle>`.\n+///\n+/// `OwnedHandle` uses [`CloseHandle`] to close its handle on drop. As such,\n+/// it must not be used with handles to open registry keys which need to be\n+/// closed with [`RegCloseKey`] instead.\n+///\n+/// [`CloseHandle`]: https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle\n+/// [`RegCloseKey`]: https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey\n+///\n+/// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+#[repr(transparent)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub struct OwnedHandle {\n+    handle: NonNull<c_void>,\n+}\n+\n+/// FFI type for handles in return values or out parameters, where `INVALID_HANDLE_VALUE` is used\n+/// as a sentry value to indicate errors, such as in the return value of `CreateFileW`. This uses\n+/// `repr(transparent)` and has the representation of a host handle, so that it can be used in such\n+/// FFI declarations.\n+///\n+/// The only thing you can usefully do with a `HandleOrInvalid` is to convert it into an\n+/// `OwnedHandle` using its [`TryFrom`] implementation; this conversion takes care of the check for\n+/// `INVALID_HANDLE_VALUE`. This ensures that such FFI calls cannot start using the handle without\n+/// checking for `INVALID_HANDLE_VALUE` first.\n+///\n+/// If this holds a valid handle, it will close the handle on drop.\n+#[repr(transparent)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+#[derive(Debug)]\n+pub struct HandleOrInvalid(Option<OwnedHandle>);\n+\n+// The Windows [`HANDLE`] type may be transferred across and shared between\n+// thread boundaries (despite containing a `*mut void`, which in general isn't\n+// `Send` or `Sync`).\n+//\n+// [`HANDLE`]: std::os::windows::raw::HANDLE\n+unsafe impl Send for OwnedHandle {}\n+unsafe impl Send for HandleOrInvalid {}\n+unsafe impl Send for BorrowedHandle<'_> {}\n+unsafe impl Sync for OwnedHandle {}\n+unsafe impl Sync for HandleOrInvalid {}\n+unsafe impl Sync for BorrowedHandle<'_> {}\n+\n+impl BorrowedHandle<'_> {\n+    /// Return a `BorrowedHandle` holding the given raw handle.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `handle` must be a valid open handle, it\n+    /// must remain open for the duration of the returned `BorrowedHandle`, and\n+    /// it must not be null.\n+    ///\n+    /// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n+    /// sometimes a valid handle value. See [here] for the full story.\n+    ///\n+    /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+    #[inline]\n+    #[unstable(feature = \"io_safety\", issue = \"87074\")]\n+    pub unsafe fn borrow_raw_handle(handle: RawHandle) -> Self {\n+        assert!(!handle.is_null());\n+        Self { handle: NonNull::new_unchecked(handle), _phantom: PhantomData }\n+    }\n+}\n+\n+impl TryFrom<HandleOrInvalid> for OwnedHandle {\n+    type Error = ();\n+\n+    #[inline]\n+    fn try_from(handle_or_invalid: HandleOrInvalid) -> Result<Self, ()> {\n+        // In theory, we ought to be able to assume that the pointer here is\n+        // never null, use `OwnedHandle` rather than `Option<OwnedHandle>`, and\n+        // obviate the the panic path here.  Unfortunately, Win32 documentation\n+        // doesn't explicitly guarantee this anywhere.\n+        //\n+        // APIs like [`CreateFileW`] itself have `HANDLE` arguments where a\n+        // null handle indicates an absent value, which wouldn't work if null\n+        // were a valid handle value, so it seems very unlikely that it could\n+        // ever return null. But who knows?\n+        //\n+        // [`CreateFileW`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew\n+        let owned_handle = handle_or_invalid.0.expect(\"A `HandleOrInvalid` was null!\");\n+        if owned_handle.handle.as_ptr() == c::INVALID_HANDLE_VALUE {\n+            Err(())\n+        } else {\n+            Ok(owned_handle)\n+        }\n+    }\n+}\n+\n+impl AsRawHandle for BorrowedHandle<'_> {\n+    #[inline]\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.handle.as_ptr()\n+    }\n+}\n+\n+impl AsRawHandle for OwnedHandle {\n+    #[inline]\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.handle.as_ptr()\n+    }\n+}\n+\n+impl IntoRawHandle for OwnedHandle {\n+    #[inline]\n+    fn into_raw_handle(self) -> RawHandle {\n+        let handle = self.handle.as_ptr();\n+        forget(self);\n+        handle\n+    }\n+}\n+\n+impl FromRawHandle for OwnedHandle {\n+    /// Constructs a new instance of `Self` from the given raw handle.\n+    ///\n+    /// Use `HandleOrInvalid` instead of `Option<OwnedHandle>` for APIs that\n+    /// use `INVALID_HANDLE_VALUE` to indicate failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `handle` must be open and suitable for\n+    /// assuming ownership. The resource must not require any cleanup other\n+    /// than `CloseHandle`.\n+    ///\n+    /// In particular, it must not be used with handles to open registry\n+    /// keys which need to be closed with [`RegCloseKey`] instead.\n+    ///\n+    /// Note that it *may* have the value `INVALID_HANDLE_VALUE` (-1), which is\n+    /// sometimes a valid handle value. See [here] for the full story.\n+    ///\n+    /// [`RegCloseKey`]: https://docs.microsoft.com/en-us/windows/win32/api/winreg/nf-winreg-regclosekey\n+    /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+    #[inline]\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+        assert!(!handle.is_null());\n+        Self { handle: NonNull::new_unchecked(handle) }\n+    }\n+}\n+\n+impl FromRawHandle for HandleOrInvalid {\n+    /// Constructs a new instance of `Self` from the given `RawHandle` returned\n+    /// from a Windows API that uses `INVALID_HANDLE_VALUE` to indicate\n+    /// failure, such as `CreateFileW`.\n+    ///\n+    /// Use `Option<OwnedHandle>` instead of `HandleOrInvalid` for APIs that\n+    /// use null to indicate failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `handle` must be either open and otherwise\n+    /// unowned, or equal to `INVALID_HANDLE_VALUE` (-1). It must not be null.\n+    /// Note that not all Windows APIs use `INVALID_HANDLE_VALUE` for errors;\n+    /// see [here] for the full story.\n+    ///\n+    /// [here]: https://devblogs.microsoft.com/oldnewthing/20040302-00/?p=40443\n+    #[inline]\n+    unsafe fn from_raw_handle(handle: RawHandle) -> Self {\n+        // We require non-null here to catch errors earlier.\n+        Self(Some(OwnedHandle::from_raw_handle(handle)))\n+    }\n+}\n+\n+impl Drop for OwnedHandle {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            let _ = c::CloseHandle(self.handle.as_ptr());\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for BorrowedHandle<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"BorrowedHandle\").field(\"handle\", &self.handle).finish()\n+    }\n+}\n+\n+impl fmt::Debug for OwnedHandle {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OwnedHandle\").field(\"handle\", &self.handle).finish()\n+    }\n+}\n+\n+/// A trait to borrow the handle from an underlying object.\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub trait AsHandle {\n+    /// Borrows the handle.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,no_run\n+    /// # #![feature(io_safety)]\n+    /// use std::fs::File;\n+    /// # use std::io;\n+    /// use std::os::windows::io::{AsHandle, BorrowedHandle};\n+    ///\n+    /// let mut f = File::open(\"foo.txt\")?;\n+    /// let borrowed_handle: BorrowedHandle<'_> = f.as_handle();\n+    /// # Ok::<(), io::Error>(())\n+    /// ```\n+    fn as_handle(&self) -> BorrowedHandle<'_>;\n+}\n+\n+impl AsHandle for BorrowedHandle<'_> {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        *self\n+    }\n+}\n+\n+impl AsHandle for OwnedHandle {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        // Safety: `OwnedHandle` and `BorrowedHandle` have the same validity\n+        // invariants, and the `BorrowdHandle` is bounded by the lifetime\n+        // of `&self`.\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl AsHandle for fs::File {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        self.as_inner().as_handle()\n+    }\n+}\n+\n+impl From<fs::File> for OwnedHandle {\n+    #[inline]\n+    fn from(file: fs::File) -> OwnedHandle {\n+        file.into_inner().into_inner().into_inner().into()\n+    }\n+}\n+\n+impl From<OwnedHandle> for fs::File {\n+    #[inline]\n+    fn from(owned: OwnedHandle) -> Self {\n+        Self::from_inner(FromInner::from_inner(FromInner::from_inner(owned)))\n+    }\n+}\n+\n+impl AsHandle for crate::io::Stdin {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl<'a> AsHandle for crate::io::StdinLock<'a> {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl AsHandle for crate::io::Stdout {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl<'a> AsHandle for crate::io::StdoutLock<'a> {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl AsHandle for crate::io::Stderr {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl<'a> AsHandle for crate::io::StderrLock<'a> {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl AsHandle for crate::process::ChildStdin {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl From<crate::process::ChildStdin> for OwnedHandle {\n+    #[inline]\n+    fn from(child_stdin: crate::process::ChildStdin) -> OwnedHandle {\n+        unsafe { OwnedHandle::from_raw_handle(child_stdin.into_raw_handle()) }\n+    }\n+}\n+\n+impl AsHandle for crate::process::ChildStdout {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl From<crate::process::ChildStdout> for OwnedHandle {\n+    #[inline]\n+    fn from(child_stdout: crate::process::ChildStdout) -> OwnedHandle {\n+        unsafe { OwnedHandle::from_raw_handle(child_stdout.into_raw_handle()) }\n+    }\n+}\n+\n+impl AsHandle for crate::process::ChildStderr {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl From<crate::process::ChildStderr> for OwnedHandle {\n+    #[inline]\n+    fn from(child_stderr: crate::process::ChildStderr) -> OwnedHandle {\n+        unsafe { OwnedHandle::from_raw_handle(child_stderr.into_raw_handle()) }\n+    }\n+}\n+\n+impl<T> AsHandle for crate::thread::JoinHandle<T> {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        unsafe { BorrowedHandle::borrow_raw_handle(self.as_raw_handle()) }\n+    }\n+}\n+\n+impl<T> From<crate::thread::JoinHandle<T>> for OwnedHandle {\n+    #[inline]\n+    fn from(join_handle: crate::thread::JoinHandle<T>) -> OwnedHandle {\n+        join_handle.into_inner().into_handle().into_inner()\n+    }\n+}"}, {"sha": "2f6f0769548091ac6f74e1ee771e1bee3047cbfd", "filename": "library/std/src/os/windows/io/mod.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,56 @@\n+//! Windows-specific extensions to general I/O primitives.\n+//!\n+//! Just like raw pointers, raw Windows handles and sockets point to resources\n+//! with dynamic lifetimes, and they can dangle if they outlive their resources\n+//! or be forged if they're created from invalid values.\n+//!\n+//! This module provides three types for representing raw handles and sockets\n+//! with different ownership properties: raw, borrowed, and owned, which are\n+//! analogous to types used for representing pointers:\n+//!\n+//! | Type                   | Analogous to |\n+//! | ---------------------- | ------------ |\n+//! | [`RawHandle`]          | `*const _`   |\n+//! | [`RawSocket`]          | `*const _`   |\n+//! |                        |              |\n+//! | [`BorrowedHandle<'a>`] | `&'a _`      |\n+//! | [`BorrowedSocket<'a>`] | `&'a _`      |\n+//! |                        |              |\n+//! | [`OwnedHandle`]        | `Box<_>`     |\n+//! | [`OwnedSocket`]        | `Box<_>`     |\n+//!\n+//! Like raw pointers, `RawHandle` and `RawSocket` values are primitive values.\n+//! And in new code, they should be considered unsafe to do I/O on (analogous\n+//! to dereferencing them). Rust did not always provide this guidance, so\n+//! existing code in the Rust ecosystem often doesn't mark `RawHandle` and\n+//! `RawSocket` usage as unsafe. Once the `io_safety` feature is stable,\n+//! libraries will be encouraged to migrate, either by adding `unsafe` to APIs\n+//! that dereference `RawHandle` and `RawSocket` values, or by using to\n+//! `BorrowedHandle`, `BorrowedSocket`, `OwnedHandle`, or `OwnedSocket`.\n+//!\n+//! Like references, `BorrowedHandle` and `BorrowedSocket` values are tied to a\n+//! lifetime, to ensure that they don't outlive the resource they point to.\n+//! These are safe to use. `BorrowedHandle` and `BorrowedSocket` values may be\n+//! used in APIs which provide safe access to any system call except for\n+//! `CloseHandle`, `closesocket`, or any other call that would end the\n+//! dynamic lifetime of the resource without ending the lifetime of the\n+//! handle or socket.\n+//!\n+//! Like boxes, `OwnedHandle` and `OwnedSocket` values conceptually own the\n+//! resource they point to, and free (close) it when they are dropped.\n+//!\n+//! [`BorrowedHandle<'a>`]: crate::os::windows::io::BorrowedHandle\n+//! [`BorrowedSocket<'a>`]: crate::os::windows::io::BorrowedSocket\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+mod handle;\n+mod raw;\n+mod socket;\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub use handle::*;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use raw::*;\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub use socket::*;"}, {"sha": "c7f122048a198285d139fbb8e3cab89bba222acf", "filename": "library/std/src/os/windows/io/raw.rs", "status": "renamed", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -5,6 +5,7 @@\n use crate::fs;\n use crate::io;\n use crate::net;\n+use crate::os::windows::io::{OwnedHandle, OwnedSocket};\n use crate::os::windows::raw;\n use crate::sys;\n use crate::sys::c;\n@@ -61,7 +62,7 @@ pub trait IntoRawHandle {\n impl AsRawHandle for fs::File {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.as_inner().handle().raw() as RawHandle\n+        self.as_inner().as_raw_handle() as RawHandle\n     }\n }\n \n@@ -112,15 +113,17 @@ impl FromRawHandle for fs::File {\n     #[inline]\n     unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n         let handle = handle as c::HANDLE;\n-        fs::File::from_inner(sys::fs::File::from_inner(handle))\n+        fs::File::from_inner(sys::fs::File::from_inner(FromInner::from_inner(\n+            OwnedHandle::from_raw_handle(handle),\n+        )))\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawHandle for fs::File {\n     #[inline]\n     fn into_raw_handle(self) -> RawHandle {\n-        self.into_inner().into_handle().into_raw() as *mut _\n+        self.into_inner().into_raw_handle() as *mut _\n     }\n }\n \n@@ -166,45 +169,45 @@ pub trait IntoRawSocket {\n impl AsRawSocket for net::TcpStream {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {\n-        *self.as_inner().socket().as_inner()\n+        self.as_inner().socket().as_raw_socket()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawSocket for net::TcpListener {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {\n-        *self.as_inner().socket().as_inner()\n+        self.as_inner().socket().as_raw_socket()\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRawSocket for net::UdpSocket {\n     #[inline]\n     fn as_raw_socket(&self) -> RawSocket {\n-        *self.as_inner().socket().as_inner()\n+        self.as_inner().socket().as_raw_socket()\n     }\n }\n \n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawSocket for net::TcpStream {\n     #[inline]\n     unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n-        let sock = sys::net::Socket::from_inner(sock);\n+        let sock = sys::net::Socket::from_inner(OwnedSocket::from_raw_socket(sock));\n         net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(sock))\n     }\n }\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawSocket for net::TcpListener {\n     #[inline]\n     unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n-        let sock = sys::net::Socket::from_inner(sock);\n+        let sock = sys::net::Socket::from_inner(OwnedSocket::from_raw_socket(sock));\n         net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(sock))\n     }\n }\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawSocket for net::UdpSocket {\n     #[inline]\n     unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n-        let sock = sys::net::Socket::from_inner(sock);\n+        let sock = sys::net::Socket::from_inner(OwnedSocket::from_raw_socket(sock));\n         net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(sock))\n     }\n }\n@@ -213,22 +216,22 @@ impl FromRawSocket for net::UdpSocket {\n impl IntoRawSocket for net::TcpStream {\n     #[inline]\n     fn into_raw_socket(self) -> RawSocket {\n-        self.into_inner().into_socket().into_inner()\n+        self.into_inner().into_socket().into_inner().into_raw_socket()\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawSocket for net::TcpListener {\n     #[inline]\n     fn into_raw_socket(self) -> RawSocket {\n-        self.into_inner().into_socket().into_inner()\n+        self.into_inner().into_socket().into_inner().into_raw_socket()\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawSocket for net::UdpSocket {\n     #[inline]\n     fn into_raw_socket(self) -> RawSocket {\n-        self.into_inner().into_socket().into_inner()\n+        self.into_inner().into_socket().into_inner().into_raw_socket()\n     }\n }", "previous_filename": "library/std/src/os/windows/io.rs"}, {"sha": "23db66df09f7aff203e720de38a38869fc436ef2", "filename": "library/std/src/os/windows/io/socket.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -0,0 +1,216 @@\n+//! Owned and borrowed OS sockets.\n+\n+#![unstable(feature = \"io_safety\", issue = \"87074\")]\n+\n+use super::raw::{AsRawSocket, FromRawSocket, IntoRawSocket, RawSocket};\n+use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::mem::forget;\n+use crate::sys::c;\n+\n+/// A borrowed socket.\n+///\n+/// This has a lifetime parameter to tie it to the lifetime of something that\n+/// owns the socket.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host socket,\n+/// so it can be used in FFI in places where a socket is passed as an argument,\n+/// it is not captured or consumed, and it never has the value\n+/// `INVALID_SOCKET`.\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// This is -2, in two's complement. -1 is `INVALID_SOCKET`.\n+#[cfg_attr(target_pointer_width = \"32\", rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE))]\n+#[cfg_attr(\n+    target_pointer_width = \"64\",\n+    rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FF_FF_FF_FF_FE)\n+)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub struct BorrowedSocket<'socket> {\n+    socket: RawSocket,\n+    _phantom: PhantomData<&'socket OwnedSocket>,\n+}\n+\n+/// An owned socket.\n+///\n+/// This closes the socket on drop.\n+///\n+/// This uses `repr(transparent)` and has the representation of a host socket,\n+/// so it can be used in FFI in places where a socket is passed as a consumed\n+/// argument or returned as an owned value, and it never has the value\n+/// `INVALID_SOCKET`.\n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(0)]\n+// This is -2, in two's complement. -1 is `INVALID_SOCKET`.\n+#[cfg_attr(target_pointer_width = \"32\", rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE))]\n+#[cfg_attr(\n+    target_pointer_width = \"64\",\n+    rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FF_FF_FF_FF_FE)\n+)]\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub struct OwnedSocket {\n+    socket: RawSocket,\n+}\n+\n+impl BorrowedSocket<'_> {\n+    /// Return a `BorrowedSocket` holding the given raw socket.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `raw` must remain open for the duration of\n+    /// the returned `BorrowedSocket`, and it must not have the value\n+    /// `INVALID_SOCKET`.\n+    #[inline]\n+    #[unstable(feature = \"io_safety\", issue = \"87074\")]\n+    pub unsafe fn borrow_raw_socket(socket: RawSocket) -> Self {\n+        debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);\n+        Self { socket, _phantom: PhantomData }\n+    }\n+}\n+\n+impl AsRawSocket for BorrowedSocket<'_> {\n+    #[inline]\n+    fn as_raw_socket(&self) -> RawSocket {\n+        self.socket\n+    }\n+}\n+\n+impl AsRawSocket for OwnedSocket {\n+    #[inline]\n+    fn as_raw_socket(&self) -> RawSocket {\n+        self.socket\n+    }\n+}\n+\n+impl IntoRawSocket for OwnedSocket {\n+    #[inline]\n+    fn into_raw_socket(self) -> RawSocket {\n+        let socket = self.socket;\n+        forget(self);\n+        socket\n+    }\n+}\n+\n+impl FromRawSocket for OwnedSocket {\n+    /// Constructs a new instance of `Self` from the given raw socket.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The resource pointed to by `socket` must be open and suitable for\n+    /// assuming ownership. The resource must not require cleanup other than\n+    /// `closesocket`.\n+    #[inline]\n+    unsafe fn from_raw_socket(socket: RawSocket) -> Self {\n+        debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);\n+        Self { socket }\n+    }\n+}\n+\n+impl Drop for OwnedSocket {\n+    #[inline]\n+    fn drop(&mut self) {\n+        unsafe {\n+            let _ = c::closesocket(self.socket);\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for BorrowedSocket<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"BorrowedSocket\").field(\"socket\", &self.socket).finish()\n+    }\n+}\n+\n+impl fmt::Debug for OwnedSocket {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OwnedSocket\").field(\"socket\", &self.socket).finish()\n+    }\n+}\n+\n+/// A trait to borrow the socket from an underlying object.\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+pub trait AsSocket {\n+    /// Borrows the socket.\n+    fn as_socket(&self) -> BorrowedSocket<'_>;\n+}\n+\n+impl AsSocket for BorrowedSocket<'_> {\n+    #[inline]\n+    fn as_socket(&self) -> BorrowedSocket<'_> {\n+        *self\n+    }\n+}\n+\n+impl AsSocket for OwnedSocket {\n+    #[inline]\n+    fn as_socket(&self) -> BorrowedSocket<'_> {\n+        // Safety: `OwnedSocket` and `BorrowedSocket` have the same validity\n+        // invariants, and the `BorrowdSocket` is bounded by the lifetime\n+        // of `&self`.\n+        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+    }\n+}\n+\n+impl AsSocket for crate::net::TcpStream {\n+    #[inline]\n+    fn as_socket(&self) -> BorrowedSocket<'_> {\n+        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+    }\n+}\n+\n+impl From<crate::net::TcpStream> for OwnedSocket {\n+    #[inline]\n+    fn from(tcp_stream: crate::net::TcpStream) -> OwnedSocket {\n+        unsafe { OwnedSocket::from_raw_socket(tcp_stream.into_raw_socket()) }\n+    }\n+}\n+\n+impl From<OwnedSocket> for crate::net::TcpStream {\n+    #[inline]\n+    fn from(owned: OwnedSocket) -> Self {\n+        unsafe { Self::from_raw_socket(owned.into_raw_socket()) }\n+    }\n+}\n+\n+impl AsSocket for crate::net::TcpListener {\n+    #[inline]\n+    fn as_socket(&self) -> BorrowedSocket<'_> {\n+        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+    }\n+}\n+\n+impl From<crate::net::TcpListener> for OwnedSocket {\n+    #[inline]\n+    fn from(tcp_listener: crate::net::TcpListener) -> OwnedSocket {\n+        unsafe { OwnedSocket::from_raw_socket(tcp_listener.into_raw_socket()) }\n+    }\n+}\n+\n+impl From<OwnedSocket> for crate::net::TcpListener {\n+    #[inline]\n+    fn from(owned: OwnedSocket) -> Self {\n+        unsafe { Self::from_raw_socket(owned.into_raw_socket()) }\n+    }\n+}\n+\n+impl AsSocket for crate::net::UdpSocket {\n+    #[inline]\n+    fn as_socket(&self) -> BorrowedSocket<'_> {\n+        unsafe { BorrowedSocket::borrow_raw_socket(self.as_raw_socket()) }\n+    }\n+}\n+\n+impl From<crate::net::UdpSocket> for OwnedSocket {\n+    #[inline]\n+    fn from(udp_socket: crate::net::UdpSocket) -> OwnedSocket {\n+        unsafe { OwnedSocket::from_raw_socket(udp_socket.into_raw_socket()) }\n+    }\n+}\n+\n+impl From<OwnedSocket> for crate::net::UdpSocket {\n+    #[inline]\n+    fn from(owned: OwnedSocket) -> Self {\n+        unsafe { Self::from_raw_socket(owned.into_raw_socket()) }\n+    }\n+}"}, {"sha": "969054dd3b3dcc8a72f37dbcf95a14e8de8369fd", "filename": "library/std/src/os/windows/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fmod.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -32,8 +32,11 @@ pub mod prelude {\n     pub use super::fs::{MetadataExt, OpenOptionsExt};\n     #[doc(no_inline)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{AsRawHandle, AsRawSocket, RawHandle, RawSocket};\n+    pub use super::io::{\n+        AsHandle, AsSocket, BorrowedHandle, BorrowedSocket, FromRawHandle, FromRawSocket,\n+        HandleOrInvalid, IntoRawHandle, IntoRawSocket, OwnedHandle, OwnedSocket,\n+    };\n     #[doc(no_inline)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{FromRawHandle, FromRawSocket, IntoRawHandle, IntoRawSocket};\n+    pub use super::io::{AsRawHandle, AsRawSocket, RawHandle, RawSocket};\n }"}, {"sha": "b246599dfc0a9d986c7f3f7b11e469c7b08965af", "filename": "library/std/src/os/windows/process.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fprocess.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -3,7 +3,9 @@\n #![stable(feature = \"process_extensions\", since = \"1.2.0\")]\n \n use crate::ffi::OsStr;\n-use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle, RawHandle};\n+use crate::os::windows::io::{\n+    AsHandle, AsRawHandle, BorrowedHandle, FromRawHandle, IntoRawHandle, OwnedHandle, RawHandle,\n+};\n use crate::process;\n use crate::sealed::Sealed;\n use crate::sys;\n@@ -12,7 +14,16 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl FromRawHandle for process::Stdio {\n     unsafe fn from_raw_handle(handle: RawHandle) -> process::Stdio {\n-        let handle = sys::handle::Handle::new(handle as *mut _);\n+        let handle = sys::handle::Handle::from_raw_handle(handle as *mut _);\n+        let io = sys::process::Stdio::Handle(handle);\n+        process::Stdio::from_inner(io)\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<OwnedHandle> for process::Stdio {\n+    fn from(handle: OwnedHandle) -> process::Stdio {\n+        let handle = sys::handle::Handle::from_inner(handle);\n         let io = sys::process::Stdio::Handle(handle);\n         process::Stdio::from_inner(io)\n     }\n@@ -22,59 +33,74 @@ impl FromRawHandle for process::Stdio {\n impl AsRawHandle for process::Child {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.as_inner().handle().raw() as *mut _\n+        self.as_inner().handle().as_raw_handle() as *mut _\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsHandle for process::Child {\n+    #[inline]\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        self.as_inner().handle().as_handle()\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawHandle for process::Child {\n     fn into_raw_handle(self) -> RawHandle {\n-        self.into_inner().into_handle().into_raw() as *mut _\n+        self.into_inner().into_handle().into_raw_handle() as *mut _\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl From<process::Child> for OwnedHandle {\n+    fn from(child: process::Child) -> OwnedHandle {\n+        child.into_inner().into_handle().into_inner()\n     }\n }\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl AsRawHandle for process::ChildStdin {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.as_inner().handle().raw() as *mut _\n+        self.as_inner().handle().as_raw_handle() as *mut _\n     }\n }\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl AsRawHandle for process::ChildStdout {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.as_inner().handle().raw() as *mut _\n+        self.as_inner().handle().as_raw_handle() as *mut _\n     }\n }\n \n #[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n impl AsRawHandle for process::ChildStderr {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.as_inner().handle().raw() as *mut _\n+        self.as_inner().handle().as_raw_handle() as *mut _\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawHandle for process::ChildStdin {\n     fn into_raw_handle(self) -> RawHandle {\n-        self.into_inner().into_handle().into_raw() as *mut _\n+        self.into_inner().into_handle().into_raw_handle() as *mut _\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawHandle for process::ChildStdout {\n     fn into_raw_handle(self) -> RawHandle {\n-        self.into_inner().into_handle().into_raw() as *mut _\n+        self.into_inner().into_handle().into_raw_handle() as *mut _\n     }\n }\n \n #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n impl IntoRawHandle for process::ChildStderr {\n     fn into_raw_handle(self) -> RawHandle {\n-        self.into_inner().into_handle().into_raw() as *mut _\n+        self.into_inner().into_handle().into_raw_handle() as *mut _\n     }\n }\n "}, {"sha": "fb1bf66ceed356aa1da457a24d3f3171dcda9d1a", "filename": "library/std/src/os/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fthread.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -10,14 +10,14 @@ use crate::thread;\n impl<T> AsRawHandle for thread::JoinHandle<T> {\n     #[inline]\n     fn as_raw_handle(&self) -> RawHandle {\n-        self.as_inner().handle().raw() as *mut _\n+        self.as_inner().handle().as_raw_handle() as *mut _\n     }\n }\n \n #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n impl<T> IntoRawHandle for thread::JoinHandle<T> {\n     #[inline]\n     fn into_raw_handle(self) -> RawHandle {\n-        self.into_inner().into_handle().into_raw() as *mut _\n+        self.into_inner().into_handle().into_raw_handle() as *mut _\n     }\n }"}, {"sha": "c9b21fcf9c6d2eef7a2a006e6e3a65082d634f51", "filename": "library/std/src/process.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -258,6 +258,12 @@ pub struct ChildStdin {\n     inner: AnonPipe,\n }\n \n+// In addition to the `impl`s here, `ChildStdin` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and\n+// `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.\n+\n #[stable(feature = \"process\", since = \"1.0.0\")]\n impl Write for ChildStdin {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n@@ -335,6 +341,12 @@ pub struct ChildStdout {\n     inner: AnonPipe,\n }\n \n+// In addition to the `impl`s here, `ChildStdout` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and\n+// `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.\n+\n #[stable(feature = \"process\", since = \"1.0.0\")]\n impl Read for ChildStdout {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -396,6 +408,12 @@ pub struct ChildStderr {\n     inner: AnonPipe,\n }\n \n+// In addition to the `impl`s here, `ChildStderr` also has `impl`s for\n+// `AsFd`/`From<OwnedFd>`/`Into<OwnedFd>` and\n+// `AsRawFd`/`IntoRawFd`/`FromRawFd`, on Unix and WASI, and\n+// `AsHandle`/`From<OwnedHandle>`/`Into<OwnedHandle>` and\n+// `AsRawHandle`/`IntoRawHandle`/`FromRawHandle` on Windows.\n+\n #[stable(feature = \"process\", since = \"1.0.0\")]\n impl Read for ChildStderr {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {"}, {"sha": "0956726084e02a21f7783841e7ec17bea3faa973", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 62, "deletions": 53, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -5,21 +5,14 @@ mod tests;\n \n use crate::cmp;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n-use crate::mem;\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::sys::cvt;\n-use crate::sys_common::AsInner;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n use libc::{c_int, c_void};\n \n #[derive(Debug)]\n-#[rustc_layout_scalar_valid_range_start(0)]\n-// libstd/os/raw/mod.rs assures me that every libstd-supported platform has a\n-// 32-bit c_int. Below is -2, in two's complement, but that only works out\n-// because c_int is 32 bits.\n-#[rustc_layout_scalar_valid_range_end(0xFF_FF_FF_FE)]\n-pub struct FileDesc {\n-    fd: c_int,\n-}\n+pub struct FileDesc(OwnedFd);\n \n // The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n // with the man page quoting that if the count of bytes to read is\n@@ -67,26 +60,13 @@ const fn max_iov() -> usize {\n }\n \n impl FileDesc {\n-    pub fn new(fd: c_int) -> FileDesc {\n-        assert_ne!(fd, -1i32);\n-        // SAFETY: we just asserted that the value is in the valid range and isn't `-1` (the only value bigger than `0xFF_FF_FF_FE` unsigned)\n-        unsafe { FileDesc { fd } }\n-    }\n-\n-    pub fn raw(&self) -> c_int {\n-        self.fd\n-    }\n-\n-    /// Extracts the actual file descriptor without closing it.\n-    pub fn into_raw(self) -> c_int {\n-        let fd = self.fd;\n-        mem::forget(self);\n-        fd\n-    }\n-\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n+            libc::read(\n+                self.as_raw_fd(),\n+                buf.as_mut_ptr() as *mut c_void,\n+                cmp::min(buf.len(), READ_LIMIT),\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -95,7 +75,7 @@ impl FileDesc {\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::readv(\n-                self.fd,\n+                self.as_raw_fd(),\n                 bufs.as_ptr() as *const libc::iovec,\n                 cmp::min(bufs.len(), max_iov()) as c_int,\n             )\n@@ -138,7 +118,7 @@ impl FileDesc {\n \n         unsafe {\n             cvt_pread64(\n-                self.fd,\n+                self.as_raw_fd(),\n                 buf.as_mut_ptr() as *mut c_void,\n                 cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n@@ -149,7 +129,11 @@ impl FileDesc {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n+            libc::write(\n+                self.as_raw_fd(),\n+                buf.as_ptr() as *const c_void,\n+                cmp::min(buf.len(), READ_LIMIT),\n+            )\n         })?;\n         Ok(ret as usize)\n     }\n@@ -158,7 +142,7 @@ impl FileDesc {\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::writev(\n-                self.fd,\n+                self.as_raw_fd(),\n                 bufs.as_ptr() as *const libc::iovec,\n                 cmp::min(bufs.len(), max_iov()) as c_int,\n             )\n@@ -196,7 +180,7 @@ impl FileDesc {\n \n         unsafe {\n             cvt_pwrite64(\n-                self.fd,\n+                self.as_raw_fd(),\n                 buf.as_ptr() as *const c_void,\n                 cmp::min(buf.len(), READ_LIMIT),\n                 offset as i64,\n@@ -207,7 +191,7 @@ impl FileDesc {\n \n     #[cfg(target_os = \"linux\")]\n     pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n+        unsafe { Ok((cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n     }\n \n     #[cfg(not(any(\n@@ -224,7 +208,7 @@ impl FileDesc {\n     )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n-            cvt(libc::ioctl(self.fd, libc::FIOCLEX))?;\n+            cvt(libc::ioctl(self.as_raw_fd(), libc::FIOCLEX))?;\n             Ok(())\n         }\n     }\n@@ -242,10 +226,10 @@ impl FileDesc {\n     ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n-            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n+            let previous = cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFD))?;\n             let new = previous | libc::FD_CLOEXEC;\n             if new != previous {\n-                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n+                cvt(libc::fcntl(self.as_raw_fd(), libc::F_SETFD, new))?;\n             }\n             Ok(())\n         }\n@@ -261,22 +245,22 @@ impl FileDesc {\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         unsafe {\n             let v = nonblocking as c_int;\n-            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n+            cvt(libc::ioctl(self.as_raw_fd(), libc::FIONBIO, &v))?;\n             Ok(())\n         }\n     }\n \n     #[cfg(not(target_os = \"linux\"))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         unsafe {\n-            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFL))?;\n+            let previous = cvt(libc::fcntl(self.as_raw_fd(), libc::F_GETFL))?;\n             let new = if nonblocking {\n                 previous | libc::O_NONBLOCK\n             } else {\n                 previous & !libc::O_NONBLOCK\n             };\n             if new != previous {\n-                cvt(libc::fcntl(self.fd, libc::F_SETFL, new))?;\n+                cvt(libc::fcntl(self.as_raw_fd(), libc::F_SETFL, new))?;\n             }\n             Ok(())\n         }\n@@ -296,8 +280,8 @@ impl FileDesc {\n         #[cfg(target_os = \"espidf\")]\n         let cmd = libc::F_DUPFD;\n \n-        let fd = cvt(unsafe { libc::fcntl(self.raw(), cmd, 0) })?;\n-        Ok(FileDesc::new(fd))\n+        let fd = cvt(unsafe { libc::fcntl(self.as_raw_fd(), cmd, 0) })?;\n+        Ok(unsafe { FileDesc::from_raw_fd(fd) })\n     }\n }\n \n@@ -312,19 +296,44 @@ impl<'a> Read for &'a FileDesc {\n     }\n }\n \n-impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int {\n-        &self.fd\n+impl AsInner<OwnedFd> for FileDesc {\n+    fn as_inner(&self) -> &OwnedFd {\n+        &self.0\n+    }\n+}\n+\n+impl IntoInner<OwnedFd> for FileDesc {\n+    fn into_inner(self) -> OwnedFd {\n+        self.0\n+    }\n+}\n+\n+impl FromInner<OwnedFd> for FileDesc {\n+    fn from_inner(owned_fd: OwnedFd) -> Self {\n+        Self(owned_fd)\n+    }\n+}\n+\n+impl AsFd for FileDesc {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for FileDesc {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for FileDesc {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n     }\n }\n \n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // Note that errors are ignored when closing a file descriptor. The\n-        // reason for this is that if an error occurs we don't actually know if\n-        // the file descriptor was closed or not, and if we retried (for\n-        // something like EINTR), we might close another valid file descriptor\n-        // opened after we closed ours.\n-        let _ = unsafe { libc::close(self.fd) };\n+impl FromRawFd for FileDesc {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self(FromRawFd::from_raw_fd(raw_fd))\n     }\n }"}, {"sha": "5d17e46786c79d05972ab5a2827a8598496ed449", "filename": "library/std/src/sys/unix/fd/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd%2Ftests.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,9 +1,10 @@\n use super::{FileDesc, IoSlice};\n+use crate::os::unix::io::FromRawFd;\n use core::mem::ManuallyDrop;\n \n #[test]\n fn limit_vector_count() {\n-    let stdout = ManuallyDrop::new(unsafe { FileDesc { fd: 1 } });\n+    let stdout = ManuallyDrop::new(unsafe { FileDesc::from_raw_fd(1) });\n     let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n     assert!(stdout.write_vectored(&bufs).is_ok());\n }"}, {"sha": "6075eb5c7c58a73266fae59326a7bdfc6605793c", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -4,13 +4,14 @@ use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n use crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n use crate::sys::fd::FileDesc;\n use crate::sys::time::SystemTime;\n use crate::sys::{cvt, cvt_r};\n-use crate::sys_common::{AsInner, FromInner};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n #[cfg(any(\n     all(target_os = \"linux\", target_env = \"gnu\"),\n@@ -764,11 +765,11 @@ impl File {\n         // However, since this is a variadic function, C integer promotion rules mean that on\n         // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n         let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n-        Ok(File(FileDesc::new(fd)))\n+        Ok(File(unsafe { FileDesc::from_raw_fd(fd) }))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let fd = self.0.raw();\n+        let fd = self.as_raw_fd();\n \n         cfg_has_statx! {\n             if let Some(ret) = unsafe { try_statx(\n@@ -787,7 +788,7 @@ impl File {\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { os_fsync(self.0.raw()) })?;\n+        cvt_r(|| unsafe { os_fsync(self.as_raw_fd()) })?;\n         return Ok(());\n \n         #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -801,7 +802,7 @@ impl File {\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n+        cvt_r(|| unsafe { os_datasync(self.as_raw_fd()) })?;\n         return Ok(());\n \n         #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -834,14 +835,14 @@ impl File {\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n         #[cfg(target_os = \"android\")]\n-        return crate::sys::android::ftruncate64(self.0.raw(), size);\n+        return crate::sys::android::ftruncate64(self.as_raw_fd(), size);\n \n         #[cfg(not(target_os = \"android\"))]\n         {\n             use crate::convert::TryInto;\n             let size: off64_t =\n                 size.try_into().map_err(|e| io::Error::new(io::ErrorKind::InvalidInput, e))?;\n-            cvt_r(|| unsafe { ftruncate64(self.0.raw(), size) }).map(drop)\n+            cvt_r(|| unsafe { ftruncate64(self.as_raw_fd(), size) }).map(drop)\n         }\n     }\n \n@@ -891,24 +892,16 @@ impl File {\n             SeekFrom::End(off) => (libc::SEEK_END, off),\n             SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n         };\n-        let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n+        let n = cvt(unsafe { lseek64(self.as_raw_fd(), pos, whence) })?;\n         Ok(n as u64)\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n         self.0.duplicate().map(File)\n     }\n \n-    pub fn fd(&self) -> &FileDesc {\n-        &self.0\n-    }\n-\n-    pub fn into_fd(self) -> FileDesc {\n-        self.0\n-    }\n-\n     pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n-        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n+        cvt_r(|| unsafe { libc::fchmod(self.as_raw_fd(), perm.mode) })?;\n         Ok(())\n     }\n }\n@@ -933,9 +926,51 @@ fn cstr(path: &Path) -> io::Result<CString> {\n     Ok(CString::new(path.as_os_str().as_bytes())?)\n }\n \n-impl FromInner<c_int> for File {\n-    fn from_inner(fd: c_int) -> File {\n-        File(FileDesc::new(fd))\n+impl AsInner<FileDesc> for File {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.0\n+    }\n+}\n+\n+impl AsInnerMut<FileDesc> for File {\n+    fn as_inner_mut(&mut self) -> &mut FileDesc {\n+        &mut self.0\n+    }\n+}\n+\n+impl IntoInner<FileDesc> for File {\n+    fn into_inner(self) -> FileDesc {\n+        self.0\n+    }\n+}\n+\n+impl FromInner<FileDesc> for File {\n+    fn from_inner(file_desc: FileDesc) -> Self {\n+        Self(file_desc)\n+    }\n+}\n+\n+impl AsFd for File {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n+    }\n+}\n+\n+impl FromRawFd for File {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self(FromRawFd::from_raw_fd(raw_fd))\n     }\n }\n \n@@ -1009,7 +1044,7 @@ impl fmt::Debug for File {\n             None\n         }\n \n-        let fd = self.0.raw();\n+        let fd = self.as_raw_fd();\n         let mut b = f.debug_struct(\"File\");\n         b.field(\"fd\", &fd);\n         if let Some(path) = get_path(fd) {"}, {"sha": "c2f5da1dbbb1180cb785cf6691709172a6a065b2", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 62, "deletions": 30, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -3,6 +3,7 @@ use crate::ffi::CStr;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::str;\n use crate::sys::fd::FileDesc;\n use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n@@ -74,10 +75,10 @@ impl Socket {\n                     // flag to atomically create the socket and set it as\n                     // CLOEXEC. On Linux this was added in 2.6.27.\n                     let fd = cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0))?;\n-                    Ok(Socket(FileDesc::new(fd)))\n+                    Ok(Socket(FileDesc::from_raw_fd(fd)))\n                 } else {\n                     let fd = cvt(libc::socket(fam, ty, 0))?;\n-                    let fd = FileDesc::new(fd);\n+                    let fd = FileDesc::from_raw_fd(fd);\n                     fd.set_cloexec()?;\n                     let socket = Socket(fd);\n \n@@ -109,11 +110,11 @@ impl Socket {\n                 ))] {\n                     // Like above, set cloexec atomically\n                     cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr()))?;\n-                    Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))))\n+                    Ok((Socket(FileDesc::from_raw_fd(fds[0])), Socket(FileDesc::from_raw_fd(fds[1]))))\n                 } else {\n                     cvt(libc::socketpair(fam, ty, 0, fds.as_mut_ptr()))?;\n-                    let a = FileDesc::new(fds[0]);\n-                    let b = FileDesc::new(fds[1]);\n+                    let a = FileDesc::from_raw_fd(fds[0]);\n+                    let b = FileDesc::from_raw_fd(fds[1]);\n                     a.set_cloexec()?;\n                     b.set_cloexec()?;\n                     Ok((Socket(a), Socket(b)))\n@@ -131,7 +132,7 @@ impl Socket {\n         self.set_nonblocking(true)?;\n         let r = unsafe {\n             let (addrp, len) = addr.into_inner();\n-            cvt(libc::connect(self.0.raw(), addrp, len))\n+            cvt(libc::connect(self.as_raw_fd(), addrp, len))\n         };\n         self.set_nonblocking(false)?;\n \n@@ -142,7 +143,7 @@ impl Socket {\n             Err(e) => return Err(e),\n         }\n \n-        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n+        let mut pollfd = libc::pollfd { fd: self.as_raw_fd(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n             return Err(io::Error::new_const(\n@@ -212,15 +213,17 @@ impl Socket {\n                 target_os = \"netbsd\",\n                 target_os = \"openbsd\",\n             ))] {\n-                let fd = cvt_r(|| unsafe {\n-                    libc::accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC)\n-                })?;\n-                Ok(Socket(FileDesc::new(fd)))\n+                unsafe {\n+                    let fd = cvt_r(|| libc::accept4(self.as_raw_fd(), storage, len, libc::SOCK_CLOEXEC))?;\n+                    Ok(Socket(FileDesc::from_raw_fd(fd)))\n+                }\n             } else {\n-                let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n-                let fd = FileDesc::new(fd);\n-                fd.set_cloexec()?;\n-                Ok(Socket(fd))\n+                unsafe {\n+                    let fd = cvt_r(|| libc::accept(self.as_raw_fd(), storage, len))?;\n+                    let fd = FileDesc::from_raw_fd(fd);\n+                    fd.set_cloexec()?;\n+                    Ok(Socket(fd))\n+                }\n             }\n         }\n     }\n@@ -231,7 +234,7 @@ impl Socket {\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n+            libc::recv(self.as_raw_fd(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -263,7 +266,7 @@ impl Socket {\n \n         let n = cvt(unsafe {\n             libc::recvfrom(\n-                self.0.raw(),\n+                self.as_raw_fd(),\n                 buf.as_mut_ptr() as *mut c_void,\n                 buf.len(),\n                 flags,\n@@ -288,7 +291,7 @@ impl Socket {\n         target_os = \"openbsd\",\n     ))]\n     pub fn recv_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n-        let n = cvt(unsafe { libc::recvmsg(self.0.raw(), msg, libc::MSG_CMSG_CLOEXEC) })?;\n+        let n = cvt(unsafe { libc::recvmsg(self.as_raw_fd(), msg, libc::MSG_CMSG_CLOEXEC) })?;\n         Ok(n as usize)\n     }\n \n@@ -319,7 +322,7 @@ impl Socket {\n         target_os = \"openbsd\",\n     ))]\n     pub fn send_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n-        let n = cvt(unsafe { libc::sendmsg(self.0.raw(), msg, 0) })?;\n+        let n = cvt(unsafe { libc::sendmsg(self.as_raw_fd(), msg, 0) })?;\n         Ok(n as usize)\n     }\n \n@@ -369,7 +372,7 @@ impl Socket {\n             Shutdown::Read => libc::SHUT_RD,\n             Shutdown::Both => libc::SHUT_RDWR,\n         };\n-        cvt(unsafe { libc::shutdown(self.0.raw(), how) })?;\n+        cvt(unsafe { libc::shutdown(self.as_raw_fd(), how) })?;\n         Ok(())\n     }\n \n@@ -396,7 +399,7 @@ impl Socket {\n     #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as libc::c_int;\n-        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(drop)\n+        cvt(unsafe { libc::ioctl(self.as_raw_fd(), libc::FIONBIO, &mut nonblocking) }).map(drop)\n     }\n \n     #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n@@ -410,23 +413,52 @@ impl Socket {\n         let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n         if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n     }\n+\n+    // This is used by sys_common code to abstract over Windows and Unix.\n+    pub fn as_raw(&self) -> RawFd {\n+        self.as_raw_fd()\n+    }\n+}\n+\n+impl AsInner<FileDesc> for Socket {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.0\n+    }\n+}\n+\n+impl IntoInner<FileDesc> for Socket {\n+    fn into_inner(self) -> FileDesc {\n+        self.0\n+    }\n+}\n+\n+impl FromInner<FileDesc> for Socket {\n+    fn from_inner(file_desc: FileDesc) -> Self {\n+        Self(file_desc)\n+    }\n+}\n+\n+impl AsFd for Socket {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n }\n \n-impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int {\n-        self.0.as_inner()\n+impl AsRawFd for Socket {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n     }\n }\n \n-impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket {\n-        Socket(FileDesc::new(fd))\n+impl IntoRawFd for Socket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n     }\n }\n \n-impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int {\n-        self.0.into_raw()\n+impl FromRawFd for Socket {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self(FromRawFd::from_raw_fd(raw_fd))\n     }\n }\n "}, {"sha": "a56c275c942071793a3e456ffa97260d5fb2f7fb", "filename": "library/std/src/sys/unix/pipe.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fpipe.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,7 +1,9 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem;\n+use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys::fd::FileDesc;\n use crate::sys::{cvt, cvt_r};\n+use crate::sys_common::IntoInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n@@ -24,16 +26,20 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n             target_os = \"openbsd\",\n             target_os = \"redox\"\n         ))] {\n-            cvt(unsafe { libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC) })?;\n-            Ok((AnonPipe(FileDesc::new(fds[0])), AnonPipe(FileDesc::new(fds[1]))))\n+            unsafe {\n+                cvt(libc::pipe2(fds.as_mut_ptr(), libc::O_CLOEXEC))?;\n+                Ok((AnonPipe(FileDesc::from_raw_fd(fds[0])), AnonPipe(FileDesc::from_raw_fd(fds[1]))))\n+            }\n         } else {\n-            cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n-\n-            let fd0 = FileDesc::new(fds[0]);\n-            let fd1 = FileDesc::new(fds[1]);\n-            fd0.set_cloexec()?;\n-            fd1.set_cloexec()?;\n-            Ok((AnonPipe(fd0), AnonPipe(fd1)))\n+            unsafe {\n+                cvt(libc::pipe(fds.as_mut_ptr()))?;\n+\n+                let fd0 = FileDesc::from_raw_fd(fds[0]);\n+                let fd1 = FileDesc::from_raw_fd(fds[1]);\n+                fd0.set_cloexec()?;\n+                fd1.set_cloexec()?;\n+                Ok((AnonPipe(fd0), AnonPipe(fd1)))\n+            }\n         }\n     }\n }\n@@ -64,27 +70,26 @@ impl AnonPipe {\n     pub fn is_write_vectored(&self) -> bool {\n         self.0.is_write_vectored()\n     }\n+}\n \n-    pub fn fd(&self) -> &FileDesc {\n-        &self.0\n-    }\n-    pub fn into_fd(self) -> FileDesc {\n+impl IntoInner<FileDesc> for AnonPipe {\n+    fn into_inner(self) -> FileDesc {\n         self.0\n     }\n }\n \n pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n-    let p1 = p1.into_fd();\n-    let p2 = p2.into_fd();\n+    let p1 = p1.into_inner();\n+    let p2 = p2.into_inner();\n     p1.set_nonblocking(true)?;\n     p2.set_nonblocking(true)?;\n \n     let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n-    fds[0].fd = p1.raw();\n+    fds[0].fd = p1.as_raw_fd();\n     fds[0].events = libc::POLLIN;\n-    fds[1].fd = p2.raw();\n+    fds[1].fd = p2.as_raw_fd();\n     fds[1].events = libc::POLLIN;\n     loop {\n         // wait for either pipe to become readable using `poll`\n@@ -120,3 +125,27 @@ pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) ->\n         }\n     }\n }\n+\n+impl AsRawFd for AnonPipe {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+\n+impl AsFd for AnonPipe {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n+}\n+\n+impl IntoRawFd for AnonPipe {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n+    }\n+}\n+\n+impl FromRawFd for AnonPipe {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        Self(FromRawFd::from_raw_fd(raw_fd))\n+    }\n+}"}, {"sha": "7b261a302c33f280428799c576d940fc3c9f31b8", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -13,6 +13,7 @@ use crate::sys::fd::FileDesc;\n use crate::sys::fs::File;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n+use crate::sys_common::IntoInner;\n \n #[cfg(not(target_os = \"fuchsia\"))]\n use crate::sys::fs::OpenOptions;\n@@ -388,17 +389,17 @@ impl Stdio {\n             // stderr. No matter which we dup first, the second will get\n             // overwritten prematurely.\n             Stdio::Fd(ref fd) => {\n-                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                if fd.as_raw_fd() >= 0 && fd.as_raw_fd() <= libc::STDERR_FILENO {\n                     Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                 } else {\n-                    Ok((ChildStdio::Explicit(fd.raw()), None))\n+                    Ok((ChildStdio::Explicit(fd.as_raw_fd()), None))\n                 }\n             }\n \n             Stdio::MakePipe => {\n                 let (reader, writer) = pipe::anon_pipe()?;\n                 let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n-                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n+                Ok((ChildStdio::Owned(theirs.into_inner()), Some(ours)))\n             }\n \n             #[cfg(not(target_os = \"fuchsia\"))]\n@@ -408,7 +409,7 @@ impl Stdio {\n                 opts.write(!readable);\n                 let path = unsafe { CStr::from_ptr(DEV_NULL.as_ptr() as *const _) };\n                 let fd = File::open_c(&path, &opts)?;\n-                Ok((ChildStdio::Owned(fd.into_fd()), None))\n+                Ok((ChildStdio::Owned(fd.into_inner()), None))\n             }\n \n             #[cfg(target_os = \"fuchsia\")]\n@@ -419,13 +420,13 @@ impl Stdio {\n \n impl From<AnonPipe> for Stdio {\n     fn from(pipe: AnonPipe) -> Stdio {\n-        Stdio::Fd(pipe.into_fd())\n+        Stdio::Fd(pipe.into_inner())\n     }\n }\n \n impl From<File> for Stdio {\n     fn from(file: File) -> Stdio {\n-        Stdio::Fd(file.into_fd())\n+        Stdio::Fd(file.into_inner())\n     }\n }\n \n@@ -434,7 +435,7 @@ impl ChildStdio {\n         match *self {\n             ChildStdio::Inherit => None,\n             ChildStdio::Explicit(fd) => Some(fd),\n-            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n+            ChildStdio::Owned(ref fd) => Some(fd.as_raw_fd()),\n \n             #[cfg(target_os = \"fuchsia\")]\n             ChildStdio::Null => None,"}, {"sha": "12edf04a4e2e9f780db06dcbaf52ff972a774e4e", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -97,7 +97,9 @@ impl Command {\n         drop(env_lock);\n         drop(output);\n \n-        let mut p = Process::new(pid, pidfd);\n+        // Safety: We obtained the pidfd from calling `clone3` with\n+        // `CLONE_PIDFD` so it's valid an otherwise unowned.\n+        let mut p = unsafe { Process::new(pid, pidfd) };\n         let mut bytes = [0; 8];\n \n         // loop to handle EINTR\n@@ -446,7 +448,8 @@ impl Command {\n             None => None,\n         };\n \n-        let mut p = Process::new(0, -1);\n+        // Safety: -1 indicates we don't have a pidfd.\n+        let mut p = unsafe { Process::new(0, -1) };\n \n         struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n \n@@ -545,14 +548,17 @@ pub struct Process {\n \n impl Process {\n     #[cfg(target_os = \"linux\")]\n-    fn new(pid: pid_t, pidfd: pid_t) -> Self {\n+    unsafe fn new(pid: pid_t, pidfd: pid_t) -> Self {\n+        use crate::os::unix::io::FromRawFd;\n         use crate::sys_common::FromInner;\n-        let pidfd = (pidfd >= 0).then(|| PidFd::from_inner(sys::fd::FileDesc::new(pidfd)));\n+        // Safety: If `pidfd` is nonnegative, we assume it's valid and otherwise unowned.\n+        let pidfd = (pidfd >= 0)\n+            .then(|| PidFd::from_inner(unsafe { sys::fd::FileDesc::from_raw_fd(pidfd) }));\n         Process { pid, status: None, pidfd }\n     }\n \n     #[cfg(not(target_os = \"linux\"))]\n-    fn new(pid: pid_t, _pidfd: pid_t) -> Self {\n+    unsafe fn new(pid: pid_t, _pidfd: pid_t) -> Self {\n         Process { pid, status: None }\n     }\n "}, {"sha": "b359987595d301528767c9f1178bf1dbb1bb4367", "filename": "library/std/src/sys/unix/stdio.rs", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstdio.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,5 +1,6 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem::ManuallyDrop;\n+use crate::os::unix::io::{AsFd, BorrowedFd, FromRawFd};\n use crate::sys::fd::FileDesc;\n \n pub struct Stdin(());\n@@ -14,11 +15,11 @@ impl Stdin {\n \n impl io::Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        ManuallyDrop::new(FileDesc::new(libc::STDIN_FILENO)).read(buf)\n+        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read(buf) }\n     }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(FileDesc::new(libc::STDIN_FILENO)).read_vectored(bufs)\n+        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDIN_FILENO)).read_vectored(bufs) }\n     }\n \n     #[inline]\n@@ -35,11 +36,13 @@ impl Stdout {\n \n impl io::Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        ManuallyDrop::new(FileDesc::new(libc::STDOUT_FILENO)).write(buf)\n+        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDOUT_FILENO)).write(buf) }\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(FileDesc::new(libc::STDOUT_FILENO)).write_vectored(bufs)\n+        unsafe {\n+            ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDOUT_FILENO)).write_vectored(bufs)\n+        }\n     }\n \n     #[inline]\n@@ -60,11 +63,13 @@ impl Stderr {\n \n impl io::Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        ManuallyDrop::new(FileDesc::new(libc::STDERR_FILENO)).write(buf)\n+        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDERR_FILENO)).write(buf) }\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(FileDesc::new(libc::STDERR_FILENO)).write_vectored(bufs)\n+        unsafe {\n+            ManuallyDrop::new(FileDesc::from_raw_fd(libc::STDERR_FILENO)).write_vectored(bufs)\n+        }\n     }\n \n     #[inline]\n@@ -86,3 +91,51 @@ pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n pub fn panic_output() -> Option<impl io::Write> {\n     Some(Stderr::new())\n }\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for io::Stdin {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw_fd(libc::STDIN_FILENO) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl<'a> AsFd for io::StdinLock<'a> {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw_fd(libc::STDIN_FILENO) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for io::Stdout {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw_fd(libc::STDOUT_FILENO) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl<'a> AsFd for io::StdoutLock<'a> {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw_fd(libc::STDOUT_FILENO) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl AsFd for io::Stderr {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw_fd(libc::STDERR_FILENO) }\n+    }\n+}\n+\n+#[unstable(feature = \"io_safety\", issue = \"87074\")]\n+impl<'a> AsFd for io::StderrLock<'a> {\n+    #[inline]\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        unsafe { BorrowedFd::borrow_raw_fd(libc::STDERR_FILENO) }\n+    }\n+}"}, {"sha": "e4f4456611cd043e615ffa347919231404670031", "filename": "library/std/src/sys/wasi/fd.rs", "status": "modified", "additions": 109, "deletions": 54, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffd.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -5,11 +5,12 @@ use super::err2io;\n use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n-use crate::os::raw::c_int;\n+use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n #[derive(Debug)]\n pub struct WasiFd {\n-    fd: c_int,\n+    fd: OwnedFd,\n }\n \n fn iovec<'a>(a: &'a mut [IoSliceMut<'_>]) -> &'a [wasi::Iovec] {\n@@ -27,38 +28,26 @@ fn ciovec<'a>(a: &'a [IoSlice<'_>]) -> &'a [wasi::Ciovec] {\n }\n \n impl WasiFd {\n-    pub unsafe fn from_raw(fd: c_int) -> WasiFd {\n-        WasiFd { fd }\n-    }\n-\n-    pub fn into_raw(self) -> c_int {\n-        let ret = self.fd;\n-        mem::forget(self);\n-        ret\n-    }\n-\n-    pub fn as_raw(&self) -> c_int {\n-        self.fd\n-    }\n-\n     pub fn datasync(&self) -> io::Result<()> {\n-        unsafe { wasi::fd_datasync(self.fd as wasi::Fd).map_err(err2io) }\n+        unsafe { wasi::fd_datasync(self.as_raw_fd() as wasi::Fd).map_err(err2io) }\n     }\n \n     pub fn pread(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n-        unsafe { wasi::fd_pread(self.fd as wasi::Fd, iovec(bufs), offset).map_err(err2io) }\n+        unsafe { wasi::fd_pread(self.as_raw_fd() as wasi::Fd, iovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn pwrite(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n-        unsafe { wasi::fd_pwrite(self.fd as wasi::Fd, ciovec(bufs), offset).map_err(err2io) }\n+        unsafe {\n+            wasi::fd_pwrite(self.as_raw_fd() as wasi::Fd, ciovec(bufs), offset).map_err(err2io)\n+        }\n     }\n \n     pub fn read(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        unsafe { wasi::fd_read(self.fd as wasi::Fd, iovec(bufs)).map_err(err2io) }\n+        unsafe { wasi::fd_read(self.as_raw_fd() as wasi::Fd, iovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        unsafe { wasi::fd_write(self.fd as wasi::Fd, ciovec(bufs)).map_err(err2io) }\n+        unsafe { wasi::fd_write(self.as_raw_fd() as wasi::Fd, ciovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n@@ -67,37 +56,42 @@ impl WasiFd {\n             SeekFrom::End(pos) => (wasi::WHENCE_END, pos),\n             SeekFrom::Current(pos) => (wasi::WHENCE_CUR, pos),\n         };\n-        unsafe { wasi::fd_seek(self.fd as wasi::Fd, offset, whence).map_err(err2io) }\n+        unsafe { wasi::fd_seek(self.as_raw_fd() as wasi::Fd, offset, whence).map_err(err2io) }\n     }\n \n     pub fn tell(&self) -> io::Result<u64> {\n-        unsafe { wasi::fd_tell(self.fd as wasi::Fd).map_err(err2io) }\n+        unsafe { wasi::fd_tell(self.as_raw_fd() as wasi::Fd).map_err(err2io) }\n     }\n \n     // FIXME: __wasi_fd_fdstat_get\n \n     pub fn set_flags(&self, flags: wasi::Fdflags) -> io::Result<()> {\n-        unsafe { wasi::fd_fdstat_set_flags(self.fd as wasi::Fd, flags).map_err(err2io) }\n+        unsafe { wasi::fd_fdstat_set_flags(self.as_raw_fd() as wasi::Fd, flags).map_err(err2io) }\n     }\n \n     pub fn set_rights(&self, base: wasi::Rights, inheriting: wasi::Rights) -> io::Result<()> {\n-        unsafe { wasi::fd_fdstat_set_rights(self.fd as wasi::Fd, base, inheriting).map_err(err2io) }\n+        unsafe {\n+            wasi::fd_fdstat_set_rights(self.as_raw_fd() as wasi::Fd, base, inheriting)\n+                .map_err(err2io)\n+        }\n     }\n \n     pub fn sync(&self) -> io::Result<()> {\n-        unsafe { wasi::fd_sync(self.fd as wasi::Fd).map_err(err2io) }\n+        unsafe { wasi::fd_sync(self.as_raw_fd() as wasi::Fd).map_err(err2io) }\n     }\n \n     pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n-        unsafe { wasi::fd_advise(self.fd as wasi::Fd, offset, len, advice).map_err(err2io) }\n+        unsafe {\n+            wasi::fd_advise(self.as_raw_fd() as wasi::Fd, offset, len, advice).map_err(err2io)\n+        }\n     }\n \n     pub fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n-        unsafe { wasi::fd_allocate(self.fd as wasi::Fd, offset, len).map_err(err2io) }\n+        unsafe { wasi::fd_allocate(self.as_raw_fd() as wasi::Fd, offset, len).map_err(err2io) }\n     }\n \n     pub fn create_directory(&self, path: &str) -> io::Result<()> {\n-        unsafe { wasi::path_create_directory(self.fd as wasi::Fd, path).map_err(err2io) }\n+        unsafe { wasi::path_create_directory(self.as_raw_fd() as wasi::Fd, path).map_err(err2io) }\n     }\n \n     pub fn link(\n@@ -109,10 +103,10 @@ impl WasiFd {\n     ) -> io::Result<()> {\n         unsafe {\n             wasi::path_link(\n-                self.fd as wasi::Fd,\n+                self.as_raw_fd() as wasi::Fd,\n                 old_flags,\n                 old_path,\n-                new_fd.fd as wasi::Fd,\n+                new_fd.as_raw_fd() as wasi::Fd,\n                 new_path,\n             )\n             .map_err(err2io)\n@@ -130,42 +124,47 @@ impl WasiFd {\n     ) -> io::Result<WasiFd> {\n         unsafe {\n             wasi::path_open(\n-                self.fd as wasi::Fd,\n+                self.as_raw_fd() as wasi::Fd,\n                 dirflags,\n                 path,\n                 oflags,\n                 fs_rights_base,\n                 fs_rights_inheriting,\n                 fs_flags,\n             )\n-            .map(|fd| WasiFd::from_raw(fd as c_int))\n+            .map(|fd| WasiFd::from_raw_fd(fd as RawFd))\n             .map_err(err2io)\n         }\n     }\n \n     pub fn readdir(&self, buf: &mut [u8], cookie: wasi::Dircookie) -> io::Result<usize> {\n         unsafe {\n-            wasi::fd_readdir(self.fd as wasi::Fd, buf.as_mut_ptr(), buf.len(), cookie)\n+            wasi::fd_readdir(self.as_raw_fd() as wasi::Fd, buf.as_mut_ptr(), buf.len(), cookie)\n                 .map_err(err2io)\n         }\n     }\n \n     pub fn readlink(&self, path: &str, buf: &mut [u8]) -> io::Result<usize> {\n         unsafe {\n-            wasi::path_readlink(self.fd as wasi::Fd, path, buf.as_mut_ptr(), buf.len())\n+            wasi::path_readlink(self.as_raw_fd() as wasi::Fd, path, buf.as_mut_ptr(), buf.len())\n                 .map_err(err2io)\n         }\n     }\n \n     pub fn rename(&self, old_path: &str, new_fd: &WasiFd, new_path: &str) -> io::Result<()> {\n         unsafe {\n-            wasi::path_rename(self.fd as wasi::Fd, old_path, new_fd.fd as wasi::Fd, new_path)\n-                .map_err(err2io)\n+            wasi::path_rename(\n+                self.as_raw_fd() as wasi::Fd,\n+                old_path,\n+                new_fd.as_raw_fd() as wasi::Fd,\n+                new_path,\n+            )\n+            .map_err(err2io)\n         }\n     }\n \n     pub fn filestat_get(&self) -> io::Result<wasi::Filestat> {\n-        unsafe { wasi::fd_filestat_get(self.fd as wasi::Fd).map_err(err2io) }\n+        unsafe { wasi::fd_filestat_get(self.as_raw_fd() as wasi::Fd).map_err(err2io) }\n     }\n \n     pub fn filestat_set_times(\n@@ -175,20 +174,23 @@ impl WasiFd {\n         fstflags: wasi::Fstflags,\n     ) -> io::Result<()> {\n         unsafe {\n-            wasi::fd_filestat_set_times(self.fd as wasi::Fd, atim, mtim, fstflags).map_err(err2io)\n+            wasi::fd_filestat_set_times(self.as_raw_fd() as wasi::Fd, atim, mtim, fstflags)\n+                .map_err(err2io)\n         }\n     }\n \n     pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {\n-        unsafe { wasi::fd_filestat_set_size(self.fd as wasi::Fd, size).map_err(err2io) }\n+        unsafe { wasi::fd_filestat_set_size(self.as_raw_fd() as wasi::Fd, size).map_err(err2io) }\n     }\n \n     pub fn path_filestat_get(\n         &self,\n         flags: wasi::Lookupflags,\n         path: &str,\n     ) -> io::Result<wasi::Filestat> {\n-        unsafe { wasi::path_filestat_get(self.fd as wasi::Fd, flags, path).map_err(err2io) }\n+        unsafe {\n+            wasi::path_filestat_get(self.as_raw_fd() as wasi::Fd, flags, path).map_err(err2io)\n+        }\n     }\n \n     pub fn path_filestat_set_times(\n@@ -200,33 +202,46 @@ impl WasiFd {\n         fstflags: wasi::Fstflags,\n     ) -> io::Result<()> {\n         unsafe {\n-            wasi::path_filestat_set_times(self.fd as wasi::Fd, flags, path, atim, mtim, fstflags)\n-                .map_err(err2io)\n+            wasi::path_filestat_set_times(\n+                self.as_raw_fd() as wasi::Fd,\n+                flags,\n+                path,\n+                atim,\n+                mtim,\n+                fstflags,\n+            )\n+            .map_err(err2io)\n         }\n     }\n \n     pub fn symlink(&self, old_path: &str, new_path: &str) -> io::Result<()> {\n-        unsafe { wasi::path_symlink(old_path, self.fd as wasi::Fd, new_path).map_err(err2io) }\n+        unsafe {\n+            wasi::path_symlink(old_path, self.as_raw_fd() as wasi::Fd, new_path).map_err(err2io)\n+        }\n     }\n \n     pub fn unlink_file(&self, path: &str) -> io::Result<()> {\n-        unsafe { wasi::path_unlink_file(self.fd as wasi::Fd, path).map_err(err2io) }\n+        unsafe { wasi::path_unlink_file(self.as_raw_fd() as wasi::Fd, path).map_err(err2io) }\n     }\n \n     pub fn remove_directory(&self, path: &str) -> io::Result<()> {\n-        unsafe { wasi::path_remove_directory(self.fd as wasi::Fd, path).map_err(err2io) }\n+        unsafe { wasi::path_remove_directory(self.as_raw_fd() as wasi::Fd, path).map_err(err2io) }\n     }\n \n     pub fn sock_recv(\n         &self,\n         ri_data: &mut [IoSliceMut<'_>],\n         ri_flags: wasi::Riflags,\n     ) -> io::Result<(usize, wasi::Roflags)> {\n-        unsafe { wasi::sock_recv(self.fd as wasi::Fd, iovec(ri_data), ri_flags).map_err(err2io) }\n+        unsafe {\n+            wasi::sock_recv(self.as_raw_fd() as wasi::Fd, iovec(ri_data), ri_flags).map_err(err2io)\n+        }\n     }\n \n     pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::Siflags) -> io::Result<usize> {\n-        unsafe { wasi::sock_send(self.fd as wasi::Fd, ciovec(si_data), si_flags).map_err(err2io) }\n+        unsafe {\n+            wasi::sock_send(self.as_raw_fd() as wasi::Fd, ciovec(si_data), si_flags).map_err(err2io)\n+        }\n     }\n \n     pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {\n@@ -235,14 +250,54 @@ impl WasiFd {\n             Shutdown::Write => wasi::SDFLAGS_WR,\n             Shutdown::Both => wasi::SDFLAGS_WR | wasi::SDFLAGS_RD,\n         };\n-        unsafe { wasi::sock_shutdown(self.fd as wasi::Fd, how).map_err(err2io) }\n+        unsafe { wasi::sock_shutdown(self.as_raw_fd() as wasi::Fd, how).map_err(err2io) }\n+    }\n+}\n+\n+impl AsInner<OwnedFd> for WasiFd {\n+    fn as_inner(&self) -> &OwnedFd {\n+        &self.fd\n+    }\n+}\n+\n+impl AsInnerMut<OwnedFd> for WasiFd {\n+    fn as_inner_mut(&mut self) -> &mut OwnedFd {\n+        &mut self.fd\n+    }\n+}\n+\n+impl IntoInner<OwnedFd> for WasiFd {\n+    fn into_inner(self) -> OwnedFd {\n+        self.fd\n+    }\n+}\n+\n+impl FromInner<OwnedFd> for WasiFd {\n+    fn from_inner(owned_fd: OwnedFd) -> Self {\n+        Self { fd: owned_fd }\n+    }\n+}\n+\n+impl AsFd for WasiFd {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.fd.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for WasiFd {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for WasiFd {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.fd.into_raw_fd()\n     }\n }\n \n-impl Drop for WasiFd {\n-    fn drop(&mut self) {\n-        // FIXME: can we handle the return code here even though we can't on\n-        // unix?\n-        let _ = unsafe { wasi::fd_close(self.fd as wasi::Fd) };\n+impl FromRawFd for WasiFd {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        unsafe { Self { fd: FromRawFd::from_raw_fd(raw_fd) } }\n     }\n }"}, {"sha": "984dda8dc0b4ee744994c7e9c4658e23be3313f7", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -8,12 +8,13 @@ use crate::iter;\n use crate::mem::{self, ManuallyDrop};\n use crate::os::raw::c_int;\n use crate::os::wasi::ffi::{OsStrExt, OsStringExt};\n+use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n-use crate::sys_common::FromInner;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n pub use crate::sys_common::fs::{remove_dir_all, try_exists};\n \n@@ -442,22 +443,50 @@ impl File {\n         unsupported()\n     }\n \n-    pub fn fd(&self) -> &WasiFd {\n+    pub fn read_link(&self, file: &Path) -> io::Result<PathBuf> {\n+        read_link(&self.fd, file)\n+    }\n+}\n+\n+impl AsInner<WasiFd> for File {\n+    fn as_inner(&self) -> &WasiFd {\n         &self.fd\n     }\n+}\n \n-    pub fn into_fd(self) -> WasiFd {\n+impl IntoInner<WasiFd> for File {\n+    fn into_inner(self) -> WasiFd {\n         self.fd\n     }\n+}\n \n-    pub fn read_link(&self, file: &Path) -> io::Result<PathBuf> {\n-        read_link(&self.fd, file)\n+impl FromInner<WasiFd> for File {\n+    fn from_inner(fd: WasiFd) -> File {\n+        File { fd }\n+    }\n+}\n+\n+impl AsFd for File {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.fd.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.fd.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.fd.into_raw_fd()\n     }\n }\n \n-impl FromInner<c_int> for File {\n-    fn from_inner(fd: c_int) -> File {\n-        unsafe { File { fd: WasiFd::from_raw(fd) } }\n+impl FromRawFd for File {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        unsafe { Self { fd: FromRawFd::from_raw_fd(raw_fd) } }\n     }\n }\n \n@@ -474,7 +503,7 @@ impl DirBuilder {\n \n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"File\").field(\"fd\", &self.fd.as_raw()).finish()\n+        f.debug_struct(\"File\").field(\"fd\", &self.as_raw_fd()).finish()\n     }\n }\n \n@@ -654,7 +683,7 @@ fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n             let relative = CStr::from_ptr(relative_path).to_bytes().to_vec();\n \n             return Ok((\n-                ManuallyDrop::new(WasiFd::from_raw(fd as c_int)),\n+                ManuallyDrop::new(WasiFd::from_raw_fd(fd as c_int)),\n                 PathBuf::from(OsString::from_vec(relative)),\n             ));\n         }"}, {"sha": "c7c4a9f6efdfb8fad71c442251e61be3ea0990d0", "filename": "library/std/src/sys/wasi/net.rs", "status": "modified", "additions": 97, "deletions": 29, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fnet.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -5,13 +5,57 @@ use crate::convert::TryFrom;\n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n-use crate::os::raw::c_int;\n+use crate::os::wasi::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd};\n use crate::sys::unsupported;\n-use crate::sys_common::FromInner;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n+pub struct Socket(WasiFd);\n+\n pub struct TcpStream {\n-    fd: WasiFd,\n+    inner: Socket,\n+}\n+\n+impl AsInner<WasiFd> for Socket {\n+    fn as_inner(&self) -> &WasiFd {\n+        &self.0\n+    }\n+}\n+\n+impl IntoInner<WasiFd> for Socket {\n+    fn into_inner(self) -> WasiFd {\n+        self.0\n+    }\n+}\n+\n+impl FromInner<WasiFd> for Socket {\n+    fn from_inner(inner: WasiFd) -> Socket {\n+        Socket(inner)\n+    }\n+}\n+\n+impl AsFd for Socket {\n+    fn as_fd(&self) -> BorrowedFd<'_> {\n+        self.0.as_fd()\n+    }\n+}\n+\n+impl AsRawFd for Socket {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.0.as_raw_fd()\n+    }\n+}\n+\n+impl IntoRawFd for Socket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_raw_fd()\n+    }\n+}\n+\n+impl FromRawFd for Socket {\n+    unsafe fn from_raw_fd(raw_fd: RawFd) -> Self {\n+        unsafe { Self(FromRawFd::from_raw_fd(raw_fd)) }\n+    }\n }\n \n impl TcpStream {\n@@ -107,29 +151,29 @@ impl TcpStream {\n         unsupported()\n     }\n \n-    pub fn fd(&self) -> &WasiFd {\n-        &self.fd\n+    pub fn socket(&self) -> &Socket {\n+        &self.inner\n     }\n \n-    pub fn into_fd(self) -> WasiFd {\n-        self.fd\n+    pub fn into_socket(self) -> Socket {\n+        self.inner\n     }\n }\n \n-impl FromInner<c_int> for TcpStream {\n-    fn from_inner(fd: c_int) -> TcpStream {\n-        unsafe { TcpStream { fd: WasiFd::from_raw(fd) } }\n+impl FromInner<Socket> for TcpStream {\n+    fn from_inner(socket: Socket) -> TcpStream {\n+        TcpStream { inner: socket }\n     }\n }\n \n impl fmt::Debug for TcpStream {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TcpStream\").field(\"fd\", &self.fd.as_raw()).finish()\n+        f.debug_struct(\"TcpStream\").field(\"fd\", &self.inner.as_raw_fd()).finish()\n     }\n }\n \n pub struct TcpListener {\n-    fd: WasiFd,\n+    inner: Socket,\n }\n \n impl TcpListener {\n@@ -173,29 +217,41 @@ impl TcpListener {\n         unsupported()\n     }\n \n-    pub fn fd(&self) -> &WasiFd {\n-        &self.fd\n+    pub fn socket(&self) -> &Socket {\n+        &self.inner\n     }\n \n-    pub fn into_fd(self) -> WasiFd {\n-        self.fd\n+    pub fn into_socket(self) -> Socket {\n+        self.inner\n     }\n }\n \n-impl FromInner<c_int> for TcpListener {\n-    fn from_inner(fd: c_int) -> TcpListener {\n-        unsafe { TcpListener { fd: WasiFd::from_raw(fd) } }\n+impl AsInner<Socket> for TcpListener {\n+    fn as_inner(&self) -> &Socket {\n+        &self.inner\n+    }\n+}\n+\n+impl IntoInner<Socket> for TcpListener {\n+    fn into_inner(self) -> Socket {\n+        self.inner\n+    }\n+}\n+\n+impl FromInner<Socket> for TcpListener {\n+    fn from_inner(inner: Socket) -> TcpListener {\n+        TcpListener { inner }\n     }\n }\n \n impl fmt::Debug for TcpListener {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TcpListener\").field(\"fd\", &self.fd.as_raw()).finish()\n+        f.debug_struct(\"TcpListener\").field(\"fd\", &self.inner.as_raw_fd()).finish()\n     }\n }\n \n pub struct UdpSocket {\n-    fd: WasiFd,\n+    inner: Socket,\n }\n \n impl UdpSocket {\n@@ -323,24 +379,36 @@ impl UdpSocket {\n         unsupported()\n     }\n \n-    pub fn fd(&self) -> &WasiFd {\n-        &self.fd\n+    pub fn socket(&self) -> &Socket {\n+        &self.inner\n+    }\n+\n+    pub fn into_socket(self) -> Socket {\n+        self.inner\n     }\n+}\n+\n+impl AsInner<Socket> for UdpSocket {\n+    fn as_inner(&self) -> &Socket {\n+        &self.inner\n+    }\n+}\n \n-    pub fn into_fd(self) -> WasiFd {\n-        self.fd\n+impl IntoInner<Socket> for UdpSocket {\n+    fn into_inner(self) -> Socket {\n+        self.inner\n     }\n }\n \n-impl FromInner<c_int> for UdpSocket {\n-    fn from_inner(fd: c_int) -> UdpSocket {\n-        unsafe { UdpSocket { fd: WasiFd::from_raw(fd) } }\n+impl FromInner<Socket> for UdpSocket {\n+    fn from_inner(inner: Socket) -> UdpSocket {\n+        UdpSocket { inner }\n     }\n }\n \n impl fmt::Debug for UdpSocket {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"UdpSocket\").field(\"fd\", &self.fd.as_raw()).finish()\n+        f.debug_struct(\"UdpSocket\").field(\"fd\", &self.inner.as_raw_fd()).finish()\n     }\n }\n "}, {"sha": "2c8f394cd47b05244944b87664539c2ce4e493ed", "filename": "library/std/src/sys/wasi/stdio.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fstdio.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -4,6 +4,7 @@ use super::fd::WasiFd;\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::mem::ManuallyDrop;\n use crate::os::raw;\n+use crate::os::wasi::io::{AsRawFd, FromRawFd};\n \n pub struct Stdin;\n pub struct Stdout;\n@@ -13,9 +14,11 @@ impl Stdin {\n     pub const fn new() -> Stdin {\n         Stdin\n     }\n+}\n \n+impl AsRawFd for Stdin {\n     #[inline]\n-    pub fn as_raw_fd(&self) -> raw::c_int {\n+    fn as_raw_fd(&self) -> raw::c_int {\n         0\n     }\n }\n@@ -26,7 +29,7 @@ impl io::Read for Stdin {\n     }\n \n     fn read_vectored(&mut self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).read(data)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw_fd(self.as_raw_fd()) }).read(data)\n     }\n \n     #[inline]\n@@ -39,9 +42,11 @@ impl Stdout {\n     pub const fn new() -> Stdout {\n         Stdout\n     }\n+}\n \n+impl AsRawFd for Stdout {\n     #[inline]\n-    pub fn as_raw_fd(&self) -> raw::c_int {\n+    fn as_raw_fd(&self) -> raw::c_int {\n         1\n     }\n }\n@@ -52,7 +57,7 @@ impl io::Write for Stdout {\n     }\n \n     fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw_fd(self.as_raw_fd()) }).write(data)\n     }\n \n     #[inline]\n@@ -68,9 +73,11 @@ impl Stderr {\n     pub const fn new() -> Stderr {\n         Stderr\n     }\n+}\n \n+impl AsRawFd for Stderr {\n     #[inline]\n-    pub fn as_raw_fd(&self) -> raw::c_int {\n+    fn as_raw_fd(&self) -> raw::c_int {\n         2\n     }\n }\n@@ -81,7 +88,7 @@ impl io::Write for Stderr {\n     }\n \n     fn write_vectored(&mut self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(self.as_raw_fd()) }).write(data)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw_fd(self.as_raw_fd()) }).write(data)\n     }\n \n     #[inline]"}, {"sha": "0c1a50e231cd4f87cbfd63a85a4e1b5be5806237", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -4,14 +4,15 @@ use crate::ffi::OsString;\n use crate::fmt;\n use crate::io::{self, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n+use crate::os::windows::io::{AsHandle, BorrowedHandle};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::slice;\n use crate::sync::Arc;\n use crate::sys::handle::Handle;\n use crate::sys::time::SystemTime;\n use crate::sys::{c, cvt};\n-use crate::sys_common::FromInner;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n use super::to_u16s;\n \n@@ -295,12 +296,12 @@ impl File {\n         if handle == c::INVALID_HANDLE_VALUE {\n             Err(Error::last_os_error())\n         } else {\n-            Ok(File { handle: Handle::new(handle) })\n+            unsafe { Ok(File { handle: Handle::from_raw_handle(handle) }) }\n         }\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        cvt(unsafe { c::FlushFileBuffers(self.handle.raw()) })?;\n+        cvt(unsafe { c::FlushFileBuffers(self.handle.as_raw_handle()) })?;\n         Ok(())\n     }\n \n@@ -313,7 +314,7 @@ impl File {\n         let size = mem::size_of_val(&info);\n         cvt(unsafe {\n             c::SetFileInformationByHandle(\n-                self.handle.raw(),\n+                self.handle.as_raw_handle(),\n                 c::FileEndOfFileInfo,\n                 &mut info as *mut _ as *mut _,\n                 size as c::DWORD,\n@@ -326,7 +327,7 @@ impl File {\n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         unsafe {\n             let mut info: c::BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n-            cvt(c::GetFileInformationByHandle(self.handle.raw(), &mut info))?;\n+            cvt(c::GetFileInformationByHandle(self.handle.as_raw_handle(), &mut info))?;\n             let mut reparse_tag = 0;\n             if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n                 let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n@@ -449,22 +450,14 @@ impl File {\n         };\n         let pos = pos as c::LARGE_INTEGER;\n         let mut newpos = 0;\n-        cvt(unsafe { c::SetFilePointerEx(self.handle.raw(), pos, &mut newpos, whence) })?;\n+        cvt(unsafe { c::SetFilePointerEx(self.handle.as_raw_handle(), pos, &mut newpos, whence) })?;\n         Ok(newpos as u64)\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n         Ok(File { handle: self.handle.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)? })\n     }\n \n-    pub fn handle(&self) -> &Handle {\n-        &self.handle\n-    }\n-\n-    pub fn into_handle(self) -> Handle {\n-        self.handle\n-    }\n-\n     fn reparse_point<'a>(\n         &self,\n         space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n@@ -473,7 +466,7 @@ impl File {\n             let mut bytes = 0;\n             cvt({\n                 c::DeviceIoControl(\n-                    self.handle.raw(),\n+                    self.handle.as_raw_handle(),\n                     c::FSCTL_GET_REPARSE_POINT,\n                     ptr::null_mut(),\n                     0,\n@@ -541,7 +534,7 @@ impl File {\n         let size = mem::size_of_val(&info);\n         cvt(unsafe {\n             c::SetFileInformationByHandle(\n-                self.handle.raw(),\n+                self.handle.as_raw_handle(),\n                 c::FileBasicInfo,\n                 &mut info as *mut _ as *mut _,\n                 size as c::DWORD,\n@@ -551,17 +544,53 @@ impl File {\n     }\n }\n \n-impl FromInner<c::HANDLE> for File {\n-    fn from_inner(handle: c::HANDLE) -> File {\n-        File { handle: Handle::new(handle) }\n+impl AsInner<Handle> for File {\n+    fn as_inner(&self) -> &Handle {\n+        &self.handle\n+    }\n+}\n+\n+impl IntoInner<Handle> for File {\n+    fn into_inner(self) -> Handle {\n+        self.handle\n+    }\n+}\n+\n+impl FromInner<Handle> for File {\n+    fn from_inner(handle: Handle) -> File {\n+        File { handle: handle }\n+    }\n+}\n+\n+impl AsHandle for File {\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        self.as_inner().as_handle()\n+    }\n+}\n+\n+impl AsRawHandle for File {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.as_inner().as_raw_handle()\n+    }\n+}\n+\n+impl IntoRawHandle for File {\n+    fn into_raw_handle(self) -> RawHandle {\n+        self.into_inner().into_raw_handle()\n+    }\n+}\n+\n+impl FromRawHandle for File {\n+    unsafe fn from_raw_handle(raw_handle: RawHandle) -> Self {\n+        Self { handle: FromInner::from_inner(FromRawHandle::from_raw_handle(raw_handle)) }\n     }\n }\n \n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME(#24570): add more info here (e.g., mode)\n         let mut b = f.debug_struct(\"File\");\n-        b.field(\"handle\", &self.handle.raw());\n+        b.field(\"handle\", &self.handle.as_raw_handle());\n         if let Ok(path) = get_path(&self) {\n             b.field(\"path\", &path);\n         }\n@@ -838,7 +867,7 @@ pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n fn get_path(f: &File) -> io::Result<PathBuf> {\n     super::fill_utf16_buf(\n         |buf, sz| unsafe {\n-            c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz, c::VOLUME_NAME_DOS)\n+            c::GetFinalPathNameByHandleW(f.handle.as_raw_handle(), buf, sz, c::VOLUME_NAME_DOS)\n         },\n         |buf| PathBuf::from(OsString::from_wide(buf)),\n     )\n@@ -909,7 +938,7 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     opts.write(true);\n     opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT | c::FILE_FLAG_BACKUP_SEMANTICS);\n     let f = File::open(junction, &opts)?;\n-    let h = f.handle().raw();\n+    let h = f.as_inner().as_raw_handle();\n \n     unsafe {\n         let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];"}, {"sha": "21d86b002264ad30ea46bf5075e7986ff5a5f682", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 76, "deletions": 46, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -3,76 +3,87 @@\n use crate::cmp;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, Read};\n use crate::mem;\n-use crate::ops::Deref;\n+use crate::os::windows::io::{\n+    AsHandle, AsRawHandle, BorrowedHandle, FromRawHandle, IntoRawHandle, OwnedHandle, RawHandle,\n+};\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::cvt;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n /// An owned container for `HANDLE` object, closing them on Drop.\n ///\n /// All methods are inherited through a `Deref` impl to `RawHandle`\n-pub struct Handle(RawHandle);\n-\n-/// A wrapper type for `HANDLE` objects to give them proper Send/Sync inference\n-/// as well as Rust-y methods.\n-///\n-/// This does **not** drop the handle when it goes out of scope, use `Handle`\n-/// instead for that.\n-#[derive(Copy, Clone)]\n-pub struct RawHandle(c::HANDLE);\n-\n-unsafe impl Send for RawHandle {}\n-unsafe impl Sync for RawHandle {}\n+pub struct Handle(OwnedHandle);\n \n impl Handle {\n-    pub fn new(handle: c::HANDLE) -> Handle {\n-        Handle(RawHandle::new(handle))\n-    }\n-\n     pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n         unsafe {\n             let event =\n                 c::CreateEventW(ptr::null_mut(), manual as c::BOOL, init as c::BOOL, ptr::null());\n-            if event.is_null() { Err(io::Error::last_os_error()) } else { Ok(Handle::new(event)) }\n+            if event.is_null() {\n+                Err(io::Error::last_os_error())\n+            } else {\n+                Ok(Handle::from_raw_handle(event))\n+            }\n         }\n     }\n+}\n \n-    pub fn into_raw(self) -> c::HANDLE {\n-        let ret = self.raw();\n-        mem::forget(self);\n-        ret\n+impl AsInner<OwnedHandle> for Handle {\n+    fn as_inner(&self) -> &OwnedHandle {\n+        &self.0\n     }\n }\n \n-impl Deref for Handle {\n-    type Target = RawHandle;\n-    fn deref(&self) -> &RawHandle {\n-        &self.0\n+impl IntoInner<OwnedHandle> for Handle {\n+    fn into_inner(self) -> OwnedHandle {\n+        self.0\n     }\n }\n \n-impl Drop for Handle {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let _ = c::CloseHandle(self.raw());\n-        }\n+impl FromInner<OwnedHandle> for Handle {\n+    fn from_inner(file_desc: OwnedHandle) -> Self {\n+        Self(file_desc)\n     }\n }\n \n-impl RawHandle {\n-    pub fn new(handle: c::HANDLE) -> RawHandle {\n-        RawHandle(handle)\n+impl AsHandle for Handle {\n+    fn as_handle(&self) -> BorrowedHandle<'_> {\n+        self.0.as_handle()\n     }\n+}\n \n-    pub fn raw(&self) -> c::HANDLE {\n-        self.0\n+impl AsRawHandle for Handle {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        self.0.as_raw_handle()\n     }\n+}\n \n+impl IntoRawHandle for Handle {\n+    fn into_raw_handle(self) -> RawHandle {\n+        self.0.into_raw_handle()\n+    }\n+}\n+\n+impl FromRawHandle for Handle {\n+    unsafe fn from_raw_handle(raw_handle: RawHandle) -> Self {\n+        Self(FromRawHandle::from_raw_handle(raw_handle))\n+    }\n+}\n+\n+impl Handle {\n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let res = cvt(unsafe {\n-            c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, ptr::null_mut())\n+            c::ReadFile(\n+                self.as_raw_handle(),\n+                buf.as_mut_ptr() as c::LPVOID,\n+                len,\n+                &mut read,\n+                ptr::null_mut(),\n+            )\n         });\n \n         match res {\n@@ -104,7 +115,13 @@ impl RawHandle {\n             let mut overlapped: c::OVERLAPPED = mem::zeroed();\n             overlapped.Offset = offset as u32;\n             overlapped.OffsetHigh = (offset >> 32) as u32;\n-            cvt(c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID, len, &mut read, &mut overlapped))\n+            cvt(c::ReadFile(\n+                self.as_raw_handle(),\n+                buf.as_mut_ptr() as c::LPVOID,\n+                len,\n+                &mut read,\n+                &mut overlapped,\n+            ))\n         };\n         match res {\n             Ok(_) => Ok(read as usize),\n@@ -120,7 +137,13 @@ impl RawHandle {\n     ) -> io::Result<Option<usize>> {\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         let mut amt = 0;\n-        let res = cvt(c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped));\n+        let res = cvt(c::ReadFile(\n+            self.as_raw_handle(),\n+            buf.as_ptr() as c::LPVOID,\n+            len,\n+            &mut amt,\n+            overlapped,\n+        ));\n         match res {\n             Ok(_) => Ok(Some(amt as usize)),\n             Err(e) => {\n@@ -143,7 +166,8 @@ impl RawHandle {\n         unsafe {\n             let mut bytes = 0;\n             let wait = if wait { c::TRUE } else { c::FALSE };\n-            let res = cvt(c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait));\n+            let res =\n+                cvt(c::GetOverlappedResult(self.as_raw_handle(), overlapped, &mut bytes, wait));\n             match res {\n                 Ok(_) => Ok(bytes as usize),\n                 Err(e) => {\n@@ -160,14 +184,20 @@ impl RawHandle {\n     }\n \n     pub fn cancel_io(&self) -> io::Result<()> {\n-        unsafe { cvt(c::CancelIo(self.raw())).map(drop) }\n+        unsafe { cvt(c::CancelIo(self.as_raw_handle())).map(drop) }\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n         let len = cmp::min(buf.len(), <c::DWORD>::MAX as usize) as c::DWORD;\n         cvt(unsafe {\n-            c::WriteFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, ptr::null_mut())\n+            c::WriteFile(\n+                self.as_raw_handle(),\n+                buf.as_ptr() as c::LPVOID,\n+                len,\n+                &mut amt,\n+                ptr::null_mut(),\n+            )\n         })?;\n         Ok(amt as usize)\n     }\n@@ -189,7 +219,7 @@ impl RawHandle {\n             overlapped.Offset = offset as u32;\n             overlapped.OffsetHigh = (offset >> 32) as u32;\n             cvt(c::WriteFile(\n-                self.0,\n+                self.as_raw_handle(),\n                 buf.as_ptr() as c::LPVOID,\n                 len,\n                 &mut written,\n@@ -210,19 +240,19 @@ impl RawHandle {\n             let cur_proc = c::GetCurrentProcess();\n             c::DuplicateHandle(\n                 cur_proc,\n-                self.0,\n+                self.as_raw_handle(),\n                 cur_proc,\n                 &mut ret,\n                 access,\n                 inherit as c::BOOL,\n                 options,\n             )\n         })?;\n-        Ok(Handle::new(ret))\n+        unsafe { Ok(Handle::from_raw_handle(ret)) }\n     }\n }\n \n-impl<'a> Read for &'a RawHandle {\n+impl<'a> Read for &'a Handle {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)\n     }"}, {"sha": "55aacb38c6f785e23a550560db9eb73a8ead6675", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -4,6 +4,9 @@ use crate::cmp;\n use crate::io::{self, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n+use crate::os::windows::io::{\n+    AsRawSocket, AsSocket, BorrowedSocket, FromRawSocket, IntoRawSocket, OwnedSocket, RawSocket,\n+};\n use crate::ptr;\n use crate::sync::Once;\n use crate::sys;\n@@ -24,7 +27,7 @@ pub mod netc {\n     pub use crate::sys::c::*;\n }\n \n-pub struct Socket(c::SOCKET);\n+pub struct Socket(OwnedSocket);\n \n static INIT: Once = Once::new();\n \n@@ -109,7 +112,7 @@ impl Socket {\n         };\n \n         if socket != c::INVALID_SOCKET {\n-            Ok(Self(socket))\n+            unsafe { Ok(Self::from_raw_socket(socket)) }\n         } else {\n             let error = unsafe { c::WSAGetLastError() };\n \n@@ -124,17 +127,19 @@ impl Socket {\n                 return Err(last_error());\n             }\n \n-            let socket = Self(socket);\n-            socket.set_no_inherit()?;\n-            Ok(socket)\n+            unsafe {\n+                let socket = Self::from_raw_socket(socket);\n+                socket.set_no_inherit()?;\n+                Ok(socket)\n+            }\n         }\n     }\n \n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n         let result = {\n             let (addrp, len) = addr.into_inner();\n-            let result = unsafe { c::connect(self.0, addrp, len) };\n+            let result = unsafe { c::connect(self.as_raw_socket(), addrp, len) };\n             cvt(result).map(drop)\n         };\n         self.set_nonblocking(false)?;\n@@ -160,7 +165,7 @@ impl Socket {\n                 let fds = {\n                     let mut fds = unsafe { mem::zeroed::<c::fd_set>() };\n                     fds.fd_count = 1;\n-                    fds.fd_array[0] = self.0;\n+                    fds.fd_array[0] = self.as_raw_socket();\n                     fds\n                 };\n \n@@ -194,17 +199,19 @@ impl Socket {\n     }\n \n     pub fn accept(&self, storage: *mut c::SOCKADDR, len: *mut c_int) -> io::Result<Socket> {\n-        let socket = unsafe { c::accept(self.0, storage, len) };\n+        let socket = unsafe { c::accept(self.as_raw_socket(), storage, len) };\n \n         match socket {\n             c::INVALID_SOCKET => Err(last_error()),\n-            _ => Ok(Self(socket)),\n+            _ => unsafe { Ok(Self::from_raw_socket(socket)) },\n         }\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n         let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n-        let result = unsafe { c::WSADuplicateSocketW(self.0, c::GetCurrentProcessId(), &mut info) };\n+        let result = unsafe {\n+            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n+        };\n         cvt(result)?;\n         let socket = unsafe {\n             c::WSASocketW(\n@@ -218,7 +225,7 @@ impl Socket {\n         };\n \n         if socket != c::INVALID_SOCKET {\n-            Ok(Self(socket))\n+            unsafe { Ok(Self::from_inner(OwnedSocket::from_raw_socket(socket))) }\n         } else {\n             let error = unsafe { c::WSAGetLastError() };\n \n@@ -241,17 +248,20 @@ impl Socket {\n                 return Err(last_error());\n             }\n \n-            let socket = Self(socket);\n-            socket.set_no_inherit()?;\n-            Ok(socket)\n+            unsafe {\n+                let socket = Self::from_inner(OwnedSocket::from_raw_socket(socket));\n+                socket.set_no_inherit()?;\n+                Ok(socket)\n+            }\n         }\n     }\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n         let length = cmp::min(buf.len(), i32::MAX as usize) as i32;\n-        let result = unsafe { c::recv(self.0, buf.as_mut_ptr() as *mut _, length, flags) };\n+        let result =\n+            unsafe { c::recv(self.as_raw_socket(), buf.as_mut_ptr() as *mut _, length, flags) };\n \n         match result {\n             c::SOCKET_ERROR => {\n@@ -279,7 +289,7 @@ impl Socket {\n         let mut flags = 0;\n         let result = unsafe {\n             c::WSARecv(\n-                self.0,\n+                self.as_raw_socket(),\n                 bufs.as_mut_ptr() as *mut c::WSABUF,\n                 length,\n                 &mut nread,\n@@ -325,7 +335,7 @@ impl Socket {\n         // do the same on windows to map a shut down socket to returning EOF.\n         let result = unsafe {\n             c::recvfrom(\n-                self.0,\n+                self.as_raw_socket(),\n                 buf.as_mut_ptr() as *mut _,\n                 length,\n                 flags,\n@@ -361,7 +371,7 @@ impl Socket {\n         let mut nwritten = 0;\n         let result = unsafe {\n             c::WSASend(\n-                self.0,\n+                self.as_raw_socket(),\n                 bufs.as_ptr() as *const c::WSABUF as *mut _,\n                 length,\n                 &mut nwritten,\n@@ -408,8 +418,10 @@ impl Socket {\n \n     #[cfg(not(target_vendor = \"uwp\"))]\n     fn set_no_inherit(&self) -> io::Result<()> {\n-        sys::cvt(unsafe { c::SetHandleInformation(self.0 as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0) })\n-            .map(drop)\n+        sys::cvt(unsafe {\n+            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n+        })\n+        .map(drop)\n     }\n \n     #[cfg(target_vendor = \"uwp\")]\n@@ -423,13 +435,14 @@ impl Socket {\n             Shutdown::Read => c::SD_RECEIVE,\n             Shutdown::Both => c::SD_BOTH,\n         };\n-        let result = unsafe { c::shutdown(self.0, how) };\n+        let result = unsafe { c::shutdown(self.as_raw_socket(), how) };\n         cvt(result).map(drop)\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as c_ulong;\n-        let result = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n+        let result =\n+            unsafe { c::ioctlsocket(self.as_raw_socket(), c::FIONBIO as c_int, &mut nonblocking) };\n         cvt(result).map(drop)\n     }\n \n@@ -446,6 +459,11 @@ impl Socket {\n         let raw: c_int = net::getsockopt(self, c::SOL_SOCKET, c::SO_ERROR)?;\n         if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n     }\n+\n+    // This is used by sys_common code to abstract over Windows and Unix.\n+    pub fn as_raw(&self) -> RawSocket {\n+        self.as_inner().as_raw_socket()\n+    }\n }\n \n #[unstable(reason = \"not public\", issue = \"none\", feature = \"fd_read\")]\n@@ -455,28 +473,44 @@ impl<'a> Read for &'a Socket {\n     }\n }\n \n-impl Drop for Socket {\n-    fn drop(&mut self) {\n-        let _ = unsafe { c::closesocket(self.0) };\n+impl AsInner<OwnedSocket> for Socket {\n+    fn as_inner(&self) -> &OwnedSocket {\n+        &self.0\n     }\n }\n \n-impl AsInner<c::SOCKET> for Socket {\n-    fn as_inner(&self) -> &c::SOCKET {\n-        &self.0\n+impl FromInner<OwnedSocket> for Socket {\n+    fn from_inner(sock: OwnedSocket) -> Socket {\n+        Socket(sock)\n     }\n }\n \n-impl FromInner<c::SOCKET> for Socket {\n-    fn from_inner(sock: c::SOCKET) -> Socket {\n-        Socket(sock)\n+impl IntoInner<OwnedSocket> for Socket {\n+    fn into_inner(self) -> OwnedSocket {\n+        self.0\n+    }\n+}\n+\n+impl AsSocket for Socket {\n+    fn as_socket(&self) -> BorrowedSocket<'_> {\n+        self.0.as_socket()\n+    }\n+}\n+\n+impl AsRawSocket for Socket {\n+    fn as_raw_socket(&self) -> RawSocket {\n+        self.0.as_raw_socket()\n+    }\n+}\n+\n+impl IntoRawSocket for Socket {\n+    fn into_raw_socket(self) -> RawSocket {\n+        self.0.into_raw_socket()\n     }\n }\n \n-impl IntoInner<c::SOCKET> for Socket {\n-    fn into_inner(self) -> c::SOCKET {\n-        let ret = self.0;\n-        mem::forget(self);\n-        ret\n+impl FromRawSocket for Socket {\n+    unsafe fn from_raw_socket(raw_socket: RawSocket) -> Self {\n+        Self(FromRawSocket::from_raw_socket(raw_socket))\n     }\n }"}, {"sha": "883690c4831675b2b2c317a78275d87ac7acd9d8", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -288,7 +288,7 @@ fn home_dir_crt() -> Option<PathBuf> {\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n             return None;\n         }\n-        let _handle = Handle::new(token);\n+        let _handle = Handle::from_raw_handle(token);\n         super::fill_utf16_buf(\n             |buf, mut sz| {\n                 match c::GetUserProfileDirectoryW(token, buf, &mut sz) {"}, {"sha": "63d3d6c5ed42fc8659e1e6f621de4983a3ce197d", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -12,6 +12,7 @@ use crate::sys::c;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n use crate::sys::hashmap_random_keys;\n+use crate::sys_common::IntoInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n@@ -21,6 +22,12 @@ pub struct AnonPipe {\n     inner: Handle,\n }\n \n+impl IntoInner<Handle> for AnonPipe {\n+    fn into_inner(self) -> Handle {\n+        self.inner\n+    }\n+}\n+\n pub struct Pipes {\n     pub ours: AnonPipe,\n     pub theirs: AnonPipe,\n@@ -123,7 +130,7 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n                 }\n                 return Err(err);\n             }\n-            ours = Handle::new(handle);\n+            ours = Handle::from_raw_handle(handle);\n             break;\n         }\n \n@@ -146,11 +153,11 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n         };\n         opts.security_attributes(&mut sa);\n         let theirs = File::open(Path::new(&name), &opts)?;\n-        let theirs = AnonPipe { inner: theirs.into_handle() };\n+        let theirs = AnonPipe { inner: theirs.into_inner() };\n \n         Ok(Pipes {\n             ours: AnonPipe { inner: ours },\n-            theirs: AnonPipe { inner: theirs.into_handle() },\n+            theirs: AnonPipe { inner: theirs.into_inner() },\n         })\n     }\n }\n@@ -207,7 +214,7 @@ pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) ->\n \n     let mut p1 = AsyncPipe::new(p1, v1)?;\n     let mut p2 = AsyncPipe::new(p2, v2)?;\n-    let objs = [p1.event.raw(), p2.event.raw()];\n+    let objs = [p1.event.as_raw_handle(), p2.event.as_raw_handle()];\n \n     // In a loop we wait for either pipe's scheduled read operation to complete.\n     // If the operation completes with 0 bytes, that means EOF was reached, in\n@@ -262,7 +269,7 @@ impl<'a> AsyncPipe<'a> {\n         // I/O operation is successfully scheduled (what we want).\n         let event = Handle::new_event(true, true)?;\n         let mut overlapped: Box<c::OVERLAPPED> = unsafe { Box::new(mem::zeroed()) };\n-        overlapped.hEvent = event.raw();\n+        overlapped.hEvent = event.as_raw_handle();\n         Ok(AsyncPipe { pipe, overlapped, event, dst, state: State::NotReading })\n     }\n "}, {"sha": "ccff90629a37144598de7bbbda40812f41f01c9d", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -15,6 +15,7 @@ use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n use crate::num::NonZeroI32;\n use crate::os::windows::ffi::OsStrExt;\n+use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle};\n use crate::path::Path;\n use crate::ptr;\n use crate::sys::c;\n@@ -26,7 +27,7 @@ use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n-use crate::sys_common::AsInner;\n+use crate::sys_common::{AsInner, IntoInner};\n \n use libc::{c_void, EXIT_FAILURE, EXIT_SUCCESS};\n \n@@ -316,9 +317,9 @@ impl Command {\n         let stdin = stdin.to_handle(c::STD_INPUT_HANDLE, &mut pipes.stdin)?;\n         let stdout = stdout.to_handle(c::STD_OUTPUT_HANDLE, &mut pipes.stdout)?;\n         let stderr = stderr.to_handle(c::STD_ERROR_HANDLE, &mut pipes.stderr)?;\n-        si.hStdInput = stdin.raw();\n-        si.hStdOutput = stdout.raw();\n-        si.hStdError = stderr.raw();\n+        si.hStdInput = stdin.as_raw_handle();\n+        si.hStdOutput = stdout.as_raw_handle();\n+        si.hStdError = stderr.as_raw_handle();\n \n         unsafe {\n             cvt(c::CreateProcessW(\n@@ -338,9 +339,11 @@ impl Command {\n         // We close the thread handle because we don't care about keeping\n         // the thread id valid, and we aren't keeping the thread handle\n         // around to be able to close it later.\n-        drop(Handle::new(pi.hThread));\n+        unsafe {\n+            drop(Handle::from_raw_handle(pi.hThread));\n \n-        Ok((Process { handle: Handle::new(pi.hProcess) }, pipes))\n+            Ok((Process { handle: Handle::from_raw_handle(pi.hProcess) }, pipes))\n+        }\n     }\n }\n \n@@ -365,13 +368,13 @@ impl Stdio {\n             // should still be unavailable so propagate the\n             // INVALID_HANDLE_VALUE.\n             Stdio::Inherit => match stdio::get_handle(stdio_id) {\n-                Ok(io) => {\n-                    let io = Handle::new(io);\n+                Ok(io) => unsafe {\n+                    let io = Handle::from_raw_handle(io);\n                     let ret = io.duplicate(0, true, c::DUPLICATE_SAME_ACCESS);\n-                    io.into_raw();\n+                    io.into_raw_handle();\n                     ret\n-                }\n-                Err(..) => Ok(Handle::new(c::INVALID_HANDLE_VALUE)),\n+                },\n+                Err(..) => unsafe { Ok(Handle::from_raw_handle(c::INVALID_HANDLE_VALUE)) },\n             },\n \n             Stdio::MakePipe => {\n@@ -397,7 +400,7 @@ impl Stdio {\n                 opts.read(stdio_id == c::STD_INPUT_HANDLE);\n                 opts.write(stdio_id != c::STD_INPUT_HANDLE);\n                 opts.security_attributes(&mut sa);\n-                File::open(Path::new(\"NUL\"), &opts).map(|file| file.into_handle())\n+                File::open(Path::new(\"NUL\"), &opts).map(|file| file.into_inner())\n             }\n         }\n     }\n@@ -411,7 +414,7 @@ impl From<AnonPipe> for Stdio {\n \n impl From<File> for Stdio {\n     fn from(file: File) -> Stdio {\n-        Stdio::Handle(file.into_handle())\n+        Stdio::Handle(file.into_inner())\n     }\n }\n \n@@ -430,37 +433,37 @@ pub struct Process {\n \n impl Process {\n     pub fn kill(&mut self) -> io::Result<()> {\n-        cvt(unsafe { c::TerminateProcess(self.handle.raw(), 1) })?;\n+        cvt(unsafe { c::TerminateProcess(self.handle.as_raw_handle(), 1) })?;\n         Ok(())\n     }\n \n     pub fn id(&self) -> u32 {\n-        unsafe { c::GetProcessId(self.handle.raw()) as u32 }\n+        unsafe { c::GetProcessId(self.handle.as_raw_handle()) as u32 }\n     }\n \n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         unsafe {\n-            let res = c::WaitForSingleObject(self.handle.raw(), c::INFINITE);\n+            let res = c::WaitForSingleObject(self.handle.as_raw_handle(), c::INFINITE);\n             if res != c::WAIT_OBJECT_0 {\n                 return Err(Error::last_os_error());\n             }\n             let mut status = 0;\n-            cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n+            cvt(c::GetExitCodeProcess(self.handle.as_raw_handle(), &mut status))?;\n             Ok(ExitStatus(status))\n         }\n     }\n \n     pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n         unsafe {\n-            match c::WaitForSingleObject(self.handle.raw(), 0) {\n+            match c::WaitForSingleObject(self.handle.as_raw_handle(), 0) {\n                 c::WAIT_OBJECT_0 => {}\n                 c::WAIT_TIMEOUT => {\n                     return Ok(None);\n                 }\n                 _ => return Err(io::Error::last_os_error()),\n             }\n             let mut status = 0;\n-            cvt(c::GetExitCodeProcess(self.handle.raw(), &mut status))?;\n+            cvt(c::GetExitCodeProcess(self.handle.as_raw_handle(), &mut status))?;\n             Ok(Some(ExitStatus(status)))\n         }\n     }"}, {"sha": "1cf0e9f0cf1ea8e0cb66b633d327ce268ce4957d", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -3,6 +3,7 @@\n use crate::char::decode_utf16;\n use crate::cmp;\n use crate::io;\n+use crate::os::windows::io::{FromRawHandle, IntoRawHandle};\n use crate::ptr;\n use crate::str;\n use crate::sys::c;\n@@ -53,10 +54,12 @@ fn is_console(handle: c::HANDLE) -> bool {\n fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n     let handle = get_handle(handle_id)?;\n     if !is_console(handle) {\n-        let handle = Handle::new(handle);\n-        let ret = handle.write(data);\n-        handle.into_raw(); // Don't close the handle\n-        return ret;\n+        unsafe {\n+            let handle = Handle::from_raw_handle(handle);\n+            let ret = handle.write(data);\n+            handle.into_raw_handle(); // Don't close the handle\n+            return ret;\n+        }\n     }\n \n     // As the console is meant for presenting text, we assume bytes of `data` come from a string\n@@ -140,10 +143,12 @@ impl io::Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let handle = get_handle(c::STD_INPUT_HANDLE)?;\n         if !is_console(handle) {\n-            let handle = Handle::new(handle);\n-            let ret = handle.read(buf);\n-            handle.into_raw(); // Don't close the handle\n-            return ret;\n+            unsafe {\n+                let handle = Handle::from_raw_handle(handle);\n+                let ret = handle.read(buf);\n+                handle.into_raw_handle(); // Don't close the handle\n+                return ret;\n+            }\n         }\n \n         if buf.len() == 0 {"}, {"sha": "a5293133b3ab05d7ad97ace5c74ba10ae2b892b8", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -1,6 +1,7 @@\n use crate::ffi::CStr;\n use crate::io;\n use crate::num::NonZeroUsize;\n+use crate::os::windows::io::{AsRawHandle, FromRawHandle};\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n@@ -45,7 +46,7 @@ impl Thread {\n             drop(Box::from_raw(p));\n             Err(io::Error::last_os_error())\n         } else {\n-            Ok(Thread { handle: Handle::new(ret) })\n+            Ok(Thread { handle: Handle::from_raw_handle(ret) })\n         };\n \n         extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {\n@@ -71,7 +72,7 @@ impl Thread {\n     }\n \n     pub fn join(self) {\n-        let rc = unsafe { c::WaitForSingleObject(self.handle.raw(), c::INFINITE) };\n+        let rc = unsafe { c::WaitForSingleObject(self.handle.as_raw_handle(), c::INFINITE) };\n         if rc == c::WAIT_FAILED {\n             panic!(\"failed to join on thread: {}\", io::Error::last_os_error());\n         }"}, {"sha": "0ffa5c01dd33b546eaa9ee6ccba297d19ed859db", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521734787ecf80ff12df7ca5998f7ec0b3b7b2c9/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=521734787ecf80ff12df7ca5998f7ec0b3b7b2c9", "patch": "@@ -61,13 +61,7 @@ cfg_if::cfg_if! {\n pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int, payload: T) -> io::Result<()> {\n     unsafe {\n         let payload = &payload as *const T as *const c_void;\n-        cvt(c::setsockopt(\n-            *sock.as_inner(),\n-            opt,\n-            val,\n-            payload,\n-            mem::size_of::<T>() as c::socklen_t,\n-        ))?;\n+        cvt(c::setsockopt(sock.as_raw(), opt, val, payload, mem::size_of::<T>() as c::socklen_t))?;\n         Ok(())\n     }\n }\n@@ -76,7 +70,7 @@ pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int, val: c_int) -> io::Result<\n     unsafe {\n         let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as c::socklen_t;\n-        cvt(c::getsockopt(*sock.as_inner(), opt, val, &mut slot as *mut _ as *mut _, &mut len))?;\n+        cvt(c::getsockopt(sock.as_raw(), opt, val, &mut slot as *mut _ as *mut _, &mut len))?;\n         assert_eq!(len as usize, mem::size_of::<T>());\n         Ok(slot)\n     }\n@@ -217,7 +211,7 @@ impl TcpStream {\n         let sock = Socket::new(addr, c::SOCK_STREAM)?;\n \n         let (addrp, len) = addr.into_inner();\n-        cvt_r(|| unsafe { c::connect(*sock.as_inner(), addrp, len) })?;\n+        cvt_r(|| unsafe { c::connect(sock.as_raw(), addrp, len) })?;\n         Ok(TcpStream { inner: sock })\n     }\n \n@@ -273,7 +267,7 @@ impl TcpStream {\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n-            c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n+            c::send(self.inner.as_raw(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n         })?;\n         Ok(ret as usize)\n     }\n@@ -288,11 +282,11 @@ impl TcpStream {\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe { c::getpeername(*self.inner.as_inner(), buf, len) })\n+        sockname(|buf, len| unsafe { c::getpeername(self.inner.as_raw(), buf, len) })\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n+        sockname(|buf, len| unsafe { c::getsockname(self.inner.as_raw(), buf, len) })\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n@@ -348,7 +342,7 @@ impl fmt::Debug for TcpStream {\n         }\n \n         let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n-        res.field(name, &self.inner.as_inner()).finish()\n+        res.field(name, &self.inner.as_raw()).finish()\n     }\n }\n \n@@ -380,10 +374,10 @@ impl TcpListener {\n \n         // Bind our new socket\n         let (addrp, len) = addr.into_inner();\n-        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len as _) })?;\n+        cvt(unsafe { c::bind(sock.as_raw(), addrp, len as _) })?;\n \n         // Start listening\n-        cvt(unsafe { c::listen(*sock.as_inner(), 128) })?;\n+        cvt(unsafe { c::listen(sock.as_raw(), 128) })?;\n         Ok(TcpListener { inner: sock })\n     }\n \n@@ -396,7 +390,7 @@ impl TcpListener {\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n+        sockname(|buf, len| unsafe { c::getsockname(self.inner.as_raw(), buf, len) })\n     }\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n@@ -453,7 +447,7 @@ impl fmt::Debug for TcpListener {\n         }\n \n         let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n-        res.field(name, &self.inner.as_inner()).finish()\n+        res.field(name, &self.inner.as_raw()).finish()\n     }\n }\n \n@@ -473,7 +467,7 @@ impl UdpSocket {\n \n         let sock = Socket::new(addr, c::SOCK_DGRAM)?;\n         let (addrp, len) = addr.into_inner();\n-        cvt(unsafe { c::bind(*sock.as_inner(), addrp, len as _) })?;\n+        cvt(unsafe { c::bind(sock.as_raw(), addrp, len as _) })?;\n         Ok(UdpSocket { inner: sock })\n     }\n \n@@ -486,11 +480,11 @@ impl UdpSocket {\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe { c::getpeername(*self.inner.as_inner(), buf, len) })\n+        sockname(|buf, len| unsafe { c::getpeername(self.inner.as_raw(), buf, len) })\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        sockname(|buf, len| unsafe { c::getsockname(*self.inner.as_inner(), buf, len) })\n+        sockname(|buf, len| unsafe { c::getsockname(self.inner.as_raw(), buf, len) })\n     }\n \n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n@@ -506,7 +500,7 @@ impl UdpSocket {\n         let (dstp, dstlen) = dst.into_inner();\n         let ret = cvt(unsafe {\n             c::sendto(\n-                *self.inner.as_inner(),\n+                self.inner.as_raw(),\n                 buf.as_ptr() as *const c_void,\n                 len,\n                 MSG_NOSIGNAL,\n@@ -643,14 +637,14 @@ impl UdpSocket {\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n         let ret = cvt(unsafe {\n-            c::send(*self.inner.as_inner(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n+            c::send(self.inner.as_raw(), buf.as_ptr() as *const c_void, len, MSG_NOSIGNAL)\n         })?;\n         Ok(ret as usize)\n     }\n \n     pub fn connect(&self, addr: io::Result<&SocketAddr>) -> io::Result<()> {\n         let (addrp, len) = addr?.into_inner();\n-        cvt_r(|| unsafe { c::connect(*self.inner.as_inner(), addrp, len) }).map(drop)\n+        cvt_r(|| unsafe { c::connect(self.inner.as_raw(), addrp, len) }).map(drop)\n     }\n }\n \n@@ -669,6 +663,6 @@ impl fmt::Debug for UdpSocket {\n         }\n \n         let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n-        res.field(name, &self.inner.as_inner()).finish()\n+        res.field(name, &self.inner.as_raw()).finish()\n     }\n }"}]}