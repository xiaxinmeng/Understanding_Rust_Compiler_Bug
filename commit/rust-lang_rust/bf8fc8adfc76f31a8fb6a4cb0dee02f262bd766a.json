{"sha": "bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmOGZjOGFkZmM3NmYzMWE4ZmI2YTRjYjBkZWUwMmYyNjJiZDc2NmE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T23:51:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-24T09:29:45Z"}, "message": "syntax_ext: Improve and simplify code generated by `#[global_allocator]`\n\nInstead of\n```\nmod allocator_abi { /* methods */ }\n```\nwe now generate\n```\nconst _: () = { /* methods */ }\n```\nand use `std_path` for paths referring to standard library entities.\n\nThis way we no longer need to generate `use` and `extern crate` imports, and `#[global_allocator]` starts working inside unnamed blocks.", "tree": {"sha": "a8da70f217469424dbb22c71cc9bdbb3e1a137ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8da70f217469424dbb22c71cc9bdbb3e1a137ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "html_url": "https://github.com/rust-lang/rust/commit/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76b1ffaf6c70abd3fa4da2e694dc709116258098", "url": "https://api.github.com/repos/rust-lang/rust/commits/76b1ffaf6c70abd3fa4da2e694dc709116258098", "html_url": "https://github.com/rust-lang/rust/commit/76b1ffaf6c70abd3fa4da2e694dc709116258098"}], "stats": {"total": 95, "additions": 34, "deletions": 61}, "files": [{"sha": "71c9e6cd23d443995887534cda8c390b646b0df9", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "patch": "@@ -1,13 +1,12 @@\n-use syntax::ast::{ItemKind, Mutability, Ty, TyKind, Unsafety, VisibilityKind};\n-use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident, Item};\n+use syntax::ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafety};\n+use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n-use syntax::source_map::respan;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n pub fn expand(\n@@ -36,52 +35,31 @@ pub fn expand(\n         span,\n         kind: AllocatorKind::Global,\n         global: item.ident,\n-        core: Ident::with_empty_ctxt(sym::core),\n         cx: ecx,\n     };\n \n-    // We will generate a new submodule. To `use` the static from that module, we need to get\n-    // the `super::...` path.\n-    let super_path = f.cx.path(f.span, vec![Ident::with_empty_ctxt(kw::Super), f.global]);\n-\n-    // Generate the items in the submodule\n-    let mut items = vec![\n-        // import `core` to use allocators\n-        f.cx.item_extern_crate(f.span, f.core),\n-        // `use` the `global_allocator` in `super`\n-        f.cx.item_use_simple(\n-            f.span,\n-            respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n-            super_path,\n-        ),\n-    ];\n-\n-    // Add the allocator methods to the submodule\n-    items.extend(\n-        ALLOCATOR_METHODS\n-            .iter()\n-            .map(|method| f.allocator_fn(method)),\n-    );\n+    // Generate item statements for the allocator methods.\n+    let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n \n-    // Generate the submodule itself\n-    let name = f.kind.fn_name(\"allocator_abi\");\n-    let allocator_abi = Ident::from_str(&name).gensym();\n-    let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item =\n+        ecx.item_const(span, Ident::with_empty_ctxt(kw::Underscore), const_ty, const_body);\n \n-    // Return the item and new submodule\n-    vec![Annotatable::Item(item), Annotatable::Item(module)]\n+    // Return the original item and the new methods.\n+    vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n }\n \n struct AllocFnFactory<'a, 'b> {\n     span: Span,\n     kind: AllocatorKind,\n     global: Ident,\n-    core: Ident,\n     cx: &'b ExtCtxt<'a>,\n }\n \n impl AllocFnFactory<'_, '_> {\n-    fn allocator_fn(&self, method: &AllocatorMethod) -> P<Item> {\n+    fn allocator_fn(&self, method: &AllocatorMethod) -> Stmt {\n         let mut abi_args = Vec::new();\n         let mut i = 0;\n         let ref mut mk = || {\n@@ -105,25 +83,22 @@ impl AllocFnFactory<'_, '_> {\n             Generics::default(),\n             self.cx.block_expr(output_expr),\n         );\n-        self.cx.item(\n+        let item = self.cx.item(\n             self.span,\n             Ident::from_str(&self.kind.fn_name(method.name)),\n             self.attrs(),\n             kind,\n-        )\n+        );\n+        self.cx.stmt_item(self.span, item)\n     }\n \n     fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n-        let method = self.cx.path(\n-            self.span,\n-            vec![\n-                self.core,\n-                Ident::from_str(\"alloc\"),\n-                Ident::from_str(\"GlobalAlloc\"),\n-                Ident::from_str(method),\n-            ],\n-        );\n-        let method = self.cx.expr_path(method);\n+        let method = self.cx.std_path(&[\n+            Symbol::intern(\"alloc\"),\n+            Symbol::intern(\"GlobalAlloc\"),\n+            Symbol::intern(method),\n+        ]);\n+        let method = self.cx.expr_path(self.cx.path(self.span, method));\n         let allocator = self.cx.path_ident(self.span, self.global);\n         let allocator = self.cx.expr_path(allocator);\n         let allocator = self.cx.expr_addr_of(self.span, allocator);\n@@ -153,16 +128,12 @@ impl AllocFnFactory<'_, '_> {\n                 args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n                 args.push(self.cx.arg(self.span, align, ty_usize));\n \n-                let layout_new = self.cx.path(\n-                    self.span,\n-                    vec![\n-                        self.core,\n-                        Ident::from_str(\"alloc\"),\n-                        Ident::from_str(\"Layout\"),\n-                        Ident::from_str(\"from_size_align_unchecked\"),\n-                    ],\n-                );\n-                let layout_new = self.cx.expr_path(layout_new);\n+                let layout_new = self.cx.std_path(&[\n+                    Symbol::intern(\"alloc\"),\n+                    Symbol::intern(\"Layout\"),\n+                    Symbol::intern(\"from_size_align_unchecked\"),\n+                ]);\n+                let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n                 let size = self.cx.expr_ident(self.span, size);\n                 let align = self.cx.expr_ident(self.span, align);\n                 let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);"}, {"sha": "12813a1fc8bd4088818ab205bd9035ffe94b6e02", "filename": "src/test/run-pass/allocator/custom-in-block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs?ref=bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "patch": "@@ -13,9 +13,10 @@ fn main() {\n     #[global_allocator]\n     pub static GLOBAL: A = A(AtomicUsize::new(0));\n \n+    let n = GLOBAL.0.load(Ordering::SeqCst);\n     let s = Box::new(0);\n     helper::work_with(&s);\n-    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 1);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n     drop(s);\n-    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 2);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n }"}, {"sha": "ea341b1ac14aeee096f1340fa316f50d39752a0b", "filename": "src/test/run-pass/allocator/custom-in-submodule.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs?ref=bf8fc8adfc76f31a8fb6a4cb0dee02f262bd766a", "patch": "@@ -17,9 +17,10 @@ mod submodule {\n }\n \n fn main() {\n+    let n = submodule::GLOBAL.0.load(Ordering::SeqCst);\n     let s = Box::new(0);\n     helper::work_with(&s);\n-    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), 1);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), n + 1);\n     drop(s);\n-    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), 2);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), n + 2);\n }"}]}