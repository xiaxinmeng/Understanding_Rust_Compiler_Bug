{"sha": "211fb66810c978576201bb2054f1ccea0e176f10", "node_id": "C_kwDOAAsO6NoAKDIxMWZiNjY4MTBjOTc4NTc2MjAxYmIyMDU0ZjFjY2VhMGUxNzZmMTA", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-06-03T20:47:05Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-07-06T18:02:45Z"}, "message": "Fix stacked borrows violation in rustc_arena\n\nThere was a problem with storing a `Box<T>` in a struct, where\nthe current rules would invalidate the value. this makes it store\na raw pointer instead, circumventing the aliasing problems.", "tree": {"sha": "58f6a23d0d4aef030abb0dcd9db29e3e5b0b2079", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58f6a23d0d4aef030abb0dcd9db29e3e5b0b2079"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/211fb66810c978576201bb2054f1ccea0e176f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/211fb66810c978576201bb2054f1ccea0e176f10", "html_url": "https://github.com/rust-lang/rust/commit/211fb66810c978576201bb2054f1ccea0e176f10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/211fb66810c978576201bb2054f1ccea0e176f10/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "907ea5584173464b31326480dd11d9a71cbd4141", "url": "https://api.github.com/repos/rust-lang/rust/commits/907ea5584173464b31326480dd11d9a71cbd4141", "html_url": "https://github.com/rust-lang/rust/commit/907ea5584173464b31326480dd11d9a71cbd4141"}], "stats": {"total": 27, "additions": 19, "deletions": 8}, "files": [{"sha": "a5f1cbc96daa7ea19a1151f27924eb067290b32e", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/211fb66810c978576201bb2054f1ccea0e176f10/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211fb66810c978576201bb2054f1ccea0e176f10/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=211fb66810c978576201bb2054f1ccea0e176f10", "patch": "@@ -19,6 +19,7 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n+#![feature(ptr_const_cast)]\n \n use smallvec::SmallVec;\n \n@@ -27,7 +28,7 @@ use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::marker::{PhantomData, Send};\n use std::mem::{self, MaybeUninit};\n-use std::ptr;\n+use std::ptr::{self, NonNull};\n use std::slice;\n \n #[inline(never)]\n@@ -55,15 +56,24 @@ pub struct TypedArena<T> {\n \n struct ArenaChunk<T = u8> {\n     /// The raw storage for the arena chunk.\n-    storage: Box<[MaybeUninit<T>]>,\n+    storage: NonNull<[MaybeUninit<T>]>,\n     /// The number of valid entries in the chunk.\n     entries: usize,\n }\n \n+unsafe impl<#[may_dangle] T> Drop for ArenaChunk<T> {\n+    fn drop(&mut self) {\n+        unsafe { Box::from_raw(self.storage.as_mut()) };\n+    }\n+}\n+\n impl<T> ArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n-        ArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n+        ArenaChunk {\n+            storage: NonNull::new(Box::into_raw(Box::new_uninit_slice(capacity))).unwrap(),\n+            entries: 0,\n+        }\n     }\n \n     /// Destroys this arena chunk.\n@@ -72,14 +82,15 @@ impl<T> ArenaChunk<T> {\n         // The branch on needs_drop() is an -O1 performance optimization.\n         // Without the branch, dropping TypedArena<u8> takes linear time.\n         if mem::needs_drop::<T>() {\n-            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut self.storage[..len]));\n+            let slice = &mut *(self.storage.as_mut());\n+            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n         }\n     }\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n     fn start(&mut self) -> *mut T {\n-        MaybeUninit::slice_as_mut_ptr(&mut self.storage)\n+        self.storage.as_ptr() as *mut T\n     }\n \n     // Returns a pointer to the end of the allocated space.\n@@ -90,7 +101,7 @@ impl<T> ArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 ptr::invalid_mut(!0)\n             } else {\n-                self.start().add(self.storage.len())\n+                self.start().add((*self.storage.as_ptr()).len())\n             }\n         }\n     }\n@@ -274,7 +285,7 @@ impl<T> TypedArena<T> {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n+                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / elem_size / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n@@ -382,7 +393,7 @@ impl DroplessArena {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n+                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE;"}]}