{"sha": "baaa3b682986879c7784b5733ecea942e9ae7de3", "node_id": "C_kwDOAAsO6NoAKGJhYWEzYjY4Mjk4Njg3OWM3Nzg0YjU3MzNlY2VhOTQyZTlhZTdkZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-28T21:58:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-28T21:58:08Z"}, "message": "Auto merge of #96393 - joboet:pthread_parker, r=thomcc\n\nstd: directly use pthread in UNIX parker implementation\n\n`Mutex` and `Condvar` are being replaced by more efficient implementations, which need thread parking themselves (see #93740). Therefore we should use the `pthread` synchronization primitives directly. Also, we can avoid allocating the mutex and condition variable because the `Parker` struct is being placed in an `Arc` anyways.\n\nThis basically is just a copy of the current `Mutex` and `Condvar` code, which will however be removed (again, see #93740). An alternative implementation could be to use dedicated private `OsMutex` and `OsCondvar` types, but all the other platforms supported by std actually have their own thread parking primitives.\n\nI used `Pin` to guarantee a stable address for the `Parker` struct, while the current implementation does not, rather using extra unsafe declaration. Since the thread struct is shared anyways, I assumed this would not add too much clutter while being clearer.", "tree": {"sha": "c044cb80f3dbe8cbc0ce7e767676dd26f6737ccb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c044cb80f3dbe8cbc0ce7e767676dd26f6737ccb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baaa3b682986879c7784b5733ecea942e9ae7de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baaa3b682986879c7784b5733ecea942e9ae7de3", "html_url": "https://github.com/rust-lang/rust/commit/baaa3b682986879c7784b5733ecea942e9ae7de3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baaa3b682986879c7784b5733ecea942e9ae7de3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e85edd9a844b523a02dbd89f3c02cd13e4c9fe46", "url": "https://api.github.com/repos/rust-lang/rust/commits/e85edd9a844b523a02dbd89f3c02cd13e4c9fe46", "html_url": "https://github.com/rust-lang/rust/commit/e85edd9a844b523a02dbd89f3c02cd13e4c9fe46"}, {"sha": "1285fb746649dbad417733a4741cb98e88a497f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1285fb746649dbad417733a4741cb98e88a497f3", "html_url": "https://github.com/rust-lang/rust/commit/1285fb746649dbad417733a4741cb98e88a497f3"}], "stats": {"total": 368, "additions": 337, "deletions": 31}, "files": [{"sha": "8e909aab7f0cabae9793bac4e96677253e5947df", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -39,6 +39,7 @@ pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n \n #[cfg(target_os = \"espidf\")]"}, {"sha": "fd83f2f73d6d66d8ccff49bf8265e5fe5946dc3d", "filename": "library/std/src/sys/unix/thread_parker.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -0,0 +1,265 @@\n+//! Thread parking without `futex` using the `pthread` synchronization primitives.\n+\n+#![cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    all(target_os = \"emscripten\", target_feature = \"atomics\")\n+)))]\n+\n+use crate::cell::UnsafeCell;\n+use crate::marker::PhantomPinned;\n+use crate::pin::Pin;\n+use crate::ptr::addr_of_mut;\n+use crate::sync::atomic::AtomicUsize;\n+use crate::sync::atomic::Ordering::SeqCst;\n+use crate::time::Duration;\n+\n+const EMPTY: usize = 0;\n+const PARKED: usize = 1;\n+const NOTIFIED: usize = 2;\n+\n+unsafe fn lock(lock: *mut libc::pthread_mutex_t) {\n+    let r = libc::pthread_mutex_lock(lock);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+unsafe fn unlock(lock: *mut libc::pthread_mutex_t) {\n+    let r = libc::pthread_mutex_unlock(lock);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+unsafe fn notify_one(cond: *mut libc::pthread_cond_t) {\n+    let r = libc::pthread_cond_signal(cond);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+unsafe fn wait(cond: *mut libc::pthread_cond_t, lock: *mut libc::pthread_mutex_t) {\n+    let r = libc::pthread_cond_wait(cond, lock);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n+\n+unsafe fn wait_timeout(\n+    cond: *mut libc::pthread_cond_t,\n+    lock: *mut libc::pthread_mutex_t,\n+    dur: Duration,\n+) {\n+    // Use the system clock on systems that do not support pthread_condattr_setclock.\n+    // This unfortunately results in problems when the system time changes.\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"espidf\"))]\n+    let (now, dur) = {\n+        use super::time::SystemTime;\n+        use crate::cmp::min;\n+\n+        // OSX implementation of `pthread_cond_timedwait` is buggy\n+        // with super long durations. When duration is greater than\n+        // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+        // in macOS Sierra return error 316.\n+        //\n+        // This program demonstrates the issue:\n+        // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+        //\n+        // To work around this issue, and possible bugs of other OSes, timeout\n+        // is clamped to 1000 years, which is allowable per the API of `park_timeout`\n+        // because of spurious wakeups.\n+        let dur = min(dur, Duration::from_secs(1000 * 365 * 86400));\n+        let now = SystemTime::now().t;\n+        (now, dur)\n+    };\n+    // Use the monotonic clock on other systems.\n+    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"espidf\")))]\n+    let (now, dur) = {\n+        use super::time::Timespec;\n+\n+        (Timespec::now(libc::CLOCK_MONOTONIC), dur)\n+    };\n+\n+    let timeout = now.checked_add_duration(&dur).map(|t| t.t).unwrap_or(TIMESPEC_MAX);\n+    let r = libc::pthread_cond_timedwait(cond, lock, &timeout);\n+    debug_assert!(r == libc::ETIMEDOUT || r == 0);\n+}\n+\n+pub struct Parker {\n+    state: AtomicUsize,\n+    lock: UnsafeCell<libc::pthread_mutex_t>,\n+    cvar: UnsafeCell<libc::pthread_cond_t>,\n+    // The `pthread` primitives require a stable address, so make this struct `!Unpin`.\n+    _pinned: PhantomPinned,\n+}\n+\n+impl Parker {\n+    /// Construct the UNIX parker in-place.\n+    ///\n+    /// # Safety\n+    /// The constructed parker must never be moved.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        // Use the default mutex implementation to allow for simpler initialization.\n+        // This could lead to undefined behaviour when deadlocking. This is avoided\n+        // by not deadlocking. Note in particular the unlocking operation before any\n+        // panic, as code after the panic could try to park again.\n+        addr_of_mut!((*parker).state).write(AtomicUsize::new(EMPTY));\n+        addr_of_mut!((*parker).lock).write(UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER));\n+\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+                target_os = \"l4re\",\n+                target_os = \"android\",\n+                target_os = \"redox\"\n+            ))] {\n+                addr_of_mut!((*parker).cvar).write(UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER));\n+            } else if #[cfg(target_os = \"espidf\")] {\n+                let r = libc::pthread_cond_init(addr_of_mut!((*parker).cvar).cast(), crate::ptr::null());\n+                assert_eq!(r, 0);\n+            } else {\n+                use crate::mem::MaybeUninit;\n+                let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n+                let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n+                assert_eq!(r, 0);\n+                let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n+                assert_eq!(r, 0);\n+                let r = libc::pthread_cond_init(addr_of_mut!((*parker).cvar).cast(), attr.as_ptr());\n+                assert_eq!(r, 0);\n+                let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n+                assert_eq!(r, 0);\n+            }\n+        }\n+    }\n+\n+    // This implementation doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // If we were previously notified then we consume this notification and\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        // Otherwise we need to coordinate going to sleep\n+        lock(self.lock.get());\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read here, even though we know it will be `NOTIFIED`.\n+                // This is because `unpark` may have been called again since we read\n+                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+                // acquire operation that synchronizes with that `unpark` to observe\n+                // any writes it made before the call to unpark. To do that we must\n+                // read from the write it made to `state`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+\n+                unlock(self.lock.get());\n+\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => {\n+                unlock(self.lock.get());\n+\n+                panic!(\"inconsistent park state\")\n+            }\n+        }\n+\n+        loop {\n+            wait(self.cvar.get(), self.lock.get());\n+\n+            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n+                Ok(_) => break, // got a notification\n+                Err(_) => {}    // spurious wakeup, go back to sleep\n+            }\n+        }\n+\n+        unlock(self.lock.get());\n+    }\n+\n+    // This implementation doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker. Use\n+    // `Pin` to guarantee a stable address for the mutex and condition variable.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        // Like `park` above we have a fast path for an already-notified thread, and\n+        // afterwards we start coordinating for a sleep.\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        lock(self.lock.get());\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read again here, see `park`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                unlock(self.lock.get());\n+\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => {\n+                unlock(self.lock.get());\n+                panic!(\"inconsistent park_timeout state\")\n+            }\n+        }\n+\n+        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n+        // from a notification we just want to unconditionally set the state back to\n+        // empty, either consuming a notification or un-flagging ourselves as\n+        // parked.\n+        wait_timeout(self.cvar.get(), self.lock.get(), dur);\n+\n+        match self.state.swap(EMPTY, SeqCst) {\n+            NOTIFIED => unlock(self.lock.get()), // got a notification, hurray!\n+            PARKED => unlock(self.lock.get()),   // no notification, alas\n+            n => {\n+                unlock(self.lock.get());\n+                panic!(\"inconsistent park_timeout state: {n}\")\n+            }\n+        }\n+    }\n+\n+    pub fn unpark(self: Pin<&Self>) {\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n+        match self.state.swap(NOTIFIED, SeqCst) {\n+            EMPTY => return,    // no one was waiting\n+            NOTIFIED => return, // already unparked\n+            PARKED => {}        // gotta go wake someone up\n+            _ => panic!(\"inconsistent state in unpark\"),\n+        }\n+\n+        // There is a period between when the parked thread sets `state` to\n+        // `PARKED` (or last checked `state` in the case of a spurious wake\n+        // up) and when it actually waits on `cvar`. If we were to notify\n+        // during this period it would be ignored and then when the parked\n+        // thread went to sleep it would never wake up. Fortunately, it has\n+        // `lock` locked at this stage so we can acquire `lock` to wait until\n+        // it is ready to receive the notification.\n+        //\n+        // Releasing `lock` before the call to `notify_one` means that when the\n+        // parked thread wakes it doesn't get woken only to have to wait for us\n+        // to release `lock`.\n+        unsafe {\n+            lock(self.lock.get());\n+            unlock(self.lock.get());\n+            notify_one(self.cvar.get());\n+        }\n+    }\n+}\n+\n+impl Drop for Parker {\n+    fn drop(&mut self) {\n+        unsafe {\n+            libc::pthread_cond_destroy(self.cvar.get_mut());\n+            libc::pthread_mutex_destroy(self.lock.get_mut());\n+        }\n+    }\n+}\n+\n+unsafe impl Sync for Parker {}\n+unsafe impl Send for Parker {}"}, {"sha": "d43ceec9c8a59528d617e20f0054455f4b5fadc7", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -132,7 +132,7 @@ mod inner {\n \n     #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     pub struct SystemTime {\n-        t: Timespec,\n+        pub(in crate::sys::unix) t: Timespec,\n     }\n \n     pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n@@ -279,7 +279,7 @@ mod inner {\n \n     #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n     pub struct SystemTime {\n-        t: Timespec,\n+        pub(in crate::sys::unix) t: Timespec,\n     }\n \n     pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };"}, {"sha": "5144834447503414a9ea832e1b9b930ff1d44dd9", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -58,6 +58,7 @@\n // [4]: Windows Internals, Part 1, ISBN 9780735671300\n \n use crate::convert::TryFrom;\n+use crate::pin::Pin;\n use crate::ptr;\n use crate::sync::atomic::{\n     AtomicI8, AtomicPtr,\n@@ -95,13 +96,16 @@ const NOTIFIED: i8 = 1;\n // Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n // Ordering::Acquire when reading this state in park() after waking up.\n impl Parker {\n-    pub fn new() -> Self {\n-        Self { state: AtomicI8::new(EMPTY) }\n+    /// Construct the Windows parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Self { state: AtomicI8::new(EMPTY) });\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n-    // which means that `self.state != PARKED`.\n-    pub unsafe fn park(&self) {\n+    // which means that `self.state != PARKED`. This implementation doesn't require `Pin`,\n+    // but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -132,8 +136,9 @@ impl Parker {\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n-    // which means that `self.state != PARKED`.\n-    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+    // which means that `self.state != PARKED`. This implementation doesn't require `Pin`,\n+    // but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -184,7 +189,8 @@ impl Parker {\n         }\n     }\n \n-    pub fn unpark(&self) {\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n         // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n         // wake the thread in the first case.\n         //"}, {"sha": "d9e2f39e3451848bea88a071b3a293d24b82e517", "filename": "library/std/src/sys_common/thread_parker/futex.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -1,3 +1,4 @@\n+use crate::pin::Pin;\n use crate::sync::atomic::AtomicU32;\n use crate::sync::atomic::Ordering::{Acquire, Release};\n use crate::sys::futex::{futex_wait, futex_wake};\n@@ -32,14 +33,15 @@ pub struct Parker {\n // Ordering::Release when writing NOTIFIED (the 'token') in unpark(), and using\n // Ordering::Acquire when checking for this state in park().\n impl Parker {\n-    #[inline]\n-    pub const fn new() -> Self {\n-        Parker { state: AtomicU32::new(EMPTY) }\n+    /// Construct the futex parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Self { state: AtomicU32::new(EMPTY) });\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n     // which means that `self.state != PARKED`.\n-    pub unsafe fn park(&self) {\n+    pub unsafe fn park(self: Pin<&Self>) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -58,8 +60,9 @@ impl Parker {\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,\n-    // which means that `self.state != PARKED`.\n-    pub unsafe fn park_timeout(&self, timeout: Duration) {\n+    // which means that `self.state != PARKED`. This implementation doesn't\n+    // require `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, timeout: Duration) {\n         // Change NOTIFIED=>EMPTY or EMPTY=>PARKED, and directly return in the\n         // first case.\n         if self.state.fetch_sub(1, Acquire) == NOTIFIED {\n@@ -78,8 +81,9 @@ impl Parker {\n         }\n     }\n \n+    // This implementation doesn't require `Pin`, but other implementations do.\n     #[inline]\n-    pub fn unpark(&self) {\n+    pub fn unpark(self: Pin<&Self>) {\n         // Change PARKED=>NOTIFIED, EMPTY=>NOTIFIED, or NOTIFIED=>NOTIFIED, and\n         // wake the thread in the first case.\n         //"}, {"sha": "f3d8b34d3fd39279b20887f50081e2788b65f470", "filename": "library/std/src/sys_common/thread_parker/generic.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fgeneric.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -1,5 +1,6 @@\n //! Parker implementation based on a Mutex and Condvar.\n \n+use crate::pin::Pin;\n use crate::sync::atomic::AtomicUsize;\n use crate::sync::atomic::Ordering::SeqCst;\n use crate::sync::{Condvar, Mutex};\n@@ -16,13 +17,18 @@ pub struct Parker {\n }\n \n impl Parker {\n-    pub fn new() -> Self {\n-        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n+    /// Construct the generic parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker {\n+            state: AtomicUsize::new(EMPTY),\n+            lock: Mutex::new(()),\n+            cvar: Condvar::new(),\n+        });\n     }\n \n-    // This implementation doesn't require `unsafe`, but other implementations\n-    // may assume this is only called by the thread that owns the Parker.\n-    pub unsafe fn park(&self) {\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n         // If we were previously notified then we consume this notification and\n         // return quickly.\n         if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n@@ -55,9 +61,8 @@ impl Parker {\n         }\n     }\n \n-    // This implementation doesn't require `unsafe`, but other implementations\n-    // may assume this is only called by the thread that owns the Parker.\n-    pub unsafe fn park_timeout(&self, dur: Duration) {\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n         // Like `park` above we have a fast path for an already-notified thread, and\n         // afterwards we start coordinating for a sleep.\n         // return quickly.\n@@ -88,7 +93,8 @@ impl Parker {\n         }\n     }\n \n-    pub fn unpark(&self) {\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n         // To ensure the unparked thread will observe any writes we made\n         // before this call, we must perform a release operation that `park`\n         // can synchronize with. To do that we must write `NOTIFIED` even if"}, {"sha": "ea0204cd357ba5605b5b253a89dd8945e43e743a", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -8,6 +8,8 @@ cfg_if::cfg_if! {\n         pub use futex::Parker;\n     } else if #[cfg(windows)] {\n         pub use crate::sys::thread_parker::Parker;\n+    } else if #[cfg(target_family = \"unix\")] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}, {"sha": "99da5f7a87e15eec196312e22f5baf5b1fc14751", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -163,6 +163,8 @@ use crate::num::NonZeroU64;\n use crate::num::NonZeroUsize;\n use crate::panic;\n use crate::panicking;\n+use crate::pin::Pin;\n+use crate::ptr::addr_of_mut;\n use crate::str;\n use crate::sync::Arc;\n use crate::sys::thread as imp;\n@@ -923,7 +925,7 @@ pub fn sleep(dur: Duration) {\n pub fn park() {\n     // SAFETY: park_timeout is called on the parker owned by this thread.\n     unsafe {\n-        current().inner.parker.park();\n+        current().inner.as_ref().parker().park();\n     }\n }\n \n@@ -987,7 +989,7 @@ pub fn park_timeout_ms(ms: u32) {\n pub fn park_timeout(dur: Duration) {\n     // SAFETY: park_timeout is called on the parker owned by this thread.\n     unsafe {\n-        current().inner.parker.park_timeout(dur);\n+        current().inner.as_ref().parker().park_timeout(dur);\n     }\n }\n \n@@ -1073,6 +1075,12 @@ struct Inner {\n     parker: Parker,\n }\n \n+impl Inner {\n+    fn parker(self: Pin<&Self>) -> Pin<&Parker> {\n+        unsafe { Pin::map_unchecked(self, |inner| &inner.parker) }\n+    }\n+}\n+\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n /// A handle to a thread.\n@@ -1094,14 +1102,28 @@ struct Inner {\n ///\n /// [`thread::current`]: current\n pub struct Thread {\n-    inner: Arc<Inner>,\n+    inner: Pin<Arc<Inner>>,\n }\n \n impl Thread {\n     // Used only internally to construct a thread object without spawning\n     // Panics if the name contains nuls.\n     pub(crate) fn new(name: Option<CString>) -> Thread {\n-        Thread { inner: Arc::new(Inner { name, id: ThreadId::new(), parker: Parker::new() }) }\n+        // We have to use `unsafe` here to constuct the `Parker` in-place,\n+        // which is required for the UNIX implementation.\n+        //\n+        // SAFETY: We pin the Arc immediately after creation, so its address never\n+        // changes.\n+        let inner = unsafe {\n+            let mut arc = Arc::<Inner>::new_uninit();\n+            let ptr = Arc::get_mut_unchecked(&mut arc).as_mut_ptr();\n+            addr_of_mut!((*ptr).name).write(name);\n+            addr_of_mut!((*ptr).id).write(ThreadId::new());\n+            Parker::new(addr_of_mut!((*ptr).parker));\n+            Pin::new_unchecked(arc.assume_init())\n+        };\n+\n+        Thread { inner }\n     }\n \n     /// Atomically makes the handle's token available if it is not already.\n@@ -1137,7 +1159,7 @@ impl Thread {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn unpark(&self) {\n-        self.inner.parker.unpark();\n+        self.inner.as_ref().parker().unpark();\n     }\n \n     /// Gets the thread's unique identifier."}, {"sha": "388d50c5cdc43627eae454d9abea881bf3d6c2a5", "filename": "src/test/debuginfo/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/baaa3b682986879c7784b5733ecea942e9ae7de3/src%2Ftest%2Fdebuginfo%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baaa3b682986879c7784b5733ecea942e9ae7de3/src%2Ftest%2Fdebuginfo%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fthread.rs?ref=baaa3b682986879c7784b5733ecea942e9ae7de3", "patch": "@@ -14,7 +14,7 @@\n //\n // cdb-command:dx t,d\n // cdb-check:t,d              : [...] [Type: std::thread::Thread *]\n-// cdb-check:    [...] inner            : {...} [Type: alloc::sync::Arc<std::thread::Inner>]\n+// cdb-check:[...] inner [...][Type: core::pin::Pin<alloc::sync::Arc<std::thread::Inner> >]\n \n use std::thread;\n "}]}