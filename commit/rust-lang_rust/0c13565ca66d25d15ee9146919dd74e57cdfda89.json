{"sha": "0c13565ca66d25d15ee9146919dd74e57cdfda89", "node_id": "C_kwDOAAsO6NoAKDBjMTM1NjVjYTY2ZDI1ZDE1ZWU5MTQ2OTE5ZGQ3NGU1N2NkZmRhODk", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-20T12:32:58Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-03-27T12:16:54Z"}, "message": "Add a builtin `FnPtr` trait", "tree": {"sha": "b0a7561ac7421c0df2e6daa3a047cf3dfb107627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0a7561ac7421c0df2e6daa3a047cf3dfb107627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c13565ca66d25d15ee9146919dd74e57cdfda89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c13565ca66d25d15ee9146919dd74e57cdfda89", "html_url": "https://github.com/rust-lang/rust/commit/0c13565ca66d25d15ee9146919dd74e57cdfda89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c13565ca66d25d15ee9146919dd74e57cdfda89/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309", "html_url": "https://github.com/rust-lang/rust/commit/7a0600714ab1a4cb2d1a88cd0660b9f9a2c07309"}], "stats": {"total": 337, "additions": 310, "deletions": 27}, "files": [{"sha": "54d67bd1f29dc58dffcce82d56da4e16e5764d51", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -382,6 +382,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::FnPtrShim(..)\n             | ty::InstanceDef::DropGlue(..)\n             | ty::InstanceDef::CloneShim(..)\n+            | ty::InstanceDef::FnPtrAddrShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n                 let Some((body, instance)) ="}, {"sha": "07faecdb6a7a1bb398198900a767050ea5c363ed", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -166,6 +166,9 @@ language_item_table! {\n \n     Freeze,                  sym::freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n \n+    FnPtrTrait,              sym::fn_ptr_trait,        fn_ptr_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    FnPtrAddr,               sym::fn_ptr_addr,         fn_ptr_addr,                Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n     Drop,                    sym::drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n     Destruct,                sym::destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n "}, {"sha": "90397f01bc8148c958e65d8aa4d527b1b459f675", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -381,7 +381,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::Virtual(..)\n                             | InstanceDef::ClosureOnceShim { .. }\n                             | InstanceDef::DropGlue(..)\n-                            | InstanceDef::CloneShim(..) => None,\n+                            | InstanceDef::CloneShim(..)\n+                            | InstanceDef::FnPtrAddrShim(..) => None,\n                         }\n                     }\n                     MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),"}, {"sha": "9b31ad783fc35226c5508ff9827b718cf6c5bcaf", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -340,7 +340,8 @@ macro_rules! make_mir_visitor {\n \n                         ty::InstanceDef::FnPtrShim(_def_id, ty) |\n                         ty::InstanceDef::DropGlue(_def_id, Some(ty)) |\n-                        ty::InstanceDef::CloneShim(_def_id, ty) => {\n+                        ty::InstanceDef::CloneShim(_def_id, ty) |\n+                        ty::InstanceDef::FnPtrAddrShim(_def_id, ty) => {\n                             // FIXME(eddyb) use a better `TyContext` here.\n                             self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                         }"}, {"sha": "036b447767971ae056361ed014adbdf8f333ed48", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -96,6 +96,13 @@ pub enum InstanceDef<'tcx> {\n     ///\n     /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n     CloneShim(DefId, Ty<'tcx>),\n+\n+    /// Compiler-generated `<T as FnPtr>::addr` implementation.\n+    ///\n+    /// Automatically generated for all potentially higher-ranked `fn(I) -> R` types.\n+    ///\n+    /// The `DefId` is for `FnPtr::addr`, the `Ty` is the type `T`.\n+    FnPtrAddrShim(DefId, Ty<'tcx>),\n }\n \n impl<'tcx> Instance<'tcx> {\n@@ -151,7 +158,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n             | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _) => def_id,\n+            | InstanceDef::CloneShim(def_id, _)\n+            | InstanceDef::FnPtrAddrShim(def_id, _) => def_id,\n         }\n     }\n \n@@ -167,7 +175,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => None,\n+            | InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..) => None,\n         }\n     }\n \n@@ -182,7 +191,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n             | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n+            | InstanceDef::CloneShim(def_id, _)\n+            | InstanceDef::FnPtrAddrShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n         }\n     }\n \n@@ -268,6 +278,7 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn has_polymorphic_mir_body(&self) -> bool {\n         match *self {\n             InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..)\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::DropGlue(_, Some(_)) => false,\n             InstanceDef::ClosureOnceShim { .. }\n@@ -306,6 +317,7 @@ fn fmt_instance(\n         InstanceDef::DropGlue(_, None) => write!(f, \" - shim(None)\"),\n         InstanceDef::DropGlue(_, Some(ty)) => write!(f, \" - shim(Some({}))\", ty),\n         InstanceDef::CloneShim(_, ty) => write!(f, \" - shim({})\", ty),\n+        InstanceDef::FnPtrAddrShim(_, ty) => write!(f, \" - shim({})\", ty),\n     }\n }\n "}, {"sha": "48b400f7c977721a91402347a7d35c093c7876b3", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -2284,12 +2284,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         def_id1: DefId,\n         def_id2: DefId,\n     ) -> Option<ImplOverlapKind> {\n+        let impl_trait_ref1 = self.impl_trait_ref(def_id1);\n+        let impl_trait_ref2 = self.impl_trait_ref(def_id2);\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.subst_identity().references_error())\n-            || self\n-                .impl_trait_ref(def_id2)\n-                .map_or(false, |tr| tr.subst_identity().references_error())\n+        if impl_trait_ref1.map_or(false, |tr| tr.subst_identity().references_error())\n+            || impl_trait_ref2.map_or(false, |tr| tr.subst_identity().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n@@ -2317,11 +2317,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let is_marker_overlap = {\n-            let is_marker_impl = |def_id: DefId| -> bool {\n-                let trait_ref = self.impl_trait_ref(def_id);\n+            let is_marker_impl = |trait_ref: Option<EarlyBinder<TraitRef<'_>>>| -> bool {\n                 trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n-            is_marker_impl(def_id1) && is_marker_impl(def_id2)\n+            is_marker_impl(impl_trait_ref1) && is_marker_impl(impl_trait_ref2)\n         };\n \n         if is_marker_overlap {\n@@ -2405,7 +2404,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             | ty::InstanceDef::Virtual(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }\n             | ty::InstanceDef::DropGlue(..)\n-            | ty::InstanceDef::CloneShim(..) => self.mir_shims(instance),\n+            | ty::InstanceDef::CloneShim(..)\n+            | ty::InstanceDef::FnPtrAddrShim(..) => self.mir_shims(instance),\n         }\n     }\n "}, {"sha": "b69186c9451e4b3ef38906701c2b413c2b172a70", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -270,7 +270,8 @@ impl<'tcx> Inliner<'tcx> {\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => return Ok(()),\n+            | InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..) => return Ok(()),\n         }\n \n         if self.tcx.is_constructor(callee_def_id) {"}, {"sha": "faf404c77715b0df9f134275bc1c738ac79053ba", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -84,6 +84,9 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n                 | InstanceDef::FnPtrShim(..)\n                 | InstanceDef::ClosureOnceShim { .. }\n                 | InstanceDef::CloneShim(..) => {}\n+\n+                // This shim does not call any other functions, thus there can be no recursion.\n+                InstanceDef::FnPtrAddrShim(..) => continue,\n                 InstanceDef::DropGlue(..) => {\n                     // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n                     // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this"}, {"sha": "06a6deeee43e40ebf2956b6116fa32333dc24042", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -77,6 +77,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n             build_drop_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::CloneShim(def_id, ty) => build_clone_shim(tcx, def_id, ty),\n+        ty::InstanceDef::FnPtrAddrShim(def_id, ty) => build_fn_ptr_addr_shim(tcx, def_id, ty),\n         ty::InstanceDef::Virtual(..) => {\n             bug!(\"InstanceDef::Virtual ({:?}) is for direct calls only\", instance)\n         }\n@@ -861,3 +862,39 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     body\n }\n+\n+/// ```ignore (pseudo-impl)\n+/// impl FnPtr for fn(u32) {\n+///     fn addr(self) -> usize {\n+///         self as usize\n+///     }\n+/// }\n+/// ```\n+fn build_fn_ptr_addr_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n+    assert!(matches!(self_ty.kind(), ty::FnPtr(..)), \"expected fn ptr, found {self_ty}\");\n+    let span = tcx.def_span(def_id);\n+    let Some(sig) = tcx.fn_sig(def_id).subst(tcx, &[self_ty.into()]).no_bound_vars() else {\n+        span_bug!(span, \"FnPtr::addr with bound vars for `{self_ty}`\");\n+    };\n+    let locals = local_decls_for_sig(&sig, span);\n+\n+    let source_info = SourceInfo::outermost(span);\n+    // FIXME: use `expose_addr` once we figure out whether function pointers have meaningful provenance.\n+    let rvalue = Rvalue::Cast(\n+        CastKind::FnPtrToPtr,\n+        Operand::Move(Place::from(Local::new(1))),\n+        tcx.mk_imm_ptr(tcx.types.unit),\n+    );\n+    let stmt = Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((Place::return_place(), rvalue))),\n+    };\n+    let statements = vec![stmt];\n+    let start_block = BasicBlockData {\n+        statements,\n+        terminator: Some(Terminator { source_info, kind: TerminatorKind::Return }),\n+        is_cleanup: false,\n+    };\n+    let source = MirSource::from_instance(ty::InstanceDef::FnPtrAddrShim(def_id, self_ty));\n+    new_body(source, IndexVec::from_elem_n(start_block, 1), locals, sig.inputs().len(), span)\n+}"}, {"sha": "8e7012c27748c1796eb9c8d17ce2ffd9c363f9f9", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -974,7 +974,8 @@ fn visit_instance_use<'tcx>(\n         | ty::InstanceDef::ClosureOnceShim { .. }\n         | ty::InstanceDef::Item(..)\n         | ty::InstanceDef::FnPtrShim(..)\n-        | ty::InstanceDef::CloneShim(..) => {\n+        | ty::InstanceDef::CloneShim(..)\n+        | ty::InstanceDef::FnPtrAddrShim(..) => {\n             output.push(create_fn_mono_item(tcx, instance, source));\n         }\n     }"}, {"sha": "64968a76ab55438da5a6b39aa909fd6133508727", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -278,7 +278,8 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                 | ty::InstanceDef::Intrinsic(..)\n                 | ty::InstanceDef::DropGlue(..)\n                 | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..) => return None,\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n             };\n \n             // If this is a method, we want to put it into the same module as\n@@ -432,7 +433,8 @@ fn mono_item_visibility<'tcx>(\n         | InstanceDef::Intrinsic(..)\n         | InstanceDef::ClosureOnceShim { .. }\n         | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..) => return Visibility::Hidden,\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n     };\n \n     // The `start_fn` lang item is actually a monomorphized instance of a"}, {"sha": "0ed9935314506a22f1db3e2e00d5681a9a979f68", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -722,6 +722,8 @@ symbols! {\n         fn_mut,\n         fn_once,\n         fn_once_output,\n+        fn_ptr_addr,\n+        fn_ptr_trait,\n         forbid,\n         forget,\n         format,"}, {"sha": "8dad3f312c98a9d678c8d4acfb72a13f691f7ba6", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -153,6 +153,12 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is a `FnPtr` if it is of `FnPtr` type.\n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n     // A callable type (a closure, fn def, or fn ptr) is known to implement the `Fn<A>`\n     // family of traits where `A` is given by the signature of the type.\n     fn consider_builtin_fn_trait_candidates(\n@@ -331,6 +337,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_copy_clone_candidate(self, goal)\n         } else if lang_items.pointer_like() == Some(trait_def_id) {\n             G::consider_builtin_pointer_like_candidate(self, goal)\n+        } else if lang_items.fn_ptr_trait() == Some(trait_def_id) {\n+            G::consider_builtin_fn_ptr_trait_candidate(self, goal)\n         } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n             G::consider_builtin_fn_trait_candidates(self, goal, kind)\n         } else if lang_items.tuple_trait() == Some(trait_def_id) {"}, {"sha": "2b104703aab2ff9430264e636653beb639d33cbc", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -261,6 +261,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         bug!(\"`PointerLike` does not have an associated type: {:?}\", goal);\n     }\n \n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`FnPtr` does not have an associated type: {:?}\", goal);\n+    }\n+\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "718c82c8f1f2847d6e29e282daed0151e5c59d93", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -222,9 +222,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n \n         if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n-            &&  let usize_layout = tcx.layout_of(ty::ParamEnv::empty().and(tcx.types.usize)).unwrap().layout\n-            && layout.layout.size() == usize_layout.size()\n-            && layout.layout.align().abi == usize_layout.align().abi\n+            && layout.layout.size() == tcx.data_layout.pointer_size\n+            && layout.layout.align().abi == tcx.data_layout.pointer_align.abi\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n@@ -233,6 +232,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        if let ty::FnPtr(..) = goal.predicate.self_ty().kind() {\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "89e91eb298bfe3da513db17190bb6f0e4e1148ad", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -411,11 +411,24 @@ fn resolve_negative_obligation<'tcx>(\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n \n+/// Returns whether all impls which would apply to the `trait_ref`\n+/// e.g. `Ty: Trait<Arg>` are already known in the local crate.\n+///\n+/// This both checks whether any downstream or sibling crates could\n+/// implement it and whether an upstream crate can add this impl\n+/// without breaking backwards compatibility.\n #[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn trait_ref_is_knowable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), Conflict> {\n+    if Some(trait_ref.def_id) == tcx.lang_items().fn_ptr_trait() {\n+        // The only types implementing `FnPtr` are function pointers,\n+        // so if there's no impl of `FnPtr` in the current crate,\n+        // then such an impl will never be added in the future.\n+        return Ok(());\n+    }\n+\n     if orphan_check_trait_ref(trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref."}, {"sha": "234d773d64d7894508b6ccc91e7338d5a4af25ec", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 146, "deletions": 6, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -5,6 +5,8 @@\n //! candidates. See the [rustc dev guide] for more details.\n //!\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n+\n+use hir::def_id::DefId;\n use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n@@ -96,6 +98,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.assemble_candidate_for_tuple(obligation, &mut candidates);\n             } else if lang_items.pointer_like() == Some(def_id) {\n                 self.assemble_candidate_for_ptr_sized(obligation, &mut candidates);\n+            } else if lang_items.fn_ptr_trait() == Some(def_id) {\n+                self.assemble_candidates_for_fn_ptr_trait(obligation, &mut candidates);\n             } else {\n                 if lang_items.clone_trait() == Some(def_id) {\n                     // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n@@ -321,13 +325,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     /// Searches for impls that might apply to `obligation`.\n+    #[instrument(level = \"debug\", skip(self, candidates))]\n     fn assemble_candidates_from_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        debug!(?obligation, \"assemble_candidates_from_impls\");\n-\n         // Essentially any user-written impl will match with an error type,\n         // so creating `ImplCandidates` isn't useful. However, we might\n         // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized`)\n@@ -352,6 +355,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if self.fast_reject_trait_refs(obligation, &impl_trait_ref.0) {\n                     return;\n                 }\n+                if self.reject_fn_ptr_impls(\n+                    impl_def_id,\n+                    obligation,\n+                    impl_trait_ref.skip_binder().self_ty(),\n+                ) {\n+                    return;\n+                }\n \n                 self.infcx.probe(|_| {\n                     if let Ok(_substs) = self.match_impl(impl_def_id, impl_trait_ref, obligation) {\n@@ -362,6 +372,99 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n     }\n \n+    /// The various `impl<T: FnPtr> Trait for T` in libcore are more like builtin impls for all function items\n+    /// and function pointers and less like blanket impls. Rejecting them when they can't possibly apply (because\n+    /// the obligation's self-type does not implement `FnPtr`) avoids reporting that the self type does not implement\n+    /// `FnPtr`, when we wanted to report that it doesn't implement `Trait`.\n+    #[instrument(level = \"trace\", skip(self), ret)]\n+    fn reject_fn_ptr_impls(\n+        &self,\n+        impl_def_id: DefId,\n+        obligation: &TraitObligation<'tcx>,\n+        impl_self_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Let `impl<T: FnPtr> Trait for Vec<T>` go through the normal rejection path.\n+        if !matches!(impl_self_ty.kind(), ty::Param(..)) {\n+            return false;\n+        }\n+        let Some(fn_ptr_trait) = self.tcx().lang_items().fn_ptr_trait() else {\n+            return false;\n+        };\n+\n+        for &(predicate, _) in self.tcx().predicates_of(impl_def_id).predicates {\n+            let ty::PredicateKind::Clause(ty::Clause::Trait(pred))\n+                = predicate.kind().skip_binder() else { continue };\n+            if fn_ptr_trait != pred.trait_ref.def_id {\n+                continue;\n+            }\n+            trace!(?pred);\n+            // Not the bound we're looking for\n+            if pred.self_ty() != impl_self_ty {\n+                continue;\n+            }\n+\n+            match obligation.self_ty().skip_binder().kind() {\n+                // Fast path to avoid evaluating an obligation that trivally holds.\n+                // There may be more bounds, but these are checked by the regular path.\n+                ty::FnPtr(..) => return false,\n+                // These may potentially implement `FnPtr`\n+                ty::Placeholder(..)\n+                | ty::Dynamic(_, _, _)\n+                | ty::Alias(_, _)\n+                | ty::Infer(_)\n+                | ty::Param(..) => {}\n+\n+                ty::Bound(_, _) => span_bug!(\n+                    obligation.cause.span(),\n+                    \"cannot have escaping bound var in self type of {obligation:#?}\"\n+                ),\n+                // These can't possibly implement `FnPtr` as they are concrete types\n+                // and not `FnPtr`\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(_)\n+                | ty::Uint(_)\n+                | ty::Float(_)\n+                | ty::Adt(_, _)\n+                | ty::Foreign(_)\n+                | ty::Str\n+                | ty::Array(_, _)\n+                | ty::Slice(_)\n+                | ty::RawPtr(_)\n+                | ty::Ref(_, _, _)\n+                | ty::Closure(_, _)\n+                | ty::Generator(_, _, _)\n+                | ty::GeneratorWitness(_)\n+                | ty::GeneratorWitnessMIR(_, _)\n+                | ty::Never\n+                | ty::Tuple(_)\n+                | ty::Error(_) => return true,\n+                // FIXME: Function definitions could actually implement `FnPtr` by\n+                // casting the ZST function def to a function pointer.\n+                ty::FnDef(_, _) => return true,\n+            }\n+\n+            // Generic params can implement `FnPtr` if the predicate\n+            // holds within its own environment.\n+            let obligation = Obligation::new(\n+                self.tcx(),\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                self.tcx().mk_predicate(obligation.predicate.map_bound(|mut pred| {\n+                    pred.trait_ref =\n+                        self.tcx().mk_trait_ref(fn_ptr_trait, [pred.trait_ref.self_ty()]);\n+                    ty::PredicateKind::Clause(ty::Clause::Trait(pred))\n+                })),\n+            );\n+            if let Ok(r) = self.infcx.evaluate_obligation(&obligation) {\n+                if !r.may_apply() {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     fn assemble_candidates_from_auto_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -853,13 +956,50 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let usize_layout =\n-            self.tcx().layout_of(ty::ParamEnv::empty().and(self.tcx().types.usize)).unwrap().layout;\n         if let Ok(layout) = self.tcx().layout_of(obligation.param_env.and(self_ty))\n-            && layout.layout.size() == usize_layout.size()\n-            && layout.layout.align().abi == usize_layout.align().abi\n+            && layout.layout.size() == self.tcx().data_layout.pointer_size\n+            && layout.layout.align().abi == self.tcx().data_layout.pointer_align.abi\n         {\n             candidates.vec.push(BuiltinCandidate { has_nested: false });\n         }\n     }\n+\n+    fn assemble_candidates_for_fn_ptr_trait(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        candidates: &mut SelectionCandidateSet<'tcx>,\n+    ) {\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        match self_ty.skip_binder().kind() {\n+            ty::FnPtr(_) => candidates.vec.push(BuiltinCandidate { has_nested: false }),\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(..)\n+            | ty::Foreign(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::Placeholder(..)\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Never\n+            | ty::Tuple(..)\n+            | ty::Alias(..)\n+            | ty::Param(..)\n+            | ty::Bound(..)\n+            | ty::Error(_) => {}\n+            ty::Infer(_) => {\n+                candidates.ambiguous = true;\n+            }\n+        }\n+    }\n }"}, {"sha": "ad70154c98efaf48ecc93ce32d262b01956b987e", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -243,7 +243,8 @@ fn resolve_associated_item<'tcx>(\n             }\n         }\n         traits::ImplSource::Builtin(..) => {\n-            if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n+            let lang_items = tcx.lang_items();\n+            if Some(trait_ref.def_id) == lang_items.clone_trait() {\n                 // FIXME(eddyb) use lang items for methods instead of names.\n                 let name = tcx.item_name(trait_item_id);\n                 if name == sym::clone {\n@@ -270,6 +271,22 @@ fn resolve_associated_item<'tcx>(\n                     let substs = tcx.erase_regions(rcvr_substs);\n                     Some(ty::Instance::new(trait_item_id, substs))\n                 }\n+            } else if Some(trait_ref.def_id) == lang_items.fn_ptr_trait() {\n+                if lang_items.fn_ptr_addr() == Some(trait_item_id) {\n+                    let self_ty = trait_ref.self_ty();\n+                    if !matches!(self_ty.kind(), ty::FnPtr(..)) {\n+                        return Ok(None);\n+                    }\n+                    Some(Instance {\n+                        def: ty::InstanceDef::FnPtrAddrShim(trait_item_id, self_ty),\n+                        substs: rcvr_substs,\n+                    })\n+                } else {\n+                    tcx.sess.span_fatal(\n+                        tcx.def_span(trait_item_id),\n+                        \"`FnPtrAddr` trait with unexpected assoc item\",\n+                    )\n+                }\n             } else {\n                 None\n             }"}, {"sha": "c0cb12df5b094f1afea5abbaa979b0dce7e2f57d", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -922,3 +922,18 @@ mod copy_impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Copy for &T {}\n }\n+\n+/// A common trait implemented by all function pointers.\n+#[unstable(\n+    feature = \"fn_ptr_trait\",\n+    issue = \"none\",\n+    reason = \"internal trait for implementing various traits for all function pointers\"\n+)]\n+#[lang = \"fn_ptr_trait\"]\n+#[cfg(not(bootstrap))]\n+#[rustc_deny_explicit_impl]\n+pub trait FnPtr {\n+    /// Returns the address of the function pointer.\n+    #[lang = \"fn_ptr_addr\"]\n+    fn addr(self) -> *const ();\n+}"}, {"sha": "45918ae5b6104fe4412156e3efb568385754a99c", "filename": "tests/ui/fn/fn-ptr-trait.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c13565ca66d25d15ee9146919dd74e57cdfda89/tests%2Fui%2Ffn%2Ffn-ptr-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c13565ca66d25d15ee9146919dd74e57cdfda89/tests%2Fui%2Ffn%2Ffn-ptr-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-ptr-trait.rs?ref=0c13565ca66d25d15ee9146919dd74e57cdfda89", "patch": "@@ -0,0 +1,9 @@\n+#![feature(fn_ptr_trait)]\n+// check-pass\n+\n+use std::marker::FnPtr;\n+\n+trait Foo {}\n+impl<T> Foo for Vec<T> where T: FnPtr {}\n+\n+fn main() {}"}]}