{"sha": "45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "node_id": "C_kwDOAAsO6NoAKDQ1ZjQ0MWE3YjQxZDA5YmI3OGIwYmEzZTI2MGQyYzg2OGVmNmFkZDc", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-14T16:42:46Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-15T12:34:08Z"}, "message": "nll: correctly deal with bivariance", "tree": {"sha": "0ab27b9bde513532c7f3b006f74148a246e85ad1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ab27b9bde513532c7f3b006f74148a246e85ad1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "html_url": "https://github.com/rust-lang/rust/commit/45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca92d90b5917e7176d5ff06607a2cd5352c088d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca92d90b5917e7176d5ff06607a2cd5352c088d3", "html_url": "https://github.com/rust-lang/rust/commit/ca92d90b5917e7176d5ff06607a2cd5352c088d3"}], "stats": {"total": 137, "additions": 82, "deletions": 55}, "files": [{"sha": "753c1e87d21f3f7dad6179a02dc7448ade2aee8e", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "patch": "@@ -23,7 +23,7 @@ use super::{\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n     Scalar, StackPopJump,\n };\n-use crate::transform::validate::equal_up_to_regions;\n+use crate::transform::validate;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -354,8 +354,8 @@ pub(super) fn mir_assign_valid_types<'tcx>(\n     // Type-changing assignments can happen when subtyping is used. While\n     // all normal lifetimes are erased, higher-ranked types with their\n     // late-bound lifetimes are still around and can lead to type\n-    // differences. So we compare ignoring lifetimes.\n-    if equal_up_to_regions(tcx, param_env, src.ty, dest.ty) {\n+    // differences.\n+    if validate::is_subtype(tcx, param_env, src.ty, dest.ty) {\n         // Make sure the layout is equal, too -- just to be safe. Miri really\n         // needs layout equality. For performance reason we skip this check when\n         // the types are equal. Equal types *can* have different layouts when"}, {"sha": "69e457f0a1a86db132544894e35b09fdf53de430", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "patch": "@@ -2,7 +2,8 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::bit_set::BitSet;\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n@@ -12,12 +13,12 @@ use rustc_middle::mir::{\n     ProjectionElem, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n     TerminatorKind, UnOp, START_BLOCK,\n };\n-use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n use rustc_target::abi::{Size, VariantIdx};\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n #[derive(Copy, Clone, Debug)]\n enum EdgeKind {\n@@ -70,13 +71,11 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n-/// Returns whether the two types are equal up to lifetimes.\n-/// All lifetimes, including higher-ranked ones, get ignored for this comparison.\n-/// (This is unlike the `erasing_regions` methods, which keep higher-ranked lifetimes for soundness reasons.)\n+/// Returns whether the two types are equal up to subtyping.\n ///\n-/// The point of this function is to approximate \"equal up to subtyping\".  However,\n-/// the approximation is incorrect as variance is ignored.\n-pub fn equal_up_to_regions<'tcx>(\n+/// This is used in case we don't know the expected subtyping direction\n+/// and still want to check whether anything is broken.\n+pub fn is_equal_up_to_subtyping<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     src: Ty<'tcx>,\n@@ -87,27 +86,40 @@ pub fn equal_up_to_regions<'tcx>(\n         return true;\n     }\n \n-    // Normalize lifetimes away on both sides, then compare.\n-    let normalize = |ty: Ty<'tcx>| {\n-        tcx.try_normalize_erasing_regions(param_env, ty).unwrap_or(ty).fold_with(\n-            &mut BottomUpFolder {\n-                tcx,\n-                // FIXME: We erase all late-bound lifetimes, but this is not fully correct.\n-                // If you have a type like `<for<'a> fn(&'a u32) as SomeTrait>::Assoc`,\n-                // this is not necessarily equivalent to `<fn(&'static u32) as SomeTrait>::Assoc`,\n-                // since one may have an `impl SomeTrait for fn(&32)` and\n-                // `impl SomeTrait for fn(&'static u32)` at the same time which\n-                // specify distinct values for Assoc. (See also #56105)\n-                lt_op: |_| tcx.lifetimes.re_erased,\n-                // Leave consts and types unchanged.\n-                ct_op: |ct| ct,\n-                ty_op: |ty| ty,\n-            },\n-        )\n-    };\n-    tcx.infer_ctxt().build().can_eq(param_env, normalize(src), normalize(dest)).is_ok()\n+    // Check for subtyping in either direction.\n+    is_subtype(tcx, param_env, src, dest) || is_subtype(tcx, param_env, dest, src)\n }\n \n+pub fn is_subtype<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    if src == dest {\n+        return true;\n+    }\n+\n+    let mut builder =\n+        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n+    let infcx = builder.build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let cause = ObligationCause::dummy();\n+    let src = ocx.normalize(cause.clone(), param_env, src);\n+    let dest = ocx.normalize(cause.clone(), param_env, dest);\n+    let Ok(infer_ok) = infcx.at(&cause, param_env).sub(src, dest) else {\n+        return false;\n+    };\n+    let () = ocx.register_infer_ok_obligations(infer_ok);\n+    let errors = ocx.select_all_or_error();\n+    // With `Reveal::All`, opaque types get normalized away, with `Reveal::UserFacing`\n+    // we would get unification errors because we're unable to look into opaque types,\n+    // even if they're constrained in our current function.\n+    //\n+    // It seems very unlikely that this hides any bugs.\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    errors.is_empty()\n+}\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     body: &'a Body<'tcx>,\n@@ -183,22 +195,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n \n-        // Normalize projections and things like that.\n-        // Type-changing assignments can happen when subtyping is used. While\n-        // all normal lifetimes are erased, higher-ranked types with their\n-        // late-bound lifetimes are still around and can lead to type\n-        // differences. So we compare ignoring lifetimes.\n-\n-        // First, try with reveal_all. This might not work in some cases, as the predicates\n-        // can be cleared in reveal_all mode. We try the reveal first anyways as it is used\n-        // by some other passes like inlining as well.\n-        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n-        if equal_up_to_regions(self.tcx, param_env, src, dest) {\n-            return true;\n-        }\n-\n-        // If this fails, we can try it without the reveal.\n-        equal_up_to_regions(self.tcx, self.param_env, src, dest)\n+        is_subtype(self.tcx, self.param_env, src, dest)\n     }\n }\n "}, {"sha": "74b2fb613b78199a3a230653bc772b02449b645a", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "patch": "@@ -556,8 +556,12 @@ where\n         self.ambient_variance_info = self.ambient_variance_info.xform(info);\n \n         debug!(?self.ambient_variance);\n-\n-        let r = self.relate(a, b)?;\n+        // In a bivariant context this always succeeds.\n+        let r = if self.ambient_variance == ty::Variance::Bivariant {\n+            a\n+        } else {\n+            self.relate(a, b)?\n+        };\n \n         self.ambient_variance = old_ambient_variance;\n "}, {"sha": "2084492cc638060803da7749c676ba90ff55e5d5", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "patch": "@@ -1,7 +1,6 @@\n //! Inlining pass for MIR functions\n use crate::deref_separator::deref_finder;\n use rustc_attr::InlineAttr;\n-use rustc_const_eval::transform::validate::equal_up_to_regions;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n@@ -14,7 +13,8 @@ use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n-use super::simplify::{remove_dead_blocks, CfgSimplifier};\n+use crate::simplify::{remove_dead_blocks, CfgSimplifier};\n+use crate::validate;\n use crate::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n@@ -180,7 +180,7 @@ impl<'tcx> Inliner<'tcx> {\n         let TerminatorKind::Call { args, destination, .. } = &terminator.kind else { bug!() };\n         let destination_ty = destination.ty(&caller_body.local_decls, self.tcx).ty;\n         let output_type = callee_body.return_ty();\n-        if !equal_up_to_regions(self.tcx, self.param_env, output_type, destination_ty) {\n+        if !validate::is_subtype(self.tcx, self.param_env, output_type, destination_ty) {\n             trace!(?output_type, ?destination_ty);\n             return Err(\"failed to normalize return type\");\n         }\n@@ -200,7 +200,7 @@ impl<'tcx> Inliner<'tcx> {\n                 arg_tuple_tys.iter().zip(callee_body.args_iter().skip(skipped_args))\n             {\n                 let input_type = callee_body.local_decls[input].ty;\n-                if !equal_up_to_regions(self.tcx, self.param_env, arg_ty, input_type) {\n+                if !validate::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize tuple argument type\");\n                 }\n@@ -209,7 +209,7 @@ impl<'tcx> Inliner<'tcx> {\n             for (arg, input) in args.iter().zip(callee_body.args_iter()) {\n                 let input_type = callee_body.local_decls[input].ty;\n                 let arg_ty = arg.ty(&caller_body.local_decls, self.tcx);\n-                if !equal_up_to_regions(self.tcx, self.param_env, arg_ty, input_type) {\n+                if !validate::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize argument type\");\n                 }\n@@ -847,7 +847,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n             let parent_ty = parent.ty(&self.callee_body.local_decls, self.tcx);\n             let check_equal = |this: &mut Self, f_ty| {\n-                if !equal_up_to_regions(this.tcx, this.param_env, ty, f_ty) {\n+                if !validate::is_equal_up_to_subtyping(this.tcx, this.param_env, ty, f_ty) {\n                     trace!(?ty, ?f_ty);\n                     this.validation = Err(\"failed to normalize projection type\");\n                     return;"}, {"sha": "cadfb3b66f29747cc0e37ffc30561e69b605eb29", "filename": "src/test/ui/mir/important-higher-ranked-regions.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45f441a7b41d09bb78b0ba3e260d2c868ef6add7/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fimportant-higher-ranked-regions.rs?ref=45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// compile-flags: -Zvalidate-mir\n+\n+// This test checks that bivariant parameters are handled correctly\n+// in the mir.\n+#![allow(coherence_leak_check)]\n+trait Trait {\n+    type Assoc;\n+}\n+\n+struct Foo<T, U>(T)\n+where\n+    T: Trait<Assoc = U>;\n+\n+impl Trait for for<'a> fn(&'a ()) {\n+    type Assoc = u32;\n+}\n+impl Trait for fn(&'static ()) {\n+    type Assoc = String;\n+}\n+\n+fn foo(x: Foo<for<'a> fn(&'a ()), u32>) -> Foo<fn(&'static ()), String> {\n+    x\n+}\n+\n+fn main() {}"}]}