{"sha": "019d4291c712b5127e07b6dab02d4b8c484ecaf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOWQ0MjkxYzcxMmI1MTI3ZTA3YjZkYWIwMmQ0YjhjNDg0ZWNhZjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T00:33:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T00:35:18Z"}, "message": "rustc: Introduce a coherence checker, behind a compile switch for now", "tree": {"sha": "5a7a01c188035ecda5881abf74908b6735e35848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7a01c188035ecda5881abf74908b6735e35848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/019d4291c712b5127e07b6dab02d4b8c484ecaf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/019d4291c712b5127e07b6dab02d4b8c484ecaf8", "html_url": "https://github.com/rust-lang/rust/commit/019d4291c712b5127e07b6dab02d4b8c484ecaf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/019d4291c712b5127e07b6dab02d4b8c484ecaf8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e430a699f2c60890d9b86069fd0c68a70ece7120", "url": "https://api.github.com/repos/rust-lang/rust/commits/e430a699f2c60890d9b86069fd0c68a70ece7120", "html_url": "https://github.com/rust-lang/rust/commit/e430a699f2c60890d9b86069fd0c68a70ece7120"}], "stats": {"total": 240, "additions": 237, "deletions": 3}, "files": [{"sha": "1a70edc18437e2ea23ddbcc3cc2df357b0fb509f", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=019d4291c712b5127e07b6dab02d4b8c484ecaf8", "patch": "@@ -35,7 +35,7 @@ const trace: uint = 128u;\n // FIXME (#2377): This exists to transition to a Rust crate runtime\n // It should be removed\n const no_rt: uint = 256u;\n-const fast_resolve: uint = 512u;\n+const coherence: uint = 512u;\n \n fn debugging_opts_map() -> ~[(str, str, uint)] {\n     ~[(\"ppregions\", \"prettyprint regions with \\\n@@ -49,7 +49,7 @@ fn debugging_opts_map() -> ~[(str, str, uint)] {\n      (\"no-verify\", \"skip LLVM verification\", no_verify),\n      (\"trace\", \"emit trace logs\", trace),\n      (\"no-rt\", \"do not link to the runtime\", no_rt),\n-     (\"fast-resolve\", \"use fast name resolution\", fast_resolve)\n+     (\"coherence\", \"perform coherence checking\", coherence)\n     ]\n }\n \n@@ -164,7 +164,7 @@ impl session for session {\n     fn no_asm_comments() -> bool { self.debugging_opt(no_asm_comments) }\n     fn no_verify() -> bool { self.debugging_opt(no_verify) }\n     fn trace() -> bool { self.debugging_opt(trace) }\n-    fn fast_resolve() -> bool { self.debugging_opt(fast_resolve) }\n+    fn coherence() -> bool { self.debugging_opt(coherence) }\n }\n \n /// Some reasonable defaults"}, {"sha": "6281aaed1abf65b964485102493db08fb7edca37", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=019d4291c712b5127e07b6dab02d4b8c484ecaf8", "patch": "@@ -291,6 +291,11 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 vtable_map: std::map::int_hash(),\n                 tcx: tcx};\n     collect::collect_item_types(ccx, crate);\n+\n+    if tcx.sess.coherence() {\n+        coherence::check_coherence(ccx, crate);\n+    }\n+\n     check::check_item_types(ccx, crate);\n     check_for_main_fn(ccx);\n     tcx.sess.abort_if_errors();"}, {"sha": "365d945fa3de584ed46d9e3eadb4db47907657e2", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=019d4291c712b5127e07b6dab02d4b8c484ecaf8", "patch": "@@ -0,0 +1,228 @@\n+// Coherence phase\n+//\n+// The job of the coherence phase of typechecking is to ensure that each trait\n+// has at most one implementation for each type. Then we build a mapping from\n+// each trait in the system to its implementations.\n+\n+import middle::ty::{get, t, ty_box, ty_uniq, ty_ptr, ty_rptr, ty_enum};\n+import middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n+import middle::ty::{ty_float, ty_str, ty_estr, ty_vec, ty_evec, ty_rec};\n+import middle::ty::{ty_fn, ty_trait, ty_tup, ty_var, ty_var_integral};\n+import middle::ty::{ty_param, ty_self, ty_constr, ty_type, ty_opaque_box};\n+import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, new_ty_hash};\n+import middle::ty::{subst};\n+import middle::typeck::infer::{infer_ctxt, mk_eqty, new_infer_ctxt};\n+import syntax::ast::{crate, def_id, item, item_impl, method, region_param};\n+import syntax::ast::{trait_ref};\n+import syntax::ast_util::{def_id_of_def, new_def_hash};\n+import syntax::visit::{default_simple_visitor, mk_simple_visitor};\n+import syntax::visit::{visit_crate};\n+\n+import dvec::{dvec, extensions};\n+import result::{extensions};\n+import std::map::hashmap;\n+import uint::range;\n+\n+class CoherenceInfo {\n+    // Contains implementations of methods that are inherent to a type.\n+    // Methods in these implementations don't need to be exported.\n+    let inherent_methods: hashmap<t,@dvec<@item>>;\n+\n+    // Contains implementations of methods associated with a trait. For these,\n+    // the associated trait must be imported at the call site.\n+    let extension_methods: hashmap<def_id,@dvec<@item>>;\n+\n+    new() {\n+        self.inherent_methods = new_ty_hash();\n+        self.extension_methods = new_def_hash();\n+    }\n+}\n+\n+class CoherenceChecker {\n+    let crate_context: @crate_ctxt;\n+    let inference_context: infer_ctxt;\n+    let info: @CoherenceInfo;\n+\n+    new(crate_context: @crate_ctxt) {\n+        self.crate_context = crate_context;\n+        self.inference_context = new_infer_ctxt(crate_context.tcx);\n+        self.info = @CoherenceInfo();\n+    }\n+\n+    fn check_coherence(crate: @crate) {\n+        // Check implementations. This populates the tables containing the\n+        // inherent methods and extension methods.\n+\n+        visit_crate(*crate, (), mk_simple_visitor(@{\n+            visit_item: |item| {\n+                alt item.node {\n+                    item_impl(_, _, associated_trait, self_type, _) {\n+                        self.check_implementation(item, associated_trait);\n+                    }\n+                    _ {\n+                        // Nothing to do.\n+                    }\n+                };\n+            }\n+            with *default_simple_visitor()\n+        }));\n+\n+        // Check trait coherence.\n+        for self.info.extension_methods.each |def_id, items| {\n+            self.check_implementation_coherence(def_id, items);\n+        }\n+    }\n+\n+    fn check_implementation(item: @item,\n+                            optional_associated_trait: option<@trait_ref>) {\n+\n+        let self_type = self.crate_context.tcx.tcache.get(local_def(item.id));\n+        alt optional_associated_trait {\n+            none {\n+                alt self.get_base_type(self_type.ty) {\n+                    none {\n+                        let session = self.crate_context.tcx.sess;\n+                        session.span_warn(item.span,\n+                                          \"no base type found for inherent \\\n+                                           implementation; implement a trait \\\n+                                           instead\");\n+                    }\n+                    some(base_type) {\n+                        let implementation_list;\n+                        alt self.info.inherent_methods.find(base_type) {\n+                            none {\n+                                implementation_list = @dvec();\n+                            }\n+                            some(existing_implementation_list) {\n+                                implementation_list =\n+                                    existing_implementation_list;\n+                            }\n+                        }\n+\n+                        implementation_list.push(item);\n+                    }\n+                }\n+            }\n+            some(associated_trait) {\n+                let def =\n+                    self.crate_context.tcx.def_map.get(associated_trait.id);\n+                let def_id = def_id_of_def(def);\n+\n+                let implementation_list;\n+                alt self.info.extension_methods.find(def_id) {\n+                    none {\n+                        implementation_list = @dvec();\n+                    }\n+                    some(existing_implementation_list) {\n+                        implementation_list = existing_implementation_list;\n+                    }\n+                }\n+\n+                implementation_list.push(item);\n+            }\n+        }\n+    }\n+\n+    fn get_base_type(original_type: t) -> option<t> {\n+        alt get(original_type).struct {\n+            ty_box(base_mutability_and_type) |\n+            ty_uniq(base_mutability_and_type) |\n+            ty_ptr(base_mutability_and_type) |\n+            ty_rptr(_, base_mutability_and_type) {\n+                self.get_base_type(base_mutability_and_type.ty)\n+            }\n+\n+            ty_enum(*) | ty_class(*) {\n+                some(original_type)\n+            }\n+\n+            ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n+            ty_str | ty_estr(*) | ty_vec(*) | ty_evec(*) | ty_rec(*) |\n+            ty_fn(*) | ty_trait(*) | ty_tup(*) | ty_var(*) |\n+            ty_var_integral(*) | ty_param(*) | ty_self | ty_constr(*) |\n+            ty_type | ty_opaque_box | ty_opaque_closure_ptr(*) |\n+            ty_unboxed_vec(*) {\n+                none\n+            }\n+        }\n+    }\n+\n+    fn check_implementation_coherence(_trait_def_id: def_id,\n+                                      implementations: @dvec<@item>) {\n+\n+        // Unify pairs of polytypes.\n+        for implementations.eachi |i, implementation_a| {\n+            let polytype_a =\n+                self.get_self_type_for_implementation(implementation_a);\n+            for range(i + 1, implementations.len()) |j| {\n+                let implementation_b = implementations.get_elt(j);\n+                let polytype_b =\n+                    self.get_self_type_for_implementation(implementation_b);\n+\n+                if self.polytypes_unify(polytype_a, polytype_b) {\n+                    let session = self.crate_context.tcx.sess;\n+                    session.span_err(implementation_b.span,\n+                                     \"conflicting implementations for a \\\n+                                      trait\");\n+                    session.span_note(implementation_a.span,\n+                                      \"note conflicting implementation here\");\n+                }\n+            }\n+        }\n+    }\n+\n+    fn polytypes_unify(polytype_a: ty_param_bounds_and_ty,\n+                       polytype_b: ty_param_bounds_and_ty)\n+                    -> bool {\n+\n+        let monotype_a = self.universally_quantify_polytype(polytype_a);\n+        let monotype_b = self.universally_quantify_polytype(polytype_b);\n+        ret mk_eqty(self.inference_context, monotype_a, monotype_b).is_ok();\n+    }\n+\n+    // Converts a polytype to a monotype by replacing all parameters with\n+    // type variables.\n+    fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n+        let self_region;\n+        alt polytype.rp {\n+            ast::rp_none {\n+                self_region = none;\n+            }\n+            ast::rp_self {\n+                self_region = some(self.inference_context.next_region_var())\n+            }\n+        };\n+\n+        let bounds_count = polytype.bounds.len();\n+        let type_parameters =\n+            self.inference_context.next_ty_vars(bounds_count);\n+\n+        let substitutions = {\n+            self_r: self_region,\n+            self_ty: none,\n+            tps: type_parameters\n+        };\n+\n+        ret subst(self.crate_context.tcx, substitutions, polytype.ty);\n+    }\n+\n+    fn get_self_type_for_implementation(implementation: @item)\n+                                     -> ty_param_bounds_and_ty {\n+\n+        alt implementation.node {\n+            item_impl(*) {\n+                let def = local_def(implementation.id);\n+                ret self.crate_context.tcx.tcache.get(def);\n+            }\n+            _ {\n+                self.crate_context.tcx.sess.span_bug(implementation.span,\n+                                                     \"not an implementation\");\n+            }\n+        }\n+    }\n+}\n+\n+fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {\n+    CoherenceChecker(crate_context).check_coherence(crate);\n+}\n+"}, {"sha": "4dd0451f164b92cdab3a99f100194589501c5a98", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/019d4291c712b5127e07b6dab02d4b8c484ecaf8/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=019d4291c712b5127e07b6dab02d4b8c484ecaf8", "patch": "@@ -67,6 +67,7 @@ mod middle {\n         mod astconv;\n         mod infer;\n         mod collect;\n+        mod coherence;\n     }\n     mod check_loop;\n     mod check_alt;"}]}