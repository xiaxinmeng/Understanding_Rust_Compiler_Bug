{"sha": "b177813f3bef708636ec4be271e376b111c36a59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNzc4MTNmM2JlZjcwODYzNmVjNGJlMjcxZTM3NmIxMTFjMzZhNTk=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-22T07:33:55Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-22T07:33:55Z"}, "message": "Add mbe expand limit and poision macro set", "tree": {"sha": "f9272f478f1b943b4e643ed9bd2b5fd1ee2e7e8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9272f478f1b943b4e643ed9bd2b5fd1ee2e7e8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b177813f3bef708636ec4be271e376b111c36a59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b177813f3bef708636ec4be271e376b111c36a59", "html_url": "https://github.com/rust-lang/rust/commit/b177813f3bef708636ec4be271e376b111c36a59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b177813f3bef708636ec4be271e376b111c36a59/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc5c1d24e1a641b134f634516828301e8cfc320", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc5c1d24e1a641b134f634516828301e8cfc320", "html_url": "https://github.com/rust-lang/rust/commit/bbc5c1d24e1a641b134f634516828301e8cfc320"}], "stats": {"total": 234, "additions": 216, "deletions": 18}, "files": [{"sha": "c7849c995b009ccf839cef94a1b7fea8b1070eba", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=b177813f3bef708636ec4be271e376b111c36a59", "patch": "@@ -94,6 +94,13 @@ fn parse_macro(\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n     let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+\n+    // Set a hard limit for the expanded tt\n+    let count = tt.count();\n+    if count > 65536 {\n+        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n+    }\n+\n     Ok(mbe::token_tree_to_ast_item_list(&tt))\n }\n "}, {"sha": "fbfff4fd785f0bbbbc78cf3cc9a120d8e3654e70", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=b177813f3bef708636ec4be271e376b111c36a59", "patch": "@@ -55,7 +55,7 @@ mod tests;\n \n use std::sync::Arc;\n \n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n@@ -91,6 +91,19 @@ pub struct CrateDefMap {\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n     public_macros: FxHashMap<Name, MacroDefId>,\n+\n+    /// Some macros are not well-behavior, which leads to infinite loop\n+    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n+    /// We mark it down and skip it in collector\n+    ///\n+    /// FIXME:\n+    /// Right now it only handle a poison macro in a single crate,\n+    /// such that if other crate try to call that macro,\n+    /// the whole process will do again until it became poisoned in that crate.\n+    /// We should handle this macro set globally\n+    /// However, do we want to put it as a global variable?\n+    poison_macros: FxHashSet<MacroDefId>,\n+\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -195,6 +208,7 @@ impl CrateDefMap {\n                 root,\n                 modules,\n                 public_macros: FxHashMap::default(),\n+                poison_macros: FxHashSet::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "82738cce3b5271537ad6c8a7f0de9802b78f909a", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 172, "deletions": 14, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=b177813f3bef708636ec4be271e376b111c36a59", "patch": "@@ -42,14 +42,40 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         global_macro_scope: FxHashMap::default(),\n-        marco_stack_count: 0,\n+        macro_stack_monitor: SimpleMacroStackMonitor::default(),\n     };\n     collector.collect();\n     collector.finish()\n }\n \n+trait MacroStackMonitor {\n+    fn increase(&mut self, macro_def_id: MacroDefId);\n+    fn decrease(&mut self, macro_def_id: MacroDefId);\n+\n+    fn is_poison(&self, macro_def_id: MacroDefId) -> bool;\n+}\n+\n+#[derive(Default)]\n+struct SimpleMacroStackMonitor {\n+    counts: FxHashMap<MacroDefId, u32>,\n+}\n+\n+impl MacroStackMonitor for SimpleMacroStackMonitor {\n+    fn increase(&mut self, macro_def_id: MacroDefId) {\n+        *self.counts.entry(macro_def_id).or_default() += 1;\n+    }\n+\n+    fn decrease(&mut self, macro_def_id: MacroDefId) {\n+        *self.counts.entry(macro_def_id).or_default() -= 1;\n+    }\n+\n+    fn is_poison(&self, macro_def_id: MacroDefId) -> bool {\n+        *self.counts.get(&macro_def_id).unwrap_or(&0) > 100\n+    }\n+}\n+\n /// Walks the tree of module recursively\n-struct DefCollector<DB> {\n+struct DefCollector<DB, M> {\n     db: DB,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n@@ -59,12 +85,13 @@ struct DefCollector<DB> {\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stackoverflow, we add a deep counter here for prevent that.\n-    marco_stack_count: u32,\n+    macro_stack_monitor: M,\n }\n \n-impl<'a, DB> DefCollector<&'a DB>\n+impl<'a, DB, M> DefCollector<&'a DB, M>\n where\n     DB: DefDatabase,\n+    M: MacroStackMonitor,\n {\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n@@ -317,30 +344,40 @@ where\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n                 let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n-                resolved.push((*module_id, call_id));\n+                resolved.push((*module_id, call_id, macro_id));\n             }\n             false\n         });\n \n-        for (module_id, macro_call_id) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id);\n+        for (module_id, macro_call_id, macro_def_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id);\n         }\n         res\n     }\n \n-    fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n-        self.marco_stack_count += 1;\n+    fn collect_macro_expansion(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        macro_call_id: MacroCallId,\n+        macro_def_id: MacroDefId,\n+    ) {\n+        if self.def_map.poison_macros.contains(&macro_def_id) {\n+            return;\n+        }\n+\n+        self.macro_stack_monitor.increase(macro_def_id);\n \n-        if self.marco_stack_count < 300 {\n+        if !self.macro_stack_monitor.is_poison(macro_def_id) {\n             let file_id: HirFileId = macro_call_id.into();\n             let raw_items = self.db.raw_items(file_id);\n             ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items())\n+                .collect(raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {}\", macro_call_id.debug_dump(self.db));\n+            self.def_map.poison_macros.insert(macro_def_id);\n         }\n \n-        self.marco_stack_count -= 1;\n+        self.macro_stack_monitor.decrease(macro_def_id);\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -356,9 +393,10 @@ struct ModCollector<'a, D> {\n     raw_items: &'a raw::RawItems,\n }\n \n-impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n+impl<DB, M> ModCollector<'_, &'_ mut DefCollector<&'_ DB, M>>\n where\n     DB: DefDatabase,\n+    M: MacroStackMonitor,\n {\n     fn collect(&mut self, items: &[raw::RawItem]) {\n         for item in items {\n@@ -484,7 +522,7 @@ where\n         {\n             let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_id);\n             return;\n         }\n \n@@ -530,3 +568,123 @@ fn resolve_submodule(\n         None => Err(if is_dir_owner { file_mod } else { file_dir_mod }),\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_db::SourceDatabase;\n+\n+    use crate::{Crate, mock::MockDatabase, DefDatabase};\n+    use ra_arena::{Arena};\n+    use super::*;\n+    use rustc_hash::FxHashSet;\n+\n+    struct LimitedMacroStackMonitor {\n+        count: u32,\n+        limit: u32,\n+        poison_limit: u32,\n+    }\n+\n+    impl MacroStackMonitor for LimitedMacroStackMonitor {\n+        fn increase(&mut self, _: MacroDefId) {\n+            self.count += 1;\n+            assert!(self.count < self.limit);\n+        }\n+\n+        fn decrease(&mut self, _: MacroDefId) {\n+            self.count -= 1;\n+        }\n+\n+        fn is_poison(&self, _: MacroDefId) -> bool {\n+            self.count >= self.poison_limit\n+        }\n+    }\n+\n+    fn do_collect_defs(\n+        db: &impl DefDatabase,\n+        def_map: CrateDefMap,\n+        monitor: impl MacroStackMonitor,\n+    ) -> CrateDefMap {\n+        let mut collector = DefCollector {\n+            db,\n+            def_map,\n+            glob_imports: FxHashMap::default(),\n+            unresolved_imports: Vec::new(),\n+            unexpanded_macros: Vec::new(),\n+            global_macro_scope: FxHashMap::default(),\n+            macro_stack_monitor: monitor,\n+        };\n+        collector.collect();\n+        collector.finish()\n+    }\n+\n+    fn do_limited_resolve(code: &str, limit: u32, poison_limit: u32) -> CrateDefMap {\n+        let (db, _source_root, _) = MockDatabase::with_single_file(&code);\n+        let crate_id = db.crate_graph().iter().next().unwrap();\n+        let krate = Crate { crate_id };\n+\n+        let def_map = {\n+            let edition = krate.edition(&db);\n+            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                public_macros: FxHashMap::default(),\n+                poison_macros: FxHashSet::default(),\n+                diagnostics: Vec::new(),\n+            }\n+        };\n+\n+        do_collect_defs(&db, def_map, LimitedMacroStackMonitor { count: 0, limit, poison_limit })\n+    }\n+\n+    #[test]\n+    fn test_macro_expand_limit_width() {\n+        do_limited_resolve(\n+            r#\"\n+        macro_rules! foo {\n+            ($($ty:ty)*) => { foo!($($ty)*, $($ty)*); }\n+        }\n+foo!(KABOOM);\n+        \"#,\n+            16,\n+            1000,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_macro_expand_poisoned() {\n+        let def = do_limited_resolve(\n+            r#\"\n+        macro_rules! foo {\n+            ($ty:ty) => { foo!($ty); }\n+        }\n+foo!(KABOOM);\n+        \"#,\n+            100,\n+            16,\n+        );\n+\n+        assert_eq!(def.poison_macros.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_macro_expand_normal() {\n+        let def = do_limited_resolve(\n+            r#\"\n+        macro_rules! foo {\n+            ($ident:ident) => { struct $ident {} }\n+        }\n+foo!(Bar);\n+        \"#,\n+            16,\n+            16,\n+        );\n+\n+        assert_eq!(def.poison_macros.len(), 0);\n+    }\n+}"}, {"sha": "f07107414b89b9cdd7828d20321dbacfafdf489d", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=b177813f3bef708636ec4be271e376b111c36a59", "patch": "@@ -5,6 +5,7 @@ use ra_syntax::{SyntaxKind};\n \n struct OffsetTokenSink {\n     token_pos: usize,\n+    error: bool,\n }\n \n impl TreeSink for OffsetTokenSink {\n@@ -13,7 +14,9 @@ impl TreeSink for OffsetTokenSink {\n     }\n     fn start_node(&mut self, _kind: SyntaxKind) {}\n     fn finish_node(&mut self) {}\n-    fn error(&mut self, _error: ra_parser::ParseError) {}\n+    fn error(&mut self, _error: ra_parser::ParseError) {\n+        self.error = true;\n+    }\n }\n \n pub(crate) struct Parser<'a> {\n@@ -67,11 +70,15 @@ impl<'a> Parser<'a> {\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),\n     {\n         let mut src = SubtreeTokenSource::new(&self.subtree.token_trees[*self.cur_pos..]);\n-        let mut sink = OffsetTokenSink { token_pos: 0 };\n+        let mut sink = OffsetTokenSink { token_pos: 0, error: false };\n \n         f(&src, &mut sink);\n \n-        self.finish(sink.token_pos, &mut src)\n+        let r = self.finish(sink.token_pos, &mut src);\n+        if sink.error {\n+            return None;\n+        }\n+        r\n     }\n \n     fn finish(self, parsed_token: usize, src: &mut SubtreeTokenSource) -> Option<tt::TokenTree> {"}, {"sha": "9cc646140f70d2e037e61235b26aedacfaade4df", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b177813f3bef708636ec4be271e376b111c36a59/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=b177813f3bef708636ec4be271e376b111c36a59", "patch": "@@ -149,3 +149,15 @@ impl fmt::Display for Punct {\n         fmt::Display::fmt(&self.char, f)\n     }\n }\n+\n+impl Subtree {\n+    /// Count the number of tokens recursively\n+    pub fn count(&self) -> usize {\n+        self.token_trees.iter().fold(self.token_trees.len(), |acc, c| {\n+            acc + match c {\n+                TokenTree::Subtree(c) => c.count(),\n+                _ => 0,\n+            }\n+        })\n+    }\n+}"}]}