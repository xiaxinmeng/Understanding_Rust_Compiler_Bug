{"sha": "41d956bf632fbc658f21a4195344fe79b685cde9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZDk1NmJmNjMyZmJjNjU4ZjIxYTQxOTUzNDRmZTc5YjY4NWNkZTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-17T00:08:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-17T00:08:56Z"}, "message": "Rollup merge of #73269 - mzohreva:mz/sgx-wait-timeout, r=jethrogb\n\nEnable some timeouts in SGX platform\n\nThis would partially resolve https://github.com/fortanix/rust-sgx/issues/31\n\ncc @jethrogb and @Goirad", "tree": {"sha": "24b2fbdfb120b84814d6b1bd996e6dba940fd15e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24b2fbdfb120b84814d6b1bd996e6dba940fd15e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41d956bf632fbc658f21a4195344fe79b685cde9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEOwYCRBK7hj4Ov3rIwAAdHIIADC2pYH1pcJBkUnHkfEw/ymf\nQexMPd4OuZKO4Rux1P3jOm+3u3NEOrQSIpA7YBYYNWyHyKte4r5GlY7msB+c9G9p\niBECBtct12sC8nFcL40Z0PEUj2+d8KEyiF0RYuGaBe9x81JN8aVcZTQRjzsBT1VC\nNVRHD0v7IWP20pSkDQz/ycMDjeyS812d7VhNK7Cg0u+RwFX9DcrVNlU10hDYy50y\nsisJ8OPSvYDynuffO2eW0uygXVxBixg07yeJNfAkrqhc5HuQN/hnTxL/tv4HhexG\nV6lbB2wbyciQXT8ZN/3FsZdCz2bPxfuK9iGAxUxTX11PJTkEKYS19EBVVHa1tak=\n=n0ge\n-----END PGP SIGNATURE-----\n", "payload": "tree 24b2fbdfb120b84814d6b1bd996e6dba940fd15e\nparent ec93d566b3ef29d5b97acca520558b5b05104f20\nparent 85c25aed510ce599504b172f7c7bef280e91637b\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594944536 -0700\ncommitter GitHub <noreply@github.com> 1594944536 -0700\n\nRollup merge of #73269 - mzohreva:mz/sgx-wait-timeout, r=jethrogb\n\nEnable some timeouts in SGX platform\n\nThis would partially resolve https://github.com/fortanix/rust-sgx/issues/31\n\ncc @jethrogb and @Goirad\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41d956bf632fbc658f21a4195344fe79b685cde9", "html_url": "https://github.com/rust-lang/rust/commit/41d956bf632fbc658f21a4195344fe79b685cde9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41d956bf632fbc658f21a4195344fe79b685cde9/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec93d566b3ef29d5b97acca520558b5b05104f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec93d566b3ef29d5b97acca520558b5b05104f20", "html_url": "https://github.com/rust-lang/rust/commit/ec93d566b3ef29d5b97acca520558b5b05104f20"}, {"sha": "85c25aed510ce599504b172f7c7bef280e91637b", "url": "https://api.github.com/repos/rust-lang/rust/commits/85c25aed510ce599504b172f7c7bef280e91637b", "html_url": "https://github.com/rust-lang/rust/commit/85c25aed510ce599504b172f7c7bef280e91637b"}], "stats": {"total": 263, "additions": 215, "deletions": 48}, "files": [{"sha": "9b90bfd68b50f3047ec1ee6e01245efe98311a11", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -694,7 +694,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -714,7 +713,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_while_wait() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());\n@@ -739,7 +737,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_while_wake() {\n         let pair = Arc::new((Mutex::new(false), Condvar::new()));\n         let pair_copy = pair.clone();\n@@ -763,7 +760,6 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn wait_timeout_wake() {\n         let m = Arc::new(Mutex::new(()));\n         let c = Arc::new(Condvar::new());"}, {"sha": "3ff50e9f213477716e1f39447a5d4451ca2cfc62", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -2088,7 +2088,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn oneshot_single_thread_recv_timeout() {\n         let (tx, rx) = channel();\n         tx.send(()).unwrap();\n@@ -2099,7 +2098,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2130,7 +2128,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout_upgrade() {\n         let (tx, rx) = channel::<()>();\n         let timeout = Duration::from_millis(1);\n@@ -2142,7 +2139,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -2173,7 +2169,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn very_long_recv_timeout_wont_panic() {\n         let (tx, rx) = channel::<()>();\n         let join_handle = thread::spawn(move || rx.recv_timeout(Duration::from_secs(u64::MAX)));\n@@ -2195,7 +2190,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn shared_recv_timeout() {\n         let (tx, rx) = channel();\n         let total = 5;\n@@ -2425,7 +2419,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn recv_timeout() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.recv_timeout(Duration::from_millis(1)), Err(RecvTimeoutError::Timeout));\n@@ -2517,7 +2510,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n@@ -2543,7 +2535,6 @@ mod sync_tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn stress_recv_timeout_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;"}, {"sha": "73f1b951e74304b0d406ba631e0f9c26896fac79", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -1,6 +1,8 @@\n use crate::cmp;\n-use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n-use crate::time::Duration;\n+use crate::convert::TryFrom;\n+use crate::io::{Error as IoError, ErrorKind, IoSlice, IoSliceMut, Result as IoResult};\n+use crate::sys::rand::rdrand64;\n+use crate::time::{Duration, Instant};\n \n pub(crate) mod alloc;\n #[macro_use]\n@@ -149,10 +151,94 @@ pub fn exit(panic: bool) -> ! {\n \n /// Usercall `wait`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n-pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n+pub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n+    if timeout != WAIT_NO && timeout != WAIT_INDEFINITE {\n+        // We don't want people to rely on accuracy of timeouts to make\n+        // security decisions in an SGX enclave. That's why we add a random\n+        // amount not exceeding +/- 10% to the timeout value to discourage\n+        // people from relying on accuracy of timeouts while providing a way\n+        // to make things work in other cases. Note that in the SGX threat\n+        // model the enclave runner which is serving the wait usercall is not\n+        // trusted to ensure accurate timeouts.\n+        if let Ok(timeout_signed) = i64::try_from(timeout) {\n+            let tenth = timeout_signed / 10;\n+            let deviation = (rdrand64() as i64).checked_rem(tenth).unwrap_or(0);\n+            timeout = timeout_signed.saturating_add(deviation) as _;\n+        }\n+    }\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n }\n \n+/// This function makes an effort to wait for a non-spurious event at least as\n+/// long as `duration`. Note that in general there is no guarantee about accuracy\n+/// of time and timeouts in SGX model. The enclave runner serving usercalls may\n+/// lie about current time and/or ignore timeout values.\n+///\n+/// Once the event is observed, `should_wake_up` will be used to determine\n+/// whether or not the event was spurious.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn wait_timeout<F>(event_mask: u64, duration: Duration, should_wake_up: F)\n+where\n+    F: Fn() -> bool,\n+{\n+    // Calls the wait usercall and checks the result. Returns true if event was\n+    // returned, and false if WouldBlock/TimedOut was returned.\n+    // If duration is None, it will use WAIT_NO.\n+    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n+        let timeout = duration.map_or(raw::WAIT_NO, |duration| {\n+            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n+        });\n+        match wait(event_mask, timeout) {\n+            Ok(eventset) => {\n+                if event_mask == 0 {\n+                    rtabort!(\"expected wait() to return Err, found Ok.\");\n+                }\n+                rtassert!(eventset != 0 && eventset & !event_mask == 0);\n+                true\n+            }\n+            Err(e) => {\n+                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n+                false\n+            }\n+        }\n+    }\n+\n+    match wait_checked(event_mask, Some(duration)) {\n+        false => return,                    // timed out\n+        true if should_wake_up() => return, // woken up\n+        true => {}                          // spurious event\n+    }\n+\n+    // Drain all cached events.\n+    // Note that `event_mask != 0` is implied if we get here.\n+    loop {\n+        match wait_checked(event_mask, None) {\n+            false => break,                     // no more cached events\n+            true if should_wake_up() => return, // woken up\n+            true => {}                          // spurious event\n+        }\n+    }\n+\n+    // Continue waiting, but take note of time spent waiting so we don't wait\n+    // forever. We intentionally don't call `Instant::now()` before this point\n+    // to avoid the cost of the `insecure_time` usercall in case there are no\n+    // spurious wakeups.\n+\n+    let start = Instant::now();\n+    let mut remaining = duration;\n+    loop {\n+        match wait_checked(event_mask, Some(remaining)) {\n+            false => return,                    // timed out\n+            true if should_wake_up() => return, // woken up\n+            true => {}                          // spurious event\n+        }\n+        remaining = match duration.checked_sub(start.elapsed()) {\n+            Some(remaining) => remaining,\n+            None => break,\n+        }\n+    }\n+}\n+\n /// Usercall `send`. See the ABI documentation for more information.\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {"}, {"sha": "ed6dbcf497147f68834e71a85bdad2165fc50f6c", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -31,8 +31,10 @@ impl Condvar {\n         mutex.lock()\n     }\n \n-    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n-        rtabort!(\"timeout not supported in SGX\");\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let success = WaitQueue::wait_timeout(&self.inner, dur, || mutex.unlock());\n+        mutex.lock();\n+        success\n     }\n \n     #[inline]"}, {"sha": "1d32eb25424345578d63d378ad1fa3c9d463f4db", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -137,8 +137,8 @@ pub extern \"C\" fn __rust_abort() {\n     abort_internal();\n }\n \n-pub fn hashmap_random_keys() -> (u64, u64) {\n-    fn rdrand64() -> u64 {\n+pub mod rand {\n+    pub fn rdrand64() -> u64 {\n         unsafe {\n             let mut ret: u64 = 0;\n             for _ in 0..10 {\n@@ -149,7 +149,10 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n             rtabort!(\"Failed to obtain random data\");\n         }\n     }\n-    (rdrand64(), rdrand64())\n+}\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    (self::rand::rdrand64(), self::rand::rdrand64())\n }\n \n pub use crate::sys_common::{AsInner, FromInner, IntoInner};"}, {"sha": "5895f70436efa4a6f36547fd36e24fb0bffd048f", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -73,8 +73,8 @@ impl Thread {\n         // FIXME: could store this pointer in TLS somewhere\n     }\n \n-    pub fn sleep(_dur: Duration) {\n-        rtabort!(\"can't sleep\"); // FIXME\n+    pub fn sleep(dur: Duration) {\n+        usercalls::wait_timeout(0, dur, || true);\n     }\n \n     pub fn join(self) {"}, {"sha": "070afa55f301927e3d5f7ac429a5fb930e3c595c", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 112, "deletions": 17, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -1,16 +1,17 @@\n+//! A simple queue implementation for synchronization primitives.\n+//!\n+//! This queue is used to implement condition variable and mutexes.\n+//!\n+//! Users of this API are expected to use the `WaitVariable<T>` type. Since\n+//! that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n+//! allow shared access.\n+//!\n+//! Since userspace may send spurious wake-ups, the wakeup event state is\n+//! recorded in the enclave. The wakeup event state is protected by a spinlock.\n+//! The queue and associated wait state are stored in a `WaitVariable`.\n use crate::num::NonZeroUsize;\n-/// A simple queue implementation for synchronization primitives.\n-///\n-/// This queue is used to implement condition variable and mutexes.\n-///\n-/// Users of this API are expected to use the `WaitVariable<T>` type. Since\n-/// that type is not `Sync`, it needs to be protected by e.g., a `SpinMutex` to\n-/// allow shared access.\n-///\n-/// Since userspace may send spurious wake-ups, the wakeup event state is\n-/// recorded in the enclave. The wakeup event state is protected by a spinlock.\n-/// The queue and associated wait state are stored in a `WaitVariable`.\n use crate::ops::{Deref, DerefMut};\n+use crate::time::Duration;\n \n use super::abi::thread;\n use super::abi::usercalls;\n@@ -158,6 +159,34 @@ impl WaitQueue {\n         }\n     }\n \n+    /// Adds the calling thread to the `WaitVariable`'s wait queue, then wait\n+    /// until a wakeup event or timeout. If event was observed, returns true.\n+    /// If not, it will remove the calling thread from the wait queue.\n+    pub fn wait_timeout<T, F: FnOnce()>(\n+        lock: &SpinMutex<WaitVariable<T>>,\n+        timeout: Duration,\n+        before_wait: F,\n+    ) -> bool {\n+        // very unsafe: check requirements of UnsafeList::push\n+        unsafe {\n+            let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n+                tcs: thread::current(),\n+                wake: false,\n+            }));\n+            let entry_lock = lock.lock().queue.inner.push(&mut entry);\n+            before_wait();\n+            usercalls::wait_timeout(EV_UNPARK, timeout, || entry_lock.lock().wake);\n+            // acquire the wait queue's lock first to avoid deadlock.\n+            let mut guard = lock.lock();\n+            let success = entry_lock.lock().wake;\n+            if !success {\n+                // nobody is waking us up, so remove our entry from the wait queue.\n+                guard.queue.inner.remove(&mut entry);\n+            }\n+            success\n+        }\n+    }\n+\n     /// Either find the next waiter on the wait queue, or return the mutex\n     /// guard unchanged.\n     ///\n@@ -325,6 +354,31 @@ mod unsafe_list {\n                 Some((*first.as_ptr()).value.as_ref().unwrap())\n             }\n         }\n+\n+        /// Removes an entry from the list.\n+        ///\n+        /// # Safety\n+        ///\n+        /// The caller must ensure that `entry` has been pushed onto `self`\n+        /// prior to this call and has not moved since then.\n+        pub unsafe fn remove(&mut self, entry: &mut UnsafeListEntry<T>) {\n+            rtassert!(!self.is_empty());\n+            // BEFORE:\n+            //     /----\\ next ---> /-----\\ next ---> /----\\\n+            // ... |prev|           |entry|           |next| ...\n+            //     \\----/ <--- prev \\-----/ <--- prev \\----/\n+            //\n+            // AFTER:\n+            //     /----\\ next ---> /----\\\n+            // ... |prev|           |next| ...\n+            //     \\----/ <--- prev \\----/\n+            let mut prev = entry.prev;\n+            let mut next = entry.next;\n+            prev.as_mut().next = next;\n+            next.as_mut().prev = prev;\n+            entry.next = NonNull::dangling();\n+            entry.prev = NonNull::dangling();\n+        }\n     }\n \n     #[cfg(test)]\n@@ -354,6 +408,51 @@ mod unsafe_list {\n             }\n         }\n \n+        #[test]\n+        fn push_remove() {\n+            unsafe {\n+                let mut node = UnsafeListEntry::new(1234);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node), &1234);\n+                list.remove(&mut node);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n+        #[test]\n+        fn push_remove_pop() {\n+            unsafe {\n+                let mut node1 = UnsafeListEntry::new(11);\n+                let mut node2 = UnsafeListEntry::new(12);\n+                let mut node3 = UnsafeListEntry::new(13);\n+                let mut node4 = UnsafeListEntry::new(14);\n+                let mut node5 = UnsafeListEntry::new(15);\n+                let mut list = UnsafeList::new();\n+                assert_eq!(list.push(&mut node1), &11);\n+                assert_eq!(list.push(&mut node2), &12);\n+                assert_eq!(list.push(&mut node3), &13);\n+                assert_eq!(list.push(&mut node4), &14);\n+                assert_eq!(list.push(&mut node5), &15);\n+\n+                list.remove(&mut node1);\n+                assert_eq!(list.pop().unwrap(), &12);\n+                list.remove(&mut node3);\n+                assert_eq!(list.pop().unwrap(), &14);\n+                list.remove(&mut node5);\n+                assert_empty(&mut list);\n+\n+                assert_eq!(list.push(&mut node1), &11);\n+                assert_eq!(list.pop().unwrap(), &11);\n+                assert_empty(&mut list);\n+\n+                assert_eq!(list.push(&mut node3), &13);\n+                assert_eq!(list.push(&mut node4), &14);\n+                list.remove(&mut node3);\n+                list.remove(&mut node4);\n+                assert_empty(&mut list);\n+            }\n+        }\n+\n         #[test]\n         fn complex_pushes_pops() {\n             unsafe {\n@@ -474,7 +573,7 @@ mod spin_mutex {\n         use super::*;\n         use crate::sync::Arc;\n         use crate::thread;\n-        use crate::time::{Duration, SystemTime};\n+        use crate::time::Duration;\n \n         #[test]\n         fn sleep() {\n@@ -485,11 +584,7 @@ mod spin_mutex {\n                 *mutex2.lock() = 1;\n             });\n \n-            // \"sleep\" for 50ms\n-            // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-            let start = SystemTime::now();\n-            let max = Duration::from_millis(50);\n-            while start.elapsed().unwrap() < max {}\n+            thread::sleep(Duration::from_millis(50));\n \n             assert_eq!(*guard, 0);\n             drop(guard);"}, {"sha": "202867258f1e403006c53b07932a67e2dfb9915f", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -1741,15 +1741,13 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n             thread::park_timeout(Duration::from_millis(10));\n         }\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn test_park_timeout_unpark_called_other_thread() {\n         for _ in 0..10 {\n             let th = thread::current();\n@@ -1764,7 +1762,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n     fn sleep_ms_smoke() {\n         thread::sleep(Duration::from_millis(2));\n     }"}, {"sha": "a2b11764a2fc64cfd46297caa3ab313676789d93", "filename": "src/test/ui/issues/issue-59020.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fissues%2Fissue-59020.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fissues%2Fissue-59020.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59020.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -1,7 +1,6 @@\n // edition:2018\n // run-pass\n // ignore-emscripten no threads support\n-// ignore-sgx no thread sleep support\n \n use std::thread;\n use std::time::Duration;"}, {"sha": "3e7e9a51cdd3ad044d8bee4281abad20283c0345", "filename": "src/test/ui/issues/issue-9396.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fissues%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fissues%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-9396.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -2,7 +2,6 @@\n #![allow(unused_must_use)]\n #![allow(deprecated)]\n // ignore-emscripten no threads support\n-// ignore-sgx no thread sleep support\n \n use std::sync::mpsc::{TryRecvError, channel};\n use std::thread;"}, {"sha": "a889542fec0be8a673acdb4ae1299898771c8759", "filename": "src/test/ui/mpsc_stress.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fmpsc_stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fmpsc_stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmpsc_stress.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n // compile-flags:--test\n // ignore-emscripten\n-// ignore-sgx no thread sleep support\n \n use std::sync::mpsc::channel;\n use std::sync::mpsc::TryRecvError;\n@@ -37,6 +36,8 @@ impl Barrier {\n     fn wait(self) {\n         self.shared.fetch_add(1, Ordering::SeqCst);\n         while self.shared.load(Ordering::SeqCst) != self.count {\n+            #[cfg(target_env = \"sgx\")]\n+            thread::yield_now();\n         }\n     }\n }"}, {"sha": "3b3a4a4f3250cb21d66b98a7a535a7618167fef5", "filename": "src/test/ui/sleep.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fsleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Fsleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsleep.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n // ignore-emscripten no threads support\n-// ignore-sgx no thread sleep support\n \n use std::thread::{self, sleep};\n use std::time::Duration;"}, {"sha": "08b47dc531857c1ef493f5f94378f3f5d0eb6a29", "filename": "src/test/ui/tcp-stress.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41d956bf632fbc658f21a4195344fe79b685cde9/src%2Ftest%2Fui%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftcp-stress.rs?ref=41d956bf632fbc658f21a4195344fe79b685cde9", "patch": "@@ -4,7 +4,6 @@\n // ignore-emscripten no threads or sockets support\n // ignore-netbsd system ulimit (Too many open files)\n // ignore-openbsd system ulimit (Too many open files)\n-// ignore-sgx no thread sleep support\n \n use std::io::prelude::*;\n use std::net::{TcpListener, TcpStream};"}]}