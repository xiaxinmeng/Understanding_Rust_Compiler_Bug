{"sha": "f906c5458c43d0666dd9af37f44cd46a190f0506", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MDZjNTQ1OGM0M2QwNjY2ZGQ5YWYzN2Y0NGNkNDZhMTkwZjA1MDY=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-07-26T21:37:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-26T21:37:52Z"}, "message": "Merge pull request #272 from oli-obk/mir-validate\n\nMir validate", "tree": {"sha": "bdf5414d2f805a95716e688eb163d9f243b38876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdf5414d2f805a95716e688eb163d9f243b38876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f906c5458c43d0666dd9af37f44cd46a190f0506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f906c5458c43d0666dd9af37f44cd46a190f0506", "html_url": "https://github.com/rust-lang/rust/commit/f906c5458c43d0666dd9af37f44cd46a190f0506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f906c5458c43d0666dd9af37f44cd46a190f0506/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46324c24ca56ec41606ab54a9c16fb3b7660fb5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/46324c24ca56ec41606ab54a9c16fb3b7660fb5f", "html_url": "https://github.com/rust-lang/rust/commit/46324c24ca56ec41606ab54a9c16fb3b7660fb5f"}, {"sha": "791dbaf58402ef87c16485be8d8ee37b5aa1dda3", "url": "https://api.github.com/repos/rust-lang/rust/commits/791dbaf58402ef87c16485be8d8ee37b5aa1dda3", "html_url": "https://github.com/rust-lang/rust/commit/791dbaf58402ef87c16485be8d8ee37b5aa1dda3"}], "stats": {"total": 944, "additions": 898, "deletions": 46}, "files": [{"sha": "d6da3afe8fc8f4782532f2407e683b4c71aeaa61", "filename": "Cargo.lock", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -6,8 +6,10 @@ dependencies = [\n  \"cargo_metadata 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiletest_rs 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -18,6 +20,14 @@ dependencies = [\n  \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.0.0\"\n@@ -101,6 +111,14 @@ dependencies = [\n  \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"memchr\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"num-traits\"\n version = \"0.1.37\"\n@@ -123,11 +141,28 @@ dependencies = [\n  \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"regex\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc-serialize\"\n version = \"0.3.24\"\n@@ -203,16 +238,43 @@ dependencies = [\n  \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"thread_local\"\n+version = \"0.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"unicode-xid\"\n version = \"0.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"unreachable\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"utf8-ranges\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"utf8-ranges\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"void\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\"\n@@ -225,6 +287,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n+\"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n \"checksum byteorder 1.0.0 (git+https://github.com/BurntSushi/byteorder)\" = \"<none>\"\n \"checksum cargo_metadata 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d84cb53c78e573aa126a4b9f963fdb2629f8183b26e235da08bb36dc7381162\"\n \"checksum compiletest_rs 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"617b23d0ed4f57b3bcff6b5fe0a78f0010f1efb636298317665a960b6dbc0533\"\n@@ -237,10 +300,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n \"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n \"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n+\"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n \"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n+\"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n+\"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum serde 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b46a59dd63931010fdb1d88538513f3279090d88b5c22ef4fe8440cfffcc6e3\"\n \"checksum serde_derive 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6c06b68790963518008b8ae0152d48be4bbbe77015d2c717f6282eea1824be9a\"\n@@ -250,7 +316,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n+\"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\"\n \"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n+\"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n \"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n+\"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n+\"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "330e9e0748b5c22de51d9043443b61995b73d452", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -32,6 +32,8 @@ env_logger = \"0.3.3\"\n log = \"0.3.6\"\n log_settings = \"0.1.1\"\n cargo_metadata = \"0.2\"\n+regex = \"0.2.2\"\n+lazy_static = \"0.2.8\"\n \n [dev-dependencies]\n compiletest_rs = \"0.2.6\""}, {"sha": "dfcbd7d0cee67e88559e14faa838534fcd3b50e0", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::{MemoryPointer, Kind};\n+use memory::{MemoryPointer, LockInfo, AccessKind, Kind};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -51,6 +51,30 @@ pub enum EvalError<'tcx> {\n         required: u64,\n         has: u64,\n     },\n+    MemoryLockViolation {\n+        ptr: MemoryPointer,\n+        len: u64,\n+        frame: usize,\n+        access: AccessKind,\n+        lock: LockInfo,\n+    },\n+    MemoryAcquireConflict {\n+        ptr: MemoryPointer,\n+        len: u64,\n+        kind: AccessKind,\n+        lock: LockInfo,\n+    },\n+    InvalidMemoryLockRelease {\n+        ptr: MemoryPointer,\n+        len: u64,\n+        frame: usize,\n+        lock: LockInfo,\n+    },\n+    DeallocatedLockedMemory {\n+        ptr: MemoryPointer,\n+        lock: LockInfo,\n+    },\n+    ValidationFailure(String),\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n     ModifiedConstantMemory,\n@@ -97,6 +121,16 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"pointer offset outside bounds of allocation\",\n             InvalidNullPointerUsage =>\n                 \"invalid use of NULL pointer\",\n+            MemoryLockViolation { .. } =>\n+                \"memory access conflicts with lock\",\n+            MemoryAcquireConflict { .. } =>\n+                \"new memory lock conflicts with existing lock\",\n+            ValidationFailure(..) =>\n+                \"type validation failed\",\n+            InvalidMemoryLockRelease { .. } =>\n+                \"invalid attempt to release write lock\",\n+            DeallocatedLockedMemory { .. } =>\n+                \"tried to deallocate memory in conflict with a lock\",\n             ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             ReadBytesAsPointer =>\n@@ -196,6 +230,25 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        if access { \"memory access\" } else { \"pointer computed\" },\n                        ptr.offset, ptr.alloc_id, allocation_size)\n             },\n+            MemoryLockViolation { ptr, len, frame, access, ref lock } => {\n+                write!(f, \"{:?} access by frame {} at {:?}, size {}, is in conflict with lock {:?}\",\n+                       access, frame, ptr, len, lock)\n+            }\n+            MemoryAcquireConflict { ptr, len, kind, ref lock } => {\n+                write!(f, \"new {:?} lock at {:?}, size {}, is in conflict with lock {:?}\",\n+                       kind, ptr, len, lock)\n+            }\n+            InvalidMemoryLockRelease { ptr, len, frame, ref lock } => {\n+                write!(f, \"frame {} tried to release memory write lock at {:?}, size {}, but cannot release lock {:?}\",\n+                       frame, ptr, len, lock)\n+            }\n+            DeallocatedLockedMemory { ptr, ref lock } => {\n+                write!(f, \"tried to deallocate memory at {:?} in conflict with lock {:?}\",\n+                       ptr, lock)\n+            }\n+            ValidationFailure(ref err) => {\n+                write!(f, \"type validation failed: {}\", err)\n+            }\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             FunctionPointerTyMismatch(sig, got) =>\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),"}, {"sha": "331ae7e248b15e5bdf5f5a84c33d4eb894d369e8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -4,6 +4,7 @@ use std::fmt::Write;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::ConstVal;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n@@ -21,6 +22,7 @@ use memory::{Memory, MemoryPointer, TlsKey, HasMemory};\n use memory::Kind as MemoryKind;\n use operator;\n use value::{PrimVal, PrimValKind, Value, Pointer};\n+use validation::ValidationQuery;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -29,6 +31,11 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The virtual memory system.\n     pub(crate) memory: Memory<'a, 'tcx>,\n \n+    #[allow(dead_code)]\n+    // FIXME(@RalfJung): validation branch\n+    /// Lvalues that were suspended by the validation subsystem, and will be recovered later\n+    pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n+\n     /// Precomputed statics, constants and promoteds.\n     pub(crate) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n@@ -112,6 +119,12 @@ pub enum StackPopCleanup {\n     None,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DynamicLifetime {\n+    pub frame: usize,\n+    pub region: Option<CodeExtent>, // \"None\" indicates \"until the function ends\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct ResourceLimits {\n     pub memory_size: u64,\n@@ -134,6 +147,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         EvalContext {\n             tcx,\n             memory: Memory::new(&tcx.data_layout, limits.memory_size),\n+            suspended: HashMap::new(),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n@@ -169,6 +183,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n+    #[inline]\n+    pub fn cur_frame(&self) -> usize {\n+        assert!(self.stack.len() > 0);\n+        self.stack.len() - 1\n+    }\n+\n     /// Returns true if the current frame or any parent frame is part of a ctfe.\n     ///\n     /// Used to disable features in const eval, which do not have a rfc enabling\n@@ -336,6 +356,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             stmt: 0,\n         });\n \n+        let cur_frame = self.cur_frame();\n+        self.memory.set_cur_frame(cur_frame);\n+\n         if self.stack.len() > self.stack_limit {\n             Err(EvalError::StackFrameLimitReached)\n         } else {\n@@ -345,7 +368,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n+        self.memory.locks_lifetime_ended(None);\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n+        if !self.stack.is_empty() {\n+            // TODO: IS this the correct time to start considering these accesses as originating from the returned-to stack frame?\n+            let cur_frame = self.cur_frame();\n+            self.memory.set_cur_frame(cur_frame);\n+        }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => if let Lvalue::Global(id) = frame.return_lvalue {\n                 let global_value = self.globals.get_mut(&id)\n@@ -1551,9 +1580,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         if let Lvalue::Local { frame, local } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n-            let last_frame = self.stack.len() - 1;\n-            if frame != last_frame {\n-                write!(msg, \" ({} frames up)\", last_frame - frame).unwrap();\n+            if frame != self.cur_frame() {\n+                write!(msg, \" ({} frames up)\", self.cur_frame() - frame).unwrap();\n             }\n             write!(msg, \":\").unwrap();\n "}, {"sha": "e4ab3d90a5c1abc924eae433a00b4ed1628fc3f7", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -7,7 +7,7 @@ use syntax::ast::Mutability;\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use memory::MemoryPointer;\n-use value::{PrimVal, Value, Pointer};\n+use value::{PrimVal, Pointer, Value};\n \n #[derive(Copy, Clone, Debug)]\n pub enum Lvalue<'tcx> {\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local },\n+            Local(local) => Lvalue::Local { frame: self.cur_frame(), local },\n \n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n@@ -349,7 +349,33 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n-    fn eval_lvalue_projection(\n+    pub(super) fn val_to_lvalue(&mut self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        Ok(match self.tcx.struct_tail(ty).sty {\n+            ty::TyDynamic(..) => {\n+                let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n+                Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true }\n+            },\n+            ty::TyStr | ty::TySlice(_) => {\n+                let (ptr, len) = val.into_slice(&mut self.memory)?;\n+                Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true }\n+            },\n+            _ => Lvalue::Ptr { ptr: val.into_ptr(&mut self.memory)?, extra: LvalueExtra::None, aligned: true },\n+        })\n+    }\n+\n+    pub(super) fn lvalue_index(&mut self, base: Lvalue<'tcx>, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n+        let base = self.force_allocation(base)?;\n+        let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+\n+        let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n+        let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+        assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n+        let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n+        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned })\n+    }\n+\n+    pub(super) fn eval_lvalue_projection(\n         &mut self,\n         base: Lvalue<'tcx>,\n         base_ty: Ty<'tcx>,\n@@ -388,32 +414,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 trace!(\"deref to {} on {:?}\", pointee_type, val);\n \n-                match self.tcx.struct_tail(pointee_type).sty {\n-                    ty::TyDynamic(..) => {\n-                        let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n-                        (ptr, LvalueExtra::Vtable(vtable), true)\n-                    },\n-                    ty::TyStr | ty::TySlice(_) => {\n-                        let (ptr, len) = val.into_slice(&mut self.memory)?;\n-                        (ptr, LvalueExtra::Length(len), true)\n-                    },\n-                    _ => (val.into_ptr(&mut self.memory)?, LvalueExtra::None, true),\n-                }\n+                return self.val_to_lvalue(val, pointee_type);\n             }\n \n             Index(ref operand) => {\n                 // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n-\n-                let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n-                assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n-                let ptr = base_ptr.offset(n * elem_size, &self)?;\n-                (ptr, LvalueExtra::None, aligned)\n+                return self.lvalue_index(base, base_ty, n);\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {"}, {"sha": "461fced3c6090652f07b561d8d1ba93a0acd05fe", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 279, "deletions": 14, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -1,14 +1,102 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr, mem, io};\n+use std::{fmt, iter, ptr, mem, io, ops};\n \n use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n+use rustc::middle::region::CodeExtent;\n \n use error::{EvalError, EvalResult};\n use value::{PrimVal, Pointer};\n-use eval_context::EvalContext;\n+use eval_context::{EvalContext, DynamicLifetime};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Locks\n+////////////////////////////////////////////////////////////////////////////////\n+\n+mod range {\n+    use super::*;\n+\n+    // The derived `Ord` impl sorts first by the first field, then, if the fields are the same,\n+    // by the second field.\n+    // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n+    // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n+    // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n+    // This kind of search breaks, if `end < start`, so don't do that!\n+    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+    pub struct MemoryRange {\n+        start: u64,\n+        end: u64,\n+    }\n+\n+    impl MemoryRange {\n+        #[allow(dead_code)]\n+        // FIXME(@RalfJung): validation branch\n+        pub fn new(offset: u64, len: u64) -> MemoryRange {\n+            assert!(len > 0);\n+            MemoryRange {\n+                start: offset,\n+                end: offset + len,\n+            }\n+        }\n+\n+        pub fn range(offset: u64, len: u64) -> ops::Range<MemoryRange> {\n+            assert!(len > 0);\n+            // We select all elements that are within\n+            // the range given by the offset into the allocation and the length.\n+            // This is sound if \"self.contains() || self.overlaps() == true\" implies that self is in-range.\n+            let left = MemoryRange {\n+                start: 0,\n+                end: offset,\n+            };\n+            let right = MemoryRange {\n+                start: offset + len + 1,\n+                end: 0,\n+            };\n+            left..right\n+        }\n+\n+        #[allow(dead_code)]\n+        // FIXME(@RalfJung): validation branch\n+        pub fn contained_in(&self, offset: u64, len: u64) -> bool {\n+            assert!(len > 0);\n+            offset <= self.start && self.end <= (offset + len)\n+        }\n+\n+        pub fn overlaps(&self, offset: u64, len: u64) -> bool {\n+            assert!(len > 0);\n+            //let non_overlap = (offset + len) <= self.start || self.end <= offset;\n+            (offset + len) > self.start && self.end > offset\n+        }\n+    }\n+}\n+use self::range::*;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+}\n+\n+/// Information about a lock that is currently held.\n+#[derive(Clone, Debug)]\n+pub enum LockInfo {\n+    WriteLock(DynamicLifetime),\n+    ReadLock(Vec<DynamicLifetime>), // This should never be empty -- that would be a read lock held and nobody there to release it...\n+}\n+use self::LockInfo::*;\n+\n+impl LockInfo {\n+    fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n+        use self::AccessKind::*;\n+        match (self, access) {\n+            (&ReadLock(_), Read) => true, // Read access to read-locked region is okay, no matter who's holding the read lock.\n+            (&WriteLock(ref lft), _) if Some(lft.frame) == frame => true, // All access is okay when we hold the write lock.\n+            _ => false, // Nothing else is okay.\n+        }\n+    }\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -41,6 +129,35 @@ pub struct Allocation {\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: Kind,\n+    /// Memory regions that are locked by some function\n+    locks: BTreeMap<MemoryRange, LockInfo>,\n+}\n+\n+impl Allocation {\n+    fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a LockInfo)> + 'a {\n+        self.locks.range(MemoryRange::range(offset, len))\n+            .filter(move |&(range, _)| range.overlaps(offset, len))\n+    }\n+\n+    #[allow(dead_code)]\n+    // FIXME(@RalfJung): validation branch\n+    fn iter_locks_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a mut LockInfo)> + 'a {\n+        self.locks.range_mut(MemoryRange::range(offset, len))\n+            .filter(move |&(range, _)| range.overlaps(offset, len))\n+    }\n+\n+    fn check_locks<'tcx>(&self, frame: Option<usize>, offset: u64, len: u64, access: AccessKind) -> Result<(), LockInfo> {\n+        if len == 0 {\n+            return Ok(())\n+        }\n+        for (_, lock) in self.iter_locks(offset, len) {\n+            // Check if the lock is in conflict with the access.\n+            if !lock.access_permitted(frame, access) {\n+                return Err(lock.clone());\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -96,6 +213,10 @@ impl<'tcx> MemoryPointer {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Top-level interpreter memory\n+////////////////////////////////////////////////////////////////////////////////\n+\n pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n@@ -104,10 +225,6 @@ pub struct TlsEntry<'tcx> {\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Top-level interpreter memory\n-////////////////////////////////////////////////////////////////////////////////\n-\n pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     alloc_map: HashMap<AllocId, Allocation>,\n@@ -151,6 +268,9 @@ pub struct Memory<'a, 'tcx> {\n     /// alignment checking is currently enforced for read and/or write accesses.\n     reads_are_aligned: bool,\n     writes_are_aligned: bool,\n+\n+    /// The current stack frame.  Used to check accesses against locks.\n+    cur_frame: usize,\n }\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n@@ -169,6 +289,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             next_thread_local: 0,\n             reads_are_aligned: true,\n             writes_are_aligned: true,\n+            cur_frame: usize::max_value(),\n         }\n     }\n \n@@ -220,6 +341,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             align,\n             kind,\n             mutable: Mutability::Mutable,\n+            locks: BTreeMap::new(),\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -257,6 +379,14 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             None => return Err(EvalError::DoubleFree),\n         };\n \n+        // It is okay for us to still holds locks on deallocation -- for example, we could store data we own\n+        // in a local, and the local could be deallocated (from StorageDead) before the function returns.\n+        // However, we should check *something*.  For now, we make sure that there is no conflicting write\n+        // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n+        // TODO: Figure out the exact rules here.\n+        alloc.check_locks(Some(self.cur_frame), 0, alloc.bytes.len() as u64, AccessKind::Read)\n+            .map_err(|lock| EvalError::DeallocatedLockedMemory { ptr, lock })?;\n+\n         if alloc.kind != kind {\n             return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n         }\n@@ -280,7 +410,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.layout.endian\n     }\n \n-    /// Check that the pointer is aligned and non-NULL\n+    /// Check that the pointer is aligned AND non-NULL.\n     pub fn check_align(&self, ptr: Pointer, align: u64) -> EvalResult<'tcx> {\n         let offset = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n@@ -321,6 +451,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n+    pub(crate) fn set_cur_frame(&mut self, cur_frame: usize) {\n+        self.cur_frame = cur_frame;\n+    }\n+\n     pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n@@ -397,6 +531,129 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n }\n \n+/// Locking\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n+    pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n+        if len == 0 {\n+            return Ok(())\n+        }\n+        let alloc = self.get(ptr.alloc_id)?;\n+        let frame = self.cur_frame;\n+        alloc.check_locks(Some(frame), ptr.offset, len, access)\n+            .map_err(|lock| EvalError::MemoryLockViolation { ptr, len, frame, access, lock })\n+    }\n+\n+    #[allow(dead_code)]\n+    // FIXME(@RalfJung): validation branch\n+    /// Acquire the lock for the given lifetime\n+    pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n+        use std::collections::btree_map::Entry::*;\n+\n+        let frame = self.cur_frame;\n+        assert!(len > 0);\n+        trace!(\"Frame {} acquiring {:?} lock at {:?}, size {} for region {:?}\", frame, kind, ptr, len, region);\n+        self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n+\n+        // Check if this conflicts with other locks\n+        alloc.check_locks(None, ptr.offset, len, kind)\n+            .map_err(|lock| EvalError::MemoryAcquireConflict { ptr, len, kind, lock })?;\n+\n+        let lifetime = DynamicLifetime { frame, region };\n+        match (alloc.locks.entry(MemoryRange::new(ptr.offset, len)), kind) {\n+            (Vacant(entry), AccessKind::Read) => { entry.insert(ReadLock(vec![lifetime])); },\n+            (Vacant(entry), AccessKind::Write) => { entry.insert(WriteLock(lifetime)); },\n+            (Occupied(mut entry), AccessKind::Read) =>\n+                match *entry.get_mut() {\n+                    ReadLock(ref mut lifetimes) => lifetimes.push(lifetime),\n+                    WriteLock(_) => bug!(\"We already checked that there is no conflicting write lock\"),\n+                },\n+            (Occupied(_), AccessKind::Write) => bug!(\"We already checked that there is no conflicting lock\"),\n+        };\n+        Ok(())\n+    }\n+\n+    #[allow(dead_code)]\n+    // FIXME(@RalfJung): validation branch\n+    /// Release a write lock prematurely. If there's a read lock or someone else's lock, fail.\n+    pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64) -> EvalResult<'tcx> {\n+        assert!(len > 0);\n+        let cur_frame = self.cur_frame;\n+        let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n+\n+        let mut remove_list : Vec<MemoryRange> = Vec::new();\n+        for (range, lock) in alloc.iter_locks_mut(ptr.offset, len) {\n+            match *lock {\n+                WriteLock(ref lft) => {\n+                    // Make sure we can release this lock\n+                    if lft.frame != cur_frame {\n+                        return Err(EvalError::InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n+                    }\n+                    if !range.contained_in(ptr.offset, len) {\n+                        return Err(EvalError::Unimplemented(format!(\"miri does not support releasing part of a write-locked region\")));\n+                    }\n+                    // Release it later.  We cannot do this now.\n+                    remove_list.push(*range);\n+                }\n+                ReadLock(_) => {\n+                    // Abort here and bubble the error outwards so that we do not even register a suspension.\n+                    return Err(EvalError::InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.clone() });\n+                },\n+            }\n+        }\n+\n+        for range in remove_list {\n+            trace!(\"Releasing {:?}\", alloc.locks[&range]);\n+            alloc.locks.remove(&range);\n+        }\n+\n+        // TODO: Test that we actually released a write lock for the entire covered region.\n+\n+        Ok(())\n+    }\n+\n+    pub(crate) fn locks_lifetime_ended(&mut self, ending_region: Option<CodeExtent>) {\n+        let cur_frame = self.cur_frame;\n+        trace!(\"Releasing frame {} locks that expire at {:?}\", cur_frame, ending_region);\n+        let has_ended =  |lifetime: &DynamicLifetime| -> bool {\n+            if lifetime.frame != cur_frame {\n+                return false;\n+            }\n+            match ending_region {\n+                None => true, // When a function ends, we end *all* its locks. It's okay for a function to still have lifetime-related locks\n+                              // when it returns, that can happen e.g. with NLL when a lifetime can, but does not have to, extend beyond the\n+                              // end of a function.  Same for a function still having recoveries.\n+                Some(ending_region) => lifetime.region == Some(ending_region),\n+            }\n+        };\n+\n+        for alloc in self.alloc_map.values_mut() {\n+            // Collect things for removal as we cannot remove while iterating\n+            let mut remove_list : Vec<MemoryRange> = Vec::new();\n+            for (range, lock) in alloc.locks.iter_mut() {\n+                // Delete everything that ends now -- i.e., keep only all the other lifetimes.\n+                match *lock {\n+                    WriteLock(ref lft) => {\n+                        if has_ended(lft) {\n+                            remove_list.push(*range);\n+                        }\n+                    }\n+                    ReadLock(ref mut lfts) => {\n+                        lfts.retain(|lft| !has_ended(lft));\n+                        if lfts.is_empty() {\n+                            remove_list.push(*range);\n+                        }\n+                    },\n+                }\n+            }\n+            // Perform delayed removal\n+            for range in remove_list {\n+                alloc.locks.remove(&range);\n+            }\n+        }\n+    }\n+}\n+\n /// Allocation accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n@@ -408,21 +665,26 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n+    \n+    fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => if alloc.mutable == Mutability::Mutable {\n-                Ok(alloc)\n-            } else {\n-                Err(EvalError::ModifiedConstantMemory)\n-            },\n+            Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n                 None => Err(EvalError::DanglingPointerDeref),\n             }\n         }\n     }\n \n+    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n+        let alloc = self.get_mut_unchecked(id)?;\n+        if alloc.mutable == Mutability::Mutable {\n+            Ok(alloc)\n+        } else {\n+            Err(EvalError::ModifiedConstantMemory)\n+        }\n+    }\n+\n     pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         if ptr.offset != 0 {\n             return Err(EvalError::InvalidFunctionPointer);\n@@ -540,6 +802,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n+        self.check_locks(ptr, size, AccessKind::Read)?;\n         self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -556,6 +819,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n+        self.check_locks(ptr, size, AccessKind::Write)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -694,6 +958,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     return Err(EvalError::ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, (size + 1) as u64)?;\n+                self.check_locks(ptr, (size + 1) as u64, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             },\n             None => Err(EvalError::UnterminatedCString(ptr)),"}, {"sha": "90f174f9d60a833f8a77c80251ae9d346597d217", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -1,6 +1,7 @@\n #![feature(\n     i128_type,\n     rustc_private,\n+    conservative_impl_trait,\n )]\n \n // From rustc.\n@@ -15,12 +16,16 @@ extern crate syntax;\n \n // From crates.io.\n extern crate byteorder;\n+#[macro_use]\n+extern crate lazy_static;\n+extern crate regex;\n \n mod cast;\n mod const_eval;\n mod error;\n mod eval_context;\n mod lvalue;\n+mod validation;\n mod memory;\n mod operator;\n mod step;"}, {"sha": "86e123233061b043029524430c99b026e314b990", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -7,8 +7,9 @@ use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir;\n use rustc::traits::Reveal;\n+use rustc::ty;\n use rustc::ty::layout::Layout;\n-use rustc::ty::{subst, self};\n+use rustc::ty::subst::Substs;\n \n use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup};\n@@ -116,7 +117,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // Mark locals as dead or alive.\n             StorageLive(ref lvalue) | StorageDead(ref lvalue)=> {\n                 let (frame, local) = match self.eval_lvalue(lvalue)? {\n-                    Lvalue::Local{ frame, local } if self.stack.len() == frame+1 => (frame, local),\n+                    Lvalue::Local{ frame, local } if self.cur_frame() == frame => (frame, local),\n                     _ => return Err(EvalError::Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n                 };\n                 let old_val = match stmt.kind {\n@@ -127,8 +128,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.deallocate_local(old_val)?;\n             }\n \n-            // Just a borrowck thing\n-            EndRegion(..) => {}\n+            // NOPs for now.\n+            EndRegion(_ce) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly.\n@@ -167,7 +168,7 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n     fn global_item(\n         &mut self,\n         def_id: DefId,\n-        substs: &'tcx subst::Substs<'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n         span: Span,\n         mutability: Mutability,\n     ) {"}, {"sha": "3ee6bab77e051d6d7608841e75d28f32efc4e82f", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n-        trace!(\"read_discriminant_value {:#?}\", adt_layout);\n+        //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, signed: false, .. } => {"}, {"sha": "4c9e239299dc778c3dd4a858c9e69699388d9711", "filename": "src/librustc_mir/interpret/validation.rs", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -0,0 +1,418 @@\n+// code for @RalfJung's validation branch is dead for now\n+#![allow(dead_code)]\n+\n+use rustc::hir::Mutability;\n+use rustc::hir::Mutability::*;\n+use rustc::mir;\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::subst::Subst;\n+use rustc::traits::Reveal;\n+use rustc::infer::TransNormalize;\n+use rustc::middle::region::CodeExtent;\n+\n+use error::{EvalError, EvalResult};\n+use eval_context::{EvalContext, DynamicLifetime};\n+use memory::{AccessKind, LockInfo};\n+use value::{PrimVal, Value};\n+use lvalue::{Lvalue, LvalueExtra};\n+\n+// FIXME remove this once it lands in rustc\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum ValidationOp {\n+    Acquire,\n+    Release,\n+    Suspend(CodeExtent),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct ValidationOperand<'tcx, T> {\n+    pub lval: T,\n+    pub ty: Ty<'tcx>,\n+    pub re: Option<CodeExtent>,\n+    pub mutbl: Mutability,\n+}\n+// FIXME end\n+\n+pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue<'tcx>>;\n+\n+#[derive(Copy, Clone, Debug)]\n+enum ValidationMode {\n+    Acquire,\n+    /// Recover because the given region ended\n+    Recover(CodeExtent),\n+    Release\n+}\n+\n+impl ValidationMode {\n+    fn acquiring(self) -> bool {\n+        use self::ValidationMode::*;\n+        match self {\n+            Acquire | Recover(_) => true,\n+            Release => false,\n+        }\n+    }\n+}\n+\n+// Validity checks\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n+        // HACK: Determine if this method is whitelisted and hence we do not perform any validation.\n+        {\n+            // The regexp we use for filtering\n+            use regex::Regex;\n+            lazy_static! {\n+                static ref RE: Regex = Regex::new(\"^(\\\n+std::mem::swap::|\\\n+std::mem::uninitialized::|\\\n+std::ptr::read::|\\\n+std::panicking::try::do_call::|\\\n+std::slice::from_raw_parts_mut::|\\\n+<std::heap::Heap as std::heap::Alloc>::|\\\n+<std::mem::ManuallyDrop<T>><std::heap::AllocErr>::new$|\\\n+<std::mem::ManuallyDrop<T> as std::ops::DerefMut><std::heap::AllocErr>::deref_mut$|\\\n+std::sync::atomic::AtomicBool::get_mut$|\\\n+<std::boxed::Box<T>><[a-zA-Z0-9_\\\\[\\\\]]+>::from_raw|\\\n+<[a-zA-Z0-9_:<>]+ as std::slice::SliceIndex<[a-zA-Z0-9_\\\\[\\\\]]+>><[a-zA-Z0-9_\\\\[\\\\]]+>::get_unchecked_mut$|\\\n+<alloc::raw_vec::RawVec<T, std::heap::Heap>><[a-zA-Z0-9_\\\\[\\\\]]+>::into_box$|\\\n+<std::vec::Vec<T>><[a-zA-Z0-9_\\\\[\\\\]]+>::into_boxed_slice$\\\n+)\").unwrap();\n+            }\n+            // Now test\n+            let name = self.stack[self.cur_frame()].instance.to_string();\n+            if RE.is_match(&name) {\n+                return Ok(())\n+            }\n+        }\n+\n+        // We need to monomorphize ty *without* erasing lifetimes\n+        let ty = operand.ty.subst(self.tcx, self.substs());\n+        let lval = self.eval_lvalue(&operand.lval)?;\n+        let query = ValidationQuery { lval, ty, re: operand.re, mutbl: operand.mutbl };\n+\n+        let mode = match op {\n+            ValidationOp::Acquire => ValidationMode::Acquire,\n+            ValidationOp::Release => ValidationMode::Release,\n+            ValidationOp::Suspend(_) => ValidationMode::Release,\n+        };\n+        match self.validate(query.clone(), mode) {\n+            Err(EvalError::InvalidMemoryLockRelease { lock: LockInfo::ReadLock(_), .. }) => {\n+                // HACK: When &x is used while x is already borrowed read-only, AddValidation still\n+                // emits suspension.  This code is legit, so just ignore the error *and*\n+                // do NOT register a suspension.\n+                // TODO: Integrate AddValidation better with borrowck so that we can/ not emit\n+                // these wrong validation statements.  This is all pretty fragile right now.\n+                return Ok(());\n+            }\n+            res => res,\n+        }?;\n+        // Now that we are here, we know things went well.  Time to register the suspension.\n+        match op {\n+            ValidationOp::Suspend(ce) => {\n+                if query.mutbl == MutMutable {\n+                    let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+                    trace!(\"Suspending {:?} until {:?}\", query, ce);\n+                    self.suspended.entry(lft).or_insert_with(Vec::new).push(query);\n+                }\n+            }\n+            _ => {}\n+        };\n+        Ok(())\n+    }\n+\n+    pub(crate) fn end_region(&mut self, ce: CodeExtent) -> EvalResult<'tcx> {\n+        self.memory.locks_lifetime_ended(Some(ce));\n+        // Recover suspended lvals\n+        let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+        if let Some(queries) = self.suspended.remove(&lft) {\n+            for query in queries {\n+                trace!(\"Recovering {:?} from suspension\", query);\n+                self.validate(query, ValidationMode::Recover(ce))?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn validate_variant(\n+        &mut self,\n+        query: ValidationQuery<'tcx>,\n+        variant: &ty::VariantDef,\n+        subst: &ty::subst::Substs<'tcx>,\n+        mode: ValidationMode,\n+    ) -> EvalResult<'tcx> {\n+        // TODO: Maybe take visibility/privacy into account.\n+        for (idx, field) in variant.fields.iter().enumerate() {\n+            let field_ty = field.ty(self.tcx, subst);\n+            let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+            self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, re: Option<CodeExtent>, mutbl: Mutability, mode: ValidationMode) -> EvalResult<'tcx> {\n+        // Check alignment and non-NULLness\n+        let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n+        let ptr = val.into_ptr(&mut self.memory)?;\n+        self.memory.check_align(ptr, align)?;\n+\n+        // Recurse\n+        let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n+        self.validate(ValidationQuery { lval: pointee_lvalue, ty: pointee_ty, re, mutbl }, mode)\n+    }\n+\n+    /// Validate the lvalue at the given type. If `acquire` is false, just do a release of all write locks\n+    #[inline]\n+    fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n+    {\n+        match self.try_validate(query, mode) {\n+            // HACK: If, during releasing, we hit memory we cannot use, we just ignore that.\n+            // This can happen because releases are added before drop elaboration.\n+            // TODO: Fix the MIR so that these releases do not happen.\n+            res @ Err(EvalError::DanglingPointerDeref) | res @ Err(EvalError::ReadUndefBytes) => {\n+                if let ValidationMode::Release = mode {\n+                    return Ok(());\n+                }\n+                res\n+            }\n+            res => res,\n+        }\n+    }\n+\n+    fn try_validate(&mut self, mut query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n+    {\n+        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::RegionKind::*;\n+        use rustc::ty::AdtKind;\n+\n+        // No point releasing shared stuff.\n+        if !mode.acquiring() && query.mutbl == MutImmutable {\n+            return Ok(());\n+        }\n+        // When we recover, we may see data whose validity *just* ended.  Do not acquire it.\n+        if let ValidationMode::Recover(ce) = mode {\n+            if Some(ce) == query.re {\n+                return Ok(());\n+            }\n+        }\n+\n+        // HACK: For now, bail out if we hit a dead local during recovery (can happen because sometimes we have\n+        // StorageDead before EndRegion).\n+        // TODO: We should rather fix the MIR.\n+        // HACK: Releasing on dead/undef local variables is a NOP.  This can happen because of releases being added\n+        // before drop elaboration.\n+        // TODO: Fix the MIR so that these releases do not happen.\n+        match query.lval {\n+            Lvalue::Local { frame, local } => {\n+                let res = self.stack[frame].get_local(local);\n+                match (res, mode) {\n+                    (Err(EvalError::DeadLocal), ValidationMode::Recover(_)) |\n+                    (Err(EvalError::DeadLocal), ValidationMode::Release) |\n+                    (Ok(Value::ByVal(PrimVal::Undef)), ValidationMode::Release) => {\n+                        return Ok(());\n+                    }\n+                    _ => {},\n+                }\n+            },\n+            _ => {}\n+        }\n+\n+        // This is essentially a copy of normalize_associated_type, but without erasure\n+        if query.ty.has_projection_types() {\n+            let param_env = ty::ParamEnv::empty(Reveal::All);\n+            let old_ty = query.ty;\n+            query.ty = self.tcx.infer_ctxt().enter(move |infcx| {\n+                old_ty.trans_normalize(&infcx, param_env)\n+            })\n+        }\n+        trace!(\"{:?} on {:?}\", mode, query);\n+\n+        // Decide whether this type *owns* the memory it covers (like integers), or whether it\n+        // just assembles pieces (that each own their memory) together to a larger whole.\n+        // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n+        let is_owning = match query.ty.sty {\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) |\n+            TyBool | TyFloat(_) | TyChar | TyStr |\n+            TyRef(..) | TyFnPtr(..) | TyFnDef(..) | TyNever => true,\n+            TyAdt(adt, _) if adt.is_box() => true,\n+            TySlice(_) | TyAdt(_, _) | TyTuple(..) | TyClosure(..) | TyArray(..) | TyDynamic(..) => false,\n+            TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => bug!(\"I got an incomplete/unnormalized type for validation\"),\n+        };\n+        if is_owning {\n+            match query.lval {\n+                Lvalue::Ptr { ptr, extra, aligned: _ } => {\n+                    // Determine the size\n+                    // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n+                    let len = match self.type_size(query.ty)? {\n+                        Some(size) => {\n+                            assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n+                            size\n+                        }\n+                        None => {\n+                            // The only unsized typ we concider \"owning\" is TyStr.\n+                            assert_eq!(query.ty.sty, TyStr, \"Found a surprising unsized owning type\");\n+                            // The extra must be the length, in bytes.\n+                            match extra {\n+                                LvalueExtra::Length(len) => len,\n+                                _ => bug!(\"TyStr must have a length as extra\"),\n+                            }\n+                        }\n+                    };\n+                    // Handle locking\n+                    if len > 0 {\n+                        let ptr = ptr.to_ptr()?;\n+                        let access = match query.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+                        if mode.acquiring() {\n+                            self.memory.acquire_lock(ptr, len, query.re, access)?;\n+                        } else {\n+                            self.memory.release_write_lock(ptr, len)?;\n+                        }\n+                    }\n+                }\n+                Lvalue::Local { .. } | Lvalue::Global(..) => {\n+                    // These are not backed by memory, so we have nothing to do.\n+                }\n+            }\n+        }\n+\n+        match query.ty.sty {\n+            TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n+                // TODO: Make sure these are not undef.\n+                // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n+                Ok(())\n+            }\n+            TyBool | TyFloat(_) | TyChar | TyStr => {\n+                // TODO: Check if these are valid bool/float/codepoint/UTF-8, respectively (and in particular, not undef).\n+                Ok(())\n+            }\n+            TyNever => {\n+                Err(EvalError::ValidationFailure(format!(\"The empty type is never valid.\")))\n+            }\n+            TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n+                let val = self.read_lvalue(query.lval)?;\n+                // Sharing restricts our context\n+                if mutbl == MutImmutable {\n+                    query.mutbl = MutImmutable;\n+                }\n+                // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n+                // we record the region of this borrow to the context.\n+                if query.re == None {\n+                    match *region {\n+                        ReScope(ce) => query.re = Some(ce),\n+                        // It is possible for us to encounter erased lifetimes here because the lifetimes in\n+                        // this functions' Subst will be erased.\n+                        _ => {},\n+                    }\n+                }\n+                self.validate_ptr(val, pointee_ty, query.re, query.mutbl, mode)\n+            }\n+            TyAdt(adt, _) if adt.is_box() => {\n+                let val = self.read_lvalue(query.lval)?;\n+                self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n+            }\n+            TyFnPtr(_sig) => {\n+                let ptr = self.read_lvalue(query.lval)?.into_ptr(&mut self.memory)?.to_ptr()?;\n+                self.memory.get_fn(ptr)?;\n+                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                Ok(())\n+            }\n+            TyFnDef(..) => {\n+                // This is a zero-sized type with all relevant data sitting in the type.\n+                // There is nothing to validate.\n+                Ok(())\n+            }\n+\n+            // Compound types\n+            TySlice(elem_ty) => {\n+                let len = match query.lval {\n+                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n+                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", query.lval),\n+                };\n+                for i in 0..len {\n+                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i)?;\n+                    self.validate(ValidationQuery { lval: inner_lvalue, ty: elem_ty, ..query }, mode)?;\n+                }\n+                Ok(())\n+            }\n+            TyArray(elem_ty, len) => {\n+                for i in 0..len {\n+                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i as u64)?;\n+                    self.validate(ValidationQuery { lval: inner_lvalue, ty: elem_ty, ..query }, mode)?;\n+                }\n+                Ok(())\n+            }\n+            TyDynamic(_data, _region) => {\n+                // Check that this is a valid vtable\n+                let vtable = match query.lval {\n+                    Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n+                    _ => bug!(\"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\", query.lval),\n+                };\n+                self.read_size_and_align_from_vtable(vtable)?;\n+                // TODO: Check that the vtable contains all the function pointers we expect it to have.\n+                // Trait objects cannot have any operations performed\n+                // on them directly.  We cannot, in general, even acquire any locks as the trait object *could*\n+                // contain an UnsafeCell.  If we call functions to get access to data, we will validate\n+                // their return values.  So, it doesn't seem like there's anything else to do.\n+                Ok(())\n+            }\n+            TyAdt(adt, subst) => {\n+                if Some(adt.did) == self.tcx.lang_items.unsafe_cell_type() && query.mutbl == MutImmutable {\n+                    // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n+                    return Ok(());\n+                }\n+\n+                match adt.adt_kind() {\n+                    AdtKind::Enum => {\n+                        // TODO: Can we get the discriminant without forcing an allocation?\n+                        let ptr = self.force_allocation(query.lval)?.to_ptr()?;\n+                        let discr = self.read_discriminant_value(ptr, query.ty)?;\n+\n+                        // Get variant index for discriminant\n+                        let variant_idx = adt.discriminants(self.tcx)\n+                            .position(|variant_discr| variant_discr.to_u128_unchecked() == discr)\n+                            .ok_or(EvalError::InvalidDiscriminant)?;\n+                        let variant = &adt.variants[variant_idx];\n+\n+                        if variant.fields.len() > 0 {\n+                            // Downcast to this variant, if needed\n+                            let lval = if adt.variants.len() > 1 {\n+                                self.eval_lvalue_projection(query.lval, query.ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?\n+                            } else {\n+                                query.lval\n+                            };\n+\n+                            // Recursively validate the fields\n+                            self.validate_variant(ValidationQuery { lval, ..query} , variant, subst, mode)\n+                        } else {\n+                            // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n+                            Ok(())\n+                        }\n+                    }\n+                    AdtKind::Struct => {\n+                        self.validate_variant(query, adt.struct_variant(), subst, mode)\n+                    }\n+                    AdtKind::Union => {\n+                        // No guarantees are provided for union types.\n+                        // TODO: Make sure that all access to union fields is unsafe; otherwise, we may have some checking to do (but what exactly?)\n+                        Ok(())\n+                    }\n+                }\n+            }\n+            TyTuple(ref types, _) => {\n+                for (idx, field_ty) in types.iter().enumerate() {\n+                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+                    self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n+                }\n+                Ok(())\n+            }\n+            TyClosure(def_id, ref closure_substs) => {\n+                for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n+                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+                    self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n+                }\n+                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                // Is there other things we can/should check?  Like vtable pointers?\n+                Ok(())\n+            }\n+            _ => bug!(\"We already establishd that this is a type we support.\")\n+        }\n+    }\n+}"}, {"sha": "afbd4760a3c9ba67703c00685b360cb630ec30bb", "filename": "tests/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f906c5458c43d0666dd9af37f44cd46a190f0506/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f906c5458c43d0666dd9af37f44cd46a190f0506/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=f906c5458c43d0666dd9af37f44cd46a190f0506", "patch": "@@ -55,4 +55,5 @@ fn main() {\n     let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n     let z : &BarS<[u32]> = unsafe{&*bar_ref};\n     assert_eq!(&z.0, &[0,1,2]);\n+    // If validation fails here, that's likely because an immutable suspension is recovered mutably.\n }"}]}