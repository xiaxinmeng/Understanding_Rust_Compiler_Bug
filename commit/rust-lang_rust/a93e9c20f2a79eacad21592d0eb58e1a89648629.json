{"sha": "a93e9c20f2a79eacad21592d0eb58e1a89648629", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5M2U5YzIwZjJhNzllYWNhZDIxNTkyZDBlYjU4ZTFhODk2NDg2Mjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-27T03:57:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-27T03:57:37Z"}, "message": "auto merge of #18130 : mahkoh/rust/udp, r=alexcrichton\n\nCloses #18111\r\n\r\nNote that the non-empty part doesn't matter right now because of #18129.", "tree": {"sha": "7ac61badd4d32ca18c31fe1bbb2ad7dfe17e36b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ac61badd4d32ca18c31fe1bbb2ad7dfe17e36b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a93e9c20f2a79eacad21592d0eb58e1a89648629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a93e9c20f2a79eacad21592d0eb58e1a89648629", "html_url": "https://github.com/rust-lang/rust/commit/a93e9c20f2a79eacad21592d0eb58e1a89648629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a93e9c20f2a79eacad21592d0eb58e1a89648629/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f037452447f5f46deb26e1c483fe88fb51a19198", "url": "https://api.github.com/repos/rust-lang/rust/commits/f037452447f5f46deb26e1c483fe88fb51a19198", "html_url": "https://github.com/rust-lang/rust/commit/f037452447f5f46deb26e1c483fe88fb51a19198"}, {"sha": "d6dc01e7974bc6dc77b50563bd690c839eb66656", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6dc01e7974bc6dc77b50563bd690c839eb66656", "html_url": "https://github.com/rust-lang/rust/commit/d6dc01e7974bc6dc77b50563bd690c839eb66656"}], "stats": {"total": 45, "additions": 32, "deletions": 13}, "files": [{"sha": "7d9eea3a73279bf535fdeb6cc8cb230fe6bf6718", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a93e9c20f2a79eacad21592d0eb58e1a89648629/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93e9c20f2a79eacad21592d0eb58e1a89648629/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=a93e9c20f2a79eacad21592d0eb58e1a89648629", "patch": "@@ -100,6 +100,8 @@ impl UdpSocket {\n     ///\n     /// Note that this call does not perform any actual network communication,\n     /// because UDP is a datagram protocol.\n+    #[deprecated = \"`UdpStream` has been deprecated\"]\n+    #[allow(deprecated)]\n     pub fn connect(self, other: SocketAddr) -> UdpStream {\n         UdpStream {\n             socket: self,\n@@ -205,6 +207,14 @@ impl Clone for UdpSocket {\n \n /// A type that allows convenient usage of a UDP stream connected to one\n /// address via the `Reader` and `Writer` traits.\n+///\n+/// # Note\n+///\n+/// This structure has been deprecated because `Reader` is a stream-oriented API but UDP\n+/// is a packet-oriented protocol. Every `Reader` method will read a whole packet and\n+/// throw all superfluous bytes away so that they are no longer available for further\n+/// method calls.\n+#[deprecated]\n pub struct UdpStream {\n     socket: UdpSocket,\n     connected_to: SocketAddr\n@@ -225,13 +235,15 @@ impl UdpStream {\n }\n \n impl Reader for UdpStream {\n+    /// Returns the next non-empty message from the specified address.\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let peer = self.connected_to;\n         self.as_socket(|sock| {\n-            match sock.recv_from(buf) {\n-                Ok((_nread, src)) if src != peer => Ok(0),\n-                Ok((nread, _src)) => Ok(nread),\n-                Err(e) => Err(e),\n+            loop {\n+                let (nread, src) = try!(sock.recv_from(buf));\n+                if nread > 0 && src == peer {\n+                    return Ok(nread);\n+                }\n             }\n         })\n     }\n@@ -334,22 +346,28 @@ mod test {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn stream_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n+        let dummy_ip = next_test_ip4();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n         spawn(proc() {\n-            match UdpSocket::bind(client_ip) {\n-                Ok(client) => {\n-                    let client = box client;\n-                    let mut stream = client.connect(server_ip);\n-                    rx1.recv();\n-                    stream.write([99]).unwrap();\n+            let send_as = |ip, val: &[u8]| {\n+                match UdpSocket::bind(ip) {\n+                    Ok(client) => {\n+                        let client = box client;\n+                        let mut stream = client.connect(server_ip);\n+                        stream.write(val).unwrap();\n+                    }\n+                    Err(..) => fail!()\n                 }\n-                Err(..) => fail!()\n-            }\n+            };\n+            rx1.recv();\n+            send_as(dummy_ip, [98]);\n+            send_as(client_ip, [99]);\n             tx2.send(());\n         });\n \n@@ -364,7 +382,7 @@ mod test {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n                     }\n-                    Err(..) => fail!()\n+                    Err(..) => fail!(),\n                 }\n             }\n             Err(..) => fail!()\n@@ -373,6 +391,7 @@ mod test {\n     }\n \n     #[test]\n+    #[allow(deprecated)]\n     fn stream_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();"}]}