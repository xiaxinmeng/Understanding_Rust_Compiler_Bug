{"sha": "57a603795160250de09dd4e3634c099a2d76fb58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTYwMzc5NTE2MDI1MGRlMDlkZDRlMzYzNGMwOTlhMmQ3NmZiNTg=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-09T14:07:56Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-11T09:58:20Z"}, "message": "Improve Option doc", "tree": {"sha": "768b5286934d08490b0d6cd21a1ccc8103b88038", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/768b5286934d08490b0d6cd21a1ccc8103b88038"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a603795160250de09dd4e3634c099a2d76fb58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a603795160250de09dd4e3634c099a2d76fb58", "html_url": "https://github.com/rust-lang/rust/commit/57a603795160250de09dd4e3634c099a2d76fb58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a603795160250de09dd4e3634c099a2d76fb58/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "url": "https://api.github.com/repos/rust-lang/rust/commits/48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "html_url": "https://github.com/rust-lang/rust/commit/48dc0ba307abe4e0abdc16db7ebc5915bf813f01"}], "stats": {"total": 78, "additions": 50, "deletions": 28}, "files": [{"sha": "dacb396ee402815ef6e5969e36e5e76ac44618b2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/57a603795160250de09dd4e3634c099a2d76fb58/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a603795160250de09dd4e3634c099a2d76fb58/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=57a603795160250de09dd4e3634c099a2d76fb58", "patch": "@@ -10,9 +10,9 @@\n \n //! Optional values.\n //!\n-//! Type `Option` represents an optional value: every `Option`\n-//! is either `Some` and contains a value, or `None`, and\n-//! does not. `Option` types are very common in Rust code, as\n+//! Type [`Option`] represents an optional value: every [`Option`]\n+//! is either [`Some`] and contains a value, or [`None`], and\n+//! does not. [`Option`] types are very common in Rust code, as\n //! they have a number of uses:\n //!\n //! * Initial values\n@@ -26,8 +26,8 @@\n //! * Nullable pointers\n //! * Swapping things out of difficult situations\n //!\n-//! Options are commonly paired with pattern matching to query the presence\n-//! of a value and take action, always accounting for the `None` case.\n+//! [`Option`]s are commonly paired with pattern matching to query the presence\n+//! of a value and take action, always accounting for the [`None`] case.\n //!\n //! ```\n //! fn divide(numerator: f64, denominator: f64) -> Option<f64> {\n@@ -57,13 +57,13 @@\n //!\n //! Rust's pointer types must always point to a valid location; there are\n //! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n-//! the optional owned box, `Option<Box<T>>`.\n+//! the optional owned box, [`Option`]`<`[`Box<T>`]`>`.\n //!\n-//! The following example uses `Option` to create an optional box of\n-//! `i32`. Notice that in order to use the inner `i32` value first the\n+//! The following example uses [`Option`] to create an optional box of\n+//! [`i32`]. Notice that in order to use the inner [`i32`] value first the\n //! `check_optional` function needs to use pattern matching to\n-//! determine whether the box has a value (i.e. it is `Some(...)`) or\n-//! not (`None`).\n+//! determine whether the box has a value (i.e. it is [`Some(...)`][`Some`]) or\n+//! not ([`None`]).\n //!\n //! ```\n //! let optional: Option<Box<i32>> = None;\n@@ -80,14 +80,14 @@\n //! }\n //! ```\n //!\n-//! This usage of `Option` to create safe nullable pointers is so\n+//! This usage of [`Option`] to create safe nullable pointers is so\n //! common that Rust does special optimizations to make the\n-//! representation of `Option<Box<T>>` a single pointer. Optional pointers\n+//! representation of [`Option`]`<`[`Box<T>`]`>` a single pointer. Optional pointers\n //! in Rust are stored as efficiently as any other pointer type.\n //!\n //! # Examples\n //!\n-//! Basic pattern matching on `Option`:\n+//! Basic pattern matching on [`Option`]:\n //!\n //! ```\n //! let msg = Some(\"howdy\");\n@@ -101,7 +101,7 @@\n //! let unwrapped_msg = msg.unwrap_or(\"default message\");\n //! ```\n //!\n-//! Initialize a result to `None` before a loop:\n+//! Initialize a result to [`None`] before a loop:\n //!\n //! ```\n //! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n@@ -136,6 +136,12 @@\n //!     None => println!(\"there are no animals :(\"),\n //! }\n //! ```\n+//!\n+//! [`Option`]: enum.Option.html\n+//! [`Some`]: enum.Option.html#variant.Some\n+//! [`None`]: enum.Option.html#variant.None\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`i32`]: ../../std/primitive.i32.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -156,7 +162,7 @@ pub enum Option<T> {\n     None,\n     /// Some value `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T)\n+    Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -168,7 +174,7 @@ impl<T> Option<T> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `true` if the option is a `Some` value\n+    /// Returns `true` if the option is a `Some` value.\n     ///\n     /// # Examples\n     ///\n@@ -188,7 +194,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns `true` if the option is a `None` value\n+    /// Returns `true` if the option is a `None` value.\n     ///\n     /// # Examples\n     ///\n@@ -209,15 +215,17 @@ impl<T> Option<T> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Converts from `Option<T>` to `Option<&T>`\n+    /// Converts from `Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n     ///\n     /// Convert an `Option<String>` into an `Option<usize>`, preserving the original.\n-    /// The `map` method takes the `self` argument by value, consuming the original,\n+    /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n+    /// [`map`]: enum.Option.html#method.map\n+    ///\n     /// ```\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n@@ -234,7 +242,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<&mut T>`\n+    /// Converts from `Option<T>` to `Option<&mut T>`.\n     ///\n     /// # Examples\n     ///\n@@ -357,7 +365,7 @@ impl<T> Option<T> {\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n     ///\n     /// # Examples\n     ///\n@@ -423,8 +431,12 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n-    /// `Ok(v)` and `None` to `Err(err)`.\n+    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping `Some(v)` to\n+    /// [`Ok(v)`] and `None` to [`Err(err)`][Err].\n+    ///\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [Err]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -444,8 +456,12 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to\n-    /// `Ok(v)` and `None` to `Err(err())`.\n+    /// Transforms the `Option<T>` into a [`Result<T, E>`], mapping `Some(v)` to\n+    /// [`Ok(v)`] and `None` to [`Err(err())`][Err].\n+    ///\n+    /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+    /// [`Ok(v)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [Err]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -789,7 +805,9 @@ impl<A> DoubleEndedIterator for Item<A> {\n impl<A> ExactSizeIterator for Item<A> {}\n impl<A> FusedIterator for Item<A> {}\n \n-/// An iterator over a reference of the contained item in an Option.\n+/// An iterator over a reference of the contained item in an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n@@ -823,7 +841,9 @@ impl<'a, A> Clone for Iter<'a, A> {\n     }\n }\n \n-/// An iterator over a mutable reference of the contained item in an Option.\n+/// An iterator over a mutable reference of the contained item in an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n@@ -850,7 +870,9 @@ impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, A> FusedIterator for IterMut<'a, A> {}\n \n-/// An iterator over the item contained inside an Option.\n+/// An iterator over the item contained inside an [`Option`].\n+///\n+/// [`Option`]: enum.Option.html\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> { inner: Item<A> }"}]}