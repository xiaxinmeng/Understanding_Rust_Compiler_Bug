{"sha": "b498e1d71537a79e7aff5378da625aca8b4eef96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OThlMWQ3MTUzN2E3OWU3YWZmNTM3OGRhNjI1YWNhOGI0ZWVmOTY=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-06-12T22:03:19Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-06-23T20:14:45Z"}, "message": "cmp_owned: reverse operands if necessary", "tree": {"sha": "1bd6a749317bd50891c1be220c6a26c9d6f5066f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bd6a749317bd50891c1be220c6a26c9d6f5066f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b498e1d71537a79e7aff5378da625aca8b4eef96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b498e1d71537a79e7aff5378da625aca8b4eef96", "html_url": "https://github.com/rust-lang/rust/commit/b498e1d71537a79e7aff5378da625aca8b4eef96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b498e1d71537a79e7aff5378da625aca8b4eef96/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5987c7d4041ce5d72c8412d2ad73fe3b63308b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/5987c7d4041ce5d72c8412d2ad73fe3b63308b51", "html_url": "https://github.com/rust-lang/rust/commit/5987c7d4041ce5d72c8412d2ad73fe3b63308b51"}], "stats": {"total": 362, "additions": 282, "deletions": 80}, "files": [{"sha": "76ffe6f6a1c42ca58f10370243fca90498825915", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b498e1d71537a79e7aff5378da625aca8b4eef96/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b498e1d71537a79e7aff5378da625aca8b4eef96/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=b498e1d71537a79e7aff5378da625aca8b4eef96", "patch": "@@ -371,8 +371,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n                 if op.is_comparison() {\n                     check_nan(cx, left, expr);\n                     check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right);\n-                    check_to_owned(cx, right, left);\n+                    check_to_owned(cx, left, right, true);\n+                    check_to_owned(cx, right, left, false);\n                 }\n                 if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n@@ -570,28 +570,38 @@ fn is_array(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     matches!(&walk_ptrs_ty(cx.tables.expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n-fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n-    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'_, 'tcx>, lhs: Ty<'tcx>, rhs: Ty<'tcx>) -> bool {\n-        if let Some(trait_def_id) = cx.tcx.lang_items().eq_trait() {\n-            return implements_trait(cx, lhs, trait_def_id, &[rhs.into()])\n-                && implements_trait(cx, rhs, trait_def_id, &[lhs.into()]);\n+fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    #[derive(Default)]\n+    struct EqImpl {\n+        ty_eq_other: bool,\n+        other_eq_ty: bool,\n+    }\n+\n+    impl EqImpl {\n+        fn is_implemented(&self) -> bool {\n+            self.ty_eq_other || self.other_eq_ty\n         }\n+    }\n \n-        false\n+    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'_, 'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+        })\n     }\n \n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tables.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables.expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -602,24 +612,19 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n         _ => return,\n     };\n \n-    let other_ty = cx.tables.expr_ty_adjusted(other);\n+    let other_ty = cx.tables.expr_ty(other);\n \n-    let deref_arg_impl_partial_eq_other = arg_ty\n-        .builtin_deref(true)\n-        .map_or(false, |tam| symmetric_partial_eq(cx, tam.ty, other_ty));\n-    let arg_impl_partial_eq_deref_other = other_ty\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n         .builtin_deref(true)\n-        .map_or(false, |tam| symmetric_partial_eq(cx, arg_ty, tam.ty));\n-    let arg_impl_partial_eq_other = symmetric_partial_eq(cx, arg_ty, other_ty);\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n \n-    if !deref_arg_impl_partial_eq_other && !arg_impl_partial_eq_deref_other && !arg_impl_partial_eq_other {\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n         return;\n     }\n \n-    let other_gets_derefed = match other.kind {\n-        ExprKind::Unary(UnOp::UnDeref, _) => true,\n-        _ => false,\n-    };\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::UnDeref, _));\n \n     let lint_span = if other_gets_derefed {\n         expr.span.to(other.span)\n@@ -639,18 +644,34 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n                 return;\n             }\n \n-            let try_hint = if deref_arg_impl_partial_eq_other {\n-                // suggest deref on the left\n-                format!(\"*{}\", snip)\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", snip);\n+                eq_impl = with_deref;\n             } else {\n-                // suggest dropping the to_owned on the left\n-                snip.to_string()\n+                expr_snip = snip.to_string();\n+                eq_impl = without_deref;\n             };\n \n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\"{} == {}\", expr_snip, snippet(cx, other.span, \"..\"));\n+                } else {\n+                    hint = format!(\"{} == {}\", snippet(cx, other.span, \"..\"), expr_snip);\n+                }\n+            }\n+\n             diag.span_suggestion(\n-                lint_span,\n+                span,\n                 \"try\",\n-                try_hint,\n+                hint,\n                 Applicability::MachineApplicable, // snippet\n             );\n         },"}, {"sha": "3305ac9bf8b6cb40ec93bc7fadea0ad83b920d4e", "filename": "tests/ui/cmp_owned/asymmetric_partial_eq.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b498e1d71537a79e7aff5378da625aca8b4eef96/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b498e1d71537a79e7aff5378da625aca8b4eef96/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed?ref=b498e1d71537a79e7aff5378da625aca8b4eef96", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == owned {}\n+        if borrowed == owned {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed {}\n+        if owned == borrowed {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == \"Hi\" {}\n+        if borrowed == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "88bc2f51dd6629a8b923f4a1a874ad424764c80f", "filename": "tests/ui/cmp_owned/asymmetric_partial_eq.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b498e1d71537a79e7aff5378da625aca8b4eef96/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b498e1d71537a79e7aff5378da625aca8b4eef96/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs?ref=b498e1d71537a79e7aff5378da625aca8b4eef96", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed.to_owned() == owned {}\n+        if owned == borrowed.to_owned() {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed.to_owned() {}\n+        if borrowed.to_owned() == owned {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if \"Hi\" == borrowed.to_string() {}\n+        if borrowed.to_string() == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "43bf8851fc620d700fe9adcc457f8d88466c2780", "filename": "tests/ui/cmp_owned/asymmetric_partial_eq.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b498e1d71537a79e7aff5378da625aca8b4eef96/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b498e1d71537a79e7aff5378da625aca8b4eef96/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr?ref=b498e1d71537a79e7aff5378da625aca8b4eef96", "patch": "@@ -0,0 +1,46 @@\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:42:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+   |\n+   = note: `-D clippy::cmp-owned` implied by `-D warnings`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:43:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |            ---------^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == owned`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:61:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |                     ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:62:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^---------\n+   |            |\n+   |            help: try: `owned == borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:88:20\n+   |\n+LL |         if \"Hi\" == borrowed.to_string() {}\n+   |            --------^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == \"Hi\"`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:89:12\n+   |\n+LL |         if borrowed.to_string() == \"Hi\" {}\n+   |            ^^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "b29c555eb1e2f1b09f5cb4e3e34ffe15460659bb", "filename": "tests/ui/cmp_owned/issue_4874.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5987c7d4041ce5d72c8412d2ad73fe3b63308b51/tests%2Fui%2Fcmp_owned%2Fissue_4874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5987c7d4041ce5d72c8412d2ad73fe3b63308b51/tests%2Fui%2Fcmp_owned%2Fissue_4874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fissue_4874.rs?ref=5987c7d4041ce5d72c8412d2ad73fe3b63308b51", "patch": "@@ -1,51 +0,0 @@\n-#![allow(clippy::redundant_clone)] // See #5700\n-\n-#[derive(PartialEq)]\n-struct Foo;\n-\n-struct Bar;\n-\n-impl std::fmt::Display for Bar {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"bar\")\n-    }\n-}\n-\n-// NOTE: PartialEq<Bar> for T can't be implemented due to the orphan rules\n-impl<T> PartialEq<T> for Bar\n-where\n-    T: AsRef<str> + ?Sized,\n-{\n-    fn eq(&self, _: &T) -> bool {\n-        true\n-    }\n-}\n-\n-// NOTE: PartialEq<Bar> for Foo is not implemented\n-impl PartialEq<Foo> for Bar {\n-    fn eq(&self, _: &Foo) -> bool {\n-        true\n-    }\n-}\n-\n-impl ToOwned for Bar {\n-    type Owned = Foo;\n-    fn to_owned(&self) -> Foo {\n-        Foo\n-    }\n-}\n-\n-impl std::borrow::Borrow<Bar> for Foo {\n-    fn borrow(&self) -> &Bar {\n-        static BAR: Bar = Bar;\n-        &BAR\n-    }\n-}\n-\n-fn main() {\n-    let b = Bar {};\n-    if \"Hi\" == b.to_string() {}\n-\n-    let f = Foo {};\n-    if f == b.to_owned() {}\n-}"}]}