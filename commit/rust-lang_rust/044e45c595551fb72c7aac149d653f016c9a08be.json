{"sha": "044e45c595551fb72c7aac149d653f016c9a08be", "node_id": "C_kwDOAAsO6NoAKDA0NGU0NWM1OTU1NTFmYjcyYzdhYWMxNDlkNjUzZjAxNmM5YTA4YmU", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-27T19:51:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-30T20:06:48Z"}, "message": "rustdoc: Keep full `ParentScope` during early doc link resolution", "tree": {"sha": "bda37bb184a7d4afc749ba016260850af308a25c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bda37bb184a7d4afc749ba016260850af308a25c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/044e45c595551fb72c7aac149d653f016c9a08be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/044e45c595551fb72c7aac149d653f016c9a08be", "html_url": "https://github.com/rust-lang/rust/commit/044e45c595551fb72c7aac149d653f016c9a08be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/044e45c595551fb72c7aac149d653f016c9a08be/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "921f63fb1f5a56023e6631cd4ab785c476bcd197", "url": "https://api.github.com/repos/rust-lang/rust/commits/921f63fb1f5a56023e6631cd4ab785c476bcd197", "html_url": "https://github.com/rust-lang/rust/commit/921f63fb1f5a56023e6631cd4ab785c476bcd197"}], "stats": {"total": 66, "additions": 36, "deletions": 30}, "files": [{"sha": "6142283e2e1db2b8d93547fcf849ac0da873262c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/044e45c595551fb72c7aac149d653f016c9a08be/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044e45c595551fb72c7aac149d653f016c9a08be/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=044e45c595551fb72c7aac149d653f016c9a08be", "patch": "@@ -143,7 +143,7 @@ enum ScopeSet<'a> {\n /// but not for late resolution yet.\n #[derive(Clone, Copy, Debug)]\n pub struct ParentScope<'a> {\n-    module: Module<'a>,\n+    pub module: Module<'a>,\n     expansion: LocalExpnId,\n     macro_rules: MacroRulesScopeRef<'a>,\n     derives: &'a [ast::Path],\n@@ -1874,25 +1874,25 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         path_str: &str,\n         ns: Namespace,\n-        mut module_id: DefId,\n+        mut parent_scope: ParentScope<'a>,\n     ) -> Option<Res> {\n         let mut segments =\n             Vec::from_iter(path_str.split(\"::\").map(Ident::from_str).map(Segment::from_ident));\n         if let Some(segment) = segments.first_mut() {\n             if segment.ident.name == kw::Crate {\n                 // FIXME: `resolve_path` always resolves `crate` to the current crate root, but\n-                // rustdoc wants it to resolve to the `module_id`'s crate root. This trick of\n+                // rustdoc wants it to resolve to the `parent_scope`'s crate root. This trick of\n                 // replacing `crate` with `self` and changing the current module should achieve\n                 // the same effect.\n                 segment.ident.name = kw::SelfLower;\n-                module_id = module_id.krate.as_def_id();\n+                parent_scope.module =\n+                    self.expect_module(parent_scope.module.def_id().krate.as_def_id());\n             } else if segment.ident.name == kw::Empty {\n                 segment.ident.name = kw::PathRoot;\n             }\n         }\n \n-        let module = self.expect_module(module_id);\n-        match self.maybe_resolve_path(&segments, Some(ns), &ParentScope::module(module, self)) {\n+        match self.maybe_resolve_path(&segments, Some(ns), &parent_scope) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                 Some(path_res.base_res())\n@@ -1904,11 +1904,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    // For rustdoc.\n-    pub fn graph_root(&self) -> Module<'a> {\n-        self.graph_root\n-    }\n-\n     // For rustdoc.\n     pub fn take_all_macro_rules(&mut self) -> FxHashMap<Symbol, Res> {\n         mem::take(&mut self.all_macro_rules)"}, {"sha": "84512fab269232795866b857e4f5cfb505126627", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/044e45c595551fb72c7aac149d653f016c9a08be/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044e45c595551fb72c7aac149d653f016c9a08be/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=044e45c595551fb72c7aac149d653f016c9a08be", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n+use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -564,7 +565,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .copied()\n             .unwrap_or_else(|| {\n                 self.cx.enter_resolver(|resolver| {\n-                    resolver.resolve_rustdoc_path(path_str, ns, module_id)\n+                    let parent_scope =\n+                        ParentScope::module(resolver.expect_module(module_id), resolver);\n+                    resolver.resolve_rustdoc_path(path_str, ns, parent_scope)\n                 })\n             })\n             .and_then(|res| res.try_into().ok())"}, {"sha": "974ef7a537ac4e33b9f9c743d9e258a3cc5525f5", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/044e45c595551fb72c7aac149d653f016c9a08be/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/044e45c595551fb72c7aac149d653f016c9a08be/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=044e45c595551fb72c7aac149d653f016c9a08be", "patch": "@@ -9,7 +9,7 @@ use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, CRATE_DEF_ID};\n use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n@@ -27,10 +27,12 @@ crate fn early_resolve_intra_doc_links(\n     externs: Externs,\n     document_private_items: bool,\n ) -> ResolverCaches {\n+    let parent_scope =\n+        ParentScope::module(resolver.expect_module(CRATE_DEF_ID.to_def_id()), resolver);\n     let mut link_resolver = EarlyDocLinkResolver {\n         resolver,\n         sess,\n-        current_mod: CRATE_DEF_ID,\n+        parent_scope,\n         visited_mods: Default::default(),\n         markdown_links: Default::default(),\n         doc_link_resolutions: Default::default(),\n@@ -52,7 +54,7 @@ crate fn early_resolve_intra_doc_links(\n     // DO NOT REMOVE THIS without first testing on the reproducer in\n     // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n     for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n-        link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, CRATE_DEF_ID.to_def_id());\n+        link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, parent_scope);\n     }\n \n     ResolverCaches {\n@@ -72,7 +74,7 @@ fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes\n struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n     sess: &'r Session,\n-    current_mod: LocalDefId,\n+    parent_scope: ParentScope<'ra>,\n     visited_mods: DefIdSet,\n     markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n     doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n@@ -82,7 +84,7 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     document_private_items: bool,\n }\n \n-impl EarlyDocLinkResolver<'_, '_> {\n+impl<'ra> EarlyDocLinkResolver<'_, 'ra> {\n     fn add_traits_in_scope(&mut self, def_id: DefId) {\n         // Calls to `traits_in_scope` are expensive, so try to avoid them if only possible.\n         // Keys in the `traits_in_scope` cache are always module IDs.\n@@ -205,20 +207,24 @@ impl EarlyDocLinkResolver<'_, '_> {\n         if !attrs.iter().any(|attr| attr.may_have_doc_links()) {\n             return;\n         }\n-        let module_id = self.current_mod.to_def_id();\n-        self.resolve_doc_links(doc_attrs(attrs.iter()), module_id);\n+        self.resolve_doc_links(doc_attrs(attrs.iter()), self.parent_scope);\n     }\n \n-    fn resolve_and_cache(&mut self, path_str: &str, ns: Namespace, module_id: DefId) -> bool {\n+    fn resolve_and_cache(\n+        &mut self,\n+        path_str: &str,\n+        ns: Namespace,\n+        parent_scope: &ParentScope<'ra>,\n+    ) -> bool {\n         self.doc_link_resolutions\n-            .entry((Symbol::intern(path_str), ns, module_id))\n-            .or_insert_with_key(|(path, ns, module_id)| {\n-                self.resolver.resolve_rustdoc_path(path.as_str(), *ns, *module_id)\n+            .entry((Symbol::intern(path_str), ns, parent_scope.module.def_id()))\n+            .or_insert_with_key(|(path, ns, _)| {\n+                self.resolver.resolve_rustdoc_path(path.as_str(), *ns, *parent_scope)\n             })\n             .is_some()\n     }\n \n-    fn resolve_doc_links(&mut self, attrs: Attributes, module_id: DefId) {\n+    fn resolve_doc_links(&mut self, attrs: Attributes, parent_scope: ParentScope<'ra>) {\n         let mut need_traits_in_scope = false;\n         for (doc_module, doc) in attrs.prepare_to_doc_link_resolution() {\n             assert_eq!(doc_module, None);\n@@ -230,7 +236,7 @@ impl EarlyDocLinkResolver<'_, '_> {\n                     // The logic here is a conservative approximation for path resolution in\n                     // `resolve_with_disambiguator`.\n                     if let Some(ns) = pinfo.disambiguator.map(Disambiguator::ns) {\n-                        if self.resolve_and_cache(&pinfo.path_str, ns, module_id) {\n+                        if self.resolve_and_cache(&pinfo.path_str, ns, &parent_scope) {\n                             continue;\n                         }\n                     }\n@@ -239,7 +245,7 @@ impl EarlyDocLinkResolver<'_, '_> {\n                     let mut any_resolved = false;\n                     let mut need_assoc = false;\n                     for ns in [TypeNS, ValueNS, MacroNS] {\n-                        if self.resolve_and_cache(&pinfo.path_str, ns, module_id) {\n+                        if self.resolve_and_cache(&pinfo.path_str, ns, &parent_scope) {\n                             any_resolved = true;\n                         } else if ns != MacroNS {\n                             need_assoc = true;\n@@ -256,7 +262,7 @@ impl EarlyDocLinkResolver<'_, '_> {\n         }\n \n         if need_traits_in_scope {\n-            self.add_traits_in_scope(module_id);\n+            self.add_traits_in_scope(parent_scope.module.def_id());\n         }\n     }\n \n@@ -298,11 +304,13 @@ impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         self.resolve_doc_links_local(&item.attrs); // Outer attribute scope\n         if let ItemKind::Mod(..) = item.kind {\n-            let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n+            let module_def_id = self.resolver.local_def_id(item.id).to_def_id();\n+            let module = self.resolver.expect_module(module_def_id);\n+            let old_module = mem::replace(&mut self.parent_scope.module, module);\n             self.resolve_doc_links_local(&item.attrs); // Inner attribute scope\n-            self.process_module_children_or_reexports(self.current_mod.to_def_id());\n+            self.process_module_children_or_reexports(module_def_id);\n             visit::walk_item(self, item);\n-            self.current_mod = old_mod;\n+            self.parent_scope.module = old_module;\n         } else {\n             match item.kind {\n                 ItemKind::Trait(..) => {"}]}