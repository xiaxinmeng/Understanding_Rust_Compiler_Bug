{"sha": "7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "node_id": "C_kwDOAAsO6NoAKDdiODlkNWVkZTIzY2JiYmY0YmVmMzdiNDNlMGQyZDk5NzUyZGRiNTE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-21T01:42:58Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-22T09:20:40Z"}, "message": "internal: Expand the derive attribute into a pseudo expansion", "tree": {"sha": "fcef1187784c58d763fdbb1d361bd4cfe7955a27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcef1187784c58d763fdbb1d361bd4cfe7955a27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "html_url": "https://github.com/rust-lang/rust/commit/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fe3b2edd68889489d2702507ac0ba22a5126adf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe3b2edd68889489d2702507ac0ba22a5126adf", "html_url": "https://github.com/rust-lang/rust/commit/1fe3b2edd68889489d2702507ac0ba22a5126adf"}], "stats": {"total": 333, "additions": 178, "deletions": 155}, "files": [{"sha": "1156dfe98e15b18a2972bc51da28afa2b544544b", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 26, "deletions": 82, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -5,7 +5,6 @@ mod source_to_def;\n use std::{cell::RefCell, fmt, iter};\n \n use base_db::{FileId, FileRange};\n-use either::Either;\n use hir_def::{\n     body,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n@@ -19,17 +18,16 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{\n     algo::skip_trivia_token,\n     ast::{self, HasAttrs as _, HasGenericParams, HasLoopBody},\n-    match_ast, AstNode, AstToken, Direction, SyntaxElement, SyntaxNode, SyntaxNodePtr, SyntaxToken,\n-    TextSize, T,\n+    match_ast, AstNode, Direction, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n };\n \n use crate::{\n     db::HirDatabase,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n-    Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasAttrs as _,\n-    HasSource, HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef,\n-    Name, Path, ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    Access, AssocItem, BuiltinAttr, Callable, ConstParam, Crate, Field, Function, HasSource,\n+    HirFileId, Impl, InFile, Label, LifetimeParam, Local, MacroDef, Module, ModuleDef, Name, Path,\n+    ScopeDef, ToolModule, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -350,14 +348,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n-    pub fn resolve_derive_ident(\n-        &self,\n-        derive: &ast::Attr,\n-        ident: &ast::Ident,\n-    ) -> Option<PathResolution> {\n-        self.imp.resolve_derive_ident(derive, ident)\n-    }\n-\n     pub fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.imp.record_literal_missing_fields(literal)\n     }\n@@ -475,7 +465,7 @@ impl<'db> SemanticsImpl<'db> {\n         let adt = InFile::new(file_id, &adt);\n         let src = InFile::new(file_id, attr.clone());\n         self.with_ctx(|ctx| {\n-            let (_, res) = ctx.attr_to_derive_macro_call(adt, src)?;\n+            let (.., res) = ctx.attr_to_derive_macro_call(adt, src)?;\n             Some(res.to_vec())\n         })\n     }\n@@ -668,7 +658,27 @@ impl<'db> SemanticsImpl<'db> {\n                     // FIXME replace map.while_some with take_while once stable\n                     token.value.ancestors().map(ast::TokenTree::cast).while_some().last()\n                 {\n-                    let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n+                    let parent = tt.syntax().parent()?;\n+                    // check for derive attribute here\n+                    let macro_call = match_ast! {\n+                        match parent {\n+                            ast::MacroCall(mcall) => mcall,\n+                            // attribute we failed expansion for earlier, this might be a derive invocation\n+                            // so try downmapping the token into the pseudo derive expansion\n+                            ast::Meta(meta) => {\n+                                let attr = meta.parent_attr()?;\n+                                let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+                                let call_id = self.with_ctx(|ctx| {\n+                                    let (_, call_id, _) = ctx.attr_to_derive_macro_call(token.with_value(&adt), token.with_value(attr))?;\n+                                    Some(call_id)\n+                                })?;\n+                                let file_id = call_id.as_file();\n+                                return process_expansion_for_token(&mut stack,file_id,Some(adt.into()),token.as_ref(),);\n+                            },\n+                            _ => return None,\n+                        }\n+                    };\n+\n                     if tt.left_delimiter_token().map_or(false, |it| it == token.value) {\n                         return None;\n                     }\n@@ -898,72 +908,6 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n-    fn resolve_derive_ident(\n-        &self,\n-        derive: &ast::Attr,\n-        ident: &ast::Ident,\n-    ) -> Option<PathResolution> {\n-        debug_assert!(ident.syntax().parent().and_then(ast::TokenTree::cast).is_some());\n-        debug_assert!(ident.syntax().ancestors().any(|anc| anc == *derive.syntax()));\n-        // derive macros are always at depth 2, tokentree -> meta -> attribute\n-        let syntax = ident.syntax();\n-\n-        let tt = derive.token_tree()?;\n-        let file = self.find_file(derive.syntax());\n-        let adt = derive.syntax().parent().and_then(ast::Adt::cast)?;\n-        let adt_def = ToDef::to_def(self, file.with_value(adt.clone()))?;\n-        let res = self.with_ctx(|ctx| {\n-            let (attr_id, derives) = ctx.attr_to_derive_macro_call(\n-                file.with_value(&adt),\n-                file.with_value(derive.clone()),\n-            )?;\n-            let attrs = adt_def.attrs(self.db);\n-            let mut derive_paths = attrs.get(attr_id)?.parse_path_comma_token_tree()?;\n-\n-            let derive_idx = tt\n-                .syntax()\n-                .children_with_tokens()\n-                .filter_map(SyntaxElement::into_token)\n-                .take_while(|tok| tok != syntax)\n-                .filter(|t| t.kind() == T![,])\n-                .count();\n-            let path_segment_idx = syntax\n-                .siblings_with_tokens(Direction::Prev)\n-                .filter_map(SyntaxElement::into_token)\n-                .take_while(|tok| matches!(tok.kind(), T![:] | T![ident]))\n-                .filter(|tok| tok.kind() == T![ident])\n-                .count();\n-\n-            let mut mod_path = derive_paths.nth(derive_idx)?;\n-\n-            if path_segment_idx < mod_path.len() {\n-                // the path for the given ident is a qualifier, resolve to module if possible\n-                while path_segment_idx < mod_path.len() {\n-                    mod_path.pop_segment();\n-                }\n-                Some(Either::Left(mod_path))\n-            } else {\n-                // otherwise fetch the derive\n-                Some(Either::Right(derives[derive_idx]))\n-            }\n-        })?;\n-\n-        match res {\n-            Either::Left(path) => {\n-                let len = path.len();\n-                resolve_hir_path(\n-                    self.db,\n-                    &self.scope(derive.syntax()).resolver,\n-                    &Path::from_known_path(path, vec![None; len]),\n-                )\n-                .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_))))\n-            }\n-            Either::Right(derive) => derive\n-                .map(|call| MacroDef { id: self.db.lookup_intern_macro_call(call).def })\n-                .map(PathResolution::Macro),\n-        }\n-    }\n-\n     fn record_literal_missing_fields(&self, literal: &ast::RecordExpr) -> Vec<(Field, Type)> {\n         self.analyze(literal.syntax())\n             .record_literal_missing_fields(self.db, literal)"}, {"sha": "c0d8e69e492c6b0cf9f496279c2fb0c5bc0a5f3a", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -249,9 +249,11 @@ impl SourceToDefCtx<'_, '_> {\n         &mut self,\n         item: InFile<&ast::Adt>,\n         src: InFile<ast::Attr>,\n-    ) -> Option<(AttrId, &[Option<MacroCallId>])> {\n+    ) -> Option<(AttrId, MacroCallId, &[Option<MacroCallId>])> {\n         let map = self.dyn_map(item)?;\n-        map[keys::DERIVE_MACRO_CALL].get(&src.value).map(|(id, ids)| (*id, &**ids))\n+        map[keys::DERIVE_MACRO_CALL]\n+            .get(&src.value)\n+            .map(|&(attr_id, call_id, ref ids)| (attr_id, call_id, &**ids))\n     }\n \n     fn to_def<Ast: AstNode + 'static, ID: Copy + 'static>("}, {"sha": "ef32a5891c78ea54fca9ff43b5ac17cb9d62f3b6", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -371,10 +371,10 @@ impl SourceAnalyzer {\n                 return builtin.map(PathResolution::BuiltinAttr);\n             }\n             return match resolve_hir_path_as_macro(db, &self.resolver, &hir_path) {\n-                res @ Some(m) if m.is_attr() => res.map(PathResolution::Macro),\n+                Some(m) => Some(PathResolution::Macro(m)),\n                 // this labels any path that starts with a tool module as the tool itself, this is technically wrong\n                 // but there is no benefit in differentiating these two cases for the time being\n-                _ => path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n+                None => path.first_segment().and_then(|it| it.name_ref()).and_then(|name_ref| {\n                     match self.resolver.krate() {\n                         Some(krate) => ToolModule::by_name(db, krate.into(), &name_ref.text()),\n                         None => ToolModule::builtin(&name_ref.text()),"}, {"sha": "1e1573d4ae0977e55e13d30f56b4aa9b41361fc8", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -116,11 +116,11 @@ impl ChildBySource for ItemScope {\n         self.derive_macro_invocs().filter(|(id, _)| id.file_id == file_id).for_each(\n             |(ast_id, calls)| {\n                 let adt = ast_id.to_node(db.upcast());\n-                calls.for_each(|(attr_id, calls)| {\n+                calls.for_each(|(attr_id, call_id, calls)| {\n                     if let Some(Either::Left(attr)) =\n                         adt.doc_comments_and_attrs().nth(attr_id.ast_index as usize)\n                     {\n-                        res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, calls.into()));\n+                        res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, call_id, calls.into()));\n                     }\n                 });\n             },"}, {"sha": "fffec96bab90f388a0d31d028b114e4accc3a866", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -66,8 +66,10 @@ pub struct ItemScope {\n     attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n     /// The derive macro invocations in this scope, keyed by the owner item over the actual derive attributes\n     /// paired with the derive macro invocations for the specific attribute.\n-    derive_macros:\n-        FxHashMap<AstId<ast::Adt>, SmallVec<[(AttrId, SmallVec<[Option<MacroCallId>; 1]>); 1]>>,\n+    derive_macros: FxHashMap<\n+        AstId<ast::Adt>,\n+        SmallVec<[(AttrId, MacroCallId, SmallVec<[Option<MacroCallId>; 1]>); 1]>,\n+    >,\n }\n \n pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n@@ -210,7 +212,7 @@ impl ItemScope {\n         idx: usize,\n     ) {\n         if let Some(derives) = self.derive_macros.get_mut(&adt) {\n-            if let Some((_, invocs)) = derives.iter_mut().find(|&&mut (id, _)| id == attr_id) {\n+            if let Some((.., invocs)) = derives.iter_mut().find(|&&mut (id, ..)| id == attr_id) {\n                 invocs[idx] = Some(call);\n             }\n         }\n@@ -223,19 +225,23 @@ impl ItemScope {\n         &mut self,\n         adt: AstId<ast::Adt>,\n         attr_id: AttrId,\n+        call_id: MacroCallId,\n         len: usize,\n     ) {\n-        self.derive_macros.entry(adt).or_default().push((attr_id, smallvec![None; len]));\n+        self.derive_macros.entry(adt).or_default().push((attr_id, call_id, smallvec![None; len]));\n     }\n \n     pub(crate) fn derive_macro_invocs(\n         &self,\n     ) -> impl Iterator<\n-        Item = (AstId<ast::Adt>, impl Iterator<Item = (AttrId, &[Option<MacroCallId>])>),\n+        Item = (\n+            AstId<ast::Adt>,\n+            impl Iterator<Item = (AttrId, MacroCallId, &[Option<MacroCallId>])>,\n+        ),\n     > + '_ {\n-        self.derive_macros\n-            .iter()\n-            .map(|(k, v)| (*k, v.iter().map(|(attr_id, invocs)| (*attr_id, &**invocs))))\n+        self.derive_macros.iter().map(|(k, v)| {\n+            (*k, v.iter().map(|&(attr_id, call_id, ref invocs)| (attr_id, call_id, &**invocs)))\n+        })\n     }\n \n     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {"}, {"sha": "1c9d99eb7882472fc5df84aab73e7d3e46d36ad1", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -34,7 +34,8 @@ pub const CONST_PARAM: Key<ast::ConstParam, ConstParamId> = Key::new();\n \n pub const MACRO: Key<ast::Macro, MacroDefId> = Key::new();\n pub const ATTR_MACRO_CALL: Key<ast::Item, MacroCallId> = Key::new();\n-pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, Box<[Option<MacroCallId>]>)> = Key::new();\n+pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, MacroCallId, Box<[Option<MacroCallId>]>)> =\n+    Key::new();\n \n /// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n /// equal if they point to exactly the same object."}, {"sha": "bb65d1dec87d4610a1ed49198abf9f187fbfeb71", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -690,9 +690,9 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         };\n \n         macro_call_as_call_id(\n+            db,\n             &AstIdWithPath::new(ast_id.file_id, ast_id.value, path),\n             expands_to,\n-            db,\n             krate,\n             resolver,\n             error_sink,\n@@ -714,9 +714,9 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n }\n \n fn macro_call_as_call_id(\n+    db: &dyn db::DefDatabase,\n     call: &AstIdWithPath<ast::MacroCall>,\n     expand_to: ExpandTo,\n-    db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     error_sink: &mut dyn FnMut(ExpandError),\n@@ -739,10 +739,10 @@ fn macro_call_as_call_id(\n }\n \n fn derive_macro_as_call_id(\n+    db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Adt>,\n     derive_attr: AttrId,\n     derive_pos: u32,\n-    db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n ) -> Result<MacroCallId, UnresolvedMacro> {\n@@ -761,11 +761,12 @@ fn derive_macro_as_call_id(\n }\n \n fn attr_macro_as_call_id(\n+    db: &dyn db::DefDatabase,\n     item_attr: &AstIdWithPath<ast::Item>,\n     macro_attr: &Attr,\n-    db: &dyn db::DefDatabase,\n     krate: CrateId,\n     def: MacroDefId,\n+    is_derive: bool,\n ) -> MacroCallId {\n     let mut arg = match macro_attr.input.as_deref() {\n         Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n@@ -782,6 +783,7 @@ fn attr_macro_as_call_id(\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n             invoc_attr_index: macro_attr.id.ast_index,\n+            is_derive,\n         },\n     );\n     res"}, {"sha": "4c436250db3cba54dec642b33c6409c9d27fb488", "filename": "crates/hir_def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -54,7 +54,7 @@ impl DefMap {\n             None => return Err(UnresolvedMacro { path: ast_id.path.clone() }),\n         };\n \n-        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(&ast_id, attr, db, self.krate, def)))\n+        Ok(ResolvedAttr::Macro(attr_macro_as_call_id(db, &ast_id, attr, self.krate, def, false)))\n     }\n \n     pub(crate) fn is_builtin_or_registered_attr(&self, path: &ModPath) -> bool {"}, {"sha": "9e29f28d982f071f3e78b92ea5cbba5633fcee21", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -1055,9 +1055,9 @@ impl DefCollector<'_> {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     let call_id = macro_call_as_call_id(\n+                        self.db,\n                         ast_id,\n                         *expand_to,\n-                        self.db,\n                         self.def_map.krate,\n                         &resolver,\n                         &mut |_err| (),\n@@ -1070,10 +1070,10 @@ impl DefCollector<'_> {\n                 }\n                 MacroDirectiveKind::Derive { ast_id, derive_attr, derive_pos } => {\n                     let call_id = derive_macro_as_call_id(\n+                        self.db,\n                         ast_id,\n                         *derive_attr,\n                         *derive_pos as u32,\n-                        self.db,\n                         self.def_map.krate,\n                         &resolver,\n                     );\n@@ -1170,9 +1170,17 @@ impl DefCollector<'_> {\n                                     len = idx;\n                                 }\n \n+                                let call_id = attr_macro_as_call_id(\n+                                    self.db,\n+                                    file_ast_id,\n+                                    attr,\n+                                    self.def_map.krate,\n+                                    def,\n+                                    true,\n+                                );\n                                 self.def_map.modules[directive.module_id]\n                                     .scope\n-                                    .init_derive_attribute(ast_id, attr.id, len + 1);\n+                                    .init_derive_attribute(ast_id, attr.id, call_id, len + 1);\n                             }\n                             None => {\n                                 let diag = DefDiagnostic::malformed_derive(\n@@ -1192,8 +1200,14 @@ impl DefCollector<'_> {\n                     }\n \n                     // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n-                    let call_id =\n-                        attr_macro_as_call_id(file_ast_id, attr, self.db, self.def_map.krate, def);\n+                    let call_id = attr_macro_as_call_id(\n+                        self.db,\n+                        file_ast_id,\n+                        attr,\n+                        self.def_map.krate,\n+                        def,\n+                        false,\n+                    );\n                     let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n                     // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n@@ -1310,9 +1324,9 @@ impl DefCollector<'_> {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     let macro_call_as_call_id = macro_call_as_call_id(\n+                        self.db,\n                         ast_id,\n                         *expand_to,\n-                        self.db,\n                         self.def_map.krate,\n                         |path| {\n                             let resolved_res = self.def_map.resolve_path_fp_with_macro(\n@@ -1959,9 +1973,9 @@ impl ModCollector<'_, '_> {\n         // Case 1: try to resolve in legacy scope and expand macro_rules\n         let mut error = None;\n         match macro_call_as_call_id(\n+            self.def_collector.db,\n             &ast_id,\n             mac.expand_to,\n-            self.def_collector.db,\n             self.def_collector.def_map.krate,\n             |path| {\n                 path.as_ident().and_then(|name| {"}, {"sha": "19966245985ac1c45de23cb33a6890e89974e2b3", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -1,9 +1,11 @@\n //! Builtin attributes.\n \n+use itertools::Itertools;\n use syntax::ast;\n \n use crate::{\n-    db::AstDatabase, name, AstId, CrateId, ExpandResult, MacroCallId, MacroDefId, MacroDefKind,\n+    db::AstDatabase, name, AstId, CrateId, ExpandResult, MacroCallId, MacroCallKind, MacroDefId,\n+    MacroDefKind,\n };\n \n macro_rules! register_builtin {\n@@ -53,7 +55,7 @@ register_builtin! {\n     (bench, Bench) => dummy_attr_expand,\n     (cfg_accessible, CfgAccessible) => dummy_attr_expand,\n     (cfg_eval, CfgEval) => dummy_attr_expand,\n-    (derive, Derive) => dummy_attr_expand,\n+    (derive, Derive) => derive_attr_expand,\n     (global_allocator, GlobalAllocator) => dummy_attr_expand,\n     (test, Test) => dummy_attr_expand,\n     (test_case, TestCase) => dummy_attr_expand\n@@ -79,3 +81,76 @@ fn dummy_attr_expand(\n ) -> ExpandResult<tt::Subtree> {\n     ExpandResult::ok(tt.clone())\n }\n+\n+fn derive_attr_expand(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n+    // we generate a very specific expansion here, as we do not actually expand the `#[derive]` attribute\n+    // itself in name res, but we do want to expand it to something for the IDE layer, so that the input\n+    // derive attributes can be downmapped, and resolved\n+    // This is basically a hack, to get rid of hacks in the IDE layer that slowly accumulate more and more\n+    // in various places.\n+\n+    // we transform the token tree of `#[derive(Foo, bar::Bar)]` into\n+    // ```\n+    //  #[Foo]\n+    //  #[bar::Bar]\n+    //  ();\n+    // ```\n+    // which allows fallback path resolution in hir::Semantics to properly identify our derives\n+    let loc = db.lookup_intern_macro_call(id);\n+    let derives = match &loc.kind {\n+        MacroCallKind::Attr { attr_args, .. } => &attr_args.0,\n+        _ => return ExpandResult::ok(tt.clone()),\n+    };\n+\n+    let mut token_trees = Vec::new();\n+    for (comma, group) in &derives\n+        .token_trees\n+        .iter()\n+        .filter_map(|tt| match tt {\n+            tt::TokenTree::Leaf(l) => Some(l),\n+            tt::TokenTree::Subtree(_) => None,\n+        })\n+        .group_by(|l| matches!(l, tt::Leaf::Punct(tt::Punct { char: ',', .. })))\n+    {\n+        if comma {\n+            continue;\n+        }\n+        let wrap = |leaf| tt::TokenTree::Leaf(tt::Leaf::Punct(leaf));\n+        token_trees.push(wrap(tt::Punct {\n+            char: '#',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }));\n+        token_trees.push(wrap(tt::Punct {\n+            char: '[',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }));\n+        token_trees.extend(group.cloned().map(tt::TokenTree::Leaf));\n+        token_trees.push(wrap(tt::Punct {\n+            char: ']',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }));\n+        token_trees.push(wrap(tt::Punct {\n+            char: '(',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }));\n+        token_trees.push(wrap(tt::Punct {\n+            char: ')',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }));\n+        token_trees.push(wrap(tt::Punct {\n+            char: ';',\n+            spacing: tt::Spacing::Alone,\n+            id: tt::TokenId::unspecified(),\n+        }));\n+    }\n+    ExpandResult::ok(tt::Subtree { delimiter: tt.delimiter, token_trees })\n+}"}, {"sha": "d6d33b4cd724f144e336c27e9fb91e67863a4cdc", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -342,6 +342,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                     .map(|it| it.syntax().clone())\n                     .collect()\n             }\n+            MacroCallKind::Attr { is_derive: true, .. } => return None,\n             MacroCallKind::Attr { invoc_attr_index, .. } => {\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?"}, {"sha": "2ccf4c56eebb887667a4a8d77cc15ad39c82f205", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -166,6 +166,7 @@ pub enum MacroCallKind {\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n         invoc_attr_index: u32,\n+        is_derive: bool,\n     },\n }\n \n@@ -431,6 +432,7 @@ impl MacroCallKind {\n         match self {\n             MacroCallKind::FnLike { expand_to, .. } => *expand_to,\n             MacroCallKind::Derive { .. } => ExpandTo::Items,\n+            MacroCallKind::Attr { is_derive: true, .. } => ExpandTo::Statements,\n             MacroCallKind::Attr { .. } => ExpandTo::Items, // is this always correct?\n         }\n     }\n@@ -497,7 +499,7 @@ impl ExpansionInfo {\n \n             let token_range = token.value.text_range();\n             match &loc.kind {\n-                MacroCallKind::Attr { attr_args, invoc_attr_index, .. } => {\n+                MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n                     let attr = item\n                         .doc_comments_and_attrs()\n                         .nth(*invoc_attr_index as usize)\n@@ -511,9 +513,13 @@ impl ExpansionInfo {\n                             let relative_range =\n                                 token.value.text_range().checked_sub(attr_input_start)?;\n                             // shift by the item's tree's max id\n-                            let token_id = self\n-                                .macro_arg_shift\n-                                .shift(attr_args.1.token_by_range(relative_range)?);\n+                            let token_id = attr_args.1.token_by_range(relative_range)?;\n+                            let token_id = if *is_derive {\n+                                // we do not shift for `#[derive]`, as we only need to downmap the derive attribute tokens\n+                                token_id\n+                            } else {\n+                                self.macro_arg_shift.shift(token_id)\n+                            };\n                             Some(token_id)\n                         }\n                         _ => None,"}, {"sha": "a232ebd4fb7cc658414acb16a9e14f564924d260", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -15,6 +15,7 @@ fn check_hover_no_result(ra_fixture: &str) {\n     assert!(hover.is_none(), \"hover not expected but found: {:?}\", hover.unwrap());\n }\n \n+#[track_caller]\n fn check(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis"}, {"sha": "d67f6baff0798003aef2e1c721fd3c8bdcd5674d", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -361,7 +361,7 @@ fn traverse(\n                 syntactic_name_ref_highlighting,\n                 node,\n             ),\n-            NodeOrToken::Token(token) => highlight::token(sema, krate, token).zip(Some(None)),\n+            NodeOrToken::Token(token) => highlight::token(sema, token).zip(Some(None)),\n         };\n         if let Some((mut highlight, binding_hash)) = element {\n             if inside_attribute {"}, {"sha": "85c0c1b286ebb859b08e68ff33ae7ef366442caf", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -18,11 +18,7 @@ use crate::{\n     Highlight, HlMod, HlTag,\n };\n \n-pub(super) fn token(\n-    sema: &Semantics<RootDatabase>,\n-    krate: Option<hir::Crate>,\n-    token: SyntaxToken,\n-) -> Option<Highlight> {\n+pub(super) fn token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Option<Highlight> {\n     if let Some(comment) = ast::Comment::cast(token.clone()) {\n         let h = HlTag::Comment;\n         return Some(match comment.kind().doc {\n@@ -39,17 +35,10 @@ pub(super) fn token(\n         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n         BYTE => HlTag::ByteLiteral.into(),\n         CHAR => HlTag::CharLiteral.into(),\n-        IDENT => {\n-            let tt = ast::TokenTree::cast(token.parent()?)?;\n-            let ident = ast::Ident::cast(token)?;\n+        IDENT if token.parent().and_then(ast::TokenTree::cast).is_some() => {\n             // from this point on we are inside a token tree, this only happens for identifiers\n             // that were not mapped down into macro invocations\n-            (|| {\n-                let attr = tt.parent_meta()?.parent_attr()?;\n-                let res = sema.resolve_derive_ident(&attr, &ident)?;\n-                Some(highlight_def(sema, krate, Definition::from(res)))\n-            })()\n-            .unwrap_or_else(|| HlTag::None.into())\n+            HlTag::None.into()\n         }\n         p if p.is_punct() => punctuation(sema, token, p),\n         k if k.is_keyword() => keyword(sema, token, k)?,"}, {"sha": "0d59f77a55c975d4ac5b4534d91e201feae904c7", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -58,15 +58,15 @@ pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext\n                     (\n                         hir::AssocItem::Function(fn_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Fn,\n-                    ) => add_function_impl(&trigger, acc, ctx, fn_item, hir_impl),\n+                    ) => add_function_impl(acc, ctx, &trigger, fn_item, hir_impl),\n                     (\n                         hir::AssocItem::TypeAlias(type_item),\n                         ImplCompletionKind::All | ImplCompletionKind::TypeAlias,\n-                    ) => add_type_alias_impl(&trigger, acc, ctx, type_item),\n+                    ) => add_type_alias_impl(acc, ctx, &trigger, type_item),\n                     (\n                         hir::AssocItem::Const(const_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Const,\n-                    ) => add_const_impl(&trigger, acc, ctx, const_item, hir_impl),\n+                    ) => add_const_impl(acc, ctx, &trigger, const_item, hir_impl),\n                     _ => {}\n                 }\n             });\n@@ -126,9 +126,9 @@ fn completion_match(mut token: SyntaxToken) -> Option<(ImplCompletionKind, Synta\n }\n \n fn add_function_impl(\n-    fn_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    fn_def_node: &SyntaxNode,\n     func: hir::Function,\n     impl_def: hir::Impl,\n ) {\n@@ -199,9 +199,9 @@ fn get_transformed_assoc_item(\n }\n \n fn add_type_alias_impl(\n-    type_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    type_def_node: &SyntaxNode,\n     type_alias: hir::TypeAlias,\n ) {\n     let alias_name = type_alias.name(ctx.db).to_smol_str();\n@@ -217,9 +217,9 @@ fn add_type_alias_impl(\n }\n \n fn add_const_impl(\n-    const_def_node: &SyntaxNode,\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n+    const_def_node: &SyntaxNode,\n     const_: hir::Const,\n     impl_def: hir::Impl,\n ) {"}, {"sha": "08104efcdc2fff566163213ba377e6cc00944ba8", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=7b89d5ede23cbbbf4bef37b43e0d2d99752ddb51", "patch": "@@ -14,7 +14,7 @@ use hir::{\n use stdx::impl_from;\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, AstToken, SyntaxKind, SyntaxNode, SyntaxToken,\n+    match_ast, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -142,16 +142,6 @@ impl IdentClass {\n         token: &SyntaxToken,\n     ) -> Option<IdentClass> {\n         let parent = token.parent()?;\n-        // resolve derives if possible\n-        if let Some(ident) = ast::Ident::cast(token.clone()) {\n-            let attr = ast::TokenTree::cast(parent.clone())\n-                .and_then(|tt| tt.parent_meta())\n-                .and_then(|meta| meta.parent_attr());\n-            if let Some(attr) = attr {\n-                return NameRefClass::classify_derive(sema, &attr, &ident)\n-                    .map(IdentClass::NameRefClass);\n-            }\n-        }\n         Self::classify_node(sema, &parent)\n     }\n \n@@ -461,14 +451,6 @@ impl NameRefClass {\n             _ => None,\n         }\n     }\n-\n-    pub fn classify_derive(\n-        sema: &Semantics<RootDatabase>,\n-        attr: &ast::Attr,\n-        ident: &ast::Ident,\n-    ) -> Option<NameRefClass> {\n-        sema.resolve_derive_ident(&attr, &ident).map(Definition::from).map(NameRefClass::Definition)\n-    }\n }\n \n impl_from!("}]}