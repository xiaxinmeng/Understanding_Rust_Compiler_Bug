{"sha": "221cce915a4dfae69ca42536215a5b0c0538047e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMWNjZTkxNWE0ZGZhZTY5Y2E0MjUzNjIxNWE1YjBjMDUzODA0N2U=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T13:01:48Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T13:01:48Z"}, "message": "move the `tcx` and `mir` parts of associated `Ctxt` onto each `BitDenotation` impl.", "tree": {"sha": "b1f45d5ed27462652d7bb531ebc62ed1f4e19930", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1f45d5ed27462652d7bb531ebc62ed1f4e19930"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/221cce915a4dfae69ca42536215a5b0c0538047e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/221cce915a4dfae69ca42536215a5b0c0538047e", "html_url": "https://github.com/rust-lang/rust/commit/221cce915a4dfae69ca42536215a5b0c0538047e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/221cce915a4dfae69ca42536215a5b0c0538047e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985", "html_url": "https://github.com/rust-lang/rust/commit/ae09c5e36e3f6da1d20a9764e87ff2a18b3a2985"}], "stats": {"total": 156, "additions": 77, "deletions": 79}, "files": [{"sha": "480b890da6ad345ae52e9f75a6200b876c5738ce", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/221cce915a4dfae69ca42536215a5b0c0538047e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221cce915a4dfae69ca42536215a5b0c0538047e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=221cce915a4dfae69ca42536215a5b0c0538047e", "patch": "@@ -24,23 +24,9 @@ use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use bitslice::{BitwiseOperator};\n use indexed_set::{Idx, IdxSet};\n \n-use std::marker::PhantomData;\n-\n // Dataflow analyses are built upon some interpretation of the\n // bitvectors attached to each basic block, represented via a\n // zero-sized structure.\n-//\n-// Note on PhantomData: Each interpretation will need to instantiate\n-// the `Bit` and `Ctxt` associated types, and in this case, those\n-// associated types need an associated lifetime `'tcx`. The\n-// interpretive structures are zero-sized, so they all need to carry a\n-// `PhantomData` representing how the structures relate to the `'tcx`\n-// lifetime.\n-//\n-// But, since all of the uses of `'tcx` are solely via instances of\n-// `Ctxt` that are passed into the `BitDenotation` methods, we can\n-// consistently use a `PhantomData` that is just a function over a\n-// `&Ctxt` (== `&MoveData<'tcx>).\n \n /// `MaybeInitializedLvals` tracks all l-values that might be\n /// initialized upon reaching a particular point in the control flow\n@@ -77,10 +63,15 @@ use std::marker::PhantomData;\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeUninitializedLvals` yields the set of\n /// l-values that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> MaybeInitializedLvals<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        MaybeInitializedLvals { tcx: tcx, mir: mir }\n+    }\n }\n \n /// `MaybeUninitializedLvals` tracks all l-values that might be\n@@ -118,10 +109,15 @@ pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n /// Similarly, at a given `drop` statement, the set-intersection\n /// between this data and `MaybeInitializedLvals` yields the set of\n /// l-values that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> MaybeUninitializedLvals<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        MaybeUninitializedLvals { tcx: tcx, mir: mir }\n+    }\n }\n \n /// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n@@ -165,10 +161,15 @@ pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n /// Similarly, at a given `drop` statement, the set-difference between\n /// this data and `MaybeInitializedLvals` yields the set of l-values\n /// that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        DefinitelyInitializedLvals { tcx: tcx, mir: mir }\n+    }\n }\n \n /// `MovingOutStatements` tracks the statements that perform moves out\n@@ -184,10 +185,10 @@ pub struct DefinitelyInitializedLvals<'a, 'tcx: 'a> {\n /// control flow. But `MovingOutStatements` also includes the added\n /// data of *which* particular statement causing the deinitialization\n /// that the borrow checker's error meessage may need to report.\n-#[derive(Debug, Default)]\n+#[allow(dead_code)]\n pub struct MovingOutStatements<'a, 'tcx: 'a> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n }\n \n impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n@@ -226,18 +227,18 @@ impl<'a, 'tcx> DefinitelyInitializedLvals<'a, 'tcx> {\n impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     type Idx = MovePathIndex;\n     type Bit = MovePath<'tcx>;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    type Ctxt = MoveData<'tcx>;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.move_paths.len()\n+        ctxt.move_paths.len()\n     }\n     fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+        &ctxt.move_paths[MovePathIndex::new(idx)]\n     }\n     fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>)\n     {\n         drop_flag_effects_for_function_entry(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 sets.on_entry.add(&path);\n@@ -251,7 +252,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             Location { block: bb, index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -264,7 +265,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             Location { block: bb, index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -278,9 +279,8 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_data = &ctxt.2;\n-        let move_path_index = move_data.rev_lookup.find(dest_lval);\n-        on_all_children_bits(ctxt.0, ctxt.1, &ctxt.2,\n+        let move_path_index = ctxt.rev_lookup.find(dest_lval);\n+        on_all_children_bits(self.tcx, self.mir, ctxt,\n                              move_path_index,\n                              |mpi| { in_out.add(&mpi); });\n     }\n@@ -289,13 +289,13 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     type Idx = MovePathIndex;\n     type Bit = MovePath<'tcx>;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    type Ctxt = MoveData<'tcx>;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.move_paths.len()\n+        ctxt.move_paths.len()\n     }\n     fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+        &ctxt.move_paths[MovePathIndex::new(idx)]\n     }\n \n     // sets on_entry bits for Arg lvalues\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n         for e in sets.on_entry.words_mut() { *e = !0; }\n \n         drop_flag_effects_for_function_entry(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 sets.on_entry.remove(&path);\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             Location { block: bb, index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -331,7 +331,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             Location { block: bb, index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -345,8 +345,8 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n-        on_all_children_bits(ctxt.0, ctxt.1, &ctxt.2,\n+        let move_path_index = ctxt.rev_lookup.find(dest_lval);\n+        on_all_children_bits(self.tcx, self.mir, ctxt,\n                              move_path_index,\n                              |mpi| { in_out.remove(&mpi); });\n     }\n@@ -355,21 +355,21 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     type Idx = MovePathIndex;\n     type Bit = MovePath<'tcx>;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    type Ctxt = MoveData<'tcx>;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.move_paths.len()\n+        ctxt.move_paths.len()\n     }\n     fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+        &ctxt.move_paths[MovePathIndex::new(idx)]\n     }\n \n     // sets on_entry bits for Arg lvalues\n     fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets<MovePathIndex>) {\n         for e in sets.on_entry.words_mut() { *e = 0; }\n \n         drop_flag_effects_for_function_entry(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 sets.on_entry.add(&path);\n@@ -383,7 +383,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n                         idx: usize)\n     {\n         drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             Location { block: bb, index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -396,7 +396,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n                          statements_len: usize)\n     {\n         drop_flag_effects_for_location(\n-            ctxt.0, ctxt.1, &ctxt.2,\n+            self.tcx, self.mir, ctxt,\n             Location { block: bb, index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -410,8 +410,8 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n                              dest_lval: &repr::Lvalue) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_lval to 1 (initialized).\n-        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n-        on_all_children_bits(ctxt.0, ctxt.1, &ctxt.2,\n+        let move_path_index = ctxt.rev_lookup.find(dest_lval);\n+        on_all_children_bits(self.tcx, self.mir, ctxt,\n                              move_path_index,\n                              |mpi| { in_out.add(&mpi); });\n     }\n@@ -420,13 +420,13 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n     type Idx = MoveOutIndex;\n     type Bit = MoveOut;\n-    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    type Ctxt = MoveData<'tcx>;\n     fn name() -> &'static str { \"moving_out\" }\n     fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n-        ctxt.2.moves.len()\n+        ctxt.moves.len()\n     }\n     fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n-        &ctxt.2.moves[idx]\n+        &ctxt.moves[idx]\n     }\n     fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets<MoveOutIndex>) {\n         // no move-statements have been executed prior to function\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                         sets: &mut BlockSets<MoveOutIndex>,\n                         bb: repr::BasicBlock,\n                         idx: usize) {\n-        let &(tcx, mir, ref move_data) = ctxt;\n+        let (tcx, mir, move_data) = (self.tcx, self.mir, ctxt);\n         let stmt = &mir.basic_block_data(bb).statements[idx];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n@@ -477,7 +477,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                          bb: repr::BasicBlock,\n                          statements_len: usize)\n     {\n-        let &(_tcx, mir, ref move_data) = ctxt;\n+        let (mir, move_data) = (self.mir, ctxt);\n         let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n         let loc_map = &move_data.loc_map;\n         let loc = Location { block: bb, index: statements_len };\n@@ -496,13 +496,13 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                              _call_bb: repr::BasicBlock,\n                              _dest_bb: repr::BasicBlock,\n                              dest_lval: &repr::Lvalue) {\n-        let move_data = &ctxt.2;\n+        let move_data = ctxt;\n         let move_path_index = move_data.rev_lookup.find(dest_lval);\n         let bits_per_block = self.bits_per_block(ctxt);\n \n         let path_map = &move_data.path_map;\n-        on_all_children_bits(ctxt.0,\n-                             ctxt.1,\n+        on_all_children_bits(self.tcx,\n+                             self.mir,\n                              move_data,\n                              move_path_index,\n                              |mpi| for moi in &path_map[mpi] {"}, {"sha": "e1470e62840da264de11c58f54a779f3f0a5e1b3", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/221cce915a4dfae69ca42536215a5b0c0538047e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221cce915a4dfae69ca42536215a5b0c0538047e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=221cce915a4dfae69ca42536215a5b0c0538047e", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx: 'a, BD> Dataflow for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n }\n \n struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O>\n-    where O: 'b + BitDenotation, O::Ctxt: HasMoveData<'tcx>\n+    where O: 'b + BitDenotation, O::Ctxt: 'a+HasMoveData<'tcx>\n {\n     builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n     changed: bool,\n@@ -191,18 +191,18 @@ impl<'tcx, A, B> HasMoveData<'tcx> for (A, B, MoveData<'tcx>) {\n }\n \n pub struct DataflowAnalysis<'a, 'tcx: 'a, O>\n-    where O: BitDenotation, O::Ctxt: HasMoveData<'tcx>\n+    where O: BitDenotation, O::Ctxt: 'a+HasMoveData<'tcx>\n {\n     flow_state: DataflowState<O>,\n-    ctxt: O::Ctxt,\n     mir: &'a Mir<'tcx>,\n+    ctxt: &'a O::Ctxt,\n }\n \n impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n     where O: BitDenotation, O::Ctxt: HasMoveData<'tcx>\n {\n-    pub fn results(self) -> (O::Ctxt, DataflowResults<O>) {\n-        (self.ctxt, DataflowResults(self.flow_state))\n+    pub fn results(self) -> DataflowResults<O> {\n+        DataflowResults(self.flow_state)\n     }\n \n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n@@ -440,7 +440,7 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n {\n     pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               ctxt: D::Ctxt,\n+               ctxt: &'a D::Ctxt,\n                denotation: D) -> Self {\n         let bits_per_block = denotation.bits_per_block(&ctxt);\n         let usize_bits = mem::size_of::<usize>() * 8;"}, {"sha": "54132cf0258da67d9bf8b97191594e7b9baa6e48", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/221cce915a4dfae69ca42536215a5b0c0538047e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/221cce915a4dfae69ca42536215a5b0c0538047e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=221cce915a4dfae69ca42536215a5b0c0538047e", "patch": "@@ -75,24 +75,22 @@ pub fn borrowck_mir<'a, 'tcx: 'a>(\n     let tcx = bcx.tcx;\n \n     let move_data = MoveData::gather_moves(mir, tcx);\n-    let ctxt = (tcx, mir, move_data);\n-    let (ctxt, flow_inits) =\n-        do_dataflow(tcx, mir, id, attributes, ctxt, MaybeInitializedLvals::default());\n-    let (ctxt, flow_uninits) =\n-        do_dataflow(tcx, mir, id, attributes, ctxt, MaybeUninitializedLvals::default());\n-    let (ctxt, flow_def_inits) =\n-        do_dataflow(tcx, mir, id, attributes, ctxt, DefinitelyInitializedLvals::default());\n+    let flow_inits =\n+        do_dataflow(tcx, mir, id, attributes, &move_data, MaybeInitializedLvals::new(tcx, mir));\n+    let flow_uninits =\n+        do_dataflow(tcx, mir, id, attributes, &move_data, MaybeUninitializedLvals::new(tcx, mir));\n+    let flow_def_inits =\n+        do_dataflow(tcx, mir, id, attributes, &move_data, DefinitelyInitializedLvals::new(tcx, mir));\n \n     if has_rustc_mir_with(attributes, \"rustc_peek_maybe_init\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_inits);\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &move_data, &flow_inits);\n     }\n     if has_rustc_mir_with(attributes, \"rustc_peek_maybe_uninit\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_uninits);\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &move_data, &flow_uninits);\n     }\n     if has_rustc_mir_with(attributes, \"rustc_peek_definite_init\").is_some() {\n-        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &ctxt, &flow_def_inits);\n+        dataflow::sanity_check_via_rustc_peek(bcx.tcx, mir, id, attributes, &move_data, &flow_def_inits);\n     }\n-    let move_data = ctxt.2;\n \n     if has_rustc_mir_with(attributes, \"stop_after_dataflow\").is_some() {\n         bcx.tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n@@ -118,8 +116,8 @@ fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              mir: &Mir<'tcx>,\n                              node_id: ast::NodeId,\n                              attributes: &[ast::Attribute],\n-                             ctxt: BD::Ctxt,\n-                             bd: BD) -> (BD::Ctxt, DataflowResults<BD>)\n+                             ctxt: &BD::Ctxt,\n+                             bd: BD) -> DataflowResults<BD>\n     where BD: BitDenotation + DataflowOperator, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n {\n     use syntax::attr::AttrMetaMethods;\n@@ -156,7 +154,7 @@ fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n \n pub struct MirBorrowckCtxtPreDataflow<'a, 'tcx: 'a, BD>\n-    where BD: BitDenotation, BD::Ctxt: HasMoveData<'tcx>\n+    where BD: BitDenotation, BD::Ctxt: 'a+HasMoveData<'tcx>\n {\n     node_id: ast::NodeId,\n     flow_state: DataflowAnalysis<'a, 'tcx, BD>,"}]}